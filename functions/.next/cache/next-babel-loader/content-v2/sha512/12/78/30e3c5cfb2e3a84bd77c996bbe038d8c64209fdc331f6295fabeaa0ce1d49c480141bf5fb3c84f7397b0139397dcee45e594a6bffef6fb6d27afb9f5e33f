{"ast":null,"code":"// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  if (req.method !== \"POST\") return res.status(405).json({\n    error: \"Method not allowed\"\n  });\n\n  try {\n    const {\n      listKey,\n      title,\n      linkUrl,\n      bodyText\n    } = req.body; // Add \"tasks\" to your map\n\n    const LIST_IDS = {\n      receiving: process.env.SLACK_LIST_RECEIVING_ID,\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\n      tasks: process.env.SLACK_LIST_TASKS_ID // <= NEW\n\n    };\n    const list_id = LIST_IDS[listKey];\n    if (!list_id) return res.status(400).json({\n      error: \"Unknown listKey\"\n    });\n    const token = process.env.SLACK_BOT_TOKEN;\n    if (!token) return res.status(500).json({\n      error: \"Missing bot token\"\n    }); // Try to discover a rich_text primary column if you didn’t hardcode one\n\n    let primaryColumnId = process.env[`SLACK_LIST_${listKey.toUpperCase()}_PRIMARY_COL`];\n\n    if (!primaryColumnId) {\n      var _probe$items, _probe$items$0$fields;\n\n      const probe = await fetch(\"https://slack.com/api/slackLists.items.list\", {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`\n        },\n        body: new URLSearchParams({\n          list_id,\n          limit: \"1\"\n        })\n      }).then(r => r.json());\n\n      if (probe !== null && probe !== void 0 && probe.ok && probe !== null && probe !== void 0 && (_probe$items = probe.items) !== null && _probe$items !== void 0 && _probe$items.length && (_probe$items$0$fields = probe.items[0].fields) !== null && _probe$items$0$fields !== void 0 && _probe$items$0$fields.length) {\n        const rt = probe.items[0].fields.find(f => Array.isArray(f.rich_text));\n        if (rt !== null && rt !== void 0 && rt.column_id) primaryColumnId = rt.column_id;\n      }\n    }\n\n    if (!primaryColumnId) {\n      return res.status(500).json({\n        error: \"Could not determine primary column id. Configure SLACK_LIST_*_PRIMARY_COL.\"\n      });\n    } // Build rich_text from either (A) a multi-line bodyText (Tasks style) or (B) simple title + link\n\n\n    const makeSectionsFromLines = lines => lines.map(line => ({\n      type: \"rich_text_section\",\n      elements: [{\n        type: \"text\",\n        text: line\n      }]\n    }));\n\n    let elements;\n\n    if (bodyText && bodyText.trim()) {\n      const lines = bodyText.replace(/\\r\\n/g, \"\\n\").split(\"\\n\").map(s => s.trim()).filter(Boolean);\n      elements = makeSectionsFromLines(lines);\n    } else {\n      elements = [{\n        type: \"rich_text_section\",\n        elements: [{\n          type: \"text\",\n          text: title || \"Untitled item\"\n        }]\n      }];\n\n      if (linkUrl) {\n        elements.push({\n          type: \"rich_text_section\",\n          elements: [{\n            type: \"link\",\n            url: linkUrl,\n            text: \"Open in Magmo\"\n          }]\n        });\n      }\n    }\n\n    const payload = {\n      list_id,\n      initial_fields: [{\n        column_id: primaryColumnId,\n        rich_text: [{\n          type: \"rich_text\",\n          elements\n        }]\n      }]\n    };\n    const resp = await fetch(\"https://slack.com/api/slackLists.items.create\", {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${token}`,\n        \"Content-Type\": \"application/json; charset=utf-8\"\n      },\n      body: JSON.stringify(payload)\n    }).then(r => r.json());\n    if (!resp.ok) return res.status(400).json({\n      error: resp.error || \"Slack API error\",\n      raw: resp\n    });\n    return res.status(200).json({\n      ok: true,\n      item: resp.item\n    });\n  } catch (e) {\n    console.error(e);\n    return res.status(500).json({\n      error: \"Server error\"\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","error","listKey","title","linkUrl","bodyText","body","LIST_IDS","receiving","process","env","SLACK_LIST_RECEIVING_ID","shipping","SLACK_LIST_SHIPPING_ID","tasks","SLACK_LIST_TASKS_ID","list_id","token","SLACK_BOT_TOKEN","primaryColumnId","toUpperCase","probe","fetch","headers","Authorization","URLSearchParams","limit","then","r","ok","items","length","fields","rt","find","f","Array","isArray","rich_text","column_id","makeSectionsFromLines","lines","map","line","type","elements","text","trim","replace","split","s","filter","Boolean","push","url","payload","initial_fields","resp","JSON","stringify","raw","item","e","console"],"mappings":"AAAA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B,OAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,IAAAA,KAAK,EAAE;AAAT,GAArB,CAAP;;AAE3B,MAAI;AACF,UAAM;AAAEC,MAAAA,OAAF;AAAWC,MAAAA,KAAX;AAAkBC,MAAAA,OAAlB;AAA2BC,MAAAA;AAA3B,QAAwCT,GAAG,CAACU,IAAlD,CADE,CAGF;;AACA,UAAMC,QAAQ,GAAG;AACfC,MAAAA,SAAS,EAAEC,OAAO,CAACC,GAAR,CAAYC,uBADR;AAEfC,MAAAA,QAAQ,EAAGH,OAAO,CAACC,GAAR,CAAYG,sBAFR;AAGfC,MAAAA,KAAK,EAAML,OAAO,CAACC,GAAR,CAAYK,mBAHR,CAG6B;;AAH7B,KAAjB;AAMA,UAAMC,OAAO,GAAGT,QAAQ,CAACL,OAAD,CAAxB;AACA,QAAI,CAACc,OAAL,EAAc,OAAOnB,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAArB,CAAP;AAEd,UAAMgB,KAAK,GAAGR,OAAO,CAACC,GAAR,CAAYQ,eAA1B;AACA,QAAI,CAACD,KAAL,EAAY,OAAOpB,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAArB,CAAP,CAdV,CAgBF;;AACA,QAAIkB,eAAe,GAAGV,OAAO,CAACC,GAAR,CAAa,cAAaR,OAAO,CAACkB,WAAR,EAAsB,cAAhD,CAAtB;;AACA,QAAI,CAACD,eAAL,EAAsB;AAAA;;AACpB,YAAME,KAAK,GAAG,MAAMC,KAAK,CAAC,6CAAD,EAAgD;AACvExB,QAAAA,MAAM,EAAE,MAD+D;AAEvEyB,QAAAA,OAAO,EAAE;AAAEC,UAAAA,aAAa,EAAG,UAASP,KAAM;AAAjC,SAF8D;AAGvEX,QAAAA,IAAI,EAAE,IAAImB,eAAJ,CAAoB;AAAET,UAAAA,OAAF;AAAWU,UAAAA,KAAK,EAAE;AAAlB,SAApB;AAHiE,OAAhD,CAAL,CAIjBC,IAJiB,CAIZC,CAAC,IAAIA,CAAC,CAAC5B,IAAF,EAJO,CAApB;;AAMA,UAAIqB,KAAK,SAAL,IAAAA,KAAK,WAAL,IAAAA,KAAK,CAAEQ,EAAP,IAAaR,KAAb,aAAaA,KAAb,+BAAaA,KAAK,CAAES,KAApB,yCAAa,aAAcC,MAA3B,6BAAqCV,KAAK,CAACS,KAAN,CAAY,CAAZ,EAAeE,MAApD,kDAAqC,sBAAuBD,MAAhE,EAAwE;AACtE,cAAME,EAAE,GAAGZ,KAAK,CAACS,KAAN,CAAY,CAAZ,EAAeE,MAAf,CAAsBE,IAAtB,CAA2BC,CAAC,IAAIC,KAAK,CAACC,OAAN,CAAcF,CAAC,CAACG,SAAhB,CAAhC,CAAX;AACA,YAAIL,EAAJ,aAAIA,EAAJ,eAAIA,EAAE,CAAEM,SAAR,EAAmBpB,eAAe,GAAGc,EAAE,CAACM,SAArB;AACpB;AACF;;AACD,QAAI,CAACpB,eAAL,EAAsB;AACpB,aAAOtB,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,KAAK,EAAE;AAAT,OAArB,CAAP;AACD,KAhCC,CAkCF;;;AACA,UAAMuC,qBAAqB,GAAIC,KAAD,IAC5BA,KAAK,CAACC,GAAN,CAAUC,IAAI,KAAK;AACjBC,MAAAA,IAAI,EAAE,mBADW;AAEjBC,MAAAA,QAAQ,EAAE,CAAC;AAAED,QAAAA,IAAI,EAAE,MAAR;AAAgBE,QAAAA,IAAI,EAAEH;AAAtB,OAAD;AAFO,KAAL,CAAd,CADF;;AAMA,QAAIE,QAAJ;;AACA,QAAIxC,QAAQ,IAAIA,QAAQ,CAAC0C,IAAT,EAAhB,EAAiC;AAC/B,YAAMN,KAAK,GAAGpC,QAAQ,CAAC2C,OAAT,CAAiB,OAAjB,EAA0B,IAA1B,EAAgCC,KAAhC,CAAsC,IAAtC,EAA4CP,GAA5C,CAAgDQ,CAAC,IAAIA,CAAC,CAACH,IAAF,EAArD,EAA+DI,MAA/D,CAAsEC,OAAtE,CAAd;AACAP,MAAAA,QAAQ,GAAGL,qBAAqB,CAACC,KAAD,CAAhC;AACD,KAHD,MAGO;AACLI,MAAAA,QAAQ,GAAG,CAAC;AACVD,QAAAA,IAAI,EAAE,mBADI;AAEVC,QAAAA,QAAQ,EAAE,CAAC;AAAED,UAAAA,IAAI,EAAE,MAAR;AAAgBE,UAAAA,IAAI,EAAE3C,KAAK,IAAI;AAA/B,SAAD;AAFA,OAAD,CAAX;;AAIA,UAAIC,OAAJ,EAAa;AACXyC,QAAAA,QAAQ,CAACQ,IAAT,CAAc;AACZT,UAAAA,IAAI,EAAE,mBADM;AAEZC,UAAAA,QAAQ,EAAE,CAAC;AAAED,YAAAA,IAAI,EAAE,MAAR;AAAgBU,YAAAA,GAAG,EAAElD,OAArB;AAA8B0C,YAAAA,IAAI,EAAE;AAApC,WAAD;AAFE,SAAd;AAID;AACF;;AAED,UAAMS,OAAO,GAAG;AACdvC,MAAAA,OADc;AAEdwC,MAAAA,cAAc,EAAE,CACd;AACEjB,QAAAA,SAAS,EAAEpB,eADb;AAEEmB,QAAAA,SAAS,EAAE,CAAC;AAAEM,UAAAA,IAAI,EAAE,WAAR;AAAqBC,UAAAA;AAArB,SAAD;AAFb,OADc;AAFF,KAAhB;AAUA,UAAMY,IAAI,GAAG,MAAMnC,KAAK,CAAC,+CAAD,EAAkD;AACxExB,MAAAA,MAAM,EAAE,MADgE;AAExEyB,MAAAA,OAAO,EAAE;AACPC,QAAAA,aAAa,EAAG,UAASP,KAAM,EADxB;AAEP,wBAAgB;AAFT,OAF+D;AAMxEX,MAAAA,IAAI,EAAEoD,IAAI,CAACC,SAAL,CAAeJ,OAAf;AANkE,KAAlD,CAAL,CAOhB5B,IAPgB,CAOXC,CAAC,IAAIA,CAAC,CAAC5B,IAAF,EAPM,CAAnB;AASA,QAAI,CAACyD,IAAI,CAAC5B,EAAV,EAAc,OAAOhC,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,KAAK,EAAEwD,IAAI,CAACxD,KAAL,IAAc,iBAAvB;AAA0C2D,MAAAA,GAAG,EAAEH;AAA/C,KAArB,CAAP;AACd,WAAO5D,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAE6B,MAAAA,EAAE,EAAE,IAAN;AAAYgC,MAAAA,IAAI,EAAEJ,IAAI,CAACI;AAAvB,KAArB,CAAP;AACD,GA/ED,CA+EE,OAAOC,CAAP,EAAU;AACVC,IAAAA,OAAO,CAAC9D,KAAR,CAAc6D,CAAd;AACA,WAAOjE,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAArB,CAAP;AACD;AACF","sourcesContent":["// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\r\n\r\n  try {\r\n    const { listKey, title, linkUrl, bodyText } = req.body;\r\n\r\n    // Add \"tasks\" to your map\r\n    const LIST_IDS = {\r\n      receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n      shipping:  process.env.SLACK_LIST_SHIPPING_ID,\r\n      tasks:     process.env.SLACK_LIST_TASKS_ID, // <= NEW\r\n    };\r\n\r\n    const list_id = LIST_IDS[listKey];\r\n    if (!list_id) return res.status(400).json({ error: \"Unknown listKey\" });\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) return res.status(500).json({ error: \"Missing bot token\" });\r\n\r\n    // Try to discover a rich_text primary column if you didn’t hardcode one\r\n    let primaryColumnId = process.env[`SLACK_LIST_${listKey.toUpperCase()}_PRIMARY_COL`];\r\n    if (!primaryColumnId) {\r\n      const probe = await fetch(\"https://slack.com/api/slackLists.items.list\", {\r\n        method: \"POST\",\r\n        headers: { Authorization: `Bearer ${token}` },\r\n        body: new URLSearchParams({ list_id, limit: \"1\" }),\r\n      }).then(r => r.json());\r\n\r\n      if (probe?.ok && probe?.items?.length && probe.items[0].fields?.length) {\r\n        const rt = probe.items[0].fields.find(f => Array.isArray(f.rich_text));\r\n        if (rt?.column_id) primaryColumnId = rt.column_id;\r\n      }\r\n    }\r\n    if (!primaryColumnId) {\r\n      return res.status(500).json({ error: \"Could not determine primary column id. Configure SLACK_LIST_*_PRIMARY_COL.\" });\r\n    }\r\n\r\n    // Build rich_text from either (A) a multi-line bodyText (Tasks style) or (B) simple title + link\r\n    const makeSectionsFromLines = (lines) =>\r\n      lines.map(line => ({\r\n        type: \"rich_text_section\",\r\n        elements: [{ type: \"text\", text: line }],\r\n      }));\r\n\r\n    let elements;\r\n    if (bodyText && bodyText.trim()) {\r\n      const lines = bodyText.replace(/\\r\\n/g, \"\\n\").split(\"\\n\").map(s => s.trim()).filter(Boolean);\r\n      elements = makeSectionsFromLines(lines);\r\n    } else {\r\n      elements = [{\r\n        type: \"rich_text_section\",\r\n        elements: [{ type: \"text\", text: title || \"Untitled item\" }],\r\n      }];\r\n      if (linkUrl) {\r\n        elements.push({\r\n          type: \"rich_text_section\",\r\n          elements: [{ type: \"link\", url: linkUrl, text: \"Open in Magmo\" }],\r\n        });\r\n      }\r\n    }\r\n\r\n    const payload = {\r\n      list_id,\r\n      initial_fields: [\r\n        {\r\n          column_id: primaryColumnId,\r\n          rich_text: [{ type: \"rich_text\", elements }],\r\n        },\r\n      ],\r\n    };\r\n\r\n    const resp = await fetch(\"https://slack.com/api/slackLists.items.create\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        Authorization: `Bearer ${token}`,\r\n        \"Content-Type\": \"application/json; charset=utf-8\",\r\n      },\r\n      body: JSON.stringify(payload),\r\n    }).then(r => r.json());\r\n\r\n    if (!resp.ok) return res.status(400).json({ error: resp.error || \"Slack API error\", raw: resp });\r\n    return res.status(200).json({ ok: true, item: resp.item });\r\n  } catch (e) {\r\n    console.error(e);\r\n    return res.status(500).json({ error: \"Server error\" });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}