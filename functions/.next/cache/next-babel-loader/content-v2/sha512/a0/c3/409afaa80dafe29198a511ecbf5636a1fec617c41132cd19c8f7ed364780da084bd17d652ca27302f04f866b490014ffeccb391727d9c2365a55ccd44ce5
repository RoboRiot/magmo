{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport firebase from \"../context/Firebase\";\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(partsSnapshot.docs.map(async partDoc => {\n    var _ref, _getRefId, _ref2, _getRefId2;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    const getRefId = ref => {\n      if (!ref) return null;\n      if (typeof ref === \"string\") return ref;\n      if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n      if (ref.id) return ref.id;\n      return null;\n    };\n\n    partData.clientFromId = (_ref = (_getRefId = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientFrom)) !== null && _getRefId !== void 0 ? _getRefId : partData === null || partData === void 0 ? void 0 : partData.clientFromId) !== null && _ref !== void 0 ? _ref : null;\n    partData.clientCurrentId = (_ref2 = (_getRefId2 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientCurrent)) !== null && _getRefId2 !== void 0 ? _getRefId2 : partData === null || partData === void 0 ? void 0 : partData.clientCurrentId) !== null && _ref2 !== void 0 ? _ref2 : null; // console.log(partData);\n\n    const fetchMachineData = async ref => {\n      if (!ref) return null;\n\n      if (typeof ref.get === \"function\") {\n        const doc = await ref.get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (typeof ref === \"string\") {\n        const doc = await db.collection(\"Machine\").doc(ref).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (ref !== null && ref !== void 0 && ref.id) {\n        const doc = await db.collection(\"Machine\").doc(ref.id).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      return null;\n    };\n\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef = partData.CurrentMachine || partData.MachineCurrent;\n    const machineData = await fetchMachineData(machineRef);\n    partData.machineData = machineData || {};\n\n    if (machineData !== null && machineData !== void 0 && machineData.client) {\n      const clientRef = machineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (clientId && !partData.clientFromId) {\n        partData.clientFromId = clientId;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    const currentMachineData = await fetchMachineData(currentMachineRef);\n    partData.currentMachineData = currentMachineData || {};\n\n    if (currentMachineData !== null && currentMachineData !== void 0 && currentMachineData.client) {\n      const clientRef = currentMachineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (clientId && !partData.clientCurrentId) {\n        partData.clientCurrentId = clientId;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.currentMachineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    return partData;\n  }));\n  return parts;\n} // Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\n\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false,\n  filterFn = null,\n  needsMachineData = true\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const getRefId = ref => {\n    if (!ref) return null;\n    if (typeof ref === \"string\") return ref;\n    if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n    if (ref.id) return ref.id;\n    return null;\n  };\n\n  const buildPart = (partDoc, machineMap, currentMachineMap) => {\n    var _ref3, _getRefId3, _ref4, _getRefId4;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    partData.clientFromId = (_ref3 = (_getRefId3 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientFrom)) !== null && _getRefId3 !== void 0 ? _getRefId3 : partData === null || partData === void 0 ? void 0 : partData.clientFromId) !== null && _ref3 !== void 0 ? _ref3 : null;\n    partData.clientCurrentId = (_ref4 = (_getRefId4 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientCurrent)) !== null && _getRefId4 !== void 0 ? _getRefId4 : partData === null || partData === void 0 ? void 0 : partData.clientCurrentId) !== null && _ref4 !== void 0 ? _ref4 : null;\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef = partData.CurrentMachine || partData.MachineCurrent;\n    const machineId = getRefId(machineRef);\n    const currentMachineId = getRefId(currentMachineRef);\n    const machineData = machineId ? machineMap[machineId] : null;\n    const currentMachineData = currentMachineId ? currentMachineMap[currentMachineId] : null;\n    partData.machineData = machineData || {};\n    partData.currentMachineData = currentMachineData || {};\n\n    if (!partData.clientFromId && machineData !== null && machineData !== void 0 && machineData.client) {\n      partData.clientFromId = getRefId(machineData.client);\n    }\n\n    if (!partData.clientCurrentId && currentMachineData !== null && currentMachineData !== void 0 && currentMachineData.client) {\n      partData.clientCurrentId = getRefId(currentMachineData.client);\n    }\n\n    return partData;\n  };\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let pageLastDoc = null;\n  let hasNextPage = false;\n  let filled = false;\n\n  while (true) {\n    let query = db.collection(\"Test\").limit(limit);\n    if (cursor) query = query.startAfter(cursor);\n    const snap = await query.get();\n\n    if (snap.empty) {\n      hasNextPage = false;\n      break;\n    }\n\n    const batchDocs = snap.docs;\n    let machineMap = {};\n    let currentMachineMap = {};\n\n    if (needsMachineData) {\n      const machineIds = new Set();\n      const currentMachineIds = new Set();\n\n      for (const doc of batchDocs) {\n        const raw = doc.data();\n\n        if (visibleOnly && raw.visible === false) {\n          continue;\n        }\n\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\n        const currentMachineId = getRefId(raw.CurrentMachine || raw.MachineCurrent);\n        if (machineId) machineIds.add(machineId);\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\n      }\n\n      const fetchMachineMap = async ids => {\n        if (!ids.length) return {};\n        const out = {};\n        const chunks = [];\n\n        for (let i = 0; i < ids.length; i += 10) {\n          chunks.push(ids.slice(i, i + 10));\n        }\n\n        for (const chunk of chunks) {\n          const snap = await db.collection(\"Machine\").where(firebase.firestore.FieldPath.documentId(), \"in\", chunk).get();\n          snap.forEach(doc => {\n            out[doc.id] = doc.data() || {};\n          });\n        }\n\n        return out;\n      };\n\n      [machineMap, currentMachineMap] = await Promise.all([fetchMachineMap([...machineIds]), fetchMachineMap([...currentMachineIds])]);\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = batchDocs[i];\n      cursor = doc;\n      const raw = doc.data();\n\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      const built = buildPart(doc, machineMap, currentMachineMap);\n\n      if (filterFn && !filterFn(built)) {\n        continue;\n      }\n\n      if (!filled) {\n        parts.push(built);\n\n        if (parts.length === pageSize) {\n          filled = true;\n          pageLastDoc = doc;\n        }\n\n        continue;\n      } // We already filled the page and found an extra matching item.\n\n\n      hasNextPage = true;\n      return {\n        parts,\n        lastDoc: pageLastDoc,\n        hasNextPage\n      };\n    } // We exhausted this batch without filling the page.\n\n\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    } // There might be more docs; continue scanning for visible items.\n\n\n    hasNextPage = true;\n  }\n\n  lastDoc = pageLastDoc || (parts.length ? cursor : null);\n  return {\n    parts,\n    lastDoc,\n    hasNextPage: filled ? hasNextPage : false\n  };\n}\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map(doc => _objectSpread({\n    id: doc.id\n  }, doc.data())); // Filter clients based on OEM and Modality if selected\n\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n\n    for (const client of clients) {\n      let match = true;\n\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n\n          if (selectedOEM && machineData.OEM === selectedOEM || selectedModality && machineData.Modality === selectedModality) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n\n    return filteredClients;\n  }\n\n  return clients;\n}\nexport async function fetchModels(selectedOEM, selectedModality, selectedClient) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n  await Promise.all(machinesSnapshot.docs.map(async machineDoc => {\n    const machineData = machineDoc.data();\n    let isValid = true;\n    if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n    if (selectedModality && machineData.Modality !== selectedModality) isValid = false;\n\n    if (selectedClient && machineData.client) {\n      var _machineData$client;\n\n      let clientDoc = null;\n\n      if (typeof ((_machineData$client = machineData.client) === null || _machineData$client === void 0 ? void 0 : _machineData$client.get) === \"function\") {\n        clientDoc = await machineData.client.get();\n      } else if (typeof machineData.client === \"string\") {\n        clientDoc = await db.collection(\"Client\").doc(machineData.client).get();\n      }\n\n      if (!clientDoc || !clientDoc.exists) {\n        isValid = false;\n      } else {\n        const clientName = clientDoc.data().name;\n        const clientId = clientDoc.id;\n\n        if (selectedClient !== clientName && selectedClient !== clientId) {\n          isValid = false;\n        }\n      }\n    }\n\n    if (isValid) {\n      models.add(machineData.Model);\n    }\n  }));\n  return Array.from(models);\n}\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/utils/fetchAssociations.js"],"names":["React","firebase","fetchPartsWithMachineData","db","firestore","partsSnapshot","collection","get","parts","Promise","all","docs","map","partDoc","partData","data","id","getRefId","ref","DocumentReference","clientFromId","ClientFrom","clientCurrentId","ClientCurrent","fetchMachineData","doc","exists","machineRef","Machine","MachineFrom","currentMachineRef","CurrentMachine","MachineCurrent","machineData","client","clientRef","clientId","clientDoc","Client","name","currentMachineData","fetchPartsWithMachineDataPage","pageSize","startAfterDoc","visibleOnly","filterFn","needsMachineData","limit","buildPart","machineMap","currentMachineMap","machineId","currentMachineId","cursor","lastDoc","pageLastDoc","hasNextPage","filled","query","startAfter","snap","empty","batchDocs","machineIds","Set","currentMachineIds","raw","visible","add","fetchMachineMap","ids","length","out","chunks","i","push","slice","chunk","where","FieldPath","documentId","forEach","built","size","fetchClients","selectedOEM","selectedModality","clientsSnapshot","clients","filteredClients","match","machines","machineDoc","OEM","Modality","fetchModels","selectedClient","machinesSnapshot","models","isValid","clientName","Model","Array","from","formatDate","timestamp","date","toDate","Date","day","String","getDate","padStart","month","getMonth","year","getFullYear"],"mappings":"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","sourcesContent":["import React from 'react'\nimport firebase from \"../context/Firebase\";\n\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(\n    partsSnapshot.docs.map(async (partDoc) => {\n      const partData = partDoc.data();\n      partData.id = partDoc.id; // Add document ID here\n      const getRefId = (ref) => {\n        if (!ref) return null;\n        if (typeof ref === \"string\") return ref;\n        if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n        if (ref.id) return ref.id;\n        return null;\n      };\n      partData.clientFromId =\n        getRefId(partData?.ClientFrom) ?? partData?.clientFromId ?? null;\n      partData.clientCurrentId =\n        getRefId(partData?.ClientCurrent) ?? partData?.clientCurrentId ?? null;\n      // console.log(partData);\n      const fetchMachineData = async (ref) => {\n        if (!ref) return null;\n        if (typeof ref.get === \"function\") {\n          const doc = await ref.get();\n          return doc.exists ? doc.data() : null;\n        }\n        if (typeof ref === \"string\") {\n          const doc = await db.collection(\"Machine\").doc(ref).get();\n          return doc.exists ? doc.data() : null;\n        }\n        if (ref?.id) {\n          const doc = await db.collection(\"Machine\").doc(ref.id).get();\n          return doc.exists ? doc.data() : null;\n        }\n        return null;\n      };\n\n      const machineRef = partData.Machine || partData.MachineFrom;\n      const currentMachineRef =\n        partData.CurrentMachine || partData.MachineCurrent;\n\n      const machineData = await fetchMachineData(machineRef);\n      partData.machineData = machineData || {};\n      if (machineData?.client) {\n        const clientRef = machineData.client;\n        const clientId = getRefId(clientRef);\n        if (clientId && !partData.clientFromId) {\n          partData.clientFromId = clientId;\n        }\n        if (typeof clientRef?.get === \"function\") {\n          const clientDoc = await clientRef.get();\n          partData.machineData.Client = clientDoc.exists\n            ? clientDoc.data().name\n            : \"\";\n        }\n      }\n\n      const currentMachineData = await fetchMachineData(currentMachineRef);\n      partData.currentMachineData = currentMachineData || {};\n      if (currentMachineData?.client) {\n        const clientRef = currentMachineData.client;\n        const clientId = getRefId(clientRef);\n        if (clientId && !partData.clientCurrentId) {\n          partData.clientCurrentId = clientId;\n        }\n        if (typeof clientRef?.get === \"function\") {\n          const clientDoc = await clientRef.get();\n          partData.currentMachineData.Client = clientDoc.exists\n            ? clientDoc.data().name\n            : \"\";\n        }\n      }\n      return partData;\n    })\n  );\n  return parts;\n}\n\n// Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false,\n  filterFn = null,\n  needsMachineData = true,\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const getRefId = (ref) => {\n    if (!ref) return null;\n    if (typeof ref === \"string\") return ref;\n    if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n    if (ref.id) return ref.id;\n    return null;\n  };\n\n  const buildPart = (partDoc, machineMap, currentMachineMap) => {\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n    partData.clientFromId =\n      getRefId(partData?.ClientFrom) ?? partData?.clientFromId ?? null;\n    partData.clientCurrentId =\n      getRefId(partData?.ClientCurrent) ?? partData?.clientCurrentId ?? null;\n\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef =\n      partData.CurrentMachine || partData.MachineCurrent;\n\n    const machineId = getRefId(machineRef);\n    const currentMachineId = getRefId(currentMachineRef);\n\n    const machineData = machineId ? machineMap[machineId] : null;\n    const currentMachineData = currentMachineId\n      ? currentMachineMap[currentMachineId]\n      : null;\n\n    partData.machineData = machineData || {};\n    partData.currentMachineData = currentMachineData || {};\n\n    if (!partData.clientFromId && machineData?.client) {\n      partData.clientFromId = getRefId(machineData.client);\n    }\n    if (!partData.clientCurrentId && currentMachineData?.client) {\n      partData.clientCurrentId = getRefId(currentMachineData.client);\n    }\n\n    return partData;\n  };\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let pageLastDoc = null;\n  let hasNextPage = false;\n  let filled = false;\n\n  while (true) {\n    let query = db.collection(\"Test\").limit(limit);\n    if (cursor) query = query.startAfter(cursor);\n\n    const snap = await query.get();\n    if (snap.empty) {\n      hasNextPage = false;\n      break;\n    }\n\n    const batchDocs = snap.docs;\n    let machineMap = {};\n    let currentMachineMap = {};\n\n    if (needsMachineData) {\n      const machineIds = new Set();\n      const currentMachineIds = new Set();\n      for (const doc of batchDocs) {\n        const raw = doc.data();\n        if (visibleOnly && raw.visible === false) {\n          continue;\n        }\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\n        const currentMachineId = getRefId(\n          raw.CurrentMachine || raw.MachineCurrent\n        );\n        if (machineId) machineIds.add(machineId);\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\n      }\n\n      const fetchMachineMap = async (ids) => {\n        if (!ids.length) return {};\n        const out = {};\n        const chunks = [];\n        for (let i = 0; i < ids.length; i += 10) {\n          chunks.push(ids.slice(i, i + 10));\n        }\n        for (const chunk of chunks) {\n          const snap = await db\n            .collection(\"Machine\")\n            .where(firebase.firestore.FieldPath.documentId(), \"in\", chunk)\n            .get();\n          snap.forEach((doc) => {\n            out[doc.id] = doc.data() || {};\n          });\n        }\n        return out;\n      };\n\n      [machineMap, currentMachineMap] = await Promise.all([\n        fetchMachineMap([...machineIds]),\n        fetchMachineMap([...currentMachineIds]),\n      ]);\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = batchDocs[i];\n      cursor = doc;\n\n      const raw = doc.data();\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      const built = buildPart(doc, machineMap, currentMachineMap);\n      if (filterFn && !filterFn(built)) {\n        continue;\n      }\n\n      if (!filled) {\n        parts.push(built);\n        if (parts.length === pageSize) {\n          filled = true;\n          pageLastDoc = doc;\n        }\n        continue;\n      }\n\n      // We already filled the page and found an extra matching item.\n      hasNextPage = true;\n      return { parts, lastDoc: pageLastDoc, hasNextPage };\n    }\n\n    // We exhausted this batch without filling the page.\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    }\n\n    // There might be more docs; continue scanning for visible items.\n    hasNextPage = true;\n  }\n\n  lastDoc = pageLastDoc || (parts.length ? cursor : null);\n  return { parts, lastDoc, hasNextPage: filled ? hasNextPage : false };\n}\n\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map((doc) => ({\n    id: doc.id,\n    ...doc.data(),\n  }));\n\n  // Filter clients based on OEM and Modality if selected\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n    for (const client of clients) {\n      let match = true;\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n          if (\n            (selectedOEM && machineData.OEM === selectedOEM) ||\n            (selectedModality && machineData.Modality === selectedModality)\n          ) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n    return filteredClients;\n  }\n\n  return clients;\n}\n\nexport async function fetchModels(\n  selectedOEM,\n  selectedModality,\n  selectedClient\n) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n\n  await Promise.all(\n    machinesSnapshot.docs.map(async (machineDoc) => {\n      const machineData = machineDoc.data();\n      let isValid = true;\n\n      if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n      if (selectedModality && machineData.Modality !== selectedModality)\n        isValid = false;\n      if (selectedClient && machineData.client) {\n        let clientDoc = null;\n        if (typeof machineData.client?.get === \"function\") {\n          clientDoc = await machineData.client.get();\n        } else if (typeof machineData.client === \"string\") {\n          clientDoc = await db.collection(\"Client\").doc(machineData.client).get();\n        }\n        if (!clientDoc || !clientDoc.exists) {\n          isValid = false;\n        } else {\n          const clientName = clientDoc.data().name;\n          const clientId = clientDoc.id;\n          if (selectedClient !== clientName && selectedClient !== clientId) {\n            isValid = false;\n          }\n        }\n      }\n\n      if (isValid) {\n        models.add(machineData.Model);\n      }\n    })\n  );\n\n  return Array.from(models);\n}\n\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}\n"]},"metadata":{},"sourceType":"module"}