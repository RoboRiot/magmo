{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\n//   try {\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\n//     const {\n//       listKey,            // \"receiving\" | \"shipping\" | \"tasks\"\n//       title, linkUrl, bodyText,\n//       date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\n//       photoUrls = [],\n//     } = req.body;\n//     const LISTS = {\n//       receiving: {\n//         id: process.env.SLACK_LIST_RECEIVING_ID,\n//         cols: {\n//           desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n//           date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\n//           pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n//           track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n//           wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\n//           lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n//           photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // attachment\n//         },\n//       },\n//       shipping: {\n//         id: process.env.SLACK_LIST_SHIPPING_ID,\n//         cols: {\n//           desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n//           date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\n//           pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n//           track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n//           wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\n//           lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n//           photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,  // attachment\n//         },\n//       },\n//       tasks: {\n//         id: process.env.SLACK_LIST_TASKS_ID,\n//         cols: {\n//           desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\n//         },\n//       },\n//     };\n//     const CHANNELS = {\n//       receiving: process.env.SLACK_CHANNEL_RECEIVING_ID,\n//       shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,\n//       tasks:     process.env.SLACK_CHANNEL_TASKS_ID,\n//     };\n//     const headersJson = {\n//       Authorization: `Bearer ${token}`,\n//       \"Content-Type\": \"application/json; charset=utf-8\",\n//     };\n//     const slack = (method, body, headers = headersJson) =>\n//       fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body })\n//         .then(r => r.json());\n//     const plain = v => (v ?? \"\").toString().trim();\n//     const safe  = plain;\n//     const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     // ---------- PATH A: Write to a LIST ----------\n//     const cfg = LISTS[listKey];\n//     if (cfg?.id) {\n//       const fields = [];\n//       // Description column\n//       if (cfg.cols.desc && (description || bodyText || linkUrl)) {\n//         const textBits = [\n//           description,\n//           (listKey === \"tasks\" && bodyText) ? bodyText : null,\n//           linkUrl ? `<${linkUrl}|Open in Magmo>` : null,\n//         ].filter(Boolean).join(\"\\n\");\n//         fields.push({ column_id: cfg.cols.desc, value: { text: textBits } });\n//       }\n//       if (cfg.cols.date && date) fields.push({ column_id: cfg.cols.date, value: { date } });\n//       if (cfg.cols.pn && (pn || sn || dom)) {\n//         const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : (pn ? `PN: ${pn}` : \"\");\n//         const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : (sn ? `SN: ${sn}` : \"\");\n//         const domLine = dom ? `DOM: ${dom}` : \"\";\n//         const pnBlock = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\n//         if (pnBlock) fields.push({ column_id: cfg.cols.pn, value: { text: pnBlock } });\n//       }\n//       if (cfg.cols.track && (trackingNumber || poNumber)) {\n//         const t = [\n//           trackingNumber ? `RL: ${trackingNumber}` : \"\",\n//           poNumber ? `PO: ${poNumber}` : \"\",\n//         ].filter(Boolean).join(\"  \");\n//         if (t) fields.push({ column_id: cfg.cols.track, value: { text: t } });\n//       }\n//       if (cfg.cols.wo && workOrder) fields.push({ column_id: cfg.cols.wo,  value: { text: `WO: ${workOrder}` } });\n//       if (cfg.cols.lsn && localSN)  fields.push({ column_id: cfg.cols.lsn, value: { text: localSN } });\n//       // NOW build the create body (cfg & fields exist)\n//       const createBody = {\n//         list_id: cfg.id,\n//         title: plain(title) || plain(localSN) || \"Untitled\",\n//         fields,\n//       };\n//       const created = await slack(\"slackLists.items.create\", JSON.stringify(createBody));\n//       if (!created?.ok) {\n//         console.error(\"slackLists.items.create error:\", created);\n//         return res.status(400).json({ error: created?.error || \"Slack Lists API error\", raw: created });\n//       }\n//       // Photos -> attachment column\n//       if (cfg.cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\n//         const fileIds = [];\n//         for (const url of photoUrls) {\n//           const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\n//             method: \"POST\",\n//             headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\n//             body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\n//           }).then(r => r.json());\n//           if (!init?.ok || !init?.upload_url) continue;\n//           try {\n//             const img = await fetch(url);\n//             const buf = await img.arrayBuffer();\n//             await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\n//           } catch (_) {}\n//           const complete = await slack(\"files.completeUploadExternal\",\n//             JSON.stringify({ files: [{ id: init.file_id, title: \"photo\" }] })\n//           );\n//           if (complete?.ok && complete?.files?.[0]?.id) fileIds.push(complete.files[0].id);\n//         }\n//         if (fileIds.length) {\n//           await slack(\"slackLists.items.update\", JSON.stringify({\n//             list_id: cfg.id,\n//             item_id: created.item.id,\n//             fields: [{ column_id: cfg.cols.photos, value: { attachment: { file_ids: fileIds } } }],\n//           }));\n//         }\n//       }\n//       return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: created.item.id });\n//     }\n//     // ---------- PATH B: Fallback to a channel post ----------\n//     const channel = CHANNELS[listKey];\n//     if (!channel) return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\n//     // Try to join public channels to avoid channel_not_found\n//     await fetch(\"https://slack.com/api/conversations.join\", {\n//       method: \"POST\",\n//       headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\n//       body: new URLSearchParams({ channel }),\n//     });\n//     const safeId = plain(linkUrl?.split(\"/\").pop()) || plain(localSN) || \"\";\n//     const safeTitle = plain(title) || plain(req.body?.title) || (safeId ? `Item ${safeId}` : \"New Item\");\n//     const lines = [];\n//     lines.push(`*${safeTitle}*`);\n//     const pnStr = joinArr(pn);\n//     const snStr = joinArr(sn);\n//     if (pnStr) lines.push(`PN: ${pnStr}`);\n//     if (snStr) lines.push(`SN: ${snStr}`);\n//     if (safe(workOrder)) lines.push(`WO: ${safe(workOrder)}`);\n//     if (safe(poNumber)) lines.push(`PO: ${safe(poNumber)}`);\n//     if (safe(trackingNumber)) lines.push(`RL: ${safe(trackingNumber)}`);\n//     if (safe(dom)) lines.push(`DOM: ${safe(dom)}`);\n//     if (safe(localSN)) lines.push(`Local SN: ${safe(localSN)}`);\n//     if (safe(date)) lines.push(`Date: ${safe(date)}`);\n//     const desc = safe(description);\n//     if (desc) lines.push(desc);\n//     else if (listKey === \"tasks\" && safe(bodyText)) lines.push(safe(bodyText));\n//     if (safe(linkUrl)) lines.push(`<${safe(linkUrl)}|Open in Magmo>`);\n//     const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\n//     const posted = await slack(\"chat.postMessage\", JSON.stringify({ channel, text }));\n//     if (!posted?.ok) {\n//       console.error(\"chat.postMessage error:\", posted);\n//       return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\n//     }\n//     return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\n//   } catch (e) {\n//     console.error(\"API /slack/add-to-list crashed:\", e);\n//     return res.status(500).json({ error: \"Server error\" });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  if (req.method !== \"POST\") return res.status(405).json({\n    error: \"Method not allowed\"\n  });\n\n  try {\n    const token = process.env.SLACK_BOT_TOKEN;\n    if (!token) return res.status(500).json({\n      error: \"Missing SLACK_BOT_TOKEN\"\n    });\n    const {\n      listKey,\n      // \"receiving\" | \"shipping\" | \"tasks\"\n      title,\n      linkUrl,\n      bodyText,\n      date,\n      pn,\n      sn,\n      dom,\n      trackingNumber,\n      poNumber,\n      workOrder,\n      localSN,\n      description,\n      photoUrls = []\n    } = req.body || {};\n    const LIST_IDS = {\n      tasks: process.env.SLACK_LIST_TASKS_ID,\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\n      receiving: process.env.SLACK_LIST_RECEIVING_ID\n    };\n    const list_id = LIST_IDS[listKey];\n    if (!list_id) return res.status(400).json({\n      error: \"Unknown listKey (no list configured)\"\n    }); // --- helpers -------------------------------------------------------------\n\n    const headersJson = {\n      Authorization: `Bearer ${token}`,\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    };\n    const headersForm = {\n      Authorization: `Bearer ${token}`,\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\n    };\n\n    const slack = (method, body, headers = headersJson) => fetch(`https://slack.com/api/${method}`, {\n      method: \"POST\",\n      headers,\n      body\n    }).then(r => r.json());\n\n    const text = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(text).join(\", \") : text(a);\n\n    const rt = t => [{\n      type: \"rich_text\",\n      elements: [{\n        type: \"rich_text_section\",\n        elements: [{\n          type: \"text\",\n          text: text(t)\n        }]\n      }]\n    }]; // --- discover columns so we hit the right IDs ---------------------------\n\n\n    const columnsResp = await slack(\"slackLists.columns.list\", JSON.stringify({\n      list_id\n    }));\n\n    if (!(columnsResp !== null && columnsResp !== void 0 && columnsResp.ok)) {\n      return res.status(400).json({\n        error: \"Failed to list columns\",\n        raw: columnsResp\n      });\n    }\n\n    const columns = columnsResp.columns || []; // find a column by fuzzy name match\n\n    const findCol = (...needles) => {\n      const L = needles.map(n => n.toLowerCase());\n      return columns.find(c => {\n        const name = (c.name || c.label || \"\").toLowerCase();\n        return L.some(n => name.includes(n));\n      });\n    }; // First/required column (prevents blanks)\n\n\n    const colTitle = (listKey === \"tasks\" ? findCol(\"task\") : findCol(\"item\")) || // fallback: first rich-text-like column\n    columns.find(c => (c.type || \"\").includes(\"rich_text\")) || columns[0];\n\n    if (!(colTitle !== null && colTitle !== void 0 && colTitle.id)) {\n      return res.status(400).json({\n        error: \"Couldn't find a title column in this list.\",\n        debug: {\n          columns\n        }\n      });\n    } // Other optional columns (best-effort)\n\n\n    const colDesc = findCol(\"description\", \"notes\");\n    const colDate = listKey === \"tasks\" ? findCol(\"due date\", \"date\") : listKey === \"shipping\" ? findCol(\"shipping date\", \"date\") : findCol(\"received date\", \"date\");\n    const colPn = findCol(\"pn and sn\", \"pn/sn\", \"pn\", \"serial\", \"dom\");\n    const colTrack = findCol(\"tracking\", \"wdim\", \"rl\", \"po\");\n    const colWO = findCol(\"wo\", \"so\", \"work order\");\n    const colLSN = findCol(\"local sn\", \"localsn\");\n    const colPhoto = findCol(\"photos\", \"attachments\", \"images\"); // --- upload photos first to get file ids (optional) ---------------------\n\n    const file_ids = [];\n\n    if (colPhoto !== null && colPhoto !== void 0 && colPhoto.id && Array.isArray(photoUrls) && photoUrls.length) {\n      for (const url of photoUrls) {\n        var _complete$files, _complete$files$;\n\n        const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\n          method: \"POST\",\n          headers: headersForm,\n          body: new URLSearchParams({\n            filename: url.split(\"/\").pop() || \"image.jpg\"\n          })\n        }).then(r => r.json());\n        if (!(init !== null && init !== void 0 && init.ok) || !(init !== null && init !== void 0 && init.upload_url)) continue;\n\n        try {\n          const img = await fetch(url);\n          const buf = await img.arrayBuffer();\n          await fetch(init.upload_url, {\n            method: \"PUT\",\n            body: Buffer.from(buf)\n          });\n        } catch (_) {}\n\n        const complete = await slack(\"files.completeUploadExternal\", JSON.stringify({\n          files: [{\n            id: init.file_id,\n            title: \"photo\"\n          }]\n        }));\n        if (complete !== null && complete !== void 0 && complete.ok && complete !== null && complete !== void 0 && (_complete$files = complete.files) !== null && _complete$files !== void 0 && (_complete$files$ = _complete$files[0]) !== null && _complete$files$ !== void 0 && _complete$files$.id) file_ids.push(complete.files[0].id);\n      }\n    } // --- build item ----------------------------------------------------------\n\n\n    const safeId = text(localSN) || text(linkUrl === null || linkUrl === void 0 ? void 0 : linkUrl.split(\"/\").pop());\n    const safeTitle = text(title) || safeId || joinArr(pn) || \"New item\";\n    const initial_fields = [{\n      column_id: colTitle.id,\n      rich_text: rt(safeTitle)\n    }]; // Description (for Tasks, include bodyText if no description)\n\n    if (colDesc !== null && colDesc !== void 0 && colDesc.id) {\n      const descText = listKey === \"tasks\" ? text(description) || text(bodyText) : text(description);\n      const withLink = [descText, text(linkUrl) && `Open: ${text(linkUrl)}`].filter(Boolean).join(\"\\n\");\n      if (withLink) initial_fields.push({\n        column_id: colDesc.id,\n        rich_text: rt(withLink)\n      });\n    }\n\n    if (colDate !== null && colDate !== void 0 && colDate.id && text(date)) {\n      initial_fields.push({\n        column_id: colDate.id,\n        date: [text(date)]\n      }); // YYYY-MM-DD\n    }\n\n    if (colPn !== null && colPn !== void 0 && colPn.id && (pn || sn || dom)) {\n      const pnStr = joinArr(pn);\n      const snStr = joinArr(sn);\n      const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, text(dom) && `DOM: ${text(dom)}`].filter(Boolean).join(\"  \");\n      if (combo) initial_fields.push({\n        column_id: colPn.id,\n        rich_text: rt(combo)\n      });\n    }\n\n    if (colTrack !== null && colTrack !== void 0 && colTrack.id && (trackingNumber || poNumber)) {\n      const combo = [text(trackingNumber) && `RL: ${text(trackingNumber)}`, text(poNumber) && `PO: ${text(poNumber)}`].filter(Boolean).join(\"  \");\n      if (combo) initial_fields.push({\n        column_id: colTrack.id,\n        rich_text: rt(combo)\n      });\n    }\n\n    if (colWO !== null && colWO !== void 0 && colWO.id && text(workOrder)) initial_fields.push({\n      column_id: colWO.id,\n      rich_text: rt(`WO: ${text(workOrder)}`)\n    });\n    if (colLSN !== null && colLSN !== void 0 && colLSN.id && text(localSN)) initial_fields.push({\n      column_id: colLSN.id,\n      rich_text: rt(text(localSN))\n    });\n    if (colPhoto !== null && colPhoto !== void 0 && colPhoto.id && file_ids.length) initial_fields.push({\n      column_id: colPhoto.id,\n      attachment: file_ids\n    });\n    const created = await slack(\"slackLists.items.create\", JSON.stringify({\n      list_id,\n      initial_fields\n    }));\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(400).json({\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"Slack Lists API error\",\n        raw: created\n      });\n    }\n\n    return res.status(200).json({\n      ok: true,\n      item: created.item\n    });\n  } catch (e) {\n    console.error(\"API /slack/add-to-list crashed:\", e);\n    return res.status(500).json({\n      error: \"Server error\"\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","linkUrl","bodyText","date","pn","sn","dom","trackingNumber","poNumber","workOrder","localSN","description","photoUrls","body","LIST_IDS","tasks","SLACK_LIST_TASKS_ID","shipping","SLACK_LIST_SHIPPING_ID","receiving","SLACK_LIST_RECEIVING_ID","list_id","headersJson","Authorization","headersForm","slack","headers","fetch","then","r","text","v","toString","trim","joinArr","a","Array","isArray","filter","Boolean","map","join","rt","t","type","elements","columnsResp","JSON","stringify","ok","raw","columns","findCol","needles","L","n","toLowerCase","find","c","name","label","some","includes","colTitle","id","debug","colDesc","colDate","colPn","colTrack","colWO","colLSN","colPhoto","file_ids","length","url","init","URLSearchParams","filename","split","pop","upload_url","img","buf","arrayBuffer","Buffer","from","_","complete","files","file_id","push","safeId","safeTitle","initial_fields","column_id","rich_text","descText","withLink","pnStr","snStr","combo","attachment","created","item","e","console"],"mappings":"AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B,OAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,IAAAA,KAAK,EAAE;AAAT,GAArB,CAAP;;AAE3B,MAAI;AACF,UAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;AACA,QAAI,CAACH,KAAL,EAAY,OAAOL,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,KAAK,EAAE;AA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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\r\n\r\n//   try {\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\r\n\r\n//     const {\r\n//       listKey,            // \"receiving\" | \"shipping\" | \"tasks\"\r\n//       title, linkUrl, bodyText,\r\n//       date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n//       photoUrls = [],\r\n//     } = req.body;\r\n\r\n//     const LISTS = {\r\n//       receiving: {\r\n//         id: process.env.SLACK_LIST_RECEIVING_ID,\r\n//         cols: {\r\n//           desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n//           date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\r\n//           pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n//           track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n//           wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n//           lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n//           photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // attachment\r\n//         },\r\n//       },\r\n//       shipping: {\r\n//         id: process.env.SLACK_LIST_SHIPPING_ID,\r\n//         cols: {\r\n//           desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n//           date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\r\n//           pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n//           track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n//           wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n//           lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n//           photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,  // attachment\r\n//         },\r\n//       },\r\n//       tasks: {\r\n//         id: process.env.SLACK_LIST_TASKS_ID,\r\n//         cols: {\r\n//           desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\r\n//         },\r\n//       },\r\n//     };\r\n\r\n//     const CHANNELS = {\r\n//       receiving: process.env.SLACK_CHANNEL_RECEIVING_ID,\r\n//       shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,\r\n//       tasks:     process.env.SLACK_CHANNEL_TASKS_ID,\r\n//     };\r\n\r\n//     const headersJson = {\r\n//       Authorization: `Bearer ${token}`,\r\n//       \"Content-Type\": \"application/json; charset=utf-8\",\r\n//     };\r\n//     const slack = (method, body, headers = headersJson) =>\r\n//       fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body })\r\n//         .then(r => r.json());\r\n\r\n//     const plain = v => (v ?? \"\").toString().trim();\r\n//     const safe  = plain;\r\n//     const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     // ---------- PATH A: Write to a LIST ----------\r\n//     const cfg = LISTS[listKey];\r\n//     if (cfg?.id) {\r\n//       const fields = [];\r\n\r\n//       // Description column\r\n//       if (cfg.cols.desc && (description || bodyText || linkUrl)) {\r\n//         const textBits = [\r\n//           description,\r\n//           (listKey === \"tasks\" && bodyText) ? bodyText : null,\r\n//           linkUrl ? `<${linkUrl}|Open in Magmo>` : null,\r\n//         ].filter(Boolean).join(\"\\n\");\r\n//         fields.push({ column_id: cfg.cols.desc, value: { text: textBits } });\r\n//       }\r\n\r\n//       if (cfg.cols.date && date) fields.push({ column_id: cfg.cols.date, value: { date } });\r\n\r\n//       if (cfg.cols.pn && (pn || sn || dom)) {\r\n//         const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : (pn ? `PN: ${pn}` : \"\");\r\n//         const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : (sn ? `SN: ${sn}` : \"\");\r\n//         const domLine = dom ? `DOM: ${dom}` : \"\";\r\n//         const pnBlock = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\r\n//         if (pnBlock) fields.push({ column_id: cfg.cols.pn, value: { text: pnBlock } });\r\n//       }\r\n\r\n//       if (cfg.cols.track && (trackingNumber || poNumber)) {\r\n//         const t = [\r\n//           trackingNumber ? `RL: ${trackingNumber}` : \"\",\r\n//           poNumber ? `PO: ${poNumber}` : \"\",\r\n//         ].filter(Boolean).join(\"  \");\r\n//         if (t) fields.push({ column_id: cfg.cols.track, value: { text: t } });\r\n//       }\r\n\r\n//       if (cfg.cols.wo && workOrder) fields.push({ column_id: cfg.cols.wo,  value: { text: `WO: ${workOrder}` } });\r\n//       if (cfg.cols.lsn && localSN)  fields.push({ column_id: cfg.cols.lsn, value: { text: localSN } });\r\n\r\n//       // NOW build the create body (cfg & fields exist)\r\n//       const createBody = {\r\n//         list_id: cfg.id,\r\n//         title: plain(title) || plain(localSN) || \"Untitled\",\r\n//         fields,\r\n//       };\r\n\r\n//       const created = await slack(\"slackLists.items.create\", JSON.stringify(createBody));\r\n//       if (!created?.ok) {\r\n//         console.error(\"slackLists.items.create error:\", created);\r\n//         return res.status(400).json({ error: created?.error || \"Slack Lists API error\", raw: created });\r\n//       }\r\n\r\n//       // Photos -> attachment column\r\n//       if (cfg.cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\r\n//         const fileIds = [];\r\n//         for (const url of photoUrls) {\r\n//           const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\r\n//             method: \"POST\",\r\n//             headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n//             body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\r\n//           }).then(r => r.json());\r\n\r\n//           if (!init?.ok || !init?.upload_url) continue;\r\n\r\n//           try {\r\n//             const img = await fetch(url);\r\n//             const buf = await img.arrayBuffer();\r\n//             await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\r\n//           } catch (_) {}\r\n\r\n//           const complete = await slack(\"files.completeUploadExternal\",\r\n//             JSON.stringify({ files: [{ id: init.file_id, title: \"photo\" }] })\r\n//           );\r\n//           if (complete?.ok && complete?.files?.[0]?.id) fileIds.push(complete.files[0].id);\r\n//         }\r\n\r\n//         if (fileIds.length) {\r\n//           await slack(\"slackLists.items.update\", JSON.stringify({\r\n//             list_id: cfg.id,\r\n//             item_id: created.item.id,\r\n//             fields: [{ column_id: cfg.cols.photos, value: { attachment: { file_ids: fileIds } } }],\r\n//           }));\r\n//         }\r\n//       }\r\n\r\n//       return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: created.item.id });\r\n//     }\r\n\r\n//     // ---------- PATH B: Fallback to a channel post ----------\r\n//     const channel = CHANNELS[listKey];\r\n//     if (!channel) return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\r\n\r\n//     // Try to join public channels to avoid channel_not_found\r\n//     await fetch(\"https://slack.com/api/conversations.join\", {\r\n//       method: \"POST\",\r\n//       headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n//       body: new URLSearchParams({ channel }),\r\n//     });\r\n\r\n//     const safeId = plain(linkUrl?.split(\"/\").pop()) || plain(localSN) || \"\";\r\n//     const safeTitle = plain(title) || plain(req.body?.title) || (safeId ? `Item ${safeId}` : \"New Item\");\r\n\r\n//     const lines = [];\r\n//     lines.push(`*${safeTitle}*`);\r\n\r\n//     const pnStr = joinArr(pn);\r\n//     const snStr = joinArr(sn);\r\n//     if (pnStr) lines.push(`PN: ${pnStr}`);\r\n//     if (snStr) lines.push(`SN: ${snStr}`);\r\n//     if (safe(workOrder)) lines.push(`WO: ${safe(workOrder)}`);\r\n//     if (safe(poNumber)) lines.push(`PO: ${safe(poNumber)}`);\r\n//     if (safe(trackingNumber)) lines.push(`RL: ${safe(trackingNumber)}`);\r\n//     if (safe(dom)) lines.push(`DOM: ${safe(dom)}`);\r\n//     if (safe(localSN)) lines.push(`Local SN: ${safe(localSN)}`);\r\n//     if (safe(date)) lines.push(`Date: ${safe(date)}`);\r\n\r\n//     const desc = safe(description);\r\n//     if (desc) lines.push(desc);\r\n//     else if (listKey === \"tasks\" && safe(bodyText)) lines.push(safe(bodyText));\r\n\r\n//     if (safe(linkUrl)) lines.push(`<${safe(linkUrl)}|Open in Magmo>`);\r\n\r\n//     const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\r\n\r\n//     const posted = await slack(\"chat.postMessage\", JSON.stringify({ channel, text }));\r\n//     if (!posted?.ok) {\r\n//       console.error(\"chat.postMessage error:\", posted);\r\n//       return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\r\n//     }\r\n\r\n//     return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\r\n//   } catch (e) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", e);\r\n//     return res.status(500).json({ error: \"Server error\" });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\r\n\r\n  try {\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\r\n\r\n    const {\r\n      listKey,                 // \"receiving\" | \"shipping\" | \"tasks\"\r\n      title, linkUrl, bodyText,\r\n      date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n      photoUrls = [],\r\n    } = req.body || {};\r\n\r\n    const LIST_IDS = {\r\n      tasks:     process.env.SLACK_LIST_TASKS_ID,\r\n      shipping:  process.env.SLACK_LIST_SHIPPING_ID,\r\n      receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n    };\r\n\r\n    const list_id = LIST_IDS[listKey];\r\n    if (!list_id) return res.status(400).json({ error: \"Unknown listKey (no list configured)\" });\r\n\r\n    // --- helpers -------------------------------------------------------------\r\n    const headersJson = {\r\n      Authorization: `Bearer ${token}`,\r\n      \"Content-Type\": \"application/json; charset=utf-8\",\r\n    };\r\n    const headersForm = {\r\n      Authorization: `Bearer ${token}`,\r\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n    };\r\n    const slack = (method, body, headers = headersJson) =>\r\n      fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body }).then(r => r.json());\r\n\r\n    const text = (v) => (v ?? \"\").toString().trim();\r\n    const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(text).join(\", \") : text(a);\r\n    const rt = (t) => [{\r\n      type: \"rich_text\",\r\n      elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text: text(t) }]}],\r\n    }];\r\n\r\n    // --- discover columns so we hit the right IDs ---------------------------\r\n    const columnsResp = await slack(\"slackLists.columns.list\", JSON.stringify({ list_id }));\r\n    if (!columnsResp?.ok) {\r\n      return res.status(400).json({ error: \"Failed to list columns\", raw: columnsResp });\r\n    }\r\n    const columns = columnsResp.columns || [];\r\n\r\n    // find a column by fuzzy name match\r\n    const findCol = (...needles) => {\r\n      const L = needles.map(n => n.toLowerCase());\r\n      return columns.find(c => {\r\n        const name = (c.name || c.label || \"\").toLowerCase();\r\n        return L.some(n => name.includes(n));\r\n      });\r\n    };\r\n\r\n    // First/required column (prevents blanks)\r\n    const colTitle =\r\n      (listKey === \"tasks\" ? findCol(\"task\") : findCol(\"item\")) ||\r\n      // fallback: first rich-text-like column\r\n      columns.find(c => (c.type || \"\").includes(\"rich_text\")) ||\r\n      columns[0];\r\n\r\n    if (!colTitle?.id) {\r\n      return res.status(400).json({ error: \"Couldn't find a title column in this list.\", debug: { columns } });\r\n    }\r\n\r\n    // Other optional columns (best-effort)\r\n    const colDesc  = findCol(\"description\", \"notes\");\r\n    const colDate  = listKey === \"tasks\" ? findCol(\"due date\",\"date\") :\r\n                     listKey === \"shipping\" ? findCol(\"shipping date\",\"date\") : findCol(\"received date\",\"date\");\r\n    const colPn    = findCol(\"pn and sn\", \"pn/sn\", \"pn\", \"serial\", \"dom\");\r\n    const colTrack = findCol(\"tracking\", \"wdim\", \"rl\", \"po\");\r\n    const colWO    = findCol(\"wo\", \"so\", \"work order\");\r\n    const colLSN   = findCol(\"local sn\", \"localsn\");\r\n    const colPhoto = findCol(\"photos\", \"attachments\", \"images\");\r\n\r\n    // --- upload photos first to get file ids (optional) ---------------------\r\n    const file_ids = [];\r\n    if (colPhoto?.id && Array.isArray(photoUrls) && photoUrls.length) {\r\n      for (const url of photoUrls) {\r\n        const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\r\n          method: \"POST\",\r\n          headers: headersForm,\r\n          body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\r\n        }).then(r => r.json());\r\n        if (!init?.ok || !init?.upload_url) continue;\r\n\r\n        try {\r\n          const img = await fetch(url);\r\n          const buf = await img.arrayBuffer();\r\n          await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\r\n        } catch (_) {}\r\n\r\n        const complete = await slack(\r\n          \"files.completeUploadExternal\",\r\n          JSON.stringify({ files: [{ id: init.file_id, title: \"photo\" }] })\r\n        );\r\n        if (complete?.ok && complete?.files?.[0]?.id) file_ids.push(complete.files[0].id);\r\n      }\r\n    }\r\n\r\n    // --- build item ----------------------------------------------------------\r\n    const safeId    = text(localSN) || text(linkUrl?.split(\"/\").pop());\r\n    const safeTitle = text(title) || safeId || joinArr(pn) || \"New item\";\r\n\r\n    const initial_fields = [\r\n      { column_id: colTitle.id, rich_text: rt(safeTitle) },\r\n    ];\r\n\r\n    // Description (for Tasks, include bodyText if no description)\r\n    if (colDesc?.id) {\r\n      const descText = listKey === \"tasks\" ? (text(description) || text(bodyText)) : text(description);\r\n      const withLink = [descText, text(linkUrl) && `Open: ${text(linkUrl)}`].filter(Boolean).join(\"\\n\");\r\n      if (withLink) initial_fields.push({ column_id: colDesc.id, rich_text: rt(withLink) });\r\n    }\r\n\r\n    if (colDate?.id && text(date)) {\r\n      initial_fields.push({ column_id: colDate.id, date: [ text(date) ] }); // YYYY-MM-DD\r\n    }\r\n\r\n    if (colPn?.id && (pn || sn || dom)) {\r\n      const pnStr = joinArr(pn);\r\n      const snStr = joinArr(sn);\r\n      const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, text(dom) && `DOM: ${text(dom)}`]\r\n        .filter(Boolean).join(\"  \");\r\n      if (combo) initial_fields.push({ column_id: colPn.id, rich_text: rt(combo) });\r\n    }\r\n\r\n    if (colTrack?.id && (trackingNumber || poNumber)) {\r\n      const combo = [text(trackingNumber) && `RL: ${text(trackingNumber)}`, text(poNumber) && `PO: ${text(poNumber)}`]\r\n        .filter(Boolean).join(\"  \");\r\n      if (combo) initial_fields.push({ column_id: colTrack.id, rich_text: rt(combo) });\r\n    }\r\n\r\n    if (colWO?.id && text(workOrder)) initial_fields.push({ column_id: colWO.id,  rich_text: rt(`WO: ${text(workOrder)}`) });\r\n    if (colLSN?.id && text(localSN))  initial_fields.push({ column_id: colLSN.id, rich_text: rt(text(localSN)) });\r\n    if (colPhoto?.id && file_ids.length) initial_fields.push({ column_id: colPhoto.id, attachment: file_ids });\r\n\r\n    const created = await slack(\"slackLists.items.create\", JSON.stringify({\r\n      list_id,\r\n      initial_fields,\r\n    }));\r\n\r\n    if (!created?.ok) {\r\n      return res.status(400).json({ error: created?.error || \"Slack Lists API error\", raw: created });\r\n    }\r\n\r\n    return res.status(200).json({ ok: true, item: created.item });\r\n  } catch (e) {\r\n    console.error(\"API /slack/add-to-list crashed:\", e);\r\n    return res.status(500).json({ error: \"Server error\" });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}