{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  const t0 = Date.now();\n  const steps = [];\n\n  const logStep = (step, extra = {}) => steps.push(_objectSpread({\n    t: new Date().toISOString(),\n    step\n  }, extra));\n\n  try {\n    var _created$item;\n\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n    if (!token) return res.status(500).json({\n      ok: false,\n      error: \"missing_SLACK_BOT_TOKEN\"\n    }); // ---------- payload from client ----------\n\n    const {\n      listKey,\n      // \"tasks\" | \"shipping\" | \"receiving\"\n      title,\n      // item title\n      pn_sn,\n      // \"PN: 123  SN: 456\"\n      work_order,\n      // string | undefined\n      tracking,\n      // string | undefined\n      local_sn,\n      // string | undefined\n      description,\n      // string | undefined\n      photoUrls = [] // array of https URLs (Firebase download URLs)\n\n    } = req.body || {}; // ---------- env: list + column ids ----------\n\n    const LIST_IDS = {\n      tasks: process.env.SLACK_LIST_TASKS_ID,\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\n      receiving: process.env.SLACK_LIST_RECEIVING_ID\n    };\n    const COLS = {\n      tasks: {\n        title: process.env.SLACK_LIST_TASKS_TITLE_COL,\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL\n      },\n      shipping: {\n        title: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\n        desc: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n        pnsn: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n        wo: process.env.SLACK_LIST_SHIPPING_WO_COL,\n        localsn: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n        tracking: process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL\n      },\n      receiving: {\n        title: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\n        desc: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n        pnsn: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n        wo: process.env.SLACK_LIST_RECEIVING_WO_COL,\n        localsn: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n        tracking: process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL\n      }\n    };\n    const list_id = LIST_IDS[listKey];\n    const CFG = COLS[listKey] || {};\n    if (!list_id) return res.status(400).json({\n      ok: false,\n      error: `unknown_listKey_${listKey}`\n    });\n    if (!CFG.title) return res.status(400).json({\n      ok: false,\n      error: \"missing_title_column_env\"\n    }); // ---------- helpers ----------\n\n    async function slackJson(method, payload) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(payload)\n      });\n      const json = await r.json();\n      return json;\n    }\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    function richText(text) {\n      const t = plain(text);\n      return [{\n        type: \"rich_text\",\n        elements: [{\n          type: \"rich_text_section\",\n          elements: [{\n            type: \"text\",\n            text: t || \"\"\n          }]\n        }]\n      }];\n    } // ---------- 1) create the row with title ----------\n\n\n    const createPayload = {\n      list_id,\n      initial_fields: [{\n        column_id: CFG.title,\n        rich_text: richText(title || \"Untitled item\")\n      }]\n    };\n    const created = await slackJson(\"slackLists.items.create\", createPayload);\n    logStep(\"[LISTS][CREATE-RICH]\", {\n      ok: (created === null || created === void 0 ? void 0 : created.ok) === true,\n      status: 200,\n      error: created === null || created === void 0 ? void 0 : created.error\n    });\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(200).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\",\n        debug: {\n          steps\n        }\n      });\n    }\n\n    const rowId = (_created$item = created.item) === null || _created$item === void 0 ? void 0 : _created$item.id;\n    logStep(\"[LISTS][CREATED]\", {\n      rowId\n    }); // ---------- 2) update rich_text fields (PN/SN, LocalSN, WO, Tracking, Description) ----------\n\n    const cells = [];\n    if (CFG.pnsn && pn_sn) cells.push({\n      row_id: rowId,\n      column_id: CFG.pnsn,\n      rich_text: richText(pn_sn)\n    });\n    if (CFG.localsn && local_sn) cells.push({\n      row_id: rowId,\n      column_id: CFG.localsn,\n      rich_text: richText(local_sn)\n    });\n    if (CFG.wo && work_order) cells.push({\n      row_id: rowId,\n      column_id: CFG.wo,\n      rich_text: richText(work_order)\n    });\n    if (CFG.tracking && tracking) cells.push({\n      row_id: rowId,\n      column_id: CFG.tracking,\n      rich_text: richText(tracking)\n    });\n    if (CFG.desc && description) cells.push({\n      row_id: rowId,\n      column_id: CFG.desc,\n      rich_text: richText(description)\n    });\n\n    if (cells.length) {\n      const updated = await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells\n      }); // Log each field we set for easier troubleshooting:\n\n      if (CFG.pnsn && pn_sn) logStep(\"[LISTS][SET-RICH][PN/SN]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.localsn && local_sn) logStep(\"[LISTS][SET-RICH][LOCAL_SN]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.desc && description) logStep(\"[LISTS][SET-RICH][DESCRIPTION]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.wo && work_order) logStep(\"[LISTS][SET-RICH][WO]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.tracking && tracking) logStep(\"[LISTS][SET-RICH][TRACKING]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n\n      if (!(updated !== null && updated !== void 0 && updated.ok)) {\n        return res.status(200).json({\n          ok: false,\n          error: (updated === null || updated === void 0 ? void 0 : updated.error) || \"update_failed\",\n          debug: {\n            steps\n          }\n        });\n      }\n    } // ---------- 3) upload photos (getUploadURLExternal -> POST bytes -> completeUploadExternal) ----------\n\n\n    async function uploadViaExternal(fileUrl, filename) {\n      // 3a. fetch bytes\n      const resp = await fetch(fileUrl);\n      const buf = await resp.arrayBuffer();\n      const byteLen = buf.byteLength;\n      logStep(\"[FILES.BYTES]\", {\n        byteLen,\n        filename\n      }); // 3b. get upload url\n\n      const up = await slackJson(\"files.getUploadURLExternal\", {\n        filename,\n        length: byteLen\n      });\n      logStep(\"[FILES.GETUPLOAD]\", {\n        ok: (up === null || up === void 0 ? void 0 : up.ok) === true,\n        status: 200,\n        byteLen,\n        filename,\n        error: up === null || up === void 0 ? void 0 : up.error\n      });\n      if (!(up !== null && up !== void 0 && up.ok) || !(up !== null && up !== void 0 && up.upload_url) || !(up !== null && up !== void 0 && up.file_id)) return {\n        ok: false,\n        error: (up === null || up === void 0 ? void 0 : up.error) || \"get_upload_url_failed\"\n      }; // 3c. post bytes to the upload_url\n\n      const post = await fetch(up.upload_url, {\n        method: \"POST\",\n        body: Buffer.from(buf)\n      });\n      logStep(\"[FILES.UPLOAD.POST]\", {\n        ok: (post === null || post === void 0 ? void 0 : post.ok) === true,\n        status: post === null || post === void 0 ? void 0 : post.status\n      });\n      if (!post.ok) return {\n        ok: false,\n        error: \"upload_post_failed\"\n      }; // 3d. complete\n\n      const complete = await slackJson(\"files.completeUploadExternal\", {\n        files: [{\n          id: up.file_id,\n          title: filename\n        }]\n      });\n      logStep(\"[FILES.COMPLETE]\", {\n        ok: (complete === null || complete === void 0 ? void 0 : complete.ok) === true,\n        status: 200,\n        error: complete === null || complete === void 0 ? void 0 : complete.error\n      });\n      if (!(complete !== null && complete !== void 0 && complete.ok)) return {\n        ok: false,\n        error: (complete === null || complete === void 0 ? void 0 : complete.error) || \"complete_failed\"\n      };\n      return {\n        ok: true,\n        file: {\n          id: up.file_id\n        }\n      };\n    }\n\n    async function attachFilesToCell(listId, row, col, fileIds) {\n      var _r, _r2, _r3, _r4;\n\n      // Try ATTACHMENT type first\n      let r = await slackJson(\"slackLists.items.update\", {\n        list_id: listId,\n        cells: [{\n          row_id: row,\n          column_id: col,\n          attachment: fileIds\n        }]\n      });\n      logStep(\"[LISTS][ATTACH-A][PHOTOS]\", {\n        ok: ((_r = r) === null || _r === void 0 ? void 0 : _r.ok) === true,\n        status: 200,\n        error: (_r2 = r) === null || _r2 === void 0 ? void 0 : _r2.error\n      });\n      if ((_r3 = r) !== null && _r3 !== void 0 && _r3.ok) return r; // If the column is a REFERENCE field to files, use that shape\n\n      if (((_r4 = r) === null || _r4 === void 0 ? void 0 : _r4.error) === \"invalid_input_type\") {\n        var _r5, _r6;\n\n        r = await slackJson(\"slackLists.items.update\", {\n          list_id: listId,\n          cells: [{\n            row_id: row,\n            column_id: col,\n            reference: fileIds.map(id => ({\n              file: {\n                file_id: id\n              }\n            }))\n          }]\n        });\n        logStep(\"[LISTS][ATTACH-D][PHOTOS]\", {\n          ok: ((_r5 = r) === null || _r5 === void 0 ? void 0 : _r5.ok) === true,\n          status: 200,\n          error: (_r6 = r) === null || _r6 === void 0 ? void 0 : _r6.error\n        });\n      }\n\n      return r;\n    }\n\n    let attachedOk = false;\n    let fileIds = [];\n\n    if (CFG.photos && Array.isArray(photoUrls) && photoUrls.length) {\n      // Upload up to 10 images\n      for (let i = 0; i < Math.min(photoUrls.length, 10); i++) {\n        var _url$split$pop, _up$file, _up$file2;\n\n        const url = plain(photoUrls[i]);\n        if (!/^https?:\\/\\//i.test(url)) continue;\n        const filename = decodeURIComponent(((_url$split$pop = url.split(\"/\").pop()) === null || _url$split$pop === void 0 ? void 0 : _url$split$pop.split(\"?\")[0]) || `photo_${i + 1}.jpg`);\n        const up = await uploadViaExternal(url, filename);\n        logStep(\"[PHOTOS][UPLOADED]\", {\n          ok: (up === null || up === void 0 ? void 0 : up.ok) === true,\n          file_id: up === null || up === void 0 ? void 0 : (_up$file = up.file) === null || _up$file === void 0 ? void 0 : _up$file.id,\n          filename\n        });\n        if (up !== null && up !== void 0 && up.ok && (_up$file2 = up.file) !== null && _up$file2 !== void 0 && _up$file2.id) fileIds.push(up.file.id);\n      }\n\n      if (fileIds.length) {\n        const att = await attachFilesToCell(list_id, rowId, CFG.photos, fileIds);\n        attachedOk = !!(att !== null && att !== void 0 && att.ok);\n\n        if (!attachedOk) {\n          logStep(\"[PHOTOS][FAILED-ATTACH]\", {\n            error: att === null || att === void 0 ? void 0 : att.error,\n            ids: fileIds\n          });\n        }\n      } else {\n        logStep(\"[PHOTOS][NO-IDS]\", {\n          reason: \"upload_failed_or_empty\"\n        });\n      }\n    } // Fallback: if photos didn’t attach, drop the URLs into Description so it’s not lost\n\n\n    if (!attachedOk && CFG.desc && photoUrls !== null && photoUrls !== void 0 && photoUrls.length) {\n      const updated = await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id: rowId,\n          column_id: CFG.desc,\n          rich_text: richText(`${plain(description)}\\n\\nPhotos:\\n${photoUrls.join(\"\\n\")}`)\n        }]\n      });\n      logStep(\"[LISTS][SET-RICH][PHOTOS->DESC-FALLBACK]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n    }\n\n    return res.status(200).json({\n      ok: true,\n      list_id,\n      item_id: rowId,\n      used_cols: {\n        title_col: CFG.title || null,\n        pnsn_col: CFG.pnsn || null,\n        description_col: CFG.desc || null,\n        workorder_col: CFG.wo || null,\n        localsn_col: CFG.localsn || null,\n        tracking_col: CFG.tracking || null,\n        photos_col: CFG.photos || null\n      },\n      debug: {\n        steps,\n        photos: fileIds\n      },\n      ms: Date.now() - t0\n    });\n  } catch (err) {\n    logStep(\"[EXCEPTION]\", {\n      message: err === null || err === void 0 ? void 0 : err.message\n    });\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err),\n      debug: {\n        steps\n      }\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","t0","Date","now","steps","logStep","step","extra","push","t","toISOString","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn_sn","work_order","tracking","local_sn","description","photoUrls","body","LIST_IDS","tasks","SLACK_LIST_TASKS_ID","shipping","SLACK_LIST_SHIPPING_ID","receiving","SLACK_LIST_RECEIVING_ID","COLS","SLACK_LIST_TASKS_TITLE_COL","desc","SLACK_LIST_TASKS_DESCRIPTION_COL","SLACK_LIST_SHIPPING_TITLE_COL","SLACK_LIST_SHIPPING_DESCRIPTION_COL","pnsn","SLACK_LIST_SHIPPING_PNSN_COL","wo","SLACK_LIST_SHIPPING_WO_COL","localsn","SLACK_LIST_SHIPPING_LOCALSN_COL","SLACK_LIST_SHIPPING_TRACKING_COL","photos","SLACK_LIST_SHIPPING_PHOTOS_COL","SLACK_LIST_RECEIVING_TITLE_COL","SLACK_LIST_RECEIVING_DESCRIPTION_COL","SLACK_LIST_RECEIVING_PNSN_COL","SLACK_LIST_RECEIVING_WO_COL","SLACK_LIST_RECEIVING_LOCALSN_COL","SLACK_LIST_RECEIVING_TRACKING_COL","SLACK_LIST_RECEIVING_PHOTOS_COL","list_id","CFG","slackJson","payload","r","fetch","headers","Authorization","JSON","stringify","plain","v","toString","trim","richText","text","type","elements","createPayload","initial_fields","column_id","rich_text","created","debug","rowId","item","id","cells","row_id","length","updated","uploadViaExternal","fileUrl","filename","resp","buf","arrayBuffer","byteLen","byteLength","up","upload_url","file_id","post","Buffer","from","complete","files","file","attachFilesToCell","listId","row","col","fileIds","attachment","reference","map","attachedOk","Array","isArray","i","Math","min","url","test","decodeURIComponent","split","pop","att","ids","reason","join","item_id","used_cols","title_col","pnsn_col","description_col","workorder_col","localsn_col","tracking_col","photos_col","ms","err","message","console","String"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,QAAMC,EAAE,GAAGC,IAAI,CAACC,GAAL,EAAX;AACA,QAAMC,KAAK,GAAG,EAAd;;AACA,QAAMC,OAAO,GAAG,CAACC,IAAD,EAAOC,KAAK,GAAG,EAAf,KAAsBH,KAAK,CAACI,IAAN;AAAaC,IAAAA,CAAC,EAAE,IAAIP,IAAJ,GAAWQ,WAAX,EAAhB;AAA0CJ,IAAAA;AAA1C,KAAmDC,KAAnD,EAAtC;;AAEA,MAAI;AAAA;;AACF,QAAIR,GAAG,CAACY,MAAJ,KAAe,MAAnB,EAA2B;AACzB,aAAOX,GAAG,CAACY,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAA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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   try {\r\n//     if (req.method !== \"POST\") {\r\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//     }\r\n\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) {\r\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//     }\r\n\r\n//     // payload from client\r\n//     const {\r\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n//       title,               // item title (what shows in the primary column)\r\n//       // keeping minimal per your request: PN/SN only for now\r\n//       pn, sn,\r\n//     } = req.body || {};\r\n\r\n//     // list ids from env\r\n//     const LIST_IDS = {\r\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\r\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n//     };\r\n\r\n//     const list_id = LIST_IDS[listKey];\r\n//     if (!list_id) {\r\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n//     }\r\n\r\n//     // ---- Slack helpers ----\r\n//     async function slackJson(method, payload) {\r\n//       const r = await fetch(`https://slack.com/api/${method}`, {\r\n//         method: \"POST\",\r\n//         headers: {\r\n//           Authorization: `Bearer ${token}`,\r\n//           \"Content-Type\": \"application/json; charset=utf-8\",\r\n//         },\r\n//         body: JSON.stringify(payload),\r\n//       });\r\n//       return r.json();\r\n//     }\r\n\r\n//     const plain = (v) => (v ?? \"\").toString().trim();\r\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     function toRichText(text) {\r\n//       const t = plain(text);\r\n//       return [{\r\n//         type: \"rich_text\",\r\n//         elements: [{\r\n//           type: \"rich_text_section\",\r\n//           elements: [{ type: \"text\", text: t }],\r\n//         }],\r\n//       }];\r\n//     }\r\n\r\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n//     async function resolveTitleColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n//       let fallback = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\r\n//           if (f.column_id && hasText) {\r\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n//             if (!fallback) fallback = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return fallback; // first text-like field if we didn't find a perfect match\r\n//     }\r\n\r\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n//     async function resolvePnSnColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       let candidate = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           if (!f.column_id) continue;\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const text = (f.text || \"\").toLowerCase();\r\n\r\n//           const looksPnSn =\r\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\r\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n//           if (looksPnSn) return f.column_id;\r\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n//             candidate = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return candidate;\r\n//     }\r\n\r\n//     // 1) Resolve columns\r\n//     const titleColId = await resolveTitleColId(list_id);\r\n//     if (!titleColId) {\r\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n//     }\r\n\r\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n//     const safeTitle = plain(title) || \"New Item\";\r\n//     const createBody = {\r\n//       list_id,\r\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n//     };\r\n\r\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 3) (Minimal) update: PN/SN only, per your request\r\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n//     let updated = null;\r\n//     let usedPnSnCol = null;\r\n\r\n//     if (pnSnText) {\r\n//       const pnSnColId = await resolvePnSnColId(list_id);\r\n//       if (pnSnColId) {\r\n//         const cells = [{\r\n//           row_id: created.item.id,\r\n//           column_id: pnSnColId,\r\n//           rich_text: toRichText(pnSnText),\r\n//         }];\r\n\r\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n//         usedPnSnCol = pnSnColId;\r\n//         // If update fails, we still return ok:false so you can see the error\r\n//         if (!updated?.ok) {\r\n//           return res.status(200).json({\r\n//             ok: false,\r\n//             error: updated?.error || \"update_failed\",\r\n//             mode: \"list\",\r\n//             list_id,\r\n//             item_id: created.item.id,\r\n//             used_title_col: titleColId,\r\n//             used_pnsn_col: usedPnSnCol,\r\n//           });\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleColId,\r\n//       used_pnsn_col: usedPnSnCol || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  const t0 = Date.now();\r\n  const steps = [];\r\n  const logStep = (step, extra = {}) => steps.push({ t: new Date().toISOString(), step, ...extra });\r\n\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n\r\n    // ---------- payload from client ----------\r\n    const {\r\n      listKey,              // \"tasks\" | \"shipping\" | \"receiving\"\r\n      title,                // item title\r\n      pn_sn,                // \"PN: 123  SN: 456\"\r\n      work_order,           // string | undefined\r\n      tracking,             // string | undefined\r\n      local_sn,             // string | undefined\r\n      description,          // string | undefined\r\n      photoUrls = [],       // array of https URLs (Firebase download URLs)\r\n    } = req.body || {};\r\n\r\n    // ---------- env: list + column ids ----------\r\n    const LIST_IDS = {\r\n      tasks: process.env.SLACK_LIST_TASKS_ID,\r\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n      receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n    };\r\n\r\n    const COLS = {\r\n      tasks: {\r\n        title: process.env.SLACK_LIST_TASKS_TITLE_COL,\r\n        desc:  process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\r\n      },\r\n      shipping: {\r\n        title:     process.env.SLACK_LIST_SHIPPING_TITLE_COL,\r\n        desc:      process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n        pnsn:      process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n        wo:        process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n        localsn:   process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n        tracking:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n        photos:    process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,\r\n      },\r\n      receiving: {\r\n        title:     process.env.SLACK_LIST_RECEIVING_TITLE_COL,\r\n        desc:      process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n        pnsn:      process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n        wo:        process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n        localsn:   process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n        tracking:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n        photos:    process.env.SLACK_LIST_RECEIVING_PHOTOS_COL,\r\n      },\r\n    };\r\n\r\n    const list_id = LIST_IDS[listKey];\r\n    const CFG = COLS[listKey] || {};\r\n    if (!list_id) return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n    if (!CFG.title) return res.status(400).json({ ok: false, error: \"missing_title_column_env\" });\r\n\r\n    // ---------- helpers ----------\r\n    async function slackJson(method, payload) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          Authorization: `Bearer ${token}`,\r\n          \"Content-Type\": \"application/json; charset=utf-8\",\r\n        },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      const json = await r.json();\r\n      return json;\r\n    }\r\n\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n\r\n    function richText(text) {\r\n      const t = plain(text);\r\n      return [{\r\n        type: \"rich_text\",\r\n        elements: [{\r\n          type: \"rich_text_section\",\r\n          elements: [{ type: \"text\", text: t || \"\" }],\r\n        }],\r\n      }];\r\n    }\r\n\r\n    // ---------- 1) create the row with title ----------\r\n    const createPayload = {\r\n      list_id,\r\n      initial_fields: [\r\n        { column_id: CFG.title, rich_text: richText(title || \"Untitled item\") },\r\n      ],\r\n    };\r\n\r\n    const created = await slackJson(\"slackLists.items.create\", createPayload);\r\n    logStep(\"[LISTS][CREATE-RICH]\", { ok: created?.ok === true, status: 200, error: created?.error });\r\n    if (!created?.ok) {\r\n      return res.status(200).json({ ok: false, error: created?.error || \"create_failed\", debug: { steps } });\r\n    }\r\n    const rowId = created.item?.id;\r\n    logStep(\"[LISTS][CREATED]\", { rowId });\r\n\r\n    // ---------- 2) update rich_text fields (PN/SN, LocalSN, WO, Tracking, Description) ----------\r\n    const cells = [];\r\n    if (CFG.pnsn && pn_sn)     cells.push({ row_id: rowId, column_id: CFG.pnsn,     rich_text: richText(pn_sn) });\r\n    if (CFG.localsn && local_sn) cells.push({ row_id: rowId, column_id: CFG.localsn,  rich_text: richText(local_sn) });\r\n    if (CFG.wo && work_order)  cells.push({ row_id: rowId, column_id: CFG.wo,       rich_text: richText(work_order) });\r\n    if (CFG.tracking && tracking) cells.push({ row_id: rowId, column_id: CFG.tracking, rich_text: richText(tracking) });\r\n    if (CFG.desc && description) cells.push({ row_id: rowId, column_id: CFG.desc,   rich_text: richText(description) });\r\n\r\n    if (cells.length) {\r\n      const updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n      // Log each field we set for easier troubleshooting:\r\n      if (CFG.pnsn && pn_sn)     logStep(\"[LISTS][SET-RICH][PN/SN]\",     { ok: updated?.ok === true, status: 200, error: updated?.error });\r\n      if (CFG.localsn && local_sn) logStep(\"[LISTS][SET-RICH][LOCAL_SN]\", { ok: updated?.ok === true, status: 200, error: updated?.error });\r\n      if (CFG.desc && description) logStep(\"[LISTS][SET-RICH][DESCRIPTION]\", { ok: updated?.ok === true, status: 200, error: updated?.error });\r\n      if (CFG.wo && work_order)    logStep(\"[LISTS][SET-RICH][WO]\", { ok: updated?.ok === true, status: 200, error: updated?.error });\r\n      if (CFG.tracking && tracking) logStep(\"[LISTS][SET-RICH][TRACKING]\", { ok: updated?.ok === true, status: 200, error: updated?.error });\r\n\r\n      if (!updated?.ok) {\r\n        return res.status(200).json({ ok: false, error: updated?.error || \"update_failed\", debug: { steps } });\r\n      }\r\n    }\r\n\r\n    // ---------- 3) upload photos (getUploadURLExternal -> POST bytes -> completeUploadExternal) ----------\r\n    async function uploadViaExternal(fileUrl, filename) {\r\n      // 3a. fetch bytes\r\n      const resp = await fetch(fileUrl);\r\n      const buf = await resp.arrayBuffer();\r\n      const byteLen = buf.byteLength;\r\n      logStep(\"[FILES.BYTES]\", { byteLen, filename });\r\n\r\n      // 3b. get upload url\r\n      const up = await slackJson(\"files.getUploadURLExternal\", { filename, length: byteLen });\r\n      logStep(\"[FILES.GETUPLOAD]\", { ok: up?.ok === true, status: 200, byteLen, filename, error: up?.error });\r\n      if (!up?.ok || !up?.upload_url || !up?.file_id) return { ok: false, error: up?.error || \"get_upload_url_failed\" };\r\n\r\n      // 3c. post bytes to the upload_url\r\n      const post = await fetch(up.upload_url, { method: \"POST\", body: Buffer.from(buf) });\r\n      logStep(\"[FILES.UPLOAD.POST]\", { ok: post?.ok === true, status: post?.status });\r\n      if (!post.ok) return { ok: false, error: \"upload_post_failed\" };\r\n\r\n      // 3d. complete\r\n      const complete = await slackJson(\"files.completeUploadExternal\", {\r\n        files: [{ id: up.file_id, title: filename }],\r\n      });\r\n      logStep(\"[FILES.COMPLETE]\", { ok: complete?.ok === true, status: 200, error: complete?.error });\r\n      if (!complete?.ok) return { ok: false, error: complete?.error || \"complete_failed\" };\r\n\r\n      return { ok: true, file: { id: up.file_id } };\r\n    }\r\n\r\n    async function attachFilesToCell(listId, row, col, fileIds) {\r\n      // Try ATTACHMENT type first\r\n      let r = await slackJson(\"slackLists.items.update\", {\r\n        list_id: listId,\r\n        cells: [{ row_id: row, column_id: col, attachment: fileIds }],\r\n      });\r\n      logStep(\"[LISTS][ATTACH-A][PHOTOS]\", { ok: r?.ok === true, status: 200, error: r?.error });\r\n\r\n      if (r?.ok) return r;\r\n\r\n      // If the column is a REFERENCE field to files, use that shape\r\n      if (r?.error === \"invalid_input_type\") {\r\n        r = await slackJson(\"slackLists.items.update\", {\r\n          list_id: listId,\r\n          cells: [{\r\n            row_id: row,\r\n            column_id: col,\r\n            reference: fileIds.map(id => ({ file: { file_id: id } })),\r\n          }],\r\n        });\r\n        logStep(\"[LISTS][ATTACH-D][PHOTOS]\", { ok: r?.ok === true, status: 200, error: r?.error });\r\n      }\r\n\r\n      return r;\r\n    }\r\n\r\n    let attachedOk = false;\r\n    let fileIds = [];\r\n\r\n    if (CFG.photos && Array.isArray(photoUrls) && photoUrls.length) {\r\n      // Upload up to 10 images\r\n      for (let i = 0; i < Math.min(photoUrls.length, 10); i++) {\r\n        const url = plain(photoUrls[i]);\r\n        if (!/^https?:\\/\\//i.test(url)) continue;\r\n        const filename = decodeURIComponent(url.split(\"/\").pop()?.split(\"?\")[0] || `photo_${i + 1}.jpg`);\r\n\r\n        const up = await uploadViaExternal(url, filename);\r\n        logStep(\"[PHOTOS][UPLOADED]\", { ok: up?.ok === true, file_id: up?.file?.id, filename });\r\n        if (up?.ok && up.file?.id) fileIds.push(up.file.id);\r\n      }\r\n\r\n      if (fileIds.length) {\r\n        const att = await attachFilesToCell(list_id, rowId, CFG.photos, fileIds);\r\n        attachedOk = !!att?.ok;\r\n        if (!attachedOk) {\r\n          logStep(\"[PHOTOS][FAILED-ATTACH]\", { error: att?.error, ids: fileIds });\r\n        }\r\n      } else {\r\n        logStep(\"[PHOTOS][NO-IDS]\", { reason: \"upload_failed_or_empty\" });\r\n      }\r\n    }\r\n\r\n    // Fallback: if photos didn’t attach, drop the URLs into Description so it’s not lost\r\n    if (!attachedOk && CFG.desc && photoUrls?.length) {\r\n      const updated = await slackJson(\"slackLists.items.update\", {\r\n        list_id,\r\n        cells: [{ row_id: rowId, column_id: CFG.desc, rich_text: richText(`${plain(description)}\\n\\nPhotos:\\n${photoUrls.join(\"\\n\")}`) }],\r\n      });\r\n      logStep(\"[LISTS][SET-RICH][PHOTOS->DESC-FALLBACK]\", { ok: updated?.ok === true, status: 200, error: updated?.error });\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      list_id,\r\n      item_id: rowId,\r\n      used_cols: {\r\n        title_col: CFG.title || null,\r\n        pnsn_col: CFG.pnsn || null,\r\n        description_col: CFG.desc || null,\r\n        workorder_col: CFG.wo || null,\r\n        localsn_col: CFG.localsn || null,\r\n        tracking_col: CFG.tracking || null,\r\n        photos_col: CFG.photos || null,\r\n      },\r\n      debug: { steps, photos: fileIds },\r\n      ms: Date.now() - t0,\r\n    });\r\n  } catch (err) {\r\n    logStep(\"[EXCEPTION]\", { message: err?.message });\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err), debug: { steps } });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}