{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   if (req.method !== \"POST\") {\n//     return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//   }\n//   const token = process.env.SLACK_BOT_TOKEN;\n//   if (!token) {\n//     return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//   }\n//   // ---- Payload from client (your UI already sends these) ----\n//   const {\n//     listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\n//     title,              // the thing we want to show in the Task column\n//     linkUrl, bodyText,\n//     date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\n//     photoUrls = [],\n//   } = req.body || {};\n//   // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\n//   const LISTS = {\n//     tasks: {\n//       id: process.env.SLACK_LIST_TASKS_ID,\n//       // OPTIONAL: if you know the \"Task\" column id already\n//       titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\n//       cols: {\n//         desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\n//       },\n//     },\n//     shipping: {\n//       id: process.env.SLACK_LIST_SHIPPING_ID,\n//       titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\n//       cols: {\n//         desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\n//         date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\n//         pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\n//         track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\n//         wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\n//         lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\n//         photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\n//       },\n//     },\n//     receiving: {\n//       id: process.env.SLACK_LIST_RECEIVING_ID,\n//       titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\n//       cols: {\n//         desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\n//         date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\n//         pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\n//         track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\n//         wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\n//         lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\n//         photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\n//       },\n//     },\n//   };\n//   const cfg = LISTS[listKey];\n//   if (!cfg?.id) {\n//     return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\n//   }\n//   // ---- Slack helpers ----\n//   async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\n//     const r = await fetch(`https://slack.com/api/${method}`, {\n//       method: \"POST\",\n//       headers: { Authorization: `Bearer ${token}`, ...headers },\n//       body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\n//     });\n//     return r.json();\n//   }\n//   const plain = (v) => (v ?? \"\").toString().trim();\n//   const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//   // Never send an empty title\n//   const safeTitle =\n//     plain(title) ||\n//     (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\n//     joinArr(pn) ||\n//     \"New Item\";\n//   // Convert plain text to Slack rich_text for text columns\n//   function toRichText(text) {\n//     return [{\n//       type: \"rich_text\",\n//       elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\n//     }];\n//   }\n//   // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\n//   async function resolveTitleColumnId(listId, provided) {\n//     if (provided) return { colId: provided, source: \"env\" };\n//     const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//     if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\n//     let candidate = null;\n//     for (const item of probe.items || []) {\n//       for (const f of item.fields || []) {\n//         const key = (f.key || \"\").trim().toLowerCase();\n//         const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\n//         if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\n//         if (!candidate && f.column_id && hasText) candidate = f.column_id;\n//       }\n//     }\n//     return { colId: candidate, source: \"auto:first_text\" };\n//   }\n//   try {\n//     // 1) Find the column to write the Task name into; fall back to top-level title\n//     const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\n//     const createBody = {\n//       list_id: cfg.id,\n//       ...(titleCol.colId\n//         ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\n//         : { title: safeTitle }), // fallback if we couldn’t resolve a column\n//     };\n//     const created = await slack(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 2) (Optional) Patch other columns you actually have IDs for\n//     const fields = [];\n//     const cols = cfg.cols || {};\n//     const addText = (colId, text) => {\n//       const t = plain(text);\n//       if (colId && t) fields.push({ column_id: colId, value: { text: t } });\n//     };\n//     // Description / Notes column (for tasks we include your assembled bodyText)\n//     if (cols.desc) {\n//       const bits = [\n//         plain(description),\n//         listKey === \"tasks\" ? plain(bodyText) : \"\",\n//         plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\n//       ].filter(Boolean).join(\"\\n\");\n//       addText(cols.desc, bits);\n//     }\n//     // Dates and grouped PN/SN/DOM example\n//     if (cols.date && plain(date)) fields.push({ column_id: cols.date, value: { date: plain(date) } });\n//     if (cols.pn) {\n//       const pnStr = joinArr(pn), snStr = joinArr(sn);\n//       const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`]\n//         .filter(Boolean).join(\"  \");\n//       addText(cols.pn, combo);\n//     }\n//     if (cols.track) {\n//       const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`]\n//         .filter(Boolean).join(\"  \");\n//       addText(cols.track, t);\n//     }\n//     if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\n//     if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\n//     if (fields.length) {\n//       await slack(\"slackLists.items.update\", { list_id: cfg.id, item_id: created.item.id, fields });\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id: cfg.id,\n//       item_id: created.item.id,\n//       used_title_col: titleCol.colId || null,\n//       title_col_source: titleCol.source || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\n// Scopes needed: lists:write (lists:read is optional if you want to auto-detect columns)\nexport default async function handler(req, res) {\n  if (req.method !== \"POST\") {\n    return res.status(405).json({\n      ok: false,\n      error: \"method_not_allowed\"\n    });\n  }\n\n  const token = process.env.SLACK_BOT_TOKEN;\n\n  if (!token) {\n    return res.status(500).json({\n      ok: false,\n      error: \"missing_SLACK_BOT_TOKEN\"\n    });\n  } // ---- Payload from client (your UI already sends these) ----\n\n\n  const {\n    listKey,\n    // \"tasks\" | \"shipping\" | \"receiving\"\n    title,\n    // text for the left-most Item/Task column\n    linkUrl,\n    // item deep-link back to your app (optional)\n    bodyText,\n    // multi-line blob used in Tasks description (optional)\n    // shipping/receiving fields\n    date,\n    // YYYY-MM-DD (your \"arrival_date\")\n    pn,\n    // string | string[]\n    sn,\n    // string | string[]\n    dom,\n    // string (optional)\n    trackingNumber,\n    // \"RL\" value\n    poNumber,\n    // PO number\n    workOrder,\n    // WO number\n    localSN,\n    // your item ID\n    description,\n    // inline human description\n    photoUrls = [] // currently unused for Lists (kept for future)\n\n  } = req.body || {}; // ---- Lists & Column IDs (only list IDs are strictly required) ----\n\n  const LISTS = {\n    tasks: {\n      id: process.env.SLACK_LIST_TASKS_ID,\n      cols: {\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null\n      }\n    },\n    shipping: {\n      id: process.env.SLACK_LIST_SHIPPING_ID,\n      cols: {\n        desc: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\n        date: process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\n        pn: process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\n        track: process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\n        wo: process.env.SLACK_LIST_SHIPPING_WO_COL || null,\n        lsn: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null // optional\n\n      }\n    },\n    receiving: {\n      id: process.env.SLACK_LIST_RECEIVING_ID,\n      cols: {\n        desc: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\n        date: process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\n        pn: process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\n        track: process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\n        wo: process.env.SLACK_LIST_RECEIVING_WO_COL || null,\n        lsn: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null // optional\n\n      }\n    }\n  };\n  const cfg = LISTS[listKey];\n\n  if (!(cfg !== null && cfg !== void 0 && cfg.id)) {\n    return res.status(400).json({\n      ok: false,\n      error: `unknown_or_unconfigured_listKey_${listKey}`\n    });\n  } // ---- Slack helper ----\n\n\n  async function slack(method, payload, headers = {\n    \"Content-Type\": \"application/json; charset=utf-8\"\n  }) {\n    const r = await fetch(`https://slack.com/api/${method}`, {\n      method: \"POST\",\n      headers: _objectSpread({\n        Authorization: `Bearer ${token}`\n      }, headers),\n      body: JSON.stringify(payload)\n    });\n    return r.json();\n  }\n\n  const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n  const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a); // Build a safe, never-empty title for Slack’s primary column\n\n\n  const safeTitle = plain(title) || (plain(localSN) ? `Item ${plain(localSN)}` : \"\") || joinArr(pn) || \"New Item\";\n\n  try {\n    var _created$item;\n\n    // 1) Create the row with ONLY the title. (This is why you see the name right now.)\n    const createBody = {\n      list_id: cfg.id,\n      title: safeTitle\n    };\n    const created = await slack(\"slackLists.items.create\", createBody);\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(200).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\",\n        mode: \"list\",\n        sent: createBody\n      });\n    }\n\n    const itemId = (created === null || created === void 0 ? void 0 : (_created$item = created.item) === null || _created$item === void 0 ? void 0 : _created$item.id) || (created === null || created === void 0 ? void 0 : created.id);\n\n    if (!itemId) {\n      return res.status(200).json({\n        ok: false,\n        error: \"missing_item_id_after_create\",\n        mode: \"list\",\n        raw: created\n      });\n    } // 2) Patch additional columns (ONLY if those column IDs exist in env)\n\n\n    const fields = [];\n    const cols = cfg.cols || {}; // Description column: include your description; for Tasks also include the assembled bodyText; include link\n\n    if (cols.desc) {\n      const bits = [plain(description), listKey === \"tasks\" ? plain(bodyText) : \"\", plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\"].filter(Boolean).join(\"\\n\");\n      if (bits) fields.push({\n        column_id: cols.desc,\n        value: {\n          text: bits\n        }\n      });\n    } // Date\n\n\n    if (cols.date && plain(date)) {\n      fields.push({\n        column_id: cols.date,\n        value: {\n          date: plain(date)\n        }\n      });\n    } // PN / SN / DOM grouped on one line\n\n\n    if (cols.pn) {\n      const pnStr = joinArr(pn);\n      const snStr = joinArr(sn);\n      const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`].filter(Boolean).join(\"  \");\n      if (combo) fields.push({\n        column_id: cols.pn,\n        value: {\n          text: combo\n        }\n      });\n    } // Tracking + PO grouped in the same column (your UI shows them together)\n\n\n    if (cols.track) {\n      const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`].filter(Boolean).join(\"  \");\n      if (t) fields.push({\n        column_id: cols.track,\n        value: {\n          text: t\n        }\n      });\n    } // WO\n\n\n    if (cols.wo && plain(workOrder)) {\n      fields.push({\n        column_id: cols.wo,\n        value: {\n          text: `WO: ${plain(workOrder)}`\n        }\n      });\n    } // Local SN (your internal ID)\n\n\n    if (cols.lsn && plain(localSN)) {\n      fields.push({\n        column_id: cols.lsn,\n        value: {\n          text: plain(localSN)\n        }\n      });\n    } // (Optional) Photos column — Slack Lists attachments are a separate thing; safest to skip unless you know its type.\n    // if (cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\n    //   fields.push({ column_id: cols.photos, value: { text: photoUrls.join(\"\\n\") } });\n    // }\n\n\n    if (fields.length) {\n      const upd = await slack(\"slackLists.items.update\", {\n        list_id: cfg.id,\n        item_id: itemId,\n        fields\n      });\n\n      if (!(upd !== null && upd !== void 0 && upd.ok)) {\n        // Still return ok=true so at least the title exists, but surface the update error for debugging\n        return res.status(200).json({\n          ok: true,\n          mode: \"list\",\n          list_id: cfg.id,\n          item_id: itemId,\n          sent_title: safeTitle,\n          warn: (upd === null || upd === void 0 ? void 0 : upd.error) || \"update_failed\"\n        });\n      }\n    } // 3) Done\n\n\n    return res.status(200).json({\n      ok: true,\n      mode: \"list\",\n      list_id: cfg.id,\n      item_id: itemId,\n      sent_title: safeTitle\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","linkUrl","bodyText","date","pn","sn","dom","trackingNumber","poNumber","workOrder","localSN","description","photoUrls","body","LISTS","tasks","id","SLACK_LIST_TASKS_ID","cols","desc","SLACK_LIST_TASKS_DESCRIPTION_COL","shipping","SLACK_LIST_SHIPPING_ID","SLACK_LIST_SHIPPING_DESCRIPTION_COL","SLACK_LIST_SHIPPING_DATE_COL","SLACK_LIST_SHIPPING_PNSN_COL","track","SLACK_LIST_SHIPPING_TRACKING_COL","wo","SLACK_LIST_SHIPPING_WO_COL","lsn","SLACK_LIST_SHIPPING_LOCALSN_COL","photos","SLACK_LIST_SHIPPING_PHOTOS_COL","receiving","SLACK_LIST_RECEIVING_ID","SLACK_LIST_RECEIVING_DESCRIPTION_COL","SLACK_LIST_RECEIVING_DATE_COL","SLACK_LIST_RECEIVING_PNSN_COL","SLACK_LIST_RECEIVING_TRACKING_COL","SLACK_LIST_RECEIVING_WO_COL","SLACK_LIST_RECEIVING_LOCALSN_COL","SLACK_LIST_RECEIVING_PHOTOS_COL","cfg","slack","payload","headers","r","fetch","Authorization","JSON","stringify","plain","v","toString","trim","joinArr","a","Array","isArray","filter","Boolean","map","join","safeTitle","createBody","list_id","created","mode","sent","itemId","item","raw","fields","bits","push","column_id","value","text","pnStr","snStr","combo","t","length","upd","item_id","sent_title","warn","err","console","message","String"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,WAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE;AAApB,KAArB,CAAP;AACD;;AAED,QAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;;AACA,MAAI,CAACH,KAAL,EAAY;AACV,WAAON,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE;AAApB,KAArB,CAAP;AACD,GAR6C,CAU9C;;;AACA,QAAM;AACJK,IAAAA,OADI;AACgB;AACpBC,IAAAA,KAFI;AAEgB;AACpBC,IAAAA,OAHI;AAGgB;AACpBC,IAAAA,QAJI;AAIgB;AAEpB;AACAC,IAAAA,IAPI;AAOgB;AACpBC,IAAAA,EARI;AAQgB;AACpBC,IAAAA,EATI;AASgB;AACpBC,IAAAA,GAVI;AAUgB;AACpBC,IAAAA,cAXI;AAWgB;AACpBC,IAAAA,QAZI;AAYgB;AACpBC,IAAAA,SAbI;AAagB;AACpBC,IAAAA,OAdI;AAcgB;AACpBC,IAAAA,WAfI;AAegB;AACpBC,IAAAA,SAAS,GAAG,EAhBR,CAgBgB;;AAhBhB,MAiBFxB,GAAG,CAACyB,IAAJ,IAAY,EAjBhB,CAX8C,CA8B9C;;AACA,QAAMC,KAAK,GAAG;AACZC,IAAAA,KAAK,EAAE;AACLC,MAAAA,EAAE,EAAEpB,OAAO,CAACC,GAAR,CAAYoB,mBADX;AAELC,MAAAA,IAAI,EAAE;AACJC,QAAAA,IAAI,EAAEvB,OAAO,CAACC,GAAR,CAAYuB,gCAAZ,IAAgD;AADlD;AAFD,KADK;AAOZC,IAAAA,QAAQ,EAAE;AACRL,MAAAA,EAAE,EAAEpB,OAAO,CAACC,GAAR,CAAYyB,sBADR;AAERJ,MAAAA,IAAI,EAAE;AACJC,QAAAA,IAAI,EAAIvB,OAAO,CAACC,GAAR,CAAY0B,mCAAZ,IAAmD,IADvD;AAEJpB,QAAAA,IAAI,EAAIP,OAAO,CAACC,GAAR,CAAY2B,4BAAZ,IAA4C,IAFhD;AAGJpB,QAAAA,EAAE,EAAMR,OAAO,CAACC,GAAR,CAAY4B,4BAAZ,IAA4C,IAHhD;AAIJC,QAAAA,KAAK,EAAG9B,OAAO,CAACC,GAAR,CAAY8B,gCAAZ,IAAgD,IAJpD;AAKJC,QAAAA,EAAE,EAAMhC,OAAO,CAACC,GAAR,CAAYgC,0BAAZ,IAA0C,IAL9C;AAMJC,QAAAA,GAAG,EAAKlC,OAAO,CAACC,GAAR,CAAYkC,+BAAZ,IAA+C,IANnD;AAOJC,QAAAA,MAAM,EAAEpC,OAAO,CAACC,GAAR,CAAYoC,8BAAZ,IAA8C,IAPlD,CAOwD;;AAPxD;AAFE,KAPE;AAmBZC,IAAAA,SAAS,EAAE;AACTlB,MAAAA,EAAE,EAAEpB,OAAO,CAACC,GAAR,CAAYsC,uBADP;AAETjB,MAAAA,IAAI,EAAE;AACJC,QAAAA,IAAI,EAAIvB,OAAO,CAACC,GAAR,CAAYuC,oCAAZ,IAAoD,IADxD;AAEJjC,QAAAA,IAAI,EAAIP,OAAO,CAACC,GAAR,CAAYwC,6BAAZ,IAA6C,IAFjD;AAGJjC,QAAAA,EAAE,EAAMR,OAAO,CAACC,GAAR,CAAYyC,6BAAZ,IAA6C,IAHjD;AAIJZ,QAAAA,KAAK,EAAG9B,OAAO,CAACC,GAAR,CAAY0C,iCAAZ,IAAiD,IAJrD;AAKJX,QAAAA,EAAE,EAAMhC,OAAO,CAACC,GAAR,CAAY2C,2BAAZ,IAA2C,IAL/C;AAMJV,QAAAA,GAAG,EAAKlC,OAAO,CAACC,GAAR,CAAY4C,gCAAZ,IAAgD,IANpD;AAOJT,QAAAA,MAAM,EAAEpC,OAAO,CAACC,GAAR,CAAY6C,+BAAZ,IAA+C,IAPnD,CAOyD;;AAPzD;AAFG;AAnBC,GAAd;AAiCA,QAAMC,GAAG,GAAG7B,KAAK,CAACf,OAAD,CAAjB;;AACA,MAAI,EAAC4C,GAAD,aAACA,GAAD,eAACA,GAAG,CAAE3B,EAAN,CAAJ,EAAc;AACZ,WAAO3B,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAG,mCAAkCK,OAAQ;AAA/D,KAArB,CAAP;AACD,GAnE6C,CAqE9C;;;AACA,iBAAe6C,KAAf,CAAqBtD,MAArB,EAA6BuD,OAA7B,EAAsCC,OAAO,GAAG;AAAE,oBAAgB;AAAlB,GAAhD,EAAuG;AACrG,UAAMC,CAAC,GAAG,MAAMC,KAAK,CAAE,yBAAwB1D,MAAO,EAAjC,EAAoC;AACvDA,MAAAA,MAAM,EAAE,MAD+C;AAEvDwD,MAAAA,OAAO;AAAIG,QAAAA,aAAa,EAAG,UAAStD,KAAM;AAAnC,SAAyCmD,OAAzC,CAFgD;AAGvDjC,MAAAA,IAAI,EAAEqC,IAAI,CAACC,SAAL,CAAeN,OAAf;AAHiD,KAApC,CAArB;AAKA,WAAOE,CAAC,CAACvD,IAAF,EAAP;AACD;;AAED,QAAM4D,KAAK,GAAIC,CAAD,IAAO,CAACA,CAAD,aAACA,CAAD,cAACA,CAAD,GAAM,EAAN,EAAUC,QAAV,GAAqBC,IAArB,EAArB;;AACA,QAAMC,OAAO,GAAIC,CAAD,IAAOC,KAAK,CAACC,OAAN,CAAcF,CAAd,IAAmBA,CAAC,CAACG,MAAF,CAASC,OAAT,EAAkBC,GAAlB,CAAsBV,KAAtB,EAA6BW,IAA7B,CAAkC,IAAlC,CAAnB,GAA6DX,KAAK,CAACK,CAAD,CAAzF,CAhF8C,CAkF9C;;;AACA,QAAMO,SAAS,GACbZ,KAAK,CAACpD,KAAD,CAAL,KACCoD,KAAK,CAAC1C,OAAD,CAAL,GAAkB,QAAO0C,KAAK,CAAC1C,OAAD,CAAU,EAAxC,GAA4C,EAD7C,KAEA8C,OAAO,CAACpD,EAAD,CAFP,IAGA,UAJF;;AAMA,MAAI;AAAA;;AACF;AACA,UAAM6D,UAAU,GAAG;AAAEC,MAAAA,OAAO,EAAEvB,GAAG,CAAC3B,EAAf;AAAmBhB,MAAAA,KAAK,EAAEgE;AAA1B,KAAnB;AACA,UAAMG,OAAO,GAAG,MAAMvB,KAAK,CAAC,yBAAD,EAA4BqB,UAA5B,CAA3B;;AAEA,QAAI,EAACE,OAAD,aAACA,OAAD,eAACA,OAAO,CAAE1E,EAAV,CAAJ,EAAkB;AAChB,aAAOJ,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,QAAAA,EAAE,EAAE,KADsB;AAE1BC,QAAAA,KAAK,EAAE,CAAAyE,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEzE,KAAT,KAAkB,eAFC;AAG1B0E,QAAAA,IAAI,EAAE,MAHoB;AAI1BC,QAAAA,IAAI,EAAEJ;AAJoB,OAArB,CAAP;AAMD;;AAED,UAAMK,MAAM,GAAG,CAAAH,OAAO,SAAP,IAAAA,OAAO,WAAP,6BAAAA,OAAO,CAAEI,IAAT,gEAAevD,EAAf,MAAqBmD,OAArB,aAAqBA,OAArB,uBAAqBA,OAAO,CAAEnD,EAA9B,CAAf;;AACA,QAAI,CAACsD,MAAL,EAAa;AACX,aAAOjF,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,QAAAA,EAAE,EAAE,KADsB;AAE1BC,QAAAA,KAAK,EAAE,8BAFmB;AAG1B0E,QAAAA,IAAI,EAAE,MAHoB;AAI1BI,QAAAA,GAAG,EAAEL;AAJqB,OAArB,CAAP;AAMD,KAtBC,CAwBF;;;AACA,UAAMM,MAAM,GAAG,EAAf;AACA,UAAMvD,IAAI,GAAGyB,GAAG,CAACzB,IAAJ,IAAY,EAAzB,CA1BE,CA4BF;;AACA,QAAIA,IAAI,CAACC,IAAT,EAAe;AACb,YAAMuD,IAAI,GAAG,CACXtB,KAAK,CAACzC,WAAD,CADM,EAEVZ,OAAO,KAAK,OAAZ,GAAsBqD,KAAK,CAAClD,QAAD,CAA3B,GAAwC,EAF9B,EAGXkD,KAAK,CAACnD,OAAD,CAAL,GAAkB,IAAGmD,KAAK,CAACnD,OAAD,CAAU,iBAApC,GAAuD,EAH5C,EAIX2D,MAJW,CAIJC,OAJI,EAIKE,IAJL,CAIU,IAJV,CAAb;AAKA,UAAIW,IAAJ,EAAUD,MAAM,CAACE,IAAP,CAAY;AAAEC,QAAAA,SAAS,EAAE1D,IAAI,CAACC,IAAlB;AAAwB0D,QAAAA,KAAK,EAAE;AAAEC,UAAAA,IAAI,EAAEJ;AAAR;AAA/B,OAAZ;AACX,KApCC,CAsCF;;;AACA,QAAIxD,IAAI,CAACf,IAAL,IAAaiD,KAAK,CAACjD,IAAD,CAAtB,EAA8B;AAC5BsE,MAAAA,MAAM,CAACE,IAAP,CAAY;AAAEC,QAAAA,SAAS,EAAE1D,IAAI,CAACf,IAAlB;AAAwB0E,QAAAA,KAAK,EAAE;AAAE1E,UAAAA,IAAI,EAAEiD,KAAK,CAACjD,IAAD;AAAb;AAA/B,OAAZ;AACD,KAzCC,CA2CF;;;AACA,QAAIe,IAAI,CAACd,EAAT,EAAa;AACX,YAAM2E,KAAK,GAAGvB,OAAO,CAACpD,EAAD,CAArB;AACA,YAAM4E,KAAK,GAAGxB,OAAO,CAACnD,EAAD,CAArB;AACA,YAAM4E,KAAK,GAAG,CACZF,KAAK,IAAK,OAAMA,KAAM,EADV,EAEZC,KAAK,IAAK,OAAMA,KAAM,EAFV,EAGZ5B,KAAK,CAAC9C,GAAD,CAAL,IAAe,QAAO8C,KAAK,CAAC9C,GAAD,CAAM,EAHrB,EAIZsD,MAJY,CAILC,OAJK,EAIIE,IAJJ,CAIS,IAJT,CAAd;AAKA,UAAIkB,KAAJ,EAAWR,MAAM,CAACE,IAAP,CAAY;AAAEC,QAAAA,SAAS,EAAE1D,IAAI,CAACd,EAAlB;AAAsByE,QAAAA,KAAK,EAAE;AAAEC,UAAAA,IAAI,EAAEG;AAAR;AAA7B,OAAZ;AACZ,KArDC,CAuDF;;;AACA,QAAI/D,IAAI,CAACQ,KAAT,EAAgB;AACd,YAAMwD,CAAC,GAAG,CACR9B,KAAK,CAAC7C,cAAD,CAAL,IAA0B,OAAM6C,KAAK,CAAC7C,cAAD,CAAiB,EAD9C,EAER6C,KAAK,CAAC5C,QAAD,CAAL,IAAoB,OAAM4C,KAAK,CAAC5C,QAAD,CAAW,EAFlC,EAGRoD,MAHQ,CAGDC,OAHC,EAGQE,IAHR,CAGa,IAHb,CAAV;AAIA,UAAImB,CAAJ,EAAOT,MAAM,CAACE,IAAP,CAAY;AAAEC,QAAAA,SAAS,EAAE1D,IAAI,CAACQ,KAAlB;AAAyBmD,QAAAA,KAAK,EAAE;AAAEC,UAAAA,IAAI,EAAEI;AAAR;AAAhC,OAAZ;AACR,KA9DC,CAgEF;;;AACA,QAAIhE,IAAI,CAACU,EAAL,IAAWwB,KAAK,CAAC3C,SAAD,CAApB,EAAiC;AAC/BgE,MAAAA,MAAM,CAACE,IAAP,CAAY;AAAEC,QAAAA,SAAS,EAAE1D,IAAI,CAACU,EAAlB;AAAsBiD,QAAAA,KAAK,EAAE;AAAEC,UAAAA,IAAI,EAAG,OAAM1B,KAAK,CAAC3C,SAAD,CAAY;AAAhC;AAA7B,OAAZ;AACD,KAnEC,CAqEF;;;AACA,QAAIS,IAAI,CAACY,GAAL,IAAYsB,KAAK,CAAC1C,OAAD,CAArB,EAAgC;AAC9B+D,MAAAA,MAAM,CAACE,IAAP,CAAY;AAAEC,QAAAA,SAAS,EAAE1D,IAAI,CAACY,GAAlB;AAAuB+C,QAAAA,KAAK,EAAE;AAAEC,UAAAA,IAAI,EAAE1B,KAAK,CAAC1C,OAAD;AAAb;AAA9B,OAAZ;AACD,KAxEC,CA0EF;AACA;AACA;AACA;;;AAEA,QAAI+D,MAAM,CAACU,MAAX,EAAmB;AACjB,YAAMC,GAAG,GAAG,MAAMxC,KAAK,CAAC,yBAAD,EAA4B;AACjDsB,QAAAA,OAAO,EAAEvB,GAAG,CAAC3B,EADoC;AAEjDqE,QAAAA,OAAO,EAAEf,MAFwC;AAGjDG,QAAAA;AAHiD,OAA5B,CAAvB;;AAMA,UAAI,EAACW,GAAD,aAACA,GAAD,eAACA,GAAG,CAAE3F,EAAN,CAAJ,EAAc;AACZ;AACA,eAAOJ,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,UAAAA,EAAE,EAAE,IADsB;AAE1B2E,UAAAA,IAAI,EAAE,MAFoB;AAG1BF,UAAAA,OAAO,EAAEvB,GAAG,CAAC3B,EAHa;AAI1BqE,UAAAA,OAAO,EAAEf,MAJiB;AAK1BgB,UAAAA,UAAU,EAAEtB,SALc;AAM1BuB,UAAAA,IAAI,EAAE,CAAAH,GAAG,SAAH,IAAAA,GAAG,WAAH,YAAAA,GAAG,CAAE1F,KAAL,KAAc;AANM,SAArB,CAAP;AAQD;AACF,KAjGC,CAmGF;;;AACA,WAAOL,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,MAAAA,EAAE,EAAE,IADsB;AAE1B2E,MAAAA,IAAI,EAAE,MAFoB;AAG1BF,MAAAA,OAAO,EAAEvB,GAAG,CAAC3B,EAHa;AAI1BqE,MAAAA,OAAO,EAAEf,MAJiB;AAK1BgB,MAAAA,UAAU,EAAEtB;AALc,KAArB,CAAP;AAOD,GA3GD,CA2GE,OAAOwB,GAAP,EAAY;AACZC,IAAAA,OAAO,CAAC/F,KAAR,CAAc,iCAAd,EAAiD8F,GAAjD;AACA,WAAOnG,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE,WAApB;AAAiCgG,MAAAA,OAAO,EAAE,CAAAF,GAAG,SAAH,IAAAA,GAAG,WAAH,YAAAA,GAAG,CAAEE,OAAL,KAAgBC,MAAM,CAACH,GAAD;AAAhE,KAArB,CAAP;AACD;AACF","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   if (req.method !== \"POST\") {\r\n//     return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//   }\r\n\r\n//   const token = process.env.SLACK_BOT_TOKEN;\r\n//   if (!token) {\r\n//     return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//   }\r\n\r\n//   // ---- Payload from client (your UI already sends these) ----\r\n//   const {\r\n//     listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\r\n//     title,              // the thing we want to show in the Task column\r\n//     linkUrl, bodyText,\r\n//     date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n//     photoUrls = [],\r\n//   } = req.body || {};\r\n\r\n//   // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\r\n//   const LISTS = {\r\n//     tasks: {\r\n//       id: process.env.SLACK_LIST_TASKS_ID,\r\n//       // OPTIONAL: if you know the \"Task\" column id already\r\n//       titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\r\n//       cols: {\r\n//         desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\r\n//       },\r\n//     },\r\n//     shipping: {\r\n//       id: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\r\n//       cols: {\r\n//         desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\r\n//         date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\r\n//         pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\r\n//         track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\r\n//         wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\r\n//         lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\r\n//         photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\r\n//       },\r\n//     },\r\n//     receiving: {\r\n//       id: process.env.SLACK_LIST_RECEIVING_ID,\r\n//       titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\r\n//       cols: {\r\n//         desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\r\n//         date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\r\n//         pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\r\n//         track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\r\n//         wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\r\n//         lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\r\n//         photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\r\n//       },\r\n//     },\r\n//   };\r\n\r\n//   const cfg = LISTS[listKey];\r\n//   if (!cfg?.id) {\r\n//     return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\r\n//   }\r\n\r\n//   // ---- Slack helpers ----\r\n//   async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\r\n//     const r = await fetch(`https://slack.com/api/${method}`, {\r\n//       method: \"POST\",\r\n//       headers: { Authorization: `Bearer ${token}`, ...headers },\r\n//       body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\r\n//     });\r\n//     return r.json();\r\n//   }\r\n\r\n//   const plain = (v) => (v ?? \"\").toString().trim();\r\n//   const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//   // Never send an empty title\r\n//   const safeTitle =\r\n//     plain(title) ||\r\n//     (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\r\n//     joinArr(pn) ||\r\n//     \"New Item\";\r\n\r\n//   // Convert plain text to Slack rich_text for text columns\r\n//   function toRichText(text) {\r\n//     return [{\r\n//       type: \"rich_text\",\r\n//       elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\r\n//     }];\r\n//   }\r\n\r\n//   // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\r\n//   async function resolveTitleColumnId(listId, provided) {\r\n//     if (provided) return { colId: provided, source: \"env\" };\r\n\r\n//     const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//     if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\r\n\r\n//     let candidate = null;\r\n//     for (const item of probe.items || []) {\r\n//       for (const f of item.fields || []) {\r\n//         const key = (f.key || \"\").trim().toLowerCase();\r\n//         const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\r\n//         if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\r\n//         if (!candidate && f.column_id && hasText) candidate = f.column_id;\r\n//       }\r\n//     }\r\n//     return { colId: candidate, source: \"auto:first_text\" };\r\n//   }\r\n\r\n//   try {\r\n//     // 1) Find the column to write the Task name into; fall back to top-level title\r\n//     const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\r\n\r\n//     const createBody = {\r\n//       list_id: cfg.id,\r\n//       ...(titleCol.colId\r\n//         ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\r\n//         : { title: safeTitle }), // fallback if we couldn’t resolve a column\r\n//     };\r\n\r\n//     const created = await slack(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 2) (Optional) Patch other columns you actually have IDs for\r\n//     const fields = [];\r\n//     const cols = cfg.cols || {};\r\n//     const addText = (colId, text) => {\r\n//       const t = plain(text);\r\n//       if (colId && t) fields.push({ column_id: colId, value: { text: t } });\r\n//     };\r\n\r\n//     // Description / Notes column (for tasks we include your assembled bodyText)\r\n//     if (cols.desc) {\r\n//       const bits = [\r\n//         plain(description),\r\n//         listKey === \"tasks\" ? plain(bodyText) : \"\",\r\n//         plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\r\n//       ].filter(Boolean).join(\"\\n\");\r\n//       addText(cols.desc, bits);\r\n//     }\r\n\r\n//     // Dates and grouped PN/SN/DOM example\r\n//     if (cols.date && plain(date)) fields.push({ column_id: cols.date, value: { date: plain(date) } });\r\n//     if (cols.pn) {\r\n//       const pnStr = joinArr(pn), snStr = joinArr(sn);\r\n//       const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`]\r\n//         .filter(Boolean).join(\"  \");\r\n//       addText(cols.pn, combo);\r\n//     }\r\n//     if (cols.track) {\r\n//       const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`]\r\n//         .filter(Boolean).join(\"  \");\r\n//       addText(cols.track, t);\r\n//     }\r\n//     if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\r\n//     if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\r\n\r\n//     if (fields.length) {\r\n//       await slack(\"slackLists.items.update\", { list_id: cfg.id, item_id: created.item.id, fields });\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id: cfg.id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleCol.colId || null,\r\n//       title_col_source: titleCol.source || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\n// Scopes needed: lists:write (lists:read is optional if you want to auto-detect columns)\r\nexport default async function handler(req, res) {\r\n  if (req.method !== \"POST\") {\r\n    return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n  }\r\n\r\n  const token = process.env.SLACK_BOT_TOKEN;\r\n  if (!token) {\r\n    return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n  }\r\n\r\n  // ---- Payload from client (your UI already sends these) ----\r\n  const {\r\n    listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\r\n    title,              // text for the left-most Item/Task column\r\n    linkUrl,            // item deep-link back to your app (optional)\r\n    bodyText,           // multi-line blob used in Tasks description (optional)\r\n\r\n    // shipping/receiving fields\r\n    date,               // YYYY-MM-DD (your \"arrival_date\")\r\n    pn,                 // string | string[]\r\n    sn,                 // string | string[]\r\n    dom,                // string (optional)\r\n    trackingNumber,     // \"RL\" value\r\n    poNumber,           // PO number\r\n    workOrder,          // WO number\r\n    localSN,            // your item ID\r\n    description,        // inline human description\r\n    photoUrls = [],     // currently unused for Lists (kept for future)\r\n  } = req.body || {};\r\n\r\n  // ---- Lists & Column IDs (only list IDs are strictly required) ----\r\n  const LISTS = {\r\n    tasks: {\r\n      id: process.env.SLACK_LIST_TASKS_ID,\r\n      cols: {\r\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\r\n      },\r\n    },\r\n    shipping: {\r\n      id: process.env.SLACK_LIST_SHIPPING_ID,\r\n      cols: {\r\n        desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\r\n        date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\r\n        pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\r\n        track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\r\n        wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\r\n        lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\r\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null, // optional\r\n      },\r\n    },\r\n    receiving: {\r\n      id: process.env.SLACK_LIST_RECEIVING_ID,\r\n      cols: {\r\n        desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\r\n        date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\r\n        pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\r\n        track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\r\n        wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\r\n        lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\r\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null, // optional\r\n      },\r\n    },\r\n  };\r\n\r\n  const cfg = LISTS[listKey];\r\n  if (!cfg?.id) {\r\n    return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\r\n  }\r\n\r\n  // ---- Slack helper ----\r\n  async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\r\n    const r = await fetch(`https://slack.com/api/${method}`, {\r\n      method: \"POST\",\r\n      headers: { Authorization: `Bearer ${token}`, ...headers },\r\n      body: JSON.stringify(payload),\r\n    });\r\n    return r.json();\r\n  }\r\n\r\n  const plain = (v) => (v ?? \"\").toString().trim();\r\n  const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n  // Build a safe, never-empty title for Slack’s primary column\r\n  const safeTitle =\r\n    plain(title) ||\r\n    (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\r\n    joinArr(pn) ||\r\n    \"New Item\";\r\n\r\n  try {\r\n    // 1) Create the row with ONLY the title. (This is why you see the name right now.)\r\n    const createBody = { list_id: cfg.id, title: safeTitle };\r\n    const created = await slack(\"slackLists.items.create\", createBody);\r\n\r\n    if (!created?.ok) {\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: created?.error || \"create_failed\",\r\n        mode: \"list\",\r\n        sent: createBody,\r\n      });\r\n    }\r\n\r\n    const itemId = created?.item?.id || created?.id;\r\n    if (!itemId) {\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: \"missing_item_id_after_create\",\r\n        mode: \"list\",\r\n        raw: created,\r\n      });\r\n    }\r\n\r\n    // 2) Patch additional columns (ONLY if those column IDs exist in env)\r\n    const fields = [];\r\n    const cols = cfg.cols || {};\r\n\r\n    // Description column: include your description; for Tasks also include the assembled bodyText; include link\r\n    if (cols.desc) {\r\n      const bits = [\r\n        plain(description),\r\n        (listKey === \"tasks\" ? plain(bodyText) : \"\"),\r\n        plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\r\n      ].filter(Boolean).join(\"\\n\");\r\n      if (bits) fields.push({ column_id: cols.desc, value: { text: bits } });\r\n    }\r\n\r\n    // Date\r\n    if (cols.date && plain(date)) {\r\n      fields.push({ column_id: cols.date, value: { date: plain(date) } });\r\n    }\r\n\r\n    // PN / SN / DOM grouped on one line\r\n    if (cols.pn) {\r\n      const pnStr = joinArr(pn);\r\n      const snStr = joinArr(sn);\r\n      const combo = [\r\n        pnStr && `PN: ${pnStr}`,\r\n        snStr && `SN: ${snStr}`,\r\n        plain(dom) && `DOM: ${plain(dom)}`\r\n      ].filter(Boolean).join(\"  \");\r\n      if (combo) fields.push({ column_id: cols.pn, value: { text: combo } });\r\n    }\r\n\r\n    // Tracking + PO grouped in the same column (your UI shows them together)\r\n    if (cols.track) {\r\n      const t = [\r\n        plain(trackingNumber) && `RL: ${plain(trackingNumber)}`,\r\n        plain(poNumber) && `PO: ${plain(poNumber)}`,\r\n      ].filter(Boolean).join(\"  \");\r\n      if (t) fields.push({ column_id: cols.track, value: { text: t } });\r\n    }\r\n\r\n    // WO\r\n    if (cols.wo && plain(workOrder)) {\r\n      fields.push({ column_id: cols.wo, value: { text: `WO: ${plain(workOrder)}` } });\r\n    }\r\n\r\n    // Local SN (your internal ID)\r\n    if (cols.lsn && plain(localSN)) {\r\n      fields.push({ column_id: cols.lsn, value: { text: plain(localSN) } });\r\n    }\r\n\r\n    // (Optional) Photos column — Slack Lists attachments are a separate thing; safest to skip unless you know its type.\r\n    // if (cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\r\n    //   fields.push({ column_id: cols.photos, value: { text: photoUrls.join(\"\\n\") } });\r\n    // }\r\n\r\n    if (fields.length) {\r\n      const upd = await slack(\"slackLists.items.update\", {\r\n        list_id: cfg.id,\r\n        item_id: itemId,\r\n        fields,\r\n      });\r\n\r\n      if (!upd?.ok) {\r\n        // Still return ok=true so at least the title exists, but surface the update error for debugging\r\n        return res.status(200).json({\r\n          ok: true,\r\n          mode: \"list\",\r\n          list_id: cfg.id,\r\n          item_id: itemId,\r\n          sent_title: safeTitle,\r\n          warn: upd?.error || \"update_failed\",\r\n        });\r\n      }\r\n    }\r\n\r\n    // 3) Done\r\n    return res.status(200).json({\r\n      ok: true,\r\n      mode: \"list\",\r\n      list_id: cfg.id,\r\n      item_id: itemId,\r\n      sent_title: safeTitle,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}