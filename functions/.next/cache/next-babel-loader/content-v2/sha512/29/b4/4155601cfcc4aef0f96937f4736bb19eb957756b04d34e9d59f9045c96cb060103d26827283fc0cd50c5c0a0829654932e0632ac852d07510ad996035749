{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\n//   try {\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\n//     const {\n//       listKey,            // \"receiving\" | \"shipping\" | \"tasks\"\n//       title, linkUrl, bodyText,\n//       date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\n//       photoUrls = [],\n//     } = req.body;\n//     const LISTS = {\n//       receiving: {\n//         id: process.env.SLACK_LIST_RECEIVING_ID,\n//         cols: {\n//           desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n//           date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\n//           pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n//           track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n//           wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\n//           lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n//           photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // attachment\n//         },\n//       },\n//       shipping: {\n//         id: process.env.SLACK_LIST_SHIPPING_ID,\n//         cols: {\n//           desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n//           date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\n//           pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n//           track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n//           wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\n//           lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n//           photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,  // attachment\n//         },\n//       },\n//       tasks: {\n//         id: process.env.SLACK_LIST_TASKS_ID,\n//         cols: {\n//           desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\n//         },\n//       },\n//     };\n//     const CHANNELS = {\n//       receiving: process.env.SLACK_CHANNEL_RECEIVING_ID,\n//       shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,\n//       tasks:     process.env.SLACK_CHANNEL_TASKS_ID,\n//     };\n//     const headersJson = {\n//       Authorization: `Bearer ${token}`,\n//       \"Content-Type\": \"application/json; charset=utf-8\",\n//     };\n//     const slack = (method, body, headers = headersJson) =>\n//       fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body })\n//         .then(r => r.json());\n//     const plain = v => (v ?? \"\").toString().trim();\n//     const safe  = plain;\n//     const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     // ---------- PATH A: Write to a LIST ----------\n//     const cfg = LISTS[listKey];\n//     if (cfg?.id) {\n//       const fields = [];\n//       // Description column\n//       if (cfg.cols.desc && (description || bodyText || linkUrl)) {\n//         const textBits = [\n//           description,\n//           (listKey === \"tasks\" && bodyText) ? bodyText : null,\n//           linkUrl ? `<${linkUrl}|Open in Magmo>` : null,\n//         ].filter(Boolean).join(\"\\n\");\n//         fields.push({ column_id: cfg.cols.desc, value: { text: textBits } });\n//       }\n//       if (cfg.cols.date && date) fields.push({ column_id: cfg.cols.date, value: { date } });\n//       if (cfg.cols.pn && (pn || sn || dom)) {\n//         const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : (pn ? `PN: ${pn}` : \"\");\n//         const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : (sn ? `SN: ${sn}` : \"\");\n//         const domLine = dom ? `DOM: ${dom}` : \"\";\n//         const pnBlock = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\n//         if (pnBlock) fields.push({ column_id: cfg.cols.pn, value: { text: pnBlock } });\n//       }\n//       if (cfg.cols.track && (trackingNumber || poNumber)) {\n//         const t = [\n//           trackingNumber ? `RL: ${trackingNumber}` : \"\",\n//           poNumber ? `PO: ${poNumber}` : \"\",\n//         ].filter(Boolean).join(\"  \");\n//         if (t) fields.push({ column_id: cfg.cols.track, value: { text: t } });\n//       }\n//       if (cfg.cols.wo && workOrder) fields.push({ column_id: cfg.cols.wo,  value: { text: `WO: ${workOrder}` } });\n//       if (cfg.cols.lsn && localSN)  fields.push({ column_id: cfg.cols.lsn, value: { text: localSN } });\n//       // NOW build the create body (cfg & fields exist)\n//       const createBody = {\n//         list_id: cfg.id,\n//         title: plain(title) || plain(localSN) || \"Untitled\",\n//         fields,\n//       };\n//       const created = await slack(\"slackLists.items.create\", JSON.stringify(createBody));\n//       if (!created?.ok) {\n//         console.error(\"slackLists.items.create error:\", created);\n//         return res.status(400).json({ error: created?.error || \"Slack Lists API error\", raw: created });\n//       }\n//       // Photos -> attachment column\n//       if (cfg.cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\n//         const fileIds = [];\n//         for (const url of photoUrls) {\n//           const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\n//             method: \"POST\",\n//             headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\n//             body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\n//           }).then(r => r.json());\n//           if (!init?.ok || !init?.upload_url) continue;\n//           try {\n//             const img = await fetch(url);\n//             const buf = await img.arrayBuffer();\n//             await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\n//           } catch (_) {}\n//           const complete = await slack(\"files.completeUploadExternal\",\n//             JSON.stringify({ files: [{ id: init.file_id, title: \"photo\" }] })\n//           );\n//           if (complete?.ok && complete?.files?.[0]?.id) fileIds.push(complete.files[0].id);\n//         }\n//         if (fileIds.length) {\n//           await slack(\"slackLists.items.update\", JSON.stringify({\n//             list_id: cfg.id,\n//             item_id: created.item.id,\n//             fields: [{ column_id: cfg.cols.photos, value: { attachment: { file_ids: fileIds } } }],\n//           }));\n//         }\n//       }\n//       return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: created.item.id });\n//     }\n//     // ---------- PATH B: Fallback to a channel post ----------\n//     const channel = CHANNELS[listKey];\n//     if (!channel) return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\n//     // Try to join public channels to avoid channel_not_found\n//     await fetch(\"https://slack.com/api/conversations.join\", {\n//       method: \"POST\",\n//       headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\n//       body: new URLSearchParams({ channel }),\n//     });\n//     const safeId = plain(linkUrl?.split(\"/\").pop()) || plain(localSN) || \"\";\n//     const safeTitle = plain(title) || plain(req.body?.title) || (safeId ? `Item ${safeId}` : \"New Item\");\n//     const lines = [];\n//     lines.push(`*${safeTitle}*`);\n//     const pnStr = joinArr(pn);\n//     const snStr = joinArr(sn);\n//     if (pnStr) lines.push(`PN: ${pnStr}`);\n//     if (snStr) lines.push(`SN: ${snStr}`);\n//     if (safe(workOrder)) lines.push(`WO: ${safe(workOrder)}`);\n//     if (safe(poNumber)) lines.push(`PO: ${safe(poNumber)}`);\n//     if (safe(trackingNumber)) lines.push(`RL: ${safe(trackingNumber)}`);\n//     if (safe(dom)) lines.push(`DOM: ${safe(dom)}`);\n//     if (safe(localSN)) lines.push(`Local SN: ${safe(localSN)}`);\n//     if (safe(date)) lines.push(`Date: ${safe(date)}`);\n//     const desc = safe(description);\n//     if (desc) lines.push(desc);\n//     else if (listKey === \"tasks\" && safe(bodyText)) lines.push(safe(bodyText));\n//     if (safe(linkUrl)) lines.push(`<${safe(linkUrl)}|Open in Magmo>`);\n//     const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\n//     const posted = await slack(\"chat.postMessage\", JSON.stringify({ channel, text }));\n//     if (!posted?.ok) {\n//       console.error(\"chat.postMessage error:\", posted);\n//       return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\n//     }\n//     return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\n//   } catch (e) {\n//     console.error(\"API /slack/add-to-list crashed:\", e);\n//     return res.status(500).json({ error: \"Server error\" });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  if (req.method !== \"POST\") {\n    return res.status(405).json({\n      ok: false,\n      error: \"method_not_allowed\"\n    });\n  }\n\n  const token = process.env.SLACK_BOT_TOKEN;\n\n  if (!token) {\n    return res.status(500).json({\n      ok: false,\n      error: \"missing_SLACK_BOT_TOKEN\"\n    });\n  } // ---- Payload from client (your UI already sends these) ----\n\n\n  const {\n    listKey,\n    // \"tasks\" | \"shipping\" | \"receiving\"\n    title,\n    // the thing we want to show in the Task column\n    linkUrl,\n    bodyText,\n    date,\n    pn,\n    sn,\n    dom,\n    trackingNumber,\n    poNumber,\n    workOrder,\n    localSN,\n    description,\n    photoUrls = []\n  } = req.body || {}; // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\n\n  const LISTS = {\n    tasks: {\n      id: process.env.SLACK_LIST_TASKS_ID,\n      // OPTIONAL: if you know the \"Task\" column id already\n      titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\n      cols: {\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null\n      }\n    },\n    shipping: {\n      id: process.env.SLACK_LIST_SHIPPING_ID,\n      titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\n      cols: {\n        desc: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\n        date: process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\n        pn: process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\n        track: process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\n        wo: process.env.SLACK_LIST_SHIPPING_WO_COL || null,\n        lsn: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null\n      }\n    },\n    receiving: {\n      id: process.env.SLACK_LIST_RECEIVING_ID,\n      titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\n      cols: {\n        desc: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\n        date: process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\n        pn: process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\n        track: process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\n        wo: process.env.SLACK_LIST_RECEIVING_WO_COL || null,\n        lsn: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null\n      }\n    }\n  };\n  const cfg = LISTS[listKey];\n\n  if (!(cfg !== null && cfg !== void 0 && cfg.id)) {\n    return res.status(400).json({\n      ok: false,\n      error: `unknown_or_unconfigured_listKey_${listKey}`\n    });\n  } // ---- Slack helpers ----\n\n\n  async function slack(method, payload, headers = {\n    \"Content-Type\": \"application/json; charset=utf-8\"\n  }) {\n    const r = await fetch(`https://slack.com/api/${method}`, {\n      method: \"POST\",\n      headers: _objectSpread({\n        Authorization: `Bearer ${token}`\n      }, headers),\n      body: typeof payload === \"string\" ? payload : JSON.stringify(payload)\n    });\n    return r.json();\n  }\n\n  const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n  const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a); // Never send an empty title\n\n\n  const safeTitle = plain(title) || (plain(localSN) ? `Item ${plain(localSN)}` : \"\") || joinArr(pn) || \"New Item\"; // Convert plain text to Slack rich_text for text columns\n\n  function toRichText(text) {\n    return [{\n      type: \"rich_text\",\n      elements: [{\n        type: \"rich_text_section\",\n        elements: [{\n          type: \"text\",\n          text\n        }]\n      }]\n    }];\n  } // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\n\n\n  async function resolveTitleColumnId(listId, provided) {\n    if (provided) return {\n      colId: provided,\n      source: \"env\"\n    };\n    const probe = await slack(\"slackLists.items.list\", {\n      list_id: listId,\n      limit: 50\n    });\n    if (!(probe !== null && probe !== void 0 && probe.ok)) return {\n      colId: null,\n      source: \"auto\",\n      error: (probe === null || probe === void 0 ? void 0 : probe.error) || \"items.list_failed\"\n    };\n    let candidate = null;\n\n    for (const item of probe.items || []) {\n      for (const f of item.fields || []) {\n        const key = (f.key || \"\").trim().toLowerCase();\n        const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\n        if (key === \"task\" && f.column_id && hasText) return {\n          colId: f.column_id,\n          source: \"auto:key_task\"\n        };\n        if (!candidate && f.column_id && hasText) candidate = f.column_id;\n      }\n    }\n\n    return {\n      colId: candidate,\n      source: \"auto:first_text\"\n    };\n  }\n\n  try {\n    // 1) Find the column to write the Task name into; fall back to top-level title\n    const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\n\n    const createBody = _objectSpread({\n      list_id: cfg.id\n    }, titleCol.colId ? {\n      initial_fields: [{\n        column_id: titleCol.colId,\n        rich_text: toRichText(safeTitle)\n      }]\n    } : {\n      title: safeTitle\n    });\n\n    const created = await slack(\"slackLists.items.create\", createBody);\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(200).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\",\n        mode: \"list\",\n        sent: createBody\n      });\n    } // 2) (Optional) Patch other columns you actually have IDs for\n\n\n    const fields = [];\n    const cols = cfg.cols || {};\n\n    const addText = (colId, text) => {\n      const t = plain(text);\n      if (colId && t) fields.push({\n        column_id: colId,\n        value: {\n          text: t\n        }\n      });\n    }; // Description / Notes column (for tasks we include your assembled bodyText)\n\n\n    if (cols.desc) {\n      const bits = [plain(description), listKey === \"tasks\" ? plain(bodyText) : \"\", plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\"].filter(Boolean).join(\"\\n\");\n      addText(cols.desc, bits);\n    } // Dates and grouped PN/SN/DOM example\n\n\n    if (cols.date && plain(date)) fields.push({\n      column_id: cols.date,\n      value: {\n        date: plain(date)\n      }\n    });\n\n    if (cols.pn) {\n      const pnStr = joinArr(pn),\n            snStr = joinArr(sn);\n      const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`].filter(Boolean).join(\"  \");\n      addText(cols.pn, combo);\n    }\n\n    if (cols.track) {\n      const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`].filter(Boolean).join(\"  \");\n      addText(cols.track, t);\n    }\n\n    if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\n    if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\n\n    if (fields.length) {\n      await slack(\"slackLists.items.update\", {\n        list_id: cfg.id,\n        item_id: created.item.id,\n        fields\n      });\n    }\n\n    return res.status(200).json({\n      ok: true,\n      mode: \"list\",\n      list_id: cfg.id,\n      item_id: created.item.id,\n      used_title_col: titleCol.colId || null,\n      title_col_source: titleCol.source || null,\n      sent_title: safeTitle\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","linkUrl","bodyText","date","pn","sn","dom","trackingNumber","poNumber","workOrder","localSN","description","photoUrls","body","LISTS","tasks","id","SLACK_LIST_TASKS_ID","titleColId","SLACK_LIST_TASKS_TITLE_COL","cols","desc","SLACK_LIST_TASKS_DESCRIPTION_COL","shipping","SLACK_LIST_SHIPPING_ID","SLACK_LIST_SHIPPING_TITLE_COL","SLACK_LIST_SHIPPING_DESCRIPTION_COL","SLACK_LIST_SHIPPING_DATE_COL","SLACK_LIST_SHIPPING_PNSN_COL","track","SLACK_LIST_SHIPPING_TRACKING_COL","wo","SLACK_LIST_SHIPPING_WO_COL","lsn","SLACK_LIST_SHIPPING_LOCALSN_COL","photos","SLACK_LIST_SHIPPING_PHOTOS_COL","receiving","SLACK_LIST_RECEIVING_ID","SLACK_LIST_RECEIVING_TITLE_COL","SLACK_LIST_RECEIVING_DESCRIPTION_COL","SLACK_LIST_RECEIVING_DATE_COL","SLACK_LIST_RECEIVING_PNSN_COL","SLACK_LIST_RECEIVING_TRACKING_COL","SLACK_LIST_RECEIVING_WO_COL","SLACK_LIST_RECEIVING_LOCALSN_COL","SLACK_LIST_RECEIVING_PHOTOS_COL","cfg","slack","payload","headers","r","fetch","Authorization","JSON","stringify","plain","v","toString","trim","joinArr","a","Array","isArray","filter","Boolean","map","join","safeTitle","toRichText","text","type","elements","resolveTitleColumnId","listId","provided","colId","source","probe","list_id","limit","candidate","item","items","f","fields","key","toLowerCase","hasText","rich_text","column_id","titleCol","createBody","initial_fields","created","mode","sent","addText","t","push","value","bits","pnStr","snStr","combo","length","item_id","used_title_col","title_col_source","sent_title","err","console","message","String"],"mappings":";;;;;;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,WAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE;AAApB,KAArB,CAAP;AACD;;AAED,QAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;;AACA,MAAI,CAACH,KAAL,EAAY;AACV,WAAON,GAAG,CAACE,MAAJ,CAAW,GAAX,EAA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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\r\n\r\n//   try {\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\r\n\r\n//     const {\r\n//       listKey,            // \"receiving\" | \"shipping\" | \"tasks\"\r\n//       title, linkUrl, bodyText,\r\n//       date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n//       photoUrls = [],\r\n//     } = req.body;\r\n\r\n//     const LISTS = {\r\n//       receiving: {\r\n//         id: process.env.SLACK_LIST_RECEIVING_ID,\r\n//         cols: {\r\n//           desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n//           date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\r\n//           pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n//           track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n//           wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n//           lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n//           photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // attachment\r\n//         },\r\n//       },\r\n//       shipping: {\r\n//         id: process.env.SLACK_LIST_SHIPPING_ID,\r\n//         cols: {\r\n//           desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n//           date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\r\n//           pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n//           track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n//           wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n//           lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n//           photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,  // attachment\r\n//         },\r\n//       },\r\n//       tasks: {\r\n//         id: process.env.SLACK_LIST_TASKS_ID,\r\n//         cols: {\r\n//           desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\r\n//         },\r\n//       },\r\n//     };\r\n\r\n//     const CHANNELS = {\r\n//       receiving: process.env.SLACK_CHANNEL_RECEIVING_ID,\r\n//       shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,\r\n//       tasks:     process.env.SLACK_CHANNEL_TASKS_ID,\r\n//     };\r\n\r\n//     const headersJson = {\r\n//       Authorization: `Bearer ${token}`,\r\n//       \"Content-Type\": \"application/json; charset=utf-8\",\r\n//     };\r\n//     const slack = (method, body, headers = headersJson) =>\r\n//       fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body })\r\n//         .then(r => r.json());\r\n\r\n//     const plain = v => (v ?? \"\").toString().trim();\r\n//     const safe  = plain;\r\n//     const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     // ---------- PATH A: Write to a LIST ----------\r\n//     const cfg = LISTS[listKey];\r\n//     if (cfg?.id) {\r\n//       const fields = [];\r\n\r\n//       // Description column\r\n//       if (cfg.cols.desc && (description || bodyText || linkUrl)) {\r\n//         const textBits = [\r\n//           description,\r\n//           (listKey === \"tasks\" && bodyText) ? bodyText : null,\r\n//           linkUrl ? `<${linkUrl}|Open in Magmo>` : null,\r\n//         ].filter(Boolean).join(\"\\n\");\r\n//         fields.push({ column_id: cfg.cols.desc, value: { text: textBits } });\r\n//       }\r\n\r\n//       if (cfg.cols.date && date) fields.push({ column_id: cfg.cols.date, value: { date } });\r\n\r\n//       if (cfg.cols.pn && (pn || sn || dom)) {\r\n//         const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : (pn ? `PN: ${pn}` : \"\");\r\n//         const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : (sn ? `SN: ${sn}` : \"\");\r\n//         const domLine = dom ? `DOM: ${dom}` : \"\";\r\n//         const pnBlock = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\r\n//         if (pnBlock) fields.push({ column_id: cfg.cols.pn, value: { text: pnBlock } });\r\n//       }\r\n\r\n//       if (cfg.cols.track && (trackingNumber || poNumber)) {\r\n//         const t = [\r\n//           trackingNumber ? `RL: ${trackingNumber}` : \"\",\r\n//           poNumber ? `PO: ${poNumber}` : \"\",\r\n//         ].filter(Boolean).join(\"  \");\r\n//         if (t) fields.push({ column_id: cfg.cols.track, value: { text: t } });\r\n//       }\r\n\r\n//       if (cfg.cols.wo && workOrder) fields.push({ column_id: cfg.cols.wo,  value: { text: `WO: ${workOrder}` } });\r\n//       if (cfg.cols.lsn && localSN)  fields.push({ column_id: cfg.cols.lsn, value: { text: localSN } });\r\n\r\n//       // NOW build the create body (cfg & fields exist)\r\n//       const createBody = {\r\n//         list_id: cfg.id,\r\n//         title: plain(title) || plain(localSN) || \"Untitled\",\r\n//         fields,\r\n//       };\r\n\r\n//       const created = await slack(\"slackLists.items.create\", JSON.stringify(createBody));\r\n//       if (!created?.ok) {\r\n//         console.error(\"slackLists.items.create error:\", created);\r\n//         return res.status(400).json({ error: created?.error || \"Slack Lists API error\", raw: created });\r\n//       }\r\n\r\n//       // Photos -> attachment column\r\n//       if (cfg.cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\r\n//         const fileIds = [];\r\n//         for (const url of photoUrls) {\r\n//           const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\r\n//             method: \"POST\",\r\n//             headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n//             body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\r\n//           }).then(r => r.json());\r\n\r\n//           if (!init?.ok || !init?.upload_url) continue;\r\n\r\n//           try {\r\n//             const img = await fetch(url);\r\n//             const buf = await img.arrayBuffer();\r\n//             await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\r\n//           } catch (_) {}\r\n\r\n//           const complete = await slack(\"files.completeUploadExternal\",\r\n//             JSON.stringify({ files: [{ id: init.file_id, title: \"photo\" }] })\r\n//           );\r\n//           if (complete?.ok && complete?.files?.[0]?.id) fileIds.push(complete.files[0].id);\r\n//         }\r\n\r\n//         if (fileIds.length) {\r\n//           await slack(\"slackLists.items.update\", JSON.stringify({\r\n//             list_id: cfg.id,\r\n//             item_id: created.item.id,\r\n//             fields: [{ column_id: cfg.cols.photos, value: { attachment: { file_ids: fileIds } } }],\r\n//           }));\r\n//         }\r\n//       }\r\n\r\n//       return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: created.item.id });\r\n//     }\r\n\r\n//     // ---------- PATH B: Fallback to a channel post ----------\r\n//     const channel = CHANNELS[listKey];\r\n//     if (!channel) return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\r\n\r\n//     // Try to join public channels to avoid channel_not_found\r\n//     await fetch(\"https://slack.com/api/conversations.join\", {\r\n//       method: \"POST\",\r\n//       headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n//       body: new URLSearchParams({ channel }),\r\n//     });\r\n\r\n//     const safeId = plain(linkUrl?.split(\"/\").pop()) || plain(localSN) || \"\";\r\n//     const safeTitle = plain(title) || plain(req.body?.title) || (safeId ? `Item ${safeId}` : \"New Item\");\r\n\r\n//     const lines = [];\r\n//     lines.push(`*${safeTitle}*`);\r\n\r\n//     const pnStr = joinArr(pn);\r\n//     const snStr = joinArr(sn);\r\n//     if (pnStr) lines.push(`PN: ${pnStr}`);\r\n//     if (snStr) lines.push(`SN: ${snStr}`);\r\n//     if (safe(workOrder)) lines.push(`WO: ${safe(workOrder)}`);\r\n//     if (safe(poNumber)) lines.push(`PO: ${safe(poNumber)}`);\r\n//     if (safe(trackingNumber)) lines.push(`RL: ${safe(trackingNumber)}`);\r\n//     if (safe(dom)) lines.push(`DOM: ${safe(dom)}`);\r\n//     if (safe(localSN)) lines.push(`Local SN: ${safe(localSN)}`);\r\n//     if (safe(date)) lines.push(`Date: ${safe(date)}`);\r\n\r\n//     const desc = safe(description);\r\n//     if (desc) lines.push(desc);\r\n//     else if (listKey === \"tasks\" && safe(bodyText)) lines.push(safe(bodyText));\r\n\r\n//     if (safe(linkUrl)) lines.push(`<${safe(linkUrl)}|Open in Magmo>`);\r\n\r\n//     const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\r\n\r\n//     const posted = await slack(\"chat.postMessage\", JSON.stringify({ channel, text }));\r\n//     if (!posted?.ok) {\r\n//       console.error(\"chat.postMessage error:\", posted);\r\n//       return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\r\n//     }\r\n\r\n//     return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\r\n//   } catch (e) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", e);\r\n//     return res.status(500).json({ error: \"Server error\" });\r\n//   }\r\n// }\r\n\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  if (req.method !== \"POST\") {\r\n    return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n  }\r\n\r\n  const token = process.env.SLACK_BOT_TOKEN;\r\n  if (!token) {\r\n    return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n  }\r\n\r\n  // ---- Payload from client (your UI already sends these) ----\r\n  const {\r\n    listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\r\n    title,              // the thing we want to show in the Task column\r\n    linkUrl, bodyText,\r\n    date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n    photoUrls = [],\r\n  } = req.body || {};\r\n\r\n  // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\r\n  const LISTS = {\r\n    tasks: {\r\n      id: process.env.SLACK_LIST_TASKS_ID,\r\n      // OPTIONAL: if you know the \"Task\" column id already\r\n      titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\r\n      cols: {\r\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\r\n      },\r\n    },\r\n    shipping: {\r\n      id: process.env.SLACK_LIST_SHIPPING_ID,\r\n      titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\r\n      cols: {\r\n        desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\r\n        date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\r\n        pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\r\n        track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\r\n        wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\r\n        lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\r\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\r\n      },\r\n    },\r\n    receiving: {\r\n      id: process.env.SLACK_LIST_RECEIVING_ID,\r\n      titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\r\n      cols: {\r\n        desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\r\n        date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\r\n        pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\r\n        track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\r\n        wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\r\n        lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\r\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\r\n      },\r\n    },\r\n  };\r\n\r\n  const cfg = LISTS[listKey];\r\n  if (!cfg?.id) {\r\n    return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\r\n  }\r\n\r\n  // ---- Slack helpers ----\r\n  async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\r\n    const r = await fetch(`https://slack.com/api/${method}`, {\r\n      method: \"POST\",\r\n      headers: { Authorization: `Bearer ${token}`, ...headers },\r\n      body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\r\n    });\r\n    return r.json();\r\n  }\r\n\r\n  const plain = (v) => (v ?? \"\").toString().trim();\r\n  const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n  // Never send an empty title\r\n  const safeTitle =\r\n    plain(title) ||\r\n    (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\r\n    joinArr(pn) ||\r\n    \"New Item\";\r\n\r\n  // Convert plain text to Slack rich_text for text columns\r\n  function toRichText(text) {\r\n    return [{\r\n      type: \"rich_text\",\r\n      elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\r\n    }];\r\n  }\r\n\r\n  // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\r\n  async function resolveTitleColumnId(listId, provided) {\r\n    if (provided) return { colId: provided, source: \"env\" };\r\n\r\n    const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n    if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\r\n\r\n    let candidate = null;\r\n    for (const item of probe.items || []) {\r\n      for (const f of item.fields || []) {\r\n        const key = (f.key || \"\").trim().toLowerCase();\r\n        const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\r\n        if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\r\n        if (!candidate && f.column_id && hasText) candidate = f.column_id;\r\n      }\r\n    }\r\n    return { colId: candidate, source: \"auto:first_text\" };\r\n  }\r\n\r\n  try {\r\n    // 1) Find the column to write the Task name into; fall back to top-level title\r\n    const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\r\n\r\n    const createBody = {\r\n      list_id: cfg.id,\r\n      ...(titleCol.colId\r\n        ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\r\n        : { title: safeTitle }), // fallback if we couldn’t resolve a column\r\n    };\r\n\r\n    const created = await slack(\"slackLists.items.create\", createBody);\r\n    if (!created?.ok) {\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: created?.error || \"create_failed\",\r\n        mode: \"list\",\r\n        sent: createBody,\r\n      });\r\n    }\r\n\r\n    // 2) (Optional) Patch other columns you actually have IDs for\r\n    const fields = [];\r\n    const cols = cfg.cols || {};\r\n    const addText = (colId, text) => {\r\n      const t = plain(text);\r\n      if (colId && t) fields.push({ column_id: colId, value: { text: t } });\r\n    };\r\n\r\n    // Description / Notes column (for tasks we include your assembled bodyText)\r\n    if (cols.desc) {\r\n      const bits = [\r\n        plain(description),\r\n        listKey === \"tasks\" ? plain(bodyText) : \"\",\r\n        plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\r\n      ].filter(Boolean).join(\"\\n\");\r\n      addText(cols.desc, bits);\r\n    }\r\n\r\n    // Dates and grouped PN/SN/DOM example\r\n    if (cols.date && plain(date)) fields.push({ column_id: cols.date, value: { date: plain(date) } });\r\n    if (cols.pn) {\r\n      const pnStr = joinArr(pn), snStr = joinArr(sn);\r\n      const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`]\r\n        .filter(Boolean).join(\"  \");\r\n      addText(cols.pn, combo);\r\n    }\r\n    if (cols.track) {\r\n      const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`]\r\n        .filter(Boolean).join(\"  \");\r\n      addText(cols.track, t);\r\n    }\r\n    if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\r\n    if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\r\n\r\n    if (fields.length) {\r\n      await slack(\"slackLists.items.update\", { list_id: cfg.id, item_id: created.item.id, fields });\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      mode: \"list\",\r\n      list_id: cfg.id,\r\n      item_id: created.item.id,\r\n      used_title_col: titleCol.colId || null,\r\n      title_col_source: titleCol.source || null,\r\n      sent_title: safeTitle,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}