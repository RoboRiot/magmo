{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  try {\n    var _createdTry$created, _createdTry$created$i, _updated3, _updated4;\n\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n\n    if (!token) {\n      return res.status(500).json({\n        ok: false,\n        error: \"missing_SLACK_BOT_TOKEN\"\n      });\n    } // ===== Body (built from the item itself on the client) =====\n    // listKey: \"tasks\" | \"shipping\" | \"receiving\"\n    // title:   main row title (item name + optional (AISxxxxx))\n    // pn, sn:  string or [string,...]  -> combined as \"PN: ...\\nSN: ...\"\n    // workOrder, localSN, tracking, shippingDate (YYYY-MM-DD or free text)\n    // description: free text (condition/notes for receiving; details for tasks/shipping)\n    // linkUrl:     URL back to your app's item page (optional; we append to description/title)\n    // photoUrls:   [url,...] (optional; we put them as text if an attachment column isn't configured)\n\n\n    const {\n      listKey,\n      title,\n      pn,\n      sn,\n      workOrder,\n      localSN,\n      tracking,\n      shippingDate,\n      description,\n      linkUrl,\n      photoUrls = []\n    } = req.body || {}; // ===== Per-list config from env (column IDs you collected) =====\n\n    const cfg = {\n      tasks: {\n        list_id: process.env.SLACK_LIST_TASKS_ID,\n        title_col: process.env.SLACK_LIST_TASKS_TITLE_COL,\n        description_col: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL\n      },\n      shipping: {\n        list_id: process.env.SLACK_LIST_SHIPPING_ID,\n        title_col: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\n        description_col: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n        date_col: process.env.SLACK_LIST_SHIPPING_DATE_COL,\n        pnsn_col: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n        tracking_col: process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n        wo_col: process.env.SLACK_LIST_SHIPPING_WO_COL,\n        localsn_col: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n        photos_col: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL // we write URLs as text\n\n      },\n      receiving: {\n        list_id: process.env.SLACK_LIST_RECEIVING_ID,\n        title_col: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\n        description_col: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n        date_col: process.env.SLACK_LIST_RECEIVING_DATE_COL,\n        pnsn_col: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n        tracking_col: process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n        wo_col: process.env.SLACK_LIST_RECEIVING_WO_COL,\n        localsn_col: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n        photos_col: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL // we write URLs as text\n\n      }\n    }[listKey || \"\"];\n    console.log('ENV title cols present? ', {\n      tasks: !!process.env.SLACK_LIST_TASKS_TITLE_COL,\n      shipping: !!process.env.SLACK_LIST_SHIPPING_TITLE_COL,\n      receiving: !!process.env.SLACK_LIST_RECEIVING_TITLE_COL\n    });\n\n    if (!(cfg !== null && cfg !== void 0 && cfg.list_id)) {\n      return res.status(400).json({\n        ok: false,\n        error: `unknown_listKey_${listKey}`\n      });\n    } // ===== Helpers =====\n\n\n    async function slackJson(method, payload) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(payload)\n      });\n      return r.json();\n    }\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const first = x => Array.isArray(x) ? x.find(Boolean) || \"\" : plain(x); // Rich text object Slack usually accepts\n\n\n    const toRichText = text => ({\n      type: \"rich_text\",\n      elements: [{\n        type: \"rich_text_section\",\n        elements: [{\n          type: \"text\",\n          text: plain(text)\n        }]\n      }]\n    }); // Try create: rich_text → text\n\n\n    async function createRowWithTitle(list_id, title_col, textValue) {\n      var _r, _r2, _r4;\n\n      const safeTitle = plain(textValue) || \"New Item\"; // 1) rich_text\n\n      let r = await slackJson(\"slackLists.items.create\", {\n        list_id,\n        initial_fields: [{\n          column_id: title_col,\n          rich_text: toRichText(safeTitle)\n        }]\n      });\n      if ((_r = r) !== null && _r !== void 0 && _r.ok) return {\n        ok: true,\n        created: r,\n        mode: \"rich_text\"\n      }; // 2) text fallback (Slack sometimes wants plain text)\n\n      if (((_r2 = r) === null || _r2 === void 0 ? void 0 : _r2.error) === \"invalid_arguments\") {\n        var _r3;\n\n        r = await slackJson(\"slackLists.items.create\", {\n          list_id,\n          initial_fields: [{\n            column_id: title_col,\n            text: safeTitle\n          }]\n        });\n        if ((_r3 = r) !== null && _r3 !== void 0 && _r3.ok) return {\n          ok: true,\n          created: r,\n          mode: \"text\"\n        };\n      }\n\n      return {\n        ok: false,\n        error: ((_r4 = r) === null || _r4 === void 0 ? void 0 : _r4.error) || \"create_failed\",\n        last: r\n      };\n    }\n\n    function pushTextCell(cells, row_id, column_id, value) {\n      if (!column_id) return;\n      const v = plain(value);\n      if (!v) return;\n      cells.push({\n        row_id,\n        column_id,\n        text: v\n      });\n    }\n\n    function pushRichCell(cells, row_id, column_id, value) {\n      if (!column_id) return;\n      const v = plain(value);\n      if (!v) return;\n      cells.push({\n        row_id,\n        column_id,\n        rich_text: toRichText(v)\n      });\n    } // ===== Title (create the row) =====\n    // If we have a linkUrl and no description column, we append URL to the title\n\n\n    const linkSuffix = linkUrl ? ` — ${linkUrl}` : \"\";\n    const titleForCreate = plain(title) || (localSN ? `Item (${localSN})` : \"New Item\");\n\n    if (!cfg.title_col) {\n      // If somehow title_col is missing, abort early with a helpful message.\n      return res.status(400).json({\n        ok: false,\n        error: \"missing_title_column_in_env\",\n        fix: `Set ${listKey.toUpperCase()} title column in .env.local (e.g. SLACK_LIST_${listKey.toUpperCase()}_TITLE_COL)`\n      });\n    }\n\n    const createdTry = await createRowWithTitle(cfg.list_id, cfg.title_col, titleForCreate + (!cfg.description_col ? linkSuffix : \"\"));\n\n    if (!createdTry.ok) {\n      return res.status(200).json({\n        ok: false,\n        error: \"title_create_failed\",\n        mode: \"list\",\n        detail: createdTry.error,\n        last_response: createdTry.last || null,\n        list_id: cfg.list_id,\n        title_col: cfg.title_col,\n        sent_title: titleForCreate\n      });\n    }\n\n    const itemId = (_createdTry$created = createdTry.created) === null || _createdTry$created === void 0 ? void 0 : (_createdTry$created$i = _createdTry$created.item) === null || _createdTry$created$i === void 0 ? void 0 : _createdTry$created$i.id; // ===== Build cell updates from the item data =====\n\n    const cells = [];\n    const pn0 = first(pn);\n    const sn0 = first(sn);\n    const pnSnText = [pn0 && `PN: ${pn0}`, sn0 && `SN: ${sn0}`].filter(Boolean).join(\"\\n\"); // Prefer rich_text for text-like columns; Slack accepts both. If it ever fails, Slack will return ok:false and we’ll try again below with text.\n\n    const addCellRT = (colId, value) => pushRichCell(cells, itemId, colId, value);\n\n    const addCellText = (colId, value) => pushTextCell(cells, itemId, colId, value); // Description (+ include link inside description if available)\n\n\n    if (cfg.description_col) {\n      const descWithLink = description && linkUrl ? `${description}\\nLink: ${linkUrl}` : description || (linkUrl ? `Link: ${linkUrl}` : \"\");\n      addCellRT(cfg.description_col, descWithLink);\n    } // PN/SN\n\n\n    if (cfg.pnsn_col && pnSnText) addCellRT(cfg.pnsn_col, pnSnText); // Work order\n\n    if (cfg.wo_col && workOrder) addCellRT(cfg.wo_col, workOrder); // Local SN (AISxxxxx)\n\n    if (cfg.localsn_col && localSN) addCellRT(cfg.localsn_col, localSN); // Tracking / Airbill\n\n    if (cfg.tracking_col && tracking) addCellRT(cfg.tracking_col, tracking); // Date\n\n    if (cfg.date_col && shippingDate) addCellRT(cfg.date_col, shippingDate); // Photos (we write URLs as text lines; attachments API for Lists isn’t public yet)\n\n    if (cfg.photos_col && photoUrls !== null && photoUrls !== void 0 && photoUrls.length) {\n      const urlsBlock = photoUrls.map(plain).filter(Boolean).join(\"\\n\");\n      if (urlsBlock) addCellText(cfg.photos_col, urlsBlock);\n    } // ===== Send one update with all cells (rich_text first) =====\n\n\n    let updated = null;\n\n    if (cells.length) {\n      var _updated, _updated2;\n\n      updated = await slackJson(\"slackLists.items.update\", {\n        list_id: cfg.list_id,\n        cells\n      }); // If Slack refuses rich_text for any cell, try again with all cells coerced to plain text.\n\n      if (!((_updated = updated) !== null && _updated !== void 0 && _updated.ok) && ((_updated2 = updated) === null || _updated2 === void 0 ? void 0 : _updated2.error) === \"invalid_arguments\") {\n        const textified = cells.map(c => {\n          var _c$text, _c$rich_text, _c$rich_text$elements, _c$rich_text$elements2, _c$rich_text$elements3, _c$rich_text$elements4;\n\n          return {\n            row_id: c.row_id,\n            column_id: c.column_id,\n            text: (_c$text = c.text) !== null && _c$text !== void 0 ? _c$text : c.rich_text ? // naive stringification of what we sent in rich_text\n            ((_c$rich_text = c.rich_text) === null || _c$rich_text === void 0 ? void 0 : (_c$rich_text$elements = _c$rich_text.elements) === null || _c$rich_text$elements === void 0 ? void 0 : (_c$rich_text$elements2 = _c$rich_text$elements[0]) === null || _c$rich_text$elements2 === void 0 ? void 0 : (_c$rich_text$elements3 = _c$rich_text$elements2.elements) === null || _c$rich_text$elements3 === void 0 ? void 0 : (_c$rich_text$elements4 = _c$rich_text$elements3[0]) === null || _c$rich_text$elements4 === void 0 ? void 0 : _c$rich_text$elements4.text) || \"\" : \"\"\n          };\n        });\n        updated = await slackJson(\"slackLists.items.update\", {\n          list_id: cfg.list_id,\n          cells: textified\n        });\n      }\n    }\n\n    return res.status(200).json({\n      ok: true,\n      mode: \"list\",\n      list_id: cfg.list_id,\n      item_id: itemId,\n      used_columns: Object.fromEntries(Object.entries(cfg).filter(([k, v]) => k.endsWith(\"_col\") && v).map(([k, v]) => [k, v])),\n      title_mode: createdTry.mode,\n      // \"rich_text\" or \"text\"\n      update_ok: updated ? !!updated.ok : true,\n      update_error: (_updated3 = updated) !== null && _updated3 !== void 0 && _updated3.ok ? null : ((_updated4 = updated) === null || _updated4 === void 0 ? void 0 : _updated4.error) || null\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn","sn","workOrder","localSN","tracking","shippingDate","description","linkUrl","photoUrls","body","cfg","tasks","list_id","SLACK_LIST_TASKS_ID","title_col","SLACK_LIST_TASKS_TITLE_COL","description_col","SLACK_LIST_TASKS_DESCRIPTION_COL","shipping","SLACK_LIST_SHIPPING_ID","SLACK_LIST_SHIPPING_TITLE_COL","SLACK_LIST_SHIPPING_DESCRIPTION_COL","date_col","SLACK_LIST_SHIPPING_DATE_COL","pnsn_col","SLACK_LIST_SHIPPING_PNSN_COL","tracking_col","SLACK_LIST_SHIPPING_TRACKING_COL","wo_col","SLACK_LIST_SHIPPING_WO_COL","localsn_col","SLACK_LIST_SHIPPING_LOCALSN_COL","photos_col","SLACK_LIST_SHIPPING_PHOTOS_COL","receiving","SLACK_LIST_RECEIVING_ID","SLACK_LIST_RECEIVING_TITLE_COL","SLACK_LIST_RECEIVING_DESCRIPTION_COL","SLACK_LIST_RECEIVING_DATE_COL","SLACK_LIST_RECEIVING_PNSN_COL","SLACK_LIST_RECEIVING_TRACKING_COL","SLACK_LIST_RECEIVING_WO_COL","SLACK_LIST_RECEIVING_LOCALSN_COL","SLACK_LIST_RECEIVING_PHOTOS_COL","console","log","slackJson","payload","r","fetch","headers","Authorization","JSON","stringify","plain","v","toString","trim","first","x","Array","isArray","find","Boolean","toRichText","text","type","elements","createRowWithTitle","textValue","safeTitle","initial_fields","column_id","rich_text","created","mode","last","pushTextCell","cells","row_id","value","push","pushRichCell","linkSuffix","titleForCreate","fix","toUpperCase","createdTry","detail","last_response","sent_title","itemId","item","id","pn0","sn0","pnSnText","filter","join","addCellRT","colId","addCellText","descWithLink","length","urlsBlock","map","updated","textified","c","item_id","used_columns","Object","fromEntries","entries","k","endsWith","title_mode","update_ok","update_error","err","message","String"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAI;AAAA;;AACF,QAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,aAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAArB,CAAP;AACD;;AAED,UAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;;AACA,QAAI,CAACH,KAAL,EAAY;AACV,aAAON,GAAG,CACPE,MADI,CACG,GADH,EAEJC,IAFI,CAEC;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAA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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   try {\r\n//     if (req.method !== \"POST\") {\r\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//     }\r\n\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) {\r\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//     }\r\n\r\n//     // payload from client\r\n//     const {\r\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n//       title,               // item title (what shows in the primary column)\r\n//       // keeping minimal per your request: PN/SN only for now\r\n//       pn, sn,\r\n//     } = req.body || {};\r\n\r\n//     // list ids from env\r\n//     const LIST_IDS = {\r\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\r\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n//     };\r\n\r\n//     const list_id = LIST_IDS[listKey];\r\n//     if (!list_id) {\r\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n//     }\r\n\r\n//     // ---- Slack helpers ----\r\n//     async function slackJson(method, payload) {\r\n//       const r = await fetch(`https://slack.com/api/${method}`, {\r\n//         method: \"POST\",\r\n//         headers: {\r\n//           Authorization: `Bearer ${token}`,\r\n//           \"Content-Type\": \"application/json; charset=utf-8\",\r\n//         },\r\n//         body: JSON.stringify(payload),\r\n//       });\r\n//       return r.json();\r\n//     }\r\n\r\n//     const plain = (v) => (v ?? \"\").toString().trim();\r\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     function toRichText(text) {\r\n//       const t = plain(text);\r\n//       return [{\r\n//         type: \"rich_text\",\r\n//         elements: [{\r\n//           type: \"rich_text_section\",\r\n//           elements: [{ type: \"text\", text: t }],\r\n//         }],\r\n//       }];\r\n//     }\r\n\r\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n//     async function resolveTitleColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n//       let fallback = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\r\n//           if (f.column_id && hasText) {\r\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n//             if (!fallback) fallback = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return fallback; // first text-like field if we didn't find a perfect match\r\n//     }\r\n\r\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n//     async function resolvePnSnColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       let candidate = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           if (!f.column_id) continue;\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const text = (f.text || \"\").toLowerCase();\r\n\r\n//           const looksPnSn =\r\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\r\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n//           if (looksPnSn) return f.column_id;\r\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n//             candidate = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return candidate;\r\n//     }\r\n\r\n//     // 1) Resolve columns\r\n//     const titleColId = await resolveTitleColId(list_id);\r\n//     if (!titleColId) {\r\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n//     }\r\n\r\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n//     const safeTitle = plain(title) || \"New Item\";\r\n//     const createBody = {\r\n//       list_id,\r\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n//     };\r\n\r\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 3) (Minimal) update: PN/SN only, per your request\r\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n//     let updated = null;\r\n//     let usedPnSnCol = null;\r\n\r\n//     if (pnSnText) {\r\n//       const pnSnColId = await resolvePnSnColId(list_id);\r\n//       if (pnSnColId) {\r\n//         const cells = [{\r\n//           row_id: created.item.id,\r\n//           column_id: pnSnColId,\r\n//           rich_text: toRichText(pnSnText),\r\n//         }];\r\n\r\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n//         usedPnSnCol = pnSnColId;\r\n//         // If update fails, we still return ok:false so you can see the error\r\n//         if (!updated?.ok) {\r\n//           return res.status(200).json({\r\n//             ok: false,\r\n//             error: updated?.error || \"update_failed\",\r\n//             mode: \"list\",\r\n//             list_id,\r\n//             item_id: created.item.id,\r\n//             used_title_col: titleColId,\r\n//             used_pnsn_col: usedPnSnCol,\r\n//           });\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleColId,\r\n//       used_pnsn_col: usedPnSnCol || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) {\r\n      return res\r\n        .status(500)\r\n        .json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n    }\r\n\r\n    // ===== Body (built from the item itself on the client) =====\r\n    // listKey: \"tasks\" | \"shipping\" | \"receiving\"\r\n    // title:   main row title (item name + optional (AISxxxxx))\r\n    // pn, sn:  string or [string,...]  -> combined as \"PN: ...\\nSN: ...\"\r\n    // workOrder, localSN, tracking, shippingDate (YYYY-MM-DD or free text)\r\n    // description: free text (condition/notes for receiving; details for tasks/shipping)\r\n    // linkUrl:     URL back to your app's item page (optional; we append to description/title)\r\n    // photoUrls:   [url,...] (optional; we put them as text if an attachment column isn't configured)\r\n    const {\r\n      listKey,\r\n      title,\r\n      pn,\r\n      sn,\r\n      workOrder,\r\n      localSN,\r\n      tracking,\r\n      shippingDate,\r\n      description,\r\n      linkUrl,\r\n      photoUrls = [],\r\n    } = req.body || {};\r\n\r\n    // ===== Per-list config from env (column IDs you collected) =====\r\n    const cfg = {\r\n      tasks: {\r\n        list_id: process.env.SLACK_LIST_TASKS_ID,\r\n        title_col: process.env.SLACK_LIST_TASKS_TITLE_COL,\r\n        description_col: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\r\n      },\r\n      shipping: {\r\n        list_id: process.env.SLACK_LIST_SHIPPING_ID,\r\n        title_col: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\r\n        description_col: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n        date_col: process.env.SLACK_LIST_SHIPPING_DATE_COL,\r\n        pnsn_col: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n        tracking_col: process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n        wo_col: process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n        localsn_col: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n        photos_col: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL, // we write URLs as text\r\n      },\r\n      receiving: {\r\n        list_id: process.env.SLACK_LIST_RECEIVING_ID,\r\n        title_col: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\r\n        description_col: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n        date_col: process.env.SLACK_LIST_RECEIVING_DATE_COL,\r\n        pnsn_col: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n        tracking_col: process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n        wo_col: process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n        localsn_col: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n        photos_col: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // we write URLs as text\r\n      },\r\n    }[listKey || \"\"];\r\n\r\n    console.log('ENV title cols present? ', {\r\n      tasks: !!process.env.SLACK_LIST_TASKS_TITLE_COL,\r\n      shipping: !!process.env.SLACK_LIST_SHIPPING_TITLE_COL,\r\n      receiving: !!process.env.SLACK_LIST_RECEIVING_TITLE_COL,\r\n    });\r\n\r\n    if (!cfg?.list_id) {\r\n      return res\r\n        .status(400)\r\n        .json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n    }\r\n\r\n    // ===== Helpers =====\r\n    async function slackJson(method, payload) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          Authorization: `Bearer ${token}`,\r\n          \"Content-Type\": \"application/json; charset=utf-8\",\r\n        },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      return r.json();\r\n    }\r\n\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n    const first = (x) => (Array.isArray(x) ? x.find(Boolean) || \"\" : plain(x));\r\n\r\n    // Rich text object Slack usually accepts\r\n    const toRichText = (text) => ({\r\n      type: \"rich_text\",\r\n      elements: [\r\n        {\r\n          type: \"rich_text_section\",\r\n          elements: [{ type: \"text\", text: plain(text) }],\r\n        },\r\n      ],\r\n    });\r\n\r\n    // Try create: rich_text → text\r\n    async function createRowWithTitle(list_id, title_col, textValue) {\r\n      const safeTitle = plain(textValue) || \"New Item\";\r\n\r\n      // 1) rich_text\r\n      let r = await slackJson(\"slackLists.items.create\", {\r\n        list_id,\r\n        initial_fields: [{ column_id: title_col, rich_text: toRichText(safeTitle) }],\r\n      });\r\n      if (r?.ok) return { ok: true, created: r, mode: \"rich_text\" };\r\n\r\n      // 2) text fallback (Slack sometimes wants plain text)\r\n      if (r?.error === \"invalid_arguments\") {\r\n        r = await slackJson(\"slackLists.items.create\", {\r\n          list_id,\r\n          initial_fields: [{ column_id: title_col, text: safeTitle }],\r\n        });\r\n        if (r?.ok) return { ok: true, created: r, mode: \"text\" };\r\n      }\r\n      return { ok: false, error: r?.error || \"create_failed\", last: r };\r\n    }\r\n\r\n    function pushTextCell(cells, row_id, column_id, value) {\r\n      if (!column_id) return;\r\n      const v = plain(value);\r\n      if (!v) return;\r\n      cells.push({ row_id, column_id, text: v });\r\n    }\r\n\r\n    function pushRichCell(cells, row_id, column_id, value) {\r\n      if (!column_id) return;\r\n      const v = plain(value);\r\n      if (!v) return;\r\n      cells.push({ row_id, column_id, rich_text: toRichText(v) });\r\n    }\r\n\r\n    // ===== Title (create the row) =====\r\n    // If we have a linkUrl and no description column, we append URL to the title\r\n    const linkSuffix = linkUrl ? ` — ${linkUrl}` : \"\";\r\n    const titleForCreate =\r\n      plain(title) || (localSN ? `Item (${localSN})` : \"New Item\");\r\n\r\n    if (!cfg.title_col) {\r\n      // If somehow title_col is missing, abort early with a helpful message.\r\n      return res.status(400).json({\r\n        ok: false,\r\n        error: \"missing_title_column_in_env\",\r\n        fix: `Set ${listKey.toUpperCase()} title column in .env.local (e.g. SLACK_LIST_${listKey.toUpperCase()}_TITLE_COL)`,\r\n      });\r\n    }\r\n\r\n    const createdTry = await createRowWithTitle(\r\n      cfg.list_id,\r\n      cfg.title_col,\r\n      titleForCreate + (!cfg.description_col ? linkSuffix : \"\")\r\n    );\r\n\r\n    if (!createdTry.ok) {\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: \"title_create_failed\",\r\n        mode: \"list\",\r\n        detail: createdTry.error,\r\n        last_response: createdTry.last || null,\r\n        list_id: cfg.list_id,\r\n        title_col: cfg.title_col,\r\n        sent_title: titleForCreate,\r\n      });\r\n    }\r\n\r\n    const itemId = createdTry.created?.item?.id;\r\n\r\n    // ===== Build cell updates from the item data =====\r\n    const cells = [];\r\n    const pn0 = first(pn);\r\n    const sn0 = first(sn);\r\n    const pnSnText = [pn0 && `PN: ${pn0}`, sn0 && `SN: ${sn0}`]\r\n      .filter(Boolean)\r\n      .join(\"\\n\");\r\n\r\n    // Prefer rich_text for text-like columns; Slack accepts both. If it ever fails, Slack will return ok:false and we’ll try again below with text.\r\n    const addCellRT = (colId, value) =>\r\n      pushRichCell(cells, itemId, colId, value);\r\n    const addCellText = (colId, value) =>\r\n      pushTextCell(cells, itemId, colId, value);\r\n\r\n    // Description (+ include link inside description if available)\r\n    if (cfg.description_col) {\r\n      const descWithLink =\r\n        description && linkUrl\r\n          ? `${description}\\nLink: ${linkUrl}`\r\n          : description || (linkUrl ? `Link: ${linkUrl}` : \"\");\r\n      addCellRT(cfg.description_col, descWithLink);\r\n    }\r\n\r\n    // PN/SN\r\n    if (cfg.pnsn_col && pnSnText) addCellRT(cfg.pnsn_col, pnSnText);\r\n\r\n    // Work order\r\n    if (cfg.wo_col && workOrder) addCellRT(cfg.wo_col, workOrder);\r\n\r\n    // Local SN (AISxxxxx)\r\n    if (cfg.localsn_col && localSN) addCellRT(cfg.localsn_col, localSN);\r\n\r\n    // Tracking / Airbill\r\n    if (cfg.tracking_col && tracking) addCellRT(cfg.tracking_col, tracking);\r\n\r\n    // Date\r\n    if (cfg.date_col && shippingDate) addCellRT(cfg.date_col, shippingDate);\r\n\r\n    // Photos (we write URLs as text lines; attachments API for Lists isn’t public yet)\r\n    if (cfg.photos_col && photoUrls?.length) {\r\n      const urlsBlock = photoUrls.map(plain).filter(Boolean).join(\"\\n\");\r\n      if (urlsBlock) addCellText(cfg.photos_col, urlsBlock);\r\n    }\r\n\r\n    // ===== Send one update with all cells (rich_text first) =====\r\n    let updated = null;\r\n    if (cells.length) {\r\n      updated = await slackJson(\"slackLists.items.update\", {\r\n        list_id: cfg.list_id,\r\n        cells,\r\n      });\r\n\r\n      // If Slack refuses rich_text for any cell, try again with all cells coerced to plain text.\r\n      if (!updated?.ok && updated?.error === \"invalid_arguments\") {\r\n        const textified = cells.map((c) => ({\r\n          row_id: c.row_id,\r\n          column_id: c.column_id,\r\n          text:\r\n            c.text ??\r\n            (c.rich_text\r\n              ? // naive stringification of what we sent in rich_text\r\n                (c.rich_text?.elements?.[0]?.elements?.[0]?.text || \"\")\r\n              : \"\"),\r\n        }));\r\n        updated = await slackJson(\"slackLists.items.update\", {\r\n          list_id: cfg.list_id,\r\n          cells: textified,\r\n        });\r\n      }\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      mode: \"list\",\r\n      list_id: cfg.list_id,\r\n      item_id: itemId,\r\n      used_columns: Object.fromEntries(\r\n        Object.entries(cfg)\r\n          .filter(([k, v]) => k.endsWith(\"_col\") && v)\r\n          .map(([k, v]) => [k, v])\r\n      ),\r\n      title_mode: createdTry.mode, // \"rich_text\" or \"text\"\r\n      update_ok: updated ? !!updated.ok : true,\r\n      update_error: updated?.ok ? null : updated?.error || null,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res\r\n      .status(500)\r\n      .json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}