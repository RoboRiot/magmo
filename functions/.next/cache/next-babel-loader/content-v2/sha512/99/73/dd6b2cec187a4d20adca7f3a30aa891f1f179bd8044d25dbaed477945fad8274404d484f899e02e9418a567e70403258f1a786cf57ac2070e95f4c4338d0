{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\n//   try {\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\n//     const {\n//       listKey,            // \"receiving\" | \"shipping\" | \"tasks\"\n//       title, linkUrl, bodyText,\n//       date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\n//       photoUrls = [],\n//     } = req.body;\n//     const LISTS = {\n//       receiving: {\n//         id: process.env.SLACK_LIST_RECEIVING_ID,\n//         cols: {\n//           desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n//           date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\n//           pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n//           track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n//           wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\n//           lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n//           photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // attachment\n//         },\n//       },\n//       shipping: {\n//         id: process.env.SLACK_LIST_SHIPPING_ID,\n//         cols: {\n//           desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n//           date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\n//           pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n//           track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n//           wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\n//           lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n//           photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,  // attachment\n//         },\n//       },\n//       tasks: {\n//         id: process.env.SLACK_LIST_TASKS_ID,\n//         cols: {\n//           desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\n//         },\n//       },\n//     };\n//     const CHANNELS = {\n//       receiving: process.env.SLACK_CHANNEL_RECEIVING_ID,\n//       shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,\n//       tasks:     process.env.SLACK_CHANNEL_TASKS_ID,\n//     };\n//     const headersJson = {\n//       Authorization: `Bearer ${token}`,\n//       \"Content-Type\": \"application/json; charset=utf-8\",\n//     };\n//     const slack = (method, body, headers = headersJson) =>\n//       fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body })\n//         .then(r => r.json());\n//     const plain = v => (v ?? \"\").toString().trim();\n//     const safe  = plain;\n//     const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     // ---------- PATH A: Write to a LIST ----------\n//     const cfg = LISTS[listKey];\n//     if (cfg?.id) {\n//       const fields = [];\n//       // Description column\n//       if (cfg.cols.desc && (description || bodyText || linkUrl)) {\n//         const textBits = [\n//           description,\n//           (listKey === \"tasks\" && bodyText) ? bodyText : null,\n//           linkUrl ? `<${linkUrl}|Open in Magmo>` : null,\n//         ].filter(Boolean).join(\"\\n\");\n//         fields.push({ column_id: cfg.cols.desc, value: { text: textBits } });\n//       }\n//       if (cfg.cols.date && date) fields.push({ column_id: cfg.cols.date, value: { date } });\n//       if (cfg.cols.pn && (pn || sn || dom)) {\n//         const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : (pn ? `PN: ${pn}` : \"\");\n//         const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : (sn ? `SN: ${sn}` : \"\");\n//         const domLine = dom ? `DOM: ${dom}` : \"\";\n//         const pnBlock = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\n//         if (pnBlock) fields.push({ column_id: cfg.cols.pn, value: { text: pnBlock } });\n//       }\n//       if (cfg.cols.track && (trackingNumber || poNumber)) {\n//         const t = [\n//           trackingNumber ? `RL: ${trackingNumber}` : \"\",\n//           poNumber ? `PO: ${poNumber}` : \"\",\n//         ].filter(Boolean).join(\"  \");\n//         if (t) fields.push({ column_id: cfg.cols.track, value: { text: t } });\n//       }\n//       if (cfg.cols.wo && workOrder) fields.push({ column_id: cfg.cols.wo,  value: { text: `WO: ${workOrder}` } });\n//       if (cfg.cols.lsn && localSN)  fields.push({ column_id: cfg.cols.lsn, value: { text: localSN } });\n//       // NOW build the create body (cfg & fields exist)\n//       const createBody = {\n//         list_id: cfg.id,\n//         title: plain(title) || plain(localSN) || \"Untitled\",\n//         fields,\n//       };\n//       const created = await slack(\"slackLists.items.create\", JSON.stringify(createBody));\n//       if (!created?.ok) {\n//         console.error(\"slackLists.items.create error:\", created);\n//         return res.status(400).json({ error: created?.error || \"Slack Lists API error\", raw: created });\n//       }\n//       // Photos -> attachment column\n//       if (cfg.cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\n//         const fileIds = [];\n//         for (const url of photoUrls) {\n//           const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\n//             method: \"POST\",\n//             headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\n//             body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\n//           }).then(r => r.json());\n//           if (!init?.ok || !init?.upload_url) continue;\n//           try {\n//             const img = await fetch(url);\n//             const buf = await img.arrayBuffer();\n//             await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\n//           } catch (_) {}\n//           const complete = await slack(\"files.completeUploadExternal\",\n//             JSON.stringify({ files: [{ id: init.file_id, title: \"photo\" }] })\n//           );\n//           if (complete?.ok && complete?.files?.[0]?.id) fileIds.push(complete.files[0].id);\n//         }\n//         if (fileIds.length) {\n//           await slack(\"slackLists.items.update\", JSON.stringify({\n//             list_id: cfg.id,\n//             item_id: created.item.id,\n//             fields: [{ column_id: cfg.cols.photos, value: { attachment: { file_ids: fileIds } } }],\n//           }));\n//         }\n//       }\n//       return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: created.item.id });\n//     }\n//     // ---------- PATH B: Fallback to a channel post ----------\n//     const channel = CHANNELS[listKey];\n//     if (!channel) return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\n//     // Try to join public channels to avoid channel_not_found\n//     await fetch(\"https://slack.com/api/conversations.join\", {\n//       method: \"POST\",\n//       headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\n//       body: new URLSearchParams({ channel }),\n//     });\n//     const safeId = plain(linkUrl?.split(\"/\").pop()) || plain(localSN) || \"\";\n//     const safeTitle = plain(title) || plain(req.body?.title) || (safeId ? `Item ${safeId}` : \"New Item\");\n//     const lines = [];\n//     lines.push(`*${safeTitle}*`);\n//     const pnStr = joinArr(pn);\n//     const snStr = joinArr(sn);\n//     if (pnStr) lines.push(`PN: ${pnStr}`);\n//     if (snStr) lines.push(`SN: ${snStr}`);\n//     if (safe(workOrder)) lines.push(`WO: ${safe(workOrder)}`);\n//     if (safe(poNumber)) lines.push(`PO: ${safe(poNumber)}`);\n//     if (safe(trackingNumber)) lines.push(`RL: ${safe(trackingNumber)}`);\n//     if (safe(dom)) lines.push(`DOM: ${safe(dom)}`);\n//     if (safe(localSN)) lines.push(`Local SN: ${safe(localSN)}`);\n//     if (safe(date)) lines.push(`Date: ${safe(date)}`);\n//     const desc = safe(description);\n//     if (desc) lines.push(desc);\n//     else if (listKey === \"tasks\" && safe(bodyText)) lines.push(safe(bodyText));\n//     if (safe(linkUrl)) lines.push(`<${safe(linkUrl)}|Open in Magmo>`);\n//     const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\n//     const posted = await slack(\"chat.postMessage\", JSON.stringify({ channel, text }));\n//     if (!posted?.ok) {\n//       console.error(\"chat.postMessage error:\", posted);\n//       return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\n//     }\n//     return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\n//   } catch (e) {\n//     console.error(\"API /slack/add-to-list crashed:\", e);\n//     return res.status(500).json({ error: \"Server error\" });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  if (req.method !== \"POST\") return res.status(405).json({\n    error: \"Method not allowed\"\n  });\n  const token = process.env.SLACK_BOT_TOKEN;\n  if (!token) return res.status(500).json({\n    error: \"Missing SLACK_BOT_TOKEN\"\n  }); // ---------- Payload ----------\n\n  const {\n    listKey,\n    // \"tasks\" | \"shipping\" | \"receiving\"\n    title,\n    linkUrl,\n    bodyText,\n    date,\n    pn,\n    sn,\n    dom,\n    trackingNumber,\n    poNumber,\n    workOrder,\n    localSN,\n    description,\n    photoUrls = []\n  } = req.body || {}; // ---------- Env (IDs) ----------\n  // Add your primary text column IDs (especially for Tasks) so the name shows in the \"Task\" column.\n\n  const LISTS = {\n    tasks: {\n      id: process.env.SLACK_LIST_TASKS_ID,\n      cols: {\n        primary: process.env.SLACK_LIST_TASKS_PRIMARY_COL,\n        // <-- set this to your \"Task\" column id\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL\n      }\n    },\n    shipping: {\n      id: process.env.SLACK_LIST_SHIPPING_ID,\n      cols: {\n        primary: process.env.SLACK_LIST_SHIPPING_PRIMARY_COL,\n        // optional, used for initial name\n        desc: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n        date: process.env.SLACK_LIST_SHIPPING_DATE_COL,\n        pn: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n        track: process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n        wo: process.env.SLACK_LIST_SHIPPING_WO_COL,\n        lsn: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL\n      }\n    },\n    receiving: {\n      id: process.env.SLACK_LIST_RECEIVING_ID,\n      cols: {\n        primary: process.env.SLACK_LIST_RECEIVING_PRIMARY_COL,\n        // optional, used for initial name\n        desc: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n        date: process.env.SLACK_LIST_RECEIVING_DATE_COL,\n        pn: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n        track: process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n        wo: process.env.SLACK_LIST_RECEIVING_WO_COL,\n        lsn: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL\n      }\n    }\n  }; // Optional channel fallbacks if a List ID isn’t configured\n\n  const CHANNELS = {\n    tasks: process.env.SLACK_CHANNEL_TASKS_ID,\n    shipping: process.env.SLACK_CHANNEL_SHIPPING_ID,\n    receiving: process.env.SLACK_CHANNEL_RECEIVING_ID\n  }; // ---------- Helpers ----------\n\n  const headersJson = {\n    Authorization: `Bearer ${token}`,\n    \"Content-Type\": \"application/json; charset=utf-8\"\n  };\n\n  const slack = (method, body) => fetch(`https://slack.com/api/${method}`, {\n    method: \"POST\",\n    headers: headersJson,\n    body: JSON.stringify(body)\n  }).then(r => r.json());\n\n  const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n  const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a); // Slack Lists text must be sent as \"rich_text\"\n\n\n  const richText = text => [{\n    type: \"rich_text\",\n    elements: [{\n      type: \"rich_text_section\",\n      elements: [{\n        type: \"text\",\n        text: text !== null && text !== void 0 ? text : \"\"\n      }]\n    }]\n  }]; // Normalize/guarantee a non-empty name\n\n\n  const safeTitle = plain(title) || (plain(localSN) ? `Item ${plain(localSN)}` : \"\") || joinArr(pn) || \"New Item\"; // Convert date to YYYY-MM-DD if possible\n\n  const toISODate = d => {\n    const s = plain(d);\n    if (!s) return \"\";\n    const dt = new Date(s);\n    return isNaN(dt.getTime()) ? \"\" : dt.toISOString().slice(0, 10);\n  }; // ---------- Verbose logging ----------\n\n\n  console.log(\"[add-to-list] incoming payload\", {\n    listKey,\n    title,\n    safeTitle,\n    pn: Array.isArray(pn) ? pn : pn ? [pn] : [],\n    sn: Array.isArray(sn) ? sn : sn ? [sn] : [],\n    localSN,\n    date\n  });\n  console.log(\"[add-to-list] env presence\", {\n    hasListTasks: !!process.env.SLACK_LIST_TASKS_ID,\n    hasListShipping: !!process.env.SLACK_LIST_SHIPPING_ID,\n    hasListReceiving: !!process.env.SLACK_LIST_RECEIVING_ID,\n    tasksPrimaryCol: process.env.SLACK_LIST_TASKS_PRIMARY_COL\n  });\n  const cfg = LISTS[listKey]; // ============================================================\n  // PATH A: Slack Lists (preferred)\n  // ============================================================\n\n  if (cfg !== null && cfg !== void 0 && cfg.id) {\n    try {\n      var _cfg$cols, _cfg$cols2, _cfg$cols3, _created$item, _cfg$cols4, _cfg$cols5, _cfg$cols6, _cfg$cols7, _cfg$cols8, _cfg$cols9;\n\n      // Choose a primary column for the initial name (fallback to desc if primary not provided).\n      const primaryColId = ((_cfg$cols = cfg.cols) === null || _cfg$cols === void 0 ? void 0 : _cfg$cols.primary) || ((_cfg$cols2 = cfg.cols) === null || _cfg$cols2 === void 0 ? void 0 : _cfg$cols2.desc);\n      const initial_fields = [];\n\n      if (primaryColId) {\n        initial_fields.push({\n          column_id: primaryColId,\n          rich_text: richText(safeTitle)\n        });\n      } // For tasks, keep creation minimal (name only).\n      // For shipping/receiving, you *may* also seed a description cell up front.\n\n\n      if (listKey !== \"tasks\" && (_cfg$cols3 = cfg.cols) !== null && _cfg$cols3 !== void 0 && _cfg$cols3.desc && plain(description)) {\n        initial_fields.push({\n          column_id: cfg.cols.desc,\n          rich_text: richText(plain(description))\n        });\n      }\n\n      const createBody = {\n        list_id: cfg.id\n      };\n      if (initial_fields.length) createBody.initial_fields = initial_fields;\n      console.log(\"[add-to-list] CREATE >\", {\n        list_id: cfg.id,\n        initial_fields_preview: initial_fields.map(f => {\n          var _f$rich_text, _f$rich_text$, _f$rich_text$$element, _f$rich_text$$element2, _f$rich_text$$element3, _f$rich_text$$element4;\n\n          return {\n            column_id: f.column_id,\n            kind: Object.keys(f)[1],\n            textPreview: (((_f$rich_text = f.rich_text) === null || _f$rich_text === void 0 ? void 0 : (_f$rich_text$ = _f$rich_text[0]) === null || _f$rich_text$ === void 0 ? void 0 : (_f$rich_text$$element = _f$rich_text$.elements) === null || _f$rich_text$$element === void 0 ? void 0 : (_f$rich_text$$element2 = _f$rich_text$$element[0]) === null || _f$rich_text$$element2 === void 0 ? void 0 : (_f$rich_text$$element3 = _f$rich_text$$element2.elements) === null || _f$rich_text$$element3 === void 0 ? void 0 : (_f$rich_text$$element4 = _f$rich_text$$element3[0]) === null || _f$rich_text$$element4 === void 0 ? void 0 : _f$rich_text$$element4.text) || \"\").slice(0, 80)\n          };\n        })\n      });\n      const created = await slack(\"slackLists.items.create\", createBody);\n      console.log(\"[add-to-list] CREATE < resp\", created);\n\n      if (!(created !== null && created !== void 0 && created.ok)) {\n        console.warn(\"[add-to-list] create failed, trying channel fallback:\", created === null || created === void 0 ? void 0 : created.error);\n        return await channelFallback({\n          slack,\n          token,\n          CHANNELS,\n          listKey,\n          safeTitle,\n          linkUrl,\n          pn,\n          sn,\n          dom,\n          workOrder,\n          poNumber,\n          trackingNumber,\n          localSN,\n          date,\n          bodyText,\n          description,\n          res\n        });\n      }\n\n      const itemId = created === null || created === void 0 ? void 0 : (_created$item = created.item) === null || _created$item === void 0 ? void 0 : _created$item.id; // Build cells to update (correct format per Slack docs)\n\n      const cells = [];\n\n      const addTextCell = (colId, text) => {\n        const t = plain(text);\n        if (colId && t) cells.push({\n          row_id: itemId,\n          column_id: colId,\n          rich_text: richText(t)\n        });\n      };\n\n      if ((_cfg$cols4 = cfg.cols) !== null && _cfg$cols4 !== void 0 && _cfg$cols4.desc) {\n        const textBits = [plain(description), listKey === \"tasks\" ? plain(bodyText) : \"\", plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\"].filter(Boolean).join(\"\\n\");\n        addTextCell(cfg.cols.desc, textBits);\n      }\n\n      if ((_cfg$cols5 = cfg.cols) !== null && _cfg$cols5 !== void 0 && _cfg$cols5.date) {\n        const iso = toISODate(date);\n        if (iso) cells.push({\n          row_id: itemId,\n          column_id: cfg.cols.date,\n          date: [iso]\n        });\n      }\n\n      if ((_cfg$cols6 = cfg.cols) !== null && _cfg$cols6 !== void 0 && _cfg$cols6.pn) {\n        const pnStr = joinArr(pn);\n        const snStr = joinArr(sn);\n        const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`].filter(Boolean).join(\"  \");\n        addTextCell(cfg.cols.pn, combo);\n      }\n\n      if ((_cfg$cols7 = cfg.cols) !== null && _cfg$cols7 !== void 0 && _cfg$cols7.track) {\n        const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`].filter(Boolean).join(\"  \");\n        addTextCell(cfg.cols.track, t);\n      }\n\n      if ((_cfg$cols8 = cfg.cols) !== null && _cfg$cols8 !== void 0 && _cfg$cols8.wo) addTextCell(cfg.cols.wo, plain(workOrder) && `WO: ${plain(workOrder)}`);\n      if ((_cfg$cols9 = cfg.cols) !== null && _cfg$cols9 !== void 0 && _cfg$cols9.lsn) addTextCell(cfg.cols.lsn, plain(localSN));\n\n      if (cells.length) {\n        console.log(\"[add-to-list] UPDATE >\", {\n          list_id: cfg.id,\n          cells_preview: cells.map(c => ({\n            row_id: c.row_id,\n            column_id: c.column_id,\n            keys: Object.keys(c)\n          }))\n        });\n        const updated = await slack(\"slackLists.items.update\", {\n          list_id: cfg.id,\n          cells\n        });\n        console.log(\"[add-to-list] UPDATE < resp\", updated);\n\n        if (!(updated !== null && updated !== void 0 && updated.ok)) {\n          console.warn(\"[add-to-list] update failed; leaving item with initial fields only:\", updated === null || updated === void 0 ? void 0 : updated.error);\n        }\n      }\n\n      return res.status(200).json({\n        ok: true,\n        mode: \"list\",\n        list_id: cfg.id,\n        item_id: itemId,\n        title: safeTitle,\n        primary_col: primaryColId || null\n      });\n    } catch (e) {\n      console.error(\"[add-to-list] lists path error:\", e);\n      return await channelFallback({\n        slack,\n        token,\n        CHANNELS,\n        listKey,\n        safeTitle,\n        linkUrl,\n        pn,\n        sn,\n        dom,\n        workOrder,\n        poNumber,\n        trackingNumber,\n        localSN,\n        date,\n        bodyText,\n        description,\n        res\n      });\n    }\n  } // ============================================================\n  // PATH B: Channel fallback (if no list configured)\n  // ============================================================\n\n\n  return await channelFallback({\n    slack,\n    token,\n    CHANNELS,\n    listKey,\n    safeTitle,\n    linkUrl,\n    pn,\n    sn,\n    dom,\n    workOrder,\n    poNumber,\n    trackingNumber,\n    localSN,\n    date,\n    bodyText,\n    description,\n    res\n  });\n} // ---------------- helpers ----------------\n\nasync function channelFallback({\n  slack,\n  token,\n  CHANNELS,\n  listKey,\n  safeTitle,\n  linkUrl,\n  pn,\n  sn,\n  dom,\n  workOrder,\n  poNumber,\n  trackingNumber,\n  localSN,\n  date,\n  bodyText,\n  description,\n  res\n}) {\n  const channel = CHANNELS[listKey];\n  if (!channel) return res.status(400).json({\n    error: \"Unknown listKey (no list or channel configured)\"\n  }); // We’ll just post a message with the essentials\n\n  const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n  const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n\n  const lines = [`*${safeTitle}*`];\n  const pnStr = joinArr(pn);\n  const snStr = joinArr(sn);\n  if (pnStr) lines.push(`PN: ${pnStr}`);\n  if (snStr) lines.push(`SN: ${snStr}`);\n  if (plain(workOrder)) lines.push(`WO: ${plain(workOrder)}`);\n  if (plain(poNumber)) lines.push(`PO: ${plain(poNumber)}`);\n  if (plain(trackingNumber)) lines.push(`RL: ${plain(trackingNumber)}`);\n  if (plain(dom)) lines.push(`DOM: ${plain(dom)}`);\n  if (plain(localSN)) lines.push(`Local SN: ${plain(localSN)}`);\n\n  const toISODate = d => {\n    const s = plain(d);\n    if (!s) return \"\";\n    const dt = new Date(s);\n    return isNaN(dt.getTime()) ? \"\" : dt.toISOString().slice(0, 10);\n  };\n\n  if (toISODate(date)) lines.push(`Date: ${toISODate(date)}`);\n  const desc = plain(description);\n  if (desc) lines.push(desc);else if (listKey === \"tasks\" && plain(bodyText)) lines.push(plain(bodyText));\n  if (plain(linkUrl)) lines.push(`<${plain(linkUrl)}|Open in Magmo>`);\n  const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\n  const posted = await slack(\"chat.postMessage\", {\n    channel,\n    text\n  });\n\n  if (!(posted !== null && posted !== void 0 && posted.ok)) {\n    console.error(\"[add-to-list] chat.postMessage error:\", posted);\n    return res.status(400).json({\n      error: (posted === null || posted === void 0 ? void 0 : posted.error) || \"Slack API error\",\n      raw: posted\n    });\n  }\n\n  return res.status(200).json({\n    ok: true,\n    mode: \"channel\",\n    channel,\n    ts: posted.ts\n  });\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","linkUrl","bodyText","date","pn","sn","dom","trackingNumber","poNumber","workOrder","localSN","description","photoUrls","body","LISTS","tasks","id","SLACK_LIST_TASKS_ID","cols","primary","SLACK_LIST_TASKS_PRIMARY_COL","desc","SLACK_LIST_TASKS_DESCRIPTION_COL","shipping","SLACK_LIST_SHIPPING_ID","SLACK_LIST_SHIPPING_PRIMARY_COL","SLACK_LIST_SHIPPING_DESCRIPTION_COL","SLACK_LIST_SHIPPING_DATE_COL","SLACK_LIST_SHIPPING_PNSN_COL","track","SLACK_LIST_SHIPPING_TRACKING_COL","wo","SLACK_LIST_SHIPPING_WO_COL","lsn","SLACK_LIST_SHIPPING_LOCALSN_COL","photos","SLACK_LIST_SHIPPING_PHOTOS_COL","receiving","SLACK_LIST_RECEIVING_ID","SLACK_LIST_RECEIVING_PRIMARY_COL","SLACK_LIST_RECEIVING_DESCRIPTION_COL","SLACK_LIST_RECEIVING_DATE_COL","SLACK_LIST_RECEIVING_PNSN_COL","SLACK_LIST_RECEIVING_TRACKING_COL","SLACK_LIST_RECEIVING_WO_COL","SLACK_LIST_RECEIVING_LOCALSN_COL","SLACK_LIST_RECEIVING_PHOTOS_COL","CHANNELS","SLACK_CHANNEL_TASKS_ID","SLACK_CHANNEL_SHIPPING_ID","SLACK_CHANNEL_RECEIVING_ID","headersJson","Authorization","slack","fetch","headers","JSON","stringify","then","r","plain","v","toString","trim","joinArr","a","Array","isArray","filter","Boolean","map","join","richText","text","type","elements","safeTitle","toISODate","d","s","dt","Date","isNaN","getTime","toISOString","slice","console","log","hasListTasks","hasListShipping","hasListReceiving","tasksPrimaryCol","cfg","primaryColId","initial_fields","push","column_id","rich_text","createBody","list_id","length","initial_fields_preview","f","kind","Object","keys","textPreview","created","ok","warn","channelFallback","itemId","item","cells","addTextCell","colId","t","row_id","textBits","iso","pnStr","snStr","combo","cells_preview","c","updated","mode","item_id","primary_col","e","channel","lines","posted","raw","ts"],"mappings":"AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B,OAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,IAAAA,KAAK,EAAE;AAAT,GAArB,CAAP;AAE3B,QAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;AACA,MAAI,CAACH,KAAL,EAAY,OAAOL,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,IAAAA,KAAK,EAAE;AAAT,GAArB,CA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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\r\n\r\n//   try {\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\r\n\r\n//     const {\r\n//       listKey,            // \"receiving\" | \"shipping\" | \"tasks\"\r\n//       title, linkUrl, bodyText,\r\n//       date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n//       photoUrls = [],\r\n//     } = req.body;\r\n\r\n//     const LISTS = {\r\n//       receiving: {\r\n//         id: process.env.SLACK_LIST_RECEIVING_ID,\r\n//         cols: {\r\n//           desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n//           date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\r\n//           pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n//           track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n//           wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n//           lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n//           photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // attachment\r\n//         },\r\n//       },\r\n//       shipping: {\r\n//         id: process.env.SLACK_LIST_SHIPPING_ID,\r\n//         cols: {\r\n//           desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n//           date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\r\n//           pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n//           track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n//           wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n//           lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n//           photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,  // attachment\r\n//         },\r\n//       },\r\n//       tasks: {\r\n//         id: process.env.SLACK_LIST_TASKS_ID,\r\n//         cols: {\r\n//           desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\r\n//         },\r\n//       },\r\n//     };\r\n\r\n//     const CHANNELS = {\r\n//       receiving: process.env.SLACK_CHANNEL_RECEIVING_ID,\r\n//       shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,\r\n//       tasks:     process.env.SLACK_CHANNEL_TASKS_ID,\r\n//     };\r\n\r\n//     const headersJson = {\r\n//       Authorization: `Bearer ${token}`,\r\n//       \"Content-Type\": \"application/json; charset=utf-8\",\r\n//     };\r\n//     const slack = (method, body, headers = headersJson) =>\r\n//       fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body })\r\n//         .then(r => r.json());\r\n\r\n//     const plain = v => (v ?? \"\").toString().trim();\r\n//     const safe  = plain;\r\n//     const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     // ---------- PATH A: Write to a LIST ----------\r\n//     const cfg = LISTS[listKey];\r\n//     if (cfg?.id) {\r\n//       const fields = [];\r\n\r\n//       // Description column\r\n//       if (cfg.cols.desc && (description || bodyText || linkUrl)) {\r\n//         const textBits = [\r\n//           description,\r\n//           (listKey === \"tasks\" && bodyText) ? bodyText : null,\r\n//           linkUrl ? `<${linkUrl}|Open in Magmo>` : null,\r\n//         ].filter(Boolean).join(\"\\n\");\r\n//         fields.push({ column_id: cfg.cols.desc, value: { text: textBits } });\r\n//       }\r\n\r\n//       if (cfg.cols.date && date) fields.push({ column_id: cfg.cols.date, value: { date } });\r\n\r\n//       if (cfg.cols.pn && (pn || sn || dom)) {\r\n//         const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : (pn ? `PN: ${pn}` : \"\");\r\n//         const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : (sn ? `SN: ${sn}` : \"\");\r\n//         const domLine = dom ? `DOM: ${dom}` : \"\";\r\n//         const pnBlock = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\r\n//         if (pnBlock) fields.push({ column_id: cfg.cols.pn, value: { text: pnBlock } });\r\n//       }\r\n\r\n//       if (cfg.cols.track && (trackingNumber || poNumber)) {\r\n//         const t = [\r\n//           trackingNumber ? `RL: ${trackingNumber}` : \"\",\r\n//           poNumber ? `PO: ${poNumber}` : \"\",\r\n//         ].filter(Boolean).join(\"  \");\r\n//         if (t) fields.push({ column_id: cfg.cols.track, value: { text: t } });\r\n//       }\r\n\r\n//       if (cfg.cols.wo && workOrder) fields.push({ column_id: cfg.cols.wo,  value: { text: `WO: ${workOrder}` } });\r\n//       if (cfg.cols.lsn && localSN)  fields.push({ column_id: cfg.cols.lsn, value: { text: localSN } });\r\n\r\n//       // NOW build the create body (cfg & fields exist)\r\n//       const createBody = {\r\n//         list_id: cfg.id,\r\n//         title: plain(title) || plain(localSN) || \"Untitled\",\r\n//         fields,\r\n//       };\r\n\r\n//       const created = await slack(\"slackLists.items.create\", JSON.stringify(createBody));\r\n//       if (!created?.ok) {\r\n//         console.error(\"slackLists.items.create error:\", created);\r\n//         return res.status(400).json({ error: created?.error || \"Slack Lists API error\", raw: created });\r\n//       }\r\n\r\n//       // Photos -> attachment column\r\n//       if (cfg.cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\r\n//         const fileIds = [];\r\n//         for (const url of photoUrls) {\r\n//           const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\r\n//             method: \"POST\",\r\n//             headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n//             body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\r\n//           }).then(r => r.json());\r\n\r\n//           if (!init?.ok || !init?.upload_url) continue;\r\n\r\n//           try {\r\n//             const img = await fetch(url);\r\n//             const buf = await img.arrayBuffer();\r\n//             await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\r\n//           } catch (_) {}\r\n\r\n//           const complete = await slack(\"files.completeUploadExternal\",\r\n//             JSON.stringify({ files: [{ id: init.file_id, title: \"photo\" }] })\r\n//           );\r\n//           if (complete?.ok && complete?.files?.[0]?.id) fileIds.push(complete.files[0].id);\r\n//         }\r\n\r\n//         if (fileIds.length) {\r\n//           await slack(\"slackLists.items.update\", JSON.stringify({\r\n//             list_id: cfg.id,\r\n//             item_id: created.item.id,\r\n//             fields: [{ column_id: cfg.cols.photos, value: { attachment: { file_ids: fileIds } } }],\r\n//           }));\r\n//         }\r\n//       }\r\n\r\n//       return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: created.item.id });\r\n//     }\r\n\r\n//     // ---------- PATH B: Fallback to a channel post ----------\r\n//     const channel = CHANNELS[listKey];\r\n//     if (!channel) return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\r\n\r\n//     // Try to join public channels to avoid channel_not_found\r\n//     await fetch(\"https://slack.com/api/conversations.join\", {\r\n//       method: \"POST\",\r\n//       headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n//       body: new URLSearchParams({ channel }),\r\n//     });\r\n\r\n//     const safeId = plain(linkUrl?.split(\"/\").pop()) || plain(localSN) || \"\";\r\n//     const safeTitle = plain(title) || plain(req.body?.title) || (safeId ? `Item ${safeId}` : \"New Item\");\r\n\r\n//     const lines = [];\r\n//     lines.push(`*${safeTitle}*`);\r\n\r\n//     const pnStr = joinArr(pn);\r\n//     const snStr = joinArr(sn);\r\n//     if (pnStr) lines.push(`PN: ${pnStr}`);\r\n//     if (snStr) lines.push(`SN: ${snStr}`);\r\n//     if (safe(workOrder)) lines.push(`WO: ${safe(workOrder)}`);\r\n//     if (safe(poNumber)) lines.push(`PO: ${safe(poNumber)}`);\r\n//     if (safe(trackingNumber)) lines.push(`RL: ${safe(trackingNumber)}`);\r\n//     if (safe(dom)) lines.push(`DOM: ${safe(dom)}`);\r\n//     if (safe(localSN)) lines.push(`Local SN: ${safe(localSN)}`);\r\n//     if (safe(date)) lines.push(`Date: ${safe(date)}`);\r\n\r\n//     const desc = safe(description);\r\n//     if (desc) lines.push(desc);\r\n//     else if (listKey === \"tasks\" && safe(bodyText)) lines.push(safe(bodyText));\r\n\r\n//     if (safe(linkUrl)) lines.push(`<${safe(linkUrl)}|Open in Magmo>`);\r\n\r\n//     const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\r\n\r\n//     const posted = await slack(\"chat.postMessage\", JSON.stringify({ channel, text }));\r\n//     if (!posted?.ok) {\r\n//       console.error(\"chat.postMessage error:\", posted);\r\n//       return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\r\n//     }\r\n\r\n//     return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\r\n//   } catch (e) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", e);\r\n//     return res.status(500).json({ error: \"Server error\" });\r\n//   }\r\n// }\r\n\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\r\n\r\n  const token = process.env.SLACK_BOT_TOKEN;\r\n  if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\r\n\r\n  // ---------- Payload ----------\r\n  const {\r\n    listKey, // \"tasks\" | \"shipping\" | \"receiving\"\r\n    title, linkUrl, bodyText,\r\n    date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n    photoUrls = [],\r\n  } = req.body || {};\r\n\r\n  // ---------- Env (IDs) ----------\r\n  // Add your primary text column IDs (especially for Tasks) so the name shows in the \"Task\" column.\r\n  const LISTS = {\r\n    tasks: {\r\n      id: process.env.SLACK_LIST_TASKS_ID,\r\n      cols: {\r\n        primary: process.env.SLACK_LIST_TASKS_PRIMARY_COL, // <-- set this to your \"Task\" column id\r\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\r\n      },\r\n    },\r\n    shipping: {\r\n      id: process.env.SLACK_LIST_SHIPPING_ID,\r\n      cols: {\r\n        primary: process.env.SLACK_LIST_SHIPPING_PRIMARY_COL, // optional, used for initial name\r\n        desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n        date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\r\n        pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n        track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n        wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n        lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,\r\n      },\r\n    },\r\n    receiving: {\r\n      id: process.env.SLACK_LIST_RECEIVING_ID,\r\n      cols: {\r\n        primary: process.env.SLACK_LIST_RECEIVING_PRIMARY_COL, // optional, used for initial name\r\n        desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n        date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\r\n        pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n        track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n        wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n        lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL,\r\n      },\r\n    },\r\n  };\r\n\r\n  // Optional channel fallbacks if a List ID isn’t configured\r\n  const CHANNELS = {\r\n    tasks:     process.env.SLACK_CHANNEL_TASKS_ID,\r\n    shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,\r\n    receiving: process.env.SLACK_CHANNEL_RECEIVING_ID,\r\n  };\r\n\r\n  // ---------- Helpers ----------\r\n  const headersJson = {\r\n    Authorization: `Bearer ${token}`,\r\n    \"Content-Type\": \"application/json; charset=utf-8\",\r\n  };\r\n  const slack = (method, body) =>\r\n    fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers: headersJson, body: JSON.stringify(body) })\r\n      .then(r => r.json());\r\n\r\n  const plain = (v) => (v ?? \"\").toString().trim();\r\n  const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n  // Slack Lists text must be sent as \"rich_text\"\r\n  const richText = (text) => [{\r\n    type: \"rich_text\",\r\n    elements: [{\r\n      type: \"rich_text_section\",\r\n      elements: [{ type: \"text\", text: text ?? \"\" }],\r\n    }],\r\n  }];\r\n\r\n  // Normalize/guarantee a non-empty name\r\n  const safeTitle =\r\n    plain(title) ||\r\n    (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\r\n    joinArr(pn) ||\r\n    \"New Item\";\r\n\r\n  // Convert date to YYYY-MM-DD if possible\r\n  const toISODate = (d) => {\r\n    const s = plain(d);\r\n    if (!s) return \"\";\r\n    const dt = new Date(s);\r\n    return isNaN(dt.getTime()) ? \"\" : dt.toISOString().slice(0, 10);\r\n  };\r\n\r\n  // ---------- Verbose logging ----------\r\n  console.log(\"[add-to-list] incoming payload\", {\r\n    listKey, title, safeTitle,\r\n    pn: Array.isArray(pn) ? pn : (pn ? [pn] : []),\r\n    sn: Array.isArray(sn) ? sn : (sn ? [sn] : []),\r\n    localSN, date\r\n  });\r\n  console.log(\"[add-to-list] env presence\", {\r\n    hasListTasks: !!process.env.SLACK_LIST_TASKS_ID,\r\n    hasListShipping: !!process.env.SLACK_LIST_SHIPPING_ID,\r\n    hasListReceiving: !!process.env.SLACK_LIST_RECEIVING_ID,\r\n    tasksPrimaryCol: process.env.SLACK_LIST_TASKS_PRIMARY_COL,\r\n  });\r\n\r\n  const cfg = LISTS[listKey];\r\n\r\n  // ============================================================\r\n  // PATH A: Slack Lists (preferred)\r\n  // ============================================================\r\n  if (cfg?.id) {\r\n    try {\r\n      // Choose a primary column for the initial name (fallback to desc if primary not provided).\r\n      const primaryColId = cfg.cols?.primary || cfg.cols?.desc;\r\n      const initial_fields = [];\r\n\r\n      if (primaryColId) {\r\n        initial_fields.push({ column_id: primaryColId, rich_text: richText(safeTitle) });\r\n      }\r\n\r\n      // For tasks, keep creation minimal (name only).\r\n      // For shipping/receiving, you *may* also seed a description cell up front.\r\n      if (listKey !== \"tasks\" && cfg.cols?.desc && plain(description)) {\r\n        initial_fields.push({ column_id: cfg.cols.desc, rich_text: richText(plain(description)) });\r\n      }\r\n\r\n      const createBody = { list_id: cfg.id };\r\n      if (initial_fields.length) createBody.initial_fields = initial_fields;\r\n\r\n      console.log(\"[add-to-list] CREATE >\", {\r\n        list_id: cfg.id,\r\n        initial_fields_preview: initial_fields.map(f => ({ column_id: f.column_id, kind: Object.keys(f)[1], textPreview: (f.rich_text?.[0]?.elements?.[0]?.elements?.[0]?.text || \"\").slice(0, 80) }))\r\n      });\r\n\r\n      const created = await slack(\"slackLists.items.create\", createBody);\r\n      console.log(\"[add-to-list] CREATE < resp\", created);\r\n\r\n      if (!created?.ok) {\r\n        console.warn(\"[add-to-list] create failed, trying channel fallback:\", created?.error);\r\n        return await channelFallback({\r\n          slack, token, CHANNELS, listKey, safeTitle, linkUrl,\r\n          pn, sn, dom, workOrder, poNumber, trackingNumber, localSN, date, bodyText, description, res\r\n        });\r\n      }\r\n\r\n      const itemId = created?.item?.id;\r\n\r\n      // Build cells to update (correct format per Slack docs)\r\n      const cells = [];\r\n      const addTextCell = (colId, text) => {\r\n        const t = plain(text);\r\n        if (colId && t) cells.push({ row_id: itemId, column_id: colId, rich_text: richText(t) });\r\n      };\r\n\r\n      if (cfg.cols?.desc) {\r\n        const textBits = [\r\n          plain(description),\r\n          listKey === \"tasks\" ? plain(bodyText) : \"\",\r\n          plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\r\n        ].filter(Boolean).join(\"\\n\");\r\n        addTextCell(cfg.cols.desc, textBits);\r\n      }\r\n\r\n      if (cfg.cols?.date) {\r\n        const iso = toISODate(date);\r\n        if (iso) cells.push({ row_id: itemId, column_id: cfg.cols.date, date: [iso] });\r\n      }\r\n\r\n      if (cfg.cols?.pn) {\r\n        const pnStr = joinArr(pn);\r\n        const snStr = joinArr(sn);\r\n        const combo = [\r\n          pnStr && `PN: ${pnStr}`,\r\n          snStr && `SN: ${snStr}`,\r\n          plain(dom) && `DOM: ${plain(dom)}`,\r\n        ].filter(Boolean).join(\"  \");\r\n        addTextCell(cfg.cols.pn, combo);\r\n      }\r\n\r\n      if (cfg.cols?.track) {\r\n        const t = [\r\n          plain(trackingNumber) && `RL: ${plain(trackingNumber)}`,\r\n          plain(poNumber) && `PO: ${plain(poNumber)}`,\r\n        ].filter(Boolean).join(\"  \");\r\n        addTextCell(cfg.cols.track, t);\r\n      }\r\n\r\n      if (cfg.cols?.wo) addTextCell(cfg.cols.wo, plain(workOrder) && `WO: ${plain(workOrder)}`);\r\n      if (cfg.cols?.lsn) addTextCell(cfg.cols.lsn, plain(localSN));\r\n\r\n      if (cells.length) {\r\n        console.log(\"[add-to-list] UPDATE >\", {\r\n          list_id: cfg.id,\r\n          cells_preview: cells.map(c => ({ row_id: c.row_id, column_id: c.column_id, keys: Object.keys(c) }))\r\n        });\r\n\r\n        const updated = await slack(\"slackLists.items.update\", { list_id: cfg.id, cells });\r\n        console.log(\"[add-to-list] UPDATE < resp\", updated);\r\n\r\n        if (!updated?.ok) {\r\n          console.warn(\"[add-to-list] update failed; leaving item with initial fields only:\", updated?.error);\r\n        }\r\n      }\r\n\r\n      return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: itemId, title: safeTitle, primary_col: primaryColId || null });\r\n    } catch (e) {\r\n      console.error(\"[add-to-list] lists path error:\", e);\r\n      return await channelFallback({\r\n        slack, token, CHANNELS, listKey, safeTitle, linkUrl,\r\n        pn, sn, dom, workOrder, poNumber, trackingNumber, localSN, date, bodyText, description, res\r\n      });\r\n    }\r\n  }\r\n\r\n  // ============================================================\r\n  // PATH B: Channel fallback (if no list configured)\r\n  // ============================================================\r\n  return await channelFallback({\r\n    slack, token, CHANNELS, listKey, safeTitle, linkUrl,\r\n    pn, sn, dom, workOrder, poNumber, trackingNumber, localSN, date, bodyText, description, res\r\n  });\r\n}\r\n\r\n// ---------------- helpers ----------------\r\n\r\nasync function channelFallback({\r\n  slack, token, CHANNELS, listKey, safeTitle, linkUrl, pn, sn, dom, workOrder, poNumber, trackingNumber, localSN, date, bodyText, description, res\r\n}) {\r\n  const channel = CHANNELS[listKey];\r\n  if (!channel) return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\r\n\r\n  // We’ll just post a message with the essentials\r\n  const plain = (v) => (v ?? \"\").toString().trim();\r\n  const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n  const lines = [ `*${safeTitle}*` ];\r\n  const pnStr = joinArr(pn);\r\n  const snStr = joinArr(sn);\r\n\r\n  if (pnStr) lines.push(`PN: ${pnStr}`);\r\n  if (snStr) lines.push(`SN: ${snStr}`);\r\n  if (plain(workOrder)) lines.push(`WO: ${plain(workOrder)}`);\r\n  if (plain(poNumber))  lines.push(`PO: ${plain(poNumber)}`);\r\n  if (plain(trackingNumber)) lines.push(`RL: ${plain(trackingNumber)}`);\r\n  if (plain(dom)) lines.push(`DOM: ${plain(dom)}`);\r\n  if (plain(localSN)) lines.push(`Local SN: ${plain(localSN)}`);\r\n  const toISODate = (d) => {\r\n    const s = plain(d); if (!s) return \"\"; const dt = new Date(s);\r\n    return isNaN(dt.getTime()) ? \"\" : dt.toISOString().slice(0, 10);\r\n  };\r\n  if (toISODate(date)) lines.push(`Date: ${toISODate(date)}`);\r\n\r\n  const desc = plain(description);\r\n  if (desc) lines.push(desc);\r\n  else if (listKey === \"tasks\" && plain(bodyText)) lines.push(plain(bodyText));\r\n  if (plain(linkUrl)) lines.push(`<${plain(linkUrl)}|Open in Magmo>`);\r\n\r\n  const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\r\n  const posted = await slack(\"chat.postMessage\", { channel, text });\r\n\r\n  if (!posted?.ok) {\r\n    console.error(\"[add-to-list] chat.postMessage error:\", posted);\r\n    return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\r\n  }\r\n  return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\r\n}\r\n"]},"metadata":{},"sourceType":"module"}