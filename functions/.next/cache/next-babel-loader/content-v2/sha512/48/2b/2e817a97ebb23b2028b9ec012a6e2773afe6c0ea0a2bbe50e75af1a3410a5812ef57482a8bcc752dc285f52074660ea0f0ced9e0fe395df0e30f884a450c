{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport firebase from \"../context/Firebase\";\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(partsSnapshot.docs.map(async partDoc => {\n    var _partData$ClientFrom$, _partData$ClientFrom, _partData$ClientCurre, _partData$ClientCurre2;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    partData.clientFromId = (_partData$ClientFrom$ = partData === null || partData === void 0 ? void 0 : (_partData$ClientFrom = partData.ClientFrom) === null || _partData$ClientFrom === void 0 ? void 0 : _partData$ClientFrom.id) !== null && _partData$ClientFrom$ !== void 0 ? _partData$ClientFrom$ : null;\n    partData.clientCurrentId = (_partData$ClientCurre = partData === null || partData === void 0 ? void 0 : (_partData$ClientCurre2 = partData.ClientCurrent) === null || _partData$ClientCurre2 === void 0 ? void 0 : _partData$ClientCurre2.id) !== null && _partData$ClientCurre !== void 0 ? _partData$ClientCurre : null; // console.log(partData);\n\n    if (partData.Machine && partData.Machine instanceof firebase.firestore.DocumentReference) {\n      console.log(partData.Machine);\n      const machineDoc = await partData.Machine.get();\n      partData.machineData = machineDoc.exists ? machineDoc.data() : {};\n\n      if (partData.machineData.client) {\n        const clientDoc = await partData.machineData.client.get();\n        partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    } else {\n      partData.machineData = {};\n    }\n\n    return partData;\n  }));\n  return parts;\n} // Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\n\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false,\n  filterFn = null\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const buildPart = async partDoc => {\n    var _partData$ClientFrom$2, _partData$ClientFrom2, _partData$ClientCurre3, _partData$ClientCurre4;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    partData.clientFromId = (_partData$ClientFrom$2 = partData === null || partData === void 0 ? void 0 : (_partData$ClientFrom2 = partData.ClientFrom) === null || _partData$ClientFrom2 === void 0 ? void 0 : _partData$ClientFrom2.id) !== null && _partData$ClientFrom$2 !== void 0 ? _partData$ClientFrom$2 : null;\n    partData.clientCurrentId = (_partData$ClientCurre3 = partData === null || partData === void 0 ? void 0 : (_partData$ClientCurre4 = partData.ClientCurrent) === null || _partData$ClientCurre4 === void 0 ? void 0 : _partData$ClientCurre4.id) !== null && _partData$ClientCurre3 !== void 0 ? _partData$ClientCurre3 : null;\n\n    const fetchMachineData = async ref => {\n      if (ref && ref instanceof firebase.firestore.DocumentReference) {\n        const doc = await ref.get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      return null;\n    };\n\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef = partData.CurrentMachine || partData.MachineCurrent;\n    const machineData = await fetchMachineData(machineRef);\n    partData.machineData = machineData || {};\n\n    if (machineData !== null && machineData !== void 0 && machineData.client) {\n      const clientDoc = await machineData.client.get();\n      partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n\n      if (!partData.clientFromId) {\n        partData.clientFromId = machineData.client.id || null;\n      }\n    }\n\n    const currentMachineData = await fetchMachineData(currentMachineRef);\n    partData.currentMachineData = currentMachineData || {};\n\n    if (currentMachineData !== null && currentMachineData !== void 0 && currentMachineData.client) {\n      const clientDoc = await currentMachineData.client.get();\n      partData.currentMachineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n\n      if (!partData.clientCurrentId) {\n        partData.clientCurrentId = currentMachineData.client.id || null;\n      }\n    }\n\n    return partData;\n  };\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let pageLastDoc = null;\n  let hasNextPage = false;\n  let filled = false;\n\n  while (true) {\n    let query = db.collection(\"Test\").limit(limit);\n    if (cursor) query = query.startAfter(cursor);\n    const snap = await query.get();\n\n    if (snap.empty) {\n      hasNextPage = false;\n      break;\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = snap.docs[i];\n      cursor = doc;\n      const raw = doc.data();\n\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      const built = await buildPart(doc);\n\n      if (filterFn && !filterFn(built)) {\n        continue;\n      }\n\n      if (!filled) {\n        parts.push(built);\n\n        if (parts.length === pageSize) {\n          filled = true;\n          pageLastDoc = doc;\n        }\n\n        continue;\n      } // We already filled the page and found an extra matching item.\n\n\n      hasNextPage = true;\n      return {\n        parts,\n        lastDoc: pageLastDoc,\n        hasNextPage\n      };\n    } // We exhausted this batch without filling the page.\n\n\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    } // There might be more docs; continue scanning for visible items.\n\n\n    hasNextPage = true;\n  }\n\n  lastDoc = pageLastDoc || (parts.length ? cursor : null);\n  return {\n    parts,\n    lastDoc,\n    hasNextPage: filled ? hasNextPage : false\n  };\n}\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map(doc => _objectSpread({\n    id: doc.id\n  }, doc.data())); // Filter clients based on OEM and Modality if selected\n\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n\n    for (const client of clients) {\n      let match = true;\n\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n\n          if (selectedOEM && machineData.OEM === selectedOEM || selectedModality && machineData.Modality === selectedModality) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n\n    return filteredClients;\n  }\n\n  return clients;\n}\nexport async function fetchModels(selectedOEM, selectedModality, selectedClient) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n  await Promise.all(machinesSnapshot.docs.map(async machineDoc => {\n    const machineData = machineDoc.data();\n    let isValid = true;\n    if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n    if (selectedModality && machineData.Modality !== selectedModality) isValid = false;\n\n    if (selectedClient && machineData.client) {\n      const clientDoc = await machineData.client.get();\n      if (!clientDoc.exists || clientDoc.data().name !== selectedClient) isValid = false;\n    }\n\n    if (isValid) {\n      models.add(machineData.Model);\n    }\n  }));\n  return Array.from(models);\n}\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/utils/fetchAssociations.js"],"names":["React","firebase","fetchPartsWithMachineData","db","firestore","partsSnapshot","collection","get","parts","Promise","all","docs","map","partDoc","partData","data","id","clientFromId","ClientFrom","clientCurrentId","ClientCurrent","Machine","DocumentReference","console","log","machineDoc","machineData","exists","client","clientDoc","Client","name","fetchPartsWithMachineDataPage","pageSize","startAfterDoc","visibleOnly","filterFn","limit","buildPart","fetchMachineData","ref","doc","machineRef","MachineFrom","currentMachineRef","CurrentMachine","MachineCurrent","currentMachineData","cursor","lastDoc","pageLastDoc","hasNextPage","filled","query","startAfter","snap","empty","i","length","raw","visible","built","push","size","fetchClients","selectedOEM","selectedModality","clientsSnapshot","clients","filteredClients","match","machines","OEM","Modality","fetchModels","selectedClient","machinesSnapshot","models","Set","isValid","add","Model","Array","from","formatDate","timestamp","date","toDate","Date","day","String","getDate","padStart","month","getMonth","year","getFullYear"],"mappings":"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","sourcesContent":["import React from 'react'\nimport firebase from \"../context/Firebase\";\n\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(\n    partsSnapshot.docs.map(async (partDoc) => {\n      const partData = partDoc.data();\n      partData.id = partDoc.id; // Add document ID here\n      partData.clientFromId = partData?.ClientFrom?.id ?? null;\n      partData.clientCurrentId = partData?.ClientCurrent?.id ?? null;\n      // console.log(partData);\n      if (\n        partData.Machine &&\n        partData.Machine instanceof firebase.firestore.DocumentReference\n      ) {\n        console.log(partData.Machine);\n        const machineDoc = await partData.Machine.get();\n        partData.machineData = machineDoc.exists ? machineDoc.data() : {};\n        if (partData.machineData.client) {\n          const clientDoc = await partData.machineData.client.get();\n          partData.machineData.Client = clientDoc.exists\n            ? clientDoc.data().name\n            : \"\";\n        }\n      } else {\n        partData.machineData = {};\n      }\n      return partData;\n    })\n  );\n  return parts;\n}\n\n// Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false,\n  filterFn = null,\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const buildPart = async (partDoc) => {\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n    partData.clientFromId = partData?.ClientFrom?.id ?? null;\n    partData.clientCurrentId = partData?.ClientCurrent?.id ?? null;\n\n    const fetchMachineData = async (ref) => {\n      if (ref && ref instanceof firebase.firestore.DocumentReference) {\n        const doc = await ref.get();\n        return doc.exists ? doc.data() : null;\n      }\n      return null;\n    };\n\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef =\n      partData.CurrentMachine || partData.MachineCurrent;\n\n    const machineData = await fetchMachineData(machineRef);\n    partData.machineData = machineData || {};\n    if (machineData?.client) {\n      const clientDoc = await machineData.client.get();\n      partData.machineData.Client = clientDoc.exists\n        ? clientDoc.data().name\n        : \"\";\n      if (!partData.clientFromId) {\n        partData.clientFromId = machineData.client.id || null;\n      }\n    }\n\n    const currentMachineData = await fetchMachineData(currentMachineRef);\n    partData.currentMachineData = currentMachineData || {};\n    if (currentMachineData?.client) {\n      const clientDoc = await currentMachineData.client.get();\n      partData.currentMachineData.Client = clientDoc.exists\n        ? clientDoc.data().name\n        : \"\";\n      if (!partData.clientCurrentId) {\n        partData.clientCurrentId = currentMachineData.client.id || null;\n      }\n    }\n    return partData;\n  };\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let pageLastDoc = null;\n  let hasNextPage = false;\n  let filled = false;\n\n  while (true) {\n    let query = db.collection(\"Test\").limit(limit);\n    if (cursor) query = query.startAfter(cursor);\n\n    const snap = await query.get();\n    if (snap.empty) {\n      hasNextPage = false;\n      break;\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = snap.docs[i];\n      cursor = doc;\n\n      const raw = doc.data();\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      const built = await buildPart(doc);\n      if (filterFn && !filterFn(built)) {\n        continue;\n      }\n\n      if (!filled) {\n        parts.push(built);\n        if (parts.length === pageSize) {\n          filled = true;\n          pageLastDoc = doc;\n        }\n        continue;\n      }\n\n      // We already filled the page and found an extra matching item.\n      hasNextPage = true;\n      return { parts, lastDoc: pageLastDoc, hasNextPage };\n    }\n\n    // We exhausted this batch without filling the page.\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    }\n\n    // There might be more docs; continue scanning for visible items.\n    hasNextPage = true;\n  }\n\n  lastDoc = pageLastDoc || (parts.length ? cursor : null);\n  return { parts, lastDoc, hasNextPage: filled ? hasNextPage : false };\n}\n\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map((doc) => ({\n    id: doc.id,\n    ...doc.data(),\n  }));\n\n  // Filter clients based on OEM and Modality if selected\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n    for (const client of clients) {\n      let match = true;\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n          if (\n            (selectedOEM && machineData.OEM === selectedOEM) ||\n            (selectedModality && machineData.Modality === selectedModality)\n          ) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n    return filteredClients;\n  }\n\n  return clients;\n}\n\nexport async function fetchModels(\n  selectedOEM,\n  selectedModality,\n  selectedClient\n) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n\n  await Promise.all(\n    machinesSnapshot.docs.map(async (machineDoc) => {\n      const machineData = machineDoc.data();\n      let isValid = true;\n\n      if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n      if (selectedModality && machineData.Modality !== selectedModality)\n        isValid = false;\n      if (selectedClient && machineData.client) {\n        const clientDoc = await machineData.client.get();\n        if (!clientDoc.exists || clientDoc.data().name !== selectedClient)\n          isValid = false;\n      }\n\n      if (isValid) {\n        models.add(machineData.Model);\n      }\n    })\n  );\n\n  return Array.from(models);\n}\n\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}\n"]},"metadata":{},"sourceType":"module"}