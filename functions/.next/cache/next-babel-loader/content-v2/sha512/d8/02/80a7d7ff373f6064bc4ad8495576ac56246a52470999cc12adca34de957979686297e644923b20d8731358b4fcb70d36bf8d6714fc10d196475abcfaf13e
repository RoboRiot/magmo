{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  const t0 = Date.now();\n  const steps = [];\n\n  const logStep = (step, extra = {}) => steps.push(_objectSpread({\n    t: new Date().toISOString(),\n    step\n  }, extra));\n\n  try {\n    var _created$item;\n\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n\n    if (!token) {\n      return res.status(500).json({\n        ok: false,\n        error: \"missing_SLACK_BOT_TOKEN\"\n      });\n    } // ---------- payload from client ----------\n\n\n    const {\n      listKey,\n      // \"tasks\" | \"shipping\" | \"receiving\"\n      title,\n      // item title\n      pn_sn,\n      // preferred input: \"PN: 123  SN: 456\"\n      work_order,\n      // preferred input\n      tracking,\n      local_sn,\n      // preferred input\n      description,\n      photoUrls,\n      // preferred input: array\n      // legacy keys we still accept for safety:\n      pn,\n      sn,\n      workOrder,\n      localSN,\n      trackingNumber,\n      photo_urls,\n      photos\n    } = req.body || {}; // Normalize inputs so both old & new callers work\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const pn_sn_norm = (() => {\n      if (plain(pn_sn)) return plain(pn_sn);\n      const pn0 = plain(pn);\n      const sn0 = plain(sn);\n      const parts = [];\n      if (pn0) parts.push(`PN: ${pn0}`);\n      if (sn0) parts.push(`SN: ${sn0}`);\n      return parts.join(\"  \");\n    })();\n\n    const work_order_norm = plain(work_order || workOrder || \"\");\n    const local_sn_norm = plain(local_sn || localSN || \"\");\n    const tracking_norm = plain(tracking || trackingNumber || \"\");\n    const description_norm = plain(description || \"\");\n    let photoUrls_norm = Array.isArray(photoUrls) ? photoUrls : Array.isArray(photo_urls) ? photo_urls : Array.isArray(photos) ? photos : []; // ---------- env: list + column ids ----------\n\n    const LIST_IDS = {\n      tasks: process.env.SLACK_LIST_TASKS_ID,\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\n      receiving: process.env.SLACK_LIST_RECEIVING_ID\n    };\n    const COLS = {\n      tasks: {\n        title: process.env.SLACK_LIST_TASKS_TITLE_COL,\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL\n      },\n      shipping: {\n        title: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\n        desc: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n        pnsn: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n        wo: process.env.SLACK_LIST_SHIPPING_WO_COL,\n        localsn: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n        tracking: process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL\n      },\n      receiving: {\n        title: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\n        desc: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n        pnsn: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n        wo: process.env.SLACK_LIST_RECEIVING_WO_COL,\n        localsn: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n        tracking: process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL\n      }\n    };\n    const list_id = LIST_IDS[listKey];\n    const CFG = COLS[listKey] || {};\n\n    if (!list_id) {\n      return res.status(400).json({\n        ok: false,\n        error: `unknown_listKey_${listKey}`\n      });\n    }\n\n    if (!CFG.title) {\n      return res.status(400).json({\n        ok: false,\n        error: \"missing_title_column_env\"\n      });\n    } // ---------- helpers ----------\n\n\n    async function slackJson(method, payload) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(payload)\n      });\n      const json = await r.json();\n      return json;\n    }\n\n    function richText(text) {\n      const t = plain(text);\n      return [{\n        type: \"rich_text\",\n        elements: [{\n          type: \"rich_text_section\",\n          elements: [{\n            type: \"text\",\n            text: t || \"\"\n          }]\n        }]\n      }];\n    }\n\n    const safeFilenameFromUrl = (url, i) => {\n      try {\n        // last path piece (may be the encoded \"Parts%2F...jpg\")\n        const last = (url.split(\"/\").pop() || \"\").split(\"?\")[0]; // decode, THEN take last segment again (in case it contains '/')\n\n        const decoded = decodeURIComponent(last);\n        const basename = decoded.split(\"/\").pop() || decoded; // replace anything unsafe (slashes, spaces, etc.)\n\n        const safe = basename.replace(/[^\\w.\\-]+/g, \"_\");\n        return safe || `photo_${i + 1}.jpg`;\n      } catch {\n        return `photo_${i + 1}.jpg`;\n      }\n    }; // ---------- 1) create the row with title ----------\n\n\n    const titleText = plain(title) || \"Untitled item\";\n    const createPayload = {\n      list_id,\n      initial_fields: [{\n        column_id: CFG.title,\n        rich_text: richText(titleText)\n      }]\n    };\n    const created = await slackJson(\"slackLists.items.create\", createPayload);\n    logStep(\"[LISTS][CREATE-RICH]\", {\n      ok: (created === null || created === void 0 ? void 0 : created.ok) === true,\n      status: 200,\n      error: created === null || created === void 0 ? void 0 : created.error\n    });\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(200).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\",\n        debug: {\n          steps\n        }\n      });\n    }\n\n    const rowId = (_created$item = created.item) === null || _created$item === void 0 ? void 0 : _created$item.id;\n    logStep(\"[LISTS][CREATED]\", {\n      rowId\n    }); // ---------- 2) update rich_text fields ----------\n\n    const cells = [];\n    if (CFG.pnsn && pn_sn_norm) cells.push({\n      row_id: rowId,\n      column_id: CFG.pnsn,\n      rich_text: richText(pn_sn_norm)\n    });\n    if (CFG.localsn && local_sn_norm) cells.push({\n      row_id: rowId,\n      column_id: CFG.localsn,\n      rich_text: richText(local_sn_norm)\n    });\n    if (CFG.wo && work_order_norm) cells.push({\n      row_id: rowId,\n      column_id: CFG.wo,\n      rich_text: richText(work_order_norm)\n    });\n    if (CFG.tracking && tracking_norm) cells.push({\n      row_id: rowId,\n      column_id: CFG.tracking,\n      rich_text: richText(tracking_norm)\n    });\n    if (CFG.desc && description_norm) cells.push({\n      row_id: rowId,\n      column_id: CFG.desc,\n      rich_text: richText(description_norm)\n    });\n\n    if (cells.length) {\n      const updated = await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells\n      });\n      if (CFG.pnsn && pn_sn_norm) logStep(\"[LISTS][SET-RICH][PN/SN]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.localsn && local_sn_norm) logStep(\"[LISTS][SET-RICH][LOCAL_SN]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.desc && description_norm) logStep(\"[LISTS][SET-RICH][DESCRIPTION]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.wo && work_order_norm) logStep(\"[LISTS][SET-RICH][WO]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.tracking && tracking_norm) logStep(\"[LISTS][SET-RICH][TRACKING]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n\n      if (!(updated !== null && updated !== void 0 && updated.ok)) {\n        return res.status(200).json({\n          ok: false,\n          error: (updated === null || updated === void 0 ? void 0 : updated.error) || \"update_failed\",\n          debug: {\n            steps\n          }\n        });\n      }\n    } // ---------- 3) upload photos ----------\n\n\n    async function uploadViaExternal(fileUrl, filename) {\n      // 3a. fetch bytes\n      const resp = await fetch(fileUrl);\n      const buf = await resp.arrayBuffer();\n      const byteLen = buf.byteLength;\n      logStep(\"[FILES.BYTES]\", {\n        byteLen,\n        filename\n      }); // 3b. get upload url (filename MUST be a single segment; no '/')\n\n      const up = await slackJson(\"files.getUploadURLExternal\", {\n        filename,\n        length: byteLen\n      });\n      logStep(\"[FILES.GETUPLOAD]\", {\n        ok: (up === null || up === void 0 ? void 0 : up.ok) === true,\n        status: 200,\n        byteLen,\n        filename,\n        error: up === null || up === void 0 ? void 0 : up.error\n      });\n      if (!(up !== null && up !== void 0 && up.ok) || !(up !== null && up !== void 0 && up.upload_url) || !(up !== null && up !== void 0 && up.file_id)) return {\n        ok: false,\n        error: (up === null || up === void 0 ? void 0 : up.error) || \"get_upload_url_failed\"\n      }; // 3c. post bytes to the upload_url\n\n      const post = await fetch(up.upload_url, {\n        method: \"POST\",\n        body: Buffer.from(buf)\n      });\n      logStep(\"[FILES.UPLOAD.POST]\", {\n        ok: (post === null || post === void 0 ? void 0 : post.ok) === true,\n        status: post === null || post === void 0 ? void 0 : post.status\n      });\n      if (!post.ok) return {\n        ok: false,\n        error: \"upload_post_failed\"\n      }; // 3d. complete\n\n      const complete = await slackJson(\"files.completeUploadExternal\", {\n        files: [{\n          id: up.file_id,\n          title: filename\n        }]\n      });\n      logStep(\"[FILES.COMPLETE]\", {\n        ok: (complete === null || complete === void 0 ? void 0 : complete.ok) === true,\n        status: 200,\n        error: complete === null || complete === void 0 ? void 0 : complete.error\n      });\n      if (!(complete !== null && complete !== void 0 && complete.ok)) return {\n        ok: false,\n        error: (complete === null || complete === void 0 ? void 0 : complete.error) || \"complete_failed\"\n      };\n      return {\n        ok: true,\n        file: {\n          id: up.file_id\n        }\n      };\n    }\n\n    async function attachFilesToCell(listId, row, col, fileIds) {\n      var _r, _r2, _r3, _r4, _r5, _r6, _r7, _r8, _r9, _r10, _r11;\n\n      // Try a few shapes. Different list column types accept different shapes.\n      // A) \"attachment\": [ \"F...\" ]\n      let r = await slackJson(\"slackLists.items.update\", {\n        list_id: listId,\n        cells: [{\n          row_id: row,\n          column_id: col,\n          attachment: fileIds\n        }]\n      });\n      logStep(\"[LISTS][ATTACH-A][PHOTOS]\", {\n        ok: ((_r = r) === null || _r === void 0 ? void 0 : _r.ok) === true,\n        status: 200,\n        error: (_r2 = r) === null || _r2 === void 0 ? void 0 : _r2.error\n      });\n      if ((_r3 = r) !== null && _r3 !== void 0 && _r3.ok) return r; // B) \"files\": [{ id: 'F...' }]\n\n      r = await slackJson(\"slackLists.items.update\", {\n        list_id: listId,\n        cells: [{\n          row_id: row,\n          column_id: col,\n          files: fileIds.map(id => ({\n            id\n          }))\n        }]\n      });\n      logStep(\"[LISTS][ATTACH-B][PHOTOS]\", {\n        ok: ((_r4 = r) === null || _r4 === void 0 ? void 0 : _r4.ok) === true,\n        status: 200,\n        error: (_r5 = r) === null || _r5 === void 0 ? void 0 : _r5.error\n      });\n      if ((_r6 = r) !== null && _r6 !== void 0 && _r6.ok) return r; // C) \"files\": [{ file_id: 'F...' }]\n\n      r = await slackJson(\"slackLists.items.update\", {\n        list_id: listId,\n        cells: [{\n          row_id: row,\n          column_id: col,\n          files: fileIds.map(id => ({\n            file_id: id\n          }))\n        }]\n      });\n      logStep(\"[LISTS][ATTACH-C][PHOTOS]\", {\n        ok: ((_r7 = r) === null || _r7 === void 0 ? void 0 : _r7.ok) === true,\n        status: 200,\n        error: (_r8 = r) === null || _r8 === void 0 ? void 0 : _r8.error\n      });\n      if ((_r9 = r) !== null && _r9 !== void 0 && _r9.ok) return r; // D) \"reference\": [{ file: { file_id: 'F...' } }]\n\n      r = await slackJson(\"slackLists.items.update\", {\n        list_id: listId,\n        cells: [{\n          row_id: row,\n          column_id: col,\n          reference: fileIds.map(id => ({\n            file: {\n              file_id: id\n            }\n          }))\n        }]\n      });\n      logStep(\"[LISTS][ATTACH-D][PHOTOS]\", {\n        ok: ((_r10 = r) === null || _r10 === void 0 ? void 0 : _r10.ok) === true,\n        status: 200,\n        error: (_r11 = r) === null || _r11 === void 0 ? void 0 : _r11.error\n      });\n      return r;\n    }\n\n    let attachedOk = false;\n    let uploadedFileIds = [];\n\n    if (CFG.photos && Array.isArray(photoUrls_norm) && photoUrls_norm.length) {\n      for (let i = 0; i < Math.min(photoUrls_norm.length, 10); i++) {\n        var _up$file, _up$file2;\n\n        const url = plain(photoUrls_norm[i]);\n        if (!/^https?:\\/\\//i.test(url)) continue;\n        const filename = safeFilenameFromUrl(url, i);\n        const up = await uploadViaExternal(url, filename);\n        logStep(\"[PHOTOS][UPLOADED]\", {\n          ok: (up === null || up === void 0 ? void 0 : up.ok) === true,\n          file_id: up === null || up === void 0 ? void 0 : (_up$file = up.file) === null || _up$file === void 0 ? void 0 : _up$file.id,\n          filename\n        });\n        if (up !== null && up !== void 0 && up.ok && (_up$file2 = up.file) !== null && _up$file2 !== void 0 && _up$file2.id) uploadedFileIds.push(up.file.id);\n      }\n\n      if (uploadedFileIds.length) {\n        const att = await attachFilesToCell(list_id, rowId, CFG.photos, uploadedFileIds);\n        attachedOk = !!(att !== null && att !== void 0 && att.ok);\n\n        if (!attachedOk) {\n          logStep(\"[PHOTOS][FAILED-ATTACH]\", {\n            error: att === null || att === void 0 ? void 0 : att.error,\n            ids: uploadedFileIds\n          });\n        }\n      } else {\n        logStep(\"[PHOTOS][NO-IDS]\", {\n          reason: \"upload_failed_or_empty\"\n        });\n      }\n    } // Fallback: drop photo URLs into Description so nothing is lost\n\n\n    if (!attachedOk && CFG.desc && photoUrls_norm !== null && photoUrls_norm !== void 0 && photoUrls_norm.length) {\n      const updated = await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id: rowId,\n          column_id: CFG.desc,\n          rich_text: richText(`${description_norm}\\n\\nPhotos:\\n${photoUrls_norm.join(\"\\n\")}`)\n        }]\n      });\n      logStep(\"[LISTS][SET-RICH][PHOTOS->DESC-FALLBACK]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n    }\n\n    return res.status(200).json({\n      ok: true,\n      list_id,\n      item_id: rowId,\n      used_cols: {\n        title_col: CFG.title || null,\n        pnsn_col: CFG.pnsn || null,\n        description_col: CFG.desc || null,\n        workorder_col: CFG.wo || null,\n        localsn_col: CFG.localsn || null,\n        tracking_col: CFG.tracking || null,\n        photos_col: CFG.photos || null\n      },\n      debug: {\n        steps,\n        photos: uploadedFileIds\n      },\n      ms: Date.now() - t0\n    });\n  } catch (err) {\n    logStep(\"[EXCEPTION]\", {\n      message: err === null || err === void 0 ? void 0 : err.message\n    });\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err),\n      debug: {\n        steps\n      }\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","t0","Date","now","steps","logStep","step","extra","push","t","toISOString","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn_sn","work_order","tracking","local_sn","description","photoUrls","pn","sn","workOrder","localSN","trackingNumber","photo_urls","photos","body","plain","v","toString","trim","pn_sn_norm","pn0","sn0","parts","join","work_order_norm","local_sn_norm","tracking_norm","description_norm","photoUrls_norm","Array","isArray","LIST_IDS","tasks","SLACK_LIST_TASKS_ID","shipping","SLACK_LIST_SHIPPING_ID","receiving","SLACK_LIST_RECEIVING_ID","COLS","SLACK_LIST_TASKS_TITLE_COL","desc","SLACK_LIST_TASKS_DESCRIPTION_COL","SLACK_LIST_SHIPPING_TITLE_COL","SLACK_LIST_SHIPPING_DESCRIPTION_COL","pnsn","SLACK_LIST_SHIPPING_PNSN_COL","wo","SLACK_LIST_SHIPPING_WO_COL","localsn","SLACK_LIST_SHIPPING_LOCALSN_COL","SLACK_LIST_SHIPPING_TRACKING_COL","SLACK_LIST_SHIPPING_PHOTOS_COL","SLACK_LIST_RECEIVING_TITLE_COL","SLACK_LIST_RECEIVING_DESCRIPTION_COL","SLACK_LIST_RECEIVING_PNSN_COL","SLACK_LIST_RECEIVING_WO_COL","SLACK_LIST_RECEIVING_LOCALSN_COL","SLACK_LIST_RECEIVING_TRACKING_COL","SLACK_LIST_RECEIVING_PHOTOS_COL","list_id","CFG","slackJson","payload","r","fetch","headers","Authorization","JSON","stringify","richText","text","type","elements","safeFilenameFromUrl","url","i","last","split","pop","decoded","decodeURIComponent","basename","safe","replace","titleText","createPayload","initial_fields","column_id","rich_text","created","debug","rowId","item","id","cells","row_id","length","updated","uploadViaExternal","fileUrl","filename","resp","buf","arrayBuffer","byteLen","byteLength","up","upload_url","file_id","post","Buffer","from","complete","files","file","attachFilesToCell","listId","row","col","fileIds","attachment","map","reference","attachedOk","uploadedFileIds","Math","min","test","att","ids","reason","item_id","used_cols","title_col","pnsn_col","description_col","workorder_col","localsn_col","tracking_col","photos_col","ms","err","message","console","String"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,QAAMC,EAAE,GAAGC,IAAI,CAACC,GAAL,EAAX;AACA,QAAMC,KAAK,GAAG,EAAd;;AACA,QAAMC,OAAO,GAAG,CAACC,IAAD,EAAOC,KAAK,GAAG,EAAf,KACdH,KAAK,CAACI,IAAN;AAAaC,IAAAA,CAAC,EAAE,IAAIP,IAAJ,GAAWQ,WAAX,EAAhB;AAA0CJ,IAAAA;AAA1C,KAAmDC,KAAnD,EADF;;AAGA,MAAI;AAAA;;AACF,QAAIR,GAAG,CAACY,MAAJ,KAAe,MAAnB,EAA2B;AACzB,aAAOX,GAAG,CAACY,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   try {\r\n//     if (req.method !== \"POST\") {\r\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//     }\r\n\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) {\r\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//     }\r\n\r\n//     // payload from client\r\n//     const {\r\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n//       title,               // item title (what shows in the primary column)\r\n//       // keeping minimal per your request: PN/SN only for now\r\n//       pn, sn,\r\n//     } = req.body || {};\r\n\r\n//     // list ids from env\r\n//     const LIST_IDS = {\r\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\r\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n//     };\r\n\r\n//     const list_id = LIST_IDS[listKey];\r\n//     if (!list_id) {\r\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n//     }\r\n\r\n//     // ---- Slack helpers ----\r\n//     async function slackJson(method, payload) {\r\n//       const r = await fetch(`https://slack.com/api/${method}`, {\r\n//         method: \"POST\",\r\n//         headers: {\r\n//           Authorization: `Bearer ${token}`,\r\n//           \"Content-Type\": \"application/json; charset=utf-8\",\r\n//         },\r\n//         body: JSON.stringify(payload),\r\n//       });\r\n//       return r.json();\r\n//     }\r\n\r\n//     const plain = (v) => (v ?? \"\").toString().trim();\r\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     function toRichText(text) {\r\n//       const t = plain(text);\r\n//       return [{\r\n//         type: \"rich_text\",\r\n//         elements: [{\r\n//           type: \"rich_text_section\",\r\n//           elements: [{ type: \"text\", text: t }],\r\n//         }],\r\n//       }];\r\n//     }\r\n\r\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n//     async function resolveTitleColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n//       let fallback = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\r\n//           if (f.column_id && hasText) {\r\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n//             if (!fallback) fallback = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return fallback; // first text-like field if we didn't find a perfect match\r\n//     }\r\n\r\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n//     async function resolvePnSnColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       let candidate = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           if (!f.column_id) continue;\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const text = (f.text || \"\").toLowerCase();\r\n\r\n//           const looksPnSn =\r\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\r\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n//           if (looksPnSn) return f.column_id;\r\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n//             candidate = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return candidate;\r\n//     }\r\n\r\n//     // 1) Resolve columns\r\n//     const titleColId = await resolveTitleColId(list_id);\r\n//     if (!titleColId) {\r\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n//     }\r\n\r\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n//     const safeTitle = plain(title) || \"New Item\";\r\n//     const createBody = {\r\n//       list_id,\r\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n//     };\r\n\r\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 3) (Minimal) update: PN/SN only, per your request\r\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n//     let updated = null;\r\n//     let usedPnSnCol = null;\r\n\r\n//     if (pnSnText) {\r\n//       const pnSnColId = await resolvePnSnColId(list_id);\r\n//       if (pnSnColId) {\r\n//         const cells = [{\r\n//           row_id: created.item.id,\r\n//           column_id: pnSnColId,\r\n//           rich_text: toRichText(pnSnText),\r\n//         }];\r\n\r\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n//         usedPnSnCol = pnSnColId;\r\n//         // If update fails, we still return ok:false so you can see the error\r\n//         if (!updated?.ok) {\r\n//           return res.status(200).json({\r\n//             ok: false,\r\n//             error: updated?.error || \"update_failed\",\r\n//             mode: \"list\",\r\n//             list_id,\r\n//             item_id: created.item.id,\r\n//             used_title_col: titleColId,\r\n//             used_pnsn_col: usedPnSnCol,\r\n//           });\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleColId,\r\n//       used_pnsn_col: usedPnSnCol || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  const t0 = Date.now();\r\n  const steps = [];\r\n  const logStep = (step, extra = {}) =>\r\n    steps.push({ t: new Date().toISOString(), step, ...extra });\r\n\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) {\r\n      return res\r\n        .status(500)\r\n        .json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n    }\r\n\r\n    // ---------- payload from client ----------\r\n    const {\r\n      listKey,          // \"tasks\" | \"shipping\" | \"receiving\"\r\n      title,            // item title\r\n      pn_sn,            // preferred input: \"PN: 123  SN: 456\"\r\n      work_order,       // preferred input\r\n      tracking,\r\n      local_sn,         // preferred input\r\n      description,\r\n      photoUrls,        // preferred input: array\r\n      // legacy keys we still accept for safety:\r\n      pn, sn, workOrder, localSN, trackingNumber, photo_urls, photos,\r\n    } = req.body || {};\r\n\r\n    // Normalize inputs so both old & new callers work\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n\r\n    const pn_sn_norm = (() => {\r\n      if (plain(pn_sn)) return plain(pn_sn);\r\n      const pn0 = plain(pn);\r\n      const sn0 = plain(sn);\r\n      const parts = [];\r\n      if (pn0) parts.push(`PN: ${pn0}`);\r\n      if (sn0) parts.push(`SN: ${sn0}`);\r\n      return parts.join(\"  \");\r\n    })();\r\n\r\n    const work_order_norm = plain(work_order || workOrder || \"\");\r\n    const local_sn_norm   = plain(local_sn   || localSN   || \"\");\r\n    const tracking_norm   = plain(tracking   || trackingNumber || \"\");\r\n    const description_norm = plain(description || \"\");\r\n\r\n    let photoUrls_norm = Array.isArray(photoUrls)\r\n      ? photoUrls\r\n      : Array.isArray(photo_urls)\r\n      ? photo_urls\r\n      : Array.isArray(photos)\r\n      ? photos\r\n      : [];\r\n\r\n    // ---------- env: list + column ids ----------\r\n    const LIST_IDS = {\r\n      tasks:     process.env.SLACK_LIST_TASKS_ID,\r\n      shipping:  process.env.SLACK_LIST_SHIPPING_ID,\r\n      receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n    };\r\n\r\n    const COLS = {\r\n      tasks: {\r\n        title: process.env.SLACK_LIST_TASKS_TITLE_COL,\r\n        desc:  process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\r\n      },\r\n      shipping: {\r\n        title:     process.env.SLACK_LIST_SHIPPING_TITLE_COL,\r\n        desc:      process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n        pnsn:      process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n        wo:        process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n        localsn:   process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n        tracking:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n        photos:    process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,\r\n      },\r\n      receiving: {\r\n        title:     process.env.SLACK_LIST_RECEIVING_TITLE_COL,\r\n        desc:      process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n        pnsn:      process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n        wo:        process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n        localsn:   process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n        tracking:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n        photos:    process.env.SLACK_LIST_RECEIVING_PHOTOS_COL,\r\n      },\r\n    };\r\n\r\n    const list_id = LIST_IDS[listKey];\r\n    const CFG = COLS[listKey] || {};\r\n    if (!list_id) {\r\n      return res\r\n        .status(400)\r\n        .json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n    }\r\n    if (!CFG.title) {\r\n      return res\r\n        .status(400)\r\n        .json({ ok: false, error: \"missing_title_column_env\" });\r\n    }\r\n\r\n    // ---------- helpers ----------\r\n    async function slackJson(method, payload) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          Authorization: `Bearer ${token}`,\r\n          \"Content-Type\": \"application/json; charset=utf-8\",\r\n        },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      const json = await r.json();\r\n      return json;\r\n    }\r\n\r\n    function richText(text) {\r\n      const t = plain(text);\r\n      return [\r\n        {\r\n          type: \"rich_text\",\r\n          elements: [\r\n            {\r\n              type: \"rich_text_section\",\r\n              elements: [{ type: \"text\", text: t || \"\" }],\r\n            },\r\n          ],\r\n        },\r\n      ];\r\n    }\r\n\r\n    const safeFilenameFromUrl = (url, i) => {\r\n      try {\r\n        // last path piece (may be the encoded \"Parts%2F...jpg\")\r\n        const last = (url.split(\"/\").pop() || \"\").split(\"?\")[0];\r\n        // decode, THEN take last segment again (in case it contains '/')\r\n        const decoded = decodeURIComponent(last);\r\n        const basename = decoded.split(\"/\").pop() || decoded;\r\n        // replace anything unsafe (slashes, spaces, etc.)\r\n        const safe = basename.replace(/[^\\w.\\-]+/g, \"_\");\r\n        return safe || `photo_${i + 1}.jpg`;\r\n      } catch {\r\n        return `photo_${i + 1}.jpg`;\r\n      }\r\n    };\r\n\r\n    // ---------- 1) create the row with title ----------\r\n    const titleText = plain(title) || \"Untitled item\";\r\n    const createPayload = {\r\n      list_id,\r\n      initial_fields: [{ column_id: CFG.title, rich_text: richText(titleText) }],\r\n    };\r\n\r\n    const created = await slackJson(\"slackLists.items.create\", createPayload);\r\n    logStep(\"[LISTS][CREATE-RICH]\", {\r\n      ok: created?.ok === true,\r\n      status: 200,\r\n      error: created?.error,\r\n    });\r\n    if (!created?.ok) {\r\n      return res\r\n        .status(200)\r\n        .json({ ok: false, error: created?.error || \"create_failed\", debug: { steps } });\r\n    }\r\n    const rowId = created.item?.id;\r\n    logStep(\"[LISTS][CREATED]\", { rowId });\r\n\r\n    // ---------- 2) update rich_text fields ----------\r\n    const cells = [];\r\n    if (CFG.pnsn && pn_sn_norm)      cells.push({ row_id: rowId, column_id: CFG.pnsn,     rich_text: richText(pn_sn_norm) });\r\n    if (CFG.localsn && local_sn_norm) cells.push({ row_id: rowId, column_id: CFG.localsn,  rich_text: richText(local_sn_norm) });\r\n    if (CFG.wo && work_order_norm)   cells.push({ row_id: rowId, column_id: CFG.wo,       rich_text: richText(work_order_norm) });\r\n    if (CFG.tracking && tracking_norm) cells.push({ row_id: rowId, column_id: CFG.tracking, rich_text: richText(tracking_norm) });\r\n    if (CFG.desc && description_norm) cells.push({ row_id: rowId, column_id: CFG.desc,     rich_text: richText(description_norm) });\r\n\r\n    if (cells.length) {\r\n      const updated = await slackJson(\"slackLists.items.update\", {\r\n        list_id,\r\n        cells,\r\n      });\r\n\r\n      if (CFG.pnsn && pn_sn_norm)       logStep(\"[LISTS][SET-RICH][PN/SN]\",       { ok: updated?.ok === true, status: 200, error: updated?.error });\r\n      if (CFG.localsn && local_sn_norm)  logStep(\"[LISTS][SET-RICH][LOCAL_SN]\",    { ok: updated?.ok === true, status: 200, error: updated?.error });\r\n      if (CFG.desc && description_norm)  logStep(\"[LISTS][SET-RICH][DESCRIPTION]\", { ok: updated?.ok === true, status: 200, error: updated?.error });\r\n      if (CFG.wo && work_order_norm)     logStep(\"[LISTS][SET-RICH][WO]\",          { ok: updated?.ok === true, status: 200, error: updated?.error });\r\n      if (CFG.tracking && tracking_norm) logStep(\"[LISTS][SET-RICH][TRACKING]\",    { ok: updated?.ok === true, status: 200, error: updated?.error });\r\n\r\n      if (!updated?.ok) {\r\n        return res\r\n          .status(200)\r\n          .json({ ok: false, error: updated?.error || \"update_failed\", debug: { steps } });\r\n      }\r\n    }\r\n\r\n    // ---------- 3) upload photos ----------\r\n    async function uploadViaExternal(fileUrl, filename) {\r\n      // 3a. fetch bytes\r\n      const resp = await fetch(fileUrl);\r\n      const buf = await resp.arrayBuffer();\r\n      const byteLen = buf.byteLength;\r\n      logStep(\"[FILES.BYTES]\", { byteLen, filename });\r\n\r\n      // 3b. get upload url (filename MUST be a single segment; no '/')\r\n      const up = await slackJson(\"files.getUploadURLExternal\", {\r\n        filename,\r\n        length: byteLen,\r\n      });\r\n      logStep(\"[FILES.GETUPLOAD]\", {\r\n        ok: up?.ok === true,\r\n        status: 200,\r\n        byteLen,\r\n        filename,\r\n        error: up?.error,\r\n      });\r\n      if (!up?.ok || !up?.upload_url || !up?.file_id)\r\n        return { ok: false, error: up?.error || \"get_upload_url_failed\" };\r\n\r\n      // 3c. post bytes to the upload_url\r\n      const post = await fetch(up.upload_url, {\r\n        method: \"POST\",\r\n        body: Buffer.from(buf),\r\n      });\r\n      logStep(\"[FILES.UPLOAD.POST]\", { ok: post?.ok === true, status: post?.status });\r\n      if (!post.ok) return { ok: false, error: \"upload_post_failed\" };\r\n\r\n      // 3d. complete\r\n      const complete = await slackJson(\"files.completeUploadExternal\", {\r\n        files: [{ id: up.file_id, title: filename }],\r\n      });\r\n      logStep(\"[FILES.COMPLETE]\", { ok: complete?.ok === true, status: 200, error: complete?.error });\r\n      if (!complete?.ok) return { ok: false, error: complete?.error || \"complete_failed\" };\r\n\r\n      return { ok: true, file: { id: up.file_id } };\r\n    }\r\n\r\n    async function attachFilesToCell(listId, row, col, fileIds) {\r\n      // Try a few shapes. Different list column types accept different shapes.\r\n      // A) \"attachment\": [ \"F...\" ]\r\n      let r = await slackJson(\"slackLists.items.update\", {\r\n        list_id: listId,\r\n        cells: [{ row_id: row, column_id: col, attachment: fileIds }],\r\n      });\r\n      logStep(\"[LISTS][ATTACH-A][PHOTOS]\", { ok: r?.ok === true, status: 200, error: r?.error });\r\n      if (r?.ok) return r;\r\n\r\n      // B) \"files\": [{ id: 'F...' }]\r\n      r = await slackJson(\"slackLists.items.update\", {\r\n        list_id: listId,\r\n        cells: [{ row_id: row, column_id: col, files: fileIds.map((id) => ({ id })) }],\r\n      });\r\n      logStep(\"[LISTS][ATTACH-B][PHOTOS]\", { ok: r?.ok === true, status: 200, error: r?.error });\r\n      if (r?.ok) return r;\r\n\r\n      // C) \"files\": [{ file_id: 'F...' }]\r\n      r = await slackJson(\"slackLists.items.update\", {\r\n        list_id: listId,\r\n        cells: [{ row_id: row, column_id: col, files: fileIds.map((id) => ({ file_id: id })) }],\r\n      });\r\n      logStep(\"[LISTS][ATTACH-C][PHOTOS]\", { ok: r?.ok === true, status: 200, error: r?.error });\r\n      if (r?.ok) return r;\r\n\r\n      // D) \"reference\": [{ file: { file_id: 'F...' } }]\r\n      r = await slackJson(\"slackLists.items.update\", {\r\n        list_id: listId,\r\n        cells: [{\r\n          row_id: row,\r\n          column_id: col,\r\n          reference: fileIds.map((id) => ({ file: { file_id: id } })),\r\n        }],\r\n      });\r\n      logStep(\"[LISTS][ATTACH-D][PHOTOS]\", { ok: r?.ok === true, status: 200, error: r?.error });\r\n\r\n      return r;\r\n    }\r\n\r\n    let attachedOk = false;\r\n    let uploadedFileIds = [];\r\n\r\n    if (CFG.photos && Array.isArray(photoUrls_norm) && photoUrls_norm.length) {\r\n      for (let i = 0; i < Math.min(photoUrls_norm.length, 10); i++) {\r\n        const url = plain(photoUrls_norm[i]);\r\n        if (!/^https?:\\/\\//i.test(url)) continue;\r\n\r\n        const filename = safeFilenameFromUrl(url, i);\r\n        const up = await uploadViaExternal(url, filename);\r\n        logStep(\"[PHOTOS][UPLOADED]\", {\r\n          ok: up?.ok === true,\r\n          file_id: up?.file?.id,\r\n          filename,\r\n        });\r\n        if (up?.ok && up.file?.id) uploadedFileIds.push(up.file.id);\r\n      }\r\n\r\n      if (uploadedFileIds.length) {\r\n        const att = await attachFilesToCell(\r\n          list_id,\r\n          rowId,\r\n          CFG.photos,\r\n          uploadedFileIds\r\n        );\r\n        attachedOk = !!att?.ok;\r\n        if (!attachedOk) {\r\n          logStep(\"[PHOTOS][FAILED-ATTACH]\", {\r\n            error: att?.error,\r\n            ids: uploadedFileIds,\r\n          });\r\n        }\r\n      } else {\r\n        logStep(\"[PHOTOS][NO-IDS]\", { reason: \"upload_failed_or_empty\" });\r\n      }\r\n    }\r\n\r\n    // Fallback: drop photo URLs into Description so nothing is lost\r\n    if (!attachedOk && CFG.desc && photoUrls_norm?.length) {\r\n      const updated = await slackJson(\"slackLists.items.update\", {\r\n        list_id,\r\n        cells: [{\r\n          row_id: rowId,\r\n          column_id: CFG.desc,\r\n          rich_text: richText(\r\n            `${description_norm}\\n\\nPhotos:\\n${photoUrls_norm.join(\"\\n\")}`\r\n          ),\r\n        }],\r\n      });\r\n      logStep(\"[LISTS][SET-RICH][PHOTOS->DESC-FALLBACK]\", {\r\n        ok: updated?.ok === true,\r\n        status: 200,\r\n        error: updated?.error,\r\n      });\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      list_id,\r\n      item_id: rowId,\r\n      used_cols: {\r\n        title_col: CFG.title || null,\r\n        pnsn_col: CFG.pnsn || null,\r\n        description_col: CFG.desc || null,\r\n        workorder_col: CFG.wo || null,\r\n        localsn_col: CFG.localsn || null,\r\n        tracking_col: CFG.tracking || null,\r\n        photos_col: CFG.photos || null,\r\n      },\r\n      debug: { steps, photos: uploadedFileIds },\r\n      ms: Date.now() - t0,\r\n    });\r\n  } catch (err) {\r\n    logStep(\"[EXCEPTION]\", { message: err?.message });\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res\r\n      .status(500)\r\n      .json({\r\n        ok: false,\r\n        error: \"exception\",\r\n        message: err?.message || String(err),\r\n        debug: { steps },\r\n      });\r\n  }\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}