{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/mack2/Desktop/code/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _defineProperty from \"C:/Users/mack2/Desktop/code/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"C:/Users/mack2/Desktop/code/node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/mack2/Desktop/code/node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _asyncToGenerator from \"C:/Users/mack2/Desktop/code/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// // inflowAPI.js\n// const BASE_URL   = 'https://cloudapi.inflowinventory.com';\n// const COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\n// // (Move this to env vars in prod)\n// const API_KEY    = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\n// const headers = {\n//   'Authorization': `Bearer ${API_KEY}`,\n//   'Content-Type':  'application/json',\n//   // Use the latest you saw in server responses; older also works, but stay current:\n//   'Accept':        'application/json;version=2025-06-24',\n// };\n// async function parseErr(res) {\n//   const t = await res.text();\n//   try { return JSON.parse(t); } catch { return t; }\n// }\n// // --- Look up existing product by name on the collection endpoint ---\n// // Use filter[name] if your tenant supports it; otherwise fall back to filter[smart].\n// async function findProductByName(name) {\n//   // Try exact name filter first\n//   let url = `${BASE_URL}/${COMPANY_ID}/products?filter[name]=${encodeURIComponent(name)}&count=1`;\n//   let res = await fetch(url, { headers });\n//   if (res.ok) {\n//     const data = await res.json();\n//     const items = Array.isArray(data?.items) ? data.items : (Array.isArray(data) ? data : []);\n//     if (items.length) return items[0];\n//   }\n//   // Fallback: smart filter (searches common fields)\n//   url = `${BASE_URL}/${COMPANY_ID}/products?filter[smart]=${encodeURIComponent(name)}&count=1`;\n//   res = await fetch(url, { headers });\n//   if (!res.ok) return null;\n//   const data2 = await res.json();\n//   const items2 = Array.isArray(data2?.items) ? data2.items : (Array.isArray(data2) ? data2 : []);\n//   return items2.length ? items2[0] : null;\n// }\n// class InflowAPI {\n//   /**\n//    * Upsert a product in inFlow via PUT to the collection.\n//    * @param {{ productId?: string, name: string, description: string, imageUrls?: string[], sku?: string }} params\n//    */\n//   static async upsertProduct({ productId, name, description, imageUrls = [], sku }) {\n//     if (!name || !name.trim()) throw new Error('Name is required');\n//     // If no productId, check if one already exists with this name to avoid the unique-name error.\n//     if (!productId) {\n//       const existing = await findProductByName(name.trim());\n//       if (existing && (existing.productId || existing.id)) {\n//         productId = existing.productId || existing.id;\n//       }\n//     }\n//     // If still no id, generate one (this matched your previously-working flow)\n//     const id = productId || crypto.randomUUID();\n//     // Build the payload exactly like your original—PUT to the collection with productId\n//     const payload = {\n//       productId: id,\n//       name,\n//       description,\n//       ...(sku ? { sku } : {}),\n//       ...(imageUrls.length > 0 && {\n//         images: imageUrls.map(u => ({\n//           imageId: crypto.randomUUID(),\n//           originalUrl: u,\n//         })),\n//       }),\n//     };\n//     const url = `${BASE_URL}/${COMPANY_ID}/products`;\n//     const res = await fetch(url, {\n//       method: 'PUT',\n//       headers,\n//       body: JSON.stringify(payload),\n//     });\n//     if (!res.ok) {\n//       const err = await parseErr(res);\n//       throw new Error(`inFlow API error (${res.status}): ${typeof err === 'string' ? err : JSON.stringify(err)}`);\n//     }\n//     return res.json();\n//   }\n// }\n// export default InflowAPI;\n// utils/inflowAPI.js (only the changed bits)\nvar BASE_URL = 'https://cloudapi.inflowinventory.com';\nvar COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\nvar API_KEY = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\nvar headers = {\n  Authorization: \"Bearer \".concat(API_KEY),\n  'Content-Type': 'application/json',\n  // stick to a stable version you know works in your tenant:\n  Accept: 'application/json;version=2024-10-01'\n};\n\nvar n = function n(s) {\n  return (s !== null && s !== void 0 ? s : '').toString().trim();\n};\n\nfunction parseText(_x) {\n  return _parseText.apply(this, arguments);\n} // ---- EXACT lookup helpers (no fuzzy/SMART fallback) ------------------------\n\n\nfunction _parseText() {\n  _parseText = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(res) {\n    var t;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return res.text();\n\n          case 2:\n            t = _context2.sent;\n            _context2.prev = 3;\n            return _context2.abrupt(\"return\", {\n              json: JSON.parse(t),\n              raw: t\n            });\n\n          case 7:\n            _context2.prev = 7;\n            _context2.t0 = _context2[\"catch\"](3);\n            return _context2.abrupt(\"return\", {\n              json: null,\n              raw: t\n            });\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[3, 7]]);\n  }));\n  return _parseText.apply(this, arguments);\n}\n\nfunction findProductIdByExactName(_x2) {\n  return _findProductIdByExactName.apply(this, arguments);\n} // Prefer direct GET /products/{id}; fallback to collection filter by id\n\n\nfunction _findProductIdByExactName() {\n  _findProductIdByExactName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(name) {\n    var nameNorm, url, res, data, items, item;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            nameNorm = n(name);\n\n            if (nameNorm) {\n              _context3.next = 3;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 3:\n            url = \"\".concat(BASE_URL, \"/\").concat(COMPANY_ID, \"/products?filter[name]=\") + \"\".concat(encodeURIComponent(nameNorm), \"&count=1\");\n            _context3.next = 6;\n            return fetch(url, {\n              headers: headers\n            });\n\n          case 6:\n            res = _context3.sent;\n\n            if (res.ok) {\n              _context3.next = 9;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 9:\n            _context3.next = 11;\n            return res.json();\n\n          case 11:\n            data = _context3.sent;\n            items = Array.isArray(data === null || data === void 0 ? void 0 : data.items) ? data.items : Array.isArray(data) ? data : [];\n            item = items[0];\n\n            if (item) {\n              _context3.next = 16;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 16:\n            if (!(n(item.name).toLowerCase() !== nameNorm.toLowerCase())) {\n              _context3.next = 18;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 18:\n            return _context3.abrupt(\"return\", item.productId || item.id || null);\n\n          case 19:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _findProductIdByExactName.apply(this, arguments);\n}\n\nfunction getProductById(_x3) {\n  return _getProductById.apply(this, arguments);\n}\n\nfunction _getProductById() {\n  _getProductById = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(productId) {\n    var res, data, items;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return fetch(\"\".concat(BASE_URL, \"/\").concat(COMPANY_ID, \"/products/\").concat(encodeURIComponent(productId)), {\n              headers: headers\n            });\n\n          case 2:\n            res = _context4.sent;\n\n            if (!res.ok) {\n              _context4.next = 5;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", res.json());\n\n          case 5:\n            _context4.next = 7;\n            return fetch(\"\".concat(BASE_URL, \"/\").concat(COMPANY_ID, \"/products?filter[productId]=\").concat(encodeURIComponent(productId), \"&count=1\"), {\n              headers: headers\n            });\n\n          case 7:\n            res = _context4.sent;\n\n            if (res.ok) {\n              _context4.next = 10;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", null);\n\n          case 10:\n            _context4.next = 12;\n            return res.json();\n\n          case 12:\n            data = _context4.sent;\n            items = Array.isArray(data === null || data === void 0 ? void 0 : data.items) ? data.items : Array.isArray(data) ? data : [];\n            return _context4.abrupt(\"return\", items[0] || null);\n\n          case 15:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getProductById.apply(this, arguments);\n}\n\nfunction buildImages() {\n  var imageUrls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return imageUrls.filter(Boolean).map(function (u) {\n    return {\n      imageId: crypto.randomUUID(),\n      originalUrl: u\n    };\n  });\n}\n\nvar InflowAPI = /*#__PURE__*/function () {\n  function InflowAPI() {\n    _classCallCheck(this, InflowAPI);\n  }\n\n  _createClass(InflowAPI, null, [{\n    key: \"upsertProduct\",\n\n    /**\n     * Strict upsert: exact-name reuse only; verify by id afterward.\n     */\n    value: function () {\n      var _upsertProduct = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n        var _ref2, _after$isActive;\n\n        var productId, name, description, _ref$imageUrls, imageUrls, sku, customFields, nameNorm, id, payload, res, _yield$parseText, json, raw, resolvedId, after;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                productId = _ref.productId, name = _ref.name, description = _ref.description, _ref$imageUrls = _ref.imageUrls, imageUrls = _ref$imageUrls === void 0 ? [] : _ref$imageUrls, sku = _ref.sku, customFields = _ref.customFields;\n                nameNorm = n(name);\n\n                if (nameNorm) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new Error('Name is required');\n\n              case 4:\n                if (productId) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 7;\n                return findProductIdByExactName(nameNorm);\n\n              case 7:\n                productId = _context.sent;\n\n              case 8:\n                id = productId || crypto.randomUUID();\n                payload = _objectSpread(_objectSpread(_objectSpread(_objectSpread({\n                  productId: id,\n                  name: nameNorm,\n                  isActive: true\n                }, n(description) ? {\n                  description: n(description)\n                } : {}), n(sku) ? {\n                  sku: n(sku)\n                } : {}), imageUrls.length ? {\n                  images: buildImages(imageUrls)\n                } : {}), customFields && Object.keys(customFields).length ? {\n                  customFields: customFields\n                } : {});\n                console.log('[inFlow] PUT payload:', payload);\n                _context.next = 13;\n                return fetch(\"\".concat(BASE_URL, \"/\").concat(COMPANY_ID, \"/products\"), {\n                  method: 'PUT',\n                  headers: headers,\n                  body: JSON.stringify(payload)\n                });\n\n              case 13:\n                res = _context.sent;\n                _context.next = 16;\n                return parseText(res);\n\n              case 16:\n                _yield$parseText = _context.sent;\n                json = _yield$parseText.json;\n                raw = _yield$parseText.raw;\n                console.log('[inFlow] Raw PUT response:', res.status, raw);\n\n                if (res.ok) {\n                  _context.next = 22;\n                  break;\n                }\n\n                throw new Error(\"inFlow API error (\".concat(res.status, \"): \").concat(raw));\n\n              case 22:\n                // prefer the id the server gave us (if any), else the one we sent\n                resolvedId = json && (json.productId || json.id) || id; // Verify by ID only (no fuzzy). This prevents false “success”.\n\n                _context.next = 25;\n                return getProductById(resolvedId);\n\n              case 25:\n                after = _context.sent;\n                console.log('[inFlow] Verified by ID:', {\n                  productId: resolvedId,\n                  name: after === null || after === void 0 ? void 0 : after.name,\n                  sku: after === null || after === void 0 ? void 0 : after.sku,\n                  // many tenants surface one of these; log whatever exists so you can tell if it’s hidden\n                  isActive: (_ref2 = (_after$isActive = after === null || after === void 0 ? void 0 : after.isActive) !== null && _after$isActive !== void 0 ? _after$isActive : after === null || after === void 0 ? void 0 : after.active) !== null && _ref2 !== void 0 ? _ref2 : after === null || after === void 0 ? void 0 : after.status,\n                  categoryId: after === null || after === void 0 ? void 0 : after.categoryId\n                });\n\n                if (after) {\n                  _context.next = 29;\n                  break;\n                }\n\n                throw new Error('Write appeared to succeed, but GET by id returned nothing.');\n\n              case 29:\n                return _context.abrupt(\"return\", after);\n\n              case 30:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function upsertProduct(_x4) {\n        return _upsertProduct.apply(this, arguments);\n      }\n\n      return upsertProduct;\n    }()\n  }]);\n\n  return InflowAPI;\n}();\n\nexport default InflowAPI;","map":null,"metadata":{},"sourceType":"module"}