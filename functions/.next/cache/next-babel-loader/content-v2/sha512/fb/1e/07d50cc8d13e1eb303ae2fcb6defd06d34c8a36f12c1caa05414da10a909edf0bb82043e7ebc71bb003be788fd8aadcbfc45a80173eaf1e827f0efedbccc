{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  const dbg = {\n    steps: [],\n    photos: []\n  };\n\n  const log = (step, detail = {}) => {\n    const entry = _objectSpread({\n      t: new Date().toISOString(),\n      step\n    }, detail);\n\n    dbg.steps.push(entry);\n    console.log(\"[SLACK][API]\", step, detail);\n  };\n\n  try {\n    var _created, _created2, _created3, _created$item;\n\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n    if (!token) return res.status(500).json({\n      ok: false,\n      error: \"missing_SLACK_BOT_TOKEN\"\n    }); // ----- request body -----\n\n    const {\n      listKey,\n      title,\n      pn,\n      sn,\n      workOrder,\n      localSN,\n      description,\n      tracking,\n      linkUrl,\n      photoUrls = [],\n      debug = true // keep detailed logs for now\n\n    } = req.body || {}; // ----- env helpers -----\n\n    const clean = s => (s !== null && s !== void 0 ? s : \"\").trim() || undefined;\n\n    const get = k => clean(process.env[k]);\n\n    const anyOf = (...keys) => keys.map(get).find(Boolean); // ----- per-list config (trimmed). Use your exact env names -----\n\n\n    const CFG = {\n      tasks: {\n        list_id: get(\"SLACK_LIST_TASKS_ID\"),\n        title_col: get(\"SLACK_LIST_TASKS_TITLE_COL\"),\n        desc_col: anyOf(\"SLACK_LIST_TASKS_DESCRIPTION_COL\", \"SLACK_LIST_TASKS_DESC_COL\"),\n        pnsn_col: get(\"SLACK_LIST_TASKS_PNSN_COL\"),\n        wo_col: anyOf(\"SLACK_LIST_TASKS_WORKORDER_COL\", \"SLACK_LIST_TASKS_WO_COL\"),\n        localsn_col: get(\"SLACK_LIST_TASKS_LOCALSN_COL\"),\n        tracking_col: get(\"SLACK_LIST_TASKS_TRACKING_COL\"),\n        photos_col: get(\"SLACK_LIST_TASKS_PHOTOS_COL\"),\n        link_col: get(\"SLACK_LIST_TASKS_LINK_COL\")\n      },\n      shipping: {\n        list_id: get(\"SLACK_LIST_SHIPPING_ID\"),\n        title_col: get(\"SLACK_LIST_SHIPPING_TITLE_COL\"),\n        desc_col: anyOf(\"SLACK_LIST_SHIPPING_DESCRIPTION_COL\", \"SLACK_LIST_SHIPPING_DESC_COL\"),\n        pnsn_col: get(\"SLACK_LIST_SHIPPING_PNSN_COL\"),\n        wo_col: anyOf(\"SLACK_LIST_SHIPPING_WORKORDER_COL\", \"SLACK_LIST_SHIPPING_WO_COL\"),\n        localsn_col: get(\"SLACK_LIST_SHIPPING_LOCALSN_COL\"),\n        tracking_col: get(\"SLACK_LIST_SHIPPING_TRACKING_COL\"),\n        photos_col: get(\"SLACK_LIST_SHIPPING_PHOTOS_COL\"),\n        link_col: get(\"SLACK_LIST_SHIPPING_LINK_COL\")\n      },\n      receiving: {\n        list_id: get(\"SLACK_LIST_RECEIVING_ID\"),\n        title_col: get(\"SLACK_LIST_RECEIVING_TITLE_COL\"),\n        desc_col: anyOf(\"SLACK_LIST_RECEIVING_DESCRIPTION_COL\", \"SLACK_LIST_RECEIVING_DESC_COL\"),\n        pnsn_col: get(\"SLACK_LIST_RECEIVING_PNSN_COL\"),\n        wo_col: anyOf(\"SLACK_LIST_RECEIVING_WORKORDER_COL\", \"SLACK_LIST_RECEIVING_WO_COL\"),\n        localsn_col: get(\"SLACK_LIST_RECEIVING_LOCALSN_COL\"),\n        tracking_col: get(\"SLACK_LIST_RECEIVING_TRACKING_COL\"),\n        photos_col: get(\"SLACK_LIST_RECEIVING_PHOTOS_COL\"),\n        link_col: get(\"SLACK_LIST_RECEIVING_LINK_COL\")\n      }\n    }[listKey || \"\"];\n    if (!(CFG !== null && CFG !== void 0 && CFG.list_id)) return res.status(400).json({\n      ok: false,\n      error: `unknown_listKey_${listKey}`\n    });\n\n    if (!CFG.title_col) {\n      return res.status(400).json({\n        ok: false,\n        error: \"missing_title_column_in_env\",\n        fix: `Set SLACK_LIST_${(listKey || \"\").toUpperCase()}_TITLE_COL in .env.local`\n      });\n    } // ----- Slack helpers -----\n\n\n    async function slack(method, payload, tag) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(payload)\n      });\n      const j = await r.json().catch(() => ({}));\n      if (debug) log(tag || method, {\n        ok: j === null || j === void 0 ? void 0 : j.ok,\n        error: j === null || j === void 0 ? void 0 : j.error,\n        status: r.status\n      });\n      return j;\n    }\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const first = x => Array.isArray(x) ? x.find(Boolean) || \"\" : plain(x);\n\n    const toRich = text => [{\n      type: \"rich_text\",\n      elements: [{\n        type: \"rich_text_section\",\n        elements: [{\n          type: \"text\",\n          text: plain(text)\n        }]\n      }]\n    }];\n\n    async function updateOneCellText(list_id, row_id, column_id, value, label) {\n      var _r, _r2, _r3;\n\n      const val = plain(value);\n      if (!val || !column_id) return {\n        ok: true,\n        skipped: true\n      }; // use CELLS array (works in your tenant)\n\n      let r = await slack(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id,\n          column_id,\n          rich_text: toRich(val)\n        }]\n      }, `[LISTS][SET-RICH][${label}]`);\n      if ((_r = r) !== null && _r !== void 0 && _r.ok) return r;\n\n      if (((_r2 = r) === null || _r2 === void 0 ? void 0 : _r2.error) === \"invalid_arguments\" || ((_r3 = r) === null || _r3 === void 0 ? void 0 : _r3.error) === \"invalid_input_type\") {\n        r = await slack(\"slackLists.items.update\", {\n          list_id,\n          cells: [{\n            row_id,\n            column_id,\n            text: val\n          }]\n        }, `[LISTS][SET-TEXT][${label}]`);\n      }\n\n      return r;\n    }\n\n    async function attachFilesToCell(list_id, row_id, column_id, ids, label) {\n      var _r4, _r5, _r6;\n\n      if (!ids.length || !column_id) return {\n        ok: true,\n        skipped: true\n      }; // Try a few shapes; keep using CELLS\n\n      let r = await slack(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id,\n          column_id,\n          attachment: ids\n        }]\n      }, `[LISTS][ATTACH-A][${label}]`);\n      if ((_r4 = r) !== null && _r4 !== void 0 && _r4.ok) return r;\n      r = await slack(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id,\n          column_id,\n          file_ids: ids\n        }]\n      }, `[LISTS][ATTACH-B][${label}]`);\n      if ((_r5 = r) !== null && _r5 !== void 0 && _r5.ok) return r;\n      r = await slack(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id,\n          column_id,\n          files: ids.map(id => ({\n            id\n          }))\n        }]\n      }, `[LISTS][ATTACH-C][${label}]`);\n      if ((_r6 = r) !== null && _r6 !== void 0 && _r6.ok) return r;\n      r = await slack(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id,\n          column_id,\n          reference: ids.map(id => ({\n            file: {\n              file_id: id\n            }\n          }))\n        }]\n      }, `[LISTS][ATTACH-D][${label}]`);\n      return r;\n    } // modern upload flow: getUploadURLExternal -> POST bytes -> completeUploadExternal\n\n\n    async function uploadViaExternal(url, filename) {\n      try {\n        const resp = await fetch(url);\n        if (!resp.ok) return {\n          ok: false,\n          error: `fetch_${resp.status}`\n        };\n        const buf = Buffer.from(await resp.arrayBuffer());\n        const byteLen = buf.length;\n        const reserve = await slack(\"files.getUploadURLExternal\", {\n          filename: filename || \"image.jpg\",\n          length: byteLen\n        }, \"[FILES.GETUPLOAD]\");\n        if (!(reserve !== null && reserve !== void 0 && reserve.ok)) return {\n          ok: false,\n          error: (reserve === null || reserve === void 0 ? void 0 : reserve.error) || \"get_upload_failed\"\n        };\n        const {\n          upload_url,\n          file_id\n        } = reserve;\n        const up = await fetch(upload_url, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/octet-stream\"\n          },\n          body: buf\n        });\n        log(\"[FILES.UPLOAD.POST]\", {\n          ok: up.ok,\n          status: up.status\n        });\n        if (!up.ok) return {\n          ok: false,\n          error: `upload_post_${up.status}`\n        };\n        const complete = await slack(\"files.completeUploadExternal\", {\n          files: [{\n            id: file_id,\n            title: filename || \"image.jpg\"\n          }]\n        }, \"[FILES.COMPLETE]\");\n        if (!(complete !== null && complete !== void 0 && complete.ok)) return {\n          ok: false,\n          error: (complete === null || complete === void 0 ? void 0 : complete.error) || \"complete_failed\"\n        };\n        const created = Array.isArray(complete.files) ? complete.files[0] : null;\n        return {\n          ok: true,\n          file: {\n            id: (created === null || created === void 0 ? void 0 : created.id) || file_id\n          }\n        };\n      } catch (e) {\n        log(\"[FILES.UPLOAD.EXC]\", {\n          message: e === null || e === void 0 ? void 0 : e.message\n        });\n        return {\n          ok: false,\n          error: \"upload_exception\"\n        };\n      }\n    } // ----- 1) create the list item with Title (ARRAY SHAPE) -----\n\n\n    const safeTitle = plain(title) || \"New Item\";\n    const titleField = {\n      column_id: CFG.title_col,\n      rich_text: toRich(safeTitle)\n    }; // Optionally include a link in title rich_text (kept simple)\n    // (Slack rich_text links are allowed; keep as plain text if this causes trouble)\n\n    if (linkUrl) {\n      titleField.rich_text = [{\n        type: \"rich_text\",\n        elements: [{\n          type: \"rich_text_section\",\n          elements: [{\n            type: \"text\",\n            text: safeTitle + \"  \"\n          }, {\n            type: \"link\",\n            url: linkUrl,\n            text: \"(open)\"\n          }]\n        }]\n      }];\n    }\n\n    let created = await slack(\"slackLists.items.create\", {\n      list_id: CFG.list_id,\n      initial_fields: [titleField] // <-- ARRAY, not map\n\n    }, \"[LISTS][CREATE-RICH]\");\n\n    if (!((_created = created) !== null && _created !== void 0 && _created.ok) && ((_created2 = created) === null || _created2 === void 0 ? void 0 : _created2.error) === \"invalid_arguments\") {\n      // fallback to plain text for title\n      created = await slack(\"slackLists.items.create\", {\n        list_id: CFG.list_id,\n        initial_fields: [{\n          column_id: CFG.title_col,\n          text: safeTitle\n        }]\n      }, \"[LISTS][CREATE-TEXT]\");\n    }\n\n    if (!((_created3 = created) !== null && _created3 !== void 0 && _created3.ok)) {\n      var _created4;\n\n      return res.status(200).json({\n        ok: false,\n        error: ((_created4 = created) === null || _created4 === void 0 ? void 0 : _created4.error) || \"create_failed\",\n        debug: dbg\n      });\n    }\n\n    const rowId = (_created$item = created.item) === null || _created$item === void 0 ? void 0 : _created$item.id;\n    log(\"[LISTS][CREATED]\", {\n      rowId\n    }); // ----- 2) PN/SN -----\n\n    const pn0 = first(pn),\n          sn0 = first(sn);\n    const pnSnText = [pn0 ? `PN: ${pn0}` : \"\", sn0 ? `SN: ${sn0}` : \"\"].filter(Boolean).join(\"  \");\n\n    if (pnSnText && CFG.pnsn_col) {\n      const r = await updateOneCellText(CFG.list_id, rowId, CFG.pnsn_col, pnSnText, \"PN/SN\");\n      if (!(r !== null && r !== void 0 && r.ok)) return res.status(200).json({\n        ok: false,\n        error: (r === null || r === void 0 ? void 0 : r.error) || \"update_failed_pnsn\",\n        debug: dbg\n      });\n    } // ----- 3) LocalSN -----\n\n\n    if (CFG.localsn_col && plain(localSN)) {\n      const r = await updateOneCellText(CFG.list_id, rowId, CFG.localsn_col, localSN, \"LOCAL_SN\");\n      if (!(r !== null && r !== void 0 && r.ok)) return res.status(200).json({\n        ok: false,\n        error: (r === null || r === void 0 ? void 0 : r.error) || \"update_failed_localsn\",\n        debug: dbg\n      });\n    } // ----- 4) Description -----\n\n\n    if (CFG.desc_col && plain(description)) {\n      const r = await updateOneCellText(CFG.list_id, rowId, CFG.desc_col, description, \"DESCRIPTION\");\n      if (!(r !== null && r !== void 0 && r.ok)) return res.status(200).json({\n        ok: false,\n        error: (r === null || r === void 0 ? void 0 : r.error) || \"update_failed_description\",\n        debug: dbg\n      });\n    } // ----- 5) Work Order -----\n\n\n    if (CFG.wo_col && plain(workOrder)) {\n      const r = await updateOneCellText(CFG.list_id, rowId, CFG.wo_col, workOrder, \"WORK_ORDER\");\n      if (!(r !== null && r !== void 0 && r.ok)) return res.status(200).json({\n        ok: false,\n        error: (r === null || r === void 0 ? void 0 : r.error) || \"update_failed_workorder\",\n        debug: dbg\n      });\n    } // ----- 6) Tracking -----\n\n\n    if (CFG.tracking_col && plain(tracking)) {\n      const r = await updateOneCellText(CFG.list_id, rowId, CFG.tracking_col, tracking, \"TRACKING\");\n      if (!(r !== null && r !== void 0 && r.ok)) return res.status(200).json({\n        ok: false,\n        error: (r === null || r === void 0 ? void 0 : r.error) || \"update_failed_tracking\",\n        debug: dbg\n      });\n    } // ----- 7) Photos (upload bytes → attach) -----\n\n\n    if (CFG.photos_col && Array.isArray(photoUrls) && photoUrls.length) {\n      const ids = [];\n\n      for (let i = 0; i < Math.min(photoUrls.length, 10); i++) {\n        var _url$split$pop, _up$file, _up$file2;\n\n        const url = plain(photoUrls[i]);\n        if (!/^https?:\\/\\//i.test(url)) continue;\n        const filename = ((_url$split$pop = url.split(\"/\").pop()) === null || _url$split$pop === void 0 ? void 0 : _url$split$pop.split(\"?\")[0]) || `photo_${i + 1}.jpg`;\n        const up = await uploadViaExternal(url, filename);\n        dbg.photos.push({\n          i,\n          url,\n          upload_ok: !!(up !== null && up !== void 0 && up.ok),\n          upload_err: up === null || up === void 0 ? void 0 : up.error,\n          file_id: up === null || up === void 0 ? void 0 : (_up$file = up.file) === null || _up$file === void 0 ? void 0 : _up$file.id\n        });\n        if (up !== null && up !== void 0 && up.ok && up !== null && up !== void 0 && (_up$file2 = up.file) !== null && _up$file2 !== void 0 && _up$file2.id) ids.push(up.file.id);\n      }\n\n      if (ids.length) {\n        const a = await attachFilesToCell(CFG.list_id, rowId, CFG.photos_col, ids, \"PHOTOS\");\n\n        if (!(a !== null && a !== void 0 && a.ok)) {\n          log(\"[PHOTOS][FAILED-ATTACH]\", {\n            error: a === null || a === void 0 ? void 0 : a.error,\n            ids\n          }); // As a last resort, dump URLs into description\n\n          if (CFG.desc_col) {\n            const joined = `Photos:\\n${photoUrls.map(plain).filter(Boolean).join(\"\\n\")}`;\n            await updateOneCellText(CFG.list_id, rowId, CFG.desc_col, [description, joined].filter(Boolean).join(\"\\n\\n\"), \"PHOTOS->DESC-FALLBACK\");\n          }\n\n          return res.status(200).json({\n            ok: false,\n            error: (a === null || a === void 0 ? void 0 : a.error) || \"update_failed_photos\",\n            debug: dbg\n          });\n        }\n      } else {\n        log(\"[PHOTOS][NO-IDS]\", {\n          reason: \"upload_failed_or_empty\"\n        });\n      }\n    }\n\n    return res.status(200).json({\n      ok: true,\n      list_id: CFG.list_id,\n      item_id: rowId,\n      used_cols: {\n        title_col: CFG.title_col,\n        pnsn_col: CFG.pnsn_col || null,\n        description_col: CFG.desc_col || null,\n        workorder_col: CFG.wo_col || null,\n        localsn_col: CFG.localsn_col || null,\n        tracking_col: CFG.tracking_col || null,\n        photos_col: CFG.photos_col || null\n      },\n      debug: dbg\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err),\n      debug: dbg\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","dbg","steps","photos","log","step","detail","entry","t","Date","toISOString","push","console","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn","sn","workOrder","localSN","description","tracking","linkUrl","photoUrls","debug","body","clean","s","trim","undefined","get","k","anyOf","keys","map","find","Boolean","CFG","tasks","list_id","title_col","desc_col","pnsn_col","wo_col","localsn_col","tracking_col","photos_col","link_col","shipping","receiving","fix","toUpperCase","slack","payload","tag","r","fetch","headers","Authorization","JSON","stringify","j","catch","plain","v","toString","first","x","Array","isArray","toRich","text","type","elements","updateOneCellText","row_id","column_id","value","label","val","skipped","cells","rich_text","attachFilesToCell","ids","length","attachment","file_ids","files","id","reference","file","file_id","uploadViaExternal","url","filename","resp","buf","Buffer","from","arrayBuffer","byteLen","reserve","upload_url","up","complete","created","e","message","safeTitle","titleField","initial_fields","rowId","item","pn0","sn0","pnSnText","filter","join","i","Math","min","test","split","pop","upload_ok","upload_err","a","joined","reason","item_id","used_cols","description_col","workorder_col","err","String"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,QAAMC,GAAG,GAAG;AAAEC,IAAAA,KAAK,EAAE,EAAT;AAAaC,IAAAA,MAAM,EAAE;AAArB,GAAZ;;AACA,QAAMC,GAAG,GAAG,CAACC,IAAD,EAAOC,MAAM,GAAG,EAAhB,KAAuB;AACjC,UAAMC,KAAK;AAAKC,MAAAA,CAAC,EAAE,IAAIC,IAAJ,GAAWC,WAAX,EAAR;AAAkCL,MAAAA;AAAlC,OAA2CC,MAA3C,CAAX;;AACAL,IAAAA,GAAG,CAACC,KAAJ,CAAUS,IAAV,CAAeJ,KAAf;AACAK,IAAAA,OAAO,CAACR,GAAR,CAAY,cAAZ,EAA4BC,IAA5B,EAAkCC,MAAlC;AACD,GAJD;;AAMA,MAAI;AAAA;;AACF,QAAIP,GAAG,CAACc,MAAJ,KAAe,MAAnB,EAA2B;AACzB,aAAOb,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAArB,CAAP;AACD;;AAED,UAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;AACA,QAAI,CAACH,KAAL,EAAY,OAAOlB,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE;AAApB,KAArB,CAAP,CANV,CAQF;;AACA,UAAM;AACJK,MAAAA,OADI;AACKC,MAAAA,KADL;AACYC,MAAAA,EADZ;AACgBC,MAAAA,EADhB;AAEJC,MAAAA,SAFI;AAEOC,MAAAA,OAFP;AAEgBC,MAAAA,WAFhB;AAE6BC,MAAAA,QAF7B;AAGJC,MAAAA,OAHI;AAIJC,MAAAA,SAAS,GAAG,EAJR;AAKJC,MAAAA,KAAK,GAAG,IALJ,CAKU;;AALV,QAMFjC,GAAG,CAACkC,IAAJ,IAAY,EANhB,CATE,CAiBF;;AACA,UAAMC,KAAK,GAAIC,CAAD,IAAO,CAACA,CAAD,aAACA,CAAD,cAACA,CAAD,GAAM,EAAN,EAAUC,IAAV,MAAoBC,SAAzC;;AACA,UAAMC,GAAG,GAAIC,CAAD,IAAOL,KAAK,CAACf,OAAO,CAACC,GAAR,CAAYmB,CAAZ,CAAD,CAAxB;;AACA,UAAMC,KAAK,GAAG,CAAC,GAAGC,IAAJ,KAAaA,IAAI,CAACC,GAAL,CAASJ,GAAT,EAAcK,IAAd,CAAmBC,OAAnB,CAA3B,CApBE,CAsBF;;;AACA,UAAMC,GAAG,GAAI;AACXC,MAAAA,KAAK,EAAE;AACLC,QAAAA,OAAO,EAAIT,GAAG,CAAC,qBAAD,CADT;AAELU,QAAAA,SAAS,EAAEV,GAAG,CAAC,4BAAD,CAFT;AAGLW,QAAAA,QAAQ,EAAGT,KAAK,CAAC,kCAAD,EAAqC,2BAArC,CAHX;AAILU,QAAAA,QAAQ,EAAGZ,GAAG,CAAC,2BAAD,CAJT;AAKLa,QAAAA,MAAM,EAAKX,KAAK,CAAC,gCAAD,EAAkC,yBAAlC,CALX;AAMLY,QAAAA,WAAW,EAAEd,GAAG,CAAC,8BAAD,CANX;AAOLe,QAAAA,YAAY,EAACf,GAAG,CAAC,+BAAD,CAPX;AAQLgB,QAAAA,UAAU,EAAGhB,GAAG,CAAC,6BAAD,CARX;AASLiB,QAAAA,QAAQ,EAAKjB,GAAG,CAAC,2BAAD;AATX,OADI;AAYXkB,MAAAA,QAAQ,EAAE;AACRT,QAAAA,OAAO,EAAIT,GAAG,CAAC,wBAAD,CADN;AAERU,QAAAA,SAAS,EAAEV,GAAG,CAAC,+BAAD,CAFN;AAGRW,QAAAA,QAAQ,EAAGT,KAAK,CAAC,qCAAD,EAAwC,8BAAxC,CAHR;AAIRU,QAAAA,QAAQ,EAAGZ,GAAG,CAAC,8BAAD,CAJN;AAKRa,QAAAA,MAAM,EAAKX,KAAK,CAAC,mCAAD,EAAqC,4BAArC,CALR;AAMRY,QAAAA,WAAW,EAAEd,GAAG,CAAC,iCAAD,CANR;AAORe,QAAAA,YAAY,EAACf,GAAG,CAAC,kCAAD,CAPR;AAQRgB,QAAAA,UAAU,EAAGhB,GAAG,CAAC,gCAAD,CARR;AASRiB,QAAAA,QAAQ,EAAKjB,GAAG,CAAC,8BAAD;AATR,OAZC;AAuBXmB,MAAAA,SAAS,EAAE;AACTV,QAAAA,OAAO,EAAIT,GAAG,CAAC,yBAAD,CADL;AAETU,QAAAA,SAAS,EAAEV,GAAG,CAAC,gCAAD,CAFL;AAGTW,QAAAA,QAAQ,EAAGT,KAAK,CAAC,sCAAD,EAAyC,+BAAzC,CAHP;AAITU,QAAAA,QAAQ,EAAGZ,GAAG,CAAC,+BAAD,CAJL;AAKTa,QAAAA,MAAM,EAAKX,KAAK,CAAC,oCAAD,EAAsC,6BAAtC,CALP;AAMTY,QAAAA,WAAW,EAAEd,GAAG,CAAC,kCAAD,CANP;AAOTe,QAAAA,YAAY,EAACf,GAAG,CAAC,mCAAD,CAPP;AAQTgB,QAAAA,UAAU,EAAGhB,GAAG,CAAC,iCAAD,CARP;AASTiB,QAAAA,QAAQ,EAAKjB,GAAG,CAAC,+BAAD;AATP;AAvBA,KAAD,CAkCThB,OAAO,IAAI,EAlCF,CAAZ;AAoCA,QAAI,EAACuB,GAAD,aAACA,GAAD,eAACA,GAAG,CAAEE,OAAN,CAAJ,EAAmB,OAAO/C,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAG,mBAAkBK,OAAQ;AAA/C,KAArB,CAAP;;AACnB,QAAI,CAACuB,GAAG,CAACG,SAAT,EAAoB;AAClB,aAAOhD,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,QAAAA,EAAE,EAAE,KADsB;AAE1BC,QAAAA,KAAK,EAAE,6BAFmB;AAG1ByC,QAAAA,GAAG,EAAG,kBAAiB,CAACpC,OAAO,IAAI,EAAZ,EAAgBqC,WAAhB,EAA8B;AAH3B,OAArB,CAAP;AAKD,KAlEC,CAoEF;;;AACA,mBAAeC,KAAf,CAAqB/C,MAArB,EAA6BgD,OAA7B,EAAsCC,GAAtC,EAA2C;AACzC,YAAMC,CAAC,GAAG,MAAMC,KAAK,CAAE,yBAAwBnD,MAAO,EAAjC,EAAoC;AACvDA,QAAAA,MAAM,EAAE,MAD+C;AAEvDoD,QAAAA,OAAO,EAAE;AAAEC,UAAAA,aAAa,EAAG,UAAShD,KAAM,EAAjC;AAAoC,0BAAgB;AAApD,SAF8C;AAGvDe,QAAAA,IAAI,EAAEkC,IAAI,CAACC,SAAL,CAAeP,OAAf;AAHiD,OAApC,CAArB;AAKA,YAAMQ,CAAC,GAAG,MAAMN,CAAC,CAAChD,IAAF,GAASuD,KAAT,CAAe,OAAO,EAAP,CAAf,CAAhB;AACA,UAAItC,KAAJ,EAAW5B,GAAG,CAAC0D,GAAG,IAAIjD,MAAR,EAAgB;AAAEG,QAAAA,EAAE,EAAEqD,CAAF,aAAEA,CAAF,uBAAEA,CAAC,CAAErD,EAAT;AAAaC,QAAAA,KAAK,EAAEoD,CAAF,aAAEA,CAAF,uBAAEA,CAAC,CAAEpD,KAAvB;AAA8BH,QAAAA,MAAM,EAAEiD,CAAC,CAACjD;AAAxC,OAAhB,CAAH;AACX,aAAOuD,CAAP;AACD;;AACD,UAAME,KAAK,GAAIC,CAAD,IAAO,CAACA,CAAD,aAACA,CAAD,cAACA,CAAD,GAAM,EAAN,EAAUC,QAAV,GAAqBrC,IAArB,EAArB;;AACA,UAAMsC,KAAK,GAAIC,CAAD,IAAQC,KAAK,CAACC,OAAN,CAAcF,CAAd,IAAmBA,CAAC,CAAChC,IAAF,CAAOC,OAAP,KAAmB,EAAtC,GAA2C2B,KAAK,CAACI,CAAD,CAAtE;;AACA,UAAMG,MAAM,GAAIC,IAAD,IAAU,CAAC;AACxBC,MAAAA,IAAI,EAAE,WADkB;AAExBC,MAAAA,QAAQ,EAAE,CAAC;AAAED,QAAAA,IAAI,EAAE,mBAAR;AAA6BC,QAAAA,QAAQ,EAAE,CAAC;AAAED,UAAAA,IAAI,EAAE,MAAR;AAAgBD,UAAAA,IAAI,EAAER,KAAK,CAACQ,IAAD;AAA3B,SAAD;AAAvC,OAAD;AAFc,KAAD,CAAzB;;AAKA,mBAAeG,iBAAf,CAAiCnC,OAAjC,EAA0CoC,MAA1C,EAAkDC,SAAlD,EAA6DC,KAA7D,EAAoEC,KAApE,EAA2E;AAAA;;AACzE,YAAMC,GAAG,GAAGhB,KAAK,CAACc,KAAD,CAAjB;AACA,UAAI,CAACE,GAAD,IAAQ,CAACH,SAAb,EAAwB,OAAO;AAAEpE,QAAAA,EAAE,EAAE,IAAN;AAAYwE,QAAAA,OAAO,EAAE;AAArB,OAAP,CAFiD,CAGzE;;AACA,UAAIzB,CAAC,GAAG,MAAMH,KAAK,CAAC,yBAAD,EAA4B;AAC7Cb,QAAAA,OAD6C;AAE7C0C,QAAAA,KAAK,EAAE,CAAC;AAAEN,UAAAA,MAAF;AAAUC,UAAAA,SAAV;AAAqBM,UAAAA,SAAS,EAAEZ,MAAM,CAACS,GAAD;AAAtC,SAAD;AAFsC,OAA5B,EAGf,qBAAoBD,KAAM,GAHX,CAAnB;AAIA,gBAAIvB,CAAJ,+BAAI,GAAG/C,EAAP,EAAW,OAAO+C,CAAP;;AACX,UAAI,QAAAA,CAAC,UAAD,kCAAG9C,KAAH,MAAa,mBAAb,IAAoC,QAAA8C,CAAC,UAAD,kCAAG9C,KAAH,MAAa,oBAArD,EAA2E;AACzE8C,QAAAA,CAAC,GAAG,MAAMH,KAAK,CAAC,yBAAD,EAA4B;AACzCb,UAAAA,OADyC;AAEzC0C,UAAAA,KAAK,EAAE,CAAC;AAAEN,YAAAA,MAAF;AAAUC,YAAAA,SAAV;AAAqBL,YAAAA,IAAI,EAAEQ;AAA3B,WAAD;AAFkC,SAA5B,EAGX,qBAAoBD,KAAM,GAHf,CAAf;AAID;;AACD,aAAOvB,CAAP;AACD;;AAED,mBAAe4B,iBAAf,CAAiC5C,OAAjC,EAA0CoC,MAA1C,EAAkDC,SAAlD,EAA6DQ,GAA7D,EAAkEN,KAAlE,EAAyE;AAAA;;AACvE,UAAI,CAACM,GAAG,CAACC,MAAL,IAAe,CAACT,SAApB,EAA+B,OAAO;AAAEpE,QAAAA,EAAE,EAAE,IAAN;AAAYwE,QAAAA,OAAO,EAAE;AAArB,OAAP,CADwC,CAEvE;;AACA,UAAIzB,CAAC,GAAG,MAAMH,KAAK,CAAC,yBAAD,EAA4B;AAC7Cb,QAAAA,OAD6C;AAE7C0C,QAAAA,KAAK,EAAE,CAAC;AAAEN,UAAAA,MAAF;AAAUC,UAAAA,SAAV;AAAqBU,UAAAA,UAAU,EAAEF;AAAjC,SAAD;AAFsC,OAA5B,EAGf,qBAAoBN,KAAM,GAHX,CAAnB;AAIA,iBAAIvB,CAAJ,gCAAI,IAAG/C,EAAP,EAAW,OAAO+C,CAAP;AAEXA,MAAAA,CAAC,GAAG,MAAMH,KAAK,CAAC,yBAAD,EAA4B;AACzCb,QAAAA,OADyC;AAEzC0C,QAAAA,KAAK,EAAE,CAAC;AAAEN,UAAAA,MAAF;AAAUC,UAAAA,SAAV;AAAqBW,UAAAA,QAAQ,EAAEH;AAA/B,SAAD;AAFkC,OAA5B,EAGX,qBAAoBN,KAAM,GAHf,CAAf;AAIA,iBAAIvB,CAAJ,gCAAI,IAAG/C,EAAP,EAAW,OAAO+C,CAAP;AAEXA,MAAAA,CAAC,GAAG,MAAMH,KAAK,CAAC,yBAAD,EAA4B;AACzCb,QAAAA,OADyC;AAEzC0C,QAAAA,KAAK,EAAE,CAAC;AAAEN,UAAAA,MAAF;AAAUC,UAAAA,SAAV;AAAqBY,UAAAA,KAAK,EAAEJ,GAAG,CAAClD,GAAJ,CAASuD,EAAD,KAAS;AAAEA,YAAAA;AAAF,WAAT,CAAR;AAA5B,SAAD;AAFkC,OAA5B,EAGX,qBAAoBX,KAAM,GAHf,CAAf;AAIA,iBAAIvB,CAAJ,gCAAI,IAAG/C,EAAP,EAAW,OAAO+C,CAAP;AAEXA,MAAAA,CAAC,GAAG,MAAMH,KAAK,CAAC,yBAAD,EAA4B;AACzCb,QAAAA,OADyC;AAEzC0C,QAAAA,KAAK,EAAE,CAAC;AAAEN,UAAAA,MAAF;AAAUC,UAAAA,SAAV;AAAqBc,UAAAA,SAAS,EAAEN,GAAG,CAAClD,GAAJ,CAASuD,EAAD,KAAS;AAAEE,YAAAA,IAAI,EAAE;AAAEC,cAAAA,OAAO,EAAEH;AAAX;AAAR,WAAT,CAAR;AAAhC,SAAD;AAFkC,OAA5B,EAGX,qBAAoBX,KAAM,GAHf,CAAf;AAIA,aAAOvB,CAAP;AACD,KAlIC,CAoIF;;;AACA,mBAAesC,iBAAf,CAAiCC,GAAjC,EAAsCC,QAAtC,EAAgD;AAC9C,UAAI;AACF,cAAMC,IAAI,GAAG,MAAMxC,KAAK,CAACsC,GAAD,CAAxB;AACA,YAAI,CAACE,IAAI,CAACxF,EAAV,EAAc,OAAO;AAAEA,UAAAA,EAAE,EAAE,KAAN;AAAaC,UAAAA,KAAK,EAAG,SAAQuF,IAAI,CAAC1F,MAAO;AAAzC,SAAP;AACd,cAAM2F,GAAG,GAAGC,MAAM,CAACC,IAAP,CAAY,MAAMH,IAAI,CAACI,WAAL,EAAlB,CAAZ;AACA,cAAMC,OAAO,GAAGJ,GAAG,CAACZ,MAApB;AAEA,cAAMiB,OAAO,GAAG,MAAMlD,KAAK,CAAC,4BAAD,EACzB;AAAE2C,UAAAA,QAAQ,EAAEA,QAAQ,IAAI,WAAxB;AAAqCV,UAAAA,MAAM,EAAEgB;AAA7C,SADyB,EAEzB,mBAFyB,CAA3B;AAGA,YAAI,EAACC,OAAD,aAACA,OAAD,eAACA,OAAO,CAAE9F,EAAV,CAAJ,EAAkB,OAAO;AAAEA,UAAAA,EAAE,EAAE,KAAN;AAAaC,UAAAA,KAAK,EAAE,CAAA6F,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAE7F,KAAT,KAAkB;AAAtC,SAAP;AAElB,cAAM;AAAE8F,UAAAA,UAAF;AAAcX,UAAAA;AAAd,YAA0BU,OAAhC;AAEA,cAAME,EAAE,GAAG,MAAMhD,KAAK,CAAC+C,UAAD,EAAa;AACjClG,UAAAA,MAAM,EAAE,MADyB;AAEjCoD,UAAAA,OAAO,EAAE;AAAE,4BAAgB;AAAlB,WAFwB;AAGjChC,UAAAA,IAAI,EAAEwE;AAH2B,SAAb,CAAtB;AAKArG,QAAAA,GAAG,CAAC,qBAAD,EAAwB;AAAEY,UAAAA,EAAE,EAAEgG,EAAE,CAAChG,EAAT;AAAaF,UAAAA,MAAM,EAAEkG,EAAE,CAAClG;AAAxB,SAAxB,CAAH;AACA,YAAI,CAACkG,EAAE,CAAChG,EAAR,EAAY,OAAO;AAAEA,UAAAA,EAAE,EAAE,KAAN;AAAaC,UAAAA,KAAK,EAAG,eAAc+F,EAAE,CAAClG,MAAO;AAA7C,SAAP;AAEZ,cAAMmG,QAAQ,GAAG,MAAMrD,KAAK,CAAC,8BAAD,EAC1B;AAAEoC,UAAAA,KAAK,EAAE,CAAC;AAAEC,YAAAA,EAAE,EAAEG,OAAN;AAAe7E,YAAAA,KAAK,EAAEgF,QAAQ,IAAI;AAAlC,WAAD;AAAT,SAD0B,EAE1B,kBAF0B,CAA5B;AAGA,YAAI,EAACU,QAAD,aAACA,QAAD,eAACA,QAAQ,CAAEjG,EAAX,CAAJ,EAAmB,OAAO;AAAEA,UAAAA,EAAE,EAAE,KAAN;AAAaC,UAAAA,KAAK,EAAE,CAAAgG,QAAQ,SAAR,IAAAA,QAAQ,WAAR,YAAAA,QAAQ,CAAEhG,KAAV,KAAmB;AAAvC,SAAP;AAEnB,cAAMiG,OAAO,GAAGtC,KAAK,CAACC,OAAN,CAAcoC,QAAQ,CAACjB,KAAvB,IAAgCiB,QAAQ,CAACjB,KAAT,CAAe,CAAf,CAAhC,GAAoD,IAApE;AACA,eAAO;AAAEhF,UAAAA,EAAE,EAAE,IAAN;AAAYmF,UAAAA,IAAI,EAAE;AAAEF,YAAAA,EAAE,EAAE,CAAAiB,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAEjB,EAAT,KAAeG;AAArB;AAAlB,SAAP;AACD,OA5BD,CA4BE,OAAOe,CAAP,EAAU;AACV/G,QAAAA,GAAG,CAAC,oBAAD,EAAuB;AAAEgH,UAAAA,OAAO,EAAED,CAAF,aAAEA,CAAF,uBAAEA,CAAC,CAAEC;AAAd,SAAvB,CAAH;AACA,eAAO;AAAEpG,UAAAA,EAAE,EAAE,KAAN;AAAaC,UAAAA,KAAK,EAAE;AAApB,SAAP;AACD;AACF,KAtKC,CAwKF;;;AACA,UAAMoG,SAAS,GAAG9C,KAAK,CAAChD,KAAD,CAAL,IAAgB,UAAlC;AACA,UAAM+F,UAAU,GAAG;AAAElC,MAAAA,SAAS,EAAEvC,GAAG,CAACG,SAAjB;AAA4B0C,MAAAA,SAAS,EAAEZ,MAAM,CAACuC,SAAD;AAA7C,KAAnB,CA1KE,CA4KF;AACA;;AACA,QAAIvF,OAAJ,EAAa;AACXwF,MAAAA,UAAU,CAAC5B,SAAX,GAAuB,CAAC;AACtBV,QAAAA,IAAI,EAAE,WADgB;AAEtBC,QAAAA,QAAQ,EAAE,CAAC;AACTD,UAAAA,IAAI,EAAE,mBADG;AAETC,UAAAA,QAAQ,EAAE,CACR;AAAED,YAAAA,IAAI,EAAE,MAAR;AAAgBD,YAAAA,IAAI,EAAEsC,SAAS,GAAG;AAAlC,WADQ,EAER;AAAErC,YAAAA,IAAI,EAAE,MAAR;AAAgBsB,YAAAA,GAAG,EAAExE,OAArB;AAA8BiD,YAAAA,IAAI,EAAE;AAApC,WAFQ;AAFD,SAAD;AAFY,OAAD,CAAvB;AAUD;;AAED,QAAImC,OAAO,GAAG,MAAMtD,KAAK,CAAC,yBAAD,EAA4B;AACnDb,MAAAA,OAAO,EAAEF,GAAG,CAACE,OADsC;AAEnDwE,MAAAA,cAAc,EAAE,CAACD,UAAD,CAFmC,CAErB;;AAFqB,KAA5B,EAGtB,sBAHsB,CAAzB;;AAKA,QAAI,cAACJ,OAAD,qCAAC,SAASlG,EAAV,KAAgB,cAAAkG,OAAO,UAAP,8CAASjG,KAAT,MAAmB,mBAAvC,EAA4D;AAC1D;AACAiG,MAAAA,OAAO,GAAG,MAAMtD,KAAK,CAAC,yBAAD,EAA4B;AAC/Cb,QAAAA,OAAO,EAAEF,GAAG,CAACE,OADkC;AAE/CwE,QAAAA,cAAc,EAAE,CAAC;AAAEnC,UAAAA,SAAS,EAAEvC,GAAG,CAACG,SAAjB;AAA4B+B,UAAAA,IAAI,EAAEsC;AAAlC,SAAD;AAF+B,OAA5B,EAGlB,sBAHkB,CAArB;AAID;;AAED,QAAI,eAACH,OAAD,sCAAC,UAASlG,EAAV,CAAJ,EAAkB;AAAA;;AAChB,aAAOhB,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,QAAAA,EAAE,EAAE,KADsB;AAE1BC,QAAAA,KAAK,EAAE,cAAAiG,OAAO,UAAP,8CAASjG,KAAT,KAAkB,eAFC;AAG1Be,QAAAA,KAAK,EAAE/B;AAHmB,OAArB,CAAP;AAKD;;AAED,UAAMuH,KAAK,oBAAGN,OAAO,CAACO,IAAX,kDAAG,cAAcxB,EAA5B;AACA7F,IAAAA,GAAG,CAAC,kBAAD,EAAqB;AAAEoH,MAAAA;AAAF,KAArB,CAAH,CAjNE,CAmNF;;AACA,UAAME,GAAG,GAAGhD,KAAK,CAAClD,EAAD,CAAjB;AAAA,UAAuBmG,GAAG,GAAGjD,KAAK,CAACjD,EAAD,CAAlC;AACA,UAAMmG,QAAQ,GAAG,CAACF,GAAG,GAAI,OAAMA,GAAI,EAAd,GAAkB,EAAtB,EAA0BC,GAAG,GAAI,OAAMA,GAAI,EAAd,GAAkB,EAA/C,EAAmDE,MAAnD,CAA0DjF,OAA1D,EAAmEkF,IAAnE,CAAwE,IAAxE,CAAjB;;AACA,QAAIF,QAAQ,IAAI/E,GAAG,CAACK,QAApB,EAA8B;AAC5B,YAAMa,CAAC,GAAG,MAAMmB,iBAAiB,CAACrC,GAAG,CAACE,OAAL,EAAcyE,KAAd,EAAqB3E,GAAG,CAACK,QAAzB,EAAmC0E,QAAnC,EAA6C,OAA7C,CAAjC;AACA,UAAI,EAAC7D,CAAD,aAACA,CAAD,eAACA,CAAC,CAAE/C,EAAJ,CAAJ,EAAY,OAAOhB,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE,CAAA8C,CAAC,SAAD,IAAAA,CAAC,WAAD,YAAAA,CAAC,CAAE9C,KAAH,KAAY,oBAAhC;AAAsDe,QAAAA,KAAK,EAAE/B;AAA7D,OAArB,CAAP;AACb,KAzNC,CA2NF;;;AACA,QAAI4C,GAAG,CAACO,WAAJ,IAAmBmB,KAAK,CAAC5C,OAAD,CAA5B,EAAuC;AACrC,YAAMoC,CAAC,GAAG,MAAMmB,iBAAiB,CAACrC,GAAG,CAACE,OAAL,EAAcyE,KAAd,EAAqB3E,GAAG,CAACO,WAAzB,EAAsCzB,OAAtC,EAA+C,UAA/C,CAAjC;AACA,UAAI,EAACoC,CAAD,aAACA,CAAD,eAACA,CAAC,CAAE/C,EAAJ,CAAJ,EAAY,OAAOhB,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE,CAAA8C,CAAC,SAAD,IAAAA,CAAC,WAAD,YAAAA,CAAC,CAAE9C,KAAH,KAAY,uBAAhC;AAAyDe,QAAAA,KAAK,EAAE/B;AAAhE,OAArB,CAAP;AACb,KA/NC,CAiOF;;;AACA,QAAI4C,GAAG,CAACI,QAAJ,IAAgBsB,KAAK,CAAC3C,WAAD,CAAzB,EAAwC;AACtC,YAAMmC,CAAC,GAAG,MAAMmB,iBAAiB,CAACrC,GAAG,CAACE,OAAL,EAAcyE,KAAd,EAAqB3E,GAAG,CAACI,QAAzB,EAAmCrB,WAAnC,EAAgD,aAAhD,CAAjC;AACA,UAAI,EAACmC,CAAD,aAACA,CAAD,eAACA,CAAC,CAAE/C,EAAJ,CAAJ,EAAY,OAAOhB,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE,CAAA8C,CAAC,SAAD,IAAAA,CAAC,WAAD,YAAAA,CAAC,CAAE9C,KAAH,KAAY,2BAAhC;AAA6De,QAAAA,KAAK,EAAE/B;AAApE,OAArB,CAAP;AACb,KArOC,CAuOF;;;AACA,QAAI4C,GAAG,CAACM,MAAJ,IAAcoB,KAAK,CAAC7C,SAAD,CAAvB,EAAoC;AAClC,YAAMqC,CAAC,GAAG,MAAMmB,iBAAiB,CAACrC,GAAG,CAACE,OAAL,EAAcyE,KAAd,EAAqB3E,GAAG,CAACM,MAAzB,EAAiCzB,SAAjC,EAA4C,YAA5C,CAAjC;AACA,UAAI,EAACqC,CAAD,aAACA,CAAD,eAACA,CAAC,CAAE/C,EAAJ,CAAJ,EAAY,OAAOhB,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE,CAAA8C,CAAC,SAAD,IAAAA,CAAC,WAAD,YAAAA,CAAC,CAAE9C,KAAH,KAAY,yBAAhC;AAA2De,QAAAA,KAAK,EAAE/B;AAAlE,OAArB,CAAP;AACb,KA3OC,CA6OF;;;AACA,QAAI4C,GAAG,CAACQ,YAAJ,IAAoBkB,KAAK,CAAC1C,QAAD,CAA7B,EAAyC;AACvC,YAAMkC,CAAC,GAAG,MAAMmB,iBAAiB,CAACrC,GAAG,CAACE,OAAL,EAAcyE,KAAd,EAAqB3E,GAAG,CAACQ,YAAzB,EAAuCxB,QAAvC,EAAiD,UAAjD,CAAjC;AACA,UAAI,EAACkC,CAAD,aAACA,CAAD,eAACA,CAAC,CAAE/C,EAAJ,CAAJ,EAAY,OAAOhB,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE,CAAA8C,CAAC,SAAD,IAAAA,CAAC,WAAD,YAAAA,CAAC,CAAE9C,KAAH,KAAY,wBAAhC;AAA0De,QAAAA,KAAK,EAAE/B;AAAjE,OAArB,CAAP;AACb,KAjPC,CAmPF;;;AACA,QAAI4C,GAAG,CAACS,UAAJ,IAAkBsB,KAAK,CAACC,OAAN,CAAc9C,SAAd,CAAlB,IAA8CA,SAAS,CAAC8D,MAA5D,EAAoE;AAClE,YAAMD,GAAG,GAAG,EAAZ;;AACA,WAAK,IAAImC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASlG,SAAS,CAAC8D,MAAnB,EAA2B,EAA3B,CAApB,EAAoDkC,CAAC,EAArD,EAAyD;AAAA;;AACvD,cAAMzB,GAAG,GAAG/B,KAAK,CAACxC,SAAS,CAACgG,CAAD,CAAV,CAAjB;AACA,YAAI,CAAC,gBAAgBG,IAAhB,CAAqB5B,GAArB,CAAL,EAAgC;AAChC,cAAMC,QAAQ,GAAG,mBAAAD,GAAG,CAAC6B,KAAJ,CAAU,GAAV,EAAeC,GAAf,oEAAsBD,KAAtB,CAA4B,GAA5B,EAAiC,CAAjC,MAAwC,SAAQJ,CAAC,GAAG,CAAE,MAAvE;AAEA,cAAMf,EAAE,GAAG,MAAMX,iBAAiB,CAACC,GAAD,EAAMC,QAAN,CAAlC;AACAtG,QAAAA,GAAG,CAACE,MAAJ,CAAWQ,IAAX,CAAgB;AAAEoH,UAAAA,CAAF;AAAKzB,UAAAA,GAAL;AAAU+B,UAAAA,SAAS,EAAE,CAAC,EAACrB,EAAD,aAACA,EAAD,eAACA,EAAE,CAAEhG,EAAL,CAAtB;AAA+BsH,UAAAA,UAAU,EAAEtB,EAAF,aAAEA,EAAF,uBAAEA,EAAE,CAAE/F,KAA/C;AAAsDmF,UAAAA,OAAO,EAAEY,EAAF,aAAEA,EAAF,mCAAEA,EAAE,CAAEb,IAAN,6CAAE,SAAUF;AAAzE,SAAhB;AACA,YAAIe,EAAE,SAAF,IAAAA,EAAE,WAAF,IAAAA,EAAE,CAAEhG,EAAJ,IAAUgG,EAAV,aAAUA,EAAV,4BAAUA,EAAE,CAAEb,IAAd,sCAAU,UAAUF,EAAxB,EAA4BL,GAAG,CAACjF,IAAJ,CAASqG,EAAE,CAACb,IAAH,CAAQF,EAAjB;AAC7B;;AAED,UAAIL,GAAG,CAACC,MAAR,EAAgB;AACd,cAAM0C,CAAC,GAAG,MAAM5C,iBAAiB,CAAC9C,GAAG,CAACE,OAAL,EAAcyE,KAAd,EAAqB3E,GAAG,CAACS,UAAzB,EAAqCsC,GAArC,EAA0C,QAA1C,CAAjC;;AACA,YAAI,EAAC2C,CAAD,aAACA,CAAD,eAACA,CAAC,CAAEvH,EAAJ,CAAJ,EAAY;AACVZ,UAAAA,GAAG,CAAC,yBAAD,EAA4B;AAAEa,YAAAA,KAAK,EAAEsH,CAAF,aAAEA,CAAF,uBAAEA,CAAC,CAAEtH,KAAZ;AAAmB2E,YAAAA;AAAnB,WAA5B,CAAH,CADU,CAEV;;AACA,cAAI/C,GAAG,CAACI,QAAR,EAAkB;AAChB,kBAAMuF,MAAM,GAAI,YAAWzG,SAAS,CAACW,GAAV,CAAc6B,KAAd,EAAqBsD,MAArB,CAA4BjF,OAA5B,EAAqCkF,IAArC,CAA0C,IAA1C,CAAgD,EAA3E;AACA,kBAAM5C,iBAAiB,CAACrC,GAAG,CAACE,OAAL,EAAcyE,KAAd,EAAqB3E,GAAG,CAACI,QAAzB,EAAmC,CAACrB,WAAD,EAAc4G,MAAd,EAAsBX,MAAtB,CAA6BjF,OAA7B,EAAsCkF,IAAtC,CAA2C,MAA3C,CAAnC,EAAuF,uBAAvF,CAAvB;AACD;;AACD,iBAAO9H,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,YAAAA,EAAE,EAAE,KAAN;AAAaC,YAAAA,KAAK,EAAE,CAAAsH,CAAC,SAAD,IAAAA,CAAC,WAAD,YAAAA,CAAC,CAAEtH,KAAH,KAAY,sBAAhC;AAAwDe,YAAAA,KAAK,EAAE/B;AAA/D,WAArB,CAAP;AACD;AACF,OAXD,MAWO;AACLG,QAAAA,GAAG,CAAC,kBAAD,EAAqB;AAAEqI,UAAAA,MAAM,EAAE;AAAV,SAArB,CAAH;AACD;AACF;;AAED,WAAOzI,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,MAAAA,EAAE,EAAE,IADsB;AAE1B+B,MAAAA,OAAO,EAAEF,GAAG,CAACE,OAFa;AAG1B2F,MAAAA,OAAO,EAAElB,KAHiB;AAI1BmB,MAAAA,SAAS,EAAE;AACT3F,QAAAA,SAAS,EAAEH,GAAG,CAACG,SADN;AAETE,QAAAA,QAAQ,EAAEL,GAAG,CAACK,QAAJ,IAAgB,IAFjB;AAGT0F,QAAAA,eAAe,EAAE/F,GAAG,CAACI,QAAJ,IAAgB,IAHxB;AAIT4F,QAAAA,aAAa,EAAEhG,GAAG,CAACM,MAAJ,IAAc,IAJpB;AAKTC,QAAAA,WAAW,EAAEP,GAAG,CAACO,WAAJ,IAAmB,IALvB;AAMTC,QAAAA,YAAY,EAAER,GAAG,CAACQ,YAAJ,IAAoB,IANzB;AAOTC,QAAAA,UAAU,EAAET,GAAG,CAACS,UAAJ,IAAkB;AAPrB,OAJe;AAa1BtB,MAAAA,KAAK,EAAE/B;AAbmB,KAArB,CAAP;AAeD,GA/RD,CA+RE,OAAO6I,GAAP,EAAY;AACZlI,IAAAA,OAAO,CAACK,KAAR,CAAc,iCAAd,EAAiD6H,GAAjD;AACA,WAAO9I,GAAG,CAACc,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE,WAApB;AAAiCmG,MAAAA,OAAO,EAAE,CAAA0B,GAAG,SAAH,IAAAA,GAAG,WAAH,YAAAA,GAAG,CAAE1B,OAAL,KAAgB2B,MAAM,CAACD,GAAD,CAAhE;AAAuE9G,MAAAA,KAAK,EAAE/B;AAA9E,KAArB,CAAP;AACD;AACF","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   try {\r\n//     if (req.method !== \"POST\") {\r\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//     }\r\n\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) {\r\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//     }\r\n\r\n//     // payload from client\r\n//     const {\r\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n//       title,               // item title (what shows in the primary column)\r\n//       // keeping minimal per your request: PN/SN only for now\r\n//       pn, sn,\r\n//     } = req.body || {};\r\n\r\n//     // list ids from env\r\n//     const LIST_IDS = {\r\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\r\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n//     };\r\n\r\n//     const list_id = LIST_IDS[listKey];\r\n//     if (!list_id) {\r\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n//     }\r\n\r\n//     // ---- Slack helpers ----\r\n//     async function slackJson(method, payload) {\r\n//       const r = await fetch(`https://slack.com/api/${method}`, {\r\n//         method: \"POST\",\r\n//         headers: {\r\n//           Authorization: `Bearer ${token}`,\r\n//           \"Content-Type\": \"application/json; charset=utf-8\",\r\n//         },\r\n//         body: JSON.stringify(payload),\r\n//       });\r\n//       return r.json();\r\n//     }\r\n\r\n//     const plain = (v) => (v ?? \"\").toString().trim();\r\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     function toRichText(text) {\r\n//       const t = plain(text);\r\n//       return [{\r\n//         type: \"rich_text\",\r\n//         elements: [{\r\n//           type: \"rich_text_section\",\r\n//           elements: [{ type: \"text\", text: t }],\r\n//         }],\r\n//       }];\r\n//     }\r\n\r\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n//     async function resolveTitleColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n//       let fallback = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\r\n//           if (f.column_id && hasText) {\r\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n//             if (!fallback) fallback = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return fallback; // first text-like field if we didn't find a perfect match\r\n//     }\r\n\r\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n//     async function resolvePnSnColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       let candidate = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           if (!f.column_id) continue;\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const text = (f.text || \"\").toLowerCase();\r\n\r\n//           const looksPnSn =\r\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\r\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n//           if (looksPnSn) return f.column_id;\r\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n//             candidate = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return candidate;\r\n//     }\r\n\r\n//     // 1) Resolve columns\r\n//     const titleColId = await resolveTitleColId(list_id);\r\n//     if (!titleColId) {\r\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n//     }\r\n\r\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n//     const safeTitle = plain(title) || \"New Item\";\r\n//     const createBody = {\r\n//       list_id,\r\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n//     };\r\n\r\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 3) (Minimal) update: PN/SN only, per your request\r\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n//     let updated = null;\r\n//     let usedPnSnCol = null;\r\n\r\n//     if (pnSnText) {\r\n//       const pnSnColId = await resolvePnSnColId(list_id);\r\n//       if (pnSnColId) {\r\n//         const cells = [{\r\n//           row_id: created.item.id,\r\n//           column_id: pnSnColId,\r\n//           rich_text: toRichText(pnSnText),\r\n//         }];\r\n\r\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n//         usedPnSnCol = pnSnColId;\r\n//         // If update fails, we still return ok:false so you can see the error\r\n//         if (!updated?.ok) {\r\n//           return res.status(200).json({\r\n//             ok: false,\r\n//             error: updated?.error || \"update_failed\",\r\n//             mode: \"list\",\r\n//             list_id,\r\n//             item_id: created.item.id,\r\n//             used_title_col: titleColId,\r\n//             used_pnsn_col: usedPnSnCol,\r\n//           });\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleColId,\r\n//       used_pnsn_col: usedPnSnCol || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  const dbg = { steps: [], photos: [] };\r\n  const log = (step, detail = {}) => {\r\n    const entry = { t: new Date().toISOString(), step, ...detail };\r\n    dbg.steps.push(entry);\r\n    console.log(\"[SLACK][API]\", step, detail);\r\n  };\r\n\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n\r\n    // ----- request body -----\r\n    const {\r\n      listKey, title, pn, sn,\r\n      workOrder, localSN, description, tracking,\r\n      linkUrl,\r\n      photoUrls = [],\r\n      debug = true, // keep detailed logs for now\r\n    } = req.body || {};\r\n\r\n    // ----- env helpers -----\r\n    const clean = (s) => (s ?? \"\").trim() || undefined;\r\n    const get = (k) => clean(process.env[k]);\r\n    const anyOf = (...keys) => keys.map(get).find(Boolean);\r\n\r\n    // ----- per-list config (trimmed). Use your exact env names -----\r\n    const CFG = ({\r\n      tasks: {\r\n        list_id:   get(\"SLACK_LIST_TASKS_ID\"),\r\n        title_col: get(\"SLACK_LIST_TASKS_TITLE_COL\"),\r\n        desc_col:  anyOf(\"SLACK_LIST_TASKS_DESCRIPTION_COL\", \"SLACK_LIST_TASKS_DESC_COL\"),\r\n        pnsn_col:  get(\"SLACK_LIST_TASKS_PNSN_COL\"),\r\n        wo_col:    anyOf(\"SLACK_LIST_TASKS_WORKORDER_COL\",\"SLACK_LIST_TASKS_WO_COL\"),\r\n        localsn_col: get(\"SLACK_LIST_TASKS_LOCALSN_COL\"),\r\n        tracking_col:get(\"SLACK_LIST_TASKS_TRACKING_COL\"),\r\n        photos_col:  get(\"SLACK_LIST_TASKS_PHOTOS_COL\"),\r\n        link_col:    get(\"SLACK_LIST_TASKS_LINK_COL\"),\r\n      },\r\n      shipping: {\r\n        list_id:   get(\"SLACK_LIST_SHIPPING_ID\"),\r\n        title_col: get(\"SLACK_LIST_SHIPPING_TITLE_COL\"),\r\n        desc_col:  anyOf(\"SLACK_LIST_SHIPPING_DESCRIPTION_COL\", \"SLACK_LIST_SHIPPING_DESC_COL\"),\r\n        pnsn_col:  get(\"SLACK_LIST_SHIPPING_PNSN_COL\"),\r\n        wo_col:    anyOf(\"SLACK_LIST_SHIPPING_WORKORDER_COL\",\"SLACK_LIST_SHIPPING_WO_COL\"),\r\n        localsn_col: get(\"SLACK_LIST_SHIPPING_LOCALSN_COL\"),\r\n        tracking_col:get(\"SLACK_LIST_SHIPPING_TRACKING_COL\"),\r\n        photos_col:  get(\"SLACK_LIST_SHIPPING_PHOTOS_COL\"),\r\n        link_col:    get(\"SLACK_LIST_SHIPPING_LINK_COL\"),\r\n      },\r\n      receiving: {\r\n        list_id:   get(\"SLACK_LIST_RECEIVING_ID\"),\r\n        title_col: get(\"SLACK_LIST_RECEIVING_TITLE_COL\"),\r\n        desc_col:  anyOf(\"SLACK_LIST_RECEIVING_DESCRIPTION_COL\", \"SLACK_LIST_RECEIVING_DESC_COL\"),\r\n        pnsn_col:  get(\"SLACK_LIST_RECEIVING_PNSN_COL\"),\r\n        wo_col:    anyOf(\"SLACK_LIST_RECEIVING_WORKORDER_COL\",\"SLACK_LIST_RECEIVING_WO_COL\"),\r\n        localsn_col: get(\"SLACK_LIST_RECEIVING_LOCALSN_COL\"),\r\n        tracking_col:get(\"SLACK_LIST_RECEIVING_TRACKING_COL\"),\r\n        photos_col:  get(\"SLACK_LIST_RECEIVING_PHOTOS_COL\"),\r\n        link_col:    get(\"SLACK_LIST_RECEIVING_LINK_COL\"),\r\n      },\r\n    })[listKey || \"\"];\r\n\r\n    if (!CFG?.list_id) return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n    if (!CFG.title_col) {\r\n      return res.status(400).json({\r\n        ok: false,\r\n        error: \"missing_title_column_in_env\",\r\n        fix: `Set SLACK_LIST_${(listKey || \"\").toUpperCase()}_TITLE_COL in .env.local`,\r\n      });\r\n    }\r\n\r\n    // ----- Slack helpers -----\r\n    async function slack(method, payload, tag) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/json; charset=utf-8\" },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      const j = await r.json().catch(() => ({}));\r\n      if (debug) log(tag || method, { ok: j?.ok, error: j?.error, status: r.status });\r\n      return j;\r\n    }\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n    const first = (x) => (Array.isArray(x) ? x.find(Boolean) || \"\" : plain(x));\r\n    const toRich = (text) => [{\r\n      type: \"rich_text\",\r\n      elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text: plain(text) }] }],\r\n    }];\r\n\r\n    async function updateOneCellText(list_id, row_id, column_id, value, label) {\r\n      const val = plain(value);\r\n      if (!val || !column_id) return { ok: true, skipped: true };\r\n      // use CELLS array (works in your tenant)\r\n      let r = await slack(\"slackLists.items.update\", {\r\n        list_id,\r\n        cells: [{ row_id, column_id, rich_text: toRich(val) }],\r\n      }, `[LISTS][SET-RICH][${label}]`);\r\n      if (r?.ok) return r;\r\n      if (r?.error === \"invalid_arguments\" || r?.error === \"invalid_input_type\") {\r\n        r = await slack(\"slackLists.items.update\", {\r\n          list_id,\r\n          cells: [{ row_id, column_id, text: val }],\r\n        }, `[LISTS][SET-TEXT][${label}]`);\r\n      }\r\n      return r;\r\n    }\r\n\r\n    async function attachFilesToCell(list_id, row_id, column_id, ids, label) {\r\n      if (!ids.length || !column_id) return { ok: true, skipped: true };\r\n      // Try a few shapes; keep using CELLS\r\n      let r = await slack(\"slackLists.items.update\", {\r\n        list_id,\r\n        cells: [{ row_id, column_id, attachment: ids }],\r\n      }, `[LISTS][ATTACH-A][${label}]`);\r\n      if (r?.ok) return r;\r\n\r\n      r = await slack(\"slackLists.items.update\", {\r\n        list_id,\r\n        cells: [{ row_id, column_id, file_ids: ids }],\r\n      }, `[LISTS][ATTACH-B][${label}]`);\r\n      if (r?.ok) return r;\r\n\r\n      r = await slack(\"slackLists.items.update\", {\r\n        list_id,\r\n        cells: [{ row_id, column_id, files: ids.map((id) => ({ id })) }],\r\n      }, `[LISTS][ATTACH-C][${label}]`);\r\n      if (r?.ok) return r;\r\n\r\n      r = await slack(\"slackLists.items.update\", {\r\n        list_id,\r\n        cells: [{ row_id, column_id, reference: ids.map((id) => ({ file: { file_id: id } })) }],\r\n      }, `[LISTS][ATTACH-D][${label}]`);\r\n      return r;\r\n    }\r\n\r\n    // modern upload flow: getUploadURLExternal -> POST bytes -> completeUploadExternal\r\n    async function uploadViaExternal(url, filename) {\r\n      try {\r\n        const resp = await fetch(url);\r\n        if (!resp.ok) return { ok: false, error: `fetch_${resp.status}` };\r\n        const buf = Buffer.from(await resp.arrayBuffer());\r\n        const byteLen = buf.length;\r\n\r\n        const reserve = await slack(\"files.getUploadURLExternal\",\r\n          { filename: filename || \"image.jpg\", length: byteLen },\r\n          \"[FILES.GETUPLOAD]\");\r\n        if (!reserve?.ok) return { ok: false, error: reserve?.error || \"get_upload_failed\" };\r\n\r\n        const { upload_url, file_id } = reserve;\r\n\r\n        const up = await fetch(upload_url, {\r\n          method: \"POST\",\r\n          headers: { \"Content-Type\": \"application/octet-stream\" },\r\n          body: buf,\r\n        });\r\n        log(\"[FILES.UPLOAD.POST]\", { ok: up.ok, status: up.status });\r\n        if (!up.ok) return { ok: false, error: `upload_post_${up.status}` };\r\n\r\n        const complete = await slack(\"files.completeUploadExternal\",\r\n          { files: [{ id: file_id, title: filename || \"image.jpg\" }] },\r\n          \"[FILES.COMPLETE]\");\r\n        if (!complete?.ok) return { ok: false, error: complete?.error || \"complete_failed\" };\r\n\r\n        const created = Array.isArray(complete.files) ? complete.files[0] : null;\r\n        return { ok: true, file: { id: created?.id || file_id } };\r\n      } catch (e) {\r\n        log(\"[FILES.UPLOAD.EXC]\", { message: e?.message });\r\n        return { ok: false, error: \"upload_exception\" };\r\n      }\r\n    }\r\n\r\n    // ----- 1) create the list item with Title (ARRAY SHAPE) -----\r\n    const safeTitle = plain(title) || \"New Item\";\r\n    const titleField = { column_id: CFG.title_col, rich_text: toRich(safeTitle) };\r\n\r\n    // Optionally include a link in title rich_text (kept simple)\r\n    // (Slack rich_text links are allowed; keep as plain text if this causes trouble)\r\n    if (linkUrl) {\r\n      titleField.rich_text = [{\r\n        type: \"rich_text\",\r\n        elements: [{\r\n          type: \"rich_text_section\",\r\n          elements: [\r\n            { type: \"text\", text: safeTitle + \"  \" },\r\n            { type: \"link\", url: linkUrl, text: \"(open)\" }\r\n          ]\r\n        }]\r\n      }];\r\n    }\r\n\r\n    let created = await slack(\"slackLists.items.create\", {\r\n      list_id: CFG.list_id,\r\n      initial_fields: [titleField], // <-- ARRAY, not map\r\n    }, \"[LISTS][CREATE-RICH]\");\r\n\r\n    if (!created?.ok && created?.error === \"invalid_arguments\") {\r\n      // fallback to plain text for title\r\n      created = await slack(\"slackLists.items.create\", {\r\n        list_id: CFG.list_id,\r\n        initial_fields: [{ column_id: CFG.title_col, text: safeTitle }],\r\n      }, \"[LISTS][CREATE-TEXT]\");\r\n    }\r\n\r\n    if (!created?.ok) {\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: created?.error || \"create_failed\",\r\n        debug: dbg,\r\n      });\r\n    }\r\n\r\n    const rowId = created.item?.id;\r\n    log(\"[LISTS][CREATED]\", { rowId });\r\n\r\n    // ----- 2) PN/SN -----\r\n    const pn0 = first(pn), sn0 = first(sn);\r\n    const pnSnText = [pn0 ? `PN: ${pn0}` : \"\", sn0 ? `SN: ${sn0}` : \"\"].filter(Boolean).join(\"  \");\r\n    if (pnSnText && CFG.pnsn_col) {\r\n      const r = await updateOneCellText(CFG.list_id, rowId, CFG.pnsn_col, pnSnText, \"PN/SN\");\r\n      if (!r?.ok) return res.status(200).json({ ok: false, error: r?.error || \"update_failed_pnsn\", debug: dbg });\r\n    }\r\n\r\n    // ----- 3) LocalSN -----\r\n    if (CFG.localsn_col && plain(localSN)) {\r\n      const r = await updateOneCellText(CFG.list_id, rowId, CFG.localsn_col, localSN, \"LOCAL_SN\");\r\n      if (!r?.ok) return res.status(200).json({ ok: false, error: r?.error || \"update_failed_localsn\", debug: dbg });\r\n    }\r\n\r\n    // ----- 4) Description -----\r\n    if (CFG.desc_col && plain(description)) {\r\n      const r = await updateOneCellText(CFG.list_id, rowId, CFG.desc_col, description, \"DESCRIPTION\");\r\n      if (!r?.ok) return res.status(200).json({ ok: false, error: r?.error || \"update_failed_description\", debug: dbg });\r\n    }\r\n\r\n    // ----- 5) Work Order -----\r\n    if (CFG.wo_col && plain(workOrder)) {\r\n      const r = await updateOneCellText(CFG.list_id, rowId, CFG.wo_col, workOrder, \"WORK_ORDER\");\r\n      if (!r?.ok) return res.status(200).json({ ok: false, error: r?.error || \"update_failed_workorder\", debug: dbg });\r\n    }\r\n\r\n    // ----- 6) Tracking -----\r\n    if (CFG.tracking_col && plain(tracking)) {\r\n      const r = await updateOneCellText(CFG.list_id, rowId, CFG.tracking_col, tracking, \"TRACKING\");\r\n      if (!r?.ok) return res.status(200).json({ ok: false, error: r?.error || \"update_failed_tracking\", debug: dbg });\r\n    }\r\n\r\n    // ----- 7) Photos (upload bytes → attach) -----\r\n    if (CFG.photos_col && Array.isArray(photoUrls) && photoUrls.length) {\r\n      const ids = [];\r\n      for (let i = 0; i < Math.min(photoUrls.length, 10); i++) {\r\n        const url = plain(photoUrls[i]);\r\n        if (!/^https?:\\/\\//i.test(url)) continue;\r\n        const filename = url.split(\"/\").pop()?.split(\"?\")[0] || `photo_${i + 1}.jpg`;\r\n\r\n        const up = await uploadViaExternal(url, filename);\r\n        dbg.photos.push({ i, url, upload_ok: !!up?.ok, upload_err: up?.error, file_id: up?.file?.id });\r\n        if (up?.ok && up?.file?.id) ids.push(up.file.id);\r\n      }\r\n\r\n      if (ids.length) {\r\n        const a = await attachFilesToCell(CFG.list_id, rowId, CFG.photos_col, ids, \"PHOTOS\");\r\n        if (!a?.ok) {\r\n          log(\"[PHOTOS][FAILED-ATTACH]\", { error: a?.error, ids });\r\n          // As a last resort, dump URLs into description\r\n          if (CFG.desc_col) {\r\n            const joined = `Photos:\\n${photoUrls.map(plain).filter(Boolean).join(\"\\n\")}`;\r\n            await updateOneCellText(CFG.list_id, rowId, CFG.desc_col, [description, joined].filter(Boolean).join(\"\\n\\n\"), \"PHOTOS->DESC-FALLBACK\");\r\n          }\r\n          return res.status(200).json({ ok: false, error: a?.error || \"update_failed_photos\", debug: dbg });\r\n        }\r\n      } else {\r\n        log(\"[PHOTOS][NO-IDS]\", { reason: \"upload_failed_or_empty\" });\r\n      }\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      list_id: CFG.list_id,\r\n      item_id: rowId,\r\n      used_cols: {\r\n        title_col: CFG.title_col,\r\n        pnsn_col: CFG.pnsn_col || null,\r\n        description_col: CFG.desc_col || null,\r\n        workorder_col: CFG.wo_col || null,\r\n        localsn_col: CFG.localsn_col || null,\r\n        tracking_col: CFG.tracking_col || null,\r\n        photos_col: CFG.photos_col || null,\r\n      },\r\n      debug: dbg,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err), debug: dbg });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}