{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useEffect, useMemo, useRef, useState } from \"react\";\nimport styles from \"./MultiSelectDropdown.module.css\";\n\nfunction normalizeValue(value) {\n  if (value == null) return \"\";\n  return String(value).trim();\n}\n\nexport default function MultiSelectDropdown({\n  label,\n  placeholder = \"Select Option\",\n  options = [],\n  selected = [],\n  onChange,\n  searchable = true,\n  disabled = false,\n  enableDelete = false,\n  onDeleteOption\n}) {\n  const {\n    0: open,\n    1: setOpen\n  } = useState(false);\n  const {\n    0: query,\n    1: setQuery\n  } = useState(\"\");\n  const menuRef = useRef(null);\n  const holdTimerRef = useRef(null);\n  const holdTriggeredRef = useRef(false);\n  const selectedSet = useMemo(() => new Set((selected || []).map(normalizeValue).filter(Boolean)), [selected]);\n  const filteredOptions = useMemo(() => {\n    const search = query.trim().toLowerCase();\n    const normalized = (options || []).map(normalizeValue).filter(Boolean);\n    if (!search) return normalized;\n    return normalized.filter(option => option.toLowerCase().includes(search));\n  }, [options, query]);\n\n  const toggleOption = value => {\n    const normalized = normalizeValue(value);\n    if (!normalized || typeof onChange !== \"function\") return;\n    const next = new Set(selectedSet);\n\n    if (next.has(normalized)) {\n      next.delete(normalized);\n    } else {\n      next.add(normalized);\n    }\n\n    onChange(Array.from(next));\n  };\n\n  const startHold = value => {\n    if (!enableDelete || typeof onDeleteOption !== \"function\") return;\n    holdTriggeredRef.current = false;\n    clearTimeout(holdTimerRef.current);\n    holdTimerRef.current = setTimeout(() => {\n      holdTriggeredRef.current = true;\n      const confirmed = window.confirm(`Delete \"${value}\" from the list?`);\n\n      if (confirmed) {\n        onDeleteOption(value);\n      }\n    }, 650);\n  };\n\n  const cancelHold = () => {\n    clearTimeout(holdTimerRef.current);\n  };\n\n  const handleOptionClick = value => {\n    if (holdTriggeredRef.current) {\n      holdTriggeredRef.current = false;\n      return;\n    }\n\n    toggleOption(value);\n  };\n\n  const displayText = useMemo(() => {\n    if (!selectedSet.size) return placeholder;\n    const values = Array.from(selectedSet);\n    if (values.length === 1) return values[0];\n    return `Multi (${values.length})`;\n  }, [placeholder, selectedSet]);\n  useEffect(() => {\n    const handleOutside = event => {\n      if (!menuRef.current) return;\n\n      if (!menuRef.current.contains(event.target)) {\n        setOpen(false);\n      }\n    };\n\n    if (open) {\n      document.addEventListener(\"mousedown\", handleOutside);\n      document.addEventListener(\"touchstart\", handleOutside);\n    }\n\n    return () => {\n      document.removeEventListener(\"mousedown\", handleOutside);\n      document.removeEventListener(\"touchstart\", handleOutside);\n    };\n  }, [open]);\n  useEffect(() => {\n    if (!open) setQuery(\"\");\n  }, [open]);\n  return __jsx(\"div\", {\n    className: styles.wrapper,\n    ref: menuRef\n  }, label ? __jsx(\"div\", {\n    className: styles.label\n  }, label) : null, __jsx(\"button\", {\n    type: \"button\",\n    className: styles.toggle,\n    onClick: () => setOpen(prev => !prev),\n    disabled: disabled\n  }, __jsx(\"span\", {\n    className: styles.toggleText\n  }, displayText), __jsx(\"span\", null, open ? \"▲\" : \"▼\")), open && __jsx(\"div\", {\n    className: styles.menu\n  }, searchable && __jsx(\"input\", {\n    className: styles.search,\n    placeholder: \"Search...\",\n    value: query,\n    onChange: event => setQuery(event.target.value)\n  }), __jsx(\"div\", {\n    className: styles.list\n  }, !filteredOptions.length && __jsx(\"div\", {\n    className: styles.emptyState\n  }, \"No results\"), filteredOptions.map(option => {\n    const checked = selectedSet.has(option);\n    return __jsx(\"div\", {\n      key: option,\n      className: styles.option,\n      onMouseDown: () => startHold(option),\n      onMouseUp: cancelHold,\n      onMouseLeave: cancelHold,\n      onTouchStart: () => startHold(option),\n      onTouchEnd: cancelHold,\n      onClick: () => handleOptionClick(option)\n    }, __jsx(\"input\", {\n      type: \"checkbox\",\n      className: styles.optionCheckbox,\n      checked: checked,\n      readOnly: true\n    }), __jsx(\"span\", {\n      className: styles.optionLabel\n    }, option));\n  }))));\n}","map":null,"metadata":{},"sourceType":"module"}