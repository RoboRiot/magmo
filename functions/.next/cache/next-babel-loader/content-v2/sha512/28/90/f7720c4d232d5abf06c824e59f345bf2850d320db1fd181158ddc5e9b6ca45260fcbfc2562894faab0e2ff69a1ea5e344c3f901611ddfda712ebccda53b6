{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  try {\n    var _created, _created2, _created3;\n\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n\n    if (!token) {\n      return res.status(500).json({\n        ok: false,\n        error: \"missing_SLACK_BOT_TOKEN\"\n      });\n    } // === payload from client (same as your working version) ===\n\n\n    const {\n      listKey,\n      title,\n      pn,\n      sn\n    } = req.body || {}; // === env based config (no auto-discovery) ===\n\n    const CFG = {\n      tasks: {\n        list_id: process.env.SLACK_LIST_TASKS_ID,\n        title_col: process.env.SLACK_LIST_TASKS_TITLE_COL,\n        pnsn_col: process.env.SLACK_LIST_TASKS_PNSN_COL // optional / likely undefined\n\n      },\n      shipping: {\n        list_id: process.env.SLACK_LIST_SHIPPING_ID,\n        title_col: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\n        pnsn_col: process.env.SLACK_LIST_SHIPPING_PNSN_COL\n      },\n      receiving: {\n        list_id: process.env.SLACK_LIST_RECEIVING_ID,\n        title_col: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\n        pnsn_col: process.env.SLACK_LIST_RECEIVING_PNSN_COL\n      }\n    }[listKey || \"\"];\n\n    if (!(CFG !== null && CFG !== void 0 && CFG.list_id)) {\n      return res.status(400).json({\n        ok: false,\n        error: `unknown_listKey_${listKey}`\n      });\n    }\n\n    if (!CFG.title_col) {\n      return res.status(400).json({\n        ok: false,\n        error: \"missing_title_column_in_env\",\n        fix: `Set SLACK_LIST_${(listKey || \"\").toUpperCase()}_TITLE_COL in .env.local`\n      });\n    } // --- Slack helpers (same shapes you had) ---\n\n\n    async function slackJson(method, payload) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(payload)\n      });\n      return r.json();\n    }\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const first = x => Array.isArray(x) ? x.find(Boolean) || \"\" : plain(x);\n\n    function toRichText(text) {\n      const t = plain(text);\n      return [{\n        type: \"rich_text\",\n        elements: [{\n          type: \"rich_text_section\",\n          elements: [{\n            type: \"text\",\n            text: t\n          }]\n        }]\n      }];\n    } // === 1) Create row with title in the known title column ===\n\n\n    const safeTitle = plain(title) || \"New Item\"; // try rich_text first (exactly what your working code did) …\n\n    let created = await slackJson(\"slackLists.items.create\", {\n      list_id: CFG.list_id,\n      initial_fields: [{\n        column_id: CFG.title_col,\n        rich_text: toRichText(safeTitle)\n      }]\n    }); // …and a plain text fallback if Slack screams \"invalid_arguments\"\n\n    if (!((_created = created) !== null && _created !== void 0 && _created.ok) && ((_created2 = created) === null || _created2 === void 0 ? void 0 : _created2.error) === \"invalid_arguments\") {\n      created = await slackJson(\"slackLists.items.create\", {\n        list_id: CFG.list_id,\n        initial_fields: [{\n          column_id: CFG.title_col,\n          text: safeTitle\n        }]\n      });\n    }\n\n    if (!((_created3 = created) !== null && _created3 !== void 0 && _created3.ok)) {\n      var _created4;\n\n      return res.status(200).json({\n        ok: false,\n        error: ((_created4 = created) === null || _created4 === void 0 ? void 0 : _created4.error) || \"create_failed\",\n        mode: \"list\",\n        list_id: CFG.list_id,\n        title_col: CFG.title_col,\n        sent_title: safeTitle\n      });\n    } // === 2) Minimal update: PN/SN only (like your working code) ===\n\n\n    const pn0 = first(pn);\n    const sn0 = first(sn);\n    const pnPart = pn0 ? `PN: ${pn0}` : \"\";\n    const snPart = sn0 ? `SN: ${sn0}` : \"\";\n    const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n    let updated = null;\n    let usedPnSnCol = null;\n\n    if (pnSnText && CFG.pnsn_col) {\n      var _updated, _updated2, _updated3;\n\n      const cellsRT = [{\n        row_id: created.item.id,\n        column_id: CFG.pnsn_col,\n        rich_text: toRichText(pnSnText)\n      }]; // rich_text first\n\n      updated = await slackJson(\"slackLists.items.update\", {\n        list_id: CFG.list_id,\n        cells: cellsRT\n      });\n      usedPnSnCol = CFG.pnsn_col; // text fallback if needed\n\n      if (!((_updated = updated) !== null && _updated !== void 0 && _updated.ok) && ((_updated2 = updated) === null || _updated2 === void 0 ? void 0 : _updated2.error) === \"invalid_arguments\") {\n        const cellsText = [{\n          row_id: created.item.id,\n          column_id: CFG.pnsn_col,\n          text: pnSnText\n        }];\n        updated = await slackJson(\"slackLists.items.update\", {\n          list_id: CFG.list_id,\n          cells: cellsText\n        });\n      } // if PN/SN update fails, surface it but still tell you the row was created\n\n\n      if (!((_updated3 = updated) !== null && _updated3 !== void 0 && _updated3.ok)) {\n        var _updated4;\n\n        return res.status(200).json({\n          ok: false,\n          error: ((_updated4 = updated) === null || _updated4 === void 0 ? void 0 : _updated4.error) || \"update_failed\",\n          mode: \"list\",\n          list_id: CFG.list_id,\n          item_id: created.item.id,\n          used_title_col: CFG.title_col,\n          used_pnsn_col: usedPnSnCol\n        });\n      }\n    } // === 3) Done ===\n\n\n    return res.status(200).json({\n      ok: true,\n      mode: \"list\",\n      list_id: CFG.list_id,\n      item_id: created.item.id,\n      used_title_col: CFG.title_col,\n      used_pnsn_col: usedPnSnCol || null,\n      sent_title: safeTitle\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn","sn","body","CFG","tasks","list_id","SLACK_LIST_TASKS_ID","title_col","SLACK_LIST_TASKS_TITLE_COL","pnsn_col","SLACK_LIST_TASKS_PNSN_COL","shipping","SLACK_LIST_SHIPPING_ID","SLACK_LIST_SHIPPING_TITLE_COL","SLACK_LIST_SHIPPING_PNSN_COL","receiving","SLACK_LIST_RECEIVING_ID","SLACK_LIST_RECEIVING_TITLE_COL","SLACK_LIST_RECEIVING_PNSN_COL","fix","toUpperCase","slackJson","payload","r","fetch","headers","Authorization","JSON","stringify","plain","v","toString","trim","first","x","Array","isArray","find","Boolean","toRichText","text","t","type","elements","safeTitle","created","initial_fields","column_id","rich_text","mode","sent_title","pn0","sn0","pnPart","snPart","pnSnText","filter","join","updated","usedPnSnCol","cellsRT","row_id","item","id","cells","cellsText","item_id","used_title_col","used_pnsn_col","err","console","message","String"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAI;AAAA;;AACF,QAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,aAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAArB,CAAP;AACD;;AAED,UAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;;AACA,QAAI,CAACH,KAAL,EAAY;AACV,aAAON,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   try {\r\n//     if (req.method !== \"POST\") {\r\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//     }\r\n\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) {\r\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//     }\r\n\r\n//     // payload from client\r\n//     const {\r\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n//       title,               // item title (what shows in the primary column)\r\n//       // keeping minimal per your request: PN/SN only for now\r\n//       pn, sn,\r\n//     } = req.body || {};\r\n\r\n//     // list ids from env\r\n//     const LIST_IDS = {\r\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\r\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n//     };\r\n\r\n//     const list_id = LIST_IDS[listKey];\r\n//     if (!list_id) {\r\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n//     }\r\n\r\n//     // ---- Slack helpers ----\r\n//     async function slackJson(method, payload) {\r\n//       const r = await fetch(`https://slack.com/api/${method}`, {\r\n//         method: \"POST\",\r\n//         headers: {\r\n//           Authorization: `Bearer ${token}`,\r\n//           \"Content-Type\": \"application/json; charset=utf-8\",\r\n//         },\r\n//         body: JSON.stringify(payload),\r\n//       });\r\n//       return r.json();\r\n//     }\r\n\r\n//     const plain = (v) => (v ?? \"\").toString().trim();\r\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     function toRichText(text) {\r\n//       const t = plain(text);\r\n//       return [{\r\n//         type: \"rich_text\",\r\n//         elements: [{\r\n//           type: \"rich_text_section\",\r\n//           elements: [{ type: \"text\", text: t }],\r\n//         }],\r\n//       }];\r\n//     }\r\n\r\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n//     async function resolveTitleColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n//       let fallback = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\r\n//           if (f.column_id && hasText) {\r\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n//             if (!fallback) fallback = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return fallback; // first text-like field if we didn't find a perfect match\r\n//     }\r\n\r\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n//     async function resolvePnSnColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       let candidate = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           if (!f.column_id) continue;\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const text = (f.text || \"\").toLowerCase();\r\n\r\n//           const looksPnSn =\r\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\r\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n//           if (looksPnSn) return f.column_id;\r\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n//             candidate = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return candidate;\r\n//     }\r\n\r\n//     // 1) Resolve columns\r\n//     const titleColId = await resolveTitleColId(list_id);\r\n//     if (!titleColId) {\r\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n//     }\r\n\r\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n//     const safeTitle = plain(title) || \"New Item\";\r\n//     const createBody = {\r\n//       list_id,\r\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n//     };\r\n\r\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 3) (Minimal) update: PN/SN only, per your request\r\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n//     let updated = null;\r\n//     let usedPnSnCol = null;\r\n\r\n//     if (pnSnText) {\r\n//       const pnSnColId = await resolvePnSnColId(list_id);\r\n//       if (pnSnColId) {\r\n//         const cells = [{\r\n//           row_id: created.item.id,\r\n//           column_id: pnSnColId,\r\n//           rich_text: toRichText(pnSnText),\r\n//         }];\r\n\r\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n//         usedPnSnCol = pnSnColId;\r\n//         // If update fails, we still return ok:false so you can see the error\r\n//         if (!updated?.ok) {\r\n//           return res.status(200).json({\r\n//             ok: false,\r\n//             error: updated?.error || \"update_failed\",\r\n//             mode: \"list\",\r\n//             list_id,\r\n//             item_id: created.item.id,\r\n//             used_title_col: titleColId,\r\n//             used_pnsn_col: usedPnSnCol,\r\n//           });\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleColId,\r\n//       used_pnsn_col: usedPnSnCol || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) {\r\n      return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n    }\r\n\r\n    // === payload from client (same as your working version) ===\r\n    const { listKey, title, pn, sn } = req.body || {};\r\n\r\n    // === env based config (no auto-discovery) ===\r\n    const CFG = {\r\n      tasks: {\r\n        list_id: process.env.SLACK_LIST_TASKS_ID,\r\n        title_col: process.env.SLACK_LIST_TASKS_TITLE_COL,\r\n        pnsn_col: process.env.SLACK_LIST_TASKS_PNSN_COL, // optional / likely undefined\r\n      },\r\n      shipping: {\r\n        list_id: process.env.SLACK_LIST_SHIPPING_ID,\r\n        title_col: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\r\n        pnsn_col: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n      },\r\n      receiving: {\r\n        list_id: process.env.SLACK_LIST_RECEIVING_ID,\r\n        title_col: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\r\n        pnsn_col: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n      },\r\n    }[listKey || \"\"];\r\n\r\n    if (!CFG?.list_id) {\r\n      return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n    }\r\n    if (!CFG.title_col) {\r\n      return res.status(400).json({\r\n        ok: false,\r\n        error: \"missing_title_column_in_env\",\r\n        fix: `Set SLACK_LIST_${(listKey || \"\").toUpperCase()}_TITLE_COL in .env.local`,\r\n      });\r\n    }\r\n\r\n    // --- Slack helpers (same shapes you had) ---\r\n    async function slackJson(method, payload) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          Authorization: `Bearer ${token}`,\r\n          \"Content-Type\": \"application/json; charset=utf-8\",\r\n        },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      return r.json();\r\n    }\r\n\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n    const first = (x) => (Array.isArray(x) ? x.find(Boolean) || \"\" : plain(x));\r\n    function toRichText(text) {\r\n      const t = plain(text);\r\n      return [{\r\n        type: \"rich_text\",\r\n        elements: [{\r\n          type: \"rich_text_section\",\r\n          elements: [{ type: \"text\", text: t }],\r\n        }],\r\n      }];\r\n    }\r\n\r\n    // === 1) Create row with title in the known title column ===\r\n    const safeTitle = plain(title) || \"New Item\";\r\n\r\n    // try rich_text first (exactly what your working code did) …\r\n    let created = await slackJson(\"slackLists.items.create\", {\r\n      list_id: CFG.list_id,\r\n      initial_fields: [{ column_id: CFG.title_col, rich_text: toRichText(safeTitle) }],\r\n    });\r\n\r\n    // …and a plain text fallback if Slack screams \"invalid_arguments\"\r\n    if (!created?.ok && created?.error === \"invalid_arguments\") {\r\n      created = await slackJson(\"slackLists.items.create\", {\r\n        list_id: CFG.list_id,\r\n        initial_fields: [{ column_id: CFG.title_col, text: safeTitle }],\r\n      });\r\n    }\r\n\r\n    if (!created?.ok) {\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: created?.error || \"create_failed\",\r\n        mode: \"list\",\r\n        list_id: CFG.list_id,\r\n        title_col: CFG.title_col,\r\n        sent_title: safeTitle,\r\n      });\r\n    }\r\n\r\n    // === 2) Minimal update: PN/SN only (like your working code) ===\r\n    const pn0 = first(pn);\r\n    const sn0 = first(sn);\r\n    const pnPart = pn0 ? `PN: ${pn0}` : \"\";\r\n    const snPart = sn0 ? `SN: ${sn0}` : \"\";\r\n    const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n    let updated = null;\r\n    let usedPnSnCol = null;\r\n\r\n    if (pnSnText && CFG.pnsn_col) {\r\n      const cellsRT = [{\r\n        row_id: created.item.id,\r\n        column_id: CFG.pnsn_col,\r\n        rich_text: toRichText(pnSnText),\r\n      }];\r\n\r\n      // rich_text first\r\n      updated = await slackJson(\"slackLists.items.update\", {\r\n        list_id: CFG.list_id,\r\n        cells: cellsRT,\r\n      });\r\n      usedPnSnCol = CFG.pnsn_col;\r\n\r\n      // text fallback if needed\r\n      if (!updated?.ok && updated?.error === \"invalid_arguments\") {\r\n        const cellsText = [{\r\n          row_id: created.item.id,\r\n          column_id: CFG.pnsn_col,\r\n          text: pnSnText,\r\n        }];\r\n        updated = await slackJson(\"slackLists.items.update\", {\r\n          list_id: CFG.list_id,\r\n          cells: cellsText,\r\n        });\r\n      }\r\n\r\n      // if PN/SN update fails, surface it but still tell you the row was created\r\n      if (!updated?.ok) {\r\n        return res.status(200).json({\r\n          ok: false,\r\n          error: updated?.error || \"update_failed\",\r\n          mode: \"list\",\r\n          list_id: CFG.list_id,\r\n          item_id: created.item.id,\r\n          used_title_col: CFG.title_col,\r\n          used_pnsn_col: usedPnSnCol,\r\n        });\r\n      }\r\n    }\r\n\r\n    // === 3) Done ===\r\n    return res.status(200).json({\r\n      ok: true,\r\n      mode: \"list\",\r\n      list_id: CFG.list_id,\r\n      item_id: created.item.id,\r\n      used_title_col: CFG.title_col,\r\n      used_pnsn_col: usedPnSnCol || null,\r\n      sent_title: safeTitle,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}