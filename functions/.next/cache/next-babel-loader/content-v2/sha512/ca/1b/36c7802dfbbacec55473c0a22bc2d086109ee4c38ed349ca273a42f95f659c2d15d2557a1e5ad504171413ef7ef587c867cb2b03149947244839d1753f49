{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport firebase from \"../context/Firebase\";\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(partsSnapshot.docs.map(async partDoc => {\n    var _ref, _getRefId, _ref2, _getRefId2;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    const getRefId = ref => {\n      if (!ref) return null;\n      if (typeof ref === \"string\") return ref;\n      if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n      if (ref.id) return ref.id;\n      return null;\n    };\n\n    partData.clientFromId = (_ref = (_getRefId = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientFrom)) !== null && _getRefId !== void 0 ? _getRefId : partData === null || partData === void 0 ? void 0 : partData.clientFromId) !== null && _ref !== void 0 ? _ref : null;\n    partData.clientCurrentId = (_ref2 = (_getRefId2 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientCurrent)) !== null && _getRefId2 !== void 0 ? _getRefId2 : partData === null || partData === void 0 ? void 0 : partData.clientCurrentId) !== null && _ref2 !== void 0 ? _ref2 : null; // console.log(partData);\n\n    const fetchMachineData = async ref => {\n      if (!ref) return null;\n\n      if (typeof ref.get === \"function\") {\n        const doc = await ref.get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (typeof ref === \"string\") {\n        const doc = await db.collection(\"Machine\").doc(ref).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (ref !== null && ref !== void 0 && ref.id) {\n        const doc = await db.collection(\"Machine\").doc(ref.id).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      return null;\n    };\n\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef = partData.CurrentMachine || partData.MachineCurrent;\n    const machineData = await fetchMachineData(machineRef);\n    partData.machineData = machineData || {};\n\n    if (machineData !== null && machineData !== void 0 && machineData.client) {\n      const clientRef = machineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (clientId && !partData.clientFromId) {\n        partData.clientFromId = clientId;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    const currentMachineData = await fetchMachineData(currentMachineRef);\n    partData.currentMachineData = currentMachineData || {};\n\n    if (currentMachineData !== null && currentMachineData !== void 0 && currentMachineData.client) {\n      const clientRef = currentMachineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (clientId && !partData.clientCurrentId) {\n        partData.clientCurrentId = clientId;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.currentMachineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    return partData;\n  }));\n  return parts;\n} // Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\n\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false,\n  filterFn = null\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const buildPart = async partDoc => {\n    var _ref3, _getRefId3, _ref4, _getRefId4;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    const getRefId = ref => {\n      if (!ref) return null;\n      if (typeof ref === \"string\") return ref;\n      if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n      if (ref.id) return ref.id;\n      return null;\n    };\n\n    partData.clientFromId = (_ref3 = (_getRefId3 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientFrom)) !== null && _getRefId3 !== void 0 ? _getRefId3 : partData === null || partData === void 0 ? void 0 : partData.clientFromId) !== null && _ref3 !== void 0 ? _ref3 : null;\n    partData.clientCurrentId = (_ref4 = (_getRefId4 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientCurrent)) !== null && _getRefId4 !== void 0 ? _getRefId4 : partData === null || partData === void 0 ? void 0 : partData.clientCurrentId) !== null && _ref4 !== void 0 ? _ref4 : null;\n\n    const fetchMachineData = async ref => {\n      if (!ref) return null;\n\n      if (typeof ref.get === \"function\") {\n        const doc = await ref.get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (typeof ref === \"string\") {\n        const doc = await db.collection(\"Machine\").doc(ref).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (ref !== null && ref !== void 0 && ref.id) {\n        const doc = await db.collection(\"Machine\").doc(ref.id).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      return null;\n    };\n\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef = partData.CurrentMachine || partData.MachineCurrent;\n    const machineData = await fetchMachineData(machineRef);\n    partData.machineData = machineData || {};\n\n    if (machineData !== null && machineData !== void 0 && machineData.client) {\n      const clientRef = machineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (!partData.clientFromId) {\n        partData.clientFromId = clientId || null;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    const currentMachineData = await fetchMachineData(currentMachineRef);\n    partData.currentMachineData = currentMachineData || {};\n\n    if (currentMachineData !== null && currentMachineData !== void 0 && currentMachineData.client) {\n      const clientRef = currentMachineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (!partData.clientCurrentId) {\n        partData.clientCurrentId = clientId || null;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.currentMachineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    return partData;\n  };\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let pageLastDoc = null;\n  let hasNextPage = false;\n  let filled = false;\n\n  while (true) {\n    let query = db.collection(\"Test\").limit(limit);\n    if (cursor) query = query.startAfter(cursor);\n    const snap = await query.get();\n\n    if (snap.empty) {\n      hasNextPage = false;\n      break;\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = snap.docs[i];\n      cursor = doc;\n      const raw = doc.data();\n\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      const built = await buildPart(doc);\n\n      if (filterFn && !filterFn(built)) {\n        continue;\n      }\n\n      if (!filled) {\n        parts.push(built);\n\n        if (parts.length === pageSize) {\n          filled = true;\n          pageLastDoc = doc;\n        }\n\n        continue;\n      } // We already filled the page and found an extra matching item.\n\n\n      hasNextPage = true;\n      return {\n        parts,\n        lastDoc: pageLastDoc,\n        hasNextPage\n      };\n    } // We exhausted this batch without filling the page.\n\n\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    } // There might be more docs; continue scanning for visible items.\n\n\n    hasNextPage = true;\n  }\n\n  lastDoc = pageLastDoc || (parts.length ? cursor : null);\n  return {\n    parts,\n    lastDoc,\n    hasNextPage: filled ? hasNextPage : false\n  };\n}\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map(doc => _objectSpread({\n    id: doc.id\n  }, doc.data())); // Filter clients based on OEM and Modality if selected\n\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n\n    for (const client of clients) {\n      let match = true;\n\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n\n          if (selectedOEM && machineData.OEM === selectedOEM || selectedModality && machineData.Modality === selectedModality) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n\n    return filteredClients;\n  }\n\n  return clients;\n}\nexport async function fetchModels(selectedOEM, selectedModality, selectedClient) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n  await Promise.all(machinesSnapshot.docs.map(async machineDoc => {\n    const machineData = machineDoc.data();\n    let isValid = true;\n    if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n    if (selectedModality && machineData.Modality !== selectedModality) isValid = false;\n\n    if (selectedClient && machineData.client) {\n      const clientDoc = await machineData.client.get();\n      if (!clientDoc.exists || clientDoc.data().name !== selectedClient) isValid = false;\n    }\n\n    if (isValid) {\n      models.add(machineData.Model);\n    }\n  }));\n  return Array.from(models);\n}\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/utils/fetchAssociations.js"],"names":["React","firebase","fetchPartsWithMachineData","db","firestore","partsSnapshot","collection","get","parts","Promise","all","docs","map","partDoc","partData","data","id","getRefId","ref","DocumentReference","clientFromId","ClientFrom","clientCurrentId","ClientCurrent","fetchMachineData","doc","exists","machineRef","Machine","MachineFrom","currentMachineRef","CurrentMachine","MachineCurrent","machineData","client","clientRef","clientId","clientDoc","Client","name","currentMachineData","fetchPartsWithMachineDataPage","pageSize","startAfterDoc","visibleOnly","filterFn","limit","buildPart","cursor","lastDoc","pageLastDoc","hasNextPage","filled","query","startAfter","snap","empty","i","length","raw","visible","built","push","size","fetchClients","selectedOEM","selectedModality","clientsSnapshot","clients","filteredClients","match","machines","machineDoc","OEM","Modality","fetchModels","selectedClient","machinesSnapshot","models","Set","isValid","add","Model","Array","from","formatDate","timestamp","date","toDate","Date","day","String","getDate","padStart","month","getMonth","year","getFullYear"],"mappings":"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","sourcesContent":["import React from 'react'\nimport firebase from \"../context/Firebase\";\n\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(\n    partsSnapshot.docs.map(async (partDoc) => {\n      const partData = partDoc.data();\n      partData.id = partDoc.id; // Add document ID here\n      const getRefId = (ref) => {\n        if (!ref) return null;\n        if (typeof ref === \"string\") return ref;\n        if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n        if (ref.id) return ref.id;\n        return null;\n      };\n      partData.clientFromId =\n        getRefId(partData?.ClientFrom) ?? partData?.clientFromId ?? null;\n      partData.clientCurrentId =\n        getRefId(partData?.ClientCurrent) ?? partData?.clientCurrentId ?? null;\n      // console.log(partData);\n      const fetchMachineData = async (ref) => {\n        if (!ref) return null;\n        if (typeof ref.get === \"function\") {\n          const doc = await ref.get();\n          return doc.exists ? doc.data() : null;\n        }\n        if (typeof ref === \"string\") {\n          const doc = await db.collection(\"Machine\").doc(ref).get();\n          return doc.exists ? doc.data() : null;\n        }\n        if (ref?.id) {\n          const doc = await db.collection(\"Machine\").doc(ref.id).get();\n          return doc.exists ? doc.data() : null;\n        }\n        return null;\n      };\n\n      const machineRef = partData.Machine || partData.MachineFrom;\n      const currentMachineRef =\n        partData.CurrentMachine || partData.MachineCurrent;\n\n      const machineData = await fetchMachineData(machineRef);\n      partData.machineData = machineData || {};\n      if (machineData?.client) {\n        const clientRef = machineData.client;\n        const clientId = getRefId(clientRef);\n        if (clientId && !partData.clientFromId) {\n          partData.clientFromId = clientId;\n        }\n        if (typeof clientRef?.get === \"function\") {\n          const clientDoc = await clientRef.get();\n          partData.machineData.Client = clientDoc.exists\n            ? clientDoc.data().name\n            : \"\";\n        }\n      }\n\n      const currentMachineData = await fetchMachineData(currentMachineRef);\n      partData.currentMachineData = currentMachineData || {};\n      if (currentMachineData?.client) {\n        const clientRef = currentMachineData.client;\n        const clientId = getRefId(clientRef);\n        if (clientId && !partData.clientCurrentId) {\n          partData.clientCurrentId = clientId;\n        }\n        if (typeof clientRef?.get === \"function\") {\n          const clientDoc = await clientRef.get();\n          partData.currentMachineData.Client = clientDoc.exists\n            ? clientDoc.data().name\n            : \"\";\n        }\n      }\n      return partData;\n    })\n  );\n  return parts;\n}\n\n// Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false,\n  filterFn = null,\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const buildPart = async (partDoc) => {\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n    const getRefId = (ref) => {\n      if (!ref) return null;\n      if (typeof ref === \"string\") return ref;\n      if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n      if (ref.id) return ref.id;\n      return null;\n    };\n    partData.clientFromId =\n      getRefId(partData?.ClientFrom) ?? partData?.clientFromId ?? null;\n    partData.clientCurrentId =\n      getRefId(partData?.ClientCurrent) ?? partData?.clientCurrentId ?? null;\n\n    const fetchMachineData = async (ref) => {\n      if (!ref) return null;\n      if (typeof ref.get === \"function\") {\n        const doc = await ref.get();\n        return doc.exists ? doc.data() : null;\n      }\n      if (typeof ref === \"string\") {\n        const doc = await db.collection(\"Machine\").doc(ref).get();\n        return doc.exists ? doc.data() : null;\n      }\n      if (ref?.id) {\n        const doc = await db.collection(\"Machine\").doc(ref.id).get();\n        return doc.exists ? doc.data() : null;\n      }\n      return null;\n    };\n\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef =\n      partData.CurrentMachine || partData.MachineCurrent;\n\n    const machineData = await fetchMachineData(machineRef);\n    partData.machineData = machineData || {};\n    if (machineData?.client) {\n      const clientRef = machineData.client;\n      const clientId = getRefId(clientRef);\n      if (!partData.clientFromId) {\n        partData.clientFromId = clientId || null;\n      }\n      if (typeof clientRef?.get === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.machineData.Client = clientDoc.exists\n          ? clientDoc.data().name\n          : \"\";\n      }\n    }\n\n    const currentMachineData = await fetchMachineData(currentMachineRef);\n    partData.currentMachineData = currentMachineData || {};\n    if (currentMachineData?.client) {\n      const clientRef = currentMachineData.client;\n      const clientId = getRefId(clientRef);\n      if (!partData.clientCurrentId) {\n        partData.clientCurrentId = clientId || null;\n      }\n      if (typeof clientRef?.get === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.currentMachineData.Client = clientDoc.exists\n          ? clientDoc.data().name\n          : \"\";\n      }\n    }\n    return partData;\n  };\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let pageLastDoc = null;\n  let hasNextPage = false;\n  let filled = false;\n\n  while (true) {\n    let query = db.collection(\"Test\").limit(limit);\n    if (cursor) query = query.startAfter(cursor);\n\n    const snap = await query.get();\n    if (snap.empty) {\n      hasNextPage = false;\n      break;\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = snap.docs[i];\n      cursor = doc;\n\n      const raw = doc.data();\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      const built = await buildPart(doc);\n      if (filterFn && !filterFn(built)) {\n        continue;\n      }\n\n      if (!filled) {\n        parts.push(built);\n        if (parts.length === pageSize) {\n          filled = true;\n          pageLastDoc = doc;\n        }\n        continue;\n      }\n\n      // We already filled the page and found an extra matching item.\n      hasNextPage = true;\n      return { parts, lastDoc: pageLastDoc, hasNextPage };\n    }\n\n    // We exhausted this batch without filling the page.\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    }\n\n    // There might be more docs; continue scanning for visible items.\n    hasNextPage = true;\n  }\n\n  lastDoc = pageLastDoc || (parts.length ? cursor : null);\n  return { parts, lastDoc, hasNextPage: filled ? hasNextPage : false };\n}\n\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map((doc) => ({\n    id: doc.id,\n    ...doc.data(),\n  }));\n\n  // Filter clients based on OEM and Modality if selected\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n    for (const client of clients) {\n      let match = true;\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n          if (\n            (selectedOEM && machineData.OEM === selectedOEM) ||\n            (selectedModality && machineData.Modality === selectedModality)\n          ) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n    return filteredClients;\n  }\n\n  return clients;\n}\n\nexport async function fetchModels(\n  selectedOEM,\n  selectedModality,\n  selectedClient\n) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n\n  await Promise.all(\n    machinesSnapshot.docs.map(async (machineDoc) => {\n      const machineData = machineDoc.data();\n      let isValid = true;\n\n      if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n      if (selectedModality && machineData.Modality !== selectedModality)\n        isValid = false;\n      if (selectedClient && machineData.client) {\n        const clientDoc = await machineData.client.get();\n        if (!clientDoc.exists || clientDoc.data().name !== selectedClient)\n          isValid = false;\n      }\n\n      if (isValid) {\n        models.add(machineData.Model);\n      }\n    })\n  );\n\n  return Array.from(models);\n}\n\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}\n"]},"metadata":{},"sourceType":"module"}