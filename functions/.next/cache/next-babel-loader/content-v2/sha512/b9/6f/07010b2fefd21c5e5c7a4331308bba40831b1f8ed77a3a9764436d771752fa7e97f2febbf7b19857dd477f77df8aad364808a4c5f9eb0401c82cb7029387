{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport firebase from \"../context/Firebase\";\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(partsSnapshot.docs.map(async partDoc => {\n    var _ref, _getRefId, _ref2, _getRefId2;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    const getRefId = ref => {\n      if (!ref) return null;\n      if (typeof ref === \"string\") return ref;\n      if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n      if (ref.id) return ref.id;\n      return null;\n    };\n\n    partData.clientFromId = (_ref = (_getRefId = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientFrom)) !== null && _getRefId !== void 0 ? _getRefId : partData === null || partData === void 0 ? void 0 : partData.clientFromId) !== null && _ref !== void 0 ? _ref : null;\n    partData.clientCurrentId = (_ref2 = (_getRefId2 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientCurrent)) !== null && _getRefId2 !== void 0 ? _getRefId2 : partData === null || partData === void 0 ? void 0 : partData.clientCurrentId) !== null && _ref2 !== void 0 ? _ref2 : null; // console.log(partData);\n\n    const fetchMachineData = async ref => {\n      if (!ref) return null;\n\n      if (typeof ref.get === \"function\") {\n        const doc = await ref.get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (typeof ref === \"string\") {\n        const doc = await db.collection(\"Machine\").doc(ref).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (ref !== null && ref !== void 0 && ref.id) {\n        const doc = await db.collection(\"Machine\").doc(ref.id).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      return null;\n    };\n\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef = partData.CurrentMachine || partData.MachineCurrent;\n    const machineData = await fetchMachineData(machineRef);\n    partData.machineData = machineData || {};\n\n    if (machineData !== null && machineData !== void 0 && machineData.client) {\n      const clientRef = machineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (clientId && !partData.clientFromId) {\n        partData.clientFromId = clientId;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    const currentMachineData = await fetchMachineData(currentMachineRef);\n    partData.currentMachineData = currentMachineData || {};\n\n    if (currentMachineData !== null && currentMachineData !== void 0 && currentMachineData.client) {\n      const clientRef = currentMachineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (clientId && !partData.clientCurrentId) {\n        partData.clientCurrentId = clientId;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.currentMachineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    return partData;\n  }));\n  return parts;\n} // Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\n\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false,\n  filterFn = null,\n  needsMachineData = true,\n  search = null\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const getRefId = ref => {\n    if (!ref) return null;\n    if (typeof ref === \"string\") return ref;\n    if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n    if (ref.id) return ref.id;\n    return null;\n  };\n\n  const MACHINE_SELECT_FIELDS = [\"OEM\", \"Modality\", \"Model\", \"client\", \"name\"];\n\n  const withMachineSelect = query => typeof query.select === \"function\" ? query.select(...MACHINE_SELECT_FIELDS) : query;\n\n  const buildPart = (partDoc, machineMap, currentMachineMap) => {\n    var _ref3, _getRefId3, _ref4, _getRefId4;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    partData.clientFromId = (_ref3 = (_getRefId3 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientFrom)) !== null && _getRefId3 !== void 0 ? _getRefId3 : partData === null || partData === void 0 ? void 0 : partData.clientFromId) !== null && _ref3 !== void 0 ? _ref3 : null;\n    partData.clientCurrentId = (_ref4 = (_getRefId4 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientCurrent)) !== null && _getRefId4 !== void 0 ? _getRefId4 : partData === null || partData === void 0 ? void 0 : partData.clientCurrentId) !== null && _ref4 !== void 0 ? _ref4 : null;\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef = partData.CurrentMachine || partData.MachineCurrent;\n    const machineId = getRefId(machineRef);\n    const currentMachineId = getRefId(currentMachineRef);\n    const machineData = machineId ? machineMap[machineId] : null;\n    const currentMachineData = currentMachineId ? currentMachineMap[currentMachineId] : null;\n    partData.machineData = machineData || {};\n    partData.currentMachineData = currentMachineData || {};\n\n    if (!partData.clientFromId && machineData !== null && machineData !== void 0 && machineData.client) {\n      partData.clientFromId = getRefId(machineData.client);\n    }\n\n    if (!partData.clientCurrentId && currentMachineData !== null && currentMachineData !== void 0 && currentMachineData.client) {\n      partData.clientCurrentId = getRefId(currentMachineData.client);\n    }\n\n    return partData;\n  };\n\n  const searchRaw = ((search === null || search === void 0 ? void 0 : search.raw) || \"\").toString().trim();\n  const searchLower = ((search === null || search === void 0 ? void 0 : search.lower) || \"\").toString().trim();\n  const searchType = (search === null || search === void 0 ? void 0 : search.type) || null;\n  const hasSearch = Boolean(searchRaw);\n\n  const toTitleCase = text => text.split(\" \").filter(Boolean).map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(\" \");\n\n  const buildSearchQuery = () => {\n    if (!hasSearch || !searchType) return {\n      mode: \"scan\",\n      query: null\n    };\n    const col = db.collection(\"Test\");\n\n    switch (searchType) {\n      case \"SKU\":\n        return {\n          mode: \"sku\",\n          query: null\n        };\n\n      case \"Name\":\n        {\n          const titleFallback = searchRaw && searchRaw === searchRaw.toLowerCase() ? toTitleCase(searchRaw) : null;\n          const terms = searchLower ? searchLower.split(/\\s+/).filter(Boolean) : [];\n          const tokens = [...terms];\n          if (searchLower && !tokens.includes(searchLower)) tokens.push(searchLower);\n          if (!tokens.length) return {\n            mode: \"scan\",\n            query: null\n          };\n\n          const prefixQuery = value => col.orderBy(\"name\").startAt(value).endAt(`${value}\\uf8ff`);\n\n          return {\n            mode: \"query\",\n            query: tokens.length === 1 ? col.where(\"nameTokens\", \"array-contains\", tokens[0]) : col.where(\"nameTokens\", \"array-contains-any\", tokens.slice(0, 10)),\n            fallback: titleFallback ? () => prefixQuery(titleFallback) : () => prefixQuery(searchRaw)\n          };\n        }\n\n      case \"Product Number\":\n        return {\n          mode: \"query\",\n          query: col.where(\"pn\", \"array-contains\", searchRaw),\n          fallback: () => col.where(\"pn\", \"==\", searchRaw)\n        };\n\n      case \"Serial Number\":\n        return {\n          mode: \"query\",\n          query: col.where(\"sn\", \"array-contains\", searchRaw),\n          fallback: () => col.where(\"sn\", \"==\", searchRaw)\n        };\n\n      case \"Date\":\n        {\n          const asDate = (() => {\n            try {\n              const d = new Date(searchRaw);\n              return isNaN(d.getTime()) ? null : d;\n            } catch {\n              return null;\n            }\n          })();\n\n          return {\n            mode: \"query\",\n            query: col.where(\"date\", \"==\", searchRaw),\n            fallback: asDate ? () => col.where(\"date\", \"==\", asDate) : null\n          };\n        }\n\n      default:\n        return {\n          mode: \"scan\",\n          query: null\n        };\n    }\n  };\n\n  const {\n    mode: searchMode,\n    query: searchQuery,\n    fallback: searchFallback\n  } = buildSearchQuery();\n\n  if (searchMode === \"sku\" && hasSearch) {\n    const docs = [];\n    const rawUpper = searchRaw.toUpperCase();\n    let doc = await db.collection(\"Test\").doc(searchRaw).get();\n\n    if (!doc.exists && rawUpper !== searchRaw) {\n      doc = await db.collection(\"Test\").doc(rawUpper).get();\n    }\n\n    if (doc.exists) docs.push(doc);\n    const localValues = rawUpper !== searchRaw ? [searchRaw, rawUpper] : [searchRaw];\n    const localSnap = await db.collection(\"Test\").where(\"localSN\", \"in\", localValues).limit(limit).get();\n    localSnap.forEach(d => {\n      if (!docs.find(existing => existing.id === d.id)) {\n        docs.push(d);\n      }\n    });\n    let machineMap = {};\n    let currentMachineMap = {};\n\n    if (needsMachineData && docs.length) {\n      const machineIds = new Set();\n      const currentMachineIds = new Set();\n\n      for (const docSnap of docs) {\n        const raw = docSnap.data();\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\n        const currentMachineId = getRefId(raw.CurrentMachine || raw.MachineCurrent);\n        if (machineId) machineIds.add(machineId);\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\n      }\n\n      const fetchMachineMap = async ids => {\n        if (!ids.length) return {};\n        const out = {};\n        const chunks = [];\n\n        for (let i = 0; i < ids.length; i += 10) {\n          chunks.push(ids.slice(i, i + 10));\n        }\n\n        for (const chunk of chunks) {\n          const snap = await withMachineSelect(db.collection(\"Machine\").where(firebase.firestore.FieldPath.documentId(), \"in\", chunk)).get();\n          snap.forEach(docSnap => {\n            out[docSnap.id] = docSnap.data() || {};\n          });\n        }\n\n        return out;\n      };\n\n      [machineMap, currentMachineMap] = await Promise.all([fetchMachineMap([...machineIds]), fetchMachineMap([...currentMachineIds])]);\n    }\n\n    const built = docs.map(docSnap => buildPart(docSnap, machineMap, currentMachineMap)).filter(item => !visibleOnly || (item === null || item === void 0 ? void 0 : item.visible) !== false).filter(item => filterFn ? filterFn(item) : true).slice(0, pageSize);\n    return {\n      parts: built,\n      lastDoc: built.length ? docs[built.length - 1] : null,\n      hasNextPage: false\n    };\n  }\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let pageLastDoc = null;\n  let hasNextPage = false;\n  let filled = false;\n  let usedFallback = false;\n  const scanBaseQuery = db.collection(\"Test\").orderBy(firebase.firestore.FieldPath.documentId());\n\n  while (true) {\n    let query = searchQuery || scanBaseQuery;\n\n    if (searchMode === \"query\" && usedFallback && searchFallback) {\n      query = searchFallback();\n    }\n\n    if (cursor) query = query.startAfter(cursor);\n    query = query.limit(limit);\n    const snap = await query.get();\n\n    if (snap.empty) {\n      if (searchMode === \"query\" && searchFallback && !cursor && !usedFallback) {\n        usedFallback = true;\n        continue;\n      }\n\n      hasNextPage = false;\n      break;\n    }\n\n    const batchDocs = snap.docs;\n    let machineMap = {};\n    let currentMachineMap = {};\n\n    if (needsMachineData) {\n      const machineIds = new Set();\n      const currentMachineIds = new Set();\n\n      for (const doc of batchDocs) {\n        const raw = doc.data();\n\n        if (visibleOnly && raw.visible === false) {\n          continue;\n        }\n\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\n        const currentMachineId = getRefId(raw.CurrentMachine || raw.MachineCurrent);\n        if (machineId) machineIds.add(machineId);\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\n      }\n\n      const fetchMachineMap = async ids => {\n        if (!ids.length) return {};\n        const out = {};\n        const chunks = [];\n\n        for (let i = 0; i < ids.length; i += 10) {\n          chunks.push(ids.slice(i, i + 10));\n        }\n\n        for (const chunk of chunks) {\n          const snap = await withMachineSelect(db.collection(\"Machine\").where(firebase.firestore.FieldPath.documentId(), \"in\", chunk)).get();\n          snap.forEach(doc => {\n            out[doc.id] = doc.data() || {};\n          });\n        }\n\n        return out;\n      };\n\n      [machineMap, currentMachineMap] = await Promise.all([fetchMachineMap([...machineIds]), fetchMachineMap([...currentMachineIds])]);\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = batchDocs[i];\n      cursor = doc;\n      const raw = doc.data();\n\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      const built = buildPart(doc, machineMap, currentMachineMap);\n\n      if (filterFn && !filterFn(built)) {\n        continue;\n      }\n\n      if (!filled) {\n        parts.push(built);\n\n        if (parts.length === pageSize) {\n          filled = true;\n          pageLastDoc = doc;\n        }\n\n        continue;\n      } // We already filled the page and found an extra matching item.\n\n\n      hasNextPage = true;\n      return {\n        parts,\n        lastDoc: pageLastDoc,\n        hasNextPage\n      };\n    } // We exhausted this batch without filling the page.\n\n\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    } // There might be more docs; continue scanning for visible items.\n\n\n    hasNextPage = true;\n  }\n\n  lastDoc = pageLastDoc || (parts.length ? cursor : null);\n  return {\n    parts,\n    lastDoc,\n    hasNextPage: filled ? hasNextPage : false\n  };\n}\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map(doc => _objectSpread({\n    id: doc.id\n  }, doc.data())); // Filter clients based on OEM and Modality if selected\n\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n\n    for (const client of clients) {\n      let match = true;\n\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n\n          if (selectedOEM && machineData.OEM === selectedOEM || selectedModality && machineData.Modality === selectedModality) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n\n    return filteredClients;\n  }\n\n  return clients;\n}\nexport async function fetchModels(selectedOEM, selectedModality, selectedClient) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n  await Promise.all(machinesSnapshot.docs.map(async machineDoc => {\n    const machineData = machineDoc.data();\n    let isValid = true;\n    if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n    if (selectedModality && machineData.Modality !== selectedModality) isValid = false;\n\n    if (selectedClient && machineData.client) {\n      var _machineData$client;\n\n      let clientDoc = null;\n\n      if (typeof ((_machineData$client = machineData.client) === null || _machineData$client === void 0 ? void 0 : _machineData$client.get) === \"function\") {\n        clientDoc = await machineData.client.get();\n      } else if (typeof machineData.client === \"string\") {\n        clientDoc = await db.collection(\"Client\").doc(machineData.client).get();\n      }\n\n      if (!clientDoc || !clientDoc.exists) {\n        isValid = false;\n      } else {\n        const clientName = clientDoc.data().name;\n        const clientId = clientDoc.id;\n\n        if (selectedClient !== clientName && selectedClient !== clientId) {\n          isValid = false;\n        }\n      }\n    }\n\n    if (isValid) {\n      models.add(machineData.Model);\n    }\n  }));\n  return Array.from(models);\n}\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}","map":null,"metadata":{},"sourceType":"module"}