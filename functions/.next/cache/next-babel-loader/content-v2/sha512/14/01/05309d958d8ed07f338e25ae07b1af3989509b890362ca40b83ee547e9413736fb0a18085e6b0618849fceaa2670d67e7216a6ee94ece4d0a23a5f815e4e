{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  try {\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n\n    if (!token) {\n      return res.status(500).json({\n        ok: false,\n        error: \"missing_SLACK_BOT_TOKEN\"\n      });\n    } // Minimal payload we need for this pass\n\n\n    const {\n      listKey,\n      title,\n      pn,\n      sn\n    } = req.body || {};\n    const LIST_IDS = {\n      tasks: process.env.SLACK_LIST_TASKS_ID,\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\n      receiving: process.env.SLACK_LIST_RECEIVING_ID\n    };\n    const list_id = LIST_IDS[listKey];\n\n    if (!list_id) {\n      return res.status(400).json({\n        ok: false,\n        error: `unknown_listKey_${listKey}`\n      });\n    } // Optional env overrides for title column (use these if you know them)\n\n\n    const TITLE_COL_ENV = {\n      tasks: process.env.SLACK_LIST_TASKS_TITLE_COL,\n      shipping: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\n      receiving: process.env.SLACK_LIST_RECEIVING_TITLE_COL\n    }[listKey]; // ---- Slack helpers ----\n\n    async function slackJson(method, payload) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(payload)\n      });\n      return r.json();\n    }\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim(); // Correct rich_text (single object)\n\n\n    const toRichText = text => ({\n      type: \"rich_text\",\n      elements: [{\n        type: \"rich_text_section\",\n        elements: [{\n          type: \"text\",\n          text: plain(text)\n        }]\n      }]\n    });\n\n    const extractRTText = rt => {\n      try {\n        var _rt$elements$0$elemen, _rt$elements, _rt$elements$, _rt$elements$$element, _rt$elements$$element2;\n\n        return (_rt$elements$0$elemen = rt === null || rt === void 0 ? void 0 : (_rt$elements = rt.elements) === null || _rt$elements === void 0 ? void 0 : (_rt$elements$ = _rt$elements[0]) === null || _rt$elements$ === void 0 ? void 0 : (_rt$elements$$element = _rt$elements$.elements) === null || _rt$elements$$element === void 0 ? void 0 : (_rt$elements$$element2 = _rt$elements$$element[0]) === null || _rt$elements$$element2 === void 0 ? void 0 : _rt$elements$$element2.text) !== null && _rt$elements$0$elemen !== void 0 ? _rt$elements$0$elemen : \"\";\n      } catch {\n        return \"\";\n      }\n    }; // Probe list for existing items/fields\n\n\n    async function listProbe(listId) {\n      const probe = await slackJson(\"slackLists.items.list\", {\n        list_id: listId,\n        limit: 200\n      });\n      return probe !== null && probe !== void 0 && probe.ok ? probe : null;\n    } // Auto-detect a reasonable title column by sampling\n\n\n    async function resolveTitleColId(listId) {\n      const probe = await listProbe(listId);\n      if (!probe) return null;\n      let fallback = null;\n\n      for (const it of probe.items || []) {\n        for (const f of it.fields || []) {\n          if (!f.column_id) continue;\n          const key = (f.key || \"\").toLowerCase();\n          const hasText = !!f.text || !!f.rich_text; // treat rich_text as text-like\n\n          if (!hasText) continue;\n\n          if (key.includes(\"item\") || key.includes(\"task\") || key.includes(\"name\")) {\n            return f.column_id;\n          }\n\n          if (!fallback) fallback = f.column_id;\n        }\n      }\n\n      return fallback;\n    } // Try a list of candidate title columns until one works\n\n\n    async function createWithCandidates(candidateColIds, titleText) {\n      const safeTitle = plain(titleText) || \"New Item\";\n\n      for (const colId of candidateColIds.filter(Boolean)) {\n        var _r, _r2;\n\n        // 1) Try rich_text\n        let r = await slackJson(\"slackLists.items.create\", {\n          list_id,\n          initial_fields: [{\n            column_id: colId,\n            rich_text: toRichText(safeTitle)\n          }]\n        });\n        if ((_r = r) !== null && _r !== void 0 && _r.ok) return {\n          ok: true,\n          created: r,\n          used_col: colId,\n          mode: \"rich_text\"\n        }; // If Slack says invalid_arguments, retry with plain text\n\n        if (((_r2 = r) === null || _r2 === void 0 ? void 0 : _r2.error) === \"invalid_arguments\") {\n          var _r3;\n\n          r = await slackJson(\"slackLists.items.create\", {\n            list_id,\n            initial_fields: [{\n              column_id: colId,\n              text: safeTitle\n            }]\n          });\n          if ((_r3 = r) !== null && _r3 !== void 0 && _r3.ok) return {\n            ok: true,\n            created: r,\n            used_col: colId,\n            mode: \"text\"\n          };\n        }\n      }\n\n      return {\n        ok: false,\n        error: \"invalid_arguments_all_title_cols_failed\"\n      };\n    } // Build candidate list for the title column:\n    // 1) explicit env override (if provided),\n    // 2) auto-detected title-like column,\n    // 3) any text-like fallback from the probe (resolveTitleColId already returns fallback).\n\n\n    const autoTitleCol = await resolveTitleColId(list_id);\n    const candidates = [TITLE_COL_ENV, autoTitleCol].filter(Boolean); // Create the item (robust)\n\n    const createdTry = await createWithCandidates(candidates, title);\n\n    if (!createdTry.ok) {\n      return res.status(200).json({\n        ok: false,\n        error: \"invalid_arguments\",\n        mode: \"list\",\n        hint: \"title_create_failed\",\n        tried_columns: candidates,\n        sent_title: plain(title) || \"New Item\"\n      });\n    }\n\n    const created = createdTry.created;\n    const titleColId = createdTry.used_col; // ----- PN/SN update (rich_text → text fallback) -----\n\n    const pn0 = Array.isArray(pn) ? pn[0] : pn;\n    const sn0 = Array.isArray(sn) ? sn[0] : sn;\n    const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n    const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n    const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \"); // Find a PN/SN-ish column by sampling values/keys\n\n    async function resolvePnSnColId(listId) {\n      const probe = await listProbe(listId);\n      if (!probe) return null;\n      let candidate = null;\n\n      for (const it of probe.items || []) {\n        for (const f of it.fields || []) {\n          if (!f.column_id) continue;\n          const key = (f.key || \"\").toLowerCase();\n          const text = (f.text || extractRTText(f.rich_text) || \"\").toLowerCase();\n          const looks = key.includes(\"pn\") || key.includes(\"sn\") || text.includes(\"pn:\") || text.includes(\"sn:\");\n          if (looks) return f.column_id;\n\n          if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n            candidate = f.column_id;\n          }\n        }\n      }\n\n      return candidate;\n    }\n\n    let usedPnSnCol = null;\n\n    if (pnSnText) {\n      const pnSnColId = await resolvePnSnColId(list_id);\n\n      if (pnSnColId) {\n        var _r4, _r5;\n\n        // Try rich_text\n        let r = await slackJson(\"slackLists.items.update\", {\n          list_id,\n          cells: [{\n            row_id: created.item.id,\n            column_id: pnSnColId,\n            rich_text: toRichText(pnSnText)\n          }]\n        });\n\n        if (!((_r4 = r) !== null && _r4 !== void 0 && _r4.ok)) {\n          // Fallback to plain text\n          r = await slackJson(\"slackLists.items.update\", {\n            list_id,\n            cells: [{\n              row_id: created.item.id,\n              column_id: pnSnColId,\n              text: pnSnText\n            }]\n          });\n        }\n\n        if (!((_r5 = r) !== null && _r5 !== void 0 && _r5.ok)) {\n          var _r6;\n\n          // As last resort, append PN/SN to title so the row remains useful\n          await slackJson(\"slackLists.items.update\", {\n            list_id,\n            cells: [{\n              row_id: created.item.id,\n              column_id: titleColId,\n              text: `${plain(title) || \"New Item\"} — ${pnSnText}`\n            }]\n          });\n          return res.status(200).json({\n            ok: false,\n            error: ((_r6 = r) === null || _r6 === void 0 ? void 0 : _r6.error) || \"update_failed\",\n            mode: \"list\",\n            list_id,\n            item_id: created.item.id,\n            used_title_col: titleColId\n          });\n        }\n\n        usedPnSnCol = pnSnColId;\n      }\n    }\n\n    return res.status(200).json({\n      ok: true,\n      mode: \"list\",\n      list_id,\n      item_id: created.item.id,\n      used_title_col: titleColId,\n      used_pnsn_col: usedPnSnCol || null,\n      title_mode: createdTry.mode // whether Slack accepted rich_text or text for title\n\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn","sn","body","LIST_IDS","tasks","SLACK_LIST_TASKS_ID","shipping","SLACK_LIST_SHIPPING_ID","receiving","SLACK_LIST_RECEIVING_ID","list_id","TITLE_COL_ENV","SLACK_LIST_TASKS_TITLE_COL","SLACK_LIST_SHIPPING_TITLE_COL","SLACK_LIST_RECEIVING_TITLE_COL","slackJson","payload","r","fetch","headers","Authorization","JSON","stringify","plain","v","toString","trim","toRichText","text","type","elements","extractRTText","rt","listProbe","listId","probe","limit","resolveTitleColId","fallback","it","items","f","fields","column_id","key","toLowerCase","hasText","rich_text","includes","createWithCandidates","candidateColIds","titleText","safeTitle","colId","filter","Boolean","initial_fields","created","used_col","mode","autoTitleCol","candidates","createdTry","hint","tried_columns","sent_title","titleColId","pn0","Array","isArray","sn0","pnPart","snPart","pnSnText","join","resolvePnSnColId","candidate","looks","usedPnSnCol","pnSnColId","cells","row_id","item","id","item_id","used_title_col","used_pnsn_col","title_mode","err","console","message","String"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAI;AACF,QAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,aAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAArB,CAAP;AACD;;AAED,UAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;;AACA,QAAI,CAACH,KAAL,EAAY;AACV,aAAON,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,E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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   try {\r\n//     if (req.method !== \"POST\") {\r\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//     }\r\n\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) {\r\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//     }\r\n\r\n//     // payload from client\r\n//     const {\r\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n//       title,               // item title (what shows in the primary column)\r\n//       // keeping minimal per your request: PN/SN only for now\r\n//       pn, sn,\r\n//     } = req.body || {};\r\n\r\n//     // list ids from env\r\n//     const LIST_IDS = {\r\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\r\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n//     };\r\n\r\n//     const list_id = LIST_IDS[listKey];\r\n//     if (!list_id) {\r\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n//     }\r\n\r\n//     // ---- Slack helpers ----\r\n//     async function slackJson(method, payload) {\r\n//       const r = await fetch(`https://slack.com/api/${method}`, {\r\n//         method: \"POST\",\r\n//         headers: {\r\n//           Authorization: `Bearer ${token}`,\r\n//           \"Content-Type\": \"application/json; charset=utf-8\",\r\n//         },\r\n//         body: JSON.stringify(payload),\r\n//       });\r\n//       return r.json();\r\n//     }\r\n\r\n//     const plain = (v) => (v ?? \"\").toString().trim();\r\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     function toRichText(text) {\r\n//       const t = plain(text);\r\n//       return [{\r\n//         type: \"rich_text\",\r\n//         elements: [{\r\n//           type: \"rich_text_section\",\r\n//           elements: [{ type: \"text\", text: t }],\r\n//         }],\r\n//       }];\r\n//     }\r\n\r\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n//     async function resolveTitleColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n//       let fallback = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\r\n//           if (f.column_id && hasText) {\r\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n//             if (!fallback) fallback = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return fallback; // first text-like field if we didn't find a perfect match\r\n//     }\r\n\r\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n//     async function resolvePnSnColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       let candidate = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           if (!f.column_id) continue;\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const text = (f.text || \"\").toLowerCase();\r\n\r\n//           const looksPnSn =\r\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\r\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n//           if (looksPnSn) return f.column_id;\r\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n//             candidate = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return candidate;\r\n//     }\r\n\r\n//     // 1) Resolve columns\r\n//     const titleColId = await resolveTitleColId(list_id);\r\n//     if (!titleColId) {\r\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n//     }\r\n\r\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n//     const safeTitle = plain(title) || \"New Item\";\r\n//     const createBody = {\r\n//       list_id,\r\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n//     };\r\n\r\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 3) (Minimal) update: PN/SN only, per your request\r\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n//     let updated = null;\r\n//     let usedPnSnCol = null;\r\n\r\n//     if (pnSnText) {\r\n//       const pnSnColId = await resolvePnSnColId(list_id);\r\n//       if (pnSnColId) {\r\n//         const cells = [{\r\n//           row_id: created.item.id,\r\n//           column_id: pnSnColId,\r\n//           rich_text: toRichText(pnSnText),\r\n//         }];\r\n\r\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n//         usedPnSnCol = pnSnColId;\r\n//         // If update fails, we still return ok:false so you can see the error\r\n//         if (!updated?.ok) {\r\n//           return res.status(200).json({\r\n//             ok: false,\r\n//             error: updated?.error || \"update_failed\",\r\n//             mode: \"list\",\r\n//             list_id,\r\n//             item_id: created.item.id,\r\n//             used_title_col: titleColId,\r\n//             used_pnsn_col: usedPnSnCol,\r\n//           });\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleColId,\r\n//       used_pnsn_col: usedPnSnCol || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) {\r\n      return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n    }\r\n\r\n    // Minimal payload we need for this pass\r\n    const { listKey, title, pn, sn } = req.body || {};\r\n\r\n    const LIST_IDS = {\r\n      tasks: process.env.SLACK_LIST_TASKS_ID,\r\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n      receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n    };\r\n    const list_id = LIST_IDS[listKey];\r\n    if (!list_id) {\r\n      return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n    }\r\n\r\n    // Optional env overrides for title column (use these if you know them)\r\n    const TITLE_COL_ENV = {\r\n      tasks: process.env.SLACK_LIST_TASKS_TITLE_COL,\r\n      shipping: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\r\n      receiving: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\r\n    }[listKey];\r\n\r\n    // ---- Slack helpers ----\r\n    async function slackJson(method, payload) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          Authorization: `Bearer ${token}`,\r\n          \"Content-Type\": \"application/json; charset=utf-8\",\r\n        },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      return r.json();\r\n    }\r\n\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n\r\n    // Correct rich_text (single object)\r\n    const toRichText = (text) => ({\r\n      type: \"rich_text\",\r\n      elements: [\r\n        {\r\n          type: \"rich_text_section\",\r\n          elements: [{ type: \"text\", text: plain(text) }],\r\n        },\r\n      ],\r\n    });\r\n\r\n    const extractRTText = (rt) => {\r\n      try { return rt?.elements?.[0]?.elements?.[0]?.text ?? \"\"; } catch { return \"\"; }\r\n    };\r\n\r\n    // Probe list for existing items/fields\r\n    async function listProbe(listId) {\r\n      const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 200 });\r\n      return probe?.ok ? probe : null;\r\n    }\r\n\r\n    // Auto-detect a reasonable title column by sampling\r\n    async function resolveTitleColId(listId) {\r\n      const probe = await listProbe(listId);\r\n      if (!probe) return null;\r\n\r\n      let fallback = null;\r\n      for (const it of probe.items || []) {\r\n        for (const f of it.fields || []) {\r\n          if (!f.column_id) continue;\r\n          const key = (f.key || \"\").toLowerCase();\r\n          const hasText = !!f.text || !!f.rich_text; // treat rich_text as text-like\r\n          if (!hasText) continue;\r\n\r\n          if (key.includes(\"item\") || key.includes(\"task\") || key.includes(\"name\")) {\r\n            return f.column_id;\r\n          }\r\n          if (!fallback) fallback = f.column_id;\r\n        }\r\n      }\r\n      return fallback;\r\n    }\r\n\r\n    // Try a list of candidate title columns until one works\r\n    async function createWithCandidates(candidateColIds, titleText) {\r\n      const safeTitle = plain(titleText) || \"New Item\";\r\n\r\n      for (const colId of candidateColIds.filter(Boolean)) {\r\n        // 1) Try rich_text\r\n        let r = await slackJson(\"slackLists.items.create\", {\r\n          list_id,\r\n          initial_fields: [{ column_id: colId, rich_text: toRichText(safeTitle) }],\r\n        });\r\n        if (r?.ok) return { ok: true, created: r, used_col: colId, mode: \"rich_text\" };\r\n\r\n        // If Slack says invalid_arguments, retry with plain text\r\n        if (r?.error === \"invalid_arguments\") {\r\n          r = await slackJson(\"slackLists.items.create\", {\r\n            list_id,\r\n            initial_fields: [{ column_id: colId, text: safeTitle }],\r\n          });\r\n          if (r?.ok) return { ok: true, created: r, used_col: colId, mode: \"text\" };\r\n        }\r\n      }\r\n      return { ok: false, error: \"invalid_arguments_all_title_cols_failed\" };\r\n    }\r\n\r\n    // Build candidate list for the title column:\r\n    // 1) explicit env override (if provided),\r\n    // 2) auto-detected title-like column,\r\n    // 3) any text-like fallback from the probe (resolveTitleColId already returns fallback).\r\n    const autoTitleCol = await resolveTitleColId(list_id);\r\n    const candidates = [TITLE_COL_ENV, autoTitleCol].filter(Boolean);\r\n\r\n    // Create the item (robust)\r\n    const createdTry = await createWithCandidates(candidates, title);\r\n    if (!createdTry.ok) {\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: \"invalid_arguments\",\r\n        mode: \"list\",\r\n        hint: \"title_create_failed\",\r\n        tried_columns: candidates,\r\n        sent_title: plain(title) || \"New Item\",\r\n      });\r\n    }\r\n    const created = createdTry.created;\r\n    const titleColId = createdTry.used_col;\r\n\r\n    // ----- PN/SN update (rich_text → text fallback) -----\r\n    const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n    const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n    const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n    const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n    const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n    // Find a PN/SN-ish column by sampling values/keys\r\n    async function resolvePnSnColId(listId) {\r\n      const probe = await listProbe(listId);\r\n      if (!probe) return null;\r\n\r\n      let candidate = null;\r\n      for (const it of probe.items || []) {\r\n        for (const f of it.fields || []) {\r\n          if (!f.column_id) continue;\r\n          const key = (f.key || \"\").toLowerCase();\r\n          const text = (f.text || extractRTText(f.rich_text) || \"\").toLowerCase();\r\n\r\n          const looks =\r\n            key.includes(\"pn\") || key.includes(\"sn\") ||\r\n            text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n          if (looks) return f.column_id;\r\n          if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n            candidate = f.column_id;\r\n          }\r\n        }\r\n      }\r\n      return candidate;\r\n    }\r\n\r\n    let usedPnSnCol = null;\r\n    if (pnSnText) {\r\n      const pnSnColId = await resolvePnSnColId(list_id);\r\n      if (pnSnColId) {\r\n        // Try rich_text\r\n        let r = await slackJson(\"slackLists.items.update\", {\r\n          list_id,\r\n          cells: [{\r\n            row_id: created.item.id,\r\n            column_id: pnSnColId,\r\n            rich_text: toRichText(pnSnText),\r\n          }],\r\n        });\r\n        if (!r?.ok) {\r\n          // Fallback to plain text\r\n          r = await slackJson(\"slackLists.items.update\", {\r\n            list_id,\r\n            cells: [{\r\n              row_id: created.item.id,\r\n              column_id: pnSnColId,\r\n              text: pnSnText,\r\n            }],\r\n          });\r\n        }\r\n\r\n        if (!r?.ok) {\r\n          // As last resort, append PN/SN to title so the row remains useful\r\n          await slackJson(\"slackLists.items.update\", {\r\n            list_id,\r\n            cells: [{\r\n              row_id: created.item.id,\r\n              column_id: titleColId,\r\n              text: `${plain(title) || \"New Item\"} — ${pnSnText}`,\r\n            }],\r\n          });\r\n          return res.status(200).json({\r\n            ok: false,\r\n            error: r?.error || \"update_failed\",\r\n            mode: \"list\",\r\n            list_id,\r\n            item_id: created.item.id,\r\n            used_title_col: titleColId,\r\n          });\r\n        }\r\n        usedPnSnCol = pnSnColId;\r\n      }\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      mode: \"list\",\r\n      list_id,\r\n      item_id: created.item.id,\r\n      used_title_col: titleColId,\r\n      used_pnsn_col: usedPnSnCol || null,\r\n      title_mode: createdTry.mode, // whether Slack accepted rich_text or text for title\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}