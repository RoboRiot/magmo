{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\n// Optional .env.local loader that won't explode if dotenv isn't installed\n(function ensureEnv() {\n  if (!process.env.SLACK_BOT_TOKEN) {\n    try {\n      const _req = eval(\"require\"); // avoid bundler resolution\n\n\n      const path = _req(\"path\");\n\n      _req(\"dotenv\").config({\n        path: path.join(process.cwd(), \".env.local\")\n      });\n    } catch (_) {\n      /* ignore */\n    }\n  }\n})();\n\nexport default async function handler(req, res) {\n  const respond = (code, json) => {\n    if (!res.headersSent) return res.status(code).json(json);\n  };\n\n  try {\n    var _createdTry, _createdTry$created, _createdTry$created$i, _updated3, _updated4;\n\n    if (req.method !== \"POST\") {\n      return respond(405, {\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n\n    if (!token) {\n      return respond(500, {\n        ok: false,\n        error: \"missing_SLACK_BOT_TOKEN\"\n      });\n    } // ===== body built from the item on the client =====\n\n\n    const {\n      listKey,\n      title,\n      pn,\n      sn,\n      workOrder,\n      localSN,\n      tracking,\n      shippingDate,\n      description,\n      linkUrl,\n      photoUrls = []\n    } = req.body || {}; // ===== per-list env config =====\n\n    const cfgMap = {\n      tasks: {\n        list_id: process.env.SLACK_LIST_TASKS_ID,\n        title_col: process.env.SLACK_LIST_TASKS_TITLE_COL,\n        description_col: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL\n      },\n      shipping: {\n        list_id: process.env.SLACK_LIST_SHIPPING_ID,\n        title_col: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\n        description_col: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n        date_col: process.env.SLACK_LIST_SHIPPING_DATE_COL,\n        pnsn_col: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n        tracking_col: process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n        wo_col: process.env.SLACK_LIST_SHIPPING_WO_COL,\n        localsn_col: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n        photos_col: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL\n      },\n      receiving: {\n        list_id: process.env.SLACK_LIST_RECEIVING_ID,\n        title_col: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\n        description_col: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n        date_col: process.env.SLACK_LIST_RECEIVING_DATE_COL,\n        pnsn_col: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n        tracking_col: process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n        wo_col: process.env.SLACK_LIST_RECEIVING_WO_COL,\n        localsn_col: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n        photos_col: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL\n      }\n    };\n    const cfg = cfgMap[listKey || \"\"];\n\n    if (!(cfg !== null && cfg !== void 0 && cfg.list_id)) {\n      return respond(400, {\n        ok: false,\n        error: `unknown_listKey_${listKey}`\n      });\n    } // ===== slack helpers =====\n\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const first = x => Array.isArray(x) ? x.find(Boolean) || \"\" : plain(x);\n\n    const toRT = text => ({\n      type: \"rich_text\",\n      elements: [{\n        type: \"rich_text_section\",\n        elements: [{\n          type: \"text\",\n          text: plain(text)\n        }]\n      }]\n    });\n\n    async function slackJson(method, body) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(body)\n      });\n      return r.json();\n    } // List out columns (more reliable than scanning items when a list is empty)\n\n\n    async function listColumns(list_id) {\n      const r = await slackJson(\"slackLists.columns.list\", {\n        list_id\n      });\n      return r !== null && r !== void 0 && r.ok ? r.columns || [] : [];\n    } // Fallback: sniff columns from existing rows\n\n\n    async function sniffColumnsFromItems(list_id) {\n      const r = await slackJson(\"slackLists.items.list\", {\n        list_id,\n        limit: 200\n      });\n      if (!(r !== null && r !== void 0 && r.ok)) return [];\n      const map = new Map();\n\n      for (const it of r.items || []) {\n        for (const f of it.fields || []) {\n          if (f !== null && f !== void 0 && f.column_id) map.set(f.column_id, {\n            column_id: f.column_id,\n            key: f.key,\n            kind: \"field\"\n          });\n        }\n      }\n\n      return [...map.values()];\n    }\n\n    function looksTextLike(col) {\n      const key = (col.key || \"\").toLowerCase();\n      const type = (col.type || \"\").toLowerCase(); // heuristics: Slack uses \"text\", \"rich_text\", sometimes type omitted in items sniff\n\n      return type.includes(\"text\") || key.includes(\"item\") || key.includes(\"task\") || key.includes(\"name\") || key.includes(\"title\");\n    }\n\n    async function candidateTitleColumns(list_id, envTitleCol) {\n      const cols = await listColumns(list_id);\n      let candidates = [];\n\n      if (envTitleCol) {\n        candidates.push(envTitleCol);\n      } // text-like first\n\n\n      candidates = candidates.concat(cols.filter(looksTextLike).map(c => c.column_id)); // any other column ids as last resort\n\n      candidates = candidates.concat(cols.map(c => c.column_id)); // if columns API is unavailable/empty, sniff from items\n\n      if (!cols.length) {\n        const sniff = await sniffColumnsFromItems(list_id);\n        const texty = sniff.filter(looksTextLike).map(c => c.column_id);\n        const any = sniff.map(c => c.column_id);\n        candidates = candidates.concat(texty).concat(any);\n      } // dedupe, keep order\n\n\n      return [...new Set(candidates.filter(Boolean))];\n    }\n\n    async function tryCreateWithColumn(list_id, colId, textValue) {\n      var _r, _r2, _r3;\n\n      const safe = plain(textValue) || \"New Item\"; // rich_text first\n\n      let r = await slackJson(\"slackLists.items.create\", {\n        list_id,\n        initial_fields: [{\n          column_id: colId,\n          rich_text: toRT(safe)\n        }]\n      });\n      if ((_r = r) !== null && _r !== void 0 && _r.ok) return {\n        ok: true,\n        created: r,\n        colId,\n        mode: \"rich_text\"\n      }; // plain text fallback\n\n      r = await slackJson(\"slackLists.items.create\", {\n        list_id,\n        initial_fields: [{\n          column_id: colId,\n          text: safe\n        }]\n      });\n      if ((_r2 = r) !== null && _r2 !== void 0 && _r2.ok) return {\n        ok: true,\n        created: r,\n        colId,\n        mode: \"text\"\n      };\n      return {\n        ok: false,\n        error: ((_r3 = r) === null || _r3 === void 0 ? void 0 : _r3.error) || \"invalid_arguments\",\n        last: r,\n        colId\n      };\n    } // ===== figure out the title column and create the row =====\n\n\n    const linkSuffix = linkUrl ? ` — ${linkUrl}` : \"\";\n    const titleForCreate = plain(title) || (localSN ? `Item (${localSN})` : \"New Item\");\n    const candidates = await candidateTitleColumns(cfg.list_id, cfg.title_col);\n    let createdTry = null;\n\n    for (const col of candidates) {\n      createdTry = await tryCreateWithColumn(cfg.list_id, col, titleForCreate + (!cfg.description_col ? linkSuffix : \"\"));\n\n      if (createdTry.ok) {\n        // lock in the col we actually used\n        cfg.title_col = col;\n        break;\n      }\n    }\n\n    if (!((_createdTry = createdTry) !== null && _createdTry !== void 0 && _createdTry.ok)) {\n      var _createdTry2, _createdTry3;\n\n      return respond(200, {\n        ok: false,\n        error: \"title_create_failed\",\n        detail: ((_createdTry2 = createdTry) === null || _createdTry2 === void 0 ? void 0 : _createdTry2.error) || \"invalid_arguments\",\n        tried_columns: candidates,\n        last_response: ((_createdTry3 = createdTry) === null || _createdTry3 === void 0 ? void 0 : _createdTry3.last) || null,\n        list_id: cfg.list_id,\n        sent_title: titleForCreate\n      });\n    }\n\n    const itemId = (_createdTry$created = createdTry.created) === null || _createdTry$created === void 0 ? void 0 : (_createdTry$created$i = _createdTry$created.item) === null || _createdTry$created$i === void 0 ? void 0 : _createdTry$created$i.id; // ===== build cells from item data =====\n\n    const pn0 = first(pn);\n    const sn0 = first(sn);\n    const pnSnText = [pn0 && `PN: ${pn0}`, sn0 && `SN: ${sn0}`].filter(Boolean).join(\"\\n\");\n    const cellsRT = [];\n\n    const pushRT = (colId, v) => {\n      const t = plain(v);\n      if (colId && t) cellsRT.push({\n        row_id: itemId,\n        column_id: colId,\n        rich_text: toRT(t)\n      });\n    };\n\n    const pushTX = (colId, v) => {\n      const t = plain(v);\n      if (colId && t) cellsRT.push({\n        row_id: itemId,\n        column_id: colId,\n        text: t\n      });\n    };\n\n    if (cfg.description_col) {\n      const descWithLink = description && linkUrl ? `${description}\\nLink: ${linkUrl}` : description || (linkUrl ? `Link: ${linkUrl}` : \"\");\n      pushRT(cfg.description_col, descWithLink);\n    }\n\n    if (cfg.pnsn_col && pnSnText) pushRT(cfg.pnsn_col, pnSnText);\n    if (cfg.wo_col && workOrder) pushRT(cfg.wo_col, workOrder);\n    if (cfg.localsn_col && localSN) pushRT(cfg.localsn_col, localSN);\n    if (cfg.tracking_col && tracking) pushRT(cfg.tracking_col, tracking);\n    if (cfg.date_col && shippingDate) pushRT(cfg.date_col, shippingDate);\n\n    if (cfg.photos_col && photoUrls !== null && photoUrls !== void 0 && photoUrls.length) {\n      const block = photoUrls.map(plain).filter(Boolean).join(\"\\n\");\n      if (block) pushTX(cfg.photos_col, block);\n    }\n\n    let updated = null;\n\n    if (cellsRT.length) {\n      var _updated, _updated2;\n\n      updated = await slackJson(\"slackLists.items.update\", {\n        list_id: cfg.list_id,\n        cells: cellsRT\n      });\n\n      if (!((_updated = updated) !== null && _updated !== void 0 && _updated.ok) && ((_updated2 = updated) === null || _updated2 === void 0 ? void 0 : _updated2.error) === \"invalid_arguments\") {\n        // retry all as plain text\n        const cellsText = cellsRT.map(c => {\n          var _c$text, _c$rich_text, _c$rich_text$elements, _c$rich_text$elements2, _c$rich_text$elements3, _c$rich_text$elements4;\n\n          return {\n            row_id: c.row_id,\n            column_id: c.column_id,\n            text: (_c$text = c.text) !== null && _c$text !== void 0 ? _c$text : ((_c$rich_text = c.rich_text) === null || _c$rich_text === void 0 ? void 0 : (_c$rich_text$elements = _c$rich_text.elements) === null || _c$rich_text$elements === void 0 ? void 0 : (_c$rich_text$elements2 = _c$rich_text$elements[0]) === null || _c$rich_text$elements2 === void 0 ? void 0 : (_c$rich_text$elements3 = _c$rich_text$elements2.elements) === null || _c$rich_text$elements3 === void 0 ? void 0 : (_c$rich_text$elements4 = _c$rich_text$elements3[0]) === null || _c$rich_text$elements4 === void 0 ? void 0 : _c$rich_text$elements4.text) || \"\"\n          };\n        });\n        updated = await slackJson(\"slackLists.items.update\", {\n          list_id: cfg.list_id,\n          cells: cellsText\n        });\n      }\n    }\n\n    return respond(200, {\n      ok: true,\n      mode: \"list\",\n      list_id: cfg.list_id,\n      item_id: itemId,\n      used_title_col: cfg.title_col,\n      used_columns: Object.fromEntries(Object.entries(cfg).filter(([k, v]) => k.endsWith(\"_col\") && v)),\n      title_mode: createdTry.mode,\n      // \"rich_text\" or \"text\"\n      update_ok: updated ? !!updated.ok : true,\n      update_error: (_updated3 = updated) !== null && _updated3 !== void 0 && _updated3.ok ? null : ((_updated4 = updated) === null || _updated4 === void 0 ? void 0 : _updated4.error) || null\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return respond(500, {\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["ensureEnv","process","env","SLACK_BOT_TOKEN","_req","eval","path","config","join","cwd","_","handler","req","res","respond","code","json","headersSent","status","method","ok","error","token","listKey","title","pn","sn","workOrder","localSN","tracking","shippingDate","description","linkUrl","photoUrls","body","cfgMap","tasks","list_id","SLACK_LIST_TASKS_ID","title_col","SLACK_LIST_TASKS_TITLE_COL","description_col","SLACK_LIST_TASKS_DESCRIPTION_COL","shipping","SLACK_LIST_SHIPPING_ID","SLACK_LIST_SHIPPING_TITLE_COL","SLACK_LIST_SHIPPING_DESCRIPTION_COL","date_col","SLACK_LIST_SHIPPING_DATE_COL","pnsn_col","SLACK_LIST_SHIPPING_PNSN_COL","tracking_col","SLACK_LIST_SHIPPING_TRACKING_COL","wo_col","SLACK_LIST_SHIPPING_WO_COL","localsn_col","SLACK_LIST_SHIPPING_LOCALSN_COL","photos_col","SLACK_LIST_SHIPPING_PHOTOS_COL","receiving","SLACK_LIST_RECEIVING_ID","SLACK_LIST_RECEIVING_TITLE_COL","SLACK_LIST_RECEIVING_DESCRIPTION_COL","SLACK_LIST_RECEIVING_DATE_COL","SLACK_LIST_RECEIVING_PNSN_COL","SLACK_LIST_RECEIVING_TRACKING_COL","SLACK_LIST_RECEIVING_WO_COL","SLACK_LIST_RECEIVING_LOCALSN_COL","SLACK_LIST_RECEIVING_PHOTOS_COL","cfg","plain","v","toString","trim","first","x","Array","isArray","find","Boolean","toRT","text","type","elements","slackJson","r","fetch","headers","Authorization","JSON","stringify","listColumns","columns","sniffColumnsFromItems","limit","map","Map","it","items","f","fields","column_id","set","key","kind","values","looksTextLike","col","toLowerCase","includes","candidateTitleColumns","envTitleCol","cols","candidates","push","concat","filter","c","length","sniff","texty","any","Set","tryCreateWithColumn","colId","textValue","safe","initial_fields","rich_text","created","mode","last","linkSuffix","titleForCreate","createdTry","detail","tried_columns","last_response","sent_title","itemId","item","id","pn0","sn0","pnSnText","cellsRT","pushRT","t","row_id","pushTX","descWithLink","block","updated","cells","cellsText","item_id","used_title_col","used_columns","Object","fromEntries","entries","k","endsWith","title_mode","update_ok","update_error","err","console","message","String"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA,CAAC,SAASA,SAAT,GAAqB;AACpB,MAAI,CAACC,OAAO,CAACC,GAAR,CAAYC,eAAjB,EAAkC;AAChC,QAAI;AACF,YAAMC,IAAI,GAAGC,IAAI,CAAC,SAAD,CAAjB,CADE,CAC4B;;;AAC9B,YAAMC,IAAI,GAAGF,IAAI,CAAC,MAAD,CAAjB;;AACAA,MAAAA,IAAI,CAAC,QAAD,CAAJ,CAAeG,MAAf,CAAsB;AAAED,QAAAA,IAAI,EAAEA,IAAI,CAACE,IAAL,CAAUP,OAAO,CAACQ,GAAR,EAAV,EAAyB,YAAzB;AAAR,OAAtB;AACD,KAJD,CAIE,OAAOC,CAAP,EAAU;AAAE;AAAc;AAC7B;AACF,CARD;;AAUA,eAAe,eAAeC,OAAf,CAA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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   try {\r\n//     if (req.method !== \"POST\") {\r\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//     }\r\n\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) {\r\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//     }\r\n\r\n//     // payload from client\r\n//     const {\r\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n//       title,               // item title (what shows in the primary column)\r\n//       // keeping minimal per your request: PN/SN only for now\r\n//       pn, sn,\r\n//     } = req.body || {};\r\n\r\n//     // list ids from env\r\n//     const LIST_IDS = {\r\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\r\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n//     };\r\n\r\n//     const list_id = LIST_IDS[listKey];\r\n//     if (!list_id) {\r\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n//     }\r\n\r\n//     // ---- Slack helpers ----\r\n//     async function slackJson(method, payload) {\r\n//       const r = await fetch(`https://slack.com/api/${method}`, {\r\n//         method: \"POST\",\r\n//         headers: {\r\n//           Authorization: `Bearer ${token}`,\r\n//           \"Content-Type\": \"application/json; charset=utf-8\",\r\n//         },\r\n//         body: JSON.stringify(payload),\r\n//       });\r\n//       return r.json();\r\n//     }\r\n\r\n//     const plain = (v) => (v ?? \"\").toString().trim();\r\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     function toRichText(text) {\r\n//       const t = plain(text);\r\n//       return [{\r\n//         type: \"rich_text\",\r\n//         elements: [{\r\n//           type: \"rich_text_section\",\r\n//           elements: [{ type: \"text\", text: t }],\r\n//         }],\r\n//       }];\r\n//     }\r\n\r\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n//     async function resolveTitleColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n//       let fallback = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\r\n//           if (f.column_id && hasText) {\r\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n//             if (!fallback) fallback = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return fallback; // first text-like field if we didn't find a perfect match\r\n//     }\r\n\r\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n//     async function resolvePnSnColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       let candidate = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           if (!f.column_id) continue;\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const text = (f.text || \"\").toLowerCase();\r\n\r\n//           const looksPnSn =\r\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\r\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n//           if (looksPnSn) return f.column_id;\r\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n//             candidate = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return candidate;\r\n//     }\r\n\r\n//     // 1) Resolve columns\r\n//     const titleColId = await resolveTitleColId(list_id);\r\n//     if (!titleColId) {\r\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n//     }\r\n\r\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n//     const safeTitle = plain(title) || \"New Item\";\r\n//     const createBody = {\r\n//       list_id,\r\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n//     };\r\n\r\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 3) (Minimal) update: PN/SN only, per your request\r\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n//     let updated = null;\r\n//     let usedPnSnCol = null;\r\n\r\n//     if (pnSnText) {\r\n//       const pnSnColId = await resolvePnSnColId(list_id);\r\n//       if (pnSnColId) {\r\n//         const cells = [{\r\n//           row_id: created.item.id,\r\n//           column_id: pnSnColId,\r\n//           rich_text: toRichText(pnSnText),\r\n//         }];\r\n\r\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n//         usedPnSnCol = pnSnColId;\r\n//         // If update fails, we still return ok:false so you can see the error\r\n//         if (!updated?.ok) {\r\n//           return res.status(200).json({\r\n//             ok: false,\r\n//             error: updated?.error || \"update_failed\",\r\n//             mode: \"list\",\r\n//             list_id,\r\n//             item_id: created.item.id,\r\n//             used_title_col: titleColId,\r\n//             used_pnsn_col: usedPnSnCol,\r\n//           });\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleColId,\r\n//       used_pnsn_col: usedPnSnCol || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\n\r\n// Optional .env.local loader that won't explode if dotenv isn't installed\r\n(function ensureEnv() {\r\n  if (!process.env.SLACK_BOT_TOKEN) {\r\n    try {\r\n      const _req = eval(\"require\"); // avoid bundler resolution\r\n      const path = _req(\"path\");\r\n      _req(\"dotenv\").config({ path: path.join(process.cwd(), \".env.local\") });\r\n    } catch (_) { /* ignore */ }\r\n  }\r\n})();\r\n\r\nexport default async function handler(req, res) {\r\n  const respond = (code, json) => {\r\n    if (!res.headersSent) return res.status(code).json(json);\r\n  };\r\n\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return respond(405, { ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) {\r\n      return respond(500, { ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n    }\r\n\r\n    // ===== body built from the item on the client =====\r\n    const {\r\n      listKey,\r\n      title,\r\n      pn,\r\n      sn,\r\n      workOrder,\r\n      localSN,\r\n      tracking,\r\n      shippingDate,\r\n      description,\r\n      linkUrl,\r\n      photoUrls = [],\r\n    } = req.body || {};\r\n\r\n    // ===== per-list env config =====\r\n    const cfgMap = {\r\n      tasks: {\r\n        list_id: process.env.SLACK_LIST_TASKS_ID,\r\n        title_col: process.env.SLACK_LIST_TASKS_TITLE_COL,\r\n        description_col: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\r\n      },\r\n      shipping: {\r\n        list_id: process.env.SLACK_LIST_SHIPPING_ID,\r\n        title_col: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\r\n        description_col: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n        date_col: process.env.SLACK_LIST_SHIPPING_DATE_COL,\r\n        pnsn_col: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n        tracking_col: process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n        wo_col: process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n        localsn_col: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n        photos_col: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,\r\n      },\r\n      receiving: {\r\n        list_id: process.env.SLACK_LIST_RECEIVING_ID,\r\n        title_col: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\r\n        description_col: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n        date_col: process.env.SLACK_LIST_RECEIVING_DATE_COL,\r\n        pnsn_col: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n        tracking_col: process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n        wo_col: process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n        localsn_col: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n        photos_col: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL,\r\n      },\r\n    };\r\n    const cfg = cfgMap[listKey || \"\"];\r\n    if (!cfg?.list_id) {\r\n      return respond(400, { ok: false, error: `unknown_listKey_${listKey}` });\r\n    }\r\n\r\n    // ===== slack helpers =====\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n    const first = (x) => (Array.isArray(x) ? x.find(Boolean) || \"\" : plain(x));\r\n    const toRT = (text) => ({\r\n      type: \"rich_text\",\r\n      elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text: plain(text) }] }],\r\n    });\r\n    async function slackJson(method, body) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/json; charset=utf-8\" },\r\n        body: JSON.stringify(body),\r\n      });\r\n      return r.json();\r\n    }\r\n\r\n    // List out columns (more reliable than scanning items when a list is empty)\r\n    async function listColumns(list_id) {\r\n      const r = await slackJson(\"slackLists.columns.list\", { list_id });\r\n      return r?.ok ? (r.columns || []) : [];\r\n    }\r\n    // Fallback: sniff columns from existing rows\r\n    async function sniffColumnsFromItems(list_id) {\r\n      const r = await slackJson(\"slackLists.items.list\", { list_id, limit: 200 });\r\n      if (!r?.ok) return [];\r\n      const map = new Map();\r\n      for (const it of r.items || []) {\r\n        for (const f of it.fields || []) {\r\n          if (f?.column_id) map.set(f.column_id, { column_id: f.column_id, key: f.key, kind: \"field\" });\r\n        }\r\n      }\r\n      return [...map.values()];\r\n    }\r\n\r\n    function looksTextLike(col) {\r\n      const key = (col.key || \"\").toLowerCase();\r\n      const type = (col.type || \"\").toLowerCase();\r\n      // heuristics: Slack uses \"text\", \"rich_text\", sometimes type omitted in items sniff\r\n      return (\r\n        type.includes(\"text\") ||\r\n        key.includes(\"item\") ||\r\n        key.includes(\"task\") ||\r\n        key.includes(\"name\") ||\r\n        key.includes(\"title\")\r\n      );\r\n    }\r\n\r\n    async function candidateTitleColumns(list_id, envTitleCol) {\r\n      const cols = await listColumns(list_id);\r\n      let candidates = [];\r\n      if (envTitleCol) {\r\n        candidates.push(envTitleCol);\r\n      }\r\n      // text-like first\r\n      candidates = candidates.concat(cols.filter(looksTextLike).map((c) => c.column_id));\r\n      // any other column ids as last resort\r\n      candidates = candidates.concat(cols.map((c) => c.column_id));\r\n      // if columns API is unavailable/empty, sniff from items\r\n      if (!cols.length) {\r\n        const sniff = await sniffColumnsFromItems(list_id);\r\n        const texty = sniff.filter(looksTextLike).map((c) => c.column_id);\r\n        const any = sniff.map((c) => c.column_id);\r\n        candidates = candidates.concat(texty).concat(any);\r\n      }\r\n      // dedupe, keep order\r\n      return [...new Set(candidates.filter(Boolean))];\r\n    }\r\n\r\n    async function tryCreateWithColumn(list_id, colId, textValue) {\r\n      const safe = plain(textValue) || \"New Item\";\r\n      // rich_text first\r\n      let r = await slackJson(\"slackLists.items.create\", {\r\n        list_id,\r\n        initial_fields: [{ column_id: colId, rich_text: toRT(safe) }],\r\n      });\r\n      if (r?.ok) return { ok: true, created: r, colId, mode: \"rich_text\" };\r\n      // plain text fallback\r\n      r = await slackJson(\"slackLists.items.create\", {\r\n        list_id,\r\n        initial_fields: [{ column_id: colId, text: safe }],\r\n      });\r\n      if (r?.ok) return { ok: true, created: r, colId, mode: \"text\" };\r\n      return { ok: false, error: r?.error || \"invalid_arguments\", last: r, colId };\r\n    }\r\n\r\n    // ===== figure out the title column and create the row =====\r\n    const linkSuffix = linkUrl ? ` — ${linkUrl}` : \"\";\r\n    const titleForCreate = plain(title) || (localSN ? `Item (${localSN})` : \"New Item\");\r\n\r\n    const candidates = await candidateTitleColumns(cfg.list_id, cfg.title_col);\r\n    let createdTry = null;\r\n    for (const col of candidates) {\r\n      createdTry = await tryCreateWithColumn(\r\n        cfg.list_id,\r\n        col,\r\n        titleForCreate + (!cfg.description_col ? linkSuffix : \"\")\r\n      );\r\n      if (createdTry.ok) {\r\n        // lock in the col we actually used\r\n        cfg.title_col = col;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!createdTry?.ok) {\r\n      return respond(200, {\r\n        ok: false,\r\n        error: \"title_create_failed\",\r\n        detail: createdTry?.error || \"invalid_arguments\",\r\n        tried_columns: candidates,\r\n        last_response: createdTry?.last || null,\r\n        list_id: cfg.list_id,\r\n        sent_title: titleForCreate,\r\n      });\r\n    }\r\n\r\n    const itemId = createdTry.created?.item?.id;\r\n\r\n    // ===== build cells from item data =====\r\n    const pn0 = first(pn);\r\n    const sn0 = first(sn);\r\n    const pnSnText = [pn0 && `PN: ${pn0}`, sn0 && `SN: ${sn0}`].filter(Boolean).join(\"\\n\");\r\n\r\n    const cellsRT = [];\r\n    const pushRT = (colId, v) => {\r\n      const t = plain(v);\r\n      if (colId && t) cellsRT.push({ row_id: itemId, column_id: colId, rich_text: toRT(t) });\r\n    };\r\n    const pushTX = (colId, v) => {\r\n      const t = plain(v);\r\n      if (colId && t) cellsRT.push({ row_id: itemId, column_id: colId, text: t });\r\n    };\r\n\r\n    if (cfg.description_col) {\r\n      const descWithLink =\r\n        description && linkUrl\r\n          ? `${description}\\nLink: ${linkUrl}`\r\n          : description || (linkUrl ? `Link: ${linkUrl}` : \"\");\r\n      pushRT(cfg.description_col, descWithLink);\r\n    }\r\n    if (cfg.pnsn_col && pnSnText) pushRT(cfg.pnsn_col, pnSnText);\r\n    if (cfg.wo_col && workOrder) pushRT(cfg.wo_col, workOrder);\r\n    if (cfg.localsn_col && localSN) pushRT(cfg.localsn_col, localSN);\r\n    if (cfg.tracking_col && tracking) pushRT(cfg.tracking_col, tracking);\r\n    if (cfg.date_col && shippingDate) pushRT(cfg.date_col, shippingDate);\r\n    if (cfg.photos_col && photoUrls?.length) {\r\n      const block = photoUrls.map(plain).filter(Boolean).join(\"\\n\");\r\n      if (block) pushTX(cfg.photos_col, block);\r\n    }\r\n\r\n    let updated = null;\r\n    if (cellsRT.length) {\r\n      updated = await slackJson(\"slackLists.items.update\", {\r\n        list_id: cfg.list_id,\r\n        cells: cellsRT,\r\n      });\r\n\r\n      if (!updated?.ok && updated?.error === \"invalid_arguments\") {\r\n        // retry all as plain text\r\n        const cellsText = cellsRT.map((c) => ({\r\n          row_id: c.row_id,\r\n          column_id: c.column_id,\r\n          text: c.text ?? (c.rich_text?.elements?.[0]?.elements?.[0]?.text || \"\"),\r\n        }));\r\n        updated = await slackJson(\"slackLists.items.update\", {\r\n          list_id: cfg.list_id,\r\n          cells: cellsText,\r\n        });\r\n      }\r\n    }\r\n\r\n    return respond(200, {\r\n      ok: true,\r\n      mode: \"list\",\r\n      list_id: cfg.list_id,\r\n      item_id: itemId,\r\n      used_title_col: cfg.title_col,\r\n      used_columns: Object.fromEntries(Object.entries(cfg).filter(([k, v]) => k.endsWith(\"_col\") && v)),\r\n      title_mode: createdTry.mode, // \"rich_text\" or \"text\"\r\n      update_ok: updated ? !!updated.ok : true,\r\n      update_error: updated?.ok ? null : updated?.error || null,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return respond(500, { ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}