{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\n// Adds an item to a Slack List and attaches photos from Firebase URLs.\n// Verbose troubleshooting logs included when req.body.debug === true.\nexport default async function handler(req, res) {\n  const startedAt = Date.now();\n  const dbg = {\n    steps: [],\n    photos: []\n  };\n\n  function log(step, detail = {}) {\n    const entry = _objectSpread({\n      t: new Date().toISOString(),\n      step\n    }, detail);\n\n    dbg.steps.push(entry);\n    console.log(\"[SLACK][API]\", step, detail);\n  }\n\n  try {\n    var _created, _created2, _created3;\n\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n\n    if (!token) {\n      return res.status(500).json({\n        ok: false,\n        error: \"missing_SLACK_BOT_TOKEN\"\n      });\n    }\n\n    const {\n      listKey,\n      title,\n      pn,\n      sn,\n      workOrder,\n      localSN,\n      description,\n      photoUrls = [],\n      tracking,\n      linkUrl,\n      debug = false // shipping date intentionally omitted (keep blank)\n\n    } = req.body || {};\n\n    const clean = s => (s !== null && s !== void 0 ? s : \"\").trim() || undefined;\n\n    const get = k => clean(process.env[k]);\n\n    const anyOf = (...keys) => keys.map(get).find(Boolean); // Optional: allow byte-upload fallback if remote files fail (needs files:write)\n\n\n    const ENABLE_UPLOAD_FALLBACK = (process.env.SLACK_ENABLE_UPLOAD_FALLBACK || \"false\").toLowerCase() === \"true\"; // Build per-list config; everything trimmed\n\n    const CFG = {\n      tasks: {\n        list_id: get(\"SLACK_LIST_TASKS_ID\"),\n        title_col: get(\"SLACK_LIST_TASKS_TITLE_COL\"),\n        pnsn_col: get(\"SLACK_LIST_TASKS_PNSN_COL\"),\n        wo_col: anyOf(\"SLACK_LIST_TASKS_WORKORDER_COL\", \"SLACK_LIST_TASKS_WO_COL\"),\n        localsn_col: get(\"SLACK_LIST_TASKS_LOCALSN_COL\"),\n        desc_col: anyOf(\"SLACK_LIST_TASKS_DESCRIPTION_COL\", \"SLACK_LIST_TASKS_DESC_COL\"),\n        photos_col: get(\"SLACK_LIST_TASKS_PHOTOS_COL\"),\n        tracking_col: get(\"SLACK_LIST_TASKS_TRACKING_COL\"),\n        link_col: get(\"SLACK_LIST_TASKS_LINK_COL\")\n      },\n      shipping: {\n        list_id: get(\"SLACK_LIST_SHIPPING_ID\"),\n        title_col: get(\"SLACK_LIST_SHIPPING_TITLE_COL\"),\n        pnsn_col: get(\"SLACK_LIST_SHIPPING_PNSN_COL\"),\n        wo_col: anyOf(\"SLACK_LIST_SHIPPING_WORKORDER_COL\", \"SLACK_LIST_SHIPPING_WO_COL\"),\n        localsn_col: get(\"SLACK_LIST_SHIPPING_LOCALSN_COL\"),\n        desc_col: anyOf(\"SLACK_LIST_SHIPPING_DESCRIPTION_COL\", \"SLACK_LIST_SHIPPING_DESC_COL\"),\n        photos_col: get(\"SLACK_LIST_SHIPPING_PHOTOS_COL\"),\n        tracking_col: get(\"SLACK_LIST_SHIPPING_TRACKING_COL\"),\n        link_col: get(\"SLACK_LIST_SHIPPING_LINK_COL\")\n      },\n      receiving: {\n        list_id: get(\"SLACK_LIST_RECEIVING_ID\"),\n        title_col: get(\"SLACK_LIST_RECEIVING_TITLE_COL\"),\n        pnsn_col: get(\"SLACK_LIST_RECEIVING_PNSN_COL\"),\n        wo_col: anyOf(\"SLACK_LIST_RECEIVING_WORKORDER_COL\", \"SLACK_LIST_RECEIVING_WO_COL\"),\n        localsn_col: get(\"SLACK_LIST_RECEIVING_LOCALSN_COL\"),\n        desc_col: anyOf(\"SLACK_LIST_RECEIVING_DESCRIPTION_COL\", \"SLACK_LIST_RECEIVING_DESC_COL\"),\n        photos_col: get(\"SLACK_LIST_RECEIVING_PHOTOS_COL\"),\n        tracking_col: get(\"SLACK_LIST_RECEIVING_TRACKING_COL\"),\n        link_col: get(\"SLACK_LIST_RECEIVING_LINK_COL\")\n      }\n    }[listKey || \"\"];\n    if (!(CFG !== null && CFG !== void 0 && CFG.list_id)) return res.status(400).json({\n      ok: false,\n      error: `unknown_listKey_${listKey}`\n    });\n\n    if (!CFG.title_col) {\n      return res.status(400).json({\n        ok: false,\n        error: \"missing_title_column_in_env\",\n        fix: `Set SLACK_LIST_${(listKey || \"\").toUpperCase()}_TITLE_COL in .env.local`\n      });\n    } // Slack helpers\n\n\n    async function slackJson(method, payload, tag) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(payload)\n      });\n      const j = await r.json();\n      if (debug) log(tag || method, {\n        ok: j === null || j === void 0 ? void 0 : j.ok,\n        error: j === null || j === void 0 ? void 0 : j.error,\n        status: r.status\n      });\n      return j;\n    }\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const toRichText = text => [{\n      type: \"rich_text\",\n      elements: [{\n        type: \"rich_text_section\",\n        elements: [{\n          type: \"text\",\n          text: plain(text)\n        }]\n      }]\n    }];\n\n    async function setTextCell(list_id, row_id, column_id, value, label) {\n      var _r, _r2, _r3;\n\n      const val = plain(value);\n      if (!val || !column_id) return {\n        ok: true,\n        skipped: true\n      };\n      let r = await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id,\n          column_id,\n          rich_text: toRichText(val)\n        }]\n      }, `[LISTS][SET-RICH][${label}]`);\n      if ((_r = r) !== null && _r !== void 0 && _r.ok) return r;\n\n      if (((_r2 = r) === null || _r2 === void 0 ? void 0 : _r2.error) === \"invalid_arguments\" || ((_r3 = r) === null || _r3 === void 0 ? void 0 : _r3.error) === \"invalid_input_type\") {\n        r = await slackJson(\"slackLists.items.update\", {\n          list_id,\n          cells: [{\n            row_id,\n            column_id,\n            text: val\n          }]\n        }, `[LISTS][SET-TEXT][${label}]`);\n      }\n\n      return r;\n    }\n\n    async function tryAttachWithShapes(list_id, row_id, column_id, ids, label) {\n      var _r4, _r5, _r7, _r9;\n\n      // Shape A: files column expects \"attachment: [ 'F...' ]\" in many tenants\n      let r = await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id,\n          column_id,\n          attachment: ids\n        }]\n      }, `[LISTS][ATTACH-A][${label}]`);\n      if ((_r4 = r) !== null && _r4 !== void 0 && _r4.ok) return r; // Shape B: files: [{ id }]\n\n      if ((_r5 = r) !== null && _r5 !== void 0 && _r5.error) {\n        var _r6;\n\n        r = await slackJson(\"slackLists.items.update\", {\n          list_id,\n          cells: [{\n            row_id,\n            column_id,\n            files: ids.map(id => ({\n              id\n            }))\n          }]\n        }, `[LISTS][ATTACH-B][${label}]`);\n        if ((_r6 = r) !== null && _r6 !== void 0 && _r6.ok) return r;\n      } // Shape C: file_ids: [...]\n\n\n      if ((_r7 = r) !== null && _r7 !== void 0 && _r7.error) {\n        var _r8;\n\n        r = await slackJson(\"slackLists.items.update\", {\n          list_id,\n          cells: [{\n            row_id,\n            column_id,\n            file_ids: ids\n          }]\n        }, `[LISTS][ATTACH-C][${label}]`);\n        if ((_r8 = r) !== null && _r8 !== void 0 && _r8.ok) return r;\n      } // Shape D: reference.file.file_id (for reference-type fields)\n\n\n      if ((_r9 = r) !== null && _r9 !== void 0 && _r9.error) {\n        r = await slackJson(\"slackLists.items.update\", {\n          list_id,\n          cells: [{\n            row_id,\n            column_id,\n            reference: ids.map(id => ({\n              file: {\n                file_id: id\n              }\n            }))\n          }]\n        }, `[LISTS][ATTACH-D][${label}]`);\n      }\n\n      return r;\n    }\n\n    async function addRemoteFile(url, title, externalId) {\n      const payload = {\n        external_url: url,\n        title,\n        external_id: externalId\n      };\n      const j = await slackJson(\"files.remote.add\", payload, \"[FILES.REMOTE.ADD]\");\n      return j;\n    }\n\n    async function uploadBytesToSlack(url, filename) {\n      // Fallback for private URLs if enabled; requires files:write\n      try {\n        const resp = await fetch(url);\n        if (!resp.ok) return {\n          ok: false,\n          error: `fetch_fail_${resp.status}`\n        };\n        const buf = Buffer.from(await resp.arrayBuffer()); // Use undici's FormData (available in Node 18)\n\n        const form = new FormData();\n        form.append(\"filename\", filename || \"photo\");\n        form.append(\"file\", new Blob([buf]), filename || \"photo.jpg\");\n        const r = await fetch(\"https://slack.com/api/files.upload\", {\n          method: \"POST\",\n          headers: {\n            Authorization: `Bearer ${token}`\n          },\n          body: form\n        });\n        const j = await r.json();\n        if (debug) log(\"[FILES.UPLOAD]\", {\n          ok: j === null || j === void 0 ? void 0 : j.ok,\n          error: j === null || j === void 0 ? void 0 : j.error,\n          status: r.status\n        });\n        return j;\n      } catch (e) {\n        if (debug) log(\"[FILES.UPLOAD][EXCEPTION]\", {\n          message: e === null || e === void 0 ? void 0 : e.message\n        });\n        return {\n          ok: false,\n          error: \"upload_exception\"\n        };\n      }\n    } // 1) Create the row with Title\n\n\n    const safeTitle = plain(title) || \"New Item\";\n    let created = await slackJson(\"slackLists.items.create\", {\n      list_id: CFG.list_id,\n      initial_fields: [{\n        column_id: CFG.title_col,\n        rich_text: toRichText(safeTitle)\n      }]\n    }, \"[LISTS][CREATE-RICH]\");\n\n    if (!((_created = created) !== null && _created !== void 0 && _created.ok) && ((_created2 = created) === null || _created2 === void 0 ? void 0 : _created2.error) === \"invalid_arguments\") {\n      created = await slackJson(\"slackLists.items.create\", {\n        list_id: CFG.list_id,\n        initial_fields: [{\n          column_id: CFG.title_col,\n          text: safeTitle\n        }]\n      }, \"[LISTS][CREATE-TEXT]\");\n    }\n\n    if (!((_created3 = created) !== null && _created3 !== void 0 && _created3.ok)) {\n      var _created4;\n\n      return res.status(200).json({\n        ok: false,\n        error: ((_created4 = created) === null || _created4 === void 0 ? void 0 : _created4.error) || \"create_failed\",\n        list_id: CFG.list_id,\n        title_col: CFG.title_col,\n        sent_title: safeTitle,\n        debug: debug ? dbg : undefined\n      });\n    }\n\n    const rowId = created.item.id;\n    log(\"[LISTS][CREATED]\", {\n      rowId\n    }); // 2) PN/SN\n\n    if (CFG.pnsn_col) {\n      const pnPart = pn ? `PN: ${plain(pn)}` : \"\";\n      const snPart = sn ? `SN: ${plain(sn)}` : \"\";\n      const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n\n      if (pnSnText) {\n        const r = await setTextCell(CFG.list_id, rowId, CFG.pnsn_col, pnSnText, \"PN/SN\");\n\n        if (!(r !== null && r !== void 0 && r.ok)) {\n          return res.status(200).json({\n            ok: false,\n            error: (r === null || r === void 0 ? void 0 : r.error) || \"update_failed_pnsn\",\n            list_id: CFG.list_id,\n            item_id: rowId,\n            used_pnsn_col: CFG.pnsn_col,\n            debug: debug ? dbg : undefined\n          });\n        }\n      }\n    } // 3) Work Order\n\n\n    if (CFG.wo_col && workOrder) {\n      const r = await setTextCell(CFG.list_id, rowId, CFG.wo_col, workOrder, \"WORK_ORDER\");\n      if (!(r !== null && r !== void 0 && r.ok)) return res.status(200).json({\n        ok: false,\n        error: (r === null || r === void 0 ? void 0 : r.error) || \"update_failed_workorder\",\n        list_id: CFG.list_id,\n        item_id: rowId,\n        used_workorder_col: CFG.wo_col,\n        debug: debug ? dbg : undefined\n      });\n    } // 4) LocalSN\n\n\n    if (CFG.localsn_col && localSN) {\n      const r = await setTextCell(CFG.list_id, rowId, CFG.localsn_col, localSN, \"LOCAL_SN\");\n      if (!(r !== null && r !== void 0 && r.ok)) return res.status(200).json({\n        ok: false,\n        error: (r === null || r === void 0 ? void 0 : r.error) || \"update_failed_localsn\",\n        list_id: CFG.list_id,\n        item_id: rowId,\n        used_localsn_col: CFG.localsn_col,\n        debug: debug ? dbg : undefined\n      });\n    } // 5) Description\n\n\n    if (CFG.desc_col && description) {\n      const r = await setTextCell(CFG.list_id, rowId, CFG.desc_col, description, \"DESCRIPTION\");\n      if (!(r !== null && r !== void 0 && r.ok)) return res.status(200).json({\n        ok: false,\n        error: (r === null || r === void 0 ? void 0 : r.error) || \"update_failed_description\",\n        list_id: CFG.list_id,\n        item_id: rowId,\n        used_description_col: CFG.desc_col,\n        debug: debug ? dbg : undefined\n      });\n    } // 6) Tracking\n\n\n    if (CFG.tracking_col && tracking) {\n      const r = await setTextCell(CFG.list_id, rowId, CFG.tracking_col, tracking, \"TRACKING\");\n      if (!(r !== null && r !== void 0 && r.ok)) return res.status(200).json({\n        ok: false,\n        error: (r === null || r === void 0 ? void 0 : r.error) || \"update_failed_tracking\",\n        list_id: CFG.list_id,\n        item_id: rowId,\n        used_tracking_col: CFG.tracking_col,\n        debug: debug ? dbg : undefined\n      });\n    } // 7) Link back\n\n\n    if (CFG.link_col && linkUrl) {\n      const r = await setTextCell(CFG.list_id, rowId, CFG.link_col, linkUrl, \"LINK\");\n      if (!(r !== null && r !== void 0 && r.ok)) return res.status(200).json({\n        ok: false,\n        error: (r === null || r === void 0 ? void 0 : r.error) || \"update_failed_link\",\n        list_id: CFG.list_id,\n        item_id: rowId,\n        used_link_col: CFG.link_col,\n        debug: debug ? dbg : undefined\n      });\n    } // 8) Photos — create remote files → attach, with detailed logs\n\n\n    if (CFG.photos_col && Array.isArray(photoUrls) && photoUrls.length) {\n      const ids = [];\n\n      for (let i = 0; i < photoUrls.length; i++) {\n        var _add$file;\n\n        const url = plain(photoUrls[i]);\n        if (!url) continue;\n        const external_id = `firebase:${localSN || \"item\"}:${i}`;\n        const titlePart = localSN ? `Photo ${i + 1} (${localSN})` : `Photo ${i + 1}`;\n        const trace = {\n          idx: i,\n          url,\n          tries: []\n        }; // A) Try remote file (no bytes upload)\n\n        const add = await addRemoteFile(url, titlePart, external_id);\n        trace.tries.push({\n          action: \"files.remote.add\",\n          ok: add === null || add === void 0 ? void 0 : add.ok,\n          error: add === null || add === void 0 ? void 0 : add.error\n        });\n\n        if (add !== null && add !== void 0 && add.ok && add !== null && add !== void 0 && (_add$file = add.file) !== null && _add$file !== void 0 && _add$file.id) {\n          ids.push(add.file.id);\n          dbg.photos.push(trace);\n          continue;\n        } // B) Optional fallback: upload bytes to Slack (needs files:write)\n\n\n        if (ENABLE_UPLOAD_FALLBACK) {\n          var _url$split$pop, _up$file;\n\n          const filename = ((_url$split$pop = url.split(\"/\").pop()) === null || _url$split$pop === void 0 ? void 0 : _url$split$pop.split(\"?\")[0]) || `photo_${i + 1}.jpg`;\n          const up = await uploadBytesToSlack(url, filename);\n          trace.tries.push({\n            action: \"files.upload\",\n            ok: up === null || up === void 0 ? void 0 : up.ok,\n            error: up === null || up === void 0 ? void 0 : up.error\n          });\n\n          if (up !== null && up !== void 0 && up.ok && up !== null && up !== void 0 && (_up$file = up.file) !== null && _up$file !== void 0 && _up$file.id) {\n            ids.push(up.file.id);\n            dbg.photos.push(trace);\n            continue;\n          }\n        }\n\n        dbg.photos.push(trace);\n      }\n\n      if (ids.length) {\n        // Try multiple attachment shapes; log each attempt\n        let attach = await tryAttachWithShapes(CFG.list_id, rowId, CFG.photos_col, ids, \"PHOTOS\");\n\n        if (!(attach !== null && attach !== void 0 && attach.ok)) {\n          // As last resort, dump URLs into Description so nothing is lost\n          if (CFG.desc_col) {\n            const joined = `Photos:\\n${photoUrls.map(plain).filter(Boolean).join(\"\\n\")}`;\n            await setTextCell(CFG.list_id, rowId, CFG.desc_col, [description, joined].filter(Boolean).join(\"\\n\\n\"), \"PHOTOS->DESC-FALLBACK\");\n          }\n\n          return res.status(200).json({\n            ok: false,\n            error: (attach === null || attach === void 0 ? void 0 : attach.error) || \"update_failed_photos\",\n            list_id: CFG.list_id,\n            item_id: rowId,\n            used_photos_col: CFG.photos_col,\n            debug: debug ? dbg : undefined\n          });\n        }\n      } else {\n        log(\"[PHOTOS][NO-IDS]\", {\n          reason: \"remote_add_failed_or_empty\"\n        });\n      }\n    }\n\n    return res.status(200).json({\n      ok: true,\n      list_id: CFG.list_id,\n      item_id: rowId,\n      used_cols: {\n        title_col: CFG.title_col,\n        pnsn_col: CFG.pnsn_col || null,\n        workorder_col: CFG.wo_col || null,\n        localsn_col: CFG.localsn_col || null,\n        description_col: CFG.desc_col || null,\n        tracking_col: CFG.tracking_col || null,\n        photos_col: CFG.photos_col || null,\n        link_col: CFG.link_col || null\n      },\n      debug: debug ? dbg : undefined,\n      elapsed_ms: Date.now() - startedAt\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err),\n      // include whatever we logged so far\n      debug: dbg\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","startedAt","Date","now","dbg","steps","photos","log","step","detail","entry","t","toISOString","push","console","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn","sn","workOrder","localSN","description","photoUrls","tracking","linkUrl","debug","body","clean","s","trim","undefined","get","k","anyOf","keys","map","find","Boolean","ENABLE_UPLOAD_FALLBACK","SLACK_ENABLE_UPLOAD_FALLBACK","toLowerCase","CFG","tasks","list_id","title_col","pnsn_col","wo_col","localsn_col","desc_col","photos_col","tracking_col","link_col","shipping","receiving","fix","toUpperCase","slackJson","payload","tag","r","fetch","headers","Authorization","JSON","stringify","j","plain","v","toString","toRichText","text","type","elements","setTextCell","row_id","column_id","value","label","val","skipped","cells","rich_text","tryAttachWithShapes","ids","attachment","files","id","file_ids","reference","file","file_id","addRemoteFile","url","externalId","external_url","external_id","uploadBytesToSlack","filename","resp","buf","Buffer","from","arrayBuffer","form","FormData","append","Blob","e","message","safeTitle","created","initial_fields","sent_title","rowId","item","pnPart","snPart","pnSnText","filter","join","item_id","used_pnsn_col","used_workorder_col","used_localsn_col","used_description_col","used_tracking_col","used_link_col","Array","isArray","length","i","titlePart","trace","idx","tries","add","action","split","pop","up","attach","joined","used_photos_col","reason","used_cols","workorder_col","description_col","elapsed_ms","err","String"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,QAAMC,SAAS,GAAGC,IAAI,CAACC,GAAL,EAAlB;AACA,QAAMC,GAAG,GAAG;AAAEC,IAAAA,KAAK,EAAE,EAAT;AAAaC,IAAAA,MAAM,EAAE;AAArB,GAAZ;;AAEA,WAASC,GAAT,CAAaC,IAAb,EAAmBC,MAAM,GAAG,EAA5B,EAAgC;AAC9B,UAAMC,KAAK;AAAKC,MAAAA,CAAC,EAAE,IAAIT,IAAJ,GAAWU,WAAX,EAAR;AAAkCJ,MAAAA;AAAlC,OAA2CC,MAA3C,CAAX;;AACAL,IAAAA,GAAG,CAACC,KAAJ,CAAUQ,IAAV,CAAeH,KAAf;AACAI,IAA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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   try {\r\n//     if (req.method !== \"POST\") {\r\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//     }\r\n\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) {\r\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//     }\r\n\r\n//     // payload from client\r\n//     const {\r\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n//       title,               // item title (what shows in the primary column)\r\n//       // keeping minimal per your request: PN/SN only for now\r\n//       pn, sn,\r\n//     } = req.body || {};\r\n\r\n//     // list ids from env\r\n//     const LIST_IDS = {\r\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\r\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n//     };\r\n\r\n//     const list_id = LIST_IDS[listKey];\r\n//     if (!list_id) {\r\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n//     }\r\n\r\n//     // ---- Slack helpers ----\r\n//     async function slackJson(method, payload) {\r\n//       const r = await fetch(`https://slack.com/api/${method}`, {\r\n//         method: \"POST\",\r\n//         headers: {\r\n//           Authorization: `Bearer ${token}`,\r\n//           \"Content-Type\": \"application/json; charset=utf-8\",\r\n//         },\r\n//         body: JSON.stringify(payload),\r\n//       });\r\n//       return r.json();\r\n//     }\r\n\r\n//     const plain = (v) => (v ?? \"\").toString().trim();\r\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     function toRichText(text) {\r\n//       const t = plain(text);\r\n//       return [{\r\n//         type: \"rich_text\",\r\n//         elements: [{\r\n//           type: \"rich_text_section\",\r\n//           elements: [{ type: \"text\", text: t }],\r\n//         }],\r\n//       }];\r\n//     }\r\n\r\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n//     async function resolveTitleColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n//       let fallback = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\r\n//           if (f.column_id && hasText) {\r\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n//             if (!fallback) fallback = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return fallback; // first text-like field if we didn't find a perfect match\r\n//     }\r\n\r\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n//     async function resolvePnSnColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       let candidate = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           if (!f.column_id) continue;\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const text = (f.text || \"\").toLowerCase();\r\n\r\n//           const looksPnSn =\r\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\r\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n//           if (looksPnSn) return f.column_id;\r\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n//             candidate = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return candidate;\r\n//     }\r\n\r\n//     // 1) Resolve columns\r\n//     const titleColId = await resolveTitleColId(list_id);\r\n//     if (!titleColId) {\r\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n//     }\r\n\r\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n//     const safeTitle = plain(title) || \"New Item\";\r\n//     const createBody = {\r\n//       list_id,\r\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n//     };\r\n\r\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 3) (Minimal) update: PN/SN only, per your request\r\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n//     let updated = null;\r\n//     let usedPnSnCol = null;\r\n\r\n//     if (pnSnText) {\r\n//       const pnSnColId = await resolvePnSnColId(list_id);\r\n//       if (pnSnColId) {\r\n//         const cells = [{\r\n//           row_id: created.item.id,\r\n//           column_id: pnSnColId,\r\n//           rich_text: toRichText(pnSnText),\r\n//         }];\r\n\r\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n//         usedPnSnCol = pnSnColId;\r\n//         // If update fails, we still return ok:false so you can see the error\r\n//         if (!updated?.ok) {\r\n//           return res.status(200).json({\r\n//             ok: false,\r\n//             error: updated?.error || \"update_failed\",\r\n//             mode: \"list\",\r\n//             list_id,\r\n//             item_id: created.item.id,\r\n//             used_title_col: titleColId,\r\n//             used_pnsn_col: usedPnSnCol,\r\n//           });\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleColId,\r\n//       used_pnsn_col: usedPnSnCol || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\n// Adds an item to a Slack List and attaches photos from Firebase URLs.\r\n// Verbose troubleshooting logs included when req.body.debug === true.\r\n\r\nexport default async function handler(req, res) {\r\n  const startedAt = Date.now();\r\n  const dbg = { steps: [], photos: [] };\r\n\r\n  function log(step, detail = {}) {\r\n    const entry = { t: new Date().toISOString(), step, ...detail };\r\n    dbg.steps.push(entry);\r\n    console.log(\"[SLACK][API]\", step, detail);\r\n  }\r\n\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) {\r\n      return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n    }\r\n\r\n    const {\r\n      listKey, title, pn, sn, workOrder, localSN, description,\r\n      photoUrls = [], tracking, linkUrl, debug = false\r\n      // shipping date intentionally omitted (keep blank)\r\n    } = req.body || {};\r\n\r\n    const clean = (s) => (s ?? \"\").trim() || undefined;\r\n    const get = (k) => clean(process.env[k]);\r\n    const anyOf = (...keys) => keys.map(get).find(Boolean);\r\n\r\n    // Optional: allow byte-upload fallback if remote files fail (needs files:write)\r\n    const ENABLE_UPLOAD_FALLBACK = (process.env.SLACK_ENABLE_UPLOAD_FALLBACK || \"false\").toLowerCase() === \"true\";\r\n\r\n    // Build per-list config; everything trimmed\r\n    const CFG = ({\r\n      tasks: {\r\n        list_id:   get(\"SLACK_LIST_TASKS_ID\"),\r\n        title_col: get(\"SLACK_LIST_TASKS_TITLE_COL\"),\r\n        pnsn_col:  get(\"SLACK_LIST_TASKS_PNSN_COL\"),\r\n        wo_col:    anyOf(\"SLACK_LIST_TASKS_WORKORDER_COL\",\"SLACK_LIST_TASKS_WO_COL\"),\r\n        localsn_col: get(\"SLACK_LIST_TASKS_LOCALSN_COL\"),\r\n        desc_col:    anyOf(\"SLACK_LIST_TASKS_DESCRIPTION_COL\",\"SLACK_LIST_TASKS_DESC_COL\"),\r\n        photos_col:  get(\"SLACK_LIST_TASKS_PHOTOS_COL\"),\r\n        tracking_col:get(\"SLACK_LIST_TASKS_TRACKING_COL\"),\r\n        link_col:    get(\"SLACK_LIST_TASKS_LINK_COL\"),\r\n      },\r\n      shipping: {\r\n        list_id:   get(\"SLACK_LIST_SHIPPING_ID\"),\r\n        title_col: get(\"SLACK_LIST_SHIPPING_TITLE_COL\"),\r\n        pnsn_col:  get(\"SLACK_LIST_SHIPPING_PNSN_COL\"),\r\n        wo_col:    anyOf(\"SLACK_LIST_SHIPPING_WORKORDER_COL\",\"SLACK_LIST_SHIPPING_WO_COL\"),\r\n        localsn_col: get(\"SLACK_LIST_SHIPPING_LOCALSN_COL\"),\r\n        desc_col:    anyOf(\"SLACK_LIST_SHIPPING_DESCRIPTION_COL\",\"SLACK_LIST_SHIPPING_DESC_COL\"),\r\n        photos_col:  get(\"SLACK_LIST_SHIPPING_PHOTOS_COL\"),\r\n        tracking_col:get(\"SLACK_LIST_SHIPPING_TRACKING_COL\"),\r\n        link_col:    get(\"SLACK_LIST_SHIPPING_LINK_COL\"),\r\n      },\r\n      receiving: {\r\n        list_id:   get(\"SLACK_LIST_RECEIVING_ID\"),\r\n        title_col: get(\"SLACK_LIST_RECEIVING_TITLE_COL\"),\r\n        pnsn_col:  get(\"SLACK_LIST_RECEIVING_PNSN_COL\"),\r\n        wo_col:    anyOf(\"SLACK_LIST_RECEIVING_WORKORDER_COL\",\"SLACK_LIST_RECEIVING_WO_COL\"),\r\n        localsn_col: get(\"SLACK_LIST_RECEIVING_LOCALSN_COL\"),\r\n        desc_col:    anyOf(\"SLACK_LIST_RECEIVING_DESCRIPTION_COL\",\"SLACK_LIST_RECEIVING_DESC_COL\"),\r\n        photos_col:  get(\"SLACK_LIST_RECEIVING_PHOTOS_COL\"),\r\n        tracking_col:get(\"SLACK_LIST_RECEIVING_TRACKING_COL\"),\r\n        link_col:    get(\"SLACK_LIST_RECEIVING_LINK_COL\"),\r\n      },\r\n    })[listKey || \"\"];\r\n\r\n    if (!CFG?.list_id) return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n    if (!CFG.title_col) {\r\n      return res.status(400).json({\r\n        ok: false,\r\n        error: \"missing_title_column_in_env\",\r\n        fix: `Set SLACK_LIST_${(listKey || \"\").toUpperCase()}_TITLE_COL in .env.local`,\r\n      });\r\n    }\r\n\r\n    // Slack helpers\r\n    async function slackJson(method, payload, tag) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/json; charset=utf-8\" },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      const j = await r.json();\r\n      if (debug) log(tag || method, { ok: j?.ok, error: j?.error, status: r.status });\r\n      return j;\r\n    }\r\n\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n    const toRichText = (text) => [{\r\n      type: \"rich_text\",\r\n      elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text: plain(text) }] }],\r\n    }];\r\n\r\n    async function setTextCell(list_id, row_id, column_id, value, label) {\r\n      const val = plain(value);\r\n      if (!val || !column_id) return { ok: true, skipped: true };\r\n      let r = await slackJson(\"slackLists.items.update\", {\r\n        list_id, cells: [{ row_id, column_id, rich_text: toRichText(val) }],\r\n      }, `[LISTS][SET-RICH][${label}]`);\r\n      if (r?.ok) return r;\r\n      if (r?.error === \"invalid_arguments\" || r?.error === \"invalid_input_type\") {\r\n        r = await slackJson(\"slackLists.items.update\", {\r\n          list_id, cells: [{ row_id, column_id, text: val }],\r\n        }, `[LISTS][SET-TEXT][${label}]`);\r\n      }\r\n      return r;\r\n    }\r\n\r\n    async function tryAttachWithShapes(list_id, row_id, column_id, ids, label) {\r\n      // Shape A: files column expects \"attachment: [ 'F...' ]\" in many tenants\r\n      let r = await slackJson(\"slackLists.items.update\", {\r\n        list_id, cells: [{ row_id, column_id, attachment: ids }],\r\n      }, `[LISTS][ATTACH-A][${label}]`);\r\n      if (r?.ok) return r;\r\n\r\n      // Shape B: files: [{ id }]\r\n      if (r?.error) {\r\n        r = await slackJson(\"slackLists.items.update\", {\r\n          list_id, cells: [{ row_id, column_id, files: ids.map((id) => ({ id })) }],\r\n        }, `[LISTS][ATTACH-B][${label}]`);\r\n        if (r?.ok) return r;\r\n      }\r\n\r\n      // Shape C: file_ids: [...]\r\n      if (r?.error) {\r\n        r = await slackJson(\"slackLists.items.update\", {\r\n          list_id, cells: [{ row_id, column_id, file_ids: ids }],\r\n        }, `[LISTS][ATTACH-C][${label}]`);\r\n        if (r?.ok) return r;\r\n      }\r\n\r\n      // Shape D: reference.file.file_id (for reference-type fields)\r\n      if (r?.error) {\r\n        r = await slackJson(\"slackLists.items.update\", {\r\n          list_id,\r\n          cells: [{ row_id, column_id, reference: ids.map((id) => ({ file: { file_id: id } })) }],\r\n        }, `[LISTS][ATTACH-D][${label}]`);\r\n      }\r\n      return r;\r\n    }\r\n\r\n    async function addRemoteFile(url, title, externalId) {\r\n      const payload = { external_url: url, title, external_id: externalId };\r\n      const j = await slackJson(\"files.remote.add\", payload, \"[FILES.REMOTE.ADD]\");\r\n      return j;\r\n    }\r\n\r\n    async function uploadBytesToSlack(url, filename) {\r\n      // Fallback for private URLs if enabled; requires files:write\r\n      try {\r\n        const resp = await fetch(url);\r\n        if (!resp.ok) return { ok: false, error: `fetch_fail_${resp.status}` };\r\n        const buf = Buffer.from(await resp.arrayBuffer());\r\n\r\n        // Use undici's FormData (available in Node 18)\r\n        const form = new FormData();\r\n        form.append(\"filename\", filename || \"photo\");\r\n        form.append(\"file\", new Blob([buf]), filename || \"photo.jpg\");\r\n\r\n        const r = await fetch(\"https://slack.com/api/files.upload\", {\r\n          method: \"POST\",\r\n          headers: { Authorization: `Bearer ${token}` },\r\n          body: form,\r\n        });\r\n        const j = await r.json();\r\n        if (debug) log(\"[FILES.UPLOAD]\", { ok: j?.ok, error: j?.error, status: r.status });\r\n        return j;\r\n      } catch (e) {\r\n        if (debug) log(\"[FILES.UPLOAD][EXCEPTION]\", { message: e?.message });\r\n        return { ok: false, error: \"upload_exception\" };\r\n      }\r\n    }\r\n\r\n    // 1) Create the row with Title\r\n    const safeTitle = plain(title) || \"New Item\";\r\n    let created = await slackJson(\"slackLists.items.create\", {\r\n      list_id: CFG.list_id,\r\n      initial_fields: [{ column_id: CFG.title_col, rich_text: toRichText(safeTitle) }],\r\n    }, \"[LISTS][CREATE-RICH]\");\r\n    if (!created?.ok && created?.error === \"invalid_arguments\") {\r\n      created = await slackJson(\"slackLists.items.create\", {\r\n        list_id: CFG.list_id,\r\n        initial_fields: [{ column_id: CFG.title_col, text: safeTitle }],\r\n      }, \"[LISTS][CREATE-TEXT]\");\r\n    }\r\n    if (!created?.ok) {\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: created?.error || \"create_failed\",\r\n        list_id: CFG.list_id,\r\n        title_col: CFG.title_col,\r\n        sent_title: safeTitle,\r\n        debug: debug ? dbg : undefined,\r\n      });\r\n    }\r\n    const rowId = created.item.id;\r\n    log(\"[LISTS][CREATED]\", { rowId });\r\n\r\n    // 2) PN/SN\r\n    if (CFG.pnsn_col) {\r\n      const pnPart = pn ? `PN: ${plain(pn)}` : \"\";\r\n      const snPart = sn ? `SN: ${plain(sn)}` : \"\";\r\n      const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n      if (pnSnText) {\r\n        const r = await setTextCell(CFG.list_id, rowId, CFG.pnsn_col, pnSnText, \"PN/SN\");\r\n        if (!r?.ok) {\r\n          return res.status(200).json({ ok: false, error: r?.error || \"update_failed_pnsn\", list_id: CFG.list_id, item_id: rowId, used_pnsn_col: CFG.pnsn_col, debug: debug ? dbg : undefined });\r\n        }\r\n      }\r\n    }\r\n\r\n    // 3) Work Order\r\n    if (CFG.wo_col && workOrder) {\r\n      const r = await setTextCell(CFG.list_id, rowId, CFG.wo_col, workOrder, \"WORK_ORDER\");\r\n      if (!r?.ok) return res.status(200).json({ ok: false, error: r?.error || \"update_failed_workorder\", list_id: CFG.list_id, item_id: rowId, used_workorder_col: CFG.wo_col, debug: debug ? dbg : undefined });\r\n    }\r\n\r\n    // 4) LocalSN\r\n    if (CFG.localsn_col && localSN) {\r\n      const r = await setTextCell(CFG.list_id, rowId, CFG.localsn_col, localSN, \"LOCAL_SN\");\r\n      if (!r?.ok) return res.status(200).json({ ok: false, error: r?.error || \"update_failed_localsn\", list_id: CFG.list_id, item_id: rowId, used_localsn_col: CFG.localsn_col, debug: debug ? dbg : undefined });\r\n    }\r\n\r\n    // 5) Description\r\n    if (CFG.desc_col && description) {\r\n      const r = await setTextCell(CFG.list_id, rowId, CFG.desc_col, description, \"DESCRIPTION\");\r\n      if (!r?.ok) return res.status(200).json({ ok: false, error: r?.error || \"update_failed_description\", list_id: CFG.list_id, item_id: rowId, used_description_col: CFG.desc_col, debug: debug ? dbg : undefined });\r\n    }\r\n\r\n    // 6) Tracking\r\n    if (CFG.tracking_col && tracking) {\r\n      const r = await setTextCell(CFG.list_id, rowId, CFG.tracking_col, tracking, \"TRACKING\");\r\n      if (!r?.ok) return res.status(200).json({ ok: false, error: r?.error || \"update_failed_tracking\", list_id: CFG.list_id, item_id: rowId, used_tracking_col: CFG.tracking_col, debug: debug ? dbg : undefined });\r\n    }\r\n\r\n    // 7) Link back\r\n    if (CFG.link_col && linkUrl) {\r\n      const r = await setTextCell(CFG.list_id, rowId, CFG.link_col, linkUrl, \"LINK\");\r\n      if (!r?.ok) return res.status(200).json({ ok: false, error: r?.error || \"update_failed_link\", list_id: CFG.list_id, item_id: rowId, used_link_col: CFG.link_col, debug: debug ? dbg : undefined });\r\n    }\r\n\r\n    // 8) Photos — create remote files → attach, with detailed logs\r\n    if (CFG.photos_col && Array.isArray(photoUrls) && photoUrls.length) {\r\n      const ids = [];\r\n      for (let i = 0; i < photoUrls.length; i++) {\r\n        const url = plain(photoUrls[i]);\r\n        if (!url) continue;\r\n        const external_id = `firebase:${localSN || \"item\"}:${i}`;\r\n        const titlePart = localSN ? `Photo ${i + 1} (${localSN})` : `Photo ${i + 1}`;\r\n        const trace = { idx: i, url, tries: [] };\r\n\r\n        // A) Try remote file (no bytes upload)\r\n        const add = await addRemoteFile(url, titlePart, external_id);\r\n        trace.tries.push({ action: \"files.remote.add\", ok: add?.ok, error: add?.error });\r\n        if (add?.ok && add?.file?.id) {\r\n          ids.push(add.file.id);\r\n          dbg.photos.push(trace);\r\n          continue;\r\n        }\r\n\r\n        // B) Optional fallback: upload bytes to Slack (needs files:write)\r\n        if (ENABLE_UPLOAD_FALLBACK) {\r\n          const filename = url.split(\"/\").pop()?.split(\"?\")[0] || `photo_${i + 1}.jpg`;\r\n          const up = await uploadBytesToSlack(url, filename);\r\n          trace.tries.push({ action: \"files.upload\", ok: up?.ok, error: up?.error });\r\n          if (up?.ok && up?.file?.id) {\r\n            ids.push(up.file.id);\r\n            dbg.photos.push(trace);\r\n            continue;\r\n          }\r\n        }\r\n\r\n        dbg.photos.push(trace);\r\n      }\r\n\r\n      if (ids.length) {\r\n        // Try multiple attachment shapes; log each attempt\r\n        let attach = await tryAttachWithShapes(CFG.list_id, rowId, CFG.photos_col, ids, \"PHOTOS\");\r\n        if (!attach?.ok) {\r\n          // As last resort, dump URLs into Description so nothing is lost\r\n          if (CFG.desc_col) {\r\n            const joined = `Photos:\\n${photoUrls.map(plain).filter(Boolean).join(\"\\n\")}`;\r\n            await setTextCell(CFG.list_id, rowId, CFG.desc_col, [description, joined].filter(Boolean).join(\"\\n\\n\"), \"PHOTOS->DESC-FALLBACK\");\r\n          }\r\n          return res.status(200).json({\r\n            ok: false,\r\n            error: attach?.error || \"update_failed_photos\",\r\n            list_id: CFG.list_id,\r\n            item_id: rowId,\r\n            used_photos_col: CFG.photos_col,\r\n            debug: debug ? dbg : undefined,\r\n          });\r\n        }\r\n      } else {\r\n        log(\"[PHOTOS][NO-IDS]\", { reason: \"remote_add_failed_or_empty\" });\r\n      }\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      list_id: CFG.list_id,\r\n      item_id: rowId,\r\n      used_cols: {\r\n        title_col: CFG.title_col,\r\n        pnsn_col: CFG.pnsn_col || null,\r\n        workorder_col: CFG.wo_col || null,\r\n        localsn_col: CFG.localsn_col || null,\r\n        description_col: CFG.desc_col || null,\r\n        tracking_col: CFG.tracking_col || null,\r\n        photos_col: CFG.photos_col || null,\r\n        link_col: CFG.link_col || null,\r\n      },\r\n      debug: debug ? dbg : undefined,\r\n      elapsed_ms: Date.now() - startedAt,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({\r\n      ok: false,\r\n      error: \"exception\",\r\n      message: err?.message || String(err),\r\n      // include whatever we logged so far\r\n      debug: dbg,\r\n    });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}