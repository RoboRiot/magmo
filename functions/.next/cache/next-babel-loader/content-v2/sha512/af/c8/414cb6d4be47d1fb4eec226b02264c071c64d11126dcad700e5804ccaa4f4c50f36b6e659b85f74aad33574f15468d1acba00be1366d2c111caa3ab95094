{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   if (req.method !== \"POST\") {\n//     return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//   }\n//   const token = process.env.SLACK_BOT_TOKEN;\n//   if (!token) {\n//     return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//   }\n//   // ---- Payload from client (your UI already sends these) ----\n//   const {\n//     listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\n//     title,              // the thing we want to show in the Task column\n//     linkUrl, bodyText,\n//     date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\n//     photoUrls = [],\n//   } = req.body || {};\n//   // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\n//   const LISTS = {\n//     tasks: {\n//       id: process.env.SLACK_LIST_TASKS_ID,\n//       // OPTIONAL: if you know the \"Task\" column id already\n//       titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\n//       cols: {\n//         desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\n//       },\n//     },\n//     shipping: {\n//       id: process.env.SLACK_LIST_SHIPPING_ID,\n//       titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\n//       cols: {\n//         desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\n//         date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\n//         pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\n//         track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\n//         wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\n//         lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\n//         photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\n//       },\n//     },\n//     receiving: {\n//       id: process.env.SLACK_LIST_RECEIVING_ID,\n//       titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\n//       cols: {\n//         desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\n//         date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\n//         pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\n//         track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\n//         wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\n//         lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\n//         photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\n//       },\n//     },\n//   };\n//   const cfg = LISTS[listKey];\n//   if (!cfg?.id) {\n//     return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\n//   }\n//   // ---- Slack helpers ----\n//   async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\n//     const r = await fetch(`https://slack.com/api/${method}`, {\n//       method: \"POST\",\n//       headers: { Authorization: `Bearer ${token}`, ...headers },\n//       body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\n//     });\n//     return r.json();\n//   }\n//   const plain = (v) => (v ?? \"\").toString().trim();\n//   const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//   // Never send an empty title\n//   const safeTitle =\n//     plain(title) ||\n//     (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\n//     joinArr(pn) ||\n//     \"New Item\";\n//   // Convert plain text to Slack rich_text for text columns\n//   function toRichText(text) {\n//     return [{\n//       type: \"rich_text\",\n//       elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\n//     }];\n//   }\n//   // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\n//   async function resolveTitleColumnId(listId, provided) {\n//     if (provided) return { colId: provided, source: \"env\" };\n//     const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//     if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\n//     let candidate = null;\n//     for (const item of probe.items || []) {\n//       for (const f of item.fields || []) {\n//         const key = (f.key || \"\").trim().toLowerCase();\n//         const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\n//         if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\n//         if (!candidate && f.column_id && hasText) candidate = f.column_id;\n//       }\n//     }\n//     return { colId: candidate, source: \"auto:first_text\" };\n//   }\n//   try {\n//     // 1) Find the column to write the Task name into; fall back to top-level title\n//     const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\n//     const createBody = {\n//       list_id: cfg.id,\n//       ...(titleCol.colId\n//         ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\n//         : { title: safeTitle }), // fallback if we couldn’t resolve a column\n//     };\n//     const created = await slack(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 2) (Optional) Patch other columns you actually have IDs for\n//     const fields = [];\n//     const cols = cfg.cols || {};\n//     const addText = (colId, text) => {\n//       const t = plain(text);\n//       if (colId && t) fields.push({ column_id: colId, value: { text: t } });\n//     };\n//     // Description / Notes column (for tasks we include your assembled bodyText)\n//     if (cols.desc) {\n//       const bits = [\n//         plain(description),\n//         listKey === \"tasks\" ? plain(bodyText) : \"\",\n//         plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\n//       ].filter(Boolean).join(\"\\n\");\n//       addText(cols.desc, bits);\n//     }\n//     // Dates and grouped PN/SN/DOM example\n//     if (cols.date && plain(date)) fields.push({ column_id: cols.date, value: { date: plain(date) } });\n//     if (cols.pn) {\n//       const pnStr = joinArr(pn), snStr = joinArr(sn);\n//       const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`]\n//         .filter(Boolean).join(\"  \");\n//       addText(cols.pn, combo);\n//     }\n//     if (cols.track) {\n//       const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`]\n//         .filter(Boolean).join(\"  \");\n//       addText(cols.track, t);\n//     }\n//     if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\n//     if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\n//     if (fields.length) {\n//       await slack(\"slackLists.items.update\", { list_id: cfg.id, item_id: created.item.id, fields });\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id: cfg.id,\n//       item_id: created.item.id,\n//       used_title_col: titleCol.colId || null,\n//       title_col_source: titleCol.source || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  if (req.method !== \"POST\") {\n    return res.status(405).json({\n      ok: false,\n      error: \"method_not_allowed\"\n    });\n  }\n\n  const token = process.env.SLACK_BOT_TOKEN;\n\n  if (!token) {\n    return res.status(500).json({\n      ok: false,\n      error: \"missing_SLACK_BOT_TOKEN\"\n    });\n  }\n\n  const {\n    listKey,\n    // \"tasks\" | \"shipping\" | \"receiving\"\n    title,\n    linkUrl,\n    bodyText,\n    date,\n    pn,\n    sn,\n    dom,\n    trackingNumber,\n    poNumber,\n    workOrder,\n    localSN,\n    description,\n    photoUrls = []\n  } = req.body || {}; // ── List configs: only id is required to push a title\n\n  const LISTS = {\n    tasks: {\n      id: process.env.SLACK_LIST_TASKS_ID,\n      titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\n      cols: {\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null\n      }\n    },\n    shipping: {\n      id: process.env.SLACK_LIST_SHIPPING_ID,\n      titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\n      cols: {\n        desc: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\n        date: process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\n        pn: process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\n        track: process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\n        wo: process.env.SLACK_LIST_SHIPPING_WO_COL || null,\n        lsn: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null\n      }\n    },\n    receiving: {\n      id: process.env.SLACK_LIST_RECEIVING_ID,\n      titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\n      cols: {\n        desc: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\n        date: process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\n        pn: process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\n        track: process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\n        wo: process.env.SLACK_LIST_RECEIVING_WO_COL || null,\n        lsn: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null\n      }\n    }\n  };\n  const cfg = LISTS[listKey];\n\n  if (!(cfg !== null && cfg !== void 0 && cfg.id)) {\n    return res.status(400).json({\n      ok: false,\n      error: `unknown_or_unconfigured_listKey_${listKey}`\n    });\n  } // ── Slack helpers\n\n\n  const headersJson = {\n    Authorization: `Bearer ${token}`,\n    \"Content-Type\": \"application/json; charset=utf-8\"\n  };\n\n  async function slack(method, payload) {\n    const r = await fetch(`https://slack.com/api/${method}`, {\n      method: \"POST\",\n      headers: headersJson,\n      body: typeof payload === \"string\" ? payload : JSON.stringify(payload)\n    });\n    return r.json();\n  }\n\n  const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n  const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a); // Never send an empty title (Slack will reject with missing_or_invalid_name)\n\n\n  const safeTitle = plain(title) || (plain(localSN) ? `Item ${plain(localSN)}` : \"\") || joinArr(pn) || \"New Item\"; // Slack Lists supports initializing fields at creation or patching later.\n  // Doc refs:\n  // - slackLists.items.create initial_fields/title: https://docs.slack.dev/reference/methods/slackLists.items.create/ :contentReference[oaicite:1]{index=1}\n  // - slackLists.items.list (for discovery): https://docs.slack.dev/reference/methods/slackLists.items.list/ :contentReference[oaicite:2]{index=2}\n  // - Rich text format schema (if needed for rich_text): https://docs.slack.dev/block-kit/formatting-with-rich-text/ :contentReference[oaicite:3]{index=3}\n  // Optional: detect the “Task/Name” column if env not set\n\n  async function resolveTitleColumnId(listId, provided) {\n    if (provided) return {\n      colId: provided,\n      source: \"env\"\n    };\n    const probe = await slack(\"slackLists.items.list\", {\n      list_id: listId,\n      limit: 50\n    });\n    if (!(probe !== null && probe !== void 0 && probe.ok)) return {\n      colId: null,\n      source: \"auto\",\n      error: (probe === null || probe === void 0 ? void 0 : probe.error) || \"items.list_failed\"\n    };\n    let candidate = null;\n\n    for (const item of probe.items || []) {\n      for (const f of item.fields || []) {\n        const key = (f.key || \"\").trim().toLowerCase();\n        const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\n        if (key === \"task\" && f.column_id && hasText) return {\n          colId: f.column_id,\n          source: \"auto:key_task\"\n        };\n        if (!candidate && f.column_id && hasText) candidate = f.column_id;\n      }\n    }\n\n    return {\n      colId: candidate,\n      source: \"auto:first_text\"\n    };\n  } // NEW: if PN/SN col id not provided, try to discover a column that already contains “PN:” or “SN:”\n\n\n  async function resolvePnColumnId(listId, providedPn) {\n    if (providedPn) return {\n      colId: providedPn,\n      source: \"env\"\n    };\n    const probe = await slack(\"slackLists.items.list\", {\n      list_id: listId,\n      limit: 100\n    });\n    if (!(probe !== null && probe !== void 0 && probe.ok)) return {\n      colId: null,\n      source: \"auto\",\n      error: (probe === null || probe === void 0 ? void 0 : probe.error) || \"items.list_failed\"\n    };\n\n    for (const item of probe.items || []) {\n      for (const f of item.fields || []) {\n        const t = (f.text || \"\").toLowerCase();\n\n        if (f.column_id && (t.includes(\"pn:\") || t.includes(\"sn:\"))) {\n          return {\n            colId: f.column_id,\n            source: \"auto:matched_pn_sn\"\n          };\n        }\n      }\n    }\n\n    return {\n      colId: null,\n      source: \"auto:none_found\"\n    };\n  } // Simple helper: push a plain text field\n\n\n  function pushText(fields, colId, text) {\n    const t = plain(text);\n    if (colId && t) fields.push({\n      column_id: colId,\n      value: {\n        text: t\n      }\n    });\n  }\n\n  try {\n    // 1) Figure out the title column (or fallback to top-level title)\n    const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId); // Build fields we can send at creation time (optional)\n\n    const createFields = []; // If you want to pre-populate Description at creation:\n\n    if (cfg.cols.desc && (description || listKey === \"tasks\" && bodyText || linkUrl)) {\n      const bits = [plain(description), listKey === \"tasks\" ? plain(bodyText) : \"\", plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\"].filter(Boolean).join(\"\\n\");\n      pushText(createFields, cfg.cols.desc, bits);\n    } // If you want to pre-populate a date at creation:\n\n\n    if (cfg.cols.date && plain(date)) {\n      createFields.push({\n        column_id: cfg.cols.date,\n        value: {\n          date: plain(date)\n        }\n      });\n    } // Create the item\n\n\n    const createBody = _objectSpread({\n      list_id: cfg.id\n    }, titleCol.colId ? {\n      initial_fields: [{\n        column_id: titleCol.colId,\n        value: {\n          text: safeTitle\n        }\n      }, ...createFields]\n    } : {\n      title: safeTitle,\n      initial_fields: createFields\n    });\n\n    const created = await slack(\"slackLists.items.create\", createBody);\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      console.error(\"[Slack] create error:\", created);\n      return res.status(200).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\",\n        mode: \"list\",\n        sent: createBody\n      });\n    } // 2) After creation, patch the rest of the columns\n\n\n    const fields = [];\n    const cols = cfg.cols || {}; // Resolve PN/SN/DOM column id dynamically if not configured\n\n    let pnColId = cols.pn || null;\n\n    if (!pnColId) {\n      const guess = await resolvePnColumnId(cfg.id, null);\n      pnColId = guess.colId;\n      console.log(\"[Slack] PN/SN column discovery:\", guess);\n    } // PN/SN/DOM combo line\n\n\n    if (pnColId && (pn || sn || dom)) {\n      const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : pn ? `PN: ${pn}` : \"\";\n      const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : sn ? `SN: ${sn}` : \"\";\n      const domLine = dom ? `DOM: ${dom}` : \"\";\n      const combo = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\n      pushText(fields, pnColId, combo);\n    } // Tracking + PO\n\n\n    if (cols.track && (trackingNumber || poNumber)) {\n      const t = [trackingNumber ? `RL: ${plain(trackingNumber)}` : \"\", poNumber ? `PO: ${plain(poNumber)}` : \"\"].filter(Boolean).join(\"  \");\n      pushText(fields, cols.track, t);\n    } // WO and LocalSN\n\n\n    if (cols.wo && plain(workOrder)) pushText(fields, cols.wo, `WO: ${plain(workOrder)}`);\n    if (cols.lsn && plain(localSN)) pushText(fields, cols.lsn, plain(localSN)); // If we STILL don’t have a PN col id, drop PN/SN into Description so nothing is lost\n\n    if (!pnColId && (pn || sn) && cols.desc) {\n      const pnStr = Array.isArray(pn) ? pn.filter(Boolean).join(\", \") : pn || \"\";\n      const snStr = Array.isArray(sn) ? sn.filter(Boolean).join(\", \") : sn || \"\";\n      const extra = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`].filter(Boolean).join(\"  \");\n      const joiner = (description ? description + \"\\n\" : \"\") + extra; // Overwrite/append description\n\n      fields.push({\n        column_id: cols.desc,\n        value: {\n          text: joiner\n        }\n      });\n    }\n\n    if (fields.length) {\n      await slack(\"slackLists.items.update\", {\n        list_id: cfg.id,\n        item_id: created.item.id,\n        fields\n      });\n    } // 3) (optional) photos to attachment column using External Upload flow\n    // https://docs.slack.dev/reference/methods/files.getUploadURLExternal/ :contentReference[oaicite:4]{index=4}\n\n\n    if (cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\n      const fileIds = [];\n\n      for (const url of photoUrls) {\n        var _complete$files, _complete$files$;\n\n        const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\n          method: \"POST\",\n          headers: {\n            Authorization: `Bearer ${token}`,\n            \"Content-Type\": \"application/x-www-form-urlencoded\"\n          },\n          body: new URLSearchParams({\n            filename: url.split(\"/\").pop() || \"image.jpg\"\n          })\n        }).then(r => r.json());\n        if (!(init !== null && init !== void 0 && init.ok) || !(init !== null && init !== void 0 && init.upload_url)) continue;\n\n        try {\n          const img = await fetch(url);\n          const buf = await img.arrayBuffer();\n          await fetch(init.upload_url, {\n            method: \"PUT\",\n            body: Buffer.from(buf)\n          });\n        } catch {}\n\n        const complete = await slack(\"files.completeUploadExternal\", {\n          files: [{\n            id: init.file_id,\n            title: \"photo\"\n          }]\n        });\n        if (complete !== null && complete !== void 0 && complete.ok && complete !== null && complete !== void 0 && (_complete$files = complete.files) !== null && _complete$files !== void 0 && (_complete$files$ = _complete$files[0]) !== null && _complete$files$ !== void 0 && _complete$files$.id) fileIds.push(complete.files[0].id);\n      }\n\n      if (fileIds.length) {\n        await slack(\"slackLists.items.update\", {\n          list_id: cfg.id,\n          item_id: created.item.id,\n          fields: [{\n            column_id: cols.photos,\n            value: {\n              attachment: {\n                file_ids: fileIds\n              }\n            }\n          }]\n        });\n      }\n    }\n\n    return res.status(200).json({\n      ok: true,\n      mode: \"list\",\n      list_id: cfg.id,\n      item_id: created.item.id,\n      used_title_col: titleCol.colId || null,\n      title_col_source: titleCol.source || null,\n      sent_title: safeTitle\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","linkUrl","bodyText","date","pn","sn","dom","trackingNumber","poNumber","workOrder","localSN","description","photoUrls","body","LISTS","tasks","id","SLACK_LIST_TASKS_ID","titleColId","SLACK_LIST_TASKS_TITLE_COL","cols","desc","SLACK_LIST_TASKS_DESCRIPTION_COL","shipping","SLACK_LIST_SHIPPING_ID","SLACK_LIST_SHIPPING_TITLE_COL","SLACK_LIST_SHIPPING_DESCRIPTION_COL","SLACK_LIST_SHIPPING_DATE_COL","SLACK_LIST_SHIPPING_PNSN_COL","track","SLACK_LIST_SHIPPING_TRACKING_COL","wo","SLACK_LIST_SHIPPING_WO_COL","lsn","SLACK_LIST_SHIPPING_LOCALSN_COL","photos","SLACK_LIST_SHIPPING_PHOTOS_COL","receiving","SLACK_LIST_RECEIVING_ID","SLACK_LIST_RECEIVING_TITLE_COL","SLACK_LIST_RECEIVING_DESCRIPTION_COL","SLACK_LIST_RECEIVING_DATE_COL","SLACK_LIST_RECEIVING_PNSN_COL","SLACK_LIST_RECEIVING_TRACKING_COL","SLACK_LIST_RECEIVING_WO_COL","SLACK_LIST_RECEIVING_LOCALSN_COL","SLACK_LIST_RECEIVING_PHOTOS_COL","cfg","headersJson","Authorization","slack","payload","r","fetch","headers","JSON","stringify","plain","v","toString","trim","joinArr","a","Array","isArray","filter","Boolean","map","join","safeTitle","resolveTitleColumnId","listId","provided","colId","source","probe","list_id","limit","candidate","item","items","f","fields","key","toLowerCase","hasText","text","rich_text","column_id","resolvePnColumnId","providedPn","t","includes","pushText","push","value","titleCol","createFields","bits","createBody","initial_fields","created","console","mode","sent","pnColId","guess","log","pnLine","snLine","domLine","combo","pnStr","snStr","extra","joiner","length","item_id","fileIds","url","init","URLSearchParams","filename","split","pop","then","upload_url","img","buf","arrayBuffer","Buffer","from","complete","files","file_id","attachment","file_ids","used_title_col","title_col_source","sent_title","err","message","String"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,WAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE;AAApB,KAArB,CAAP;AACD;;AAED,QAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;;AACA,MAAI,CAACH,KAAL,EAAY;AACV,WAAON,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAA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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   if (req.method !== \"POST\") {\r\n//     return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//   }\r\n\r\n//   const token = process.env.SLACK_BOT_TOKEN;\r\n//   if (!token) {\r\n//     return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//   }\r\n\r\n//   // ---- Payload from client (your UI already sends these) ----\r\n//   const {\r\n//     listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\r\n//     title,              // the thing we want to show in the Task column\r\n//     linkUrl, bodyText,\r\n//     date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n//     photoUrls = [],\r\n//   } = req.body || {};\r\n\r\n//   // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\r\n//   const LISTS = {\r\n//     tasks: {\r\n//       id: process.env.SLACK_LIST_TASKS_ID,\r\n//       // OPTIONAL: if you know the \"Task\" column id already\r\n//       titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\r\n//       cols: {\r\n//         desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\r\n//       },\r\n//     },\r\n//     shipping: {\r\n//       id: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\r\n//       cols: {\r\n//         desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\r\n//         date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\r\n//         pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\r\n//         track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\r\n//         wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\r\n//         lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\r\n//         photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\r\n//       },\r\n//     },\r\n//     receiving: {\r\n//       id: process.env.SLACK_LIST_RECEIVING_ID,\r\n//       titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\r\n//       cols: {\r\n//         desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\r\n//         date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\r\n//         pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\r\n//         track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\r\n//         wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\r\n//         lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\r\n//         photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\r\n//       },\r\n//     },\r\n//   };\r\n\r\n//   const cfg = LISTS[listKey];\r\n//   if (!cfg?.id) {\r\n//     return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\r\n//   }\r\n\r\n//   // ---- Slack helpers ----\r\n//   async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\r\n//     const r = await fetch(`https://slack.com/api/${method}`, {\r\n//       method: \"POST\",\r\n//       headers: { Authorization: `Bearer ${token}`, ...headers },\r\n//       body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\r\n//     });\r\n//     return r.json();\r\n//   }\r\n\r\n//   const plain = (v) => (v ?? \"\").toString().trim();\r\n//   const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//   // Never send an empty title\r\n//   const safeTitle =\r\n//     plain(title) ||\r\n//     (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\r\n//     joinArr(pn) ||\r\n//     \"New Item\";\r\n\r\n//   // Convert plain text to Slack rich_text for text columns\r\n//   function toRichText(text) {\r\n//     return [{\r\n//       type: \"rich_text\",\r\n//       elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\r\n//     }];\r\n//   }\r\n\r\n//   // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\r\n//   async function resolveTitleColumnId(listId, provided) {\r\n//     if (provided) return { colId: provided, source: \"env\" };\r\n\r\n//     const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//     if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\r\n\r\n//     let candidate = null;\r\n//     for (const item of probe.items || []) {\r\n//       for (const f of item.fields || []) {\r\n//         const key = (f.key || \"\").trim().toLowerCase();\r\n//         const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\r\n//         if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\r\n//         if (!candidate && f.column_id && hasText) candidate = f.column_id;\r\n//       }\r\n//     }\r\n//     return { colId: candidate, source: \"auto:first_text\" };\r\n//   }\r\n\r\n//   try {\r\n//     // 1) Find the column to write the Task name into; fall back to top-level title\r\n//     const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\r\n\r\n//     const createBody = {\r\n//       list_id: cfg.id,\r\n//       ...(titleCol.colId\r\n//         ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\r\n//         : { title: safeTitle }), // fallback if we couldn’t resolve a column\r\n//     };\r\n\r\n//     const created = await slack(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 2) (Optional) Patch other columns you actually have IDs for\r\n//     const fields = [];\r\n//     const cols = cfg.cols || {};\r\n//     const addText = (colId, text) => {\r\n//       const t = plain(text);\r\n//       if (colId && t) fields.push({ column_id: colId, value: { text: t } });\r\n//     };\r\n\r\n//     // Description / Notes column (for tasks we include your assembled bodyText)\r\n//     if (cols.desc) {\r\n//       const bits = [\r\n//         plain(description),\r\n//         listKey === \"tasks\" ? plain(bodyText) : \"\",\r\n//         plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\r\n//       ].filter(Boolean).join(\"\\n\");\r\n//       addText(cols.desc, bits);\r\n//     }\r\n\r\n//     // Dates and grouped PN/SN/DOM example\r\n//     if (cols.date && plain(date)) fields.push({ column_id: cols.date, value: { date: plain(date) } });\r\n//     if (cols.pn) {\r\n//       const pnStr = joinArr(pn), snStr = joinArr(sn);\r\n//       const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`]\r\n//         .filter(Boolean).join(\"  \");\r\n//       addText(cols.pn, combo);\r\n//     }\r\n//     if (cols.track) {\r\n//       const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`]\r\n//         .filter(Boolean).join(\"  \");\r\n//       addText(cols.track, t);\r\n//     }\r\n//     if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\r\n//     if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\r\n\r\n//     if (fields.length) {\r\n//       await slack(\"slackLists.items.update\", { list_id: cfg.id, item_id: created.item.id, fields });\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id: cfg.id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleCol.colId || null,\r\n//       title_col_source: titleCol.source || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  if (req.method !== \"POST\") {\r\n    return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n  }\r\n\r\n  const token = process.env.SLACK_BOT_TOKEN;\r\n  if (!token) {\r\n    return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n  }\r\n\r\n  const {\r\n    listKey, // \"tasks\" | \"shipping\" | \"receiving\"\r\n    title, linkUrl, bodyText,\r\n    date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n    photoUrls = [],\r\n  } = req.body || {};\r\n\r\n  // ── List configs: only id is required to push a title\r\n  const LISTS = {\r\n    tasks: {\r\n      id: process.env.SLACK_LIST_TASKS_ID,\r\n      titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\r\n      cols: {\r\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\r\n      },\r\n    },\r\n    shipping: {\r\n      id: process.env.SLACK_LIST_SHIPPING_ID,\r\n      titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\r\n      cols: {\r\n        desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\r\n        date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\r\n        pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\r\n        track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\r\n        wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\r\n        lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\r\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\r\n      },\r\n    },\r\n    receiving: {\r\n      id: process.env.SLACK_LIST_RECEIVING_ID,\r\n      titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\r\n      cols: {\r\n        desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\r\n        date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\r\n        pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\r\n        track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\r\n        wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\r\n        lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\r\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\r\n      },\r\n    },\r\n  };\r\n\r\n  const cfg = LISTS[listKey];\r\n  if (!cfg?.id) {\r\n    return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\r\n  }\r\n\r\n  // ── Slack helpers\r\n  const headersJson = {\r\n    Authorization: `Bearer ${token}`,\r\n    \"Content-Type\": \"application/json; charset=utf-8\",\r\n  };\r\n  async function slack(method, payload) {\r\n    const r = await fetch(`https://slack.com/api/${method}`, {\r\n      method: \"POST\",\r\n      headers: headersJson,\r\n      body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\r\n    });\r\n    return r.json();\r\n  }\r\n\r\n  const plain   = (v) => (v ?? \"\").toString().trim();\r\n  const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n  // Never send an empty title (Slack will reject with missing_or_invalid_name)\r\n  const safeTitle =\r\n    plain(title) ||\r\n    (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\r\n    joinArr(pn) ||\r\n    \"New Item\";\r\n\r\n  // Slack Lists supports initializing fields at creation or patching later.\r\n  // Doc refs:\r\n  // - slackLists.items.create initial_fields/title: https://docs.slack.dev/reference/methods/slackLists.items.create/ :contentReference[oaicite:1]{index=1}\r\n  // - slackLists.items.list (for discovery): https://docs.slack.dev/reference/methods/slackLists.items.list/ :contentReference[oaicite:2]{index=2}\r\n  // - Rich text format schema (if needed for rich_text): https://docs.slack.dev/block-kit/formatting-with-rich-text/ :contentReference[oaicite:3]{index=3}\r\n\r\n  // Optional: detect the “Task/Name” column if env not set\r\n  async function resolveTitleColumnId(listId, provided) {\r\n    if (provided) return { colId: provided, source: \"env\" };\r\n    const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n    if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\r\n\r\n    let candidate = null;\r\n    for (const item of probe.items || []) {\r\n      for (const f of item.fields || []) {\r\n        const key = (f.key || \"\").trim().toLowerCase();\r\n        const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\r\n        if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\r\n        if (!candidate && f.column_id && hasText) candidate = f.column_id;\r\n      }\r\n    }\r\n    return { colId: candidate, source: \"auto:first_text\" };\r\n  }\r\n\r\n  // NEW: if PN/SN col id not provided, try to discover a column that already contains “PN:” or “SN:”\r\n  async function resolvePnColumnId(listId, providedPn) {\r\n    if (providedPn) return { colId: providedPn, source: \"env\" };\r\n    const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n    if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\r\n\r\n    for (const item of probe.items || []) {\r\n      for (const f of item.fields || []) {\r\n        const t = (f.text || \"\").toLowerCase();\r\n        if (f.column_id && (t.includes(\"pn:\") || t.includes(\"sn:\"))) {\r\n          return { colId: f.column_id, source: \"auto:matched_pn_sn\" };\r\n        }\r\n      }\r\n    }\r\n    return { colId: null, source: \"auto:none_found\" };\r\n  }\r\n\r\n  // Simple helper: push a plain text field\r\n  function pushText(fields, colId, text) {\r\n    const t = plain(text);\r\n    if (colId && t) fields.push({ column_id: colId, value: { text: t } });\r\n  }\r\n\r\n  try {\r\n    // 1) Figure out the title column (or fallback to top-level title)\r\n    const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\r\n\r\n    // Build fields we can send at creation time (optional)\r\n    const createFields = [];\r\n    // If you want to pre-populate Description at creation:\r\n    if (cfg.cols.desc && (description || (listKey === \"tasks\" && bodyText) || linkUrl)) {\r\n      const bits = [\r\n        plain(description),\r\n        listKey === \"tasks\" ? plain(bodyText) : \"\",\r\n        plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\r\n      ].filter(Boolean).join(\"\\n\");\r\n      pushText(createFields, cfg.cols.desc, bits);\r\n    }\r\n    // If you want to pre-populate a date at creation:\r\n    if (cfg.cols.date && plain(date)) {\r\n      createFields.push({ column_id: cfg.cols.date, value: { date: plain(date) } });\r\n    }\r\n\r\n    // Create the item\r\n    const createBody = {\r\n      list_id: cfg.id,\r\n      ...(titleCol.colId\r\n        ? { initial_fields: [{ column_id: titleCol.colId, value: { text: safeTitle } }, ...createFields] }\r\n        : { title: safeTitle, initial_fields: createFields }),\r\n    };\r\n    const created = await slack(\"slackLists.items.create\", createBody);\r\n    if (!created?.ok) {\r\n      console.error(\"[Slack] create error:\", created);\r\n      return res.status(200).json({ ok: false, error: created?.error || \"create_failed\", mode: \"list\", sent: createBody });\r\n    }\r\n\r\n    // 2) After creation, patch the rest of the columns\r\n    const fields = [];\r\n    const cols = cfg.cols || {};\r\n\r\n    // Resolve PN/SN/DOM column id dynamically if not configured\r\n    let pnColId = cols.pn || null;\r\n    if (!pnColId) {\r\n      const guess = await resolvePnColumnId(cfg.id, null);\r\n      pnColId = guess.colId;\r\n      console.log(\"[Slack] PN/SN column discovery:\", guess);\r\n    }\r\n\r\n    // PN/SN/DOM combo line\r\n    if (pnColId && (pn || sn || dom)) {\r\n      const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : (pn ? `PN: ${pn}` : \"\");\r\n      const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : (sn ? `SN: ${sn}` : \"\");\r\n      const domLine = dom ? `DOM: ${dom}` : \"\";\r\n      const combo   = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\r\n      pushText(fields, pnColId, combo);\r\n    }\r\n\r\n    // Tracking + PO\r\n    if (cols.track && (trackingNumber || poNumber)) {\r\n      const t = [\r\n        trackingNumber ? `RL: ${plain(trackingNumber)}` : \"\",\r\n        poNumber ? `PO: ${plain(poNumber)}` : \"\",\r\n      ].filter(Boolean).join(\"  \");\r\n      pushText(fields, cols.track, t);\r\n    }\r\n\r\n    // WO and LocalSN\r\n    if (cols.wo && plain(workOrder)) pushText(fields, cols.wo, `WO: ${plain(workOrder)}`);\r\n    if (cols.lsn && plain(localSN))  pushText(fields, cols.lsn, plain(localSN));\r\n\r\n    // If we STILL don’t have a PN col id, drop PN/SN into Description so nothing is lost\r\n    if (!pnColId && (pn || sn) && cols.desc) {\r\n      const pnStr = Array.isArray(pn) ? pn.filter(Boolean).join(\", \") : (pn || \"\");\r\n      const snStr = Array.isArray(sn) ? sn.filter(Boolean).join(\", \") : (sn || \"\");\r\n      const extra = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`].filter(Boolean).join(\"  \");\r\n      const joiner = (description ? description + \"\\n\" : \"\") + extra;\r\n      // Overwrite/append description\r\n      fields.push({ column_id: cols.desc, value: { text: joiner } });\r\n    }\r\n\r\n    if (fields.length) {\r\n      await slack(\"slackLists.items.update\", {\r\n        list_id: cfg.id,\r\n        item_id: created.item.id,\r\n        fields,\r\n      });\r\n    }\r\n\r\n    // 3) (optional) photos to attachment column using External Upload flow\r\n    // https://docs.slack.dev/reference/methods/files.getUploadURLExternal/ :contentReference[oaicite:4]{index=4}\r\n    if (cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\r\n      const fileIds = [];\r\n      for (const url of photoUrls) {\r\n        const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\r\n          method: \"POST\",\r\n          headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n          body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\r\n        }).then(r => r.json());\r\n        if (!init?.ok || !init?.upload_url) continue;\r\n\r\n        try {\r\n          const img = await fetch(url);\r\n          const buf = await img.arrayBuffer();\r\n          await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\r\n        } catch {}\r\n\r\n        const complete = await slack(\"files.completeUploadExternal\", { files: [{ id: init.file_id, title: \"photo\" }] });\r\n        if (complete?.ok && complete?.files?.[0]?.id) fileIds.push(complete.files[0].id);\r\n      }\r\n      if (fileIds.length) {\r\n        await slack(\"slackLists.items.update\", {\r\n          list_id: cfg.id,\r\n          item_id: created.item.id,\r\n          fields: [{ column_id: cols.photos, value: { attachment: { file_ids: fileIds } } }],\r\n        });\r\n      }\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      mode: \"list\",\r\n      list_id: cfg.id,\r\n      item_id: created.item.id,\r\n      used_title_col: titleCol.colId || null,\r\n      title_col_source: titleCol.source || null,\r\n      sent_title: safeTitle,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}