{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useState, useEffect } from \"react\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { Form, Button, Card, Container, Row, Col, Modal, Table } from \"react-bootstrap\";\nimport { useRouter } from \"next/router\";\nimport firebase from \"../../../../context/Firebase\";\nimport ClientInfoModal from \"../../ClientInfoModal\";\nimport MachineCreationModal from \"../../MachineCreationModal\";\n\nconst AddClient = () => {\n  const router = useRouter();\n  const {\n    0: clientId,\n    1: setClientId\n  } = useState(null);\n  const {\n    0: client,\n    1: setClient\n  } = useState({\n    name: \"\",\n    location: \"\"\n  });\n  const {\n    0: addedMachines,\n    1: setAddedMachines\n  } = useState([]);\n  const {\n    0: showClientInfoModal,\n    1: setShowClientInfoModal\n  } = useState(false);\n  const {\n    0: showMachineCreationModal,\n    1: setShowMachineCreationModal\n  } = useState(false);\n  const {\n    0: machineOptions,\n    1: setMachineOptions\n  } = useState([]);\n  const {\n    0: error,\n    1: setError\n  } = useState(null);\n  useEffect(() => {\n    const handleClientId = () => {\n      const {\n        id\n      } = router.query;\n\n      if (id) {\n        setClientId(id);\n        fetchClientData(id);\n      }\n    };\n\n    if (router.isReady) {\n      handleClientId();\n    }\n  }, [router.isReady, router.query]);\n\n  const fetchClientData = async id => {\n    const db = firebase.firestore();\n\n    try {\n      const doc = await db.collection(\"Client\").doc(id).get();\n\n      if (doc.exists) {\n        const data = doc.data();\n        setClient({\n          name: data.name || \"\",\n          location: data.local || \"\"\n        });\n        const machineRefs = data.machines || [];\n        const machines = await Promise.all(machineRefs.map(ref => ref.get().then(doc => _objectSpread({\n          id: doc.id\n        }, doc.data()))));\n        setAddedMachines(machines);\n      }\n    } catch (error) {\n      console.error(\"Error fetching client data:\", error);\n      setError(\"Failed to fetch client data.\");\n    }\n  };\n\n  const fetchAvailableMachines = async () => {\n    const db = firebase.firestore();\n\n    try {\n      const snapshot = await db.collection(\"Machine\").where(\"client\", \"==\", null).get();\n      const machines = snapshot.docs.map(doc => _objectSpread({\n        id: doc.id\n      }, doc.data()));\n      setMachineOptions(machines);\n    } catch (error) {\n      console.error(\"Error fetching machines:\", error);\n      setError(\"Failed to fetch machines.\");\n    }\n  };\n\n  const handleChange = field => event => {\n    const value = event.target.value;\n    setClient(prev => _objectSpread(_objectSpread({}, prev), {}, {\n      [field]: value\n    }));\n  };\n\n  const handleAddMachine = machine => {\n    setAddedMachines(prev => [...prev, machine]);\n    setShowClientInfoModal(false);\n  }; // When creating a new machine, if a client exists (edit mode) use set with merge\n  // so that if the client document doesn't exist yet it gets created.\n\n\n  const handleCreateMachine = async newMachine => {\n    const db = firebase.firestore();\n    const machineId = `AIS${Math.floor(10000 + Math.random() * 90000)}`;\n\n    try {\n      const machineWithId = _objectSpread(_objectSpread({}, newMachine), {}, {\n        id: machineId,\n        // Only set the client if clientId exists; otherwise, leave it null.\n        client: clientId ? db.collection(\"Client\").doc(clientId) : null\n      });\n\n      await db.collection(\"Machine\").doc(machineId).set(machineWithId); // If editing an existing client, update its machines array using set with merge.\n\n      if (clientId) {\n        const clientRef = db.collection(\"Client\").doc(clientId);\n        await clientRef.set({\n          machines: firebase.firestore.FieldValue.arrayUnion(db.collection(\"Machine\").doc(machineId))\n        }, {\n          merge: true\n        });\n      }\n\n      setShowMachineCreationModal(false);\n      setAddedMachines(prev => [...prev, _objectSpread({\n        id: machineId\n      }, newMachine)]);\n    } catch (error) {\n      console.error(\"Error creating and adding machine:\", error);\n      setError(\"Failed to create and add machine.\");\n    }\n  };\n\n  const handleRemoveMachine = index => {\n    setAddedMachines(prev => prev.filter((_, i) => i !== index));\n  };\n\n  const handleSubmit = async () => {\n    const db = firebase.firestore();\n\n    try {\n      if (clientId) {\n        // Update existing client\n        await db.collection(\"Client\").doc(clientId).set(_objectSpread(_objectSpread({}, client), {}, {\n          machines: addedMachines.map(machine => db.collection(\"Machine\").doc(machine.id))\n        }), {\n          merge: true\n        });\n      } else {\n        // Create new client\n        const newClientId = `AIS${Math.floor(10000 + Math.random() * 90000)}`;\n        await db.collection(\"Client\").doc(newClientId).set(_objectSpread(_objectSpread({}, client), {}, {\n          machines: addedMachines.map(machine => db.collection(\"Machine\").doc(machine.id))\n        })); // (Update machines with the new client reference as needed.)\n\n        clientId = newClientId;\n      }\n\n      alert(\"Client and machines saved successfully.\"); // Check if we came from an item; if so, route back to that item page.\n\n      if (router.query.from === \"item\" && router.query.itemId) {\n        router.push(`/NewSearch/item/${router.query.itemId}`);\n      } else if (router.query.from === \"addItem\" && router.query.itemId) {\n        router.push(\"AddItem/NewItem\");\n      } else {\n        router.push(\"../../clientSearch\");\n      }\n    } catch (error) {\n      console.error(\"Error saving client:\", error);\n      setError(\"Failed to save client.\");\n    }\n  };\n\n  return __jsx(Container, {\n    className: \"mt-5\"\n  }, __jsx(Row, {\n    className: \"justify-content-md-center\"\n  }, __jsx(Col, {\n    md: \"8\"\n  }, __jsx(Card, null, __jsx(Card.Header, null, __jsx(\"h4\", null, clientId ? \"Edit Client\" : \"Add New Client\")), __jsx(Card.Body, null, error && __jsx(\"p\", {\n    className: \"text-danger\"\n  }, error), __jsx(Form, null, __jsx(Row, null, __jsx(Col, {\n    md: 6\n  }, __jsx(Form.Group, {\n    controlId: \"clientName\"\n  }, __jsx(Form.Label, null, \"Client Name\"), __jsx(Form.Control, {\n    type: \"text\",\n    placeholder: \"Enter client name\",\n    value: client.name,\n    onChange: handleChange(\"name\")\n  }))), __jsx(Col, {\n    md: 6\n  }, __jsx(Form.Group, {\n    controlId: \"clientLocation\"\n  }, __jsx(Form.Label, null, \"Location\"), __jsx(Form.Control, {\n    type: \"text\",\n    placeholder: \"Enter location\",\n    value: client.location,\n    onChange: handleChange(\"location\")\n  })))), __jsx(Row, {\n    className: \"mt-3\"\n  }, __jsx(Col, null, __jsx(Button, {\n    variant: \"primary\",\n    onClick: () => setShowClientInfoModal(true)\n  }, \"Add Machine\"), __jsx(Button, {\n    variant: \"secondary\",\n    className: \"ms-2\",\n    onClick: () => setShowMachineCreationModal(true)\n  }, \"Create Machine\"))), __jsx(Row, {\n    className: \"mt-3\"\n  }, __jsx(Col, null, __jsx(Table, {\n    striped: true,\n    bordered: true,\n    hover: true\n  }, __jsx(\"thead\", null, __jsx(\"tr\", null, __jsx(\"th\", null, \"Machine Name\"), __jsx(\"th\", null, \"Location\"), __jsx(\"th\", null, \"Actions\"))), __jsx(\"tbody\", null, addedMachines.map((machine, index) => __jsx(\"tr\", {\n    key: index\n  }, __jsx(\"td\", null, machine.name), __jsx(\"td\", null, machine.local), __jsx(\"td\", null, __jsx(Button, {\n    variant: \"danger\",\n    size: \"sm\",\n    onClick: () => handleRemoveMachine(index)\n  }, \"Remove\")))))))), __jsx(Row, {\n    className: \"mt-4\"\n  }, __jsx(Col, {\n    md: 6\n  }, __jsx(Button, {\n    variant: \"success\",\n    onClick: handleSubmit,\n    className: \"w-100\"\n  }, \"Submit\")), __jsx(Col, {\n    md: 6\n  }, __jsx(Button, {\n    variant: \"primary\",\n    onClick: () => router.back(),\n    className: \"w-100\"\n  }, \"Back\")))))))), __jsx(ClientInfoModal, {\n    show: showClientInfoModal,\n    handleClose: () => setShowClientInfoModal(false),\n    machineOptions: machineOptions,\n    setSelectedMachine: handleAddMachine\n  }), __jsx(MachineCreationModal, {\n    show: showMachineCreationModal,\n    handleClose: () => setShowMachineCreationModal(false),\n    onCreateMachine: handleCreateMachine\n  }));\n};\n\nexport default AddClient;","map":null,"metadata":{},"sourceType":"module"}