{"ast":null,"code":"import { adminDb } from \"../../../context/FirebaseAdmin\";\n\nconst normalizeList = values => {\n  const out = [];\n  (values || []).forEach(value => {\n    if (value == null) return;\n    const normalized = String(value).trim();\n    if (!normalized) return;\n    out.push(normalized);\n  });\n  return Array.from(new Set(out));\n};\n\nconst extractModelsFromDoc = (data, docId, options = {}) => {\n  const {\n    allowDocIdFallback = true\n  } = options;\n  if (!data) return allowDocIdFallback && docId ? [docId] : [];\n  if (Array.isArray(data.models)) return normalizeList(data.models);\n  if (Array.isArray(data.model)) return normalizeList(data.model);\n  if (Array.isArray(data.items)) return normalizeList(data.items);\n  if (typeof data.model === \"string\") return normalizeList([data.model]);\n  if (typeof data.name === \"string\") return normalizeList([data.name]);\n  if (allowDocIdFallback && docId) return normalizeList([docId]);\n  return [];\n};\n\nconst extractOemsFromFields = data => {\n  const out = {};\n  if (!data) return out;\n  const oemsField = data.oems || data.OEMs || data.oem || data.OEM;\n\n  if (Array.isArray(oemsField)) {\n    oemsField.forEach(entry => {\n      if (entry == null) return;\n\n      if (typeof entry === \"string\") {\n        out[entry] = out[entry] || [];\n        return;\n      }\n\n      if (typeof entry === \"object\") {\n        const name = entry.name || entry.oem || entry.OEM || entry.label || entry.value;\n        if (!name) return;\n        const models = extractModelsFromDoc(entry);\n        out[name] = normalizeList([...(out[name] || []), ...models]);\n      }\n    });\n    return out;\n  }\n\n  if (oemsField && typeof oemsField === \"object\") {\n    Object.entries(oemsField).forEach(([oem, value]) => {\n      if (value == null) return;\n\n      if (Array.isArray(value)) {\n        out[oem] = normalizeList(value);\n        return;\n      }\n\n      if (typeof value === \"object\") {\n        const models = extractModelsFromDoc(value);\n        out[oem] = normalizeList([...(out[oem] || []), ...models]);\n        return;\n      }\n\n      out[oem] = normalizeList([...(out[oem] || []), String(value).trim()]);\n    });\n  }\n\n  return out;\n};\n\nconst mergeModels = (modelsByOem, oem, incoming) => {\n  const current = modelsByOem[oem] || [];\n  modelsByOem[oem] = normalizeList([...(current || []), ...(incoming || [])]);\n};\n\nconst mergeModalityData = (targetOemsByModality, targetModelsByModalityOem, modality, modelsByOem) => {\n  if (!modality) return;\n  const oems = Object.keys(modelsByOem || {});\n\n  if (!targetModelsByModalityOem[modality]) {\n    targetModelsByModalityOem[modality] = {};\n  }\n\n  if (!targetOemsByModality[modality]) {\n    targetOemsByModality[modality] = [];\n  }\n\n  const nextOems = new Set(targetOemsByModality[modality] || []);\n  oems.forEach(oem => {\n    nextOems.add(oem);\n    mergeModels(targetModelsByModalityOem[modality], oem, modelsByOem[oem] || []);\n  });\n  targetOemsByModality[modality] = Array.from(nextOems);\n};\n\nconst readModelsFromOemSubcollection = async collectionRef => {\n  const modelSet = new Set();\n  const snap = await collectionRef.get();\n  snap.forEach(doc => {\n    const models = extractModelsFromDoc(doc.data(), doc.id);\n    models.forEach(model => modelSet.add(model));\n  });\n  return Array.from(modelSet);\n};\n\nconst readModalityFromDocumentRef = async docRef => {\n  const docSnap = await docRef.get();\n  const data = docSnap.exists ? docSnap.data() || {} : {};\n  const modelsByOem = {};\n  const fieldOems = extractOemsFromFields(data);\n  Object.entries(fieldOems).forEach(([oem, models]) => {\n    mergeModels(modelsByOem, oem, models || []);\n  });\n  const subcollections = await docRef.listCollections();\n\n  for (const sub of subcollections) {\n    const oem = sub.id;\n    const models = await readModelsFromOemSubcollection(sub);\n    mergeModels(modelsByOem, oem, models);\n  }\n\n  return {\n    modelsByOem,\n    subcollections\n  };\n};\n\nconst readModalityFromCollectionRef = async collectionRef => {\n  const modelsByOem = {};\n  const snap = await collectionRef.get();\n\n  for (const oemDoc of snap.docs) {\n    const oem = oemDoc.id;\n    const models = extractModelsFromDoc(oemDoc.data(), oemDoc.id, {\n      allowDocIdFallback: false\n    });\n    mergeModels(modelsByOem, oem, models);\n    const nested = await oemDoc.ref.listCollections();\n\n    for (const nestedCol of nested) {\n      const nestedModels = await readModelsFromOemSubcollection(nestedCol);\n      mergeModels(modelsByOem, oem, nestedModels);\n    }\n  }\n\n  return modelsByOem;\n};\n\nexport default async function handler(req, res) {\n  res.setHeader(\"Cache-Control\", \"no-store\");\n\n  if (!adminDb) {\n    res.status(503).json({\n      error: \"Firebase Admin not available.\"\n    });\n    return;\n  }\n\n  try {\n    const modalityRefs = await adminDb.collection(\"Tracker\").listDocuments();\n    const modalitySet = new Set();\n    const oemsByModality = {};\n    const modelsByModalityOem = {};\n    let usesSubcollections = false;\n\n    for (const ref of modalityRefs) {\n      const modality = ref.id;\n      const {\n        modelsByOem,\n        subcollections\n      } = await readModalityFromDocumentRef(ref);\n      if (subcollections.length) usesSubcollections = true;\n      modalitySet.add(modality);\n      mergeModalityData(oemsByModality, modelsByModalityOem, modality, modelsByOem); // Some datasets use a \"container\" document under Tracker, where each\n      // modality is stored as a subcollection of that doc.\n\n      const hasDirectModels = Object.keys(modelsByOem).length > 0;\n\n      if (!hasDirectModels && subcollections.length) {\n        for (const modalityCollection of subcollections) {\n          const nestedModality = modalityCollection.id;\n          const nestedModelsByOem = await readModalityFromCollectionRef(modalityCollection);\n          modalitySet.add(nestedModality);\n          mergeModalityData(oemsByModality, modelsByModalityOem, nestedModality, nestedModelsByOem);\n        }\n      }\n    }\n\n    const modalities = Array.from(modalitySet);\n    res.status(200).json({\n      modalities,\n      oemsByModality,\n      modelsByModalityOem,\n      usesSubcollections,\n      source: \"server\"\n    });\n  } catch (error) {\n    console.error(\"Tracker catalog API failed:\", error);\n    res.status(500).json({\n      error: \"Failed to build tracker catalog.\"\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/isavc/OneDrive/Documents/AIS/Apps/magmo/pages/api/tracker/catalog.js"],"names":["adminDb","normalizeList","values","out","forEach","value","normalized","String","trim","push","Array","from","Set","extractModelsFromDoc","data","docId","options","allowDocIdFallback","isArray","models","model","items","name","extractOemsFromFields","oemsField","oems","OEMs","oem","OEM","entry","label","Object","entries","mergeModels","modelsByOem","incoming","current","mergeModalityData","targetOemsByModality","targetModelsByModalityOem","modality","keys","nextOems","add","readModelsFromOemSubcollection","collectionRef","modelSet","snap","get","doc","id","readModalityFromDocumentRef","docRef","docSnap","exists","fieldOems","subcollections","listCollections","sub","readModalityFromCollectionRef","oemDoc","docs","nested","ref","nestedCol","nestedModels","handler","req","res","setHeader","status","json","error","modalityRefs","collection","listDocuments","modalitySet","oemsByModality","modelsByModalityOem","usesSubcollections","length","hasDirectModels","modalityCollection","nestedModality","nestedModelsByOem","modalities","source","console"],"mappings":"AAAA,SAASA,OAAT,QAAwB,gCAAxB;;AAEA,MAAMC,aAAa,GAAIC,MAAD,IAAY;AAChC,QAAMC,GAAG,GAAG,EAAZ;AACA,GAACD,MAAM,IAAI,EAAX,EAAeE,OAAf,CAAwBC,KAAD,IAAW;AAChC,QAAIA,KAAK,IAAI,IAAb,EAAmB;AACnB,UAAMC,UAAU,GAAGC,MAAM,CAACF,KAAD,CAAN,CAAcG,IAAd,EAAnB;AACA,QAAI,CAACF,UAAL,EAAiB;AACjBH,IAAAA,GAAG,CAACM,IAAJ,CAASH,UAAT;AACD,GALD;AAMA,SAAOI,KAAK,CAACC,IAAN,CAAW,IAAIC,GAAJ,CAAQT,GAAR,CAAX,CAAP;AACD,CATD;;AAWA,MAAMU,oBAAoB,GAAG,CAACC,IAAD,EAAOC,KAAP,EAAcC,OAAO,GAAG,EAAxB,KAA+B;AAC1D,QAAM;AAAEC,IAAAA,kBAAkB,GAAG;AAAvB,MAAgCD,OAAtC;AACA,MAAI,CAACF,IAAL,EAAW,OAAOG,kBAAkB,IAAIF,KAAtB,GAA8B,CAACA,KAAD,CAA9B,GAAwC,EAA/C;AACX,MAAIL,KAAK,CAACQ,OAAN,CAAcJ,IAAI,CAACK,MAAnB,CAAJ,EAAgC,OAAOlB,aAAa,CAACa,IAAI,CAACK,MAAN,CAApB;AAChC,MAAIT,KAAK,CAACQ,OAAN,CAAcJ,IAAI,CAACM,KAAnB,CAAJ,EAA+B,OAAOnB,aAAa,CAACa,IAAI,CAACM,KAAN,CAApB;AAC/B,MAAIV,KAAK,CAACQ,OAAN,CAAcJ,IAAI,CAACO,KAAnB,CAAJ,EAA+B,OAAOpB,aAAa,CAACa,IAAI,CAACO,KAAN,CAApB;AAC/B,MAAI,OAAOP,IAAI,CAACM,KAAZ,KAAsB,QAA1B,EAAoC,OAAOnB,aAAa,CAAC,CAACa,IAAI,CAACM,KAAN,CAAD,CAApB;AACpC,MAAI,OAAON,IAAI,CAACQ,IAAZ,KAAqB,QAAzB,EAAmC,OAAOrB,aAAa,CAAC,CAACa,IAAI,CAACQ,IAAN,CAAD,CAApB;AACnC,MAAIL,kBAAkB,IAAIF,KAA1B,EAAiC,OAAOd,aAAa,CAAC,CAACc,KAAD,CAAD,CAApB;AACjC,SAAO,EAAP;AACD,CAVD;;AAYA,MAAMQ,qBAAqB,GAAIT,IAAD,IAAU;AACtC,QAAMX,GAAG,GAAG,EAAZ;AACA,MAAI,CAACW,IAAL,EAAW,OAAOX,GAAP;AACX,QAAMqB,SAAS,GAAGV,IAAI,CAACW,IAAL,IAAaX,IAAI,CAACY,IAAlB,IAA0BZ,IAAI,CAACa,GAA/B,IAAsCb,IAAI,CAACc,GAA7D;;AAEA,MAAIlB,KAAK,CAACQ,OAAN,CAAcM,SAAd,CAAJ,EAA8B;AAC5BA,IAAAA,SAAS,CAACpB,OAAV,CAAmByB,KAAD,IAAW;AAC3B,UAAIA,KAAK,IAAI,IAAb,EAAmB;;AACnB,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B1B,QAAAA,GAAG,CAAC0B,KAAD,CAAH,GAAa1B,GAAG,CAAC0B,KAAD,CAAH,IAAc,EAA3B;AACA;AACD;;AACD,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,cAAMP,IAAI,GACRO,KAAK,CAACP,IAAN,IACAO,KAAK,CAACF,GADN,IAEAE,KAAK,CAACD,GAFN,IAGAC,KAAK,CAACC,KAHN,IAIAD,KAAK,CAACxB,KALR;AAMA,YAAI,CAACiB,IAAL,EAAW;AACX,cAAMH,MAAM,GAAGN,oBAAoB,CAACgB,KAAD,CAAnC;AACA1B,QAAAA,GAAG,CAACmB,IAAD,CAAH,GAAYrB,aAAa,CAAC,CAAC,IAAIE,GAAG,CAACmB,IAAD,CAAH,IAAa,EAAjB,CAAD,EAAuB,GAAGH,MAA1B,CAAD,CAAzB;AACD;AACF,KAjBD;AAkBA,WAAOhB,GAAP;AACD;;AAED,MAAIqB,SAAS,IAAI,OAAOA,SAAP,KAAqB,QAAtC,EAAgD;AAC9CO,IAAAA,MAAM,CAACC,OAAP,CAAeR,SAAf,EAA0BpB,OAA1B,CAAkC,CAAC,CAACuB,GAAD,EAAMtB,KAAN,CAAD,KAAkB;AAClD,UAAIA,KAAK,IAAI,IAAb,EAAmB;;AACnB,UAAIK,KAAK,CAACQ,OAAN,CAAcb,KAAd,CAAJ,EAA0B;AACxBF,QAAAA,GAAG,CAACwB,GAAD,CAAH,GAAW1B,aAAa,CAACI,KAAD,CAAxB;AACA;AACD;;AACD,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,cAAMc,MAAM,GAAGN,oBAAoB,CAACR,KAAD,CAAnC;AACAF,QAAAA,GAAG,CAACwB,GAAD,CAAH,GAAW1B,aAAa,CAAC,CAAC,IAAIE,GAAG,CAACwB,GAAD,CAAH,IAAY,EAAhB,CAAD,EAAsB,GAAGR,MAAzB,CAAD,CAAxB;AACA;AACD;;AACDhB,MAAAA,GAAG,CAACwB,GAAD,CAAH,GAAW1B,aAAa,CAAC,CAAC,IAAIE,GAAG,CAACwB,GAAD,CAAH,IAAY,EAAhB,CAAD,EAAsBpB,MAAM,CAACF,KAAD,CAAN,CAAcG,IAAd,EAAtB,CAAD,CAAxB;AACD,KAZD;AAaD;;AAED,SAAOL,GAAP;AACD,CA5CD;;AA8CA,MAAM8B,WAAW,GAAG,CAACC,WAAD,EAAcP,GAAd,EAAmBQ,QAAnB,KAAgC;AAClD,QAAMC,OAAO,GAAGF,WAAW,CAACP,GAAD,CAAX,IAAoB,EAApC;AACAO,EAAAA,WAAW,CAACP,GAAD,CAAX,GAAmB1B,aAAa,CAAC,CAAC,IAAImC,OAAO,IAAI,EAAf,CAAD,EAAqB,IAAID,QAAQ,IAAI,EAAhB,CAArB,CAAD,CAAhC;AACD,CAHD;;AAKA,MAAME,iBAAiB,GAAG,CACxBC,oBADwB,EAExBC,yBAFwB,EAGxBC,QAHwB,EAIxBN,WAJwB,KAKrB;AACH,MAAI,CAACM,QAAL,EAAe;AACf,QAAMf,IAAI,GAAGM,MAAM,CAACU,IAAP,CAAYP,WAAW,IAAI,EAA3B,CAAb;;AACA,MAAI,CAACK,yBAAyB,CAACC,QAAD,CAA9B,EAA0C;AACxCD,IAAAA,yBAAyB,CAACC,QAAD,CAAzB,GAAsC,EAAtC;AACD;;AACD,MAAI,CAACF,oBAAoB,CAACE,QAAD,CAAzB,EAAqC;AACnCF,IAAAA,oBAAoB,CAACE,QAAD,CAApB,GAAiC,EAAjC;AACD;;AACD,QAAME,QAAQ,GAAG,IAAI9B,GAAJ,CAAQ0B,oBAAoB,CAACE,QAAD,CAApB,IAAkC,EAA1C,CAAjB;AACAf,EAAAA,IAAI,CAACrB,OAAL,CAAcuB,GAAD,IAAS;AACpBe,IAAAA,QAAQ,CAACC,GAAT,CAAahB,GAAb;AACAM,IAAAA,WAAW,CACTM,yBAAyB,CAACC,QAAD,CADhB,EAETb,GAFS,EAGTO,WAAW,CAACP,GAAD,CAAX,IAAoB,EAHX,CAAX;AAKD,GAPD;AAQAW,EAAAA,oBAAoB,CAACE,QAAD,CAApB,GAAiC9B,KAAK,CAACC,IAAN,CAAW+B,QAAX,CAAjC;AACD,CAxBD;;AA0BA,MAAME,8BAA8B,GAAG,MAAOC,aAAP,IAAyB;AAC9D,QAAMC,QAAQ,GAAG,IAAIlC,GAAJ,EAAjB;AACA,QAAMmC,IAAI,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAnB;AACAD,EAAAA,IAAI,CAAC3C,OAAL,CAAc6C,GAAD,IAAS;AACpB,UAAM9B,MAAM,GAAGN,oBAAoB,CAACoC,GAAG,CAACnC,IAAJ,EAAD,EAAamC,GAAG,CAACC,EAAjB,CAAnC;AACA/B,IAAAA,MAAM,CAACf,OAAP,CAAgBgB,KAAD,IAAW0B,QAAQ,CAACH,GAAT,CAAavB,KAAb,CAA1B;AACD,GAHD;AAIA,SAAOV,KAAK,CAACC,IAAN,CAAWmC,QAAX,CAAP;AACD,CARD;;AAUA,MAAMK,2BAA2B,GAAG,MAAOC,MAAP,IAAkB;AACpD,QAAMC,OAAO,GAAG,MAAMD,MAAM,CAACJ,GAAP,EAAtB;AACA,QAAMlC,IAAI,GAAGuC,OAAO,CAACC,MAAR,GAAiBD,OAAO,CAACvC,IAAR,MAAkB,EAAnC,GAAwC,EAArD;AACA,QAAMoB,WAAW,GAAG,EAApB;AAEA,QAAMqB,SAAS,GAAGhC,qBAAqB,CAACT,IAAD,CAAvC;AACAiB,EAAAA,MAAM,CAACC,OAAP,CAAeuB,SAAf,EAA0BnD,OAA1B,CAAkC,CAAC,CAACuB,GAAD,EAAMR,MAAN,CAAD,KAAmB;AACnDc,IAAAA,WAAW,CAACC,WAAD,EAAcP,GAAd,EAAmBR,MAAM,IAAI,EAA7B,CAAX;AACD,GAFD;AAIA,QAAMqC,cAAc,GAAG,MAAMJ,MAAM,CAACK,eAAP,EAA7B;;AACA,OAAK,MAAMC,GAAX,IAAkBF,cAAlB,EAAkC;AAChC,UAAM7B,GAAG,GAAG+B,GAAG,CAACR,EAAhB;AACA,UAAM/B,MAAM,GAAG,MAAMyB,8BAA8B,CAACc,GAAD,CAAnD;AACAzB,IAAAA,WAAW,CAACC,WAAD,EAAcP,GAAd,EAAmBR,MAAnB,CAAX;AACD;;AAED,SAAO;AAAEe,IAAAA,WAAF;AAAesB,IAAAA;AAAf,GAAP;AACD,CAlBD;;AAoBA,MAAMG,6BAA6B,GAAG,MAAOd,aAAP,IAAyB;AAC7D,QAAMX,WAAW,GAAG,EAApB;AACA,QAAMa,IAAI,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAnB;;AAEA,OAAK,MAAMY,MAAX,IAAqBb,IAAI,CAACc,IAA1B,EAAgC;AAC9B,UAAMlC,GAAG,GAAGiC,MAAM,CAACV,EAAnB;AACA,UAAM/B,MAAM,GAAGN,oBAAoB,CAAC+C,MAAM,CAAC9C,IAAP,EAAD,EAAgB8C,MAAM,CAACV,EAAvB,EAA2B;AAC5DjC,MAAAA,kBAAkB,EAAE;AADwC,KAA3B,CAAnC;AAGAgB,IAAAA,WAAW,CAACC,WAAD,EAAcP,GAAd,EAAmBR,MAAnB,CAAX;AAEA,UAAM2C,MAAM,GAAG,MAAMF,MAAM,CAACG,GAAP,CAAWN,eAAX,EAArB;;AACA,SAAK,MAAMO,SAAX,IAAwBF,MAAxB,EAAgC;AAC9B,YAAMG,YAAY,GAAG,MAAMrB,8BAA8B,CAACoB,SAAD,CAAzD;AACA/B,MAAAA,WAAW,CAACC,WAAD,EAAcP,GAAd,EAAmBsC,YAAnB,CAAX;AACD;AACF;;AAED,SAAO/B,WAAP;AACD,CAnBD;;AAqBA,eAAe,eAAegC,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9CA,EAAAA,GAAG,CAACC,SAAJ,CAAc,eAAd,EAA+B,UAA/B;;AACA,MAAI,CAACrE,OAAL,EAAc;AACZoE,IAAAA,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAArB;AACA;AACD;;AAED,MAAI;AACF,UAAMC,YAAY,GAAG,MAAMzE,OAAO,CAAC0E,UAAR,CAAmB,SAAnB,EAA8BC,aAA9B,EAA3B;AACA,UAAMC,WAAW,GAAG,IAAIhE,GAAJ,EAApB;AACA,UAAMiE,cAAc,GAAG,EAAvB;AACA,UAAMC,mBAAmB,GAAG,EAA5B;AACA,QAAIC,kBAAkB,GAAG,KAAzB;;AAEA,SAAK,MAAMhB,GAAX,IAAkBU,YAAlB,EAAgC;AAC9B,YAAMjC,QAAQ,GAAGuB,GAAG,CAACb,EAArB;AACA,YAAM;AAAEhB,QAAAA,WAAF;AAAesB,QAAAA;AAAf,UAAkC,MAAML,2BAA2B,CACvEY,GADuE,CAAzE;AAGA,UAAIP,cAAc,CAACwB,MAAnB,EAA2BD,kBAAkB,GAAG,IAArB;AAC3BH,MAAAA,WAAW,CAACjC,GAAZ,CAAgBH,QAAhB;AACAH,MAAAA,iBAAiB,CACfwC,cADe,EAEfC,mBAFe,EAGftC,QAHe,EAIfN,WAJe,CAAjB,CAP8B,CAc9B;AACA;;AACA,YAAM+C,eAAe,GAAGlD,MAAM,CAACU,IAAP,CAAYP,WAAZ,EAAyB8C,MAAzB,GAAkC,CAA1D;;AACA,UAAI,CAACC,eAAD,IAAoBzB,cAAc,CAACwB,MAAvC,EAA+C;AAC7C,aAAK,MAAME,kBAAX,IAAiC1B,cAAjC,EAAiD;AAC/C,gBAAM2B,cAAc,GAAGD,kBAAkB,CAAChC,EAA1C;AACA,gBAAMkC,iBAAiB,GACrB,MAAMzB,6BAA6B,CAACuB,kBAAD,CADrC;AAEAN,UAAAA,WAAW,CAACjC,GAAZ,CAAgBwC,cAAhB;AACA9C,UAAAA,iBAAiB,CACfwC,cADe,EAEfC,mBAFe,EAGfK,cAHe,EAIfC,iBAJe,CAAjB;AAMD;AACF;AACF;;AAED,UAAMC,UAAU,GAAG3E,KAAK,CAACC,IAAN,CAAWiE,WAAX,CAAnB;AACAR,IAAAA,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AACnBc,MAAAA,UADmB;AAEnBR,MAAAA,cAFmB;AAGnBC,MAAAA,mBAHmB;AAInBC,MAAAA,kBAJmB;AAKnBO,MAAAA,MAAM,EAAE;AALW,KAArB;AAOD,GAhDD,CAgDE,OAAOd,KAAP,EAAc;AACde,IAAAA,OAAO,CAACf,KAAR,CAAc,6BAAd,EAA6CA,KAA7C;AACAJ,IAAAA,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAArB;AACD;AACF","sourcesContent":["import { adminDb } from \"../../../context/FirebaseAdmin\";\n\r\nconst normalizeList = (values) => {\n  const out = [];\r\n  (values || []).forEach((value) => {\r\n    if (value == null) return;\r\n    const normalized = String(value).trim();\r\n    if (!normalized) return;\r\n    out.push(normalized);\r\n  });\r\n  return Array.from(new Set(out));\r\n};\r\n\r\nconst extractModelsFromDoc = (data, docId, options = {}) => {\n  const { allowDocIdFallback = true } = options;\n  if (!data) return allowDocIdFallback && docId ? [docId] : [];\n  if (Array.isArray(data.models)) return normalizeList(data.models);\n  if (Array.isArray(data.model)) return normalizeList(data.model);\n  if (Array.isArray(data.items)) return normalizeList(data.items);\n  if (typeof data.model === \"string\") return normalizeList([data.model]);\n  if (typeof data.name === \"string\") return normalizeList([data.name]);\n  if (allowDocIdFallback && docId) return normalizeList([docId]);\n  return [];\n};\n\r\nconst extractOemsFromFields = (data) => {\n  const out = {};\r\n  if (!data) return out;\r\n  const oemsField = data.oems || data.OEMs || data.oem || data.OEM;\r\n\r\n  if (Array.isArray(oemsField)) {\r\n    oemsField.forEach((entry) => {\r\n      if (entry == null) return;\r\n      if (typeof entry === \"string\") {\r\n        out[entry] = out[entry] || [];\r\n        return;\r\n      }\r\n      if (typeof entry === \"object\") {\r\n        const name =\r\n          entry.name ||\r\n          entry.oem ||\r\n          entry.OEM ||\r\n          entry.label ||\r\n          entry.value;\r\n        if (!name) return;\r\n        const models = extractModelsFromDoc(entry);\r\n        out[name] = normalizeList([...(out[name] || []), ...models]);\r\n      }\r\n    });\r\n    return out;\r\n  }\r\n\r\n  if (oemsField && typeof oemsField === \"object\") {\r\n    Object.entries(oemsField).forEach(([oem, value]) => {\r\n      if (value == null) return;\r\n      if (Array.isArray(value)) {\r\n        out[oem] = normalizeList(value);\r\n        return;\r\n      }\r\n      if (typeof value === \"object\") {\r\n        const models = extractModelsFromDoc(value);\r\n        out[oem] = normalizeList([...(out[oem] || []), ...models]);\r\n        return;\r\n      }\r\n      out[oem] = normalizeList([...(out[oem] || []), String(value).trim()]);\r\n    });\r\n  }\r\n\r\n  return out;\r\n};\n\nconst mergeModels = (modelsByOem, oem, incoming) => {\n  const current = modelsByOem[oem] || [];\n  modelsByOem[oem] = normalizeList([...(current || []), ...(incoming || [])]);\n};\n\nconst mergeModalityData = (\n  targetOemsByModality,\n  targetModelsByModalityOem,\n  modality,\n  modelsByOem\n) => {\n  if (!modality) return;\n  const oems = Object.keys(modelsByOem || {});\n  if (!targetModelsByModalityOem[modality]) {\n    targetModelsByModalityOem[modality] = {};\n  }\n  if (!targetOemsByModality[modality]) {\n    targetOemsByModality[modality] = [];\n  }\n  const nextOems = new Set(targetOemsByModality[modality] || []);\n  oems.forEach((oem) => {\n    nextOems.add(oem);\n    mergeModels(\n      targetModelsByModalityOem[modality],\n      oem,\n      modelsByOem[oem] || []\n    );\n  });\n  targetOemsByModality[modality] = Array.from(nextOems);\n};\n\nconst readModelsFromOemSubcollection = async (collectionRef) => {\n  const modelSet = new Set();\n  const snap = await collectionRef.get();\n  snap.forEach((doc) => {\n    const models = extractModelsFromDoc(doc.data(), doc.id);\n    models.forEach((model) => modelSet.add(model));\n  });\n  return Array.from(modelSet);\n};\n\nconst readModalityFromDocumentRef = async (docRef) => {\n  const docSnap = await docRef.get();\n  const data = docSnap.exists ? docSnap.data() || {} : {};\n  const modelsByOem = {};\n\n  const fieldOems = extractOemsFromFields(data);\n  Object.entries(fieldOems).forEach(([oem, models]) => {\n    mergeModels(modelsByOem, oem, models || []);\n  });\n\n  const subcollections = await docRef.listCollections();\n  for (const sub of subcollections) {\n    const oem = sub.id;\n    const models = await readModelsFromOemSubcollection(sub);\n    mergeModels(modelsByOem, oem, models);\n  }\n\n  return { modelsByOem, subcollections };\n};\n\nconst readModalityFromCollectionRef = async (collectionRef) => {\n  const modelsByOem = {};\n  const snap = await collectionRef.get();\n\n  for (const oemDoc of snap.docs) {\n    const oem = oemDoc.id;\n    const models = extractModelsFromDoc(oemDoc.data(), oemDoc.id, {\n      allowDocIdFallback: false,\n    });\n    mergeModels(modelsByOem, oem, models);\n\n    const nested = await oemDoc.ref.listCollections();\n    for (const nestedCol of nested) {\n      const nestedModels = await readModelsFromOemSubcollection(nestedCol);\n      mergeModels(modelsByOem, oem, nestedModels);\n    }\n  }\n\n  return modelsByOem;\n};\n\r\nexport default async function handler(req, res) {\r\n  res.setHeader(\"Cache-Control\", \"no-store\");\r\n  if (!adminDb) {\r\n    res.status(503).json({ error: \"Firebase Admin not available.\" });\r\n    return;\r\n  }\r\n\r\n  try {\n    const modalityRefs = await adminDb.collection(\"Tracker\").listDocuments();\n    const modalitySet = new Set();\n    const oemsByModality = {};\n    const modelsByModalityOem = {};\n    let usesSubcollections = false;\n\n    for (const ref of modalityRefs) {\n      const modality = ref.id;\n      const { modelsByOem, subcollections } = await readModalityFromDocumentRef(\n        ref\n      );\n      if (subcollections.length) usesSubcollections = true;\n      modalitySet.add(modality);\n      mergeModalityData(\n        oemsByModality,\n        modelsByModalityOem,\n        modality,\n        modelsByOem\n      );\n\n      // Some datasets use a \"container\" document under Tracker, where each\n      // modality is stored as a subcollection of that doc.\n      const hasDirectModels = Object.keys(modelsByOem).length > 0;\n      if (!hasDirectModels && subcollections.length) {\n        for (const modalityCollection of subcollections) {\n          const nestedModality = modalityCollection.id;\n          const nestedModelsByOem =\n            await readModalityFromCollectionRef(modalityCollection);\n          modalitySet.add(nestedModality);\n          mergeModalityData(\n            oemsByModality,\n            modelsByModalityOem,\n            nestedModality,\n            nestedModelsByOem\n          );\n        }\n      }\n    }\n\n    const modalities = Array.from(modalitySet);\n    res.status(200).json({\n      modalities,\n      oemsByModality,\n      modelsByModalityOem,\r\n      usesSubcollections,\r\n      source: \"server\",\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Tracker catalog API failed:\", error);\r\n    res.status(500).json({ error: \"Failed to build tracker catalog.\" });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}