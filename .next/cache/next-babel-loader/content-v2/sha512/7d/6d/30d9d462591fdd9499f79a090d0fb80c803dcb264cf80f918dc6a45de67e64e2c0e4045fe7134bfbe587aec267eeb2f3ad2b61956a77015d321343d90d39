{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport firebase from \"../context/Firebase\";\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(partsSnapshot.docs.map(async partDoc => {\n    var _ref, _getRefId, _ref2, _getRefId2;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    const getRefId = ref => {\n      if (!ref) return null;\n      if (typeof ref === \"string\") return ref;\n      if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n      if (ref.id) return ref.id;\n      return null;\n    };\n\n    partData.clientFromId = (_ref = (_getRefId = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientFrom)) !== null && _getRefId !== void 0 ? _getRefId : partData === null || partData === void 0 ? void 0 : partData.clientFromId) !== null && _ref !== void 0 ? _ref : null;\n    partData.clientCurrentId = (_ref2 = (_getRefId2 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientCurrent)) !== null && _getRefId2 !== void 0 ? _getRefId2 : partData === null || partData === void 0 ? void 0 : partData.clientCurrentId) !== null && _ref2 !== void 0 ? _ref2 : null; // console.log(partData);\n\n    const fetchMachineData = async ref => {\n      if (!ref) return null;\n\n      if (typeof ref.get === \"function\") {\n        const doc = await ref.get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (typeof ref === \"string\") {\n        const doc = await db.collection(\"Machine\").doc(ref).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (ref !== null && ref !== void 0 && ref.id) {\n        const doc = await db.collection(\"Machine\").doc(ref.id).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      return null;\n    };\n\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef = partData.CurrentMachine || partData.MachineCurrent;\n    const machineData = await fetchMachineData(machineRef);\n    partData.machineData = machineData || {};\n\n    if (machineData !== null && machineData !== void 0 && machineData.client) {\n      const clientRef = machineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (clientId && !partData.clientFromId) {\n        partData.clientFromId = clientId;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    const currentMachineData = await fetchMachineData(currentMachineRef);\n    partData.currentMachineData = currentMachineData || {};\n\n    if (currentMachineData !== null && currentMachineData !== void 0 && currentMachineData.client) {\n      const clientRef = currentMachineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (clientId && !partData.clientCurrentId) {\n        partData.clientCurrentId = clientId;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.currentMachineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    return partData;\n  }));\n  return parts;\n} // Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\n\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false,\n  filterFn = null,\n  needsMachineData = true,\n  search = null\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const getRefId = ref => {\n    if (!ref) return null;\n    if (typeof ref === \"string\") return ref;\n    if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n    if (ref.id) return ref.id;\n    return null;\n  };\n\n  const MACHINE_SELECT_FIELDS = [\"OEM\", \"Modality\", \"Model\", \"client\", \"name\"];\n\n  const withMachineSelect = query => typeof query.select === \"function\" ? query.select(...MACHINE_SELECT_FIELDS) : query;\n\n  const buildPart = (partDoc, machineMap, currentMachineMap) => {\n    var _ref3, _getRefId3, _ref4, _getRefId4;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    partData.clientFromId = (_ref3 = (_getRefId3 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientFrom)) !== null && _getRefId3 !== void 0 ? _getRefId3 : partData === null || partData === void 0 ? void 0 : partData.clientFromId) !== null && _ref3 !== void 0 ? _ref3 : null;\n    partData.clientCurrentId = (_ref4 = (_getRefId4 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientCurrent)) !== null && _getRefId4 !== void 0 ? _getRefId4 : partData === null || partData === void 0 ? void 0 : partData.clientCurrentId) !== null && _ref4 !== void 0 ? _ref4 : null;\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef = partData.CurrentMachine || partData.MachineCurrent;\n    const machineId = getRefId(machineRef);\n    const currentMachineId = getRefId(currentMachineRef);\n    const machineData = machineId ? machineMap[machineId] : null;\n    const currentMachineData = currentMachineId ? currentMachineMap[currentMachineId] : null;\n    partData.machineData = machineData || {};\n    partData.currentMachineData = currentMachineData || {};\n\n    if (!partData.clientFromId && machineData !== null && machineData !== void 0 && machineData.client) {\n      partData.clientFromId = getRefId(machineData.client);\n    }\n\n    if (!partData.clientCurrentId && currentMachineData !== null && currentMachineData !== void 0 && currentMachineData.client) {\n      partData.clientCurrentId = getRefId(currentMachineData.client);\n    }\n\n    return partData;\n  };\n\n  const searchRaw = ((search === null || search === void 0 ? void 0 : search.raw) || \"\").toString().trim();\n  const searchLower = ((search === null || search === void 0 ? void 0 : search.lower) || \"\").toString().trim();\n  const searchType = (search === null || search === void 0 ? void 0 : search.type) || null;\n  const hasSearch = Boolean(searchRaw);\n\n  const toTitleCase = text => text.split(\" \").filter(Boolean).map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(\" \");\n\n  const buildSearchQuery = () => {\n    if (!hasSearch || !searchType) return {\n      mode: \"scan\",\n      query: null\n    };\n    const col = db.collection(\"Test\");\n\n    switch (searchType) {\n      case \"SKU\":\n        return {\n          mode: \"sku\",\n          query: null\n        };\n\n      case \"Name\":\n        {\n          const titleFallback = searchRaw && searchRaw === searchRaw.toLowerCase() ? toTitleCase(searchRaw) : null;\n          const terms = searchLower ? searchLower.split(/\\s+/).filter(Boolean) : [];\n          const tokens = [...terms];\n          if (searchLower && !tokens.includes(searchLower)) tokens.push(searchLower);\n          if (!tokens.length) return {\n            mode: \"scan\",\n            query: null\n          };\n\n          const prefixQuery = value => col.orderBy(\"name\").startAt(value).endAt(`${value}\\uf8ff`);\n\n          return {\n            mode: \"query\",\n            query: tokens.length === 1 ? col.where(\"nameTokens\", \"array-contains\", tokens[0]) : col.where(\"nameTokens\", \"array-contains-any\", tokens.slice(0, 10)),\n            fallback: titleFallback ? () => prefixQuery(titleFallback) : () => prefixQuery(searchRaw)\n          };\n        }\n\n      case \"Product Number\":\n        return {\n          mode: \"query\",\n          query: col.where(\"pn\", \"array-contains\", searchRaw),\n          fallback: () => col.where(\"pn\", \"==\", searchRaw)\n        };\n\n      case \"Serial Number\":\n        return {\n          mode: \"query\",\n          query: col.where(\"sn\", \"array-contains\", searchRaw),\n          fallback: () => col.where(\"sn\", \"==\", searchRaw)\n        };\n\n      case \"Date\":\n        {\n          const asDate = (() => {\n            try {\n              const d = new Date(searchRaw);\n              return isNaN(d.getTime()) ? null : d;\n            } catch {\n              return null;\n            }\n          })();\n\n          return {\n            mode: \"query\",\n            query: col.where(\"date\", \"==\", searchRaw),\n            fallback: asDate ? () => col.where(\"date\", \"==\", asDate) : null\n          };\n        }\n\n      default:\n        return {\n          mode: \"scan\",\n          query: null\n        };\n    }\n  };\n\n  const {\n    mode: searchMode,\n    query: searchQuery,\n    fallback: searchFallback\n  } = buildSearchQuery();\n\n  if (searchMode === \"sku\" && hasSearch) {\n    const docs = [];\n    const rawUpper = searchRaw.toUpperCase();\n    let doc = await db.collection(\"Test\").doc(searchRaw).get();\n\n    if (!doc.exists && rawUpper !== searchRaw) {\n      doc = await db.collection(\"Test\").doc(rawUpper).get();\n    }\n\n    if (doc.exists) docs.push(doc);\n    const localValues = rawUpper !== searchRaw ? [searchRaw, rawUpper] : [searchRaw];\n    const localSnap = await db.collection(\"Test\").where(\"localSN\", \"in\", localValues).limit(limit).get();\n    localSnap.forEach(d => {\n      if (!docs.find(existing => existing.id === d.id)) {\n        docs.push(d);\n      }\n    });\n    let machineMap = {};\n    let currentMachineMap = {};\n\n    if (needsMachineData && docs.length) {\n      const machineIds = new Set();\n      const currentMachineIds = new Set();\n\n      for (const docSnap of docs) {\n        const raw = docSnap.data();\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\n        const currentMachineId = getRefId(raw.CurrentMachine || raw.MachineCurrent);\n        if (machineId) machineIds.add(machineId);\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\n      }\n\n      const fetchMachineMap = async ids => {\n        if (!ids.length) return {};\n        const out = {};\n        const chunks = [];\n\n        for (let i = 0; i < ids.length; i += 10) {\n          chunks.push(ids.slice(i, i + 10));\n        }\n\n        for (const chunk of chunks) {\n          const snap = await withMachineSelect(db.collection(\"Machine\").where(firebase.firestore.FieldPath.documentId(), \"in\", chunk)).get();\n          snap.forEach(docSnap => {\n            out[docSnap.id] = docSnap.data() || {};\n          });\n        }\n\n        return out;\n      };\n\n      [machineMap, currentMachineMap] = await Promise.all([fetchMachineMap([...machineIds]), fetchMachineMap([...currentMachineIds])]);\n    }\n\n    const built = docs.map(docSnap => buildPart(docSnap, machineMap, currentMachineMap)).filter(item => !visibleOnly || (item === null || item === void 0 ? void 0 : item.visible) !== false).filter(item => filterFn ? filterFn(item) : true).slice(0, pageSize);\n    return {\n      parts: built,\n      lastDoc: built.length ? docs[built.length - 1] : null,\n      hasNextPage: false\n    };\n  }\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let pageLastDoc = null;\n  let hasNextPage = false;\n  let filled = false;\n  let usedFallback = false;\n  const scanBaseQuery = db.collection(\"Test\").orderBy(firebase.firestore.FieldPath.documentId());\n\n  while (true) {\n    let query = searchQuery || scanBaseQuery;\n\n    if (searchMode === \"query\" && usedFallback && searchFallback) {\n      query = searchFallback();\n    }\n\n    if (cursor) query = query.startAfter(cursor);\n    query = query.limit(limit);\n    const snap = await query.get();\n\n    if (snap.empty) {\n      if (searchMode === \"query\" && searchFallback && !cursor && !usedFallback) {\n        usedFallback = true;\n        continue;\n      }\n\n      hasNextPage = false;\n      break;\n    }\n\n    const batchDocs = snap.docs;\n    let machineMap = {};\n    let currentMachineMap = {};\n\n    if (needsMachineData) {\n      const machineIds = new Set();\n      const currentMachineIds = new Set();\n\n      for (const doc of batchDocs) {\n        const raw = doc.data();\n\n        if (visibleOnly && raw.visible === false) {\n          continue;\n        }\n\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\n        const currentMachineId = getRefId(raw.CurrentMachine || raw.MachineCurrent);\n        if (machineId) machineIds.add(machineId);\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\n      }\n\n      const fetchMachineMap = async ids => {\n        if (!ids.length) return {};\n        const out = {};\n        const chunks = [];\n\n        for (let i = 0; i < ids.length; i += 10) {\n          chunks.push(ids.slice(i, i + 10));\n        }\n\n        for (const chunk of chunks) {\n          const snap = await withMachineSelect(db.collection(\"Machine\").where(firebase.firestore.FieldPath.documentId(), \"in\", chunk)).get();\n          snap.forEach(doc => {\n            out[doc.id] = doc.data() || {};\n          });\n        }\n\n        return out;\n      };\n\n      [machineMap, currentMachineMap] = await Promise.all([fetchMachineMap([...machineIds]), fetchMachineMap([...currentMachineIds])]);\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = batchDocs[i];\n      cursor = doc;\n      const raw = doc.data();\n\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      const built = buildPart(doc, machineMap, currentMachineMap);\n\n      if (filterFn && !filterFn(built)) {\n        continue;\n      }\n\n      if (!filled) {\n        parts.push(built);\n\n        if (parts.length === pageSize) {\n          filled = true;\n          pageLastDoc = doc;\n        }\n\n        continue;\n      } // We already filled the page and found an extra matching item.\n\n\n      hasNextPage = true;\n      return {\n        parts,\n        lastDoc: pageLastDoc,\n        hasNextPage\n      };\n    } // We exhausted this batch without filling the page.\n\n\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    } // There might be more docs; continue scanning for visible items.\n\n\n    hasNextPage = true;\n  }\n\n  lastDoc = pageLastDoc || (parts.length ? cursor : null);\n  return {\n    parts,\n    lastDoc,\n    hasNextPage: filled ? hasNextPage : false\n  };\n}\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const normalizeText = value => {\n    if (value == null) return \"\";\n    return String(value).toLowerCase().trim();\n  };\n\n  const fieldMatchesSelection = (value, selected) => {\n    if (!selected) return false;\n\n    if (Array.isArray(value)) {\n      return value.some(entry => fieldMatchesSelection(entry, selected));\n    }\n\n    return normalizeText(value) === normalizeText(selected);\n  };\n\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map(doc => _objectSpread({\n    id: doc.id\n  }, doc.data())); // Filter clients based on OEM and Modality if selected\n\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n\n    for (const client of clients) {\n      let match = true;\n\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          var _machineData$OEM, _machineData$Modality;\n\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n\n          if (selectedOEM && fieldMatchesSelection((_machineData$OEM = machineData.OEM) !== null && _machineData$OEM !== void 0 ? _machineData$OEM : machineData.oem, selectedOEM) || selectedModality && fieldMatchesSelection((_machineData$Modality = machineData.Modality) !== null && _machineData$Modality !== void 0 ? _machineData$Modality : machineData.modality, selectedModality)) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n\n    return filteredClients;\n  }\n\n  return clients;\n}\nexport async function fetchModels(selectedOEM, selectedModality, selectedClient) {\n  const normalizeText = value => {\n    if (value == null) return \"\";\n    return String(value).toLowerCase().trim();\n  };\n\n  const fieldMatchesSelection = (value, selected) => {\n    if (!selected) return true;\n\n    if (Array.isArray(value)) {\n      return value.some(entry => fieldMatchesSelection(entry, selected));\n    }\n\n    return normalizeText(value) === normalizeText(selected);\n  };\n\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n  await Promise.all(machinesSnapshot.docs.map(async machineDoc => {\n    var _machineData$OEM2, _machineData$Modality2;\n\n    const machineData = machineDoc.data();\n    let isValid = true;\n    if (!fieldMatchesSelection((_machineData$OEM2 = machineData.OEM) !== null && _machineData$OEM2 !== void 0 ? _machineData$OEM2 : machineData.oem, selectedOEM)) isValid = false;\n    if (!fieldMatchesSelection((_machineData$Modality2 = machineData.Modality) !== null && _machineData$Modality2 !== void 0 ? _machineData$Modality2 : machineData.modality, selectedModality)) isValid = false;\n\n    if (selectedClient && machineData.client) {\n      var _machineData$client;\n\n      let clientDoc = null;\n\n      if (typeof ((_machineData$client = machineData.client) === null || _machineData$client === void 0 ? void 0 : _machineData$client.get) === \"function\") {\n        clientDoc = await machineData.client.get();\n      } else if (typeof machineData.client === \"string\") {\n        clientDoc = await db.collection(\"Client\").doc(machineData.client).get();\n      }\n\n      if (!clientDoc || !clientDoc.exists) {\n        isValid = false;\n      } else {\n        const clientName = clientDoc.data().name;\n        const clientId = clientDoc.id;\n\n        if (selectedClient !== clientName && selectedClient !== clientId) {\n          isValid = false;\n        }\n      }\n    }\n\n    if (isValid) {\n      var _machineData$Model;\n\n      const modelValue = (_machineData$Model = machineData.Model) !== null && _machineData$Model !== void 0 ? _machineData$Model : machineData.model;\n\n      if (Array.isArray(modelValue)) {\n        modelValue.forEach(entry => entry && models.add(entry));\n      } else if (modelValue) {\n        models.add(modelValue);\n      }\n    }\n  }));\n  return Array.from(models);\n}\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}","map":{"version":3,"sources":["C:/Users/isavc/OneDrive/Documents/AIS/Apps/magmo/utils/fetchAssociations.js"],"names":["React","firebase","fetchPartsWithMachineData","db","firestore","partsSnapshot","collection","get","parts","Promise","all","docs","map","partDoc","partData","data","id","getRefId","ref","DocumentReference","clientFromId","ClientFrom","clientCurrentId","ClientCurrent","fetchMachineData","doc","exists","machineRef","Machine","MachineFrom","currentMachineRef","CurrentMachine","MachineCurrent","machineData","client","clientRef","clientId","clientDoc","Client","name","currentMachineData","fetchPartsWithMachineDataPage","pageSize","startAfterDoc","visibleOnly","filterFn","needsMachineData","search","limit","MACHINE_SELECT_FIELDS","withMachineSelect","query","select","buildPart","machineMap","currentMachineMap","machineId","currentMachineId","searchRaw","raw","toString","trim","searchLower","lower","searchType","type","hasSearch","Boolean","toTitleCase","text","split","filter","word","charAt","toUpperCase","slice","join","buildSearchQuery","mode","col","titleFallback","toLowerCase","terms","tokens","includes","push","length","prefixQuery","value","orderBy","startAt","endAt","where","fallback","asDate","d","Date","isNaN","getTime","searchMode","searchQuery","searchFallback","rawUpper","localValues","localSnap","forEach","find","existing","machineIds","Set","currentMachineIds","docSnap","add","fetchMachineMap","ids","out","chunks","i","chunk","snap","FieldPath","documentId","built","item","visible","lastDoc","hasNextPage","cursor","pageLastDoc","filled","usedFallback","scanBaseQuery","startAfter","empty","batchDocs","size","fetchClients","selectedOEM","selectedModality","normalizeText","String","fieldMatchesSelection","selected","Array","isArray","some","entry","clientsSnapshot","clients","filteredClients","match","machines","machineDoc","OEM","oem","Modality","modality","fetchModels","selectedClient","machinesSnapshot","models","isValid","clientName","modelValue","Model","model","from","formatDate","timestamp","date","toDate","day","getDate","padStart","month","getMonth","year","getFullYear"],"mappings":"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","sourcesContent":["import React from 'react'\r\nimport firebase from \"../context/Firebase\";\r\n\r\nexport async function fetchPartsWithMachineData() {\r\n  const db = firebase.firestore();\r\n  const partsSnapshot = await db.collection(\"Test\").get();\r\n  const parts = await Promise.all(\r\n    partsSnapshot.docs.map(async (partDoc) => {\r\n      const partData = partDoc.data();\r\n      partData.id = partDoc.id; // Add document ID here\r\n      const getRefId = (ref) => {\r\n        if (!ref) return null;\r\n        if (typeof ref === \"string\") return ref;\r\n        if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\r\n        if (ref.id) return ref.id;\r\n        return null;\r\n      };\r\n      partData.clientFromId =\r\n        getRefId(partData?.ClientFrom) ?? partData?.clientFromId ?? null;\r\n      partData.clientCurrentId =\r\n        getRefId(partData?.ClientCurrent) ?? partData?.clientCurrentId ?? null;\r\n      // console.log(partData);\r\n      const fetchMachineData = async (ref) => {\r\n        if (!ref) return null;\r\n        if (typeof ref.get === \"function\") {\r\n          const doc = await ref.get();\r\n          return doc.exists ? doc.data() : null;\r\n        }\r\n        if (typeof ref === \"string\") {\r\n          const doc = await db.collection(\"Machine\").doc(ref).get();\r\n          return doc.exists ? doc.data() : null;\r\n        }\r\n        if (ref?.id) {\r\n          const doc = await db.collection(\"Machine\").doc(ref.id).get();\r\n          return doc.exists ? doc.data() : null;\r\n        }\r\n        return null;\r\n      };\r\n\r\n      const machineRef = partData.Machine || partData.MachineFrom;\r\n      const currentMachineRef =\r\n        partData.CurrentMachine || partData.MachineCurrent;\r\n\r\n      const machineData = await fetchMachineData(machineRef);\r\n      partData.machineData = machineData || {};\r\n      if (machineData?.client) {\r\n        const clientRef = machineData.client;\r\n        const clientId = getRefId(clientRef);\r\n        if (clientId && !partData.clientFromId) {\r\n          partData.clientFromId = clientId;\r\n        }\r\n        if (typeof clientRef?.get === \"function\") {\r\n          const clientDoc = await clientRef.get();\r\n          partData.machineData.Client = clientDoc.exists\r\n            ? clientDoc.data().name\r\n            : \"\";\r\n        }\r\n      }\r\n\r\n      const currentMachineData = await fetchMachineData(currentMachineRef);\r\n      partData.currentMachineData = currentMachineData || {};\r\n      if (currentMachineData?.client) {\r\n        const clientRef = currentMachineData.client;\r\n        const clientId = getRefId(clientRef);\r\n        if (clientId && !partData.clientCurrentId) {\r\n          partData.clientCurrentId = clientId;\r\n        }\r\n        if (typeof clientRef?.get === \"function\") {\r\n          const clientDoc = await clientRef.get();\r\n          partData.currentMachineData.Client = clientDoc.exists\r\n            ? clientDoc.data().name\r\n            : \"\";\r\n        }\r\n      }\r\n      return partData;\r\n    })\r\n  );\r\n  return parts;\r\n}\r\n\r\n// Paginated version for faster list views (e.g., mainSearch).\r\n// Uses documentId order for stable pagination.\r\nexport async function fetchPartsWithMachineDataPage({\r\n  pageSize = 25,\r\n  startAfterDoc = null,\r\n  visibleOnly = false,\r\n  filterFn = null,\r\n  needsMachineData = true,\r\n  search = null,\r\n} = {}) {\r\n  const db = firebase.firestore();\r\n  const limit = pageSize + 1;\r\n\r\n  const getRefId = (ref) => {\r\n    if (!ref) return null;\r\n    if (typeof ref === \"string\") return ref;\r\n    if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\r\n    if (ref.id) return ref.id;\r\n    return null;\r\n  };\r\n\r\n  const MACHINE_SELECT_FIELDS = [\"OEM\", \"Modality\", \"Model\", \"client\", \"name\"];\r\n  const withMachineSelect = (query) =>\r\n    typeof query.select === \"function\"\r\n      ? query.select(...MACHINE_SELECT_FIELDS)\r\n      : query;\r\n\r\n  const buildPart = (partDoc, machineMap, currentMachineMap) => {\r\n    const partData = partDoc.data();\r\n    partData.id = partDoc.id; // Add document ID here\r\n    partData.clientFromId =\r\n      getRefId(partData?.ClientFrom) ?? partData?.clientFromId ?? null;\r\n    partData.clientCurrentId =\r\n      getRefId(partData?.ClientCurrent) ?? partData?.clientCurrentId ?? null;\r\n\r\n    const machineRef = partData.Machine || partData.MachineFrom;\r\n    const currentMachineRef =\r\n      partData.CurrentMachine || partData.MachineCurrent;\r\n\r\n    const machineId = getRefId(machineRef);\r\n    const currentMachineId = getRefId(currentMachineRef);\r\n\r\n    const machineData = machineId ? machineMap[machineId] : null;\r\n    const currentMachineData = currentMachineId\r\n      ? currentMachineMap[currentMachineId]\r\n      : null;\r\n\r\n    partData.machineData = machineData || {};\r\n    partData.currentMachineData = currentMachineData || {};\r\n\r\n    if (!partData.clientFromId && machineData?.client) {\r\n      partData.clientFromId = getRefId(machineData.client);\r\n    }\r\n    if (!partData.clientCurrentId && currentMachineData?.client) {\r\n      partData.clientCurrentId = getRefId(currentMachineData.client);\r\n    }\r\n\r\n    return partData;\r\n  };\r\n\r\n  const searchRaw = (search?.raw || \"\").toString().trim();\r\n  const searchLower = (search?.lower || \"\").toString().trim();\r\n  const searchType = search?.type || null;\r\n  const hasSearch = Boolean(searchRaw);\r\n\r\n  const toTitleCase = (text) =>\r\n    text\r\n      .split(\" \")\r\n      .filter(Boolean)\r\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\r\n      .join(\" \");\r\n\r\n  const buildSearchQuery = () => {\r\n    if (!hasSearch || !searchType) return { mode: \"scan\", query: null };\r\n    const col = db.collection(\"Test\");\r\n\r\n    switch (searchType) {\r\n      case \"SKU\":\r\n        return { mode: \"sku\", query: null };\r\n      case \"Name\": {\r\n        const titleFallback =\r\n          searchRaw && searchRaw === searchRaw.toLowerCase()\r\n            ? toTitleCase(searchRaw)\r\n            : null;\r\n        const terms = searchLower ? searchLower.split(/\\s+/).filter(Boolean) : [];\r\n        const tokens = [...terms];\r\n        if (searchLower && !tokens.includes(searchLower)) tokens.push(searchLower);\r\n        if (!tokens.length) return { mode: \"scan\", query: null };\r\n\r\n        const prefixQuery = (value) =>\r\n          col.orderBy(\"name\").startAt(value).endAt(`${value}\\uf8ff`);\r\n\r\n        return {\r\n          mode: \"query\",\r\n          query:\r\n            tokens.length === 1\r\n              ? col.where(\"nameTokens\", \"array-contains\", tokens[0])\r\n              : col.where(\r\n                  \"nameTokens\",\r\n                  \"array-contains-any\",\r\n                  tokens.slice(0, 10)\r\n                ),\r\n          fallback: titleFallback\r\n            ? () => prefixQuery(titleFallback)\r\n            : () => prefixQuery(searchRaw),\r\n        };\r\n      }\r\n      case \"Product Number\":\r\n        return {\r\n          mode: \"query\",\r\n          query: col.where(\"pn\", \"array-contains\", searchRaw),\r\n          fallback: () => col.where(\"pn\", \"==\", searchRaw),\r\n        };\r\n      case \"Serial Number\":\r\n        return {\r\n          mode: \"query\",\r\n          query: col.where(\"sn\", \"array-contains\", searchRaw),\r\n          fallback: () => col.where(\"sn\", \"==\", searchRaw),\r\n        };\r\n      case \"Date\": {\r\n        const asDate = (() => {\r\n          try {\r\n            const d = new Date(searchRaw);\r\n            return isNaN(d.getTime()) ? null : d;\r\n          } catch {\r\n            return null;\r\n          }\r\n        })();\r\n        return {\r\n          mode: \"query\",\r\n          query: col.where(\"date\", \"==\", searchRaw),\r\n          fallback: asDate ? () => col.where(\"date\", \"==\", asDate) : null,\r\n        };\r\n      }\r\n      default:\r\n        return { mode: \"scan\", query: null };\r\n    }\r\n  };\r\n\r\n  const { mode: searchMode, query: searchQuery, fallback: searchFallback } =\r\n    buildSearchQuery();\r\n\r\n  if (searchMode === \"sku\" && hasSearch) {\r\n    const docs = [];\r\n    const rawUpper = searchRaw.toUpperCase();\r\n    let doc = await db.collection(\"Test\").doc(searchRaw).get();\r\n    if (!doc.exists && rawUpper !== searchRaw) {\r\n      doc = await db.collection(\"Test\").doc(rawUpper).get();\r\n    }\r\n    if (doc.exists) docs.push(doc);\r\n\r\n    const localValues =\r\n      rawUpper !== searchRaw ? [searchRaw, rawUpper] : [searchRaw];\r\n    const localSnap = await db\r\n      .collection(\"Test\")\r\n      .where(\"localSN\", \"in\", localValues)\r\n      .limit(limit)\r\n      .get();\r\n    localSnap.forEach((d) => {\r\n      if (!docs.find((existing) => existing.id === d.id)) {\r\n        docs.push(d);\r\n      }\r\n    });\r\n\r\n    let machineMap = {};\r\n    let currentMachineMap = {};\r\n    if (needsMachineData && docs.length) {\r\n      const machineIds = new Set();\r\n      const currentMachineIds = new Set();\r\n      for (const docSnap of docs) {\r\n        const raw = docSnap.data();\r\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\r\n        const currentMachineId = getRefId(\r\n          raw.CurrentMachine || raw.MachineCurrent\r\n        );\r\n        if (machineId) machineIds.add(machineId);\r\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\r\n      }\r\n      const fetchMachineMap = async (ids) => {\r\n        if (!ids.length) return {};\r\n        const out = {};\r\n        const chunks = [];\r\n        for (let i = 0; i < ids.length; i += 10) {\r\n          chunks.push(ids.slice(i, i + 10));\r\n        }\r\n        for (const chunk of chunks) {\r\n          const snap = await withMachineSelect(\r\n            db\r\n              .collection(\"Machine\")\r\n              .where(firebase.firestore.FieldPath.documentId(), \"in\", chunk)\r\n          ).get();\r\n          snap.forEach((docSnap) => {\r\n            out[docSnap.id] = docSnap.data() || {};\r\n          });\r\n        }\r\n        return out;\r\n      };\r\n      [machineMap, currentMachineMap] = await Promise.all([\r\n        fetchMachineMap([...machineIds]),\r\n        fetchMachineMap([...currentMachineIds]),\r\n      ]);\r\n    }\r\n\r\n    const built = docs\r\n      .map((docSnap) => buildPart(docSnap, machineMap, currentMachineMap))\r\n      .filter((item) => (!visibleOnly || item?.visible !== false))\r\n      .filter((item) => (filterFn ? filterFn(item) : true))\r\n      .slice(0, pageSize);\r\n\r\n    return {\r\n      parts: built,\r\n      lastDoc: built.length ? docs[built.length - 1] : null,\r\n      hasNextPage: false,\r\n    };\r\n  }\r\n\r\n  let parts = [];\r\n  let cursor = startAfterDoc || null;\r\n  let lastDoc = null;\r\n  let pageLastDoc = null;\r\n  let hasNextPage = false;\r\n  let filled = false;\r\n  let usedFallback = false;\r\n  const scanBaseQuery = db\r\n    .collection(\"Test\")\r\n    .orderBy(firebase.firestore.FieldPath.documentId());\r\n\r\n  while (true) {\r\n    let query = searchQuery || scanBaseQuery;\r\n    if (searchMode === \"query\" && usedFallback && searchFallback) {\r\n      query = searchFallback();\r\n    }\r\n    if (cursor) query = query.startAfter(cursor);\r\n    query = query.limit(limit);\r\n\r\n    const snap = await query.get();\r\n    if (snap.empty) {\r\n      if (searchMode === \"query\" && searchFallback && !cursor && !usedFallback) {\r\n        usedFallback = true;\r\n        continue;\r\n      }\r\n      hasNextPage = false;\r\n      break;\r\n    }\r\n\r\n    const batchDocs = snap.docs;\r\n    let machineMap = {};\r\n    let currentMachineMap = {};\r\n\r\n    if (needsMachineData) {\r\n      const machineIds = new Set();\r\n      const currentMachineIds = new Set();\r\n      for (const doc of batchDocs) {\r\n        const raw = doc.data();\r\n        if (visibleOnly && raw.visible === false) {\r\n          continue;\r\n        }\r\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\r\n        const currentMachineId = getRefId(\r\n          raw.CurrentMachine || raw.MachineCurrent\r\n        );\r\n        if (machineId) machineIds.add(machineId);\r\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\r\n      }\r\n\r\n        const fetchMachineMap = async (ids) => {\r\n          if (!ids.length) return {};\r\n          const out = {};\r\n          const chunks = [];\r\n          for (let i = 0; i < ids.length; i += 10) {\r\n            chunks.push(ids.slice(i, i + 10));\r\n          }\r\n          for (const chunk of chunks) {\r\n            const snap = await withMachineSelect(\r\n              db\r\n                .collection(\"Machine\")\r\n                .where(firebase.firestore.FieldPath.documentId(), \"in\", chunk)\r\n            ).get();\r\n            snap.forEach((doc) => {\r\n              out[doc.id] = doc.data() || {};\r\n            });\r\n          }\r\n        return out;\r\n      };\r\n\r\n      [machineMap, currentMachineMap] = await Promise.all([\r\n        fetchMachineMap([...machineIds]),\r\n        fetchMachineMap([...currentMachineIds]),\r\n      ]);\r\n    }\r\n\r\n    for (let i = 0; i < snap.docs.length; i++) {\r\n      const doc = batchDocs[i];\r\n      cursor = doc;\r\n\r\n      const raw = doc.data();\r\n      if (visibleOnly && raw.visible === false) {\r\n        continue; // skip hidden items but keep advancing the cursor\r\n      }\r\n\r\n      const built = buildPart(doc, machineMap, currentMachineMap);\r\n      if (filterFn && !filterFn(built)) {\r\n        continue;\r\n      }\r\n\r\n      if (!filled) {\r\n        parts.push(built);\r\n        if (parts.length === pageSize) {\r\n          filled = true;\r\n          pageLastDoc = doc;\r\n        }\r\n        continue;\r\n      }\r\n\r\n      // We already filled the page and found an extra matching item.\r\n      hasNextPage = true;\r\n      return { parts, lastDoc: pageLastDoc, hasNextPage };\r\n    }\r\n\r\n    // We exhausted this batch without filling the page.\r\n    if (snap.size < limit) {\r\n      hasNextPage = false;\r\n      break;\r\n    }\r\n\r\n    // There might be more docs; continue scanning for visible items.\r\n    hasNextPage = true;\r\n  }\r\n\r\n  lastDoc = pageLastDoc || (parts.length ? cursor : null);\r\n  return { parts, lastDoc, hasNextPage: filled ? hasNextPage : false };\r\n}\r\n\r\nexport async function fetchClients(selectedOEM, selectedModality) {\r\n  const normalizeText = (value) => {\r\n    if (value == null) return \"\";\r\n    return String(value).toLowerCase().trim();\r\n  };\r\n\r\n  const fieldMatchesSelection = (value, selected) => {\r\n    if (!selected) return false;\r\n    if (Array.isArray(value)) {\r\n      return value.some((entry) => fieldMatchesSelection(entry, selected));\r\n    }\r\n    return normalizeText(value) === normalizeText(selected);\r\n  };\r\n\r\n  const db = firebase.firestore();\r\n  const clientsSnapshot = await db.collection(\"Client\").get();\r\n  const clients = clientsSnapshot.docs.map((doc) => ({\r\n    id: doc.id,\r\n    ...doc.data(),\r\n  }));\r\n\r\n  // Filter clients based on OEM and Modality if selected\r\n  if (selectedOEM || selectedModality) {\r\n    const filteredClients = [];\r\n    for (const client of clients) {\r\n      let match = true;\r\n      if (selectedOEM || selectedModality) {\r\n        for (const machineRef of client.machines) {\r\n          const machineDoc = await machineRef.get();\r\n          const machineData = machineDoc.data();\r\n          if (\r\n            (selectedOEM &&\r\n              fieldMatchesSelection(\r\n                machineData.OEM ?? machineData.oem,\r\n                selectedOEM\r\n              )) ||\r\n            (selectedModality &&\r\n              fieldMatchesSelection(\r\n                machineData.Modality ?? machineData.modality,\r\n                selectedModality\r\n              ))\r\n          ) {\r\n            match = true;\r\n            break;\r\n          } else {\r\n            match = false;\r\n          }\r\n        }\r\n      }\r\n      if (match) {\r\n        filteredClients.push(client);\r\n      }\r\n    }\r\n    return filteredClients;\r\n  }\r\n\r\n  return clients;\r\n}\r\n\r\nexport async function fetchModels(\r\n  selectedOEM,\r\n  selectedModality,\r\n  selectedClient\r\n) {\r\n  const normalizeText = (value) => {\r\n    if (value == null) return \"\";\r\n    return String(value).toLowerCase().trim();\r\n  };\r\n\r\n  const fieldMatchesSelection = (value, selected) => {\r\n    if (!selected) return true;\r\n    if (Array.isArray(value)) {\r\n      return value.some((entry) => fieldMatchesSelection(entry, selected));\r\n    }\r\n    return normalizeText(value) === normalizeText(selected);\r\n  };\r\n\r\n  const db = firebase.firestore();\r\n  const machinesSnapshot = await db.collection(\"Machine\").get();\r\n  const models = new Set();\r\n\r\n  await Promise.all(\r\n    machinesSnapshot.docs.map(async (machineDoc) => {\r\n      const machineData = machineDoc.data();\r\n      let isValid = true;\r\n\r\n      if (!fieldMatchesSelection(machineData.OEM ?? machineData.oem, selectedOEM))\r\n        isValid = false;\r\n      if (\r\n        !fieldMatchesSelection(\r\n          machineData.Modality ?? machineData.modality,\r\n          selectedModality\r\n        )\r\n      )\r\n        isValid = false;\r\n      if (selectedClient && machineData.client) {\r\n        let clientDoc = null;\r\n        if (typeof machineData.client?.get === \"function\") {\r\n          clientDoc = await machineData.client.get();\r\n        } else if (typeof machineData.client === \"string\") {\r\n          clientDoc = await db.collection(\"Client\").doc(machineData.client).get();\r\n        }\r\n        if (!clientDoc || !clientDoc.exists) {\r\n          isValid = false;\r\n        } else {\r\n          const clientName = clientDoc.data().name;\r\n          const clientId = clientDoc.id;\r\n          if (selectedClient !== clientName && selectedClient !== clientId) {\r\n            isValid = false;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (isValid) {\r\n        const modelValue = machineData.Model ?? machineData.model;\r\n        if (Array.isArray(modelValue)) {\r\n          modelValue.forEach((entry) => entry && models.add(entry));\r\n        } else if (modelValue) {\r\n          models.add(modelValue);\r\n        }\r\n      }\r\n    })\r\n  );\r\n\r\n  return Array.from(models);\r\n}\r\n\r\nexport function formatDate(timestamp) {\r\n  if (!timestamp) return \"\";\r\n  let date;\r\n  if (timestamp.toDate) {\r\n    date = timestamp.toDate();\r\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\r\n    date = new Date(timestamp);\r\n  } else {\r\n    return \"\"; // handle unexpected formats\r\n  }\r\n  const day = String(date.getDate()).padStart(2, \"0\");\r\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\r\n  const year = date.getFullYear();\r\n  return `${month}/${day}/${year}`;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}