{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/router\";\nimport { Table, Button, Container, Card, Row, Col, Alert } from \"react-bootstrap\";\nimport firebase from \"../../../../context/Firebase\"; // Import for SSR\n\nimport { adminDb } from \"../../../../context/FirebaseAdmin\";\n\nconst Machine = () => {\n  const router = useRouter();\n  const {\n    0: selectedMachine,\n    1: setSelectedMachine\n  } = useState(null);\n  const {\n    0: associatedParts,\n    1: setAssociatedParts\n  } = useState([]);\n  const {\n    0: error,\n    1: setError\n  } = useState(null);\n  useEffect(() => {\n    if (router.isReady) {\n      const {\n        machineId\n      } = router.query;\n\n      if (!machineId) {\n        const pathSegments = router.asPath.split(\"/\");\n        const machineIdFromPath = pathSegments[pathSegments.length - 1];\n        console.log(`Machine ID extracted from URL path: ${machineIdFromPath}`);\n        fetchMachineData(machineIdFromPath);\n      } else {\n        console.log(`Machine ID from router query: ${machineId}`);\n        fetchMachineData(machineId);\n      }\n    }\n  }, [router.isReady]);\n\n  const fetchMachineData = async machineId => {\n    try {\n      console.log(`Attempting to fetch machine data for ID: ${machineId}`);\n      const db = firebase.firestore();\n      const machineDoc = await db.collection(\"Machine\").doc(machineId).get();\n\n      if (machineDoc.exists) {\n        const machineData = machineDoc.data();\n        setSelectedMachine(machineData);\n        console.log(\"Machine data:\", machineData); // Fetch associated parts\n\n        if (machineData.associatedParts) {\n          fetchAssociatedParts(machineData.associatedParts);\n        }\n      } else {\n        console.error(\"Machine not found\");\n        setError(\"Machine not found\");\n      }\n    } catch (error) {\n      console.error(\"Error fetching machine data:\", error);\n      setError(\"Error fetching machine data\");\n    }\n  };\n\n  const fetchAssociatedParts = async associatedPartsRefs => {\n    try {\n      const db = firebase.firestore();\n      const partsDocs = await Promise.all(associatedPartsRefs.map(ref => ref.get()));\n      const partsData = await Promise.all(partsDocs.map(async doc => {\n        var _data$ClientFrom;\n\n        if (!doc.exists) {\n          // skip or return an empty object\n          return null;\n        }\n\n        const data = doc.data() || {};\n        let clientName = \"\";\n\n        if ((_data$ClientFrom = data.ClientFrom) !== null && _data$ClientFrom !== void 0 && _data$ClientFrom.get) {\n          const clientDoc = await data.ClientFrom.get();\n          clientName = clientDoc.exists ? clientDoc.data().name : \"\";\n        }\n\n        return _objectSpread(_objectSpread({\n          id: doc.id\n        }, data), {}, {\n          clientName\n        });\n      }));\n      setAssociatedParts(partsData.filter(p => p));\n      console.log(\"Associated parts data:\", partsData);\n    } catch (error) {\n      console.error(\"Error fetching associated parts:\", error);\n      setError(\"Error fetching associated parts\");\n    }\n  };\n\n  const handlePrintMulti = async () => {\n    // Create your payload with the mapped items.\n    // Replace 'associatedParts' with your actual variable containing the list.\n    const payload = {\n      items: associatedParts.map(part => ({\n        name: part.name,\n        arrival_date: part.arrival_date,\n        // Ensure your part has a 'date' field.\n        poNumber: part.poNumber || \"\",\n        OEM: part.TheMachine ? part.TheMachine.oem || \"\" : \"\",\n        modality: part.TheMachine ? part.TheMachine.modality || \"\" : \"\",\n        model: part.TheMachine ? part.TheMachine.model || \"\" : \"\",\n        local_sn: part.id,\n        // Using document id as the local serial number.\n        client: part.clientName || \"\",\n        description: part.description || (part.descriptions && part.descriptions.length > 0 ? part.descriptions[0].description : \"\")\n      })),\n      test_print: true,\n      // Hard-coded here if you want to test printing one item\n      index: 1 // Hard-coded index (1-based)\n\n    };\n\n    try {\n      const response = await fetch(\"https://9d70-174-76-22-138.ngrok-free.app/print_multi\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(payload)\n      });\n      const result = await response.json();\n      console.log(\"Print multi result:\", result.status);\n    } catch (error) {\n      console.error(\"Error printing multiple labels:\", error);\n    }\n  };\n\n  const handleSelectPart = (id, name) => {\n    console.log(`Selected part ID: ${id}, Name: ${name}`);\n    router.push(\"../item/\" + id);\n  };\n\n  const formatDate = input => {\n    let date;\n\n    if (input && input.seconds) {\n      // Handle timestamp object with 'seconds' property\n      date = new Date(input.seconds * 1000);\n    } else if (typeof input === \"string\") {\n      // Handle date string\n      date = new Date(input);\n    } else {\n      return \"N/A\";\n    }\n\n    if (isNaN(date.getTime())) {\n      // Invalid date string\n      return \"Invalid Date\";\n    }\n\n    return date.toLocaleDateString();\n  };\n\n  return __jsx(Container, {\n    className: \"mt-5\"\n  }, __jsx(Row, {\n    className: \"justify-content-md-center\"\n  }, __jsx(Col, {\n    md: \"8\"\n  }, __jsx(Card, null, __jsx(Card.Header, null, __jsx(\"h4\", null, \"Machine Details\")), __jsx(Card.Body, null, error && __jsx(Alert, {\n    variant: \"danger\"\n  }, error), selectedMachine ? __jsx(React.Fragment, null, __jsx(\"h5\", null, \"Machine: \", selectedMachine.name), __jsx(\"p\", null, \"Model: \", selectedMachine.Model), __jsx(\"p\", null, \"Model: \", selectedMachine.Modality), __jsx(\"p\", null, \"Model: \", selectedMachine.OEM), __jsx(\"p\", null, \"Last PM: \", formatDate(selectedMachine.lastPM)), __jsx(\"p\", null, \"Next PM: \", formatDate(selectedMachine.nextPM)), __jsx(\"h5\", null, \"Associated Parts\"), __jsx(Table, {\n    striped: true,\n    bordered: true,\n    hover: true,\n    size: \"sm\"\n  }, __jsx(\"thead\", null, __jsx(\"tr\", null, __jsx(\"th\", null, \"Name\"), __jsx(\"th\", null, \"ID\"), __jsx(\"th\", null, \"Part Number\"), __jsx(\"th\", null, \"Serial Number\"), __jsx(\"th\", null, \"Date\"), __jsx(\"th\", null, \"Select\"))), __jsx(\"tbody\", null, associatedParts.map(part => __jsx(\"tr\", {\n    key: part.id\n  }, __jsx(\"td\", null, part.name), __jsx(\"td\", null, part.id), __jsx(\"td\", null, part.pn), __jsx(\"td\", null, part.sn), __jsx(\"td\", null, part.date), __jsx(\"td\", null, __jsx(Button, {\n    variant: \"primary\",\n    onClick: () => handleSelectPart(part.id, part.name)\n  }, \"Select\")))), __jsx(\"tr\", null, __jsx(\"td\", {\n    colSpan: \"5\",\n    style: {\n      textAlign: \"center\",\n      paddingTop: \"20px\"\n    }\n  }, __jsx(Button, {\n    variant: \"secondary\",\n    onClick: handlePrintMulti\n  }, \"Print All Items\"))), __jsx(Button, {\n    variant: \"primary\",\n    style: {\n      marginTop: \"20px\"\n    },\n    onClick: () => router.back()\n  }, \"back\")))) : !error && __jsx(\"p\", null, \"Loading machine data...\"))))));\n};\n\nexport default Machine; // Server-side rendering function\n\nexport async function getServerSideProps(context) {\n  const {\n    id\n  } = context.params;\n\n  try {\n    // Fetch machine data from Firestore using Admin SDK\n    const machineDoc = await adminDb.collection(\"Machine\").doc(id).get();\n\n    if (!machineDoc.exists) {\n      return {\n        notFound: true // This will show a 404 page\n\n      };\n    }\n\n    const machineData = machineDoc.data(); // Fetch associated parts if they exist\n\n    let associatedParts = [];\n\n    if (machineData.associatedParts && Array.isArray(machineData.associatedParts)) {\n      try {\n        const partsPromises = machineData.associatedParts.map(partRef => {\n          if (partRef.path) {\n            return adminDb.doc(partRef.path).get();\n          }\n\n          return null;\n        }).filter(Boolean);\n        const partsDocs = await Promise.all(partsPromises);\n        associatedParts = await Promise.all(partsDocs.map(async doc => {\n          if (!doc.exists) {\n            return null;\n          }\n\n          const data = doc.data() || {};\n          let clientName = \"\"; // Fetch client name if ClientFrom reference exists\n\n          if (data.ClientFrom && data.ClientFrom.path) {\n            try {\n              const clientDoc = await adminDb.doc(data.ClientFrom.path).get();\n              clientName = clientDoc.exists ? clientDoc.data().name : \"\";\n            } catch (error) {\n              console.error(\"Error fetching client data:\", error);\n            }\n          }\n\n          return _objectSpread(_objectSpread({\n            id: doc.id\n          }, data), {}, {\n            clientName\n          });\n        })); // Filter out null values\n\n        associatedParts = associatedParts.filter(part => part !== null);\n      } catch (error) {\n        console.error(\"Error fetching associated parts:\", error);\n      }\n    } // Serialize the machine data, removing any non-serializable fields\n\n\n    const serializedMachine = {\n      id,\n      name: machineData.name || \"\",\n      Model: machineData.Model || \"\",\n      OEM: machineData.OEM || \"\",\n      Modality: machineData.Modality || \"\",\n      lastPM: machineData.lastPM || null,\n      nextPM: machineData.nextPM || null // Add other machine fields as needed, but ensure they're serializable\n\n    };\n    return {\n      props: {\n        initialMachine: serializedMachine,\n        initialAssociatedParts: associatedParts\n      }\n    };\n  } catch (error) {\n    console.error(\"Error in getServerSideProps:\", error);\n    return {\n      props: {\n        error: \"Failed to load machine data\"\n      }\n    };\n  }\n}","map":null,"metadata":{},"sourceType":"module"}