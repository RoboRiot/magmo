{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport firebase from \"../context/Firebase\";\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(partsSnapshot.docs.map(async partDoc => {\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n    // console.log(partData);\n\n    if (partData.Machine && partData.Machine instanceof firebase.firestore.DocumentReference) {\n      console.log(partData.Machine);\n      const machineDoc = await partData.Machine.get();\n      partData.machineData = machineDoc.exists ? machineDoc.data() : {};\n\n      if (partData.machineData.client) {\n        const clientDoc = await partData.machineData.client.get();\n        partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    } else {\n      partData.machineData = {};\n    }\n\n    return partData;\n  }));\n  return parts;\n} // Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\n\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null\n} = {}) {\n  const db = firebase.firestore(); // Fetch one extra doc so we can reliably determine if a next page exists.\n\n  let query = db.collection(\"Test\").limit(pageSize + 1);\n\n  if (startAfterDoc) {\n    query = query.startAfter(startAfterDoc);\n  }\n\n  const partsSnapshot = await query.get();\n  const docs = partsSnapshot.docs;\n  const hasNextPage = docs.length > pageSize;\n  const pageDocs = hasNextPage ? docs.slice(0, pageSize) : docs;\n  const parts = await Promise.all(pageDocs.map(async partDoc => {\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    if (partData.Machine && partData.Machine instanceof firebase.firestore.DocumentReference) {\n      const machineDoc = await partData.Machine.get();\n      partData.machineData = machineDoc.exists ? machineDoc.data() : {};\n\n      if (partData.machineData.client) {\n        const clientDoc = await partData.machineData.client.get();\n        partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    } else {\n      partData.machineData = {};\n    }\n\n    return partData;\n  }));\n  const lastDoc = pageDocs.length > 0 ? pageDocs[pageDocs.length - 1] : null;\n  return {\n    parts,\n    lastDoc,\n    hasNextPage\n  };\n}\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map(doc => _objectSpread({\n    id: doc.id\n  }, doc.data())); // Filter clients based on OEM and Modality if selected\n\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n\n    for (const client of clients) {\n      let match = true;\n\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n\n          if (selectedOEM && machineData.OEM === selectedOEM || selectedModality && machineData.Modality === selectedModality) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n\n    return filteredClients;\n  }\n\n  return clients;\n}\nexport async function fetchModels(selectedOEM, selectedModality, selectedClient) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n  await Promise.all(machinesSnapshot.docs.map(async machineDoc => {\n    const machineData = machineDoc.data();\n    let isValid = true;\n    if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n    if (selectedModality && machineData.Modality !== selectedModality) isValid = false;\n\n    if (selectedClient && machineData.client) {\n      const clientDoc = await machineData.client.get();\n      if (!clientDoc.exists || clientDoc.data().name !== selectedClient) isValid = false;\n    }\n\n    if (isValid) {\n      models.add(machineData.Model);\n    }\n  }));\n  return Array.from(models);\n}\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/utils/fetchAssociations.js"],"names":["React","firebase","fetchPartsWithMachineData","db","firestore","partsSnapshot","collection","get","parts","Promise","all","docs","map","partDoc","partData","data","id","Machine","DocumentReference","console","log","machineDoc","machineData","exists","client","clientDoc","Client","name","fetchPartsWithMachineDataPage","pageSize","startAfterDoc","query","limit","startAfter","hasNextPage","length","pageDocs","slice","lastDoc","fetchClients","selectedOEM","selectedModality","clientsSnapshot","clients","doc","filteredClients","match","machineRef","machines","OEM","Modality","push","fetchModels","selectedClient","machinesSnapshot","models","Set","isValid","add","Model","Array","from","formatDate","timestamp","date","toDate","Date","day","String","getDate","padStart","month","getMonth","year","getFullYear"],"mappings":"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","sourcesContent":["import React from 'react'\nimport firebase from \"../context/Firebase\";\n\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(\n    partsSnapshot.docs.map(async (partDoc) => {\n      const partData = partDoc.data();\n      partData.id = partDoc.id; // Add document ID here\n      // console.log(partData);\n      if (\n        partData.Machine &&\n        partData.Machine instanceof firebase.firestore.DocumentReference\n      ) {\n        console.log(partData.Machine);\n        const machineDoc = await partData.Machine.get();\n        partData.machineData = machineDoc.exists ? machineDoc.data() : {};\n        if (partData.machineData.client) {\n          const clientDoc = await partData.machineData.client.get();\n          partData.machineData.Client = clientDoc.exists\n            ? clientDoc.data().name\n            : \"\";\n        }\n      } else {\n        partData.machineData = {};\n      }\n      return partData;\n    })\n  );\n  return parts;\n}\n\n// Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n} = {}) {\n  const db = firebase.firestore();\n  // Fetch one extra doc so we can reliably determine if a next page exists.\n  let query = db.collection(\"Test\").limit(pageSize + 1);\n\n  if (startAfterDoc) {\n    query = query.startAfter(startAfterDoc);\n  }\n\n  const partsSnapshot = await query.get();\n  const docs = partsSnapshot.docs;\n  const hasNextPage = docs.length > pageSize;\n  const pageDocs = hasNextPage ? docs.slice(0, pageSize) : docs;\n\n  const parts = await Promise.all(\n    pageDocs.map(async (partDoc) => {\n      const partData = partDoc.data();\n      partData.id = partDoc.id; // Add document ID here\n      if (\n        partData.Machine &&\n        partData.Machine instanceof firebase.firestore.DocumentReference\n      ) {\n        const machineDoc = await partData.Machine.get();\n        partData.machineData = machineDoc.exists ? machineDoc.data() : {};\n        if (partData.machineData.client) {\n          const clientDoc = await partData.machineData.client.get();\n          partData.machineData.Client = clientDoc.exists\n            ? clientDoc.data().name\n            : \"\";\n        }\n      } else {\n        partData.machineData = {};\n      }\n      return partData;\n    })\n  );\n\n  const lastDoc =\n    pageDocs.length > 0 ? pageDocs[pageDocs.length - 1] : null;\n\n  return { parts, lastDoc, hasNextPage };\n}\n\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map((doc) => ({\n    id: doc.id,\n    ...doc.data(),\n  }));\n\n  // Filter clients based on OEM and Modality if selected\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n    for (const client of clients) {\n      let match = true;\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n          if (\n            (selectedOEM && machineData.OEM === selectedOEM) ||\n            (selectedModality && machineData.Modality === selectedModality)\n          ) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n    return filteredClients;\n  }\n\n  return clients;\n}\n\nexport async function fetchModels(\n  selectedOEM,\n  selectedModality,\n  selectedClient\n) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n\n  await Promise.all(\n    machinesSnapshot.docs.map(async (machineDoc) => {\n      const machineData = machineDoc.data();\n      let isValid = true;\n\n      if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n      if (selectedModality && machineData.Modality !== selectedModality)\n        isValid = false;\n      if (selectedClient && machineData.client) {\n        const clientDoc = await machineData.client.get();\n        if (!clientDoc.exists || clientDoc.data().name !== selectedClient)\n          isValid = false;\n      }\n\n      if (isValid) {\n        models.add(machineData.Model);\n      }\n    })\n  );\n\n  return Array.from(models);\n}\n\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}\n"]},"metadata":{},"sourceType":"module"}