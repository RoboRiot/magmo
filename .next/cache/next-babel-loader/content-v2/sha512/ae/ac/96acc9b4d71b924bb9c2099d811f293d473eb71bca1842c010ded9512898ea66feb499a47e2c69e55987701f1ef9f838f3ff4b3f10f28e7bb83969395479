{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // inflowAPI.js\n// const BASE_URL   = 'https://cloudapi.inflowinventory.com';\n// const COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\n// // (Move this to env vars in prod)\n// const API_KEY    = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\n// const headers = {\n//   'Authorization': `Bearer ${API_KEY}`,\n//   'Content-Type':  'application/json',\n//   // Use the latest you saw in server responses; older also works, but stay current:\n//   'Accept':        'application/json;version=2025-06-24',\n// };\n// async function parseErr(res) {\n//   const t = await res.text();\n//   try { return JSON.parse(t); } catch { return t; }\n// }\n// // --- Look up existing product by name on the collection endpoint ---\n// // Use filter[name] if your tenant supports it; otherwise fall back to filter[smart].\n// async function findProductByName(name) {\n//   // Try exact name filter first\n//   let url = `${BASE_URL}/${COMPANY_ID}/products?filter[name]=${encodeURIComponent(name)}&count=1`;\n//   let res = await fetch(url, { headers });\n//   if (res.ok) {\n//     const data = await res.json();\n//     const items = Array.isArray(data?.items) ? data.items : (Array.isArray(data) ? data : []);\n//     if (items.length) return items[0];\n//   }\n//   // Fallback: smart filter (searches common fields)\n//   url = `${BASE_URL}/${COMPANY_ID}/products?filter[smart]=${encodeURIComponent(name)}&count=1`;\n//   res = await fetch(url, { headers });\n//   if (!res.ok) return null;\n//   const data2 = await res.json();\n//   const items2 = Array.isArray(data2?.items) ? data2.items : (Array.isArray(data2) ? data2 : []);\n//   return items2.length ? items2[0] : null;\n// }\n// class InflowAPI {\n//   /**\n//    * Upsert a product in inFlow via PUT to the collection.\n//    * @param {{ productId?: string, name: string, description: string, imageUrls?: string[], sku?: string }} params\n//    */\n//   static async upsertProduct({ productId, name, description, imageUrls = [], sku }) {\n//     if (!name || !name.trim()) throw new Error('Name is required');\n//     // If no productId, check if one already exists with this name to avoid the unique-name error.\n//     if (!productId) {\n//       const existing = await findProductByName(name.trim());\n//       if (existing && (existing.productId || existing.id)) {\n//         productId = existing.productId || existing.id;\n//       }\n//     }\n//     // If still no id, generate one (this matched your previously-working flow)\n//     const id = productId || crypto.randomUUID();\n//     // Build the payload exactly like your original—PUT to the collection with productId\n//     const payload = {\n//       productId: id,\n//       name,\n//       description,\n//       ...(sku ? { sku } : {}),\n//       ...(imageUrls.length > 0 && {\n//         images: imageUrls.map(u => ({\n//           imageId: crypto.randomUUID(),\n//           originalUrl: u,\n//         })),\n//       }),\n//     };\n//     const url = `${BASE_URL}/${COMPANY_ID}/products`;\n//     const res = await fetch(url, {\n//       method: 'PUT',\n//       headers,\n//       body: JSON.stringify(payload),\n//     });\n//     if (!res.ok) {\n//       const err = await parseErr(res);\n//       throw new Error(`inFlow API error (${res.status}): ${typeof err === 'string' ? err : JSON.stringify(err)}`);\n//     }\n//     return res.json();\n//   }\n// }\n// export default InflowAPI;\n// utils/inflowAPI.js (only the changed bits)\nconst BASE_URL = 'https://cloudapi.inflowinventory.com';\nconst COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\nconst API_KEY = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\nconst headers = {\n  Authorization: `Bearer ${API_KEY}`,\n  'Content-Type': 'application/json',\n  // stick to a stable version you know works in your tenant:\n  Accept: 'application/json;version=2024-10-01'\n};\n\nconst n = s => (s !== null && s !== void 0 ? s : '').toString().trim();\n\nasync function parseText(res) {\n  const t = await res.text();\n\n  try {\n    return {\n      json: JSON.parse(t),\n      raw: t\n    };\n  } catch {\n    return {\n      json: null,\n      raw: t\n    };\n  }\n} // ---- EXACT lookup helpers (no fuzzy/SMART fallback) ------------------------\n\n\nasync function findProductIdByExactName(name) {\n  const nameNorm = n(name);\n  if (!nameNorm) return null;\n  const url = `${BASE_URL}/${COMPANY_ID}/products?filter[name]=` + `${encodeURIComponent(nameNorm)}&count=1`;\n  const res = await fetch(url, {\n    headers\n  });\n  if (!res.ok) return null;\n  const data = await res.json();\n  const items = Array.isArray(data === null || data === void 0 ? void 0 : data.items) ? data.items : Array.isArray(data) ? data : [];\n  const item = items[0];\n  if (!item) return null; // guard: only accept if name is an exact (case-insensitive) match\n\n  if (n(item.name).toLowerCase() !== nameNorm.toLowerCase()) return null;\n  return item.productId || item.id || null;\n} // Prefer direct GET /products/{id}; fallback to collection filter by id\n\n\nasync function getProductById(productId) {\n  // Try item endpoint\n  let res = await fetch(`${BASE_URL}/${COMPANY_ID}/products/${encodeURIComponent(productId)}`, {\n    headers\n  });\n  if (res.ok) return res.json(); // Fallback: filter by id on collection\n\n  res = await fetch(`${BASE_URL}/${COMPANY_ID}/products?filter[productId]=${encodeURIComponent(productId)}&count=1`, {\n    headers\n  });\n  if (!res.ok) return null;\n  const data = await res.json();\n  const items = Array.isArray(data === null || data === void 0 ? void 0 : data.items) ? data.items : Array.isArray(data) ? data : [];\n  return items[0] || null;\n}\n\nfunction buildImages(imageUrls = []) {\n  return imageUrls.filter(Boolean).map(u => ({\n    imageId: crypto.randomUUID(),\n    originalUrl: u\n  }));\n}\n\nclass InflowAPI {\n  /**\n   * Strict upsert: exact-name reuse only; verify by id afterward.\n   */\n  static async upsertProduct({\n    productId,\n    name,\n    description,\n    imageUrls = [],\n    sku,\n    customFields\n  }) {\n    var _ref, _after$isActive;\n\n    const nameNorm = n(name);\n    if (!nameNorm) throw new Error('Name is required'); // Only reuse an id if the name is an exact match. No SMART search.\n\n    if (!productId) productId = await findProductIdByExactName(nameNorm);\n    const id = productId || crypto.randomUUID();\n\n    const payload = _objectSpread(_objectSpread(_objectSpread(_objectSpread({\n      productId: id,\n      name: nameNorm,\n      isActive: true\n    }, n(description) ? {\n      description: n(description)\n    } : {}), n(sku) ? {\n      sku: n(sku)\n    } : {}), imageUrls.length ? {\n      images: buildImages(imageUrls)\n    } : {}), customFields && Object.keys(customFields).length ? {\n      customFields\n    } : {});\n\n    console.log('[inFlow] PUT payload:', payload);\n    const res = await fetch(`${BASE_URL}/${COMPANY_ID}/products`, {\n      method: 'PUT',\n      headers,\n      body: JSON.stringify(payload)\n    });\n    const {\n      json,\n      raw\n    } = await parseText(res);\n    console.log('[inFlow] Raw PUT response:', res.status, raw);\n\n    if (!res.ok) {\n      throw new Error(`inFlow API error (${res.status}): ${raw}`);\n    } // prefer the id the server gave us (if any), else the one we sent\n\n\n    const resolvedId = json && (json.productId || json.id) || id; // Verify by ID only (no fuzzy). This prevents false “success”.\n\n    const after = await getProductById(resolvedId);\n    console.log('[inFlow] Verified by ID:', {\n      productId: resolvedId,\n      name: after === null || after === void 0 ? void 0 : after.name,\n      sku: after === null || after === void 0 ? void 0 : after.sku,\n      // many tenants surface one of these; log whatever exists so you can tell if it’s hidden\n      isActive: (_ref = (_after$isActive = after === null || after === void 0 ? void 0 : after.isActive) !== null && _after$isActive !== void 0 ? _after$isActive : after === null || after === void 0 ? void 0 : after.active) !== null && _ref !== void 0 ? _ref : after === null || after === void 0 ? void 0 : after.status,\n      categoryId: after === null || after === void 0 ? void 0 : after.categoryId\n    });\n\n    if (!after) {\n      throw new Error('Write appeared to succeed, but GET by id returned nothing.');\n    }\n\n    return after;\n  }\n\n}\n\nexport default InflowAPI;","map":null,"metadata":{},"sourceType":"module"}