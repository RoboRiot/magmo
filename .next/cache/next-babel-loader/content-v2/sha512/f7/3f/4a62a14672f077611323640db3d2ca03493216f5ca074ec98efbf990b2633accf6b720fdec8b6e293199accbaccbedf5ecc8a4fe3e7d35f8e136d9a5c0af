{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\n//   try {\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\n//     const {\n//       listKey,            // \"receiving\" | \"shipping\" | \"tasks\"\n//       title, linkUrl, bodyText,\n//       date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\n//       photoUrls = [],\n//     } = req.body;\n//     const LISTS = {\n//       receiving: {\n//         id: process.env.SLACK_LIST_RECEIVING_ID,\n//         cols: {\n//           desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n//           date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\n//           pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n//           track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n//           wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\n//           lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n//           photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // attachment\n//         },\n//       },\n//       shipping: {\n//         id: process.env.SLACK_LIST_SHIPPING_ID,\n//         cols: {\n//           desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n//           date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\n//           pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n//           track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n//           wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\n//           lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n//           photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,  // attachment\n//         },\n//       },\n//       tasks: {\n//         id: process.env.SLACK_LIST_TASKS_ID,\n//         cols: {\n//           desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\n//         },\n//       },\n//     };\n//     const CHANNELS = {\n//       receiving: process.env.SLACK_CHANNEL_RECEIVING_ID,\n//       shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,\n//       tasks:     process.env.SLACK_CHANNEL_TASKS_ID,\n//     };\n//     const headersJson = {\n//       Authorization: `Bearer ${token}`,\n//       \"Content-Type\": \"application/json; charset=utf-8\",\n//     };\n//     const slack = (method, body, headers = headersJson) =>\n//       fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body })\n//         .then(r => r.json());\n//     const plain = v => (v ?? \"\").toString().trim();\n//     const safe  = plain;\n//     const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     // ---------- PATH A: Write to a LIST ----------\n//     const cfg = LISTS[listKey];\n//     if (cfg?.id) {\n//       const fields = [];\n//       // Description column\n//       if (cfg.cols.desc && (description || bodyText || linkUrl)) {\n//         const textBits = [\n//           description,\n//           (listKey === \"tasks\" && bodyText) ? bodyText : null,\n//           linkUrl ? `<${linkUrl}|Open in Magmo>` : null,\n//         ].filter(Boolean).join(\"\\n\");\n//         fields.push({ column_id: cfg.cols.desc, value: { text: textBits } });\n//       }\n//       if (cfg.cols.date && date) fields.push({ column_id: cfg.cols.date, value: { date } });\n//       if (cfg.cols.pn && (pn || sn || dom)) {\n//         const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : (pn ? `PN: ${pn}` : \"\");\n//         const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : (sn ? `SN: ${sn}` : \"\");\n//         const domLine = dom ? `DOM: ${dom}` : \"\";\n//         const pnBlock = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\n//         if (pnBlock) fields.push({ column_id: cfg.cols.pn, value: { text: pnBlock } });\n//       }\n//       if (cfg.cols.track && (trackingNumber || poNumber)) {\n//         const t = [\n//           trackingNumber ? `RL: ${trackingNumber}` : \"\",\n//           poNumber ? `PO: ${poNumber}` : \"\",\n//         ].filter(Boolean).join(\"  \");\n//         if (t) fields.push({ column_id: cfg.cols.track, value: { text: t } });\n//       }\n//       if (cfg.cols.wo && workOrder) fields.push({ column_id: cfg.cols.wo,  value: { text: `WO: ${workOrder}` } });\n//       if (cfg.cols.lsn && localSN)  fields.push({ column_id: cfg.cols.lsn, value: { text: localSN } });\n//       // NOW build the create body (cfg & fields exist)\n//       const createBody = {\n//         list_id: cfg.id,\n//         title: plain(title) || plain(localSN) || \"Untitled\",\n//         fields,\n//       };\n//       const created = await slack(\"slackLists.items.create\", JSON.stringify(createBody));\n//       if (!created?.ok) {\n//         console.error(\"slackLists.items.create error:\", created);\n//         return res.status(400).json({ error: created?.error || \"Slack Lists API error\", raw: created });\n//       }\n//       // Photos -> attachment column\n//       if (cfg.cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\n//         const fileIds = [];\n//         for (const url of photoUrls) {\n//           const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\n//             method: \"POST\",\n//             headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\n//             body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\n//           }).then(r => r.json());\n//           if (!init?.ok || !init?.upload_url) continue;\n//           try {\n//             const img = await fetch(url);\n//             const buf = await img.arrayBuffer();\n//             await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\n//           } catch (_) {}\n//           const complete = await slack(\"files.completeUploadExternal\",\n//             JSON.stringify({ files: [{ id: init.file_id, title: \"photo\" }] })\n//           );\n//           if (complete?.ok && complete?.files?.[0]?.id) fileIds.push(complete.files[0].id);\n//         }\n//         if (fileIds.length) {\n//           await slack(\"slackLists.items.update\", JSON.stringify({\n//             list_id: cfg.id,\n//             item_id: created.item.id,\n//             fields: [{ column_id: cfg.cols.photos, value: { attachment: { file_ids: fileIds } } }],\n//           }));\n//         }\n//       }\n//       return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: created.item.id });\n//     }\n//     // ---------- PATH B: Fallback to a channel post ----------\n//     const channel = CHANNELS[listKey];\n//     if (!channel) return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\n//     // Try to join public channels to avoid channel_not_found\n//     await fetch(\"https://slack.com/api/conversations.join\", {\n//       method: \"POST\",\n//       headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\n//       body: new URLSearchParams({ channel }),\n//     });\n//     const safeId = plain(linkUrl?.split(\"/\").pop()) || plain(localSN) || \"\";\n//     const safeTitle = plain(title) || plain(req.body?.title) || (safeId ? `Item ${safeId}` : \"New Item\");\n//     const lines = [];\n//     lines.push(`*${safeTitle}*`);\n//     const pnStr = joinArr(pn);\n//     const snStr = joinArr(sn);\n//     if (pnStr) lines.push(`PN: ${pnStr}`);\n//     if (snStr) lines.push(`SN: ${snStr}`);\n//     if (safe(workOrder)) lines.push(`WO: ${safe(workOrder)}`);\n//     if (safe(poNumber)) lines.push(`PO: ${safe(poNumber)}`);\n//     if (safe(trackingNumber)) lines.push(`RL: ${safe(trackingNumber)}`);\n//     if (safe(dom)) lines.push(`DOM: ${safe(dom)}`);\n//     if (safe(localSN)) lines.push(`Local SN: ${safe(localSN)}`);\n//     if (safe(date)) lines.push(`Date: ${safe(date)}`);\n//     const desc = safe(description);\n//     if (desc) lines.push(desc);\n//     else if (listKey === \"tasks\" && safe(bodyText)) lines.push(safe(bodyText));\n//     if (safe(linkUrl)) lines.push(`<${safe(linkUrl)}|Open in Magmo>`);\n//     const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\n//     const posted = await slack(\"chat.postMessage\", JSON.stringify({ channel, text }));\n//     if (!posted?.ok) {\n//       console.error(\"chat.postMessage error:\", posted);\n//       return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\n//     }\n//     return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\n//   } catch (e) {\n//     console.error(\"API /slack/add-to-list crashed:\", e);\n//     return res.status(500).json({ error: \"Server error\" });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  if (req.method !== \"POST\") {\n    return res.status(405).json({\n      error: \"Method not allowed\"\n    });\n  }\n\n  const token = process.env.SLACK_BOT_TOKEN;\n\n  if (!token) {\n    return res.status(500).json({\n      error: \"Missing SLACK_BOT_TOKEN\"\n    });\n  } // Payload from client\n\n\n  const {\n    listKey,\n    // \"tasks\" | \"shipping\" | \"receiving\"\n    title,\n    // human title coming from the client (use this!)\n    linkUrl,\n    bodyText,\n    date,\n    pn,\n    sn,\n    dom,\n    trackingNumber,\n    poNumber,\n    workOrder,\n    localSN,\n    description,\n    photoUrls = []\n  } = req.body || {}; // --- ENV mapping: only the list IDs are strictly required to get the title in.\n\n  const LISTS = {\n    tasks: {\n      id: process.env.SLACK_LIST_TASKS_ID,\n      cols: {\n        // OPTIONAL column ids; fill only the ones you actually have\n        // title column is implicit via \"title\" below; do not pass a column for that\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL // \"Task\" list's notes/description column (optional)\n\n      }\n    },\n    shipping: {\n      id: process.env.SLACK_LIST_SHIPPING_ID,\n      cols: {\n        desc: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n        date: process.env.SLACK_LIST_SHIPPING_DATE_COL,\n        pn: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n        track: process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n        wo: process.env.SLACK_LIST_SHIPPING_WO_COL,\n        lsn: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL // attachment col (optional)\n\n      }\n    },\n    receiving: {\n      id: process.env.SLACK_LIST_RECEIVING_ID,\n      cols: {\n        desc: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n        date: process.env.SLACK_LIST_RECEIVING_DATE_COL,\n        pn: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n        track: process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n        wo: process.env.SLACK_LIST_RECEIVING_WO_COL,\n        lsn: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL // attachment col (optional)\n\n      }\n    }\n  };\n  const CHANNELS = {\n    tasks: process.env.SLACK_CHANNEL_TASKS_ID,\n    // optional fallback\n    shipping: process.env.SLACK_CHANNEL_SHIPPING_ID,\n    // optional fallback\n    receiving: process.env.SLACK_CHANNEL_RECEIVING_ID // optional fallback\n\n  };\n  const headersJson = {\n    Authorization: `Bearer ${token}`,\n    \"Content-Type\": \"application/json; charset=utf-8\"\n  };\n\n  const slack = async (method, body, headers = headersJson) => {\n    const r = await fetch(`https://slack.com/api/${method}`, {\n      method: \"POST\",\n      headers,\n      body\n    });\n    return r.json();\n  }; // --------- logging to server console (see your terminal) ----------\n\n\n  console.log(\"add-to-list payload\", {\n    listKey,\n    title,\n    localSN,\n    pn: Array.isArray(pn) ? pn : pn ? [pn] : [],\n    sn: Array.isArray(sn) ? sn : sn ? [sn] : [],\n    hasPhotos: Array.isArray(photoUrls) && photoUrls.length\n  });\n  console.log(\"env lists present?\", {\n    TASKS: !!process.env.SLACK_LIST_TASKS_ID,\n    SHIPPING: !!process.env.SLACK_LIST_SHIPPING_ID,\n    RECEIVING: !!process.env.SLACK_LIST_RECEIVING_ID\n  }); // --------- safe helpers ----------\n\n  const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n  const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a); // Build a safe, never-empty title for the SERVER (belt & suspenders)\n  // NOTE: Slack Lists has a dedicated \"title\" field — this populates your \"Task\"/\"Item\" column in the UI.\n\n\n  const safeTitle = plain(title) || (plain(localSN) ? `Item ${plain(localSN)}` : \"\") || joinArr(pn) || \"New Item\";\n  const cfg = LISTS[listKey]; // ============ PATH A: Slack Lists (preferred) ============\n\n  if (cfg !== null && cfg !== void 0 && cfg.id) {\n    try {\n      var _created$item;\n\n      // 1) Create the row with ONLY the title first. This guarantees a non-empty item in the UI.\n      const createBody = {\n        list_id: cfg.id,\n        title: safeTitle // ← keep as a plain string; Slack will render it in the list's primary column (\"Task\"/\"Item\")\n\n      };\n      console.log(\"slackLists.items.create >\", createBody);\n      const created = await slack(\"slackLists.items.create\", JSON.stringify(createBody));\n      console.log(\"slackLists.items.create < resp\", created);\n\n      if (!(created !== null && created !== void 0 && created.ok)) {\n        // If Lists API rejects, try channel fallback (below)\n        console.warn(\"Lists create failed, will try channel fallback:\", created === null || created === void 0 ? void 0 : created.error);\n        return await channelFallback({\n          slack,\n          token,\n          CHANNELS,\n          listKey,\n          safeTitle,\n          linkUrl,\n          pn,\n          sn,\n          dom,\n          workOrder,\n          poNumber,\n          trackingNumber,\n          localSN,\n          date,\n          bodyText,\n          description,\n          res\n        });\n      }\n\n      const itemId = created === null || created === void 0 ? void 0 : (_created$item = created.item) === null || _created$item === void 0 ? void 0 : _created$item.id; // 2) Now (optionally) patch additional columns — only if those column IDs exist.\n\n      const fields = [];\n      const cols = cfg.cols || {};\n\n      const addText = (colId, text) => {\n        const t = plain(text);\n        if (colId && t) fields.push({\n          column_id: colId,\n          value: {\n            text: t\n          }\n        });\n      }; // Description / Notes column\n\n\n      if (cols.desc) {\n        const textBits = [plain(description), listKey === \"tasks\" ? plain(bodyText) : \"\", plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\"].filter(Boolean).join(\"\\n\");\n        addText(cols.desc, textBits);\n      } // Date column (Slack expects { date: \"YYYY-MM-DD\" })\n\n\n      if (cols.date && plain(date)) {\n        fields.push({\n          column_id: cols.date,\n          value: {\n            date: plain(date)\n          }\n        });\n      } // PN/SN/DOM combo column\n\n\n      if (cols.pn) {\n        const pnStr = joinArr(pn);\n        const snStr = joinArr(sn);\n        const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`].filter(Boolean).join(\"  \");\n        addText(cols.pn, combo);\n      } // Tracking/PO column\n\n\n      if (cols.track) {\n        const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`].filter(Boolean).join(\"  \");\n        addText(cols.track, t);\n      } // Work order column\n\n\n      if (cols.wo) addText(cols.wo, plain(workOrder) && `WO: ${plain(workOrder)}`); // Local SN column\n\n      if (cols.lsn) addText(cols.lsn, plain(localSN)); // Patch fields if we actually have any *valid* (non-empty) field + column_id pairs\n\n      if (fields.length) {\n        const updateBody = {\n          list_id: cfg.id,\n          item_id: itemId,\n          fields\n        };\n        console.log(\"slackLists.items.update >\", updateBody);\n        const updated = await slack(\"slackLists.items.update\", JSON.stringify(updateBody));\n        console.log(\"slackLists.items.update < resp\", updated); // If this fails because of a bad column_id, we still keep the row (title already created).\n\n        if (!(updated !== null && updated !== void 0 && updated.ok)) {\n          console.warn(\"Lists update failed; leaving item with title only:\", updated === null || updated === void 0 ? void 0 : updated.error);\n        }\n      } // (Optional) Attach photos to attachment column — skip for now unless you really want it:\n      // If you enable this, make sure cols.photos is the ID of an \"attachment\" type column.\n      // await maybeAttachPhotos({ token, listId: cfg.id, itemId, photoUrls, photosCol: cols.photos });\n\n\n      return res.status(200).json({\n        ok: true,\n        mode: \"list\",\n        list_id: cfg.id,\n        item_id: itemId\n      });\n    } catch (e) {\n      console.error(\"Lists path error:\", e); // If something exploded, still try channel fallback\n\n      return await channelFallback({\n        slack,\n        token,\n        CHANNELS,\n        listKey,\n        safeTitle,\n        linkUrl,\n        pn,\n        sn,\n        dom,\n        workOrder,\n        poNumber,\n        trackingNumber,\n        localSN,\n        date,\n        bodyText,\n        description,\n        res\n      });\n    }\n  } // ============ PATH B: Only channel configured ============\n\n\n  return await channelFallback({\n    slack,\n    token,\n    CHANNELS,\n    listKey,\n    safeTitle,\n    linkUrl,\n    pn,\n    sn,\n    dom,\n    workOrder,\n    poNumber,\n    trackingNumber,\n    localSN,\n    date,\n    bodyText,\n    description,\n    res\n  });\n} // ---------------- helpers ----------------\n\nasync function channelFallback({\n  slack,\n  token,\n  CHANNELS,\n  listKey,\n  safeTitle,\n  linkUrl,\n  pn,\n  sn,\n  dom,\n  workOrder,\n  poNumber,\n  trackingNumber,\n  localSN,\n  date,\n  bodyText,\n  description,\n  res\n}) {\n  const channel = CHANNELS[listKey];\n\n  if (!channel) {\n    return res.status(400).json({\n      error: \"Unknown listKey (no list or channel configured)\"\n    });\n  } // Join public channels to avoid channel_not_found (ignore failures)\n\n\n  try {\n    await fetch(\"https://slack.com/api/conversations.join\", {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${token}`,\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      },\n      body: new URLSearchParams({\n        channel\n      })\n    });\n  } catch {}\n\n  const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n  const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n\n  const lines = [];\n  lines.push(`*${safeTitle}*`);\n  const pnStr = joinArr(pn);\n  const snStr = joinArr(sn);\n  if (pnStr) lines.push(`PN: ${pnStr}`);\n  if (snStr) lines.push(`SN: ${snStr}`);\n  if (plain(workOrder)) lines.push(`WO: ${plain(workOrder)}`);\n  if (plain(poNumber)) lines.push(`PO: ${plain(poNumber)}`);\n  if (plain(trackingNumber)) lines.push(`RL: ${plain(trackingNumber)}`);\n  if (plain(dom)) lines.push(`DOM: ${plain(dom)}`);\n  if (plain(localSN)) lines.push(`Local SN: ${plain(localSN)}`);\n  if (plain(date)) lines.push(`Date: ${plain(date)}`);\n  const desc = plain(description);\n  if (desc) lines.push(desc);else if (listKey === \"tasks\" && plain(bodyText)) lines.push(plain(bodyText));\n  if (plain(linkUrl)) lines.push(`<${plain(linkUrl)}|Open in Magmo>`);\n  const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\n  console.log(\"chat.postMessage >\", {\n    channel,\n    text\n  });\n  const posted = await slack(\"chat.postMessage\", JSON.stringify({\n    channel,\n    text\n  }));\n  console.log(\"chat.postMessage < resp\", posted);\n\n  if (!(posted !== null && posted !== void 0 && posted.ok)) {\n    return res.status(400).json({\n      error: (posted === null || posted === void 0 ? void 0 : posted.error) || \"Slack API error\",\n      raw: posted\n    });\n  }\n\n  return res.status(200).json({\n    ok: true,\n    mode: \"channel\",\n    channel,\n    ts: posted.ts\n  });\n} // (Optional) photo attachments via external upload — keep disabled until titles work 100%\n// async function maybeAttachPhotos({ token, listId, itemId, photoUrls, photosCol }) { ... }","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","linkUrl","bodyText","date","pn","sn","dom","trackingNumber","poNumber","workOrder","localSN","description","photoUrls","body","LISTS","tasks","id","SLACK_LIST_TASKS_ID","cols","desc","SLACK_LIST_TASKS_DESCRIPTION_COL","shipping","SLACK_LIST_SHIPPING_ID","SLACK_LIST_SHIPPING_DESCRIPTION_COL","SLACK_LIST_SHIPPING_DATE_COL","SLACK_LIST_SHIPPING_PNSN_COL","track","SLACK_LIST_SHIPPING_TRACKING_COL","wo","SLACK_LIST_SHIPPING_WO_COL","lsn","SLACK_LIST_SHIPPING_LOCALSN_COL","photos","SLACK_LIST_SHIPPING_PHOTOS_COL","receiving","SLACK_LIST_RECEIVING_ID","SLACK_LIST_RECEIVING_DESCRIPTION_COL","SLACK_LIST_RECEIVING_DATE_COL","SLACK_LIST_RECEIVING_PNSN_COL","SLACK_LIST_RECEIVING_TRACKING_COL","SLACK_LIST_RECEIVING_WO_COL","SLACK_LIST_RECEIVING_LOCALSN_COL","SLACK_LIST_RECEIVING_PHOTOS_COL","CHANNELS","SLACK_CHANNEL_TASKS_ID","SLACK_CHANNEL_SHIPPING_ID","SLACK_CHANNEL_RECEIVING_ID","headersJson","Authorization","slack","headers","r","fetch","console","log","Array","isArray","hasPhotos","length","TASKS","SHIPPING","RECEIVING","plain","v","toString","trim","joinArr","a","filter","Boolean","map","join","safeTitle","cfg","createBody","list_id","created","JSON","stringify","ok","warn","channelFallback","itemId","item","fields","addText","colId","text","t","push","column_id","value","textBits","pnStr","snStr","combo","updateBody","item_id","updated","mode","e","channel","URLSearchParams","lines","posted","raw","ts"],"mappings":"AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,WAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAArB,CAAP;AACD;;AAED,QAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;;AACA,MAAI,CAACH,KAAL,EAAY;AACV,WAAOL,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAArB,CAAP;AACD,GAR6C,CAU9C;;;AACA,QAAM;AACJK,IAAAA,OADI;AACgB;AACpBC,IAAAA,KAFI;AAEgB;AACpBC,IAAAA,OAHI;AAGKC,IAAAA,QAHL;AAIJC,IAAAA,IAJI;AAIEC,IAAAA,EAJF;AAIMC,IAAAA,EAJN;AAIUC,IAAAA,GAJV;AAIeC,IAAAA,cAJf;AAI+BC,IAAAA,QAJ/B;AAIyCC,IAAAA,SAJzC;AAIoDC,IAAAA,OAJpD;AAI6DC,IAAAA,WAJ7D;AAKJC,IAAAA,SAAS,GAAG;AALR,MAMFvB,GAAG,CAACwB,IAAJ,IAAY,EANhB,CAX8C,CAmB9C;;AACA,QAAMC,KAAK,GAAG;AACZC,IAAAA,KAAK,EAAE;AACLC,MAAAA,EAAE,EAAEpB,OAAO,CAACC,GAAR,CAAYoB,mBADX;AAELC,MAAAA,IAAI,EAAE;AACJ;AACA;AACAC,QAAAA,IAAI,EAAEvB,OAAO,CAACC,GAAR,CAAYuB,gCAHd,CAGgD;;AAHhD;AAFD,KADK;AASZC,IAAAA,QAAQ,EAAE;AACRL,MAAAA,EAAE,EAAEpB,OAAO,CAACC,GAAR,CAAYyB,sBADR;AAERJ,MAAAA,IAAI,EAAE;AACJC,QAAAA,IAAI,EAAIvB,OAAO,CAACC,GAAR,CAAY0B,mCADhB;AAEJpB,QAAAA,IAAI,EAAIP,OAAO,CAACC,GAAR,CAAY2B,4BAFhB;AAGJpB,QAAAA,EAAE,EAAMR,OAAO,CAACC,GAAR,CAAY4B,4BAHhB;AAIJC,QAAAA,KAAK,EAAG9B,OAAO,CAACC,GAAR,CAAY8B,gCAJhB;AAKJC,QAAAA,EAAE,EAAMhC,OAAO,CAACC,GAAR,CAAYgC,0BALhB;AAMJC,QAAAA,GAAG,EAAKlC,OAAO,CAACC,GAAR,CAAYkC,+BANhB;AAOJC,QAAAA,MAAM,EAAEpC,OAAO,CAACC,GAAR,CAAYoC,8BAPhB,CAOiD;;AAPjD;AAFE,KATE;AAqBZC,IAAAA,SAAS,EAAE;AACTlB,MAAAA,EAAE,EAAEpB,OAAO,CAACC,GAAR,CAAYsC,uBADP;AAETjB,MAAAA,IAAI,EAAE;AACJC,QAAAA,IAAI,EAAIvB,OAAO,CAACC,GAAR,CAAYuC,oCADhB;AAEJjC,QAAAA,IAAI,EAAIP,OAAO,CAACC,GAAR,CAAYwC,6BAFhB;AAGJjC,QAAAA,EAAE,EAAMR,OAAO,CAACC,GAAR,CAAYyC,6BAHhB;AAIJZ,QAAAA,KAAK,EAAG9B,OAAO,CAACC,GAAR,CAAY0C,iCAJhB;AAKJX,QAAAA,EAAE,EAAMhC,OAAO,CAACC,GAAR,CAAY2C,2BALhB;AAMJV,QAAAA,GAAG,EAAKlC,OAAO,CAACC,GAAR,CAAY4C,gCANhB;AAOJT,QAAAA,MAAM,EAAEpC,OAAO,CAACC,GAAR,CAAY6C,+BAPhB,CAOiD;;AAPjD;AAFG;AArBC,GAAd;AAmCA,QAAMC,QAAQ,GAAG;AACf5B,IAAAA,KAAK,EAAMnB,OAAO,CAACC,GAAR,CAAY+C,sBADR;AACoC;AACnDvB,IAAAA,QAAQ,EAAGzB,OAAO,CAACC,GAAR,CAAYgD,yBAFR;AAEoC;AACnDX,IAAAA,SAAS,EAAEtC,OAAO,CAACC,GAAR,CAAYiD,0BAHR,CAGoC;;AAHpC,GAAjB;AAMA,QAAMC,WAAW,GAAG;AAClBC,IAAAA,aAAa,EAAG,UAASrD,KAAM,EADb;AAElB,oBAAgB;AAFE,GAApB;;AAIA,QAAMsD,KAAK,GAAG,OAAO1D,MAAP,EAAesB,IAAf,EAAqBqC,OAAO,GAAGH,WAA/B,KAA+C;AAC3D,UAAMI,CAAC,GAAG,MAAMC,KAAK,CAAE,yBAAwB7D,MAAO,EAAjC,EAAoC;AACvDA,MAAAA,MAAM,EAAE,MAD+C;AAEvD2D,MAAAA,OAFuD;AAGvDrC,MAAAA;AAHuD,KAApC,CAArB;AAKA,WAAOsC,CAAC,CAAC1D,IAAF,EAAP;AACD,GAPD,CAjE8C,CA0E9C;;;AACA4D,EAAAA,OAAO,CAACC,GAAR,CAAY,qBAAZ,EAAmC;AACjCvD,IAAAA,OADiC;AAEjCC,IAAAA,KAFiC;AAGjCU,IAAAA,OAHiC;AAIjCN,IAAAA,EAAE,EAAEmD,KAAK,CAACC,OAAN,CAAcpD,EAAd,IAAoBA,EAApB,GAA0BA,EAAE,GAAG,CAACA,EAAD,CAAH,GAAU,EAJT;AAKjCC,IAAAA,EAAE,EAAEkD,KAAK,CAACC,OAAN,CAAcnD,EAAd,IAAoBA,EAApB,GAA0BA,EAAE,GAAG,CAACA,EAAD,CAAH,GAAU,EALT;AAMjCoD,IAAAA,SAAS,EAAEF,KAAK,CAACC,OAAN,CAAc5C,SAAd,KAA4BA,SAAS,CAAC8C;AANhB,GAAnC;AAQAL,EAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ,EAAkC;AAChCK,IAAAA,KAAK,EAAE,CAAC,CAAC/D,OAAO,CAACC,GAAR,CAAYoB,mBADW;AAEhC2C,IAAAA,QAAQ,EAAE,CAAC,CAAChE,OAAO,CAACC,GAAR,CAAYyB,sBAFQ;AAGhCuC,IAAAA,SAAS,EAAE,CAAC,CAACjE,OAAO,CAACC,GAAR,CAAYsC;AAHO,GAAlC,EAnF8C,CAyF9C;;AACA,QAAM2B,KAAK,GAAIC,CAAD,IAAO,CAACA,CAAD,aAACA,CAAD,cAACA,CAAD,GAAM,EAAN,EAAUC,QAAV,GAAqBC,IAArB,EAArB;;AACA,QAAMC,OAAO,GAAIC,CAAD,IACdZ,KAAK,CAACC,OAAN,CAAcW,CAAd,IAAmBA,CAAC,CAACC,MAAF,CAASC,OAAT,EAAkBC,GAAlB,CAAsBR,KAAtB,EAA6BS,IAA7B,CAAkC,IAAlC,CAAnB,GAA6DT,KAAK,CAACK,CAAD,CADpE,CA3F8C,CA8F9C;AACA;;;AACA,QAAMK,SAAS,GACbV,KAAK,CAAC9D,KAAD,CAAL,KACC8D,KAAK,CAACpD,OAAD,CAAL,GAAkB,QAAOoD,KAAK,CAACpD,OAAD,CAAU,EAAxC,GAA4C,EAD7C,KAEAwD,OAAO,CAAC9D,EAAD,CAFP,IAGA,UAJF;AAMA,QAAMqE,GAAG,GAAG3D,KAAK,CAACf,OAAD,CAAjB,CAtG8C,CAwG9C;;AACA,MAAI0E,GAAJ,aAAIA,GAAJ,eAAIA,GAAG,CAAEzD,EAAT,EAAa;AACX,QAAI;AAAA;;AACF;AACA,YAAM0D,UAAU,GAAG;AACjBC,QAAAA,OAAO,EAAEF,GAAG,CAACzD,EADI;AAEjBhB,QAAAA,KAAK,EAAEwE,SAFU,CAEC;;AAFD,OAAnB;AAIAnB,MAAAA,OAAO,CAACC,GAAR,CAAY,2BAAZ,EAAyCoB,UAAzC;AAEA,YAAME,OAAO,GAAG,MAAM3B,KAAK,CACzB,yBADyB,EAEzB4B,IAAI,CAACC,SAAL,CAAeJ,UAAf,CAFyB,CAA3B;AAIArB,MAAAA,OAAO,CAACC,GAAR,CAAY,gCAAZ,EAA8CsB,OAA9C;;AAEA,UAAI,EAACA,OAAD,aAACA,OAAD,eAACA,OAAO,CAAEG,EAAV,CAAJ,EAAkB;AAChB;AACA1B,QAAAA,OAAO,CAAC2B,IAAR,CAAa,iDAAb,EAAgEJ,OAAhE,aAAgEA,OAAhE,uBAAgEA,OAAO,CAAElF,KAAzE;AACA,eAAO,MAAMuF,eAAe,CAAC;AAAEhC,UAAAA,KAAF;AAAStD,UAAAA,KAAT;AAAgBgD,UAAAA,QAAhB;AAA0B5C,UAAAA,OAA1B;AAAmCyE,UAAAA,SAAnC;AAA8CvE,UAAAA,OAA9C;AAAuDG,UAAAA,EAAvD;AAA2DC,UAAAA,EAA3D;AAA+DC,UAAAA,GAA/D;AAAoEG,UAAAA,SAApE;AAA+ED,UAAAA,QAA/E;AAAyFD,UAAAA,cAAzF;AAAyGG,UAAAA,OAAzG;AAAkHP,UAAAA,IAAlH;AAAwHD,UAAAA,QAAxH;AAAkIS,UAAAA,WAAlI;AAA+IrB,UAAAA;AAA/I,SAAD,CAA5B;AACD;;AAED,YAAM4F,MAAM,GAAGN,OAAH,aAAGA,OAAH,wCAAGA,OAAO,CAAEO,IAAZ,kDAAG,cAAenE,EAA9B,CApBE,CAqBF;;AACA,YAAMoE,MAAM,GAAG,EAAf;AAEA,YAAMlE,IAAI,GAAGuD,GAAG,CAACvD,IAAJ,IAAY,EAAzB;;AAEA,YAAMmE,OAAO,GAAG,CAACC,KAAD,EAAQC,IAAR,KAAiB;AAC/B,cAAMC,CAAC,GAAG1B,KAAK,CAACyB,IAAD,CAAf;AACA,YAAID,KAAK,IAAIE,CAAb,EAAgBJ,MAAM,CAACK,IAAP,CAAY;AAAEC,UAAAA,SAAS,EAAEJ,KAAb;AAAoBK,UAAAA,KAAK,EAAE;AAAEJ,YAAAA,IAAI,EAAEC;AAAR;AAA3B,SAAZ;AACjB,OAHD,CA1BE,CA+BF;;;AACA,UAAItE,IAAI,CAACC,IAAT,EAAe;AACb,cAAMyE,QAAQ,GAAG,CACf9B,KAAK,CAACnD,WAAD,CADU,EAEfZ,OAAO,KAAK,OAAZ,GAAsB+D,KAAK,CAAC5D,QAAD,CAA3B,GAAwC,EAFzB,EAGf4D,KAAK,CAAC7D,OAAD,CAAL,GAAkB,IAAG6D,KAAK,CAAC7D,OAAD,CAAU,iBAApC,GAAuD,EAHxC,EAKdmE,MALc,CAKPC,OALO,EAMdE,IANc,CAMT,IANS,CAAjB;AAOAc,QAAAA,OAAO,CAACnE,IAAI,CAACC,IAAN,EAAYyE,QAAZ,CAAP;AACD,OAzCC,CA2CF;;;AACA,UAAI1E,IAAI,CAACf,IAAL,IAAa2D,KAAK,CAAC3D,IAAD,CAAtB,EAA8B;AAC5BiF,QAAAA,MAAM,CAACK,IAAP,CAAY;AAAEC,UAAAA,SAAS,EAAExE,IAAI,CAACf,IAAlB;AAAwBwF,UAAAA,KAAK,EAAE;AAAExF,YAAAA,IAAI,EAAE2D,KAAK,CAAC3D,IAAD;AAAb;AAA/B,SAAZ;AACD,OA9CC,CAgDF;;;AACA,UAAIe,IAAI,CAACd,EAAT,EAAa;AACX,cAAMyF,KAAK,GAAG3B,OAAO,CAAC9D,EAAD,CAArB;AACA,cAAM0F,KAAK,GAAG5B,OAAO,CAAC7D,EAAD,CAArB;AACA,cAAM0F,KAAK,GAAG,CACZF,KAAK,IAAK,OAAMA,KAAM,EADV,EAEZC,KAAK,IAAK,OAAMA,KAAM,EAFV,EAGZhC,KAAK,CAACxD,GAAD,CAAL,IAAe,QAAOwD,KAAK,CAACxD,GAAD,CAAM,EAHrB,EAKX8D,MALW,CAKJC,OALI,EAMXE,IANW,CAMN,IANM,CAAd;AAOAc,QAAAA,OAAO,CAACnE,IAAI,CAACd,EAAN,EAAU2F,KAAV,CAAP;AACD,OA5DC,CA8DF;;;AACA,UAAI7E,IAAI,CAACQ,KAAT,EAAgB;AACd,cAAM8D,CAAC,GAAG,CACR1B,KAAK,CAACvD,cAAD,CAAL,IAA0B,OAAMuD,KAAK,CAACvD,cAAD,CAAiB,EAD9C,EAERuD,KAAK,CAACtD,QAAD,CAAL,IAAoB,OAAMsD,KAAK,CAACtD,QAAD,CAAW,EAFlC,EAIP4D,MAJO,CAIAC,OAJA,EAKPE,IALO,CAKF,IALE,CAAV;AAMAc,QAAAA,OAAO,CAACnE,IAAI,CAACQ,KAAN,EAAa8D,CAAb,CAAP;AACD,OAvEC,CAyEF;;;AACA,UAAItE,IAAI,CAACU,EAAT,EAAayD,OAAO,CAACnE,IAAI,CAACU,EAAN,EAAUkC,KAAK,CAACrD,SAAD,CAAL,IAAqB,OAAMqD,KAAK,CAACrD,SAAD,CAAY,EAAtD,CAAP,CA1EX,CA4EF;;AACA,UAAIS,IAAI,CAACY,GAAT,EAAcuD,OAAO,CAACnE,IAAI,CAACY,GAAN,EAAWgC,KAAK,CAACpD,OAAD,CAAhB,CAAP,CA7EZ,CA+EF;;AACA,UAAI0E,MAAM,CAAC1B,MAAX,EAAmB;AACjB,cAAMsC,UAAU,GAAG;AACjBrB,UAAAA,OAAO,EAAEF,GAAG,CAACzD,EADI;AAEjBiF,UAAAA,OAAO,EAAEf,MAFQ;AAGjBE,UAAAA;AAHiB,SAAnB;AAKA/B,QAAAA,OAAO,CAACC,GAAR,CAAY,2BAAZ,EAAyC0C,UAAzC;AAEA,cAAME,OAAO,GAAG,MAAMjD,KAAK,CACzB,yBADyB,EAEzB4B,IAAI,CAACC,SAAL,CAAekB,UAAf,CAFyB,CAA3B;AAIA3C,QAAAA,OAAO,CAACC,GAAR,CAAY,gCAAZ,EAA8C4C,OAA9C,EAZiB,CAcjB;;AACA,YAAI,EAACA,OAAD,aAACA,OAAD,eAACA,OAAO,CAAEnB,EAAV,CAAJ,EAAkB;AAChB1B,UAAAA,OAAO,CAAC2B,IAAR,CAAa,oDAAb,EAAmEkB,OAAnE,aAAmEA,OAAnE,uBAAmEA,OAAO,CAAExG,KAA5E;AACD;AACF,OAlGC,CAoGF;AACA;AACA;;;AAEA,aAAOJ,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEsF,QAAAA,EAAE,EAAE,IAAN;AAAYoB,QAAAA,IAAI,EAAE,MAAlB;AAA0BxB,QAAAA,OAAO,EAAEF,GAAG,CAACzD,EAAvC;AAA2CiF,QAAAA,OAAO,EAAEf;AAApD,OAArB,CAAP;AACD,KAzGD,CAyGE,OAAOkB,CAAP,EAAU;AACV/C,MAAAA,OAAO,CAAC3D,KAAR,CAAc,mBAAd,EAAmC0G,CAAnC,EADU,CAEV;;AACA,aAAO,MAAMnB,eAAe,CAAC;AAAEhC,QAAAA,KAAF;AAAStD,QAAAA,KAAT;AAAgBgD,QAAAA,QAAhB;AAA0B5C,QAAAA,OAA1B;AAAmCyE,QAAAA,SAAnC;AAA8CvE,QAAAA,OAA9C;AAAuDG,QAAAA,EAAvD;AAA2DC,QAAAA,EAA3D;AAA+DC,QAAAA,GAA/D;AAAoEG,QAAAA,SAApE;AAA+ED,QAAAA,QAA/E;AAAyFD,QAAAA,cAAzF;AAAyGG,QAAAA,OAAzG;AAAkHP,QAAAA,IAAlH;AAAwHD,QAAAA,QAAxH;AAAkIS,QAAAA,WAAlI;AAA+IrB,QAAAA;AAA/I,OAAD,CAA5B;AACD;AACF,GAxN6C,CA0N9C;;;AACA,SAAO,MAAM2F,eAAe,CAAC;AAAEhC,IAAAA,KAAF;AAAStD,IAAAA,KAAT;AAAgBgD,IAAAA,QAAhB;AAA0B5C,IAAAA,OAA1B;AAAmCyE,IAAAA,SAAnC;AAA8CvE,IAAAA,OAA9C;AAAuDG,IAAAA,EAAvD;AAA2DC,IAAAA,EAA3D;AAA+DC,IAAAA,GAA/D;AAAoEG,IAAAA,SAApE;AAA+ED,IAAAA,QAA/E;AAAyFD,IAAAA,cAAzF;AAAyGG,IAAAA,OAAzG;AAAkHP,IAAAA,IAAlH;AAAwHD,IAAAA,QAAxH;AAAkIS,IAAAA,WAAlI;AAA+IrB,IAAAA;AAA/I,GAAD,CAA5B;AACD,C,CAED;;AAEA,eAAe2F,eAAf,CAA+B;AAC7BhC,EAAAA,KAD6B;AACtBtD,EAAAA,KADsB;AACfgD,EAAAA,QADe;AACL5C,EAAAA,OADK;AACIyE,EAAAA,SADJ;AACevE,EAAAA,OADf;AACwBG,EAAAA,EADxB;AAC4BC,EAAAA,EAD5B;AACgCC,EAAAA,GADhC;AACqCG,EAAAA,SADrC;AACgDD,EAAAA,QADhD;AAC0DD,EAAAA,cAD1D;AAC0EG,EAAAA,OAD1E;AACmFP,EAAAA,IADnF;AACyFD,EAAAA,QADzF;AACmGS,EAAAA,WADnG;AACgHrB,EAAAA;AADhH,CAA/B,EAEG;AACD,QAAM+G,OAAO,GAAG1D,QAAQ,CAAC5C,OAAD,CAAxB;;AACA,MAAI,CAACsG,OAAL,EAAc;AACZ,WAAO/G,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,KAAK,EAAE;AAAT,KAArB,CAAP;AACD,GAJA,CAMD;;;AACA,MAAI;AACF,UAAM0D,KAAK,CAAC,0CAAD,EAA6C;AACtD7D,MAAAA,MAAM,EAAE,MAD8C;AAEtD2D,MAAAA,OAAO,EAAE;AAAEF,QAAAA,aAAa,EAAG,UAASrD,KAAM,EAAjC;AAAoC,wBAAgB;AAApD,OAF6C;AAGtDkB,MAAAA,IAAI,EAAE,IAAIyF,eAAJ,CAAoB;AAAED,QAAAA;AAAF,OAApB;AAHgD,KAA7C,CAAX;AAKD,GAND,CAME,MAAM,CAAE;;AAEV,QAAMvC,KAAK,GAAIC,CAAD,IAAO,CAACA,CAAD,aAACA,CAAD,cAACA,CAAD,GAAM,EAAN,EAAUC,QAAV,GAAqBC,IAArB,EAArB;;AACA,QAAMC,OAAO,GAAIC,CAAD,IACdZ,KAAK,CAACC,OAAN,CAAcW,CAAd,IAAmBA,CAAC,CAACC,MAAF,CAASC,OAAT,EAAkBC,GAAlB,CAAsBR,KAAtB,EAA6BS,IAA7B,CAAkC,IAAlC,CAAnB,GAA6DT,KAAK,CAACK,CAAD,CADpE;;AAGA,QAAMoC,KAAK,GAAG,EAAd;AACAA,EAAAA,KAAK,CAACd,IAAN,CAAY,IAAGjB,SAAU,GAAzB;AACA,QAAMqB,KAAK,GAAG3B,OAAO,CAAC9D,EAAD,CAArB;AACA,QAAM0F,KAAK,GAAG5B,OAAO,CAAC7D,EAAD,CAArB;AACA,MAAIwF,KAAJ,EAAWU,KAAK,CAACd,IAAN,CAAY,OAAMI,KAAM,EAAxB;AACX,MAAIC,KAAJ,EAAWS,KAAK,CAACd,IAAN,CAAY,OAAMK,KAAM,EAAxB;AACX,MAAIhC,KAAK,CAACrD,SAAD,CAAT,EAAsB8F,KAAK,CAACd,IAAN,CAAY,OAAM3B,KAAK,CAACrD,SAAD,CAAY,EAAnC;AACtB,MAAIqD,KAAK,CAACtD,QAAD,CAAT,EAAsB+F,KAAK,CAACd,IAAN,CAAY,OAAM3B,KAAK,CAACtD,QAAD,CAAW,EAAlC;AACtB,MAAIsD,KAAK,CAACvD,cAAD,CAAT,EAA2BgG,KAAK,CAACd,IAAN,CAAY,OAAM3B,KAAK,CAACvD,cAAD,CAAiB,EAAxC;AAC3B,MAAIuD,KAAK,CAACxD,GAAD,CAAT,EAAsBiG,KAAK,CAACd,IAAN,CAAY,QAAO3B,KAAK,CAACxD,GAAD,CAAM,EAA9B;AACtB,MAAIwD,KAAK,CAACpD,OAAD,CAAT,EAAsB6F,KAAK,CAACd,IAAN,CAAY,aAAY3B,KAAK,CAACpD,OAAD,CAAU,EAAvC;AACtB,MAAIoD,KAAK,CAAC3D,IAAD,CAAT,EAAsBoG,KAAK,CAACd,IAAN,CAAY,SAAQ3B,KAAK,CAAC3D,IAAD,CAAO,EAAhC;AACtB,QAAMgB,IAAI,GAAG2C,KAAK,CAACnD,WAAD,CAAlB;AACA,MAAIQ,IAAJ,EAAsBoF,KAAK,CAACd,IAAN,CAAWtE,IAAX,EAAtB,KACK,IAAIpB,OAAO,KAAK,OAAZ,IAAuB+D,KAAK,CAAC5D,QAAD,CAAhC,EAA4CqG,KAAK,CAACd,IAAN,CAAW3B,KAAK,CAAC5D,QAAD,CAAhB;AACjD,MAAI4D,KAAK,CAAC7D,OAAD,CAAT,EAAsBsG,KAAK,CAACd,IAAN,CAAY,IAAG3B,KAAK,CAAC7D,OAAD,CAAU,iBAA9B;AAEtB,QAAMsF,IAAI,GAAGgB,KAAK,CAACnC,MAAN,CAAaC,OAAb,EAAsBE,IAAtB,CAA2B,IAA3B,KAAoC,uBAAjD;AACAlB,EAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ,EAAkC;AAAE+C,IAAAA,OAAF;AAAWd,IAAAA;AAAX,GAAlC;AAEA,QAAMiB,MAAM,GAAG,MAAMvD,KAAK,CAAC,kBAAD,EAAqB4B,IAAI,CAACC,SAAL,CAAe;AAAEuB,IAAAA,OAAF;AAAWd,IAAAA;AAAX,GAAf,CAArB,CAA1B;AACAlC,EAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ,EAAuCkD,MAAvC;;AAEA,MAAI,EAACA,MAAD,aAACA,MAAD,eAACA,MAAM,CAAEzB,EAAT,CAAJ,EAAiB;AACf,WAAOzF,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,KAAK,EAAE,CAAA8G,MAAM,SAAN,IAAAA,MAAM,WAAN,YAAAA,MAAM,CAAE9G,KAAR,KAAiB,iBAA1B;AAA6C+G,MAAAA,GAAG,EAAED;AAAlD,KAArB,CAAP;AACD;;AACD,SAAOlH,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEsF,IAAAA,EAAE,EAAE,IAAN;AAAYoB,IAAAA,IAAI,EAAE,SAAlB;AAA6BE,IAAAA,OAA7B;AAAsCK,IAAAA,EAAE,EAAEF,MAAM,CAACE;AAAjD,GAArB,CAAP;AACD,C,CAED;AACA","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\r\n\r\n//   try {\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\r\n\r\n//     const {\r\n//       listKey,            // \"receiving\" | \"shipping\" | \"tasks\"\r\n//       title, linkUrl, bodyText,\r\n//       date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n//       photoUrls = [],\r\n//     } = req.body;\r\n\r\n//     const LISTS = {\r\n//       receiving: {\r\n//         id: process.env.SLACK_LIST_RECEIVING_ID,\r\n//         cols: {\r\n//           desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n//           date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\r\n//           pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n//           track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n//           wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n//           lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n//           photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // attachment\r\n//         },\r\n//       },\r\n//       shipping: {\r\n//         id: process.env.SLACK_LIST_SHIPPING_ID,\r\n//         cols: {\r\n//           desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n//           date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\r\n//           pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n//           track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n//           wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n//           lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n//           photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,  // attachment\r\n//         },\r\n//       },\r\n//       tasks: {\r\n//         id: process.env.SLACK_LIST_TASKS_ID,\r\n//         cols: {\r\n//           desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\r\n//         },\r\n//       },\r\n//     };\r\n\r\n//     const CHANNELS = {\r\n//       receiving: process.env.SLACK_CHANNEL_RECEIVING_ID,\r\n//       shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,\r\n//       tasks:     process.env.SLACK_CHANNEL_TASKS_ID,\r\n//     };\r\n\r\n//     const headersJson = {\r\n//       Authorization: `Bearer ${token}`,\r\n//       \"Content-Type\": \"application/json; charset=utf-8\",\r\n//     };\r\n//     const slack = (method, body, headers = headersJson) =>\r\n//       fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body })\r\n//         .then(r => r.json());\r\n\r\n//     const plain = v => (v ?? \"\").toString().trim();\r\n//     const safe  = plain;\r\n//     const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     // ---------- PATH A: Write to a LIST ----------\r\n//     const cfg = LISTS[listKey];\r\n//     if (cfg?.id) {\r\n//       const fields = [];\r\n\r\n//       // Description column\r\n//       if (cfg.cols.desc && (description || bodyText || linkUrl)) {\r\n//         const textBits = [\r\n//           description,\r\n//           (listKey === \"tasks\" && bodyText) ? bodyText : null,\r\n//           linkUrl ? `<${linkUrl}|Open in Magmo>` : null,\r\n//         ].filter(Boolean).join(\"\\n\");\r\n//         fields.push({ column_id: cfg.cols.desc, value: { text: textBits } });\r\n//       }\r\n\r\n//       if (cfg.cols.date && date) fields.push({ column_id: cfg.cols.date, value: { date } });\r\n\r\n//       if (cfg.cols.pn && (pn || sn || dom)) {\r\n//         const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : (pn ? `PN: ${pn}` : \"\");\r\n//         const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : (sn ? `SN: ${sn}` : \"\");\r\n//         const domLine = dom ? `DOM: ${dom}` : \"\";\r\n//         const pnBlock = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\r\n//         if (pnBlock) fields.push({ column_id: cfg.cols.pn, value: { text: pnBlock } });\r\n//       }\r\n\r\n//       if (cfg.cols.track && (trackingNumber || poNumber)) {\r\n//         const t = [\r\n//           trackingNumber ? `RL: ${trackingNumber}` : \"\",\r\n//           poNumber ? `PO: ${poNumber}` : \"\",\r\n//         ].filter(Boolean).join(\"  \");\r\n//         if (t) fields.push({ column_id: cfg.cols.track, value: { text: t } });\r\n//       }\r\n\r\n//       if (cfg.cols.wo && workOrder) fields.push({ column_id: cfg.cols.wo,  value: { text: `WO: ${workOrder}` } });\r\n//       if (cfg.cols.lsn && localSN)  fields.push({ column_id: cfg.cols.lsn, value: { text: localSN } });\r\n\r\n//       // NOW build the create body (cfg & fields exist)\r\n//       const createBody = {\r\n//         list_id: cfg.id,\r\n//         title: plain(title) || plain(localSN) || \"Untitled\",\r\n//         fields,\r\n//       };\r\n\r\n//       const created = await slack(\"slackLists.items.create\", JSON.stringify(createBody));\r\n//       if (!created?.ok) {\r\n//         console.error(\"slackLists.items.create error:\", created);\r\n//         return res.status(400).json({ error: created?.error || \"Slack Lists API error\", raw: created });\r\n//       }\r\n\r\n//       // Photos -> attachment column\r\n//       if (cfg.cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\r\n//         const fileIds = [];\r\n//         for (const url of photoUrls) {\r\n//           const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\r\n//             method: \"POST\",\r\n//             headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n//             body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\r\n//           }).then(r => r.json());\r\n\r\n//           if (!init?.ok || !init?.upload_url) continue;\r\n\r\n//           try {\r\n//             const img = await fetch(url);\r\n//             const buf = await img.arrayBuffer();\r\n//             await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\r\n//           } catch (_) {}\r\n\r\n//           const complete = await slack(\"files.completeUploadExternal\",\r\n//             JSON.stringify({ files: [{ id: init.file_id, title: \"photo\" }] })\r\n//           );\r\n//           if (complete?.ok && complete?.files?.[0]?.id) fileIds.push(complete.files[0].id);\r\n//         }\r\n\r\n//         if (fileIds.length) {\r\n//           await slack(\"slackLists.items.update\", JSON.stringify({\r\n//             list_id: cfg.id,\r\n//             item_id: created.item.id,\r\n//             fields: [{ column_id: cfg.cols.photos, value: { attachment: { file_ids: fileIds } } }],\r\n//           }));\r\n//         }\r\n//       }\r\n\r\n//       return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: created.item.id });\r\n//     }\r\n\r\n//     // ---------- PATH B: Fallback to a channel post ----------\r\n//     const channel = CHANNELS[listKey];\r\n//     if (!channel) return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\r\n\r\n//     // Try to join public channels to avoid channel_not_found\r\n//     await fetch(\"https://slack.com/api/conversations.join\", {\r\n//       method: \"POST\",\r\n//       headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n//       body: new URLSearchParams({ channel }),\r\n//     });\r\n\r\n//     const safeId = plain(linkUrl?.split(\"/\").pop()) || plain(localSN) || \"\";\r\n//     const safeTitle = plain(title) || plain(req.body?.title) || (safeId ? `Item ${safeId}` : \"New Item\");\r\n\r\n//     const lines = [];\r\n//     lines.push(`*${safeTitle}*`);\r\n\r\n//     const pnStr = joinArr(pn);\r\n//     const snStr = joinArr(sn);\r\n//     if (pnStr) lines.push(`PN: ${pnStr}`);\r\n//     if (snStr) lines.push(`SN: ${snStr}`);\r\n//     if (safe(workOrder)) lines.push(`WO: ${safe(workOrder)}`);\r\n//     if (safe(poNumber)) lines.push(`PO: ${safe(poNumber)}`);\r\n//     if (safe(trackingNumber)) lines.push(`RL: ${safe(trackingNumber)}`);\r\n//     if (safe(dom)) lines.push(`DOM: ${safe(dom)}`);\r\n//     if (safe(localSN)) lines.push(`Local SN: ${safe(localSN)}`);\r\n//     if (safe(date)) lines.push(`Date: ${safe(date)}`);\r\n\r\n//     const desc = safe(description);\r\n//     if (desc) lines.push(desc);\r\n//     else if (listKey === \"tasks\" && safe(bodyText)) lines.push(safe(bodyText));\r\n\r\n//     if (safe(linkUrl)) lines.push(`<${safe(linkUrl)}|Open in Magmo>`);\r\n\r\n//     const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\r\n\r\n//     const posted = await slack(\"chat.postMessage\", JSON.stringify({ channel, text }));\r\n//     if (!posted?.ok) {\r\n//       console.error(\"chat.postMessage error:\", posted);\r\n//       return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\r\n//     }\r\n\r\n//     return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\r\n//   } catch (e) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", e);\r\n//     return res.status(500).json({ error: \"Server error\" });\r\n//   }\r\n// }\r\n\r\n\r\n// pages/api/slack/add-to-list.js\r\n\r\nexport default async function handler(req, res) {\r\n  if (req.method !== \"POST\") {\r\n    return res.status(405).json({ error: \"Method not allowed\" });\r\n  }\r\n\r\n  const token = process.env.SLACK_BOT_TOKEN;\r\n  if (!token) {\r\n    return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\r\n  }\r\n\r\n  // Payload from client\r\n  const {\r\n    listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\r\n    title,              // human title coming from the client (use this!)\r\n    linkUrl, bodyText,\r\n    date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n    photoUrls = [],\r\n  } = req.body || {};\r\n\r\n  // --- ENV mapping: only the list IDs are strictly required to get the title in.\r\n  const LISTS = {\r\n    tasks: {\r\n      id: process.env.SLACK_LIST_TASKS_ID,\r\n      cols: {\r\n        // OPTIONAL column ids; fill only the ones you actually have\r\n        // title column is implicit via \"title\" below; do not pass a column for that\r\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL, // \"Task\" list's notes/description column (optional)\r\n      },\r\n    },\r\n    shipping: {\r\n      id: process.env.SLACK_LIST_SHIPPING_ID,\r\n      cols: {\r\n        desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n        date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\r\n        pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n        track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n        wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n        lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,  // attachment col (optional)\r\n      },\r\n    },\r\n    receiving: {\r\n      id: process.env.SLACK_LIST_RECEIVING_ID,\r\n      cols: {\r\n        desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n        date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\r\n        pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n        track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n        wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n        lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // attachment col (optional)\r\n      },\r\n    },\r\n  };\r\n\r\n  const CHANNELS = {\r\n    tasks:     process.env.SLACK_CHANNEL_TASKS_ID,     // optional fallback\r\n    shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,  // optional fallback\r\n    receiving: process.env.SLACK_CHANNEL_RECEIVING_ID, // optional fallback\r\n  };\r\n\r\n  const headersJson = {\r\n    Authorization: `Bearer ${token}`,\r\n    \"Content-Type\": \"application/json; charset=utf-8\",\r\n  };\r\n  const slack = async (method, body, headers = headersJson) => {\r\n    const r = await fetch(`https://slack.com/api/${method}`, {\r\n      method: \"POST\",\r\n      headers,\r\n      body,\r\n    });\r\n    return r.json();\r\n  };\r\n\r\n  // --------- logging to server console (see your terminal) ----------\r\n  console.log(\"add-to-list payload\", {\r\n    listKey,\r\n    title,\r\n    localSN,\r\n    pn: Array.isArray(pn) ? pn : (pn ? [pn] : []),\r\n    sn: Array.isArray(sn) ? sn : (sn ? [sn] : []),\r\n    hasPhotos: Array.isArray(photoUrls) && photoUrls.length,\r\n  });\r\n  console.log(\"env lists present?\", {\r\n    TASKS: !!process.env.SLACK_LIST_TASKS_ID,\r\n    SHIPPING: !!process.env.SLACK_LIST_SHIPPING_ID,\r\n    RECEIVING: !!process.env.SLACK_LIST_RECEIVING_ID,\r\n  });\r\n\r\n  // --------- safe helpers ----------\r\n  const plain = (v) => (v ?? \"\").toString().trim();\r\n  const joinArr = (a) =>\r\n    Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n  // Build a safe, never-empty title for the SERVER (belt & suspenders)\r\n  // NOTE: Slack Lists has a dedicated \"title\" field — this populates your \"Task\"/\"Item\" column in the UI.\r\n  const safeTitle =\r\n    plain(title) ||\r\n    (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\r\n    joinArr(pn) ||\r\n    \"New Item\";\r\n\r\n  const cfg = LISTS[listKey];\r\n\r\n  // ============ PATH A: Slack Lists (preferred) ============\r\n  if (cfg?.id) {\r\n    try {\r\n      // 1) Create the row with ONLY the title first. This guarantees a non-empty item in the UI.\r\n      const createBody = {\r\n        list_id: cfg.id,\r\n        title: safeTitle, // ← keep as a plain string; Slack will render it in the list's primary column (\"Task\"/\"Item\")\r\n      };\r\n      console.log(\"slackLists.items.create >\", createBody);\r\n\r\n      const created = await slack(\r\n        \"slackLists.items.create\",\r\n        JSON.stringify(createBody)\r\n      );\r\n      console.log(\"slackLists.items.create < resp\", created);\r\n\r\n      if (!created?.ok) {\r\n        // If Lists API rejects, try channel fallback (below)\r\n        console.warn(\"Lists create failed, will try channel fallback:\", created?.error);\r\n        return await channelFallback({ slack, token, CHANNELS, listKey, safeTitle, linkUrl, pn, sn, dom, workOrder, poNumber, trackingNumber, localSN, date, bodyText, description, res });\r\n      }\r\n\r\n      const itemId = created?.item?.id;\r\n      // 2) Now (optionally) patch additional columns — only if those column IDs exist.\r\n      const fields = [];\r\n\r\n      const cols = cfg.cols || {};\r\n\r\n      const addText = (colId, text) => {\r\n        const t = plain(text);\r\n        if (colId && t) fields.push({ column_id: colId, value: { text: t } });\r\n      };\r\n\r\n      // Description / Notes column\r\n      if (cols.desc) {\r\n        const textBits = [\r\n          plain(description),\r\n          listKey === \"tasks\" ? plain(bodyText) : \"\",\r\n          plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\r\n        ]\r\n          .filter(Boolean)\r\n          .join(\"\\n\");\r\n        addText(cols.desc, textBits);\r\n      }\r\n\r\n      // Date column (Slack expects { date: \"YYYY-MM-DD\" })\r\n      if (cols.date && plain(date)) {\r\n        fields.push({ column_id: cols.date, value: { date: plain(date) } });\r\n      }\r\n\r\n      // PN/SN/DOM combo column\r\n      if (cols.pn) {\r\n        const pnStr = joinArr(pn);\r\n        const snStr = joinArr(sn);\r\n        const combo = [\r\n          pnStr && `PN: ${pnStr}`,\r\n          snStr && `SN: ${snStr}`,\r\n          plain(dom) && `DOM: ${plain(dom)}`,\r\n        ]\r\n          .filter(Boolean)\r\n          .join(\"  \");\r\n        addText(cols.pn, combo);\r\n      }\r\n\r\n      // Tracking/PO column\r\n      if (cols.track) {\r\n        const t = [\r\n          plain(trackingNumber) && `RL: ${plain(trackingNumber)}`,\r\n          plain(poNumber) && `PO: ${plain(poNumber)}`,\r\n        ]\r\n          .filter(Boolean)\r\n          .join(\"  \");\r\n        addText(cols.track, t);\r\n      }\r\n\r\n      // Work order column\r\n      if (cols.wo) addText(cols.wo, plain(workOrder) && `WO: ${plain(workOrder)}`);\r\n\r\n      // Local SN column\r\n      if (cols.lsn) addText(cols.lsn, plain(localSN));\r\n\r\n      // Patch fields if we actually have any *valid* (non-empty) field + column_id pairs\r\n      if (fields.length) {\r\n        const updateBody = {\r\n          list_id: cfg.id,\r\n          item_id: itemId,\r\n          fields,\r\n        };\r\n        console.log(\"slackLists.items.update >\", updateBody);\r\n\r\n        const updated = await slack(\r\n          \"slackLists.items.update\",\r\n          JSON.stringify(updateBody)\r\n        );\r\n        console.log(\"slackLists.items.update < resp\", updated);\r\n\r\n        // If this fails because of a bad column_id, we still keep the row (title already created).\r\n        if (!updated?.ok) {\r\n          console.warn(\"Lists update failed; leaving item with title only:\", updated?.error);\r\n        }\r\n      }\r\n\r\n      // (Optional) Attach photos to attachment column — skip for now unless you really want it:\r\n      // If you enable this, make sure cols.photos is the ID of an \"attachment\" type column.\r\n      // await maybeAttachPhotos({ token, listId: cfg.id, itemId, photoUrls, photosCol: cols.photos });\r\n\r\n      return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: itemId });\r\n    } catch (e) {\r\n      console.error(\"Lists path error:\", e);\r\n      // If something exploded, still try channel fallback\r\n      return await channelFallback({ slack, token, CHANNELS, listKey, safeTitle, linkUrl, pn, sn, dom, workOrder, poNumber, trackingNumber, localSN, date, bodyText, description, res });\r\n    }\r\n  }\r\n\r\n  // ============ PATH B: Only channel configured ============\r\n  return await channelFallback({ slack, token, CHANNELS, listKey, safeTitle, linkUrl, pn, sn, dom, workOrder, poNumber, trackingNumber, localSN, date, bodyText, description, res });\r\n}\r\n\r\n// ---------------- helpers ----------------\r\n\r\nasync function channelFallback({\r\n  slack, token, CHANNELS, listKey, safeTitle, linkUrl, pn, sn, dom, workOrder, poNumber, trackingNumber, localSN, date, bodyText, description, res\r\n}) {\r\n  const channel = CHANNELS[listKey];\r\n  if (!channel) {\r\n    return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\r\n  }\r\n\r\n  // Join public channels to avoid channel_not_found (ignore failures)\r\n  try {\r\n    await fetch(\"https://slack.com/api/conversations.join\", {\r\n      method: \"POST\",\r\n      headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n      body: new URLSearchParams({ channel }),\r\n    });\r\n  } catch {}\r\n\r\n  const plain = (v) => (v ?? \"\").toString().trim();\r\n  const joinArr = (a) =>\r\n    Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n  const lines = [];\r\n  lines.push(`*${safeTitle}*`);\r\n  const pnStr = joinArr(pn);\r\n  const snStr = joinArr(sn);\r\n  if (pnStr) lines.push(`PN: ${pnStr}`);\r\n  if (snStr) lines.push(`SN: ${snStr}`);\r\n  if (plain(workOrder)) lines.push(`WO: ${plain(workOrder)}`);\r\n  if (plain(poNumber))  lines.push(`PO: ${plain(poNumber)}`);\r\n  if (plain(trackingNumber)) lines.push(`RL: ${plain(trackingNumber)}`);\r\n  if (plain(dom))       lines.push(`DOM: ${plain(dom)}`);\r\n  if (plain(localSN))   lines.push(`Local SN: ${plain(localSN)}`);\r\n  if (plain(date))      lines.push(`Date: ${plain(date)}`);\r\n  const desc = plain(description);\r\n  if (desc)             lines.push(desc);\r\n  else if (listKey === \"tasks\" && plain(bodyText)) lines.push(plain(bodyText));\r\n  if (plain(linkUrl))   lines.push(`<${plain(linkUrl)}|Open in Magmo>`);\r\n\r\n  const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\r\n  console.log(\"chat.postMessage >\", { channel, text });\r\n\r\n  const posted = await slack(\"chat.postMessage\", JSON.stringify({ channel, text }));\r\n  console.log(\"chat.postMessage < resp\", posted);\r\n\r\n  if (!posted?.ok) {\r\n    return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\r\n  }\r\n  return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\r\n}\r\n\r\n// (Optional) photo attachments via external upload — keep disabled until titles work 100%\r\n// async function maybeAttachPhotos({ token, listId, itemId, photoUrls, photosCol }) { ... }\r\n"]},"metadata":{},"sourceType":"module"}