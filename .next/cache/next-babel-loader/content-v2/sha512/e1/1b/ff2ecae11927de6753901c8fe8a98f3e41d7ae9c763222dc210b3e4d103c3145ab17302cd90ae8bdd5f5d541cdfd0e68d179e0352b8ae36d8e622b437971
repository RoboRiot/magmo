{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // inflowAPI.js\n// const BASE_URL   = 'https://cloudapi.inflowinventory.com';\n// const COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\n// // (Move this to env vars in prod)\n// const API_KEY    = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\n// const headers = {\n//   'Authorization': `Bearer ${API_KEY}`,\n//   'Content-Type':  'application/json',\n//   // Use the latest you saw in server responses; older also works, but stay current:\n//   'Accept':        'application/json;version=2025-06-24',\n// };\n// async function parseErr(res) {\n//   const t = await res.text();\n//   try { return JSON.parse(t); } catch { return t; }\n// }\n// // --- Look up existing product by name on the collection endpoint ---\n// // Use filter[name] if your tenant supports it; otherwise fall back to filter[smart].\n// async function findProductByName(name) {\n//   // Try exact name filter first\n//   let url = `${BASE_URL}/${COMPANY_ID}/products?filter[name]=${encodeURIComponent(name)}&count=1`;\n//   let res = await fetch(url, { headers });\n//   if (res.ok) {\n//     const data = await res.json();\n//     const items = Array.isArray(data?.items) ? data.items : (Array.isArray(data) ? data : []);\n//     if (items.length) return items[0];\n//   }\n//   // Fallback: smart filter (searches common fields)\n//   url = `${BASE_URL}/${COMPANY_ID}/products?filter[smart]=${encodeURIComponent(name)}&count=1`;\n//   res = await fetch(url, { headers });\n//   if (!res.ok) return null;\n//   const data2 = await res.json();\n//   const items2 = Array.isArray(data2?.items) ? data2.items : (Array.isArray(data2) ? data2 : []);\n//   return items2.length ? items2[0] : null;\n// }\n// class InflowAPI {\n//   /**\n//    * Upsert a product in inFlow via PUT to the collection.\n//    * @param {{ productId?: string, name: string, description: string, imageUrls?: string[], sku?: string }} params\n//    */\n//   static async upsertProduct({ productId, name, description, imageUrls = [], sku }) {\n//     if (!name || !name.trim()) throw new Error('Name is required');\n//     // If no productId, check if one already exists with this name to avoid the unique-name error.\n//     if (!productId) {\n//       const existing = await findProductByName(name.trim());\n//       if (existing && (existing.productId || existing.id)) {\n//         productId = existing.productId || existing.id;\n//       }\n//     }\n//     // If still no id, generate one (this matched your previously-working flow)\n//     const id = productId || crypto.randomUUID();\n//     // Build the payload exactly like your original—PUT to the collection with productId\n//     const payload = {\n//       productId: id,\n//       name,\n//       description,\n//       ...(sku ? { sku } : {}),\n//       ...(imageUrls.length > 0 && {\n//         images: imageUrls.map(u => ({\n//           imageId: crypto.randomUUID(),\n//           originalUrl: u,\n//         })),\n//       }),\n//     };\n//     const url = `${BASE_URL}/${COMPANY_ID}/products`;\n//     const res = await fetch(url, {\n//       method: 'PUT',\n//       headers,\n//       body: JSON.stringify(payload),\n//     });\n//     if (!res.ok) {\n//       const err = await parseErr(res);\n//       throw new Error(`inFlow API error (${res.status}): ${typeof err === 'string' ? err : JSON.stringify(err)}`);\n//     }\n//     return res.json();\n//   }\n// }\n// export default InflowAPI;\n// utils/inflowAPI.js (only the changed bits)\nconst BASE_URL = 'https://cloudapi.inflowinventory.com';\nconst COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\nconst API_KEY = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\nconst headers = {\n  Authorization: `Bearer ${API_KEY}`,\n  'Content-Type': 'application/json',\n  // stick to a stable version you know works in your tenant:\n  Accept: 'application/json;version=2024-10-01'\n};\n\nconst n = s => (s !== null && s !== void 0 ? s : '').toString().trim();\n\nasync function parseText(res) {\n  const t = await res.text();\n\n  try {\n    return {\n      json: JSON.parse(t),\n      raw: t\n    };\n  } catch {\n    return {\n      json: null,\n      raw: t\n    };\n  }\n} // ---- EXACT lookup helpers (no fuzzy/SMART fallback) ------------------------\n\n\nasync function findProductIdByExactName(name) {\n  const nameNorm = n(name);\n  if (!nameNorm) return null;\n  const url = `${BASE_URL}/${COMPANY_ID}/products?filter[name]=` + `${encodeURIComponent(nameNorm)}&count=1`;\n  const res = await fetch(url, {\n    headers\n  });\n  if (!res.ok) return null;\n  const data = await res.json();\n  const items = Array.isArray(data === null || data === void 0 ? void 0 : data.items) ? data.items : Array.isArray(data) ? data : [];\n  const item = items[0];\n  if (!item) return null; // guard: only accept if name is an exact (case-insensitive) match\n\n  if (n(item.name).toLowerCase() !== nameNorm.toLowerCase()) return null;\n  return item.productId || item.id || null;\n} // Prefer direct GET /products/{id}; fallback to collection filter by id\n\n\nasync function getProductById(productId) {\n  // Try item endpoint\n  let res = await fetch(`${BASE_URL}/${COMPANY_ID}/products/${encodeURIComponent(productId)}`, {\n    headers\n  });\n  if (res.ok) return res.json(); // Fallback: filter by id on collection\n\n  res = await fetch(`${BASE_URL}/${COMPANY_ID}/products?filter[productId]=${encodeURIComponent(productId)}&count=1`, {\n    headers\n  });\n  if (!res.ok) return null;\n  const data = await res.json();\n  const items = Array.isArray(data === null || data === void 0 ? void 0 : data.items) ? data.items : Array.isArray(data) ? data : [];\n  return items[0] || null;\n}\n\nfunction buildImages(imageUrls = []) {\n  return imageUrls.filter(Boolean).map(u => ({\n    imageId: crypto.randomUUID(),\n    originalUrl: u\n  }));\n}\n\nclass InflowAPI {\n  /**\n   * Strict upsert: exact-name reuse only; verify by id afterward.\n   */\n  static async upsertProduct({\n    productId,\n    name,\n    description,\n    imageUrls = [],\n    sku,\n    customFields\n  }) {\n    var _ref, _after$isActive;\n\n    const nameNorm = n(name);\n    if (!nameNorm) throw new Error('Name is required'); // Only reuse an id if the name is an exact match. No SMART search.\n\n    if (!productId) productId = await findProductIdByExactName(nameNorm);\n    const id = productId || crypto.randomUUID();\n\n    const payload = _objectSpread(_objectSpread(_objectSpread(_objectSpread({\n      productId: id,\n      name: nameNorm,\n      isActive: true\n    }, n(description) ? {\n      description: n(description)\n    } : {}), n(sku) ? {\n      sku: n(sku)\n    } : {}), imageUrls.length ? {\n      images: buildImages(imageUrls)\n    } : {}), customFields && Object.keys(customFields).length ? {\n      customFields\n    } : {});\n\n    console.log('[inFlow] PUT payload:', payload);\n    const res = await fetch(`${BASE_URL}/${COMPANY_ID}/products`, {\n      method: 'PUT',\n      headers,\n      body: JSON.stringify(payload)\n    });\n    const {\n      json,\n      raw\n    } = await parseText(res);\n    console.log('[inFlow] Raw PUT response:', res.status, raw);\n\n    if (!res.ok) {\n      throw new Error(`inFlow API error (${res.status}): ${raw}`);\n    } // prefer the id the server gave us (if any), else the one we sent\n\n\n    const resolvedId = json && (json.productId || json.id) || id; // Verify by ID only (no fuzzy). This prevents false “success”.\n\n    const after = await getProductById(resolvedId);\n    console.log('[inFlow] Verified by ID:', {\n      productId: resolvedId,\n      name: after === null || after === void 0 ? void 0 : after.name,\n      sku: after === null || after === void 0 ? void 0 : after.sku,\n      // many tenants surface one of these; log whatever exists so you can tell if it’s hidden\n      isActive: (_ref = (_after$isActive = after === null || after === void 0 ? void 0 : after.isActive) !== null && _after$isActive !== void 0 ? _after$isActive : after === null || after === void 0 ? void 0 : after.active) !== null && _ref !== void 0 ? _ref : after === null || after === void 0 ? void 0 : after.status,\n      categoryId: after === null || after === void 0 ? void 0 : after.categoryId\n    });\n\n    if (!after) {\n      throw new Error('Write appeared to succeed, but GET by id returned nothing.');\n    }\n\n    return after;\n  }\n\n}\n\nexport default InflowAPI;","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/utils/inflowAPI.js"],"names":["BASE_URL","COMPANY_ID","API_KEY","headers","Authorization","Accept","n","s","toString","trim","parseText","res","t","text","json","JSON","parse","raw","findProductIdByExactName","name","nameNorm","url","encodeURIComponent","fetch","ok","data","items","Array","isArray","item","toLowerCase","productId","id","getProductById","buildImages","imageUrls","filter","Boolean","map","u","imageId","crypto","randomUUID","originalUrl","InflowAPI","upsertProduct","description","sku","customFields","Error","payload","isActive","length","images","Object","keys","console","log","method","body","stringify","status","resolvedId","after","active","categoryId"],"mappings":"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","sourcesContent":["// // inflowAPI.js\n\n// const BASE_URL   = 'https://cloudapi.inflowinventory.com';\n// const COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\n// // (Move this to env vars in prod)\n// const API_KEY    = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\n\n// const headers = {\n//   'Authorization': `Bearer ${API_KEY}`,\n//   'Content-Type':  'application/json',\n//   // Use the latest you saw in server responses; older also works, but stay current:\n//   'Accept':        'application/json;version=2025-06-24',\n// };\n\n// async function parseErr(res) {\n//   const t = await res.text();\n//   try { return JSON.parse(t); } catch { return t; }\n// }\n\n// // --- Look up existing product by name on the collection endpoint ---\n// // Use filter[name] if your tenant supports it; otherwise fall back to filter[smart].\n// async function findProductByName(name) {\n//   // Try exact name filter first\n//   let url = `${BASE_URL}/${COMPANY_ID}/products?filter[name]=${encodeURIComponent(name)}&count=1`;\n//   let res = await fetch(url, { headers });\n//   if (res.ok) {\n//     const data = await res.json();\n//     const items = Array.isArray(data?.items) ? data.items : (Array.isArray(data) ? data : []);\n//     if (items.length) return items[0];\n//   }\n//   // Fallback: smart filter (searches common fields)\n//   url = `${BASE_URL}/${COMPANY_ID}/products?filter[smart]=${encodeURIComponent(name)}&count=1`;\n//   res = await fetch(url, { headers });\n//   if (!res.ok) return null;\n//   const data2 = await res.json();\n//   const items2 = Array.isArray(data2?.items) ? data2.items : (Array.isArray(data2) ? data2 : []);\n//   return items2.length ? items2[0] : null;\n// }\n\n// class InflowAPI {\n//   /**\n//    * Upsert a product in inFlow via PUT to the collection.\n//    * @param {{ productId?: string, name: string, description: string, imageUrls?: string[], sku?: string }} params\n//    */\n//   static async upsertProduct({ productId, name, description, imageUrls = [], sku }) {\n//     if (!name || !name.trim()) throw new Error('Name is required');\n\n//     // If no productId, check if one already exists with this name to avoid the unique-name error.\n//     if (!productId) {\n//       const existing = await findProductByName(name.trim());\n//       if (existing && (existing.productId || existing.id)) {\n//         productId = existing.productId || existing.id;\n//       }\n//     }\n\n//     // If still no id, generate one (this matched your previously-working flow)\n//     const id = productId || crypto.randomUUID();\n\n//     // Build the payload exactly like your original—PUT to the collection with productId\n//     const payload = {\n//       productId: id,\n//       name,\n//       description,\n//       ...(sku ? { sku } : {}),\n//       ...(imageUrls.length > 0 && {\n//         images: imageUrls.map(u => ({\n//           imageId: crypto.randomUUID(),\n//           originalUrl: u,\n//         })),\n//       }),\n//     };\n\n//     const url = `${BASE_URL}/${COMPANY_ID}/products`;\n//     const res = await fetch(url, {\n//       method: 'PUT',\n//       headers,\n//       body: JSON.stringify(payload),\n//     });\n\n//     if (!res.ok) {\n//       const err = await parseErr(res);\n//       throw new Error(`inFlow API error (${res.status}): ${typeof err === 'string' ? err : JSON.stringify(err)}`);\n//     }\n\n//     return res.json();\n//   }\n// }\n\n// export default InflowAPI;\n\n// utils/inflowAPI.js (only the changed bits)\n\nconst BASE_URL   = 'https://cloudapi.inflowinventory.com';\nconst COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\nconst API_KEY    = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\n\nconst headers = {\n  Authorization: `Bearer ${API_KEY}`,\n  'Content-Type': 'application/json',\n  // stick to a stable version you know works in your tenant:\n  Accept: 'application/json;version=2024-10-01',\n};\n\nconst n = s => (s ?? '').toString().trim();\n\nasync function parseText(res) {\n  const t = await res.text();\n  try { return { json: JSON.parse(t), raw: t }; }\n  catch { return { json: null, raw: t }; }\n}\n\n// ---- EXACT lookup helpers (no fuzzy/SMART fallback) ------------------------\n\nasync function findProductIdByExactName(name) {\n  const nameNorm = n(name);\n  if (!nameNorm) return null;\n\n  const url = `${BASE_URL}/${COMPANY_ID}/products?filter[name]=` +\n              `${encodeURIComponent(nameNorm)}&count=1`;\n  const res = await fetch(url, { headers });\n  if (!res.ok) return null;\n\n  const data = await res.json();\n  const items = Array.isArray(data?.items) ? data.items\n              : Array.isArray(data)          ? data\n              : [];\n  const item = items[0];\n  if (!item) return null;\n\n  // guard: only accept if name is an exact (case-insensitive) match\n  if (n(item.name).toLowerCase() !== nameNorm.toLowerCase()) return null;\n  return item.productId || item.id || null;\n}\n\n// Prefer direct GET /products/{id}; fallback to collection filter by id\nasync function getProductById(productId) {\n  // Try item endpoint\n  let res = await fetch(`${BASE_URL}/${COMPANY_ID}/products/${encodeURIComponent(productId)}`, { headers });\n  if (res.ok) return res.json();\n\n  // Fallback: filter by id on collection\n  res = await fetch(`${BASE_URL}/${COMPANY_ID}/products?filter[productId]=${encodeURIComponent(productId)}&count=1`, { headers });\n  if (!res.ok) return null;\n  const data = await res.json();\n  const items = Array.isArray(data?.items) ? data.items\n              : Array.isArray(data)          ? data\n              : [];\n  return items[0] || null;\n}\n\nfunction buildImages(imageUrls = []) {\n  return imageUrls\n    .filter(Boolean)\n    .map(u => ({ imageId: crypto.randomUUID(), originalUrl: u }));\n}\n\nclass InflowAPI {\n  /**\n   * Strict upsert: exact-name reuse only; verify by id afterward.\n   */\n  static async upsertProduct({ productId, name, description, imageUrls = [], sku, customFields }) {\n    const nameNorm = n(name);\n    if (!nameNorm) throw new Error('Name is required');\n\n    // Only reuse an id if the name is an exact match. No SMART search.\n    if (!productId) productId = await findProductIdByExactName(nameNorm);\n    const id = productId || crypto.randomUUID();\n\n    const payload = {\n      productId: id,\n      name: nameNorm,\n      isActive: true, // ← keep new items visible in the UI\n      ...(n(description) ? { description: n(description) } : {}),\n      ...(n(sku) ? { sku: n(sku) } : {}),\n      ...(imageUrls.length ? { images: buildImages(imageUrls) } : {}),\n      ...(customFields && Object.keys(customFields).length ? { customFields } : {}),\n    };\n\n    console.log('[inFlow] PUT payload:', payload);\n    const res = await fetch(`${BASE_URL}/${COMPANY_ID}/products`, {\n      method: 'PUT',\n      headers,\n      body: JSON.stringify(payload),\n    });\n\n    const { json, raw } = await parseText(res);\n    console.log('[inFlow] Raw PUT response:', res.status, raw);\n\n    if (!res.ok) {\n      throw new Error(`inFlow API error (${res.status}): ${raw}`);\n    }\n\n    // prefer the id the server gave us (if any), else the one we sent\n    const resolvedId = (json && (json.productId || json.id)) || id;\n\n    // Verify by ID only (no fuzzy). This prevents false “success”.\n    const after = await getProductById(resolvedId);\n    console.log('[inFlow] Verified by ID:', {\n      productId: resolvedId,\n      name: after?.name,\n      sku: after?.sku,\n      // many tenants surface one of these; log whatever exists so you can tell if it’s hidden\n      isActive: after?.isActive ?? after?.active ?? after?.status,\n      categoryId: after?.categoryId,\n    });\n\n    if (!after) {\n      throw new Error('Write appeared to succeed, but GET by id returned nothing.');\n    }\n\n    return after;\n  }\n}\n\nexport default InflowAPI;\n"]},"metadata":{},"sourceType":"module"}