{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   if (req.method !== \"POST\") {\n//     return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//   }\n//   const token = process.env.SLACK_BOT_TOKEN;\n//   if (!token) {\n//     return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//   }\n//   // ---- Payload from client (your UI already sends these) ----\n//   const {\n//     listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\n//     title,              // the thing we want to show in the Task column\n//     linkUrl, bodyText,\n//     date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\n//     photoUrls = [],\n//   } = req.body || {};\n//   // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\n//   const LISTS = {\n//     tasks: {\n//       id: process.env.SLACK_LIST_TASKS_ID,\n//       // OPTIONAL: if you know the \"Task\" column id already\n//       titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\n//       cols: {\n//         desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\n//       },\n//     },\n//     shipping: {\n//       id: process.env.SLACK_LIST_SHIPPING_ID,\n//       titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\n//       cols: {\n//         desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\n//         date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\n//         pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\n//         track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\n//         wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\n//         lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\n//         photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\n//       },\n//     },\n//     receiving: {\n//       id: process.env.SLACK_LIST_RECEIVING_ID,\n//       titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\n//       cols: {\n//         desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\n//         date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\n//         pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\n//         track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\n//         wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\n//         lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\n//         photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\n//       },\n//     },\n//   };\n//   const cfg = LISTS[listKey];\n//   if (!cfg?.id) {\n//     return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\n//   }\n//   // ---- Slack helpers ----\n//   async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\n//     const r = await fetch(`https://slack.com/api/${method}`, {\n//       method: \"POST\",\n//       headers: { Authorization: `Bearer ${token}`, ...headers },\n//       body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\n//     });\n//     return r.json();\n//   }\n//   const plain = (v) => (v ?? \"\").toString().trim();\n//   const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//   // Never send an empty title\n//   const safeTitle =\n//     plain(title) ||\n//     (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\n//     joinArr(pn) ||\n//     \"New Item\";\n//   // Convert plain text to Slack rich_text for text columns\n//   function toRichText(text) {\n//     return [{\n//       type: \"rich_text\",\n//       elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\n//     }];\n//   }\n//   // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\n//   async function resolveTitleColumnId(listId, provided) {\n//     if (provided) return { colId: provided, source: \"env\" };\n//     const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//     if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\n//     let candidate = null;\n//     for (const item of probe.items || []) {\n//       for (const f of item.fields || []) {\n//         const key = (f.key || \"\").trim().toLowerCase();\n//         const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\n//         if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\n//         if (!candidate && f.column_id && hasText) candidate = f.column_id;\n//       }\n//     }\n//     return { colId: candidate, source: \"auto:first_text\" };\n//   }\n//   try {\n//     // 1) Find the column to write the Task name into; fall back to top-level title\n//     const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\n//     const createBody = {\n//       list_id: cfg.id,\n//       ...(titleCol.colId\n//         ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\n//         : { title: safeTitle }), // fallback if we couldn’t resolve a column\n//     };\n//     const created = await slack(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 2) (Optional) Patch other columns you actually have IDs for\n//     const fields = [];\n//     const cols = cfg.cols || {};\n//     const addText = (colId, text) => {\n//       const t = plain(text);\n//       if (colId && t) fields.push({ column_id: colId, value: { text: t } });\n//     };\n//     // Description / Notes column (for tasks we include your assembled bodyText)\n//     if (cols.desc) {\n//       const bits = [\n//         plain(description),\n//         listKey === \"tasks\" ? plain(bodyText) : \"\",\n//         plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\n//       ].filter(Boolean).join(\"\\n\");\n//       addText(cols.desc, bits);\n//     }\n//     // Dates and grouped PN/SN/DOM example\n//     if (cols.date && plain(date)) fields.push({ column_id: cols.date, value: { date: plain(date) } });\n//     if (cols.pn) {\n//       const pnStr = joinArr(pn), snStr = joinArr(sn);\n//       const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`]\n//         .filter(Boolean).join(\"  \");\n//       addText(cols.pn, combo);\n//     }\n//     if (cols.track) {\n//       const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`]\n//         .filter(Boolean).join(\"  \");\n//       addText(cols.track, t);\n//     }\n//     if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\n//     if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\n//     if (fields.length) {\n//       await slack(\"slackLists.items.update\", { list_id: cfg.id, item_id: created.item.id, fields });\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id: cfg.id,\n//       item_id: created.item.id,\n//       used_title_col: titleCol.colId || null,\n//       title_col_source: titleCol.source || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  if (req.method !== \"POST\") return res.status(405).json({\n    ok: false,\n    error: \"method_not_allowed\"\n  });\n  const token = process.env.SLACK_BOT_TOKEN;\n  if (!token) return res.status(500).json({\n    ok: false,\n    error: \"missing_SLACK_BOT_TOKEN\"\n  });\n\n  try {\n    var _created$item;\n\n    const {\n      listKey,\n      title,\n      pn,\n      sn\n    } = req.body || {};\n\n    if (listKey !== \"shipping\") {\n      return res.status(400).json({\n        ok: false,\n        error: \"only_shipping_supported_in_this_call\"\n      });\n    } // You already have this in env for the list itself (we don't need column ids)\n\n\n    const LIST_ID = process.env.SLACK_LIST_SHIPPING_ID;\n    if (!LIST_ID) return res.status(500).json({\n      ok: false,\n      error: \"missing_SLACK_LIST_SHIPPING_ID\"\n    });\n    const headers = {\n      Authorization: `Bearer ${token}`,\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    };\n\n    const slack = (method, payload) => fetch(`https://slack.com/api/${method}`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(payload)\n    }).then(r => r.json());\n\n    const toList = v => Array.isArray(v) ? v.filter(Boolean).map(x => `${x}`.trim()) : v ? [`${v}`.trim()] : [];\n\n    const pnList = toList(pn);\n    const snList = toList(sn);\n    const safeTitle = (title || \"\").toString().trim() || \"Untitled\";\n    const pnsnText = [pnList.length ? `PN: ${pnList.join(\", \")}` : \"\", snList.length ? `SN: ${snList.join(\", \")}` : \"\"].filter(Boolean).join(\"  \"); // 1) Create the row (this fills the left-most \"item\" cell)\n\n    const created = await slack(\"slackLists.items.create\", {\n      list_id: LIST_ID,\n      title: safeTitle\n    });\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(400).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\"\n      });\n    }\n\n    const itemId = (_created$item = created.item) === null || _created$item === void 0 ? void 0 : _created$item.id; // 2) Auto-discover the PN/SN column id by scanning existing items' fields\n    //    We look for a field whose key or text clearly matches PN/SN usage.\n\n    const probe = await slack(\"slackLists.items.list\", {\n      list_id: LIST_ID,\n      limit: 50\n    });\n\n    if (!(probe !== null && probe !== void 0 && probe.ok)) {\n      return res.status(200).json({\n        ok: true,\n        note: \"created_without_pnsn (items.list_failed)\",\n        item_id: itemId\n      });\n    }\n\n    const findPnSnColId = () => {\n      // prefer fields that already look like \"PN: ...\", or a key containing \"pn\"\n      for (const it of probe.items || []) {\n        for (const f of it.fields || []) {\n          const key = (f.key || \"\").toLowerCase();\n          const textVal = (f.text || \"\").toLowerCase();\n          const looksLikePn = key.includes(\"pn\") || key.includes(\"sn\") || key.includes(\"dom\") || textVal.includes(\"pn:\") || textVal.includes(\"sn:\");\n          if (f.column_id && looksLikePn) return f.column_id;\n        }\n      }\n\n      return null;\n    };\n\n    const pnColId = findPnSnColId(); // 3) If we found the column id and we have PN/SN, update just that column\n\n    if (pnColId && pnsnText) {\n      const upd = await slack(\"slackLists.items.update\", {\n        list_id: LIST_ID,\n        item_id: itemId,\n        fields: [{\n          column_id: pnColId,\n          value: {\n            text: pnsnText\n          }\n        }]\n      });\n\n      if (!(upd !== null && upd !== void 0 && upd.ok)) {\n        // not fatal—the item was created; we just couldn't fill PN/SN\n        return res.status(200).json({\n          ok: true,\n          note: \"created_but_pnsn_update_failed\",\n          item_id: itemId,\n          error: (upd === null || upd === void 0 ? void 0 : upd.error) || \"unknown_update_error\"\n        });\n      }\n    }\n\n    return res.status(200).json({\n      ok: true,\n      list_id: LIST_ID,\n      item_id: itemId,\n      sent_title: safeTitle,\n      sent_pnsn: pnsnText\n    });\n  } catch (e) {\n    console.error(e);\n    return res.status(500).json({\n      ok: false,\n      error: \"server_error\"\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn","sn","body","LIST_ID","SLACK_LIST_SHIPPING_ID","headers","Authorization","slack","payload","fetch","JSON","stringify","then","r","toList","v","Array","isArray","filter","Boolean","map","x","trim","pnList","snList","safeTitle","toString","pnsnText","length","join","created","list_id","itemId","item","id","probe","limit","note","item_id","findPnSnColId","it","items","f","fields","key","toLowerCase","textVal","text","looksLikePn","includes","column_id","pnColId","upd","value","sent_title","sent_pnsn","e","console"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B,OAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,IAAAA,EAAE,EAAE,KAAN;AAAaC,IAAAA,KAAK,EAAE;AAApB,GAArB,CAAP;AAE3B,QAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;AACA,MAAI,CAACH,KAAL,EAAY,OAAON,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,IAAAA,EAAE,EAAE,KAAN;AAAaC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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   if (req.method !== \"POST\") {\r\n//     return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//   }\r\n\r\n//   const token = process.env.SLACK_BOT_TOKEN;\r\n//   if (!token) {\r\n//     return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//   }\r\n\r\n//   // ---- Payload from client (your UI already sends these) ----\r\n//   const {\r\n//     listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\r\n//     title,              // the thing we want to show in the Task column\r\n//     linkUrl, bodyText,\r\n//     date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n//     photoUrls = [],\r\n//   } = req.body || {};\r\n\r\n//   // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\r\n//   const LISTS = {\r\n//     tasks: {\r\n//       id: process.env.SLACK_LIST_TASKS_ID,\r\n//       // OPTIONAL: if you know the \"Task\" column id already\r\n//       titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\r\n//       cols: {\r\n//         desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\r\n//       },\r\n//     },\r\n//     shipping: {\r\n//       id: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\r\n//       cols: {\r\n//         desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\r\n//         date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\r\n//         pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\r\n//         track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\r\n//         wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\r\n//         lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\r\n//         photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\r\n//       },\r\n//     },\r\n//     receiving: {\r\n//       id: process.env.SLACK_LIST_RECEIVING_ID,\r\n//       titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\r\n//       cols: {\r\n//         desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\r\n//         date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\r\n//         pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\r\n//         track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\r\n//         wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\r\n//         lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\r\n//         photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\r\n//       },\r\n//     },\r\n//   };\r\n\r\n//   const cfg = LISTS[listKey];\r\n//   if (!cfg?.id) {\r\n//     return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\r\n//   }\r\n\r\n//   // ---- Slack helpers ----\r\n//   async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\r\n//     const r = await fetch(`https://slack.com/api/${method}`, {\r\n//       method: \"POST\",\r\n//       headers: { Authorization: `Bearer ${token}`, ...headers },\r\n//       body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\r\n//     });\r\n//     return r.json();\r\n//   }\r\n\r\n//   const plain = (v) => (v ?? \"\").toString().trim();\r\n//   const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//   // Never send an empty title\r\n//   const safeTitle =\r\n//     plain(title) ||\r\n//     (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\r\n//     joinArr(pn) ||\r\n//     \"New Item\";\r\n\r\n//   // Convert plain text to Slack rich_text for text columns\r\n//   function toRichText(text) {\r\n//     return [{\r\n//       type: \"rich_text\",\r\n//       elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\r\n//     }];\r\n//   }\r\n\r\n//   // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\r\n//   async function resolveTitleColumnId(listId, provided) {\r\n//     if (provided) return { colId: provided, source: \"env\" };\r\n\r\n//     const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//     if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\r\n\r\n//     let candidate = null;\r\n//     for (const item of probe.items || []) {\r\n//       for (const f of item.fields || []) {\r\n//         const key = (f.key || \"\").trim().toLowerCase();\r\n//         const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\r\n//         if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\r\n//         if (!candidate && f.column_id && hasText) candidate = f.column_id;\r\n//       }\r\n//     }\r\n//     return { colId: candidate, source: \"auto:first_text\" };\r\n//   }\r\n\r\n//   try {\r\n//     // 1) Find the column to write the Task name into; fall back to top-level title\r\n//     const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\r\n\r\n//     const createBody = {\r\n//       list_id: cfg.id,\r\n//       ...(titleCol.colId\r\n//         ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\r\n//         : { title: safeTitle }), // fallback if we couldn’t resolve a column\r\n//     };\r\n\r\n//     const created = await slack(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 2) (Optional) Patch other columns you actually have IDs for\r\n//     const fields = [];\r\n//     const cols = cfg.cols || {};\r\n//     const addText = (colId, text) => {\r\n//       const t = plain(text);\r\n//       if (colId && t) fields.push({ column_id: colId, value: { text: t } });\r\n//     };\r\n\r\n//     // Description / Notes column (for tasks we include your assembled bodyText)\r\n//     if (cols.desc) {\r\n//       const bits = [\r\n//         plain(description),\r\n//         listKey === \"tasks\" ? plain(bodyText) : \"\",\r\n//         plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\r\n//       ].filter(Boolean).join(\"\\n\");\r\n//       addText(cols.desc, bits);\r\n//     }\r\n\r\n//     // Dates and grouped PN/SN/DOM example\r\n//     if (cols.date && plain(date)) fields.push({ column_id: cols.date, value: { date: plain(date) } });\r\n//     if (cols.pn) {\r\n//       const pnStr = joinArr(pn), snStr = joinArr(sn);\r\n//       const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`]\r\n//         .filter(Boolean).join(\"  \");\r\n//       addText(cols.pn, combo);\r\n//     }\r\n//     if (cols.track) {\r\n//       const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`]\r\n//         .filter(Boolean).join(\"  \");\r\n//       addText(cols.track, t);\r\n//     }\r\n//     if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\r\n//     if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\r\n\r\n//     if (fields.length) {\r\n//       await slack(\"slackLists.items.update\", { list_id: cfg.id, item_id: created.item.id, fields });\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id: cfg.id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleCol.colId || null,\r\n//       title_col_source: titleCol.source || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  if (req.method !== \"POST\") return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n\r\n  const token = process.env.SLACK_BOT_TOKEN;\r\n  if (!token) return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n\r\n  try {\r\n    const { listKey, title, pn, sn } = req.body || {};\r\n    if (listKey !== \"shipping\") {\r\n      return res.status(400).json({ ok: false, error: \"only_shipping_supported_in_this_call\" });\r\n    }\r\n\r\n    // You already have this in env for the list itself (we don't need column ids)\r\n    const LIST_ID = process.env.SLACK_LIST_SHIPPING_ID;\r\n    if (!LIST_ID) return res.status(500).json({ ok: false, error: \"missing_SLACK_LIST_SHIPPING_ID\" });\r\n\r\n    const headers = {\r\n      Authorization: `Bearer ${token}`,\r\n      \"Content-Type\": \"application/json; charset=utf-8\",\r\n    };\r\n    const slack = (method, payload) =>\r\n      fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body: JSON.stringify(payload) })\r\n        .then(r => r.json());\r\n\r\n    const toList = (v) => Array.isArray(v) ? v.filter(Boolean).map(x => `${x}`.trim()) : (v ? [`${v}`.trim()] : []);\r\n    const pnList = toList(pn);\r\n    const snList = toList(sn);\r\n\r\n    const safeTitle = (title || \"\").toString().trim() || \"Untitled\";\r\n    const pnsnText = [\r\n      pnList.length ? `PN: ${pnList.join(\", \")}` : \"\",\r\n      snList.length ? `SN: ${snList.join(\", \")}` : \"\",\r\n    ].filter(Boolean).join(\"  \");\r\n\r\n    // 1) Create the row (this fills the left-most \"item\" cell)\r\n    const created = await slack(\"slackLists.items.create\", {\r\n      list_id: LIST_ID,\r\n      title: safeTitle,\r\n    });\r\n    if (!created?.ok) {\r\n      return res.status(400).json({ ok: false, error: created?.error || \"create_failed\" });\r\n    }\r\n    const itemId = created.item?.id;\r\n\r\n    // 2) Auto-discover the PN/SN column id by scanning existing items' fields\r\n    //    We look for a field whose key or text clearly matches PN/SN usage.\r\n    const probe = await slack(\"slackLists.items.list\", { list_id: LIST_ID, limit: 50 });\r\n    if (!probe?.ok) {\r\n      return res.status(200).json({\r\n        ok: true,\r\n        note: \"created_without_pnsn (items.list_failed)\",\r\n        item_id: itemId,\r\n      });\r\n    }\r\n\r\n    const findPnSnColId = () => {\r\n      // prefer fields that already look like \"PN: ...\", or a key containing \"pn\"\r\n      for (const it of probe.items || []) {\r\n        for (const f of it.fields || []) {\r\n          const key = (f.key || \"\").toLowerCase();\r\n          const textVal = (f.text || \"\").toLowerCase();\r\n          const looksLikePn = key.includes(\"pn\") || key.includes(\"sn\") || key.includes(\"dom\")\r\n                           || textVal.includes(\"pn:\") || textVal.includes(\"sn:\");\r\n          if (f.column_id && looksLikePn) return f.column_id;\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n\r\n    const pnColId = findPnSnColId();\r\n\r\n    // 3) If we found the column id and we have PN/SN, update just that column\r\n    if (pnColId && pnsnText) {\r\n      const upd = await slack(\"slackLists.items.update\", {\r\n        list_id: LIST_ID,\r\n        item_id: itemId,\r\n        fields: [{ column_id: pnColId, value: { text: pnsnText } }],\r\n      });\r\n      if (!upd?.ok) {\r\n        // not fatal—the item was created; we just couldn't fill PN/SN\r\n        return res.status(200).json({\r\n          ok: true,\r\n          note: \"created_but_pnsn_update_failed\",\r\n          item_id: itemId,\r\n          error: upd?.error || \"unknown_update_error\",\r\n        });\r\n      }\r\n    }\r\n\r\n    return res.status(200).json({ ok: true, list_id: LIST_ID, item_id: itemId, sent_title: safeTitle, sent_pnsn: pnsnText });\r\n  } catch (e) {\r\n    console.error(e);\r\n    return res.status(500).json({ ok: false, error: \"server_error\" });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}