{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  try {\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n    if (!token) return res.status(500).json({\n      ok: false,\n      error: \"missing_SLACK_BOT_TOKEN\"\n    }); // ---- Payload from client ----\n\n    const {\n      listKey,\n      // \"shipping\" | \"receiving\" | \"tasks\"\n      title,\n      pn,\n      sn,\n      linkUrl,\n      shippingDate,\n      // arrival_date || date\n      tracking,\n      workOrder,\n      localSN,\n      description,\n      photoUrls = [],\n      parties // untouched\n\n    } = req.body || {};\n    const LIST_IDS = {\n      tasks: process.env.SLACK_LIST_TASKS_ID,\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\n      receiving: process.env.SLACK_LIST_RECEIVING_ID\n    };\n    const list_id = LIST_IDS[listKey];\n    if (!list_id) return res.status(400).json({\n      ok: false,\n      error: `unknown_listKey_${listKey}`\n    }); // ---- Helpers ----\n\n    async function slackJson(method, payload) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(payload)\n      });\n      return r.json();\n    }\n\n    const isObj = v => v && typeof v === \"object\";\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const toRichText = text => ({\n      type: \"rich_text\",\n      elements: [{\n        type: \"rich_text_section\",\n        elements: [{\n          type: \"text\",\n          text: plain(text)\n        }]\n      }]\n    });\n\n    const extractRTText = rt => {\n      try {\n        var _rt$elements$0$elemen, _rt$elements, _rt$elements$, _rt$elements$$element, _rt$elements$$element2;\n\n        return (_rt$elements$0$elemen = rt === null || rt === void 0 ? void 0 : (_rt$elements = rt.elements) === null || _rt$elements === void 0 ? void 0 : (_rt$elements$ = _rt$elements[0]) === null || _rt$elements$ === void 0 ? void 0 : (_rt$elements$$element = _rt$elements$.elements) === null || _rt$elements$$element === void 0 ? void 0 : (_rt$elements$$element2 = _rt$elements$$element[0]) === null || _rt$elements$$element2 === void 0 ? void 0 : _rt$elements$$element2.text) !== null && _rt$elements$0$elemen !== void 0 ? _rt$elements$0$elemen : \"\";\n      } catch {\n        return \"\";\n      }\n    };\n\n    function normalizeValue(v, hint) {\n      // Firestore Timestamp-like\n      if (isObj(v) && typeof v.seconds === \"number\") {\n        const iso = new Date(v.seconds * 1000).toISOString();\n        return hint === \"date\" ? iso.slice(0, 10) : iso;\n      } // Firestore DocumentReference-like\n\n\n      if (isObj(v) && v._delegate && v._delegate.path) return `ref:${v._delegate.path}`;\n      if (Array.isArray(v)) return v.map(x => normalizeValue(x)).join(\", \");\n\n      if (isObj(v)) {\n        try {\n          const s = JSON.stringify(v);\n          return s.length > 500 ? s.slice(0, 500) + \"â€¦\" : s;\n        } catch {\n          return \"[object]\";\n        }\n      }\n\n      const s = (v !== null && v !== void 0 ? v : \"\").toString().trim();\n      if (hint === \"url\" && s && !/^https?:\\/\\//i.test(s)) return \"\"; // only keep http(s)\n\n      if (hint === \"date\" && s) {\n        // normalize to YYYY-MM-DD if we can\n        const d = new Date(s);\n        if (!isNaN(+d)) return d.toISOString().slice(0, 10);\n      }\n\n      return s;\n    } // ---- Column auto-discovery by sampling existing rows ----\n\n\n    async function listProbe(listId) {\n      const probe = await slackJson(\"slackLists.items.list\", {\n        list_id: listId,\n        limit: 200\n      });\n      return probe !== null && probe !== void 0 && probe.ok ? probe : null;\n    }\n\n    async function resolveTitleColId(listId) {\n      const probe = await listProbe(listId);\n      if (!probe) return null;\n      let fallback = null;\n\n      for (const it of probe.items || []) {\n        for (const f of it.fields || []) {\n          const key = (f.key || \"\").toLowerCase();\n          const hasText = !!f.text || !!f.rich_text; // text-like column\n\n          if (f.column_id && hasText) {\n            if (key.includes(\"item\") || key.includes(\"task\") || key.includes(\"name\")) return f.column_id;\n            if (!fallback) fallback = f.column_id;\n          }\n        }\n      }\n\n      return fallback;\n    }\n\n    async function resolveByKeywords(listId, keywords = [], loose = []) {\n      const probe = await listProbe(listId);\n      if (!probe) return null;\n      let candidate = null;\n      const kw = (keywords || []).map(k => k.toLowerCase());\n      const looseKw = (loose || []).map(k => k.toLowerCase());\n\n      for (const it of probe.items || []) {\n        for (const f of it.fields || []) {\n          if (!f.column_id) continue;\n          const key = (f.key || \"\").toLowerCase();\n          const text = (f.text || extractRTText(f.rich_text) || \"\").toLowerCase();\n          const hit = kw.some(k => key.includes(k) || text.includes(k));\n          if (hit) return f.column_id;\n\n          if (!candidate) {\n            const maybe = looseKw.some(k => key.includes(k) || text.includes(k));\n            if (maybe) candidate = f.column_id;\n          }\n        }\n      }\n\n      return candidate;\n    } // ---- 1) Create row with title (your working behavior) ----\n\n\n    const titleColId = await resolveTitleColId(list_id);\n    if (!titleColId) return res.status(400).json({\n      ok: false,\n      error: \"could_not_resolve_title_column\"\n    });\n    const safeTitle = normalizeValue(title);\n    const created = await slackJson(\"slackLists.items.create\", {\n      list_id,\n      initial_fields: [{\n        column_id: titleColId,\n        rich_text: toRichText(safeTitle)\n      }]\n    });\n    if (!(created !== null && created !== void 0 && created.ok)) return res.status(200).json({\n      ok: false,\n      error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\"\n    }); // ---- 2) Resolve target columns ----\n\n    const pnSnColId = await resolveByKeywords(list_id, [\"pn\", \"sn\", \"part number\", \"serial\"], [\"pn:\", \"sn:\"]);\n    const shipDateColId = await resolveByKeywords(list_id, [\"shipping date\", \"ship date\"], [\"date\"]);\n    const trackingColId = await resolveByKeywords(list_id, [\"tracking\", \"wdim\"], [\"tracking number\", \"tn\", \"wdim\"]);\n    const woColId = await resolveByKeywords(list_id, [\"wo/so\", \"work order\", \"sales order\"], [\"wo\", \"so\"]);\n    const localSnColId = await resolveByKeywords(list_id, [\"local sn\", \"localsn\", \"ais\"], [\"local\", \"sn\"]);\n    const descriptionColId = await resolveByKeywords(list_id, [\"description\", \"notes\"], [\"desc\", \"note\"]);\n    const linkColId = await resolveByKeywords(list_id, [\"link\", \"url\", \"page\"], []);\n    const photosColId = await resolveByKeywords(list_id, [\"shipping photos\", \"photos\", \"images\", \"pics\"], [\"photo\", \"image\", \"pic\"]); // ---- 3) Build candidates (normalized) ----\n\n    const pn0 = Array.isArray(pn) ? pn[0] : pn;\n    const sn0 = Array.isArray(sn) ? sn[0] : sn;\n    const pnTxt = normalizeValue(pn0);\n    const snTxt = normalizeValue(sn0);\n    const pnSnText = [pnTxt && `PN: ${pnTxt}`, snTxt && `SN: ${snTxt}`].filter(Boolean).join(\"  \");\n    const candidates = [];\n    if (pnSnText && pnSnColId) candidates.push({\n      label: \"PN/SN\",\n      colId: pnSnColId,\n      value: pnSnText,\n      hint: \"text\"\n    });\n\n    if (shipDateColId) {\n      const v = normalizeValue(shippingDate, \"date\");\n      if (v) candidates.push({\n        label: \"Shipping Date\",\n        colId: shipDateColId,\n        value: v,\n        hint: \"date\"\n      });\n    }\n\n    if (trackingColId) {\n      const v = normalizeValue(tracking);\n      if (v) candidates.push({\n        label: \"Tracking\",\n        colId: trackingColId,\n        value: v,\n        hint: \"text\"\n      });\n    }\n\n    if (woColId) {\n      const v = normalizeValue(workOrder);\n      if (v) candidates.push({\n        label: \"WO/SO\",\n        colId: woColId,\n        value: v,\n        hint: \"text\"\n      });\n    }\n\n    if (localSnColId) {\n      const v = normalizeValue(localSN);\n      if (v) candidates.push({\n        label: \"Local SN\",\n        colId: localSnColId,\n        value: v,\n        hint: \"text\"\n      });\n    }\n\n    if (descriptionColId) {\n      const v = normalizeValue(description);\n      if (v) candidates.push({\n        label: \"Description\",\n        colId: descriptionColId,\n        value: v,\n        hint: \"text\"\n      });\n    }\n\n    if (linkColId) {\n      const v = normalizeValue(linkUrl, \"url\");\n      if (v) candidates.push({\n        label: \"Link\",\n        colId: linkColId,\n        value: v,\n        hint: \"url\"\n      });\n    }\n\n    if (photosColId && photoUrls !== null && photoUrls !== void 0 && photoUrls.length) {\n      const v = normalizeValue(photoUrls);\n      if (v) candidates.push({\n        label: \"Photos\",\n        colId: photosColId,\n        value: v,\n        hint: \"text\"\n      });\n    } // ---- 4) Write cells one-by-one; skip anything Slack rejects ----\n\n\n    const failures = [];\n    let written = 0;\n\n    async function tryCell(colId, value) {\n      var _r, _r2;\n\n      // rich_text try\n      let r = await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id: created.item.id,\n          column_id: colId,\n          rich_text: toRichText(value)\n        }]\n      });\n      if ((_r = r) !== null && _r !== void 0 && _r.ok) return true; // text fallback\n\n      r = await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id: created.item.id,\n          column_id: colId,\n          text: value\n        }]\n      });\n      return !!((_r2 = r) !== null && _r2 !== void 0 && _r2.ok);\n    }\n\n    for (const c of candidates) {\n      const ok = await tryCell(c.colId, c.value);\n\n      if (ok) {\n        written++;\n        continue;\n      }\n\n      failures.push({\n        label: c.label,\n        column_id: c.colId,\n        value: c.value\n      });\n    } // Make sure PN/SN shows somewhere even if its column rejected\n\n\n    if (pnSnText && pnSnColId && failures.some(f => f.column_id === pnSnColId)) {\n      await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id: created.item.id,\n          column_id: titleColId,\n          text: `${safeTitle} â€” ${pnSnText}`\n        }]\n      });\n    } // If at least one field was written, succeed (but report what we skipped)\n\n\n    if (written > 0 || candidates.length === 0) {\n      return res.status(200).json({\n        ok: true,\n        list_id,\n        item_id: created.item.id,\n        wrote_cells: written,\n        skipped: failures // visibility on which columns refused values\n\n      });\n    } // Nothing could be written\n\n\n    return res.status(200).json({\n      ok: false,\n      error: \"invalid_arguments\",\n      list_id,\n      item_id: created.item.id,\n      failures\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn","sn","linkUrl","shippingDate","tracking","workOrder","localSN","description","photoUrls","parties","body","LIST_IDS","tasks","SLACK_LIST_TASKS_ID","shipping","SLACK_LIST_SHIPPING_ID","receiving","SLACK_LIST_RECEIVING_ID","list_id","slackJson","payload","r","fetch","headers","Authorization","JSON","stringify","isObj","v","plain","toString","trim","toRichText","text","type","elements","extractRTText","rt","normalizeValue","hint","seconds","iso","Date","toISOString","slice","_delegate","path","Array","isArray","map","x","join","s","length","test","d","isNaN","listProbe","listId","probe","limit","resolveTitleColId","fallback","it","items","f","fields","key","toLowerCase","hasText","rich_text","column_id","includes","resolveByKeywords","keywords","loose","candidate","kw","k","looseKw","hit","some","maybe","titleColId","safeTitle","created","initial_fields","pnSnColId","shipDateColId","trackingColId","woColId","localSnColId","descriptionColId","linkColId","photosColId","pn0","sn0","pnTxt","snTxt","pnSnText","filter","Boolean","candidates","push","label","colId","value","failures","written","tryCell","cells","row_id","item","id","c","item_id","wrote_cells","skipped","err","console","message","String"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAI;AACF,QAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,aAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAArB,CAAP;AACD;;AAED,UAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;AACA,QAAI,CAACH,KAAL,EAAY,OAAON,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE;AA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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   try {\r\n//     if (req.method !== \"POST\") {\r\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//     }\r\n\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) {\r\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//     }\r\n\r\n//     // payload from client\r\n//     const {\r\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n//       title,               // item title (what shows in the primary column)\r\n//       // keeping minimal per your request: PN/SN only for now\r\n//       pn, sn,\r\n//     } = req.body || {};\r\n\r\n//     // list ids from env\r\n//     const LIST_IDS = {\r\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\r\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n//     };\r\n\r\n//     const list_id = LIST_IDS[listKey];\r\n//     if (!list_id) {\r\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n//     }\r\n\r\n//     // ---- Slack helpers ----\r\n//     async function slackJson(method, payload) {\r\n//       const r = await fetch(`https://slack.com/api/${method}`, {\r\n//         method: \"POST\",\r\n//         headers: {\r\n//           Authorization: `Bearer ${token}`,\r\n//           \"Content-Type\": \"application/json; charset=utf-8\",\r\n//         },\r\n//         body: JSON.stringify(payload),\r\n//       });\r\n//       return r.json();\r\n//     }\r\n\r\n//     const plain = (v) => (v ?? \"\").toString().trim();\r\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     function toRichText(text) {\r\n//       const t = plain(text);\r\n//       return [{\r\n//         type: \"rich_text\",\r\n//         elements: [{\r\n//           type: \"rich_text_section\",\r\n//           elements: [{ type: \"text\", text: t }],\r\n//         }],\r\n//       }];\r\n//     }\r\n\r\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n//     async function resolveTitleColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n//       let fallback = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\r\n//           if (f.column_id && hasText) {\r\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n//             if (!fallback) fallback = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return fallback; // first text-like field if we didn't find a perfect match\r\n//     }\r\n\r\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n//     async function resolvePnSnColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       let candidate = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           if (!f.column_id) continue;\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const text = (f.text || \"\").toLowerCase();\r\n\r\n//           const looksPnSn =\r\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\r\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n//           if (looksPnSn) return f.column_id;\r\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n//             candidate = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return candidate;\r\n//     }\r\n\r\n//     // 1) Resolve columns\r\n//     const titleColId = await resolveTitleColId(list_id);\r\n//     if (!titleColId) {\r\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n//     }\r\n\r\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n//     const safeTitle = plain(title) || \"New Item\";\r\n//     const createBody = {\r\n//       list_id,\r\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n//     };\r\n\r\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 3) (Minimal) update: PN/SN only, per your request\r\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n//     let updated = null;\r\n//     let usedPnSnCol = null;\r\n\r\n//     if (pnSnText) {\r\n//       const pnSnColId = await resolvePnSnColId(list_id);\r\n//       if (pnSnColId) {\r\n//         const cells = [{\r\n//           row_id: created.item.id,\r\n//           column_id: pnSnColId,\r\n//           rich_text: toRichText(pnSnText),\r\n//         }];\r\n\r\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n//         usedPnSnCol = pnSnColId;\r\n//         // If update fails, we still return ok:false so you can see the error\r\n//         if (!updated?.ok) {\r\n//           return res.status(200).json({\r\n//             ok: false,\r\n//             error: updated?.error || \"update_failed\",\r\n//             mode: \"list\",\r\n//             list_id,\r\n//             item_id: created.item.id,\r\n//             used_title_col: titleColId,\r\n//             used_pnsn_col: usedPnSnCol,\r\n//           });\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleColId,\r\n//       used_pnsn_col: usedPnSnCol || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n\r\n    // ---- Payload from client ----\r\n    const {\r\n      listKey,  // \"shipping\" | \"receiving\" | \"tasks\"\r\n      title,\r\n      pn, sn,\r\n      linkUrl,\r\n      shippingDate,   // arrival_date || date\r\n      tracking,\r\n      workOrder,\r\n      localSN,\r\n      description,\r\n      photoUrls = [],\r\n      parties,        // untouched\r\n    } = req.body || {};\r\n\r\n    const LIST_IDS = {\r\n      tasks: process.env.SLACK_LIST_TASKS_ID,\r\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n      receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n    };\r\n    const list_id = LIST_IDS[listKey];\r\n    if (!list_id) return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n\r\n    // ---- Helpers ----\r\n    async function slackJson(method, payload) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          Authorization: `Bearer ${token}`,\r\n          \"Content-Type\": \"application/json; charset=utf-8\",\r\n        },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      return r.json();\r\n    }\r\n\r\n    const isObj = (v) => v && typeof v === \"object\";\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n\r\n    const toRichText = (text) => ({\r\n      type: \"rich_text\",\r\n      elements: [\r\n        { type: \"rich_text_section\", elements: [{ type: \"text\", text: plain(text) }] },\r\n      ],\r\n    });\r\n\r\n    const extractRTText = (rt) => {\r\n      try { return rt?.elements?.[0]?.elements?.[0]?.text ?? \"\"; } catch { return \"\"; }\r\n    };\r\n\r\n    function normalizeValue(v, hint) {\r\n      // Firestore Timestamp-like\r\n      if (isObj(v) && typeof v.seconds === \"number\") {\r\n        const iso = new Date(v.seconds * 1000).toISOString();\r\n        return hint === \"date\" ? iso.slice(0, 10) : iso;\r\n      }\r\n      // Firestore DocumentReference-like\r\n      if (isObj(v) && v._delegate && v._delegate.path) return `ref:${v._delegate.path}`;\r\n      if (Array.isArray(v)) return v.map((x) => normalizeValue(x)).join(\", \");\r\n      if (isObj(v)) {\r\n        try {\r\n          const s = JSON.stringify(v);\r\n          return s.length > 500 ? s.slice(0, 500) + \"â€¦\" : s;\r\n        } catch { return \"[object]\"; }\r\n      }\r\n      const s = (v ?? \"\").toString().trim();\r\n      if (hint === \"url\" && s && !/^https?:\\/\\//i.test(s)) return \"\"; // only keep http(s)\r\n      if (hint === \"date\" && s) {\r\n        // normalize to YYYY-MM-DD if we can\r\n        const d = new Date(s);\r\n        if (!isNaN(+d)) return d.toISOString().slice(0, 10);\r\n      }\r\n      return s;\r\n    }\r\n\r\n    // ---- Column auto-discovery by sampling existing rows ----\r\n    async function listProbe(listId) {\r\n      const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 200 });\r\n      return probe?.ok ? probe : null;\r\n    }\r\n\r\n    async function resolveTitleColId(listId) {\r\n      const probe = await listProbe(listId);\r\n      if (!probe) return null;\r\n      let fallback = null;\r\n      for (const it of probe.items || []) {\r\n        for (const f of it.fields || []) {\r\n          const key = (f.key || \"\").toLowerCase();\r\n          const hasText = !!f.text || !!f.rich_text; // text-like column\r\n          if (f.column_id && hasText) {\r\n            if (key.includes(\"item\") || key.includes(\"task\") || key.includes(\"name\")) return f.column_id;\r\n            if (!fallback) fallback = f.column_id;\r\n          }\r\n        }\r\n      }\r\n      return fallback;\r\n    }\r\n\r\n    async function resolveByKeywords(listId, keywords = [], loose = []) {\r\n      const probe = await listProbe(listId);\r\n      if (!probe) return null;\r\n      let candidate = null;\r\n      const kw = (keywords || []).map((k) => k.toLowerCase());\r\n      const looseKw = (loose || []).map((k) => k.toLowerCase());\r\n\r\n      for (const it of probe.items || []) {\r\n        for (const f of it.fields || []) {\r\n          if (!f.column_id) continue;\r\n          const key = (f.key || \"\").toLowerCase();\r\n          const text = (f.text || extractRTText(f.rich_text) || \"\").toLowerCase();\r\n\r\n          const hit = kw.some((k) => key.includes(k) || text.includes(k));\r\n          if (hit) return f.column_id;\r\n\r\n          if (!candidate) {\r\n            const maybe = looseKw.some((k) => key.includes(k) || text.includes(k));\r\n            if (maybe) candidate = f.column_id;\r\n          }\r\n        }\r\n      }\r\n      return candidate;\r\n    }\r\n\r\n    // ---- 1) Create row with title (your working behavior) ----\r\n    const titleColId = await resolveTitleColId(list_id);\r\n    if (!titleColId) return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n\r\n    const safeTitle = normalizeValue(title);\r\n    const created = await slackJson(\"slackLists.items.create\", {\r\n      list_id,\r\n      initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n    });\r\n    if (!created?.ok) return res.status(200).json({ ok: false, error: created?.error || \"create_failed\" });\r\n\r\n    // ---- 2) Resolve target columns ----\r\n    const pnSnColId       = await resolveByKeywords(list_id, [\"pn\", \"sn\", \"part number\", \"serial\"], [\"pn:\", \"sn:\"]);\r\n    const shipDateColId   = await resolveByKeywords(list_id, [\"shipping date\", \"ship date\"], [\"date\"]);\r\n    const trackingColId   = await resolveByKeywords(list_id, [\"tracking\", \"wdim\"], [\"tracking number\", \"tn\", \"wdim\"]);\r\n    const woColId         = await resolveByKeywords(list_id, [\"wo/so\", \"work order\", \"sales order\"], [\"wo\", \"so\"]);\r\n    const localSnColId    = await resolveByKeywords(list_id, [\"local sn\", \"localsn\", \"ais\"], [\"local\", \"sn\"]);\r\n    const descriptionColId= await resolveByKeywords(list_id, [\"description\", \"notes\"], [\"desc\", \"note\"]);\r\n    const linkColId       = await resolveByKeywords(list_id, [\"link\", \"url\", \"page\"], []);\r\n    const photosColId     = await resolveByKeywords(list_id, [\"shipping photos\", \"photos\", \"images\", \"pics\"], [\"photo\", \"image\", \"pic\"]);\r\n\r\n    // ---- 3) Build candidates (normalized) ----\r\n    const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n    const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n    const pnTxt = normalizeValue(pn0);\r\n    const snTxt = normalizeValue(sn0);\r\n    const pnSnText = [pnTxt && `PN: ${pnTxt}`, snTxt && `SN: ${snTxt}`].filter(Boolean).join(\"  \");\r\n\r\n    const candidates = [];\r\n    if (pnSnText && pnSnColId) candidates.push({ label: \"PN/SN\", colId: pnSnColId, value: pnSnText, hint: \"text\" });\r\n    if (shipDateColId) {\r\n      const v = normalizeValue(shippingDate, \"date\");\r\n      if (v) candidates.push({ label: \"Shipping Date\", colId: shipDateColId, value: v, hint: \"date\" });\r\n    }\r\n    if (trackingColId) {\r\n      const v = normalizeValue(tracking);\r\n      if (v) candidates.push({ label: \"Tracking\", colId: trackingColId, value: v, hint: \"text\" });\r\n    }\r\n    if (woColId) {\r\n      const v = normalizeValue(workOrder);\r\n      if (v) candidates.push({ label: \"WO/SO\", colId: woColId, value: v, hint: \"text\" });\r\n    }\r\n    if (localSnColId) {\r\n      const v = normalizeValue(localSN);\r\n      if (v) candidates.push({ label: \"Local SN\", colId: localSnColId, value: v, hint: \"text\" });\r\n    }\r\n    if (descriptionColId) {\r\n      const v = normalizeValue(description);\r\n      if (v) candidates.push({ label: \"Description\", colId: descriptionColId, value: v, hint: \"text\" });\r\n    }\r\n    if (linkColId) {\r\n      const v = normalizeValue(linkUrl, \"url\");\r\n      if (v) candidates.push({ label: \"Link\", colId: linkColId, value: v, hint: \"url\" });\r\n    }\r\n    if (photosColId && photoUrls?.length) {\r\n      const v = normalizeValue(photoUrls);\r\n      if (v) candidates.push({ label: \"Photos\", colId: photosColId, value: v, hint: \"text\" });\r\n    }\r\n\r\n    // ---- 4) Write cells one-by-one; skip anything Slack rejects ----\r\n    const failures = [];\r\n    let written = 0;\r\n\r\n    async function tryCell(colId, value) {\r\n      // rich_text try\r\n      let r = await slackJson(\"slackLists.items.update\", {\r\n        list_id,\r\n        cells: [{ row_id: created.item.id, column_id: colId, rich_text: toRichText(value) }],\r\n      });\r\n      if (r?.ok) return true;\r\n\r\n      // text fallback\r\n      r = await slackJson(\"slackLists.items.update\", {\r\n        list_id,\r\n        cells: [{ row_id: created.item.id, column_id: colId, text: value }],\r\n      });\r\n      return !!r?.ok;\r\n    }\r\n\r\n    for (const c of candidates) {\r\n      const ok = await tryCell(c.colId, c.value);\r\n      if (ok) { written++; continue; }\r\n      failures.push({ label: c.label, column_id: c.colId, value: c.value });\r\n    }\r\n\r\n    // Make sure PN/SN shows somewhere even if its column rejected\r\n    if (pnSnText && pnSnColId && failures.some(f => f.column_id === pnSnColId)) {\r\n      await slackJson(\"slackLists.items.update\", {\r\n        list_id,\r\n        cells: [{ row_id: created.item.id, column_id: titleColId, text: `${safeTitle} â€” ${pnSnText}` }],\r\n      });\r\n    }\r\n\r\n    // If at least one field was written, succeed (but report what we skipped)\r\n    if (written > 0 || candidates.length === 0) {\r\n      return res.status(200).json({\r\n        ok: true,\r\n        list_id,\r\n        item_id: created.item.id,\r\n        wrote_cells: written,\r\n        skipped: failures, // visibility on which columns refused values\r\n      });\r\n    }\r\n\r\n    // Nothing could be written\r\n    return res.status(200).json({\r\n      ok: false,\r\n      error: \"invalid_arguments\",\r\n      list_id,\r\n      item_id: created.item.id,\r\n      failures,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}