{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport firebase from \"../context/Firebase\";\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(partsSnapshot.docs.map(async partDoc => {\n    var _ref, _getRefId, _ref2, _getRefId2;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    const getRefId = ref => {\n      if (!ref) return null;\n      if (typeof ref === \"string\") return ref;\n      if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n      if (ref.id) return ref.id;\n      return null;\n    };\n\n    partData.clientFromId = (_ref = (_getRefId = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientFrom)) !== null && _getRefId !== void 0 ? _getRefId : partData === null || partData === void 0 ? void 0 : partData.clientFromId) !== null && _ref !== void 0 ? _ref : null;\n    partData.clientCurrentId = (_ref2 = (_getRefId2 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientCurrent)) !== null && _getRefId2 !== void 0 ? _getRefId2 : partData === null || partData === void 0 ? void 0 : partData.clientCurrentId) !== null && _ref2 !== void 0 ? _ref2 : null; // console.log(partData);\n\n    const fetchMachineData = async ref => {\n      if (!ref) return null;\n\n      if (typeof ref.get === \"function\") {\n        const doc = await ref.get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (typeof ref === \"string\") {\n        const doc = await db.collection(\"Machine\").doc(ref).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      if (ref !== null && ref !== void 0 && ref.id) {\n        const doc = await db.collection(\"Machine\").doc(ref.id).get();\n        return doc.exists ? doc.data() : null;\n      }\n\n      return null;\n    };\n\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef = partData.CurrentMachine || partData.MachineCurrent;\n    const machineData = await fetchMachineData(machineRef);\n    partData.machineData = machineData || {};\n\n    if (machineData !== null && machineData !== void 0 && machineData.client) {\n      const clientRef = machineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (clientId && !partData.clientFromId) {\n        partData.clientFromId = clientId;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    const currentMachineData = await fetchMachineData(currentMachineRef);\n    partData.currentMachineData = currentMachineData || {};\n\n    if (currentMachineData !== null && currentMachineData !== void 0 && currentMachineData.client) {\n      const clientRef = currentMachineData.client;\n      const clientId = getRefId(clientRef);\n\n      if (clientId && !partData.clientCurrentId) {\n        partData.clientCurrentId = clientId;\n      }\n\n      if (typeof (clientRef === null || clientRef === void 0 ? void 0 : clientRef.get) === \"function\") {\n        const clientDoc = await clientRef.get();\n        partData.currentMachineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    }\n\n    return partData;\n  }));\n  return parts;\n} // Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\n\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false,\n  filterFn = null,\n  needsMachineData = true,\n  search = null\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const getRefId = ref => {\n    if (!ref) return null;\n    if (typeof ref === \"string\") return ref;\n    if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n    if (ref.id) return ref.id;\n    return null;\n  };\n\n  const MACHINE_SELECT_FIELDS = [\"OEM\", \"Modality\", \"Model\", \"client\", \"name\"];\n\n  const buildPart = (partDoc, machineMap, currentMachineMap) => {\n    var _ref3, _getRefId3, _ref4, _getRefId4;\n\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    partData.clientFromId = (_ref3 = (_getRefId3 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientFrom)) !== null && _getRefId3 !== void 0 ? _getRefId3 : partData === null || partData === void 0 ? void 0 : partData.clientFromId) !== null && _ref3 !== void 0 ? _ref3 : null;\n    partData.clientCurrentId = (_ref4 = (_getRefId4 = getRefId(partData === null || partData === void 0 ? void 0 : partData.ClientCurrent)) !== null && _getRefId4 !== void 0 ? _getRefId4 : partData === null || partData === void 0 ? void 0 : partData.clientCurrentId) !== null && _ref4 !== void 0 ? _ref4 : null;\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef = partData.CurrentMachine || partData.MachineCurrent;\n    const machineId = getRefId(machineRef);\n    const currentMachineId = getRefId(currentMachineRef);\n    const machineData = machineId ? machineMap[machineId] : null;\n    const currentMachineData = currentMachineId ? currentMachineMap[currentMachineId] : null;\n    partData.machineData = machineData || {};\n    partData.currentMachineData = currentMachineData || {};\n\n    if (!partData.clientFromId && machineData !== null && machineData !== void 0 && machineData.client) {\n      partData.clientFromId = getRefId(machineData.client);\n    }\n\n    if (!partData.clientCurrentId && currentMachineData !== null && currentMachineData !== void 0 && currentMachineData.client) {\n      partData.clientCurrentId = getRefId(currentMachineData.client);\n    }\n\n    return partData;\n  };\n\n  const searchRaw = ((search === null || search === void 0 ? void 0 : search.raw) || \"\").toString().trim();\n  const searchLower = ((search === null || search === void 0 ? void 0 : search.lower) || \"\").toString().trim();\n  const searchType = (search === null || search === void 0 ? void 0 : search.type) || null;\n  const hasSearch = Boolean(searchRaw);\n\n  const toTitleCase = text => text.split(\" \").filter(Boolean).map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(\" \");\n\n  const buildSearchQuery = () => {\n    if (!hasSearch || !searchType) return {\n      mode: \"scan\",\n      query: null\n    };\n    const col = db.collection(\"Test\");\n\n    switch (searchType) {\n      case \"SKU\":\n        return {\n          mode: \"sku\",\n          query: null\n        };\n\n      case \"Name\":\n        {\n          const titleFallback = searchRaw && searchRaw === searchRaw.toLowerCase() ? toTitleCase(searchRaw) : null;\n          const terms = searchLower ? searchLower.split(/\\s+/).filter(Boolean) : [];\n          const tokens = [...terms];\n          if (searchLower && !tokens.includes(searchLower)) tokens.push(searchLower);\n          if (!tokens.length) return {\n            mode: \"scan\",\n            query: null\n          };\n\n          const prefixQuery = value => col.orderBy(\"name\").startAt(value).endAt(`${value}\\uf8ff`);\n\n          return {\n            mode: \"query\",\n            query: tokens.length === 1 ? col.where(\"nameTokens\", \"array-contains\", tokens[0]) : col.where(\"nameTokens\", \"array-contains-any\", tokens.slice(0, 10)),\n            fallback: titleFallback ? () => prefixQuery(titleFallback) : () => prefixQuery(searchRaw)\n          };\n        }\n\n      case \"Product Number\":\n        return {\n          mode: \"query\",\n          query: col.where(\"pn\", \"array-contains\", searchRaw),\n          fallback: () => col.where(\"pn\", \"==\", searchRaw)\n        };\n\n      case \"Serial Number\":\n        return {\n          mode: \"query\",\n          query: col.where(\"sn\", \"array-contains\", searchRaw),\n          fallback: () => col.where(\"sn\", \"==\", searchRaw)\n        };\n\n      case \"Date\":\n        {\n          const asDate = (() => {\n            try {\n              const d = new Date(searchRaw);\n              return isNaN(d.getTime()) ? null : d;\n            } catch {\n              return null;\n            }\n          })();\n\n          return {\n            mode: \"query\",\n            query: col.where(\"date\", \"==\", searchRaw),\n            fallback: asDate ? () => col.where(\"date\", \"==\", asDate) : null\n          };\n        }\n\n      default:\n        return {\n          mode: \"scan\",\n          query: null\n        };\n    }\n  };\n\n  const {\n    mode: searchMode,\n    query: searchQuery,\n    fallback: searchFallback\n  } = buildSearchQuery();\n\n  if (searchMode === \"sku\" && hasSearch) {\n    const docs = [];\n    const rawUpper = searchRaw.toUpperCase();\n    let doc = await db.collection(\"Test\").doc(searchRaw).get();\n\n    if (!doc.exists && rawUpper !== searchRaw) {\n      doc = await db.collection(\"Test\").doc(rawUpper).get();\n    }\n\n    if (doc.exists) docs.push(doc);\n    const localValues = rawUpper !== searchRaw ? [searchRaw, rawUpper] : [searchRaw];\n    const localSnap = await db.collection(\"Test\").where(\"localSN\", \"in\", localValues).limit(limit).get();\n    localSnap.forEach(d => {\n      if (!docs.find(existing => existing.id === d.id)) {\n        docs.push(d);\n      }\n    });\n    let machineMap = {};\n    let currentMachineMap = {};\n\n    if (needsMachineData && docs.length) {\n      const machineIds = new Set();\n      const currentMachineIds = new Set();\n\n      for (const docSnap of docs) {\n        const raw = docSnap.data();\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\n        const currentMachineId = getRefId(raw.CurrentMachine || raw.MachineCurrent);\n        if (machineId) machineIds.add(machineId);\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\n      }\n\n      const fetchMachineMap = async ids => {\n        if (!ids.length) return {};\n        const out = {};\n        const chunks = [];\n\n        for (let i = 0; i < ids.length; i += 10) {\n          chunks.push(ids.slice(i, i + 10));\n        }\n\n        for (const chunk of chunks) {\n          const snap = await db.collection(\"Machine\").where(firebase.firestore.FieldPath.documentId(), \"in\", chunk).select(...MACHINE_SELECT_FIELDS).get();\n          snap.forEach(docSnap => {\n            out[docSnap.id] = docSnap.data() || {};\n          });\n        }\n\n        return out;\n      };\n\n      [machineMap, currentMachineMap] = await Promise.all([fetchMachineMap([...machineIds]), fetchMachineMap([...currentMachineIds])]);\n    }\n\n    const built = docs.map(docSnap => buildPart(docSnap, machineMap, currentMachineMap)).filter(item => !visibleOnly || (item === null || item === void 0 ? void 0 : item.visible) !== false).filter(item => filterFn ? filterFn(item) : true).slice(0, pageSize);\n    return {\n      parts: built,\n      lastDoc: built.length ? docs[built.length - 1] : null,\n      hasNextPage: false\n    };\n  }\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let pageLastDoc = null;\n  let hasNextPage = false;\n  let filled = false;\n  let usedFallback = false;\n\n  while (true) {\n    let query = searchQuery || db.collection(\"Test\");\n\n    if (searchMode === \"query\" && usedFallback && searchFallback) {\n      query = searchFallback();\n    }\n\n    if (cursor) query = query.startAfter(cursor);\n    query = query.limit(limit);\n    const snap = await query.get();\n\n    if (snap.empty) {\n      if (searchMode === \"query\" && searchFallback && !cursor && !usedFallback) {\n        usedFallback = true;\n        continue;\n      }\n\n      hasNextPage = false;\n      break;\n    }\n\n    const batchDocs = snap.docs;\n    let machineMap = {};\n    let currentMachineMap = {};\n\n    if (needsMachineData) {\n      const machineIds = new Set();\n      const currentMachineIds = new Set();\n\n      for (const doc of batchDocs) {\n        const raw = doc.data();\n\n        if (visibleOnly && raw.visible === false) {\n          continue;\n        }\n\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\n        const currentMachineId = getRefId(raw.CurrentMachine || raw.MachineCurrent);\n        if (machineId) machineIds.add(machineId);\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\n      }\n\n      const fetchMachineMap = async ids => {\n        if (!ids.length) return {};\n        const out = {};\n        const chunks = [];\n\n        for (let i = 0; i < ids.length; i += 10) {\n          chunks.push(ids.slice(i, i + 10));\n        }\n\n        for (const chunk of chunks) {\n          const snap = await db.collection(\"Machine\").where(firebase.firestore.FieldPath.documentId(), \"in\", chunk).select(...MACHINE_SELECT_FIELDS).get();\n          snap.forEach(doc => {\n            out[doc.id] = doc.data() || {};\n          });\n        }\n\n        return out;\n      };\n\n      [machineMap, currentMachineMap] = await Promise.all([fetchMachineMap([...machineIds]), fetchMachineMap([...currentMachineIds])]);\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = batchDocs[i];\n      cursor = doc;\n      const raw = doc.data();\n\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      const built = buildPart(doc, machineMap, currentMachineMap);\n\n      if (filterFn && !filterFn(built)) {\n        continue;\n      }\n\n      if (!filled) {\n        parts.push(built);\n\n        if (parts.length === pageSize) {\n          filled = true;\n          pageLastDoc = doc;\n        }\n\n        continue;\n      } // We already filled the page and found an extra matching item.\n\n\n      hasNextPage = true;\n      return {\n        parts,\n        lastDoc: pageLastDoc,\n        hasNextPage\n      };\n    } // We exhausted this batch without filling the page.\n\n\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    } // There might be more docs; continue scanning for visible items.\n\n\n    hasNextPage = true;\n  }\n\n  lastDoc = pageLastDoc || (parts.length ? cursor : null);\n  return {\n    parts,\n    lastDoc,\n    hasNextPage: filled ? hasNextPage : false\n  };\n}\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map(doc => _objectSpread({\n    id: doc.id\n  }, doc.data())); // Filter clients based on OEM and Modality if selected\n\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n\n    for (const client of clients) {\n      let match = true;\n\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n\n          if (selectedOEM && machineData.OEM === selectedOEM || selectedModality && machineData.Modality === selectedModality) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n\n    return filteredClients;\n  }\n\n  return clients;\n}\nexport async function fetchModels(selectedOEM, selectedModality, selectedClient) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n  await Promise.all(machinesSnapshot.docs.map(async machineDoc => {\n    const machineData = machineDoc.data();\n    let isValid = true;\n    if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n    if (selectedModality && machineData.Modality !== selectedModality) isValid = false;\n\n    if (selectedClient && machineData.client) {\n      var _machineData$client;\n\n      let clientDoc = null;\n\n      if (typeof ((_machineData$client = machineData.client) === null || _machineData$client === void 0 ? void 0 : _machineData$client.get) === \"function\") {\n        clientDoc = await machineData.client.get();\n      } else if (typeof machineData.client === \"string\") {\n        clientDoc = await db.collection(\"Client\").doc(machineData.client).get();\n      }\n\n      if (!clientDoc || !clientDoc.exists) {\n        isValid = false;\n      } else {\n        const clientName = clientDoc.data().name;\n        const clientId = clientDoc.id;\n\n        if (selectedClient !== clientName && selectedClient !== clientId) {\n          isValid = false;\n        }\n      }\n    }\n\n    if (isValid) {\n      models.add(machineData.Model);\n    }\n  }));\n  return Array.from(models);\n}\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/utils/fetchAssociations.js"],"names":["React","firebase","fetchPartsWithMachineData","db","firestore","partsSnapshot","collection","get","parts","Promise","all","docs","map","partDoc","partData","data","id","getRefId","ref","DocumentReference","clientFromId","ClientFrom","clientCurrentId","ClientCurrent","fetchMachineData","doc","exists","machineRef","Machine","MachineFrom","currentMachineRef","CurrentMachine","MachineCurrent","machineData","client","clientRef","clientId","clientDoc","Client","name","currentMachineData","fetchPartsWithMachineDataPage","pageSize","startAfterDoc","visibleOnly","filterFn","needsMachineData","search","limit","MACHINE_SELECT_FIELDS","buildPart","machineMap","currentMachineMap","machineId","currentMachineId","searchRaw","raw","toString","trim","searchLower","lower","searchType","type","hasSearch","Boolean","toTitleCase","text","split","filter","word","charAt","toUpperCase","slice","join","buildSearchQuery","mode","query","col","titleFallback","toLowerCase","terms","tokens","includes","push","length","prefixQuery","value","orderBy","startAt","endAt","where","fallback","asDate","d","Date","isNaN","getTime","searchMode","searchQuery","searchFallback","rawUpper","localValues","localSnap","forEach","find","existing","machineIds","Set","currentMachineIds","docSnap","add","fetchMachineMap","ids","out","chunks","i","chunk","snap","FieldPath","documentId","select","built","item","visible","lastDoc","hasNextPage","cursor","pageLastDoc","filled","usedFallback","startAfter","empty","batchDocs","size","fetchClients","selectedOEM","selectedModality","clientsSnapshot","clients","filteredClients","match","machines","machineDoc","OEM","Modality","fetchModels","selectedClient","machinesSnapshot","models","isValid","clientName","Model","Array","from","formatDate","timestamp","date","toDate","day","String","getDate","padStart","month","getMonth","year","getFullYear"],"mappings":"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","sourcesContent":["import React from 'react'\nimport firebase from \"../context/Firebase\";\n\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(\n    partsSnapshot.docs.map(async (partDoc) => {\n      const partData = partDoc.data();\n      partData.id = partDoc.id; // Add document ID here\n      const getRefId = (ref) => {\n        if (!ref) return null;\n        if (typeof ref === \"string\") return ref;\n        if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n        if (ref.id) return ref.id;\n        return null;\n      };\n      partData.clientFromId =\n        getRefId(partData?.ClientFrom) ?? partData?.clientFromId ?? null;\n      partData.clientCurrentId =\n        getRefId(partData?.ClientCurrent) ?? partData?.clientCurrentId ?? null;\n      // console.log(partData);\n      const fetchMachineData = async (ref) => {\n        if (!ref) return null;\n        if (typeof ref.get === \"function\") {\n          const doc = await ref.get();\n          return doc.exists ? doc.data() : null;\n        }\n        if (typeof ref === \"string\") {\n          const doc = await db.collection(\"Machine\").doc(ref).get();\n          return doc.exists ? doc.data() : null;\n        }\n        if (ref?.id) {\n          const doc = await db.collection(\"Machine\").doc(ref.id).get();\n          return doc.exists ? doc.data() : null;\n        }\n        return null;\n      };\n\n      const machineRef = partData.Machine || partData.MachineFrom;\n      const currentMachineRef =\n        partData.CurrentMachine || partData.MachineCurrent;\n\n      const machineData = await fetchMachineData(machineRef);\n      partData.machineData = machineData || {};\n      if (machineData?.client) {\n        const clientRef = machineData.client;\n        const clientId = getRefId(clientRef);\n        if (clientId && !partData.clientFromId) {\n          partData.clientFromId = clientId;\n        }\n        if (typeof clientRef?.get === \"function\") {\n          const clientDoc = await clientRef.get();\n          partData.machineData.Client = clientDoc.exists\n            ? clientDoc.data().name\n            : \"\";\n        }\n      }\n\n      const currentMachineData = await fetchMachineData(currentMachineRef);\n      partData.currentMachineData = currentMachineData || {};\n      if (currentMachineData?.client) {\n        const clientRef = currentMachineData.client;\n        const clientId = getRefId(clientRef);\n        if (clientId && !partData.clientCurrentId) {\n          partData.clientCurrentId = clientId;\n        }\n        if (typeof clientRef?.get === \"function\") {\n          const clientDoc = await clientRef.get();\n          partData.currentMachineData.Client = clientDoc.exists\n            ? clientDoc.data().name\n            : \"\";\n        }\n      }\n      return partData;\n    })\n  );\n  return parts;\n}\n\n// Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false,\n  filterFn = null,\n  needsMachineData = true,\n  search = null,\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const getRefId = (ref) => {\n    if (!ref) return null;\n    if (typeof ref === \"string\") return ref;\n    if (ref instanceof firebase.firestore.DocumentReference) return ref.id;\n    if (ref.id) return ref.id;\n    return null;\n  };\n\n  const MACHINE_SELECT_FIELDS = [\"OEM\", \"Modality\", \"Model\", \"client\", \"name\"];\n\n  const buildPart = (partDoc, machineMap, currentMachineMap) => {\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n    partData.clientFromId =\n      getRefId(partData?.ClientFrom) ?? partData?.clientFromId ?? null;\n    partData.clientCurrentId =\n      getRefId(partData?.ClientCurrent) ?? partData?.clientCurrentId ?? null;\n\n    const machineRef = partData.Machine || partData.MachineFrom;\n    const currentMachineRef =\n      partData.CurrentMachine || partData.MachineCurrent;\n\n    const machineId = getRefId(machineRef);\n    const currentMachineId = getRefId(currentMachineRef);\n\n    const machineData = machineId ? machineMap[machineId] : null;\n    const currentMachineData = currentMachineId\n      ? currentMachineMap[currentMachineId]\n      : null;\n\n    partData.machineData = machineData || {};\n    partData.currentMachineData = currentMachineData || {};\n\n    if (!partData.clientFromId && machineData?.client) {\n      partData.clientFromId = getRefId(machineData.client);\n    }\n    if (!partData.clientCurrentId && currentMachineData?.client) {\n      partData.clientCurrentId = getRefId(currentMachineData.client);\n    }\n\n    return partData;\n  };\n\n  const searchRaw = (search?.raw || \"\").toString().trim();\n  const searchLower = (search?.lower || \"\").toString().trim();\n  const searchType = search?.type || null;\n  const hasSearch = Boolean(searchRaw);\n\n  const toTitleCase = (text) =>\n    text\n      .split(\" \")\n      .filter(Boolean)\n      .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n      .join(\" \");\n\n  const buildSearchQuery = () => {\n    if (!hasSearch || !searchType) return { mode: \"scan\", query: null };\n    const col = db.collection(\"Test\");\n\n    switch (searchType) {\n      case \"SKU\":\n        return { mode: \"sku\", query: null };\n      case \"Name\": {\n        const titleFallback =\n          searchRaw && searchRaw === searchRaw.toLowerCase()\n            ? toTitleCase(searchRaw)\n            : null;\n        const terms = searchLower ? searchLower.split(/\\s+/).filter(Boolean) : [];\n        const tokens = [...terms];\n        if (searchLower && !tokens.includes(searchLower)) tokens.push(searchLower);\n        if (!tokens.length) return { mode: \"scan\", query: null };\n\n        const prefixQuery = (value) =>\n          col.orderBy(\"name\").startAt(value).endAt(`${value}\\uf8ff`);\n\n        return {\n          mode: \"query\",\n          query:\n            tokens.length === 1\n              ? col.where(\"nameTokens\", \"array-contains\", tokens[0])\n              : col.where(\n                  \"nameTokens\",\n                  \"array-contains-any\",\n                  tokens.slice(0, 10)\n                ),\n          fallback: titleFallback\n            ? () => prefixQuery(titleFallback)\n            : () => prefixQuery(searchRaw),\n        };\n      }\n      case \"Product Number\":\n        return {\n          mode: \"query\",\n          query: col.where(\"pn\", \"array-contains\", searchRaw),\n          fallback: () => col.where(\"pn\", \"==\", searchRaw),\n        };\n      case \"Serial Number\":\n        return {\n          mode: \"query\",\n          query: col.where(\"sn\", \"array-contains\", searchRaw),\n          fallback: () => col.where(\"sn\", \"==\", searchRaw),\n        };\n      case \"Date\": {\n        const asDate = (() => {\n          try {\n            const d = new Date(searchRaw);\n            return isNaN(d.getTime()) ? null : d;\n          } catch {\n            return null;\n          }\n        })();\n        return {\n          mode: \"query\",\n          query: col.where(\"date\", \"==\", searchRaw),\n          fallback: asDate ? () => col.where(\"date\", \"==\", asDate) : null,\n        };\n      }\n      default:\n        return { mode: \"scan\", query: null };\n    }\n  };\n\n  const { mode: searchMode, query: searchQuery, fallback: searchFallback } =\n    buildSearchQuery();\n\n  if (searchMode === \"sku\" && hasSearch) {\n    const docs = [];\n    const rawUpper = searchRaw.toUpperCase();\n    let doc = await db.collection(\"Test\").doc(searchRaw).get();\n    if (!doc.exists && rawUpper !== searchRaw) {\n      doc = await db.collection(\"Test\").doc(rawUpper).get();\n    }\n    if (doc.exists) docs.push(doc);\n\n    const localValues =\n      rawUpper !== searchRaw ? [searchRaw, rawUpper] : [searchRaw];\n    const localSnap = await db\n      .collection(\"Test\")\n      .where(\"localSN\", \"in\", localValues)\n      .limit(limit)\n      .get();\n    localSnap.forEach((d) => {\n      if (!docs.find((existing) => existing.id === d.id)) {\n        docs.push(d);\n      }\n    });\n\n    let machineMap = {};\n    let currentMachineMap = {};\n    if (needsMachineData && docs.length) {\n      const machineIds = new Set();\n      const currentMachineIds = new Set();\n      for (const docSnap of docs) {\n        const raw = docSnap.data();\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\n        const currentMachineId = getRefId(\n          raw.CurrentMachine || raw.MachineCurrent\n        );\n        if (machineId) machineIds.add(machineId);\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\n      }\n      const fetchMachineMap = async (ids) => {\n        if (!ids.length) return {};\n        const out = {};\n        const chunks = [];\n        for (let i = 0; i < ids.length; i += 10) {\n          chunks.push(ids.slice(i, i + 10));\n        }\n        for (const chunk of chunks) {\n          const snap = await db\n            .collection(\"Machine\")\n            .where(firebase.firestore.FieldPath.documentId(), \"in\", chunk)\n            .select(...MACHINE_SELECT_FIELDS)\n            .get();\n          snap.forEach((docSnap) => {\n            out[docSnap.id] = docSnap.data() || {};\n          });\n        }\n        return out;\n      };\n      [machineMap, currentMachineMap] = await Promise.all([\n        fetchMachineMap([...machineIds]),\n        fetchMachineMap([...currentMachineIds]),\n      ]);\n    }\n\n    const built = docs\n      .map((docSnap) => buildPart(docSnap, machineMap, currentMachineMap))\n      .filter((item) => (!visibleOnly || item?.visible !== false))\n      .filter((item) => (filterFn ? filterFn(item) : true))\n      .slice(0, pageSize);\n\n    return {\n      parts: built,\n      lastDoc: built.length ? docs[built.length - 1] : null,\n      hasNextPage: false,\n    };\n  }\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let pageLastDoc = null;\n  let hasNextPage = false;\n  let filled = false;\n  let usedFallback = false;\n\n  while (true) {\n    let query = searchQuery || db.collection(\"Test\");\n    if (searchMode === \"query\" && usedFallback && searchFallback) {\n      query = searchFallback();\n    }\n    if (cursor) query = query.startAfter(cursor);\n    query = query.limit(limit);\n\n    const snap = await query.get();\n    if (snap.empty) {\n      if (searchMode === \"query\" && searchFallback && !cursor && !usedFallback) {\n        usedFallback = true;\n        continue;\n      }\n      hasNextPage = false;\n      break;\n    }\n\n    const batchDocs = snap.docs;\n    let machineMap = {};\n    let currentMachineMap = {};\n\n    if (needsMachineData) {\n      const machineIds = new Set();\n      const currentMachineIds = new Set();\n      for (const doc of batchDocs) {\n        const raw = doc.data();\n        if (visibleOnly && raw.visible === false) {\n          continue;\n        }\n        const machineId = getRefId(raw.Machine || raw.MachineFrom);\n        const currentMachineId = getRefId(\n          raw.CurrentMachine || raw.MachineCurrent\n        );\n        if (machineId) machineIds.add(machineId);\n        if (currentMachineId) currentMachineIds.add(currentMachineId);\n      }\n\n        const fetchMachineMap = async (ids) => {\n          if (!ids.length) return {};\n          const out = {};\n          const chunks = [];\n          for (let i = 0; i < ids.length; i += 10) {\n            chunks.push(ids.slice(i, i + 10));\n          }\n          for (const chunk of chunks) {\n            const snap = await db\n              .collection(\"Machine\")\n              .where(firebase.firestore.FieldPath.documentId(), \"in\", chunk)\n              .select(...MACHINE_SELECT_FIELDS)\n              .get();\n            snap.forEach((doc) => {\n              out[doc.id] = doc.data() || {};\n            });\n          }\n        return out;\n      };\n\n      [machineMap, currentMachineMap] = await Promise.all([\n        fetchMachineMap([...machineIds]),\n        fetchMachineMap([...currentMachineIds]),\n      ]);\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = batchDocs[i];\n      cursor = doc;\n\n      const raw = doc.data();\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      const built = buildPart(doc, machineMap, currentMachineMap);\n      if (filterFn && !filterFn(built)) {\n        continue;\n      }\n\n      if (!filled) {\n        parts.push(built);\n        if (parts.length === pageSize) {\n          filled = true;\n          pageLastDoc = doc;\n        }\n        continue;\n      }\n\n      // We already filled the page and found an extra matching item.\n      hasNextPage = true;\n      return { parts, lastDoc: pageLastDoc, hasNextPage };\n    }\n\n    // We exhausted this batch without filling the page.\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    }\n\n    // There might be more docs; continue scanning for visible items.\n    hasNextPage = true;\n  }\n\n  lastDoc = pageLastDoc || (parts.length ? cursor : null);\n  return { parts, lastDoc, hasNextPage: filled ? hasNextPage : false };\n}\n\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map((doc) => ({\n    id: doc.id,\n    ...doc.data(),\n  }));\n\n  // Filter clients based on OEM and Modality if selected\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n    for (const client of clients) {\n      let match = true;\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n          if (\n            (selectedOEM && machineData.OEM === selectedOEM) ||\n            (selectedModality && machineData.Modality === selectedModality)\n          ) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n    return filteredClients;\n  }\n\n  return clients;\n}\n\nexport async function fetchModels(\n  selectedOEM,\n  selectedModality,\n  selectedClient\n) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n\n  await Promise.all(\n    machinesSnapshot.docs.map(async (machineDoc) => {\n      const machineData = machineDoc.data();\n      let isValid = true;\n\n      if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n      if (selectedModality && machineData.Modality !== selectedModality)\n        isValid = false;\n      if (selectedClient && machineData.client) {\n        let clientDoc = null;\n        if (typeof machineData.client?.get === \"function\") {\n          clientDoc = await machineData.client.get();\n        } else if (typeof machineData.client === \"string\") {\n          clientDoc = await db.collection(\"Client\").doc(machineData.client).get();\n        }\n        if (!clientDoc || !clientDoc.exists) {\n          isValid = false;\n        } else {\n          const clientName = clientDoc.data().name;\n          const clientId = clientDoc.id;\n          if (selectedClient !== clientName && selectedClient !== clientId) {\n            isValid = false;\n          }\n        }\n      }\n\n      if (isValid) {\n        models.add(machineData.Model);\n      }\n    })\n  );\n\n  return Array.from(models);\n}\n\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}\n"]},"metadata":{},"sourceType":"module"}