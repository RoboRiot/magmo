{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/router\";\nimport { Table, Button, Alert, Spinner } from \"react-bootstrap\";\nimport firebase from \"../../../../context/Firebase\";\nimport ClientInfoModal from \"../../ClientInfoModal\";\nimport MachineCreationModal from \"../../MachineCreationModal\";\nimport styles from \"../Client.module.css\"; // Import for SSR\n\nimport { adminDb } from \"../../../../context/FirebaseAdmin\";\n\nconst Client = ({\n  initialClient,\n  initialMachines,\n  error: initialError\n}) => {\n  const router = useRouter();\n  const {\n    0: selectedClient,\n    1: setSelectedClient\n  } = useState(initialClient || null);\n  const {\n    0: machineOptions,\n    1: setMachineOptions\n  } = useState(Array.isArray(initialMachines) ? initialMachines : []);\n  const {\n    0: error,\n    1: setError\n  } = useState(initialError || null);\n  const {\n    0: isLoading,\n    1: setIsLoading\n  } = useState(!initialClient && !initialError); // State for machine addition modals\n\n  const {\n    0: showAddMachineModal,\n    1: setShowAddMachineModal\n  } = useState(false);\n  const {\n    0: showCreateMachineModal,\n    1: setShowCreateMachineModal\n  } = useState(false);\n  const {\n    0: availableMachines,\n    1: setAvailableMachines\n  } = useState([]);\n  useEffect(() => {\n    if (!router.isReady) return;\n    const activeId = router.query.id || router.asPath.split(\"/\").pop();\n    if (!activeId) return;\n    const hasInitial = initialClient && initialClient.id === activeId;\n    fetchClientData(activeId, {\n      silent: hasInitial\n    });\n  }, [router.isReady, router.query.id, initialClient]);\n\n  const fetchClientData = async (clientId, {\n    silent = false\n  } = {}) => {\n    if (!silent) {\n      setIsLoading(true);\n    }\n\n    setError(null);\n\n    try {\n      const db = firebase.firestore();\n      const clientDoc = await db.collection(\"Client\").doc(clientId).get();\n\n      if (clientDoc.exists) {\n        const clientData = clientDoc.data();\n        setSelectedClient(_objectSpread({\n          id: clientId\n        }, clientData));\n        const machineRefs = Array.isArray(clientData.machines) ? clientData.machines : [];\n        const machinePromises = machineRefs.map(machineRef => machineRef.get());\n        const machineDocs = await Promise.all(machinePromises);\n        const machines = machineDocs.map(machineDoc => _objectSpread({\n          id: machineDoc.id\n        }, machineDoc.data()));\n        setMachineOptions(machines);\n      } else {\n        setError(\"Client not found\");\n      }\n    } catch (error) {\n      console.error(\"Error fetching client data:\", error);\n      setError(\"Error fetching client data\");\n    } finally {\n      if (!silent) {\n        setIsLoading(false);\n      }\n    }\n  }; // Fetch available machines (those not yet assigned to a client)\n\n\n  const fetchAvailableMachines = async () => {\n    try {\n      const db = firebase.firestore();\n      const snapshot = await db.collection(\"Machine\").where(\"client\", \"==\", null).get();\n      const machines = snapshot.docs.map(doc => _objectSpread({\n        id: doc.id\n      }, doc.data()));\n      setAvailableMachines(machines);\n    } catch (error) {\n      console.error(\"Error fetching available machines:\", error);\n      setError(\"Failed to fetch available machines.\");\n    }\n  };\n\n  const handleSelectMachine = (id, name) => {\n    // Navigate to the machine details page if needed\n    router.push(\"../machine/\" + id);\n  }; // When adding an existing machine\n\n\n  const handleAddMachine = async machine => {\n    try {\n      const db = firebase.firestore();\n      const clientId = router.query.clientId || router.asPath.split(\"/\").pop(); // Update client's \"machines\" array with the machine reference\n\n      await db.collection(\"Client\").doc(clientId).update({\n        machines: firebase.firestore.FieldValue.arrayUnion(db.collection(\"Machine\").doc(machine.id))\n      }); // Update local state to include the newly added machine\n\n      setMachineOptions(prev => [...prev, machine]);\n      setShowAddMachineModal(false);\n    } catch (error) {\n      console.error(\"Error adding machine to client:\", error);\n      setError(\"Failed to add machine to client.\");\n    }\n  }; // When creating a new machine for the client\n\n\n  const handleCreateMachine = async newMachine => {\n    try {\n      const db = firebase.firestore();\n      const clientId = router.query.clientId || router.asPath.split(\"/\").pop();\n      const machineId = `AIS${Math.floor(10000 + Math.random() * 90000)}`;\n\n      const machineWithId = _objectSpread(_objectSpread({}, newMachine), {}, {\n        id: machineId,\n        client: db.collection(\"Client\").doc(clientId)\n      }); // Create the machine document\n\n\n      await db.collection(\"Machine\").doc(machineId).set(machineWithId); // Add the machine reference to the client\n\n      await db.collection(\"Client\").doc(clientId).update({\n        machines: firebase.firestore.FieldValue.arrayUnion(db.collection(\"Machine\").doc(machineId))\n      }); // Update local state\n\n      setMachineOptions(prev => [...prev, _objectSpread({\n        id: machineId\n      }, newMachine)]);\n      setShowCreateMachineModal(false);\n    } catch (error) {\n      console.error(\"Error creating and adding machine:\", error);\n      setError(\"Failed to create and add machine.\");\n    }\n  }; // Open the modal to add an existing machine; fetch available machines first\n\n\n  const openAddMachineModal = async () => {\n    await fetchAvailableMachines();\n    setShowAddMachineModal(true);\n  };\n\n  return __jsx(\"div\", {\n    className: styles.page\n  }, __jsx(\"div\", {\n    className: styles.shell\n  }, __jsx(\"header\", {\n    className: styles.header\n  }, __jsx(\"div\", {\n    className: styles.brand\n  }, __jsx(\"img\", {\n    src: \"/magmo-logo.png\",\n    alt: \"Magmo\",\n    className: styles.brandLogo\n  }), __jsx(\"div\", null, __jsx(\"div\", {\n    className: styles.brandName\n  }, \"Magmo\"), __jsx(\"div\", {\n    className: styles.brandSub\n  }, \"Client Detail\"))), __jsx(Button, {\n    variant: \"outline-secondary\",\n    className: styles.backButton,\n    onClick: () => router.back()\n  }, \"Back\")), __jsx(\"section\", {\n    className: styles.card\n  }, __jsx(\"div\", {\n    className: styles.cardHeader\n  }, __jsx(\"div\", null, __jsx(\"div\", {\n    className: styles.cardTitle\n  }, \"Client Machines\"), __jsx(\"div\", {\n    className: styles.cardSubtitle\n  }, \"Manage machines linked to this client.\")), __jsx(\"div\", {\n    className: styles.cardMeta\n  }, machineOptions.length, \" machines\")), __jsx(\"div\", {\n    className: styles.cardBody\n  }, error && __jsx(Alert, {\n    variant: \"danger\"\n  }, error), isLoading && __jsx(\"div\", {\n    className: styles.loadingWrap\n  }, __jsx(Spinner, {\n    animation: \"border\",\n    role: \"status\"\n  }, __jsx(\"span\", {\n    className: \"sr-only\"\n  }, \"Loading...\"))), !isLoading && selectedClient && __jsx(React.Fragment, null, __jsx(\"div\", {\n    className: styles.clientSummary\n  }, __jsx(\"div\", {\n    className: styles.clientName\n  }, selectedClient.name), __jsx(\"div\", {\n    className: styles.clientMetaRow\n  }, __jsx(\"span\", null, \"Location: \", selectedClient.local || \"Unknown\"), __jsx(\"span\", null, \"Client ID: \", selectedClient.id))), __jsx(\"div\", {\n    className: styles.actionRow\n  }, __jsx(Button, {\n    variant: \"primary\",\n    onClick: openAddMachineModal\n  }, \"Add Existing Machine\"), __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: () => setShowCreateMachineModal(true)\n  }, \"Create New Machine\")), __jsx(\"div\", {\n    className: styles.tableCard\n  }, __jsx(\"div\", {\n    className: styles.tableHeader\n  }, __jsx(\"span\", null, \"Machines\"), __jsx(\"span\", {\n    className: styles.tableHint\n  }, \"Select a machine to view details.\")), __jsx(\"div\", {\n    className: styles.tableWrap\n  }, __jsx(Table, {\n    striped: true,\n    bordered: true,\n    hover: true,\n    size: \"sm\",\n    className: styles.table\n  }, __jsx(\"thead\", null, __jsx(\"tr\", null, __jsx(\"th\", null, \"Name\"), __jsx(\"th\", null, \"Location\"), __jsx(\"th\", null, \"OEM\"), __jsx(\"th\", null, \"Modality\"), __jsx(\"th\", null, \"Select\"))), __jsx(\"tbody\", null, machineOptions.length === 0 ? __jsx(\"tr\", null, __jsx(\"td\", {\n    colSpan: 5,\n    className: styles.emptyState\n  }, \"No machines assigned yet.\")) : machineOptions.map(machine => __jsx(\"tr\", {\n    key: machine.id\n  }, __jsx(\"td\", null, machine.name), __jsx(\"td\", null, machine.local), __jsx(\"td\", null, machine.OEM), __jsx(\"td\", null, machine.Modality), __jsx(\"td\", null, __jsx(Button, {\n    variant: \"primary\",\n    size: \"sm\",\n    onClick: () => handleSelectMachine(machine.id, machine.name)\n  }, \"Select\")))))))))))), __jsx(ClientInfoModal, {\n    show: showAddMachineModal,\n    handleClose: () => setShowAddMachineModal(false),\n    machineOptions: availableMachines,\n    setSelectedMachine: handleAddMachine\n  }), __jsx(MachineCreationModal, {\n    show: showCreateMachineModal,\n    handleClose: () => setShowCreateMachineModal(false),\n    onCreateMachine: handleCreateMachine\n  }));\n};\n\nexport default Client; // Server-side rendering function\n\nexport async function getServerSideProps(context) {\n  const {\n    id\n  } = context.params;\n\n  try {\n    // Fetch client data from Firestore using Admin SDK\n    const clientDoc = await adminDb.collection(\"Client\").doc(id).get();\n\n    if (!clientDoc.exists) {\n      return {\n        notFound: true // This will show a 404 page\n\n      };\n    }\n\n    const clientData = clientDoc.data(); // Fetch machine documents referenced in the client's machines array\n\n    let machines = [];\n\n    if (clientData.machines && Array.isArray(clientData.machines)) {\n      try {\n        const machinePromises = clientData.machines.map(machineRef => {\n          if (machineRef.path) {\n            return adminDb.doc(machineRef.path).get();\n          }\n\n          return null;\n        }).filter(Boolean);\n        const machineDocs = await Promise.all(machinePromises);\n        machines = machineDocs.map(machineDoc => {\n          const machineData = machineDoc.data(); // Extract only serializable data, remove any Firestore references\n\n          const serializedMachine = {\n            id: machineDoc.id,\n            name: machineData.name || \"\",\n            local: machineData.local || \"\",\n            OEM: machineData.OEM || \"\",\n            Modality: machineData.Modality || \"\",\n            Model: machineData.Model || \"\" // Add other fields as needed, but ensure they're serializable\n\n          }; // If there's a client reference, extract just the client name\n\n          if (machineData.client && machineData.client.path) {\n            try {\n              const clientDoc = adminDb.doc(machineData.client.path).get();\n\n              if (clientDoc.exists) {\n                serializedMachine.clientName = clientDoc.data().name || \"\";\n              }\n            } catch (error) {\n              console.error(\"Error fetching client name:\", error);\n            }\n          }\n\n          return serializedMachine;\n        });\n      } catch (error) {\n        console.error(\"Error fetching machine data:\", error);\n      }\n    } // Serialize the client data, removing any non-serializable fields\n\n\n    const serializedClient = {\n      id,\n      name: clientData.name || \"\",\n      local: clientData.local || \"\" // Add other client fields as needed, but ensure they're serializable\n\n    };\n    return {\n      props: {\n        initialClient: serializedClient,\n        initialMachines: machines\n      }\n    };\n  } catch (error) {\n    console.error(\"Error in getServerSideProps:\", error);\n    return {\n      props: {\n        error: \"Failed to load client data\"\n      }\n    };\n  }\n}","map":null,"metadata":{},"sourceType":"module"}