{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useEffect, useState } from \"react\";\nimport { useRouter } from \"next/router\";\nimport { Table, Button, Alert, Modal } from \"react-bootstrap\";\nimport firebase from \"../../../../context/Firebase\";\nimport styles from \"../Machine.module.css\"; // Import for SSR\n\nimport { adminDb } from \"../../../../context/FirebaseAdmin\";\n\nconst Machine = ({\n  initialMachine,\n  initialAssociatedParts,\n  error: initialError\n}) => {\n  const router = useRouter();\n  const {\n    0: selectedMachine,\n    1: setSelectedMachine\n  } = useState(initialMachine || null);\n  const {\n    0: associatedParts,\n    1: setAssociatedParts\n  } = useState(Array.isArray(initialAssociatedParts) ? initialAssociatedParts : []);\n  const {\n    0: error,\n    1: setError\n  } = useState(initialError || null);\n  const {\n    0: dragIndex,\n    1: setDragIndex\n  } = useState(null);\n  const {\n    0: dragOverIndex,\n    1: setDragOverIndex\n  } = useState(null);\n  const {\n    0: isPrinting,\n    1: setIsPrinting\n  } = useState(false);\n  const {\n    0: showPrintSuccess,\n    1: setShowPrintSuccess\n  } = useState(false);\n  useEffect(() => {\n    if (router.isReady) {\n      const {\n        id\n      } = router.query;\n\n      if (!id) {\n        const pathSegments = router.asPath.split(\"/\");\n        const machineIdFromPath = pathSegments[pathSegments.length - 1];\n        console.log(`Machine ID extracted from URL path: ${machineIdFromPath}`);\n        fetchMachineData(machineIdFromPath);\n      } else {\n        console.log(`Machine ID from router query: ${id}`); // If SSR already hydrated, avoid re-fetching unless we truly need to.\n\n        if (!selectedMachine) {\n          fetchMachineData(id);\n        }\n      }\n    }\n  }, [router.isReady, selectedMachine]);\n\n  const fetchMachineData = async machineId => {\n    try {\n      console.log(`Attempting to fetch machine data for ID: ${machineId}`);\n      const db = firebase.firestore();\n      const machineDoc = await db.collection(\"Machine\").doc(machineId).get();\n\n      if (machineDoc.exists) {\n        const machineData = machineDoc.data();\n        setSelectedMachine(machineData);\n        setError(null);\n        console.log(\"Machine data:\", machineData); // Fetch associated parts\n\n        if (machineData.associatedParts) {\n          fetchAssociatedParts(machineData.associatedParts);\n        }\n      } else {\n        console.error(\"Machine not found\");\n        setError(\"Machine not found\");\n      }\n    } catch (error) {\n      console.error(\"Error fetching machine data:\", error);\n      setError(\"Error fetching machine data\");\n    }\n  };\n\n  const fetchAssociatedParts = async associatedPartsRefs => {\n    try {\n      const db = firebase.firestore();\n      const partsDocs = await Promise.all(associatedPartsRefs.map(ref => ref.get()));\n      const partsData = await Promise.all(partsDocs.map(async doc => {\n        var _data$ClientFrom;\n\n        if (!doc.exists) {\n          // skip or return an empty object\n          return null;\n        }\n\n        const data = doc.data() || {};\n        let clientName = \"\";\n\n        if ((_data$ClientFrom = data.ClientFrom) !== null && _data$ClientFrom !== void 0 && _data$ClientFrom.get) {\n          const clientDoc = await data.ClientFrom.get();\n          clientName = clientDoc.exists ? clientDoc.data().name : \"\";\n        }\n\n        return _objectSpread(_objectSpread({\n          id: doc.id\n        }, data), {}, {\n          clientName\n        });\n      }));\n      setAssociatedParts(partsData.filter(p => p));\n      setError(null);\n      console.log(\"Associated parts data:\", partsData);\n    } catch (error) {\n      console.error(\"Error fetching associated parts:\", error);\n      setError(\"Error fetching associated parts\");\n    }\n  };\n\n  const handlePrintMulti = async () => {\n    setIsPrinting(true); // Create your payload with the mapped items.\n    // Replace 'associatedParts' with your actual variable containing the list.\n\n    const payload = {\n      items: associatedParts.map(part => ({\n        name: part.name,\n        arrival_date: part.arrival_date,\n        // Ensure your part has a 'date' field.\n        poNumber: part.poNumber || \"\",\n        OEM: part.TheMachine ? part.TheMachine.oem || \"\" : \"\",\n        modality: part.TheMachine ? part.TheMachine.modality || \"\" : \"\",\n        model: part.TheMachine ? part.TheMachine.model || \"\" : \"\",\n        local_sn: part.id,\n        // Using document id as the local serial number.\n        client: part.clientName || \"\",\n        description: part.description || (part.descriptions && part.descriptions.length > 0 ? part.descriptions[0].description : \"\")\n      })),\n      test_print: true,\n      // Hard-coded here if you want to test printing one item\n      index: 1 // Hard-coded index (1-based)\n\n    };\n\n    try {\n      const response = await fetch(\"https://9d70-174-76-22-138.ngrok-free.app/print_multi\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(payload)\n      });\n      const result = await response.json();\n      console.log(\"Print multi result:\", result.status);\n\n      if (!response.ok || (result === null || result === void 0 ? void 0 : result.status) === \"error\") {\n        throw new Error((result === null || result === void 0 ? void 0 : result.message) || \"Print failed.\");\n      }\n\n      setShowPrintSuccess(true);\n    } catch (error) {\n      console.error(\"Error printing multiple labels:\", error);\n      setError((error === null || error === void 0 ? void 0 : error.message) || \"Error printing multiple labels\");\n    } finally {\n      setIsPrinting(false);\n    }\n  };\n\n  const handleSelectPart = (id, name) => {\n    console.log(`Selected part ID: ${id}, Name: ${name}`);\n    router.push(\"../item/\" + id);\n  };\n\n  const handleDragStart = index => event => {\n    var _associatedParts$inde;\n\n    if (event.target.closest(\"button\")) {\n      event.preventDefault();\n      return;\n    }\n\n    setDragIndex(index);\n    event.dataTransfer.effectAllowed = \"move\";\n    event.dataTransfer.setData(\"text/plain\", ((_associatedParts$inde = associatedParts[index]) === null || _associatedParts$inde === void 0 ? void 0 : _associatedParts$inde.id) || String(index));\n  };\n\n  const handleDragOver = index => event => {\n    event.preventDefault();\n    if (dragOverIndex !== index) setDragOverIndex(index);\n    event.dataTransfer.dropEffect = \"move\";\n  };\n\n  const handleDrop = index => event => {\n    event.preventDefault();\n\n    if (dragIndex == null || dragIndex === index) {\n      setDragIndex(null);\n      setDragOverIndex(null);\n      return;\n    }\n\n    setAssociatedParts(prev => {\n      const next = [...prev];\n      const [moved] = next.splice(dragIndex, 1);\n      next.splice(index, 0, moved);\n      return next;\n    });\n    setDragIndex(null);\n    setDragOverIndex(null);\n  };\n\n  const handleDragEnd = () => {\n    setDragIndex(null);\n    setDragOverIndex(null);\n  };\n\n  const formatDate = input => {\n    let date;\n\n    if (input && input.seconds) {\n      // Handle timestamp object with 'seconds' property\n      date = new Date(input.seconds * 1000);\n    } else if (typeof input === \"string\") {\n      // Handle date string\n      date = new Date(input);\n    } else {\n      return \"N/A\";\n    }\n\n    if (isNaN(date.getTime())) {\n      // Invalid date string\n      return \"Invalid Date\";\n    }\n\n    return date.toLocaleDateString();\n  };\n\n  return __jsx(\"div\", {\n    className: styles.page\n  }, isPrinting && __jsx(\"div\", {\n    className: styles.loadingOverlay\n  }, __jsx(\"img\", {\n    src: \"/magmo-logo.png\",\n    alt: \"Printing\",\n    className: styles.loadingLogo\n  })), __jsx(\"div\", {\n    className: styles.shell\n  }, __jsx(\"header\", {\n    className: styles.header\n  }, __jsx(\"div\", {\n    className: styles.brand\n  }, __jsx(\"img\", {\n    src: \"/magmo-logo.png\",\n    alt: \"Magmo\",\n    className: styles.brandLogo\n  }), __jsx(\"div\", null, __jsx(\"div\", {\n    className: styles.brandName\n  }, \"Magmo\"), __jsx(\"div\", {\n    className: styles.brandSub\n  }, \"Machine Detail\"))), __jsx(Button, {\n    variant: \"outline-secondary\",\n    className: styles.backButton,\n    onClick: () => router.back()\n  }, \"Back\")), __jsx(\"div\", {\n    className: styles.card\n  }, __jsx(Modal, {\n    show: showPrintSuccess,\n    onHide: () => setShowPrintSuccess(false),\n    centered: true\n  }, __jsx(Modal.Header, {\n    closeButton: true\n  }, __jsx(Modal.Title, null, \"Print Complete\")), __jsx(Modal.Body, null, \"All items were sent to the printer successfully.\"), __jsx(Modal.Footer, null, __jsx(Button, {\n    variant: \"primary\",\n    onClick: () => setShowPrintSuccess(false)\n  }, \"Ok\"))), __jsx(\"div\", {\n    className: styles.cardHeader\n  }, __jsx(\"div\", null, __jsx(\"div\", {\n    className: styles.cardTitle\n  }, \"Machine Details\"), __jsx(\"div\", {\n    className: styles.cardSubtitle\n  }, \"Drag and drop parts to reorder this list.\")), __jsx(\"div\", {\n    className: styles.cardMeta\n  }, associatedParts.length, \" parts\")), __jsx(\"div\", {\n    className: styles.cardBody\n  }, error && !selectedMachine && __jsx(Alert, {\n    variant: \"danger\"\n  }, error), selectedMachine ? __jsx(React.Fragment, null, __jsx(\"div\", {\n    className: styles.machineGrid\n  }, __jsx(\"div\", {\n    className: styles.machineInfo\n  }, __jsx(\"div\", {\n    className: styles.machineName\n  }, selectedMachine.name || \"Unnamed Machine\"), __jsx(\"div\", {\n    className: styles.machineMetaRow\n  }, __jsx(\"span\", null, \"OEM: \", selectedMachine.OEM || \"N/A\"), __jsx(\"span\", null, \"Modality: \", selectedMachine.Modality || \"N/A\"), __jsx(\"span\", null, \"Model: \", selectedMachine.Model || \"N/A\"))), __jsx(\"div\", {\n    className: styles.machineDates\n  }, __jsx(\"div\", null, __jsx(\"span\", {\n    className: styles.dateLabel\n  }, \"Last PM\"), __jsx(\"span\", null, formatDate(selectedMachine.lastPM))), __jsx(\"div\", null, __jsx(\"span\", {\n    className: styles.dateLabel\n  }, \"Next PM\"), __jsx(\"span\", null, formatDate(selectedMachine.nextPM))))), __jsx(\"div\", {\n    className: styles.tableCard\n  }, __jsx(\"div\", {\n    className: styles.tableHeader\n  }, \"Associated Parts\", __jsx(\"span\", {\n    className: styles.tableHint\n  }, \"Click + hold to move\")), __jsx(\"div\", {\n    className: styles.tableWrap\n  }, __jsx(Table, {\n    striped: true,\n    bordered: true,\n    hover: true,\n    size: \"sm\",\n    className: styles.table\n  }, __jsx(\"thead\", null, __jsx(\"tr\", null, __jsx(\"th\", null, \"Name\"), __jsx(\"th\", null, \"ID\"), __jsx(\"th\", null, \"Part Number\"), __jsx(\"th\", null, \"Serial Number\"), __jsx(\"th\", null, \"Date\"), __jsx(\"th\", null, \"Select\"))), __jsx(\"tbody\", null, associatedParts.length === 0 && __jsx(\"tr\", null, __jsx(\"td\", {\n    colSpan: 6,\n    className: styles.emptyState\n  }, \"No associated parts found.\")), associatedParts.map((part, index) => __jsx(\"tr\", {\n    key: part.id,\n    draggable: true,\n    onDragStart: handleDragStart(index),\n    onDragOver: handleDragOver(index),\n    onDrop: handleDrop(index),\n    onDragEnd: handleDragEnd,\n    className: `${styles.draggableRow} ${dragIndex === index ? styles.dragging : \"\"} ${dragOverIndex === index && dragIndex !== index ? styles.dropTarget : \"\"}`\n  }, __jsx(\"td\", null, part.name), __jsx(\"td\", null, part.id), __jsx(\"td\", null, part.pn), __jsx(\"td\", null, part.sn), __jsx(\"td\", null, formatDate(part.date || part.arrival_date)), __jsx(\"td\", null, __jsx(Button, {\n    variant: \"primary\",\n    size: \"sm\",\n    onClick: () => handleSelectPart(part.id, part.name)\n  }, \"Select\"))))))), __jsx(\"div\", {\n    className: styles.tableActions\n  }, __jsx(Button, {\n    variant: \"secondary\",\n    className: styles.actionButton,\n    onClick: handlePrintMulti\n  }, \"Print All Items\")))) : !error && __jsx(\"p\", {\n    className: styles.loadingText\n  }, \"Loading machine data...\")))));\n};\n\nexport default Machine; // Server-side rendering function\n\nexport async function getServerSideProps(context) {\n  const {\n    id\n  } = context.params;\n\n  try {\n    if (!adminDb) {\n      return {\n        props: {\n          error: \"Firebase Admin not configured for SSR.\"\n        }\n      };\n    } // Fetch machine data from Firestore using Admin SDK\n\n\n    const machineDoc = await adminDb.collection(\"Machine\").doc(id).get();\n\n    if (!machineDoc.exists) {\n      return {\n        notFound: true // This will show a 404 page\n\n      };\n    }\n\n    const machineData = machineDoc.data(); // Fetch associated parts if they exist\n\n    let associatedParts = [];\n\n    if (machineData.associatedParts && Array.isArray(machineData.associatedParts)) {\n      try {\n        const partsPromises = machineData.associatedParts.map(partRef => {\n          if (partRef.path) {\n            return adminDb.doc(partRef.path).get();\n          }\n\n          return null;\n        }).filter(Boolean);\n        const partsDocs = await Promise.all(partsPromises);\n\n        const toDisplayValue = value => {\n          if (Array.isArray(value)) {\n            return value.filter(v => v != null && v !== \"\").join(\", \");\n          }\n\n          return value !== null && value !== void 0 ? value : \"\";\n        };\n\n        associatedParts = await Promise.all(partsDocs.map(async doc => {\n          if (!doc.exists) {\n            return null;\n          }\n\n          const data = doc.data() || {};\n          let clientName = \"\"; // Fetch client name if ClientFrom reference exists\n\n          if (data.ClientFrom && data.ClientFrom.path) {\n            try {\n              const clientDoc = await adminDb.doc(data.ClientFrom.path).get();\n              clientName = clientDoc.exists ? clientDoc.data().name : \"\";\n            } catch (error) {\n              console.error(\"Error fetching client data:\", error);\n            }\n          }\n\n          return {\n            id: doc.id,\n            name: data.name || \"\",\n            pn: toDisplayValue(data.pn),\n            sn: toDisplayValue(data.sn),\n            date: data.date || data.arrival_date || \"\",\n            clientName\n          };\n        })); // Filter out null values\n\n        associatedParts = associatedParts.filter(part => part !== null);\n      } catch (error) {\n        console.error(\"Error fetching associated parts:\", error);\n      }\n    } // Serialize the machine data, removing any non-serializable fields\n\n\n    const serializedMachine = {\n      id,\n      name: machineData.name || \"\",\n      Model: machineData.Model || \"\",\n      OEM: machineData.OEM || \"\",\n      Modality: machineData.Modality || \"\",\n      lastPM: machineData.lastPM || null,\n      nextPM: machineData.nextPM || null // Add other machine fields as needed, but ensure they're serializable\n\n    };\n    return {\n      props: {\n        initialMachine: serializedMachine,\n        initialAssociatedParts: associatedParts\n      }\n    };\n  } catch (error) {\n    console.error(\"Error in getServerSideProps:\", error);\n    return {\n      props: {\n        error: \"Failed to load machine data\"\n      }\n    };\n  }\n}","map":null,"metadata":{},"sourceType":"module"}