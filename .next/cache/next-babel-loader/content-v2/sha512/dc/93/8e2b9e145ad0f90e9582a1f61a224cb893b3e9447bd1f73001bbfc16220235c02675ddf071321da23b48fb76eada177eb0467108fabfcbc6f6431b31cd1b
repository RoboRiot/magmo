{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  try {\n    var _created$item;\n\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n    if (!token) return res.status(500).json({\n      ok: false,\n      error: \"missing_SLACK_BOT_TOKEN\"\n    }); // === Input from client ===\n\n    const {\n      listKey,\n      // \"shipping\" | \"receiving\" | \"tasks\"\n      title,\n      // item name (+ optional (ID))\n      pn,\n      sn,\n      // strings or arrays\n      workOrder,\n      // string\n      localSN,\n      // item ID\n      tracking,\n      // string (optional)\n      description,\n      // string\n      linkUrl,\n      // the app URL for the item\n      photoUrls = [] // array of https://firebasestorageâ€¦ URLs\n\n    } = req.body || {};\n    const dbg = {\n      steps: [],\n      photos: []\n    };\n\n    const step = (label, extra = {}) => dbg.steps.push(_objectSpread({\n      step: label,\n      t: new Date().toISOString()\n    }, extra)); // ---- helpers ----\n\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const first = v => Array.isArray(v) ? v[0] : v;\n\n    const joinArr = a => Array.isArray(a) ? a.map(plain).filter(Boolean).join(\", \") : plain(a);\n\n    const toRich = text => [{\n      type: \"rich_text\",\n      elements: [{\n        type: \"rich_text_section\",\n        elements: [{\n          type: \"text\",\n          text: plain(text)\n        }]\n      }]\n    }]; // Slack call helper\n\n\n    async function slack(method, body, label) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          \"Authorization\": `Bearer ${token}`,\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(body)\n      });\n      const json = await r.json().catch(() => ({}));\n      step(label, {\n        ok: !!(json !== null && json !== void 0 && json.ok),\n        error: json === null || json === void 0 ? void 0 : json.error,\n        status: r.status\n      });\n      return json;\n    } // Remote file add (best-effort; often fails on signed URLs)\n\n\n    async function remoteAdd(url, titleForFile, externalId) {\n      const payload = {\n        external_url: url,\n        title: titleForFile || \"Image\",\n        external_id: externalId || url.slice(-24)\n      };\n      return slack(\"files.remote.add\", payload, \"[FILES.REMOTE.ADD]\");\n    } // Preferred: modern upload flow (bytes -> Slack -> file_id)\n\n\n    async function uploadViaExternal(url, filename) {\n      // 1) Fetch bytes from Firebase URL\n      const resp = await fetch(url);\n      if (!resp.ok) return {\n        ok: false,\n        error: `fetch_${resp.status}`\n      };\n      const ab = await resp.arrayBuffer();\n      const buf = Buffer.from(ab);\n      const byteLen = buf.length; // 2) Reserve upload URL\n\n      const getUrl = await slack(\"files.getUploadURLExternal\", {\n        filename: filename || \"image.jpg\",\n        length: byteLen\n      }, \"[FILES.GETUPLOAD]\");\n      if (!(getUrl !== null && getUrl !== void 0 && getUrl.ok)) return {\n        ok: false,\n        error: (getUrl === null || getUrl === void 0 ? void 0 : getUrl.error) || \"get_upload_failed\"\n      };\n      const {\n        upload_url,\n        file_id\n      } = getUrl; // 3) POST the bytes (raw bytes POST is supported)\n\n      const up = await fetch(upload_url, {\n        method: \"POST\",\n        body: buf,\n        headers: {\n          \"Content-Type\": \"application/octet-stream\"\n        }\n      });\n      step(\"[FILES.UPLOAD.POST]\", {\n        ok: up.ok,\n        status: up.status\n      });\n      if (!up.ok) return {\n        ok: false,\n        error: `upload_post_${up.status}`\n      }; // 4) Complete\n\n      const complete = await slack(\"files.completeUploadExternal\", {\n        files: [{\n          id: file_id,\n          title: filename || \"image.jpg\"\n        }]\n      }, \"[FILES.COMPLETE]\");\n      if (!(complete !== null && complete !== void 0 && complete.ok)) return {\n        ok: false,\n        error: (complete === null || complete === void 0 ? void 0 : complete.error) || \"complete_failed\"\n      };\n      const created = Array.isArray(complete.files) ? complete.files[0] : null;\n      return {\n        ok: true,\n        file: {\n          id: (created === null || created === void 0 ? void 0 : created.id) || file_id\n        }\n      };\n    } // ---- per-list config (matches your .env names exactly) ----\n\n\n    const CFG = (key => {\n      if (key === \"tasks\") {\n        return {\n          list_id: process.env.SLACK_LIST_TASKS_ID,\n          title_col: process.env.SLACK_LIST_TASKS_TITLE_COL,\n          description_col: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL\n        };\n      }\n\n      if (key === \"shipping\") {\n        return {\n          list_id: process.env.SLACK_LIST_SHIPPING_ID,\n          title_col: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\n          description_col: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n          pnsn_col: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n          wo_col: process.env.SLACK_LIST_SHIPPING_WO_COL,\n          localsn_col: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n          tracking_col: process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n          photos_col: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL\n        };\n      }\n\n      if (key === \"receiving\") {\n        return {\n          list_id: process.env.SLACK_LIST_RECEIVING_ID,\n          title_col: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\n          description_col: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n          pnsn_col: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n          wo_col: process.env.SLACK_LIST_RECEIVING_WO_COL,\n          localsn_col: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n          tracking_col: process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n          photos_col: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL\n        };\n      }\n\n      return {};\n    })(listKey);\n\n    if (!(CFG !== null && CFG !== void 0 && CFG.list_id)) {\n      return res.status(400).json({\n        ok: false,\n        error: \"unknown_listKey\",\n        debug: {\n          listKey\n        }\n      });\n    } // ---- create list item w/ title ----\n\n\n    const safeTitle = plain(title) || \"Untitled item\";\n    const initialFields = {};\n    if (CFG.title_col) initialFields[CFG.title_col] = toRich(safeTitle); // include link to your app if you want it visible in the first column (optional)\n\n    if (CFG.title_col && linkUrl) {\n      initialFields[CFG.title_col] = [{\n        type: \"rich_text\",\n        elements: [{\n          type: \"rich_text_section\",\n          elements: [{\n            type: \"text\",\n            text: safeTitle + \"  \"\n          }, {\n            type: \"link\",\n            url: linkUrl,\n            text: \"(open)\"\n          }]\n        }]\n      }];\n    }\n\n    const created = await slack(\"slackLists.items.create\", {\n      list_id: CFG.list_id,\n      initial_fields: initialFields\n    }, \"[LISTS][CREATE-RICH]\");\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(200).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\",\n        debug: dbg\n      });\n    }\n\n    const rowId = created === null || created === void 0 ? void 0 : (_created$item = created.item) === null || _created$item === void 0 ? void 0 : _created$item.id;\n    step(\"[LISTS][CREATED]\", {\n      rowId\n    }); // ---- set PN/SN (rich text in one cell like \"PN: X  SN: Y\") ----\n\n    const pn0 = first(pn),\n          sn0 = first(sn);\n    const pnSnText = [pn0 ? `PN: ${pn0}` : \"\", sn0 ? `SN: ${sn0}` : \"\"].filter(Boolean).join(\"  \");\n\n    if (pnSnText && CFG.pnsn_col) {\n      const upd = await slack(\"slackLists.items.update\", {\n        list_id: CFG.list_id,\n        item_id: rowId,\n        fields: {\n          [CFG.pnsn_col]: toRich(pnSnText)\n        }\n      }, \"[LISTS][SET-RICH][PN/SN]\");\n    } // ---- set localSN (ID) ----\n\n\n    if (CFG.localsn_col && plain(localSN)) {\n      await slack(\"slackLists.items.update\", {\n        list_id: CFG.list_id,\n        item_id: rowId,\n        fields: {\n          [CFG.localsn_col]: toRich(localSN)\n        }\n      }, \"[LISTS][SET-RICH][LOCAL_SN]\");\n    } // ---- description ----\n\n\n    if (CFG.description_col && plain(description)) {\n      await slack(\"slackLists.items.update\", {\n        list_id: CFG.list_id,\n        item_id: rowId,\n        fields: {\n          [CFG.description_col]: toRich(description)\n        }\n      }, \"[LISTS][SET-RICH][DESCRIPTION]\");\n    } // ---- work order (as-is), tracking (as-is). Leave shipping date blank per your instruction. ----\n\n\n    if (CFG.wo_col && plain(workOrder)) {\n      await slack(\"slackLists.items.update\", {\n        list_id: CFG.list_id,\n        item_id: rowId,\n        fields: {\n          [CFG.wo_col]: toRich(workOrder)\n        }\n      }, \"[LISTS][SET-RICH][WO]\");\n    }\n\n    if (CFG.tracking_col && plain(tracking)) {\n      await slack(\"slackLists.items.update\", {\n        list_id: CFG.list_id,\n        item_id: rowId,\n        fields: {\n          [CFG.tracking_col]: toRich(tracking)\n        }\n      }, \"[LISTS][SET-RICH][TRACKING]\");\n    } // ---- photos â†’ upload to Slack â†’ collect file_ids â†’ write into file column ----\n\n\n    const photoIds = [];\n\n    for (let i = 0; i < Math.min(10, photoUrls.length); i++) {\n      var _remote$file, _up$file, _up$file2;\n\n      const url = plain(photoUrls[i]);\n      if (!/^https?:\\/\\//i.test(url)) continue; // try remote.add first (cheap), then hard-switch to external upload\n\n      const remote = await remoteAdd(url, `Photo ${i + 1}`, `firebase:${rowId}:${i}`);\n\n      if (remote !== null && remote !== void 0 && remote.ok && remote !== null && remote !== void 0 && (_remote$file = remote.file) !== null && _remote$file !== void 0 && _remote$file.id) {\n        photoIds.push(remote.file.id);\n        continue;\n      } // fallback to actual upload (works for signed Firebase URLs)\n\n\n      const fileName = `photo_${rowId}_${i + 1}.jpg`;\n      const up = await uploadViaExternal(url, fileName);\n      dbg.photos.push({\n        i,\n        urlDomain: new URL(url).hostname,\n        remote_ok: !!(remote !== null && remote !== void 0 && remote.ok),\n        remote_err: remote === null || remote === void 0 ? void 0 : remote.error,\n        upload_ok: !!(up !== null && up !== void 0 && up.ok),\n        upload_err: up === null || up === void 0 ? void 0 : up.error,\n        file_id: up === null || up === void 0 ? void 0 : (_up$file = up.file) === null || _up$file === void 0 ? void 0 : _up$file.id\n      });\n\n      if (up !== null && up !== void 0 && up.ok && up !== null && up !== void 0 && (_up$file2 = up.file) !== null && _up$file2 !== void 0 && _up$file2.id) {\n        photoIds.push(up.file.id);\n      }\n    }\n\n    if (CFG.photos_col && photoIds.length > 0) {\n      // Slackâ€™s Lists File column accepts these shapes. Weâ€™ll try a few just in case.\n      const fieldPayloads = [{\n        [CFG.photos_col]: {\n          file_ids: photoIds\n        }\n      }, {\n        [CFG.photos_col]: {\n          attachment: photoIds\n        }\n      }, {\n        [CFG.photos_col]: photoIds\n      } // some workspaces accept raw array\n      ];\n      let okSet = false,\n          lastErr;\n\n      for (const p of fieldPayloads) {\n        const r = await slack(\"slackLists.items.update\", {\n          list_id: CFG.list_id,\n          item_id: rowId,\n          fields: p\n        }, \"[LISTS][SET-FILES]\");\n\n        if (r !== null && r !== void 0 && r.ok) {\n          okSet = true;\n          break;\n        }\n\n        lastErr = r === null || r === void 0 ? void 0 : r.error;\n      }\n\n      if (!okSet) step(\"[PHOTOS][FAILED-ATTACH]\", {\n        error: lastErr,\n        ids_tried: photoIds\n      });\n    } else if (photoIds.length === 0) {\n      step(\"[PHOTOS][NO-IDS]\", {\n        reason: \"remote_add_failed_or_empty\"\n      });\n    }\n\n    return res.status(200).json({\n      ok: true,\n      mode: \"list\",\n      list_id: CFG.list_id,\n      item_id: rowId,\n      used_title_col: CFG.title_col,\n      used_description_col: CFG.description_col || null,\n      used_pnsn_col: CFG.pnsn_col || null,\n      used_wo_col: CFG.wo_col || null,\n      used_localsn_col: CFG.localsn_col || null,\n      used_tracking_col: CFG.tracking_col || null,\n      used_photos_col: CFG.photos_col || null,\n      debug: dbg\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn","sn","workOrder","localSN","tracking","description","linkUrl","photoUrls","body","dbg","steps","photos","step","label","extra","push","t","Date","toISOString","plain","v","toString","trim","first","Array","isArray","joinArr","a","map","filter","Boolean","join","toRich","text","type","elements","slack","r","fetch","headers","JSON","stringify","catch","remoteAdd","url","titleForFile","externalId","payload","external_url","external_id","slice","uploadViaExternal","filename","resp","ab","arrayBuffer","buf","Buffer","from","byteLen","length","getUrl","upload_url","file_id","up","complete","files","id","created","file","CFG","key","list_id","SLACK_LIST_TASKS_ID","title_col","SLACK_LIST_TASKS_TITLE_COL","description_col","SLACK_LIST_TASKS_DESCRIPTION_COL","SLACK_LIST_SHIPPING_ID","SLACK_LIST_SHIPPING_TITLE_COL","SLACK_LIST_SHIPPING_DESCRIPTION_COL","pnsn_col","SLACK_LIST_SHIPPING_PNSN_COL","wo_col","SLACK_LIST_SHIPPING_WO_COL","localsn_col","SLACK_LIST_SHIPPING_LOCALSN_COL","tracking_col","SLACK_LIST_SHIPPING_TRACKING_COL","photos_col","SLACK_LIST_SHIPPING_PHOTOS_COL","SLACK_LIST_RECEIVING_ID","SLACK_LIST_RECEIVING_TITLE_COL","SLACK_LIST_RECEIVING_DESCRIPTION_COL","SLACK_LIST_RECEIVING_PNSN_COL","SLACK_LIST_RECEIVING_WO_COL","SLACK_LIST_RECEIVING_LOCALSN_COL","SLACK_LIST_RECEIVING_TRACKING_COL","SLACK_LIST_RECEIVING_PHOTOS_COL","debug","safeTitle","initialFields","initial_fields","rowId","item","pn0","sn0","pnSnText","upd","item_id","fields","photoIds","i","Math","min","test","remote","fileName","urlDomain","URL","hostname","remote_ok","remote_err","upload_ok","upload_err","fieldPayloads","file_ids","attachment","okSet","lastErr","p","ids_tried","reason","mode","used_title_col","used_description_col","used_pnsn_col","used_wo_col","used_localsn_col","used_tracking_col","used_photos_col","err","console","message","String"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAI;AAAA;;AACF,QAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,aAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAArB,CAAP;AACD;;AAED,UAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;AACA,QAAI,CAACH,KAAL,EAAY,OAAON,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   try {\r\n//     if (req.method !== \"POST\") {\r\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//     }\r\n\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) {\r\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//     }\r\n\r\n//     // payload from client\r\n//     const {\r\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n//       title,               // item title (what shows in the primary column)\r\n//       // keeping minimal per your request: PN/SN only for now\r\n//       pn, sn,\r\n//     } = req.body || {};\r\n\r\n//     // list ids from env\r\n//     const LIST_IDS = {\r\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\r\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n//     };\r\n\r\n//     const list_id = LIST_IDS[listKey];\r\n//     if (!list_id) {\r\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n//     }\r\n\r\n//     // ---- Slack helpers ----\r\n//     async function slackJson(method, payload) {\r\n//       const r = await fetch(`https://slack.com/api/${method}`, {\r\n//         method: \"POST\",\r\n//         headers: {\r\n//           Authorization: `Bearer ${token}`,\r\n//           \"Content-Type\": \"application/json; charset=utf-8\",\r\n//         },\r\n//         body: JSON.stringify(payload),\r\n//       });\r\n//       return r.json();\r\n//     }\r\n\r\n//     const plain = (v) => (v ?? \"\").toString().trim();\r\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     function toRichText(text) {\r\n//       const t = plain(text);\r\n//       return [{\r\n//         type: \"rich_text\",\r\n//         elements: [{\r\n//           type: \"rich_text_section\",\r\n//           elements: [{ type: \"text\", text: t }],\r\n//         }],\r\n//       }];\r\n//     }\r\n\r\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n//     async function resolveTitleColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n//       let fallback = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\r\n//           if (f.column_id && hasText) {\r\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n//             if (!fallback) fallback = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return fallback; // first text-like field if we didn't find a perfect match\r\n//     }\r\n\r\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n//     async function resolvePnSnColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       let candidate = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           if (!f.column_id) continue;\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const text = (f.text || \"\").toLowerCase();\r\n\r\n//           const looksPnSn =\r\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\r\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n//           if (looksPnSn) return f.column_id;\r\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n//             candidate = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return candidate;\r\n//     }\r\n\r\n//     // 1) Resolve columns\r\n//     const titleColId = await resolveTitleColId(list_id);\r\n//     if (!titleColId) {\r\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n//     }\r\n\r\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n//     const safeTitle = plain(title) || \"New Item\";\r\n//     const createBody = {\r\n//       list_id,\r\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n//     };\r\n\r\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 3) (Minimal) update: PN/SN only, per your request\r\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n//     let updated = null;\r\n//     let usedPnSnCol = null;\r\n\r\n//     if (pnSnText) {\r\n//       const pnSnColId = await resolvePnSnColId(list_id);\r\n//       if (pnSnColId) {\r\n//         const cells = [{\r\n//           row_id: created.item.id,\r\n//           column_id: pnSnColId,\r\n//           rich_text: toRichText(pnSnText),\r\n//         }];\r\n\r\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n//         usedPnSnCol = pnSnColId;\r\n//         // If update fails, we still return ok:false so you can see the error\r\n//         if (!updated?.ok) {\r\n//           return res.status(200).json({\r\n//             ok: false,\r\n//             error: updated?.error || \"update_failed\",\r\n//             mode: \"list\",\r\n//             list_id,\r\n//             item_id: created.item.id,\r\n//             used_title_col: titleColId,\r\n//             used_pnsn_col: usedPnSnCol,\r\n//           });\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleColId,\r\n//       used_pnsn_col: usedPnSnCol || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n\r\n    // === Input from client ===\r\n    const {\r\n      listKey,                // \"shipping\" | \"receiving\" | \"tasks\"\r\n      title,                  // item name (+ optional (ID))\r\n      pn, sn,                 // strings or arrays\r\n      workOrder,              // string\r\n      localSN,                // item ID\r\n      tracking,               // string (optional)\r\n      description,            // string\r\n      linkUrl,                // the app URL for the item\r\n      photoUrls = [],         // array of https://firebasestorageâ€¦ URLs\r\n    } = req.body || {};\r\n\r\n    const dbg = { steps: [], photos: [] };\r\n    const step = (label, extra={}) => dbg.steps.push({ step: label, t: new Date().toISOString(), ...extra });\r\n\r\n    // ---- helpers ----\r\n    const plain = v => (v ?? \"\").toString().trim();\r\n    const first = v => Array.isArray(v) ? v[0] : v;\r\n    const joinArr = a => Array.isArray(a) ? a.map(plain).filter(Boolean).join(\", \") : plain(a);\r\n    const toRich = (text) => [{\r\n      type: \"rich_text\",\r\n      elements: [{\r\n        type: \"rich_text_section\",\r\n        elements: [{ type: \"text\", text: plain(text) }],\r\n      }],\r\n    }];\r\n\r\n    // Slack call helper\r\n    async function slack(method, body, label) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: { \"Authorization\": `Bearer ${token}`, \"Content-Type\": \"application/json\" },\r\n        body: JSON.stringify(body),\r\n      });\r\n      const json = await r.json().catch(() => ({}));\r\n      step(label, { ok: !!json?.ok, error: json?.error, status: r.status });\r\n      return json;\r\n    }\r\n\r\n    // Remote file add (best-effort; often fails on signed URLs)\r\n    async function remoteAdd(url, titleForFile, externalId) {\r\n      const payload = {\r\n        external_url: url,\r\n        title: titleForFile || \"Image\",\r\n        external_id: externalId || url.slice(-24),\r\n      };\r\n      return slack(\"files.remote.add\", payload, \"[FILES.REMOTE.ADD]\");\r\n    }\r\n\r\n    // Preferred: modern upload flow (bytes -> Slack -> file_id)\r\n    async function uploadViaExternal(url, filename) {\r\n      // 1) Fetch bytes from Firebase URL\r\n      const resp = await fetch(url);\r\n      if (!resp.ok) return { ok: false, error: `fetch_${resp.status}` };\r\n      const ab = await resp.arrayBuffer();\r\n      const buf = Buffer.from(ab);\r\n      const byteLen = buf.length;\r\n\r\n      // 2) Reserve upload URL\r\n      const getUrl = await slack(\"files.getUploadURLExternal\",\r\n        { filename: filename || \"image.jpg\", length: byteLen },\r\n        \"[FILES.GETUPLOAD]\");\r\n      if (!getUrl?.ok) return { ok: false, error: getUrl?.error || \"get_upload_failed\" };\r\n      const { upload_url, file_id } = getUrl;\r\n\r\n      // 3) POST the bytes (raw bytes POST is supported)\r\n      const up = await fetch(upload_url, { method: \"POST\", body: buf, headers: { \"Content-Type\": \"application/octet-stream\" } });\r\n      step(\"[FILES.UPLOAD.POST]\", { ok: up.ok, status: up.status });\r\n      if (!up.ok) return { ok: false, error: `upload_post_${up.status}` };\r\n\r\n      // 4) Complete\r\n      const complete = await slack(\"files.completeUploadExternal\",\r\n        { files: [{ id: file_id, title: filename || \"image.jpg\" }] },\r\n        \"[FILES.COMPLETE]\");\r\n      if (!complete?.ok) return { ok: false, error: complete?.error || \"complete_failed\" };\r\n\r\n      const created = Array.isArray(complete.files) ? complete.files[0] : null;\r\n      return { ok: true, file: { id: created?.id || file_id } };\r\n    }\r\n\r\n    // ---- per-list config (matches your .env names exactly) ----\r\n    const CFG = ((key) => {\r\n      if (key === \"tasks\") {\r\n        return {\r\n          list_id: process.env.SLACK_LIST_TASKS_ID,\r\n          title_col: process.env.SLACK_LIST_TASKS_TITLE_COL,\r\n          description_col: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\r\n        };\r\n      }\r\n      if (key === \"shipping\") {\r\n        return {\r\n          list_id: process.env.SLACK_LIST_SHIPPING_ID,\r\n          title_col: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\r\n          description_col: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n          pnsn_col: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n          wo_col: process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n          localsn_col: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n          tracking_col: process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n          photos_col: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,\r\n        };\r\n      }\r\n      if (key === \"receiving\") {\r\n        return {\r\n          list_id: process.env.SLACK_LIST_RECEIVING_ID,\r\n          title_col: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\r\n          description_col: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n          pnsn_col: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n          wo_col: process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n          localsn_col: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n          tracking_col: process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n          photos_col: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL,\r\n        };\r\n      }\r\n      return {};\r\n    })(listKey);\r\n\r\n    if (!CFG?.list_id) {\r\n      return res.status(400).json({ ok: false, error: \"unknown_listKey\", debug: { listKey } });\r\n    }\r\n\r\n    // ---- create list item w/ title ----\r\n    const safeTitle = plain(title) || \"Untitled item\";\r\n    const initialFields = {};\r\n    if (CFG.title_col) initialFields[CFG.title_col] = toRich(safeTitle);\r\n\r\n    // include link to your app if you want it visible in the first column (optional)\r\n    if (CFG.title_col && linkUrl) {\r\n      initialFields[CFG.title_col] = [{\r\n        type: \"rich_text\",\r\n        elements: [{\r\n          type: \"rich_text_section\",\r\n          elements: [\r\n            { type: \"text\", text: safeTitle + \"  \" },\r\n            { type: \"link\", url: linkUrl, text: \"(open)\" }\r\n          ]\r\n        }]\r\n      }];\r\n    }\r\n\r\n    const created = await slack(\"slackLists.items.create\", {\r\n      list_id: CFG.list_id,\r\n      initial_fields: initialFields\r\n    }, \"[LISTS][CREATE-RICH]\");\r\n\r\n    if (!created?.ok) {\r\n      return res.status(200).json({ ok: false, error: created?.error || \"create_failed\", debug: dbg });\r\n    }\r\n\r\n    const rowId = created?.item?.id;\r\n    step(\"[LISTS][CREATED]\", { rowId });\r\n\r\n    // ---- set PN/SN (rich text in one cell like \"PN: X  SN: Y\") ----\r\n    const pn0 = first(pn), sn0 = first(sn);\r\n    const pnSnText = [pn0 ? `PN: ${pn0}` : \"\", sn0 ? `SN: ${sn0}` : \"\"].filter(Boolean).join(\"  \");\r\n    if (pnSnText && CFG.pnsn_col) {\r\n      const upd = await slack(\"slackLists.items.update\", {\r\n        list_id: CFG.list_id,\r\n        item_id: rowId,\r\n        fields: { [CFG.pnsn_col]: toRich(pnSnText) }\r\n      }, \"[LISTS][SET-RICH][PN/SN]\");\r\n    }\r\n\r\n    // ---- set localSN (ID) ----\r\n    if (CFG.localsn_col && plain(localSN)) {\r\n      await slack(\"slackLists.items.update\", {\r\n        list_id: CFG.list_id,\r\n        item_id: rowId,\r\n        fields: { [CFG.localsn_col]: toRich(localSN) }\r\n      }, \"[LISTS][SET-RICH][LOCAL_SN]\");\r\n    }\r\n\r\n    // ---- description ----\r\n    if (CFG.description_col && plain(description)) {\r\n      await slack(\"slackLists.items.update\", {\r\n        list_id: CFG.list_id,\r\n        item_id: rowId,\r\n        fields: { [CFG.description_col]: toRich(description) }\r\n      }, \"[LISTS][SET-RICH][DESCRIPTION]\");\r\n    }\r\n\r\n    // ---- work order (as-is), tracking (as-is). Leave shipping date blank per your instruction. ----\r\n    if (CFG.wo_col && plain(workOrder)) {\r\n      await slack(\"slackLists.items.update\", {\r\n        list_id: CFG.list_id,\r\n        item_id: rowId,\r\n        fields: { [CFG.wo_col]: toRich(workOrder) }\r\n      }, \"[LISTS][SET-RICH][WO]\");\r\n    }\r\n\r\n    if (CFG.tracking_col && plain(tracking)) {\r\n      await slack(\"slackLists.items.update\", {\r\n        list_id: CFG.list_id,\r\n        item_id: rowId,\r\n        fields: { [CFG.tracking_col]: toRich(tracking) }\r\n      }, \"[LISTS][SET-RICH][TRACKING]\");\r\n    }\r\n\r\n    // ---- photos â†’ upload to Slack â†’ collect file_ids â†’ write into file column ----\r\n    const photoIds = [];\r\n    for (let i = 0; i < Math.min(10, photoUrls.length); i++) {\r\n      const url = plain(photoUrls[i]);\r\n      if (!/^https?:\\/\\//i.test(url)) continue;\r\n\r\n      // try remote.add first (cheap), then hard-switch to external upload\r\n      const remote = await remoteAdd(url, `Photo ${i+1}`, `firebase:${rowId}:${i}`);\r\n      if (remote?.ok && remote?.file?.id) {\r\n        photoIds.push(remote.file.id);\r\n        continue;\r\n      }\r\n\r\n      // fallback to actual upload (works for signed Firebase URLs)\r\n      const fileName = `photo_${rowId}_${i + 1}.jpg`;\r\n      const up = await uploadViaExternal(url, fileName);\r\n      dbg.photos.push({ i, urlDomain: new URL(url).hostname, remote_ok: !!remote?.ok, remote_err: remote?.error, upload_ok: !!up?.ok, upload_err: up?.error, file_id: up?.file?.id });\r\n      if (up?.ok && up?.file?.id) {\r\n        photoIds.push(up.file.id);\r\n      }\r\n    }\r\n\r\n    if (CFG.photos_col && photoIds.length > 0) {\r\n      // Slackâ€™s Lists File column accepts these shapes. Weâ€™ll try a few just in case.\r\n      const fieldPayloads = [\r\n        { [CFG.photos_col]: { file_ids: photoIds } },\r\n        { [CFG.photos_col]: { attachment: photoIds } },\r\n        { [CFG.photos_col]: photoIds }, // some workspaces accept raw array\r\n      ];\r\n\r\n      let okSet = false, lastErr;\r\n      for (const p of fieldPayloads) {\r\n        const r = await slack(\"slackLists.items.update\", {\r\n          list_id: CFG.list_id,\r\n          item_id: rowId,\r\n          fields: p\r\n        }, \"[LISTS][SET-FILES]\");\r\n        if (r?.ok) { okSet = true; break; }\r\n        lastErr = r?.error;\r\n      }\r\n\r\n      if (!okSet) step(\"[PHOTOS][FAILED-ATTACH]\", { error: lastErr, ids_tried: photoIds });\r\n    } else if (photoIds.length === 0) {\r\n      step(\"[PHOTOS][NO-IDS]\", { reason: \"remote_add_failed_or_empty\" });\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      mode: \"list\",\r\n      list_id: CFG.list_id,\r\n      item_id: rowId,\r\n      used_title_col: CFG.title_col,\r\n      used_description_col: CFG.description_col || null,\r\n      used_pnsn_col: CFG.pnsn_col || null,\r\n      used_wo_col: CFG.wo_col || null,\r\n      used_localsn_col: CFG.localsn_col || null,\r\n      used_tracking_col: CFG.tracking_col || null,\r\n      used_photos_col: CFG.photos_col || null,\r\n      debug: dbg,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}