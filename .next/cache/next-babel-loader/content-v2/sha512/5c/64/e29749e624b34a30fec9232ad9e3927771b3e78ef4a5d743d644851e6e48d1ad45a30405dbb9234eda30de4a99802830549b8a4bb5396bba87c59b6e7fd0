{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   if (req.method !== \"POST\") {\n//     return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//   }\n//   const token = process.env.SLACK_BOT_TOKEN;\n//   if (!token) {\n//     return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//   }\n//   // ---- Payload from client (your UI already sends these) ----\n//   const {\n//     listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\n//     title,              // the thing we want to show in the Task column\n//     linkUrl, bodyText,\n//     date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\n//     photoUrls = [],\n//   } = req.body || {};\n//   // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\n//   const LISTS = {\n//     tasks: {\n//       id: process.env.SLACK_LIST_TASKS_ID,\n//       // OPTIONAL: if you know the \"Task\" column id already\n//       titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\n//       cols: {\n//         desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\n//       },\n//     },\n//     shipping: {\n//       id: process.env.SLACK_LIST_SHIPPING_ID,\n//       titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\n//       cols: {\n//         desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\n//         date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\n//         pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\n//         track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\n//         wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\n//         lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\n//         photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\n//       },\n//     },\n//     receiving: {\n//       id: process.env.SLACK_LIST_RECEIVING_ID,\n//       titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\n//       cols: {\n//         desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\n//         date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\n//         pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\n//         track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\n//         wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\n//         lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\n//         photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\n//       },\n//     },\n//   };\n//   const cfg = LISTS[listKey];\n//   if (!cfg?.id) {\n//     return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\n//   }\n//   // ---- Slack helpers ----\n//   async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\n//     const r = await fetch(`https://slack.com/api/${method}`, {\n//       method: \"POST\",\n//       headers: { Authorization: `Bearer ${token}`, ...headers },\n//       body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\n//     });\n//     return r.json();\n//   }\n//   const plain = (v) => (v ?? \"\").toString().trim();\n//   const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//   // Never send an empty title\n//   const safeTitle =\n//     plain(title) ||\n//     (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\n//     joinArr(pn) ||\n//     \"New Item\";\n//   // Convert plain text to Slack rich_text for text columns\n//   function toRichText(text) {\n//     return [{\n//       type: \"rich_text\",\n//       elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\n//     }];\n//   }\n//   // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\n//   async function resolveTitleColumnId(listId, provided) {\n//     if (provided) return { colId: provided, source: \"env\" };\n//     const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//     if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\n//     let candidate = null;\n//     for (const item of probe.items || []) {\n//       for (const f of item.fields || []) {\n//         const key = (f.key || \"\").trim().toLowerCase();\n//         const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\n//         if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\n//         if (!candidate && f.column_id && hasText) candidate = f.column_id;\n//       }\n//     }\n//     return { colId: candidate, source: \"auto:first_text\" };\n//   }\n//   try {\n//     // 1) Find the column to write the Task name into; fall back to top-level title\n//     const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\n//     const createBody = {\n//       list_id: cfg.id,\n//       ...(titleCol.colId\n//         ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\n//         : { title: safeTitle }), // fallback if we couldn’t resolve a column\n//     };\n//     const created = await slack(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 2) (Optional) Patch other columns you actually have IDs for\n//     const fields = [];\n//     const cols = cfg.cols || {};\n//     const addText = (colId, text) => {\n//       const t = plain(text);\n//       if (colId && t) fields.push({ column_id: colId, value: { text: t } });\n//     };\n//     // Description / Notes column (for tasks we include your assembled bodyText)\n//     if (cols.desc) {\n//       const bits = [\n//         plain(description),\n//         listKey === \"tasks\" ? plain(bodyText) : \"\",\n//         plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\n//       ].filter(Boolean).join(\"\\n\");\n//       addText(cols.desc, bits);\n//     }\n//     // Dates and grouped PN/SN/DOM example\n//     if (cols.date && plain(date)) fields.push({ column_id: cols.date, value: { date: plain(date) } });\n//     if (cols.pn) {\n//       const pnStr = joinArr(pn), snStr = joinArr(sn);\n//       const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`]\n//         .filter(Boolean).join(\"  \");\n//       addText(cols.pn, combo);\n//     }\n//     if (cols.track) {\n//       const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`]\n//         .filter(Boolean).join(\"  \");\n//       addText(cols.track, t);\n//     }\n//     if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\n//     if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\n//     if (fields.length) {\n//       await slack(\"slackLists.items.update\", { list_id: cfg.id, item_id: created.item.id, fields });\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id: cfg.id,\n//       item_id: created.item.id,\n//       used_title_col: titleCol.colId || null,\n//       title_col_source: titleCol.source || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  if (req.method !== \"POST\") {\n    return res.status(405).json({\n      ok: false,\n      error: \"method_not_allowed\"\n    });\n  }\n\n  try {\n    const token = process.env.SLACK_BOT_TOKEN;\n\n    if (!token) {\n      return res.status(500).json({\n        ok: false,\n        error: \"missing_SLACK_BOT_TOKEN\"\n      });\n    }\n\n    const {\n      listKey,\n      // \"tasks\" | \"shipping\" | \"receiving\"\n      title,\n      linkUrl,\n      bodyText,\n      date,\n      pn,\n      sn,\n      dom,\n      trackingNumber,\n      poNumber,\n      workOrder,\n      localSN,\n      description,\n      photoUrls = []\n    } = req.body || {}; // ---- Lists configured via .env (ids optional for cols) ----\n\n    const LISTS = {\n      tasks: {\n        id: process.env.SLACK_LIST_TASKS_ID,\n        // If you already know the Task column id, put it here\n        titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\n        cols: {\n          desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null\n        }\n      },\n      shipping: {\n        id: process.env.SLACK_LIST_SHIPPING_ID,\n        titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\n        cols: {\n          desc: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\n          date: process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\n          pn: process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\n          track: process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\n          wo: process.env.SLACK_LIST_SHIPPING_WO_COL || null,\n          lsn: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\n          photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null\n        }\n      },\n      receiving: {\n        id: process.env.SLACK_LIST_RECEIVING_ID,\n        titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\n        cols: {\n          desc: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\n          date: process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\n          pn: process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\n          track: process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\n          wo: process.env.SLACK_LIST_RECEIVING_WO_COL || null,\n          lsn: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\n          photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null\n        }\n      }\n    };\n    const cfg = LISTS[listKey];\n\n    if (!(cfg !== null && cfg !== void 0 && cfg.id)) {\n      return res.status(400).json({\n        ok: false,\n        error: `unknown_or_unconfigured_listKey_${listKey}`\n      });\n    } // ---- Slack helpers ----\n\n\n    const headersJson = {\n      Authorization: `Bearer ${token}`,\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    };\n\n    async function slack(method, payload, headers = headersJson) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers,\n        body: typeof payload === \"string\" ? payload : JSON.stringify(payload)\n      });\n      return r.json();\n    }\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a); // Build a safe non-empty title\n\n\n    const safeTitle = plain(title) || (plain(localSN) ? `Item ${plain(localSN)}` : \"\") || joinArr(pn) || \"New Item\"; // Slack rich_text wrapper for text columns\n\n    function toRichText(text) {\n      return [{\n        type: \"rich_text\",\n        elements: [{\n          type: \"rich_text_section\",\n          elements: [{\n            type: \"text\",\n            text\n          }]\n        }]\n      }];\n    } // ----- Auto-discovery helpers -----\n    // Find any text-ish column to use as the \"title\" cell (Task/Item)\n\n\n    async function resolveNameColumnId(listId, provided) {\n      if (provided) return {\n        colId: provided,\n        source: \"env\"\n      };\n      const probe = await slack(\"slackLists.items.list\", {\n        list_id: listId,\n        limit: 50\n      });\n      if (!(probe !== null && probe !== void 0 && probe.ok)) return {\n        colId: null,\n        source: \"auto\",\n        error: (probe === null || probe === void 0 ? void 0 : probe.error) || \"items.list_failed\"\n      };\n      let candidate = null;\n\n      for (const item of probe.items || []) {\n        for (const f of item.fields || []) {\n          const key = (f.key || \"\").trim().toLowerCase();\n          const hasText = Boolean(f.text) || Array.isArray(f.rich_text); // try to match common “title-like” keys for each list\n\n          const wanted = listKey === \"tasks\" ? [\"task\", \"title\", \"name\", \"item\"] : [\"item\", \"title\", \"name\", \"task\"];\n\n          if (wanted.includes(key) && f.column_id && hasText) {\n            return {\n              colId: f.column_id,\n              source: `auto:key_${key}`\n            };\n          }\n\n          if (!candidate && f.column_id && hasText) candidate = f.column_id;\n        }\n      }\n\n      return {\n        colId: candidate,\n        source: \"auto:first_text\"\n      };\n    } // Try to find a column by approximate key name (for PN/SN, date, etc.)\n\n\n    async function resolveColumnByGuess(listId, guessKeys = []) {\n      const probe = await slack(\"slackLists.items.list\", {\n        list_id: listId,\n        limit: 50\n      });\n      if (!(probe !== null && probe !== void 0 && probe.ok)) return null;\n      const keys = guessKeys.map(k => k.toLowerCase());\n\n      for (const item of probe.items || []) {\n        for (const f of item.fields || []) {\n          const key = (f.key || \"\").trim().toLowerCase();\n          if (!key || !f.column_id) continue;\n          if (keys.includes(key)) return f.column_id; // loose contains match (e.g., \"pn/sn\" vs \"pn & sn\")\n\n          if (keys.some(k => key.includes(k))) return f.column_id;\n        }\n      }\n\n      return null;\n    } // 1) pick a title column (or fall back to top-level title)\n\n\n    const titleCol = await resolveNameColumnId(cfg.id, cfg.titleColId);\n\n    const createBody = _objectSpread({\n      list_id: cfg.id\n    }, titleCol.colId ? {\n      initial_fields: [{\n        column_id: titleCol.colId,\n        rich_text: toRichText(safeTitle)\n      }]\n    } : {\n      title: safeTitle\n    });\n\n    const created = await slack(\"slackLists.items.create\", createBody);\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(200).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\",\n        mode: \"list\",\n        sent: createBody\n      });\n    } // 2) Prepare to patch additional columns\n\n\n    const fields = [];\n\n    const cols = _objectSpread({}, cfg.cols || {}); // If env is missing pn/sn col, try to auto-resolve it\n\n\n    if (!cols.pn) {\n      cols.pn = await resolveColumnByGuess(cfg.id, [\"pn/sn\", \"pn & sn\", \"pnsn\", \"part\", \"pn\", \"sn\", \"details\"]);\n    } // If env is missing description col, try to auto-resolve it\n\n\n    if (!cols.desc) {\n      cols.desc = await resolveColumnByGuess(cfg.id, [\"description\", \"notes\", \"details\", \"info\"]);\n    } // If env is missing date col, try a guess (for shipping/receiving)\n\n\n    if (!cols.date) {\n      cols.date = await resolveColumnByGuess(cfg.id, [\"date\", \"ship date\", \"arrival date\", \"shipping date\", \"received date\"]);\n    } // Helper to add a text field safely\n\n\n    const addText = (colId, text) => {\n      const t = plain(text);\n      if (colId && t) fields.push({\n        column_id: colId,\n        value: {\n          text: t\n        }\n      });\n    }; // Description: also doubles as fallback bucket for PN/SN so nothing is blank\n\n\n    if (cols.desc && (description || listKey === \"tasks\" && bodyText || linkUrl)) {\n      const bits = [plain(description), listKey === \"tasks\" ? plain(bodyText) : \"\", plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\"].filter(Boolean).join(\"\\n\");\n      addText(cols.desc, bits);\n    } // Date (YYYY-MM-DD)\n\n\n    if (cols.date && plain(date)) {\n      fields.push({\n        column_id: cols.date,\n        value: {\n          date: plain(date)\n        }\n      });\n    } // PN/SN/DOM – primary goal for you right now\n\n\n    const pnStr = joinArr(pn);\n    const snStr = joinArr(sn);\n    const domStr = plain(dom);\n    const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, domStr && `DOM: ${domStr}`].filter(Boolean).join(\"  \");\n\n    if (combo) {\n      if (cols.pn) {\n        addText(cols.pn, combo);\n      } else if (cols.desc) {\n        // no pn column found – stuff PN/SN into Description so it shows up\n        addText(cols.desc, combo);\n      }\n    } // Optional other fields if you keep them configured\n\n\n    if (cols.track) {\n      const track = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`].filter(Boolean).join(\"  \");\n      addText(cols.track, track);\n    }\n\n    if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\n    if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\n\n    if (fields.length) {\n      await slack(\"slackLists.items.update\", {\n        list_id: cfg.id,\n        item_id: created.item.id,\n        fields\n      });\n    }\n\n    return res.status(200).json({\n      ok: true,\n      mode: \"list\",\n      list_id: cfg.id,\n      item_id: created.item.id,\n      used_title_col: titleCol.colId || null,\n      title_col_source: titleCol.source || null,\n      sent_title: safeTitle\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","linkUrl","bodyText","date","pn","sn","dom","trackingNumber","poNumber","workOrder","localSN","description","photoUrls","body","LISTS","tasks","id","SLACK_LIST_TASKS_ID","titleColId","SLACK_LIST_TASKS_TITLE_COL","cols","desc","SLACK_LIST_TASKS_DESCRIPTION_COL","shipping","SLACK_LIST_SHIPPING_ID","SLACK_LIST_SHIPPING_TITLE_COL","SLACK_LIST_SHIPPING_DESCRIPTION_COL","SLACK_LIST_SHIPPING_DATE_COL","SLACK_LIST_SHIPPING_PNSN_COL","track","SLACK_LIST_SHIPPING_TRACKING_COL","wo","SLACK_LIST_SHIPPING_WO_COL","lsn","SLACK_LIST_SHIPPING_LOCALSN_COL","photos","SLACK_LIST_SHIPPING_PHOTOS_COL","receiving","SLACK_LIST_RECEIVING_ID","SLACK_LIST_RECEIVING_TITLE_COL","SLACK_LIST_RECEIVING_DESCRIPTION_COL","SLACK_LIST_RECEIVING_DATE_COL","SLACK_LIST_RECEIVING_PNSN_COL","SLACK_LIST_RECEIVING_TRACKING_COL","SLACK_LIST_RECEIVING_WO_COL","SLACK_LIST_RECEIVING_LOCALSN_COL","SLACK_LIST_RECEIVING_PHOTOS_COL","cfg","headersJson","Authorization","slack","payload","headers","r","fetch","JSON","stringify","plain","v","toString","trim","joinArr","a","Array","isArray","filter","Boolean","map","join","safeTitle","toRichText","text","type","elements","resolveNameColumnId","listId","provided","colId","source","probe","list_id","limit","candidate","item","items","f","fields","key","toLowerCase","hasText","rich_text","wanted","includes","column_id","resolveColumnByGuess","guessKeys","keys","k","some","titleCol","createBody","initial_fields","created","mode","sent","addText","t","push","value","bits","pnStr","snStr","domStr","combo","length","item_id","used_title_col","title_col_source","sent_title","err","console","message","String"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,WAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE;AAApB,KAArB,CAAP;AACD;;AAED,MAAI;AACF,UAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;;AACA,QAAI,CAACH,KAAL,EAAY;AACV,aAAON,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   if (req.method !== \"POST\") {\r\n//     return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//   }\r\n\r\n//   const token = process.env.SLACK_BOT_TOKEN;\r\n//   if (!token) {\r\n//     return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//   }\r\n\r\n//   // ---- Payload from client (your UI already sends these) ----\r\n//   const {\r\n//     listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\r\n//     title,              // the thing we want to show in the Task column\r\n//     linkUrl, bodyText,\r\n//     date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n//     photoUrls = [],\r\n//   } = req.body || {};\r\n\r\n//   // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\r\n//   const LISTS = {\r\n//     tasks: {\r\n//       id: process.env.SLACK_LIST_TASKS_ID,\r\n//       // OPTIONAL: if you know the \"Task\" column id already\r\n//       titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\r\n//       cols: {\r\n//         desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\r\n//       },\r\n//     },\r\n//     shipping: {\r\n//       id: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\r\n//       cols: {\r\n//         desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\r\n//         date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\r\n//         pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\r\n//         track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\r\n//         wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\r\n//         lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\r\n//         photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\r\n//       },\r\n//     },\r\n//     receiving: {\r\n//       id: process.env.SLACK_LIST_RECEIVING_ID,\r\n//       titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\r\n//       cols: {\r\n//         desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\r\n//         date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\r\n//         pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\r\n//         track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\r\n//         wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\r\n//         lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\r\n//         photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\r\n//       },\r\n//     },\r\n//   };\r\n\r\n//   const cfg = LISTS[listKey];\r\n//   if (!cfg?.id) {\r\n//     return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\r\n//   }\r\n\r\n//   // ---- Slack helpers ----\r\n//   async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\r\n//     const r = await fetch(`https://slack.com/api/${method}`, {\r\n//       method: \"POST\",\r\n//       headers: { Authorization: `Bearer ${token}`, ...headers },\r\n//       body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\r\n//     });\r\n//     return r.json();\r\n//   }\r\n\r\n//   const plain = (v) => (v ?? \"\").toString().trim();\r\n//   const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//   // Never send an empty title\r\n//   const safeTitle =\r\n//     plain(title) ||\r\n//     (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\r\n//     joinArr(pn) ||\r\n//     \"New Item\";\r\n\r\n//   // Convert plain text to Slack rich_text for text columns\r\n//   function toRichText(text) {\r\n//     return [{\r\n//       type: \"rich_text\",\r\n//       elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\r\n//     }];\r\n//   }\r\n\r\n//   // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\r\n//   async function resolveTitleColumnId(listId, provided) {\r\n//     if (provided) return { colId: provided, source: \"env\" };\r\n\r\n//     const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//     if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\r\n\r\n//     let candidate = null;\r\n//     for (const item of probe.items || []) {\r\n//       for (const f of item.fields || []) {\r\n//         const key = (f.key || \"\").trim().toLowerCase();\r\n//         const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\r\n//         if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\r\n//         if (!candidate && f.column_id && hasText) candidate = f.column_id;\r\n//       }\r\n//     }\r\n//     return { colId: candidate, source: \"auto:first_text\" };\r\n//   }\r\n\r\n//   try {\r\n//     // 1) Find the column to write the Task name into; fall back to top-level title\r\n//     const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\r\n\r\n//     const createBody = {\r\n//       list_id: cfg.id,\r\n//       ...(titleCol.colId\r\n//         ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\r\n//         : { title: safeTitle }), // fallback if we couldn’t resolve a column\r\n//     };\r\n\r\n//     const created = await slack(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 2) (Optional) Patch other columns you actually have IDs for\r\n//     const fields = [];\r\n//     const cols = cfg.cols || {};\r\n//     const addText = (colId, text) => {\r\n//       const t = plain(text);\r\n//       if (colId && t) fields.push({ column_id: colId, value: { text: t } });\r\n//     };\r\n\r\n//     // Description / Notes column (for tasks we include your assembled bodyText)\r\n//     if (cols.desc) {\r\n//       const bits = [\r\n//         plain(description),\r\n//         listKey === \"tasks\" ? plain(bodyText) : \"\",\r\n//         plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\r\n//       ].filter(Boolean).join(\"\\n\");\r\n//       addText(cols.desc, bits);\r\n//     }\r\n\r\n//     // Dates and grouped PN/SN/DOM example\r\n//     if (cols.date && plain(date)) fields.push({ column_id: cols.date, value: { date: plain(date) } });\r\n//     if (cols.pn) {\r\n//       const pnStr = joinArr(pn), snStr = joinArr(sn);\r\n//       const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`]\r\n//         .filter(Boolean).join(\"  \");\r\n//       addText(cols.pn, combo);\r\n//     }\r\n//     if (cols.track) {\r\n//       const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`]\r\n//         .filter(Boolean).join(\"  \");\r\n//       addText(cols.track, t);\r\n//     }\r\n//     if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\r\n//     if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\r\n\r\n//     if (fields.length) {\r\n//       await slack(\"slackLists.items.update\", { list_id: cfg.id, item_id: created.item.id, fields });\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id: cfg.id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleCol.colId || null,\r\n//       title_col_source: titleCol.source || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  if (req.method !== \"POST\") {\r\n    return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n  }\r\n\r\n  try {\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) {\r\n      return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n    }\r\n\r\n    const {\r\n      listKey, // \"tasks\" | \"shipping\" | \"receiving\"\r\n      title, linkUrl, bodyText,\r\n      date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n      photoUrls = [],\r\n    } = req.body || {};\r\n\r\n    // ---- Lists configured via .env (ids optional for cols) ----\r\n    const LISTS = {\r\n      tasks: {\r\n        id: process.env.SLACK_LIST_TASKS_ID,\r\n        // If you already know the Task column id, put it here\r\n        titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\r\n        cols: {\r\n          desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\r\n        },\r\n      },\r\n      shipping: {\r\n        id: process.env.SLACK_LIST_SHIPPING_ID,\r\n        titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\r\n        cols: {\r\n          desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\r\n          date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\r\n          pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\r\n          track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\r\n          wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\r\n          lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\r\n          photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\r\n        },\r\n      },\r\n      receiving: {\r\n        id: process.env.SLACK_LIST_RECEIVING_ID,\r\n        titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\r\n        cols: {\r\n          desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\r\n          date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\r\n          pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\r\n          track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\r\n          wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\r\n          lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\r\n          photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\r\n        },\r\n      },\r\n    };\r\n\r\n    const cfg = LISTS[listKey];\r\n    if (!cfg?.id) {\r\n      return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\r\n    }\r\n\r\n    // ---- Slack helpers ----\r\n    const headersJson = {\r\n      Authorization: `Bearer ${token}`,\r\n      \"Content-Type\": \"application/json; charset=utf-8\",\r\n    };\r\n    async function slack(method, payload, headers = headersJson) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers,\r\n        body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\r\n      });\r\n      return r.json();\r\n    }\r\n\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n    const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n    // Build a safe non-empty title\r\n    const safeTitle =\r\n      plain(title) ||\r\n      (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\r\n      joinArr(pn) ||\r\n      \"New Item\";\r\n\r\n    // Slack rich_text wrapper for text columns\r\n    function toRichText(text) {\r\n      return [{\r\n        type: \"rich_text\",\r\n        elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\r\n      }];\r\n    }\r\n\r\n    // ----- Auto-discovery helpers -----\r\n\r\n    // Find any text-ish column to use as the \"title\" cell (Task/Item)\r\n    async function resolveNameColumnId(listId, provided) {\r\n      if (provided) return { colId: provided, source: \"env\" };\r\n\r\n      const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n      if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\r\n\r\n      let candidate = null;\r\n      for (const item of probe.items || []) {\r\n        for (const f of item.fields || []) {\r\n          const key = (f.key || \"\").trim().toLowerCase();\r\n          const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\r\n          // try to match common “title-like” keys for each list\r\n          const wanted = (listKey === \"tasks\")\r\n            ? [\"task\", \"title\", \"name\", \"item\"]\r\n            : [\"item\", \"title\", \"name\", \"task\"];\r\n\r\n          if (wanted.includes(key) && f.column_id && hasText) {\r\n            return { colId: f.column_id, source: `auto:key_${key}` };\r\n          }\r\n          if (!candidate && f.column_id && hasText) candidate = f.column_id;\r\n        }\r\n      }\r\n      return { colId: candidate, source: \"auto:first_text\" };\r\n    }\r\n\r\n    // Try to find a column by approximate key name (for PN/SN, date, etc.)\r\n    async function resolveColumnByGuess(listId, guessKeys = []) {\r\n      const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n      if (!probe?.ok) return null;\r\n      const keys = guessKeys.map(k => k.toLowerCase());\r\n\r\n      for (const item of probe.items || []) {\r\n        for (const f of item.fields || []) {\r\n          const key = (f.key || \"\").trim().toLowerCase();\r\n          if (!key || !f.column_id) continue;\r\n          if (keys.includes(key)) return f.column_id;\r\n          // loose contains match (e.g., \"pn/sn\" vs \"pn & sn\")\r\n          if (keys.some(k => key.includes(k))) return f.column_id;\r\n        }\r\n      }\r\n      return null;\r\n    }\r\n\r\n    // 1) pick a title column (or fall back to top-level title)\r\n    const titleCol = await resolveNameColumnId(cfg.id, cfg.titleColId);\r\n\r\n    const createBody = {\r\n      list_id: cfg.id,\r\n      ...(titleCol.colId\r\n        ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\r\n        : { title: safeTitle }),\r\n    };\r\n\r\n    const created = await slack(\"slackLists.items.create\", createBody);\r\n    if (!created?.ok) {\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: created?.error || \"create_failed\",\r\n        mode: \"list\",\r\n        sent: createBody,\r\n      });\r\n    }\r\n\r\n    // 2) Prepare to patch additional columns\r\n    const fields = [];\r\n    const cols = { ...(cfg.cols || {}) };\r\n\r\n    // If env is missing pn/sn col, try to auto-resolve it\r\n    if (!cols.pn) {\r\n      cols.pn = await resolveColumnByGuess(cfg.id, [\r\n        \"pn/sn\", \"pn & sn\", \"pnsn\", \"part\", \"pn\", \"sn\", \"details\"\r\n      ]);\r\n    }\r\n\r\n    // If env is missing description col, try to auto-resolve it\r\n    if (!cols.desc) {\r\n      cols.desc = await resolveColumnByGuess(cfg.id, [\r\n        \"description\", \"notes\", \"details\", \"info\"\r\n      ]);\r\n    }\r\n\r\n    // If env is missing date col, try a guess (for shipping/receiving)\r\n    if (!cols.date) {\r\n      cols.date = await resolveColumnByGuess(cfg.id, [\r\n        \"date\", \"ship date\", \"arrival date\", \"shipping date\", \"received date\"\r\n      ]);\r\n    }\r\n\r\n    // Helper to add a text field safely\r\n    const addText = (colId, text) => {\r\n      const t = plain(text);\r\n      if (colId && t) fields.push({ column_id: colId, value: { text: t } });\r\n    };\r\n\r\n    // Description: also doubles as fallback bucket for PN/SN so nothing is blank\r\n    if (cols.desc && (description || (listKey === \"tasks\" && bodyText) || linkUrl)) {\r\n      const bits = [\r\n        plain(description),\r\n        listKey === \"tasks\" ? plain(bodyText) : \"\",\r\n        plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\r\n      ].filter(Boolean).join(\"\\n\");\r\n      addText(cols.desc, bits);\r\n    }\r\n\r\n    // Date (YYYY-MM-DD)\r\n    if (cols.date && plain(date)) {\r\n      fields.push({ column_id: cols.date, value: { date: plain(date) } });\r\n    }\r\n\r\n    // PN/SN/DOM – primary goal for you right now\r\n    const pnStr = joinArr(pn);\r\n    const snStr = joinArr(sn);\r\n    const domStr = plain(dom);\r\n    const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, domStr && `DOM: ${domStr}`]\r\n      .filter(Boolean).join(\"  \");\r\n\r\n    if (combo) {\r\n      if (cols.pn) {\r\n        addText(cols.pn, combo);\r\n      } else if (cols.desc) {\r\n        // no pn column found – stuff PN/SN into Description so it shows up\r\n        addText(cols.desc, combo);\r\n      }\r\n    }\r\n\r\n    // Optional other fields if you keep them configured\r\n    if (cols.track) {\r\n      const track = [\r\n        plain(trackingNumber) && `RL: ${plain(trackingNumber)}`,\r\n        plain(poNumber) && `PO: ${plain(poNumber)}`\r\n      ].filter(Boolean).join(\"  \");\r\n      addText(cols.track, track);\r\n    }\r\n    if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\r\n    if (cols.lsn && plain(localSN))  addText(cols.lsn, plain(localSN));\r\n\r\n    if (fields.length) {\r\n      await slack(\"slackLists.items.update\", {\r\n        list_id: cfg.id,\r\n        item_id: created.item.id,\r\n        fields,\r\n      });\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      mode: \"list\",\r\n      list_id: cfg.id,\r\n      item_id: created.item.id,\r\n      used_title_col: titleCol.colId || null,\r\n      title_col_source: titleCol.source || null,\r\n      sent_title: safeTitle,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}