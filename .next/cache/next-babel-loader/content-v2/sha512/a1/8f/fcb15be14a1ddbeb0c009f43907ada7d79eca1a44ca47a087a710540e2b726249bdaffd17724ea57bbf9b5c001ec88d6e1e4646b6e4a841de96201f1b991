{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  try {\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n\n    if (!token) {\n      return res.status(500).json({\n        ok: false,\n        error: \"missing_SLACK_BOT_TOKEN\"\n      });\n    } // ---- Payload from client (keep your working shape; just add the extras) ----\n\n\n    const {\n      listKey,\n      // \"shipping\" | \"receiving\" | \"tasks\"\n      title,\n      // primary title text\n      pn,\n      sn,\n      // PN/SN\n      linkUrl,\n      // optional - page link\n      // auto-detected columns will be filled with these if present:\n      shippingDate,\n      // Shipping Date (you can pass items.arrival_date || items.date)\n      tracking,\n      // Tracking / WDIM\n      workOrder,\n      // WO/SO (send most recent)\n      localSN,\n      // Local SN (send item id)\n      description,\n      // free text\n      parties,\n      // KEEP as-is from your working flow if you already send it\n      photoUrls = [] // optional – if you want to dump links\n\n    } = req.body || {};\n    const LIST_IDS = {\n      tasks: process.env.SLACK_LIST_TASKS_ID,\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\n      receiving: process.env.SLACK_LIST_RECEIVING_ID\n    };\n    const list_id = LIST_IDS[listKey];\n\n    if (!list_id) {\n      return res.status(400).json({\n        ok: false,\n        error: `unknown_listKey_${listKey}`\n      });\n    } // ---- Slack helpers ----\n\n\n    async function slackJson(method, payload) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(payload)\n      });\n      return r.json();\n    }\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const toRichText = text => {\n      const t = plain(text);\n      return [{\n        type: \"rich_text\",\n        elements: [{\n          type: \"rich_text_section\",\n          elements: [{\n            type: \"text\",\n            text: t\n          }]\n        }]\n      }];\n    }; // ---- Column auto-discovery by scanning list items ----\n\n\n    async function listProbe(listId) {\n      const probe = await slackJson(\"slackLists.items.list\", {\n        list_id: listId,\n        limit: 200\n      });\n      return probe !== null && probe !== void 0 && probe.ok ? probe : null;\n    }\n\n    async function resolveTitleColId(listId) {\n      const probe = await listProbe(listId);\n      if (!probe) return null;\n      let fallback = null;\n\n      for (const it of probe.items || []) {\n        for (const f of it.fields || []) {\n          const key = (f.key || \"\").toLowerCase();\n          const hasText = !!f.text || Array.isArray(f.rich_text);\n\n          if (f.column_id && hasText) {\n            if (key.includes(\"item\") || key.includes(\"task\") || key.includes(\"name\")) {\n              return f.column_id;\n            }\n\n            if (!fallback) fallback = f.column_id;\n          }\n        }\n      }\n\n      return fallback;\n    }\n\n    async function resolveByKeywords(listId, keywords = [], loose = []) {\n      const probe = await listProbe(listId);\n      if (!probe) return null;\n      let candidate = null;\n      const kw = (keywords || []).map(k => k.toLowerCase());\n      const looseKw = (loose || []).map(k => k.toLowerCase());\n\n      for (const it of probe.items || []) {\n        for (const f of it.fields || []) {\n          if (!f.column_id) continue;\n          const key = (f.key || \"\").toLowerCase();\n          const text = (f.text || \"\").toLowerCase();\n          const hit = kw.some(k => key.includes(k) || text.includes(k));\n          if (hit) return f.column_id;\n\n          if (!candidate) {\n            const maybe = looseKw.some(k => key.includes(k) || text.includes(k));\n            if (maybe) candidate = f.column_id;\n          }\n        }\n      }\n\n      return candidate;\n    }\n\n    const titleColId = await resolveTitleColId(list_id);\n\n    if (!titleColId) {\n      return res.status(400).json({\n        ok: false,\n        error: \"could_not_resolve_title_column\"\n      });\n    } // ---- 1) Create the row with the title as rich_text (your working behavior) ----\n\n\n    const safeTitle = plain(title) || \"New Item\";\n    const created = await slackJson(\"slackLists.items.create\", {\n      list_id,\n      initial_fields: [{\n        column_id: titleColId,\n        rich_text: toRichText(safeTitle)\n      }]\n    });\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(200).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\"\n      });\n    } // ---- 2) Resolve other target columns by keywords ----\n\n\n    const pnSnColId = await resolveByKeywords(list_id, [\"pn\", \"sn\", \"part number\", \"serial\"], [\"pn:\", \"sn:\"]);\n    const shipDateColId = await resolveByKeywords(list_id, [\"shipping date\", \"ship date\"], [\"date\"]);\n    const trackingColId = await resolveByKeywords(list_id, [\"tracking\", \"wdim\"], [\"tracking number\", \"tn\", \"wdim\"]);\n    const woColId = await resolveByKeywords(list_id, [\"wo/so\", \"work order\", \"sales order\"], [\"wo\", \"so\"]);\n    const localSnColId = await resolveByKeywords(list_id, [\"local sn\", \"localsn\", \"ais\"], [\"local\", \"sn\"]);\n    const descriptionColId = await resolveByKeywords(list_id, [\"description\", \"notes\"], [\"desc\", \"note\"]);\n    const linkColId = await resolveByKeywords(list_id, [\"link\", \"url\", \"page\"], []);\n    const photosColId = await resolveByKeywords(list_id, [\"shipping photos\", \"photos\", \"images\", \"pics\"], [\"photo\", \"image\", \"pic\"]); // If you have a Parties column and already send Parties in your working code,\n    // we leave that path untouched on purpose.\n    // ---- 3) Build cells to update (rich_text first, fallback to text on failure) ----\n\n    const pn0 = Array.isArray(pn) ? pn[0] : pn;\n    const sn0 = Array.isArray(sn) ? sn[0] : sn;\n    const pnSnText = [plain(pn0) ? `PN: ${plain(pn0)}` : \"\", plain(sn0) ? `SN: ${plain(sn0)}` : \"\"].filter(Boolean).join(\"  \");\n    const cells = [];\n\n    if (pnSnText && pnSnColId) {\n      cells.push({\n        row_id: created.item.id,\n        column_id: pnSnColId,\n        rich_text: toRichText(pnSnText)\n      });\n    }\n\n    if (shipDateColId && plain(shippingDate)) {\n      cells.push({\n        row_id: created.item.id,\n        column_id: shipDateColId,\n        rich_text: toRichText(shippingDate)\n      });\n    }\n\n    if (trackingColId && plain(tracking)) {\n      cells.push({\n        row_id: created.item.id,\n        column_id: trackingColId,\n        rich_text: toRichText(tracking)\n      });\n    }\n\n    if (woColId && plain(workOrder)) {\n      cells.push({\n        row_id: created.item.id,\n        column_id: woColId,\n        rich_text: toRichText(workOrder)\n      });\n    }\n\n    if (localSnColId && plain(localSN)) {\n      cells.push({\n        row_id: created.item.id,\n        column_id: localSnColId,\n        rich_text: toRichText(localSN)\n      });\n    }\n\n    if (descriptionColId && plain(description)) {\n      cells.push({\n        row_id: created.item.id,\n        column_id: descriptionColId,\n        rich_text: toRichText(description)\n      });\n    }\n\n    if (linkColId && plain(linkUrl)) {\n      cells.push({\n        row_id: created.item.id,\n        column_id: linkColId,\n        rich_text: toRichText(linkUrl)\n      });\n    }\n\n    if (photosColId && photoUrls.length) {\n      const asList = photoUrls.map((u, i) => `${i + 1}. ${u}`).join(\"\\n\");\n      cells.push({\n        row_id: created.item.id,\n        column_id: photosColId,\n        rich_text: toRichText(asList)\n      });\n    }\n\n    async function tryCellsUpdate(cellsBatch) {\n      if (!cellsBatch.length) return {\n        ok: true\n      }; // Try rich_text first\n\n      let r = await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells: cellsBatch\n      });\n      if (r !== null && r !== void 0 && r.ok) return r; // Retry with `text` for the same cells\n\n      const asText = cellsBatch.map(c => ({\n        row_id: c.row_id,\n        column_id: c.column_id,\n        text: c.rich_text && c.rich_text[0] && c.rich_text[0].elements && c.rich_text[0].elements[0] && c.rich_text[0].elements[0].elements && c.rich_text[0].elements[0].elements[0] && c.rich_text[0].elements[0].elements[0].text || \"\"\n      }));\n      return await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells: asText\n      });\n    }\n\n    const updated = await tryCellsUpdate(cells);\n\n    if (!(updated !== null && updated !== void 0 && updated.ok)) {\n      // As a last resort, if PN/SN failed and we at least have a title column, append PN/SN to title\n      if (pnSnText) {\n        await slackJson(\"slackLists.items.update\", {\n          list_id,\n          cells: [{\n            row_id: created.item.id,\n            column_id: titleColId,\n            text: `${safeTitle} — ${pnSnText}`\n          }]\n        });\n      }\n\n      return res.status(200).json({\n        ok: false,\n        error: (updated === null || updated === void 0 ? void 0 : updated.error) || \"update_failed\",\n        list_id,\n        item_id: created.item.id,\n        used_title_col: titleColId\n      });\n    }\n\n    return res.status(200).json({\n      ok: true,\n      list_id,\n      item_id: created.item.id,\n      used_title_col: titleColId,\n      auto_cols: {\n        pnSnColId,\n        shipDateColId,\n        trackingColId,\n        woColId,\n        localSnColId,\n        descriptionColId,\n        linkColId,\n        photosColId\n      }\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn","sn","linkUrl","shippingDate","tracking","workOrder","localSN","description","parties","photoUrls","body","LIST_IDS","tasks","SLACK_LIST_TASKS_ID","shipping","SLACK_LIST_SHIPPING_ID","receiving","SLACK_LIST_RECEIVING_ID","list_id","slackJson","payload","r","fetch","headers","Authorization","JSON","stringify","plain","v","toString","trim","toRichText","text","t","type","elements","listProbe","listId","probe","limit","resolveTitleColId","fallback","it","items","f","fields","key","toLowerCase","hasText","Array","isArray","rich_text","column_id","includes","resolveByKeywords","keywords","loose","candidate","kw","map","k","looseKw","hit","some","maybe","titleColId","safeTitle","created","initial_fields","pnSnColId","shipDateColId","trackingColId","woColId","localSnColId","descriptionColId","linkColId","photosColId","pn0","sn0","pnSnText","filter","Boolean","join","cells","push","row_id","item","id","length","asList","u","i","tryCellsUpdate","cellsBatch","asText","c","updated","item_id","used_title_col","auto_cols","err","console","message","String"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAI;AACF,QAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,aAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAArB,CAAP;AACD;;AAED,UAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;;AACA,QAAI,CAACH,KAAL,EAAY;AACV,aAAON,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,E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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   try {\r\n//     if (req.method !== \"POST\") {\r\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//     }\r\n\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) {\r\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//     }\r\n\r\n//     // payload from client\r\n//     const {\r\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n//       title,               // item title (what shows in the primary column)\r\n//       // keeping minimal per your request: PN/SN only for now\r\n//       pn, sn,\r\n//     } = req.body || {};\r\n\r\n//     // list ids from env\r\n//     const LIST_IDS = {\r\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\r\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n//     };\r\n\r\n//     const list_id = LIST_IDS[listKey];\r\n//     if (!list_id) {\r\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n//     }\r\n\r\n//     // ---- Slack helpers ----\r\n//     async function slackJson(method, payload) {\r\n//       const r = await fetch(`https://slack.com/api/${method}`, {\r\n//         method: \"POST\",\r\n//         headers: {\r\n//           Authorization: `Bearer ${token}`,\r\n//           \"Content-Type\": \"application/json; charset=utf-8\",\r\n//         },\r\n//         body: JSON.stringify(payload),\r\n//       });\r\n//       return r.json();\r\n//     }\r\n\r\n//     const plain = (v) => (v ?? \"\").toString().trim();\r\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     function toRichText(text) {\r\n//       const t = plain(text);\r\n//       return [{\r\n//         type: \"rich_text\",\r\n//         elements: [{\r\n//           type: \"rich_text_section\",\r\n//           elements: [{ type: \"text\", text: t }],\r\n//         }],\r\n//       }];\r\n//     }\r\n\r\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n//     async function resolveTitleColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n//       let fallback = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\r\n//           if (f.column_id && hasText) {\r\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n//             if (!fallback) fallback = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return fallback; // first text-like field if we didn't find a perfect match\r\n//     }\r\n\r\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n//     async function resolvePnSnColId(listId) {\r\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n//       if (!probe?.ok) return null;\r\n\r\n//       let candidate = null;\r\n//       for (const it of probe.items || []) {\r\n//         for (const f of it.fields || []) {\r\n//           if (!f.column_id) continue;\r\n//           const key = (f.key || \"\").toLowerCase();\r\n//           const text = (f.text || \"\").toLowerCase();\r\n\r\n//           const looksPnSn =\r\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\r\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n//           if (looksPnSn) return f.column_id;\r\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n//             candidate = f.column_id;\r\n//           }\r\n//         }\r\n//       }\r\n//       return candidate;\r\n//     }\r\n\r\n//     // 1) Resolve columns\r\n//     const titleColId = await resolveTitleColId(list_id);\r\n//     if (!titleColId) {\r\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n//     }\r\n\r\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n//     const safeTitle = plain(title) || \"New Item\";\r\n//     const createBody = {\r\n//       list_id,\r\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n//     };\r\n\r\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 3) (Minimal) update: PN/SN only, per your request\r\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n//     let updated = null;\r\n//     let usedPnSnCol = null;\r\n\r\n//     if (pnSnText) {\r\n//       const pnSnColId = await resolvePnSnColId(list_id);\r\n//       if (pnSnColId) {\r\n//         const cells = [{\r\n//           row_id: created.item.id,\r\n//           column_id: pnSnColId,\r\n//           rich_text: toRichText(pnSnText),\r\n//         }];\r\n\r\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n//         usedPnSnCol = pnSnColId;\r\n//         // If update fails, we still return ok:false so you can see the error\r\n//         if (!updated?.ok) {\r\n//           return res.status(200).json({\r\n//             ok: false,\r\n//             error: updated?.error || \"update_failed\",\r\n//             mode: \"list\",\r\n//             list_id,\r\n//             item_id: created.item.id,\r\n//             used_title_col: titleColId,\r\n//             used_pnsn_col: usedPnSnCol,\r\n//           });\r\n//         }\r\n//       }\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleColId,\r\n//       used_pnsn_col: usedPnSnCol || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) {\r\n      return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n    }\r\n\r\n    // ---- Payload from client (keep your working shape; just add the extras) ----\r\n    const {\r\n      listKey,            // \"shipping\" | \"receiving\" | \"tasks\"\r\n      title,              // primary title text\r\n      pn, sn,             // PN/SN\r\n      linkUrl,            // optional - page link\r\n      // auto-detected columns will be filled with these if present:\r\n      shippingDate,       // Shipping Date (you can pass items.arrival_date || items.date)\r\n      tracking,           // Tracking / WDIM\r\n      workOrder,          // WO/SO (send most recent)\r\n      localSN,            // Local SN (send item id)\r\n      description,        // free text\r\n      parties,            // KEEP as-is from your working flow if you already send it\r\n      photoUrls = [],     // optional – if you want to dump links\r\n    } = req.body || {};\r\n\r\n    const LIST_IDS = {\r\n      tasks: process.env.SLACK_LIST_TASKS_ID,\r\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n      receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n    };\r\n    const list_id = LIST_IDS[listKey];\r\n    if (!list_id) {\r\n      return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n    }\r\n\r\n    // ---- Slack helpers ----\r\n    async function slackJson(method, payload) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          Authorization: `Bearer ${token}`,\r\n          \"Content-Type\": \"application/json; charset=utf-8\",\r\n        },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      return r.json();\r\n    }\r\n\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n    const toRichText = (text) => {\r\n      const t = plain(text);\r\n      return [{\r\n        type: \"rich_text\",\r\n        elements: [{\r\n          type: \"rich_text_section\",\r\n          elements: [{ type: \"text\", text: t }],\r\n        }],\r\n      }];\r\n    };\r\n\r\n    // ---- Column auto-discovery by scanning list items ----\r\n    async function listProbe(listId) {\r\n      const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 200 });\r\n      return probe?.ok ? probe : null;\r\n    }\r\n\r\n    async function resolveTitleColId(listId) {\r\n      const probe = await listProbe(listId);\r\n      if (!probe) return null;\r\n      let fallback = null;\r\n      for (const it of probe.items || []) {\r\n        for (const f of it.fields || []) {\r\n          const key = (f.key || \"\").toLowerCase();\r\n          const hasText = !!f.text || Array.isArray(f.rich_text);\r\n          if (f.column_id && hasText) {\r\n            if (key.includes(\"item\") || key.includes(\"task\") || key.includes(\"name\")) {\r\n              return f.column_id;\r\n            }\r\n            if (!fallback) fallback = f.column_id;\r\n          }\r\n        }\r\n      }\r\n      return fallback;\r\n    }\r\n\r\n    async function resolveByKeywords(listId, keywords = [], loose = []) {\r\n      const probe = await listProbe(listId);\r\n      if (!probe) return null;\r\n      let candidate = null;\r\n      const kw = (keywords || []).map(k => k.toLowerCase());\r\n      const looseKw = (loose || []).map(k => k.toLowerCase());\r\n\r\n      for (const it of (probe.items || [])) {\r\n        for (const f of (it.fields || [])) {\r\n          if (!f.column_id) continue;\r\n          const key = (f.key || \"\").toLowerCase();\r\n          const text = (f.text || \"\").toLowerCase();\r\n\r\n          const hit = kw.some(k => key.includes(k) || text.includes(k));\r\n          if (hit) return f.column_id;\r\n\r\n          if (!candidate) {\r\n            const maybe = looseKw.some(k => key.includes(k) || text.includes(k));\r\n            if (maybe) candidate = f.column_id;\r\n          }\r\n        }\r\n      }\r\n      return candidate;\r\n    }\r\n\r\n    const titleColId = await resolveTitleColId(list_id);\r\n    if (!titleColId) {\r\n      return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n    }\r\n\r\n    // ---- 1) Create the row with the title as rich_text (your working behavior) ----\r\n    const safeTitle = plain(title) || \"New Item\";\r\n    const created = await slackJson(\"slackLists.items.create\", {\r\n      list_id,\r\n      initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n    });\r\n    if (!created?.ok) {\r\n      return res.status(200).json({ ok: false, error: created?.error || \"create_failed\" });\r\n    }\r\n\r\n    // ---- 2) Resolve other target columns by keywords ----\r\n    const pnSnColId = await resolveByKeywords(\r\n      list_id,\r\n      [\"pn\", \"sn\", \"part number\", \"serial\"],\r\n      [\"pn:\", \"sn:\"]\r\n    );\r\n    const shipDateColId = await resolveByKeywords(\r\n      list_id,\r\n      [\"shipping date\", \"ship date\"],\r\n      [\"date\"]\r\n    );\r\n    const trackingColId = await resolveByKeywords(\r\n      list_id,\r\n      [\"tracking\", \"wdim\"],\r\n      [\"tracking number\", \"tn\", \"wdim\"]\r\n    );\r\n    const woColId = await resolveByKeywords(\r\n      list_id,\r\n      [\"wo/so\", \"work order\", \"sales order\"],\r\n      [\"wo\", \"so\"]\r\n    );\r\n    const localSnColId = await resolveByKeywords(\r\n      list_id,\r\n      [\"local sn\", \"localsn\", \"ais\"],\r\n      [\"local\", \"sn\"]\r\n    );\r\n    const descriptionColId = await resolveByKeywords(\r\n      list_id,\r\n      [\"description\", \"notes\"],\r\n      [\"desc\", \"note\"]\r\n    );\r\n    const linkColId = await resolveByKeywords(\r\n      list_id,\r\n      [\"link\", \"url\", \"page\"],\r\n      []\r\n    );\r\n    const photosColId = await resolveByKeywords(\r\n      list_id,\r\n      [\"shipping photos\", \"photos\", \"images\", \"pics\"],\r\n      [\"photo\", \"image\", \"pic\"]\r\n    );\r\n    // If you have a Parties column and already send Parties in your working code,\r\n    // we leave that path untouched on purpose.\r\n\r\n    // ---- 3) Build cells to update (rich_text first, fallback to text on failure) ----\r\n    const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n    const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n    const pnSnText = [\r\n      plain(pn0) ? `PN: ${plain(pn0)}` : \"\",\r\n      plain(sn0) ? `SN: ${plain(sn0)}` : \"\",\r\n    ].filter(Boolean).join(\"  \");\r\n\r\n    const cells = [];\r\n\r\n    if (pnSnText && pnSnColId) {\r\n      cells.push({ row_id: created.item.id, column_id: pnSnColId, rich_text: toRichText(pnSnText) });\r\n    }\r\n    if (shipDateColId && plain(shippingDate)) {\r\n      cells.push({ row_id: created.item.id, column_id: shipDateColId, rich_text: toRichText(shippingDate) });\r\n    }\r\n    if (trackingColId && plain(tracking)) {\r\n      cells.push({ row_id: created.item.id, column_id: trackingColId, rich_text: toRichText(tracking) });\r\n    }\r\n    if (woColId && plain(workOrder)) {\r\n      cells.push({ row_id: created.item.id, column_id: woColId, rich_text: toRichText(workOrder) });\r\n    }\r\n    if (localSnColId && plain(localSN)) {\r\n      cells.push({ row_id: created.item.id, column_id: localSnColId, rich_text: toRichText(localSN) });\r\n    }\r\n    if (descriptionColId && plain(description)) {\r\n      cells.push({ row_id: created.item.id, column_id: descriptionColId, rich_text: toRichText(description) });\r\n    }\r\n    if (linkColId && plain(linkUrl)) {\r\n      cells.push({ row_id: created.item.id, column_id: linkColId, rich_text: toRichText(linkUrl) });\r\n    }\r\n    if (photosColId && photoUrls.length) {\r\n      const asList = photoUrls.map((u, i) => `${i + 1}. ${u}`).join(\"\\n\");\r\n      cells.push({ row_id: created.item.id, column_id: photosColId, rich_text: toRichText(asList) });\r\n    }\r\n\r\n    async function tryCellsUpdate(cellsBatch) {\r\n      if (!cellsBatch.length) return { ok: true };\r\n      // Try rich_text first\r\n      let r = await slackJson(\"slackLists.items.update\", { list_id, cells: cellsBatch });\r\n      if (r?.ok) return r;\r\n\r\n      // Retry with `text` for the same cells\r\n      const asText = cellsBatch.map(c => ({\r\n        row_id: c.row_id,\r\n        column_id: c.column_id,\r\n        text: (c.rich_text && c.rich_text[0] && c.rich_text[0].elements &&\r\n               c.rich_text[0].elements[0] && c.rich_text[0].elements[0].elements &&\r\n               c.rich_text[0].elements[0].elements[0] &&\r\n               c.rich_text[0].elements[0].elements[0].text) || \"\",\r\n      }));\r\n      return await slackJson(\"slackLists.items.update\", { list_id, cells: asText });\r\n    }\r\n\r\n    const updated = await tryCellsUpdate(cells);\r\n    if (!updated?.ok) {\r\n      // As a last resort, if PN/SN failed and we at least have a title column, append PN/SN to title\r\n      if (pnSnText) {\r\n        await slackJson(\"slackLists.items.update\", {\r\n          list_id,\r\n          cells: [{\r\n            row_id: created.item.id,\r\n            column_id: titleColId,\r\n            text: `${safeTitle} — ${pnSnText}`,\r\n          }],\r\n        });\r\n      }\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: updated?.error || \"update_failed\",\r\n        list_id,\r\n        item_id: created.item.id,\r\n        used_title_col: titleColId,\r\n      });\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      list_id,\r\n      item_id: created.item.id,\r\n      used_title_col: titleColId,\r\n      auto_cols: {\r\n        pnSnColId, shipDateColId, trackingColId, woColId, localSnColId, descriptionColId, linkColId, photosColId\r\n      },\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}