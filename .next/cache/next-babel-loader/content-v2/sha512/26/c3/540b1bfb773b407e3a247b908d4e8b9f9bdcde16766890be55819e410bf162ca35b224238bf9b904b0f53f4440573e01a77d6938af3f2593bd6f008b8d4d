{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   if (req.method !== \"POST\") {\n//     return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//   }\n//   const token = process.env.SLACK_BOT_TOKEN;\n//   if (!token) {\n//     return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//   }\n//   // ---- Payload from client (your UI already sends these) ----\n//   const {\n//     listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\n//     title,              // the thing we want to show in the Task column\n//     linkUrl, bodyText,\n//     date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\n//     photoUrls = [],\n//   } = req.body || {};\n//   // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\n//   const LISTS = {\n//     tasks: {\n//       id: process.env.SLACK_LIST_TASKS_ID,\n//       // OPTIONAL: if you know the \"Task\" column id already\n//       titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\n//       cols: {\n//         desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\n//       },\n//     },\n//     shipping: {\n//       id: process.env.SLACK_LIST_SHIPPING_ID,\n//       titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\n//       cols: {\n//         desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\n//         date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\n//         pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\n//         track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\n//         wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\n//         lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\n//         photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\n//       },\n//     },\n//     receiving: {\n//       id: process.env.SLACK_LIST_RECEIVING_ID,\n//       titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\n//       cols: {\n//         desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\n//         date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\n//         pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\n//         track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\n//         wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\n//         lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\n//         photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\n//       },\n//     },\n//   };\n//   const cfg = LISTS[listKey];\n//   if (!cfg?.id) {\n//     return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\n//   }\n//   // ---- Slack helpers ----\n//   async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\n//     const r = await fetch(`https://slack.com/api/${method}`, {\n//       method: \"POST\",\n//       headers: { Authorization: `Bearer ${token}`, ...headers },\n//       body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\n//     });\n//     return r.json();\n//   }\n//   const plain = (v) => (v ?? \"\").toString().trim();\n//   const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//   // Never send an empty title\n//   const safeTitle =\n//     plain(title) ||\n//     (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\n//     joinArr(pn) ||\n//     \"New Item\";\n//   // Convert plain text to Slack rich_text for text columns\n//   function toRichText(text) {\n//     return [{\n//       type: \"rich_text\",\n//       elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\n//     }];\n//   }\n//   // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\n//   async function resolveTitleColumnId(listId, provided) {\n//     if (provided) return { colId: provided, source: \"env\" };\n//     const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//     if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\n//     let candidate = null;\n//     for (const item of probe.items || []) {\n//       for (const f of item.fields || []) {\n//         const key = (f.key || \"\").trim().toLowerCase();\n//         const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\n//         if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\n//         if (!candidate && f.column_id && hasText) candidate = f.column_id;\n//       }\n//     }\n//     return { colId: candidate, source: \"auto:first_text\" };\n//   }\n//   try {\n//     // 1) Find the column to write the Task name into; fall back to top-level title\n//     const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\n//     const createBody = {\n//       list_id: cfg.id,\n//       ...(titleCol.colId\n//         ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\n//         : { title: safeTitle }), // fallback if we couldn’t resolve a column\n//     };\n//     const created = await slack(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 2) (Optional) Patch other columns you actually have IDs for\n//     const fields = [];\n//     const cols = cfg.cols || {};\n//     const addText = (colId, text) => {\n//       const t = plain(text);\n//       if (colId && t) fields.push({ column_id: colId, value: { text: t } });\n//     };\n//     // Description / Notes column (for tasks we include your assembled bodyText)\n//     if (cols.desc) {\n//       const bits = [\n//         plain(description),\n//         listKey === \"tasks\" ? plain(bodyText) : \"\",\n//         plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\n//       ].filter(Boolean).join(\"\\n\");\n//       addText(cols.desc, bits);\n//     }\n//     // Dates and grouped PN/SN/DOM example\n//     if (cols.date && plain(date)) fields.push({ column_id: cols.date, value: { date: plain(date) } });\n//     if (cols.pn) {\n//       const pnStr = joinArr(pn), snStr = joinArr(sn);\n//       const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`]\n//         .filter(Boolean).join(\"  \");\n//       addText(cols.pn, combo);\n//     }\n//     if (cols.track) {\n//       const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`]\n//         .filter(Boolean).join(\"  \");\n//       addText(cols.track, t);\n//     }\n//     if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\n//     if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\n//     if (fields.length) {\n//       await slack(\"slackLists.items.update\", { list_id: cfg.id, item_id: created.item.id, fields });\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id: cfg.id,\n//       item_id: created.item.id,\n//       used_title_col: titleCol.colId || null,\n//       title_col_source: titleCol.source || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  try {\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n\n    if (!token) {\n      return res.status(500).json({\n        ok: false,\n        error: \"missing_SLACK_BOT_TOKEN\"\n      });\n    } // payload from client\n\n\n    const {\n      listKey,\n      // \"tasks\" | \"shipping\" | \"receiving\"\n      title,\n      // item title (what shows in the primary column)\n      // keeping minimal per your request: PN/SN only for now\n      pn,\n      sn\n    } = req.body || {}; // list ids from env\n\n    const LIST_IDS = {\n      tasks: process.env.SLACK_LIST_TASKS_ID,\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\n      receiving: process.env.SLACK_LIST_RECEIVING_ID\n    };\n    const list_id = LIST_IDS[listKey];\n\n    if (!list_id) {\n      return res.status(400).json({\n        ok: false,\n        error: `unknown_listKey_${listKey}`\n      });\n    } // ---- Slack helpers ----\n\n\n    async function slackJson(method, payload) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(payload)\n      });\n      return r.json();\n    }\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n\n    function toRichText(text) {\n      const t = plain(text);\n      return [{\n        type: \"rich_text\",\n        elements: [{\n          type: \"rich_text_section\",\n          elements: [{\n            type: \"text\",\n            text: t\n          }]\n        }]\n      }];\n    } // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n\n\n    async function resolveTitleColId(listId) {\n      const probe = await slackJson(\"slackLists.items.list\", {\n        list_id: listId,\n        limit: 50\n      });\n      if (!(probe !== null && probe !== void 0 && probe.ok)) return null; // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n\n      let fallback = null;\n\n      for (const it of probe.items || []) {\n        for (const f of it.fields || []) {\n          const key = (f.key || \"\").toLowerCase();\n          const hasText = !!f.text || Array.isArray(f.rich_text);\n\n          if (f.column_id && hasText) {\n            if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n            if (!fallback) fallback = f.column_id;\n          }\n        }\n      }\n\n      return fallback; // first text-like field if we didn't find a perfect match\n    } // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n\n\n    async function resolvePnSnColId(listId) {\n      const probe = await slackJson(\"slackLists.items.list\", {\n        list_id: listId,\n        limit: 100\n      });\n      if (!(probe !== null && probe !== void 0 && probe.ok)) return null;\n      let candidate = null;\n\n      for (const it of probe.items || []) {\n        for (const f of it.fields || []) {\n          if (!f.column_id) continue;\n          const key = (f.key || \"\").toLowerCase();\n          const text = (f.text || \"\").toLowerCase();\n          const looksPnSn = key.includes(\"pn\") || key.includes(\"sn\") || text.includes(\"pn:\") || text.includes(\"sn:\");\n          if (looksPnSn) return f.column_id;\n\n          if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n            candidate = f.column_id;\n          }\n        }\n      }\n\n      return candidate;\n    } // 1) Resolve columns\n\n\n    const titleColId = await resolveTitleColId(list_id);\n\n    if (!titleColId) {\n      return res.status(400).json({\n        ok: false,\n        error: \"could_not_resolve_title_column\"\n      });\n    } // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n\n\n    const safeTitle = plain(title) || \"New Item\";\n    const createBody = {\n      list_id,\n      initial_fields: [{\n        column_id: titleColId,\n        rich_text: toRichText(safeTitle)\n      }]\n    };\n    const created = await slackJson(\"slackLists.items.create\", createBody);\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(200).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\",\n        mode: \"list\",\n        sent: createBody\n      });\n    } // 3) (Minimal) update: PN/SN only, per your request\n\n\n    const pn0 = Array.isArray(pn) ? pn[0] : pn;\n    const sn0 = Array.isArray(sn) ? sn[0] : sn;\n    const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n    const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n    const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n    let updated = null;\n    let usedPnSnCol = null;\n\n    if (pnSnText) {\n      const pnSnColId = await resolvePnSnColId(list_id);\n\n      if (pnSnColId) {\n        var _updated;\n\n        const cells = [{\n          row_id: created.item.id,\n          column_id: pnSnColId,\n          rich_text: toRichText(pnSnText)\n        }];\n        updated = await slackJson(\"slackLists.items.update\", {\n          list_id,\n          cells\n        });\n        usedPnSnCol = pnSnColId; // If update fails, we still return ok:false so you can see the error\n\n        if (!((_updated = updated) !== null && _updated !== void 0 && _updated.ok)) {\n          var _updated2;\n\n          return res.status(200).json({\n            ok: false,\n            error: ((_updated2 = updated) === null || _updated2 === void 0 ? void 0 : _updated2.error) || \"update_failed\",\n            mode: \"list\",\n            list_id,\n            item_id: created.item.id,\n            used_title_col: titleColId,\n            used_pnsn_col: usedPnSnCol\n          });\n        }\n      }\n    }\n\n    return res.status(200).json({\n      ok: true,\n      mode: \"list\",\n      list_id,\n      item_id: created.item.id,\n      used_title_col: titleColId,\n      used_pnsn_col: usedPnSnCol || null,\n      sent_title: safeTitle\n    });\n  } catch (err) {\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","token","process","env","SLACK_BOT_TOKEN","listKey","title","pn","sn","body","LIST_IDS","tasks","SLACK_LIST_TASKS_ID","shipping","SLACK_LIST_SHIPPING_ID","receiving","SLACK_LIST_RECEIVING_ID","list_id","slackJson","payload","r","fetch","headers","Authorization","JSON","stringify","plain","v","toString","trim","joinArr","a","Array","isArray","filter","Boolean","map","join","toRichText","text","t","type","elements","resolveTitleColId","listId","probe","limit","fallback","it","items","f","fields","key","toLowerCase","hasText","rich_text","column_id","includes","resolvePnSnColId","candidate","looksPnSn","titleColId","safeTitle","createBody","initial_fields","created","mode","sent","pn0","sn0","pnPart","snPart","pnSnText","updated","usedPnSnCol","pnSnColId","cells","row_id","item","id","item_id","used_title_col","used_pnsn_col","sent_title","err","console","message","String"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAC9C,MAAI;AACF,QAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,aAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,QAAAA,EAAE,EAAE,KAAN;AAAaC,QAAAA,KAAK,EAAE;AAApB,OAArB,CAAP;AACD;;AAED,UAAMC,KAAK,GAAGC,OAAO,CAACC,GAAR,CAAYC,eAA1B;;AACA,QAAI,CAACH,KAAL,EAAY;AACV,aAAON,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC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","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   if (req.method !== \"POST\") {\r\n//     return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n//   }\r\n\r\n//   const token = process.env.SLACK_BOT_TOKEN;\r\n//   if (!token) {\r\n//     return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n//   }\r\n\r\n//   // ---- Payload from client (your UI already sends these) ----\r\n//   const {\r\n//     listKey,            // \"tasks\" | \"shipping\" | \"receiving\"\r\n//     title,              // the thing we want to show in the Task column\r\n//     linkUrl, bodyText,\r\n//     date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n//     photoUrls = [],\r\n//   } = req.body || {};\r\n\r\n//   // ---- Lists (IDs from .env). Only `id` is required to push a title. ----\r\n//   const LISTS = {\r\n//     tasks: {\r\n//       id: process.env.SLACK_LIST_TASKS_ID,\r\n//       // OPTIONAL: if you know the \"Task\" column id already\r\n//       titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null,\r\n//       cols: {\r\n//         desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL || null,\r\n//       },\r\n//     },\r\n//     shipping: {\r\n//       id: process.env.SLACK_LIST_SHIPPING_ID,\r\n//       titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null,\r\n//       cols: {\r\n//         desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL || null,\r\n//         date:   process.env.SLACK_LIST_SHIPPING_DATE_COL || null,\r\n//         pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL || null,\r\n//         track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL || null,\r\n//         wo:     process.env.SLACK_LIST_SHIPPING_WO_COL || null,\r\n//         lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL || null,\r\n//         photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL || null,\r\n//       },\r\n//     },\r\n//     receiving: {\r\n//       id: process.env.SLACK_LIST_RECEIVING_ID,\r\n//       titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null,\r\n//       cols: {\r\n//         desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL || null,\r\n//         date:   process.env.SLACK_LIST_RECEIVING_DATE_COL || null,\r\n//         pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL || null,\r\n//         track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL || null,\r\n//         wo:     process.env.SLACK_LIST_RECEIVING_WO_COL || null,\r\n//         lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL || null,\r\n//         photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL || null,\r\n//       },\r\n//     },\r\n//   };\r\n\r\n//   const cfg = LISTS[listKey];\r\n//   if (!cfg?.id) {\r\n//     return res.status(400).json({ ok: false, error: `unknown_or_unconfigured_listKey_${listKey}` });\r\n//   }\r\n\r\n//   // ---- Slack helpers ----\r\n//   async function slack(method, payload, headers = { \"Content-Type\": \"application/json; charset=utf-8\" }) {\r\n//     const r = await fetch(`https://slack.com/api/${method}`, {\r\n//       method: \"POST\",\r\n//       headers: { Authorization: `Bearer ${token}`, ...headers },\r\n//       body: typeof payload === \"string\" ? payload : JSON.stringify(payload),\r\n//     });\r\n//     return r.json();\r\n//   }\r\n\r\n//   const plain = (v) => (v ?? \"\").toString().trim();\r\n//   const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//   // Never send an empty title\r\n//   const safeTitle =\r\n//     plain(title) ||\r\n//     (plain(localSN) ? `Item ${plain(localSN)}` : \"\") ||\r\n//     joinArr(pn) ||\r\n//     \"New Item\";\r\n\r\n//   // Convert plain text to Slack rich_text for text columns\r\n//   function toRichText(text) {\r\n//     return [{\r\n//       type: \"rich_text\",\r\n//       elements: [{ type: \"rich_text_section\", elements: [{ type: \"text\", text }] }],\r\n//     }];\r\n//   }\r\n\r\n//   // Try to discover a suitable text column for the “Task” cell if you didn’t provide one\r\n//   async function resolveTitleColumnId(listId, provided) {\r\n//     if (provided) return { colId: provided, source: \"env\" };\r\n\r\n//     const probe = await slack(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n//     if (!probe?.ok) return { colId: null, source: \"auto\", error: probe?.error || \"items.list_failed\" };\r\n\r\n//     let candidate = null;\r\n//     for (const item of probe.items || []) {\r\n//       for (const f of item.fields || []) {\r\n//         const key = (f.key || \"\").trim().toLowerCase();\r\n//         const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\r\n//         if (key === \"task\" && f.column_id && hasText) return { colId: f.column_id, source: \"auto:key_task\" };\r\n//         if (!candidate && f.column_id && hasText) candidate = f.column_id;\r\n//       }\r\n//     }\r\n//     return { colId: candidate, source: \"auto:first_text\" };\r\n//   }\r\n\r\n//   try {\r\n//     // 1) Find the column to write the Task name into; fall back to top-level title\r\n//     const titleCol = await resolveTitleColumnId(cfg.id, cfg.titleColId);\r\n\r\n//     const createBody = {\r\n//       list_id: cfg.id,\r\n//       ...(titleCol.colId\r\n//         ? { initial_fields: [{ column_id: titleCol.colId, rich_text: toRichText(safeTitle) }] }\r\n//         : { title: safeTitle }), // fallback if we couldn’t resolve a column\r\n//     };\r\n\r\n//     const created = await slack(\"slackLists.items.create\", createBody);\r\n//     if (!created?.ok) {\r\n//       return res.status(200).json({\r\n//         ok: false,\r\n//         error: created?.error || \"create_failed\",\r\n//         mode: \"list\",\r\n//         sent: createBody,\r\n//       });\r\n//     }\r\n\r\n//     // 2) (Optional) Patch other columns you actually have IDs for\r\n//     const fields = [];\r\n//     const cols = cfg.cols || {};\r\n//     const addText = (colId, text) => {\r\n//       const t = plain(text);\r\n//       if (colId && t) fields.push({ column_id: colId, value: { text: t } });\r\n//     };\r\n\r\n//     // Description / Notes column (for tasks we include your assembled bodyText)\r\n//     if (cols.desc) {\r\n//       const bits = [\r\n//         plain(description),\r\n//         listKey === \"tasks\" ? plain(bodyText) : \"\",\r\n//         plain(linkUrl) ? `<${plain(linkUrl)}|Open in Magmo>` : \"\",\r\n//       ].filter(Boolean).join(\"\\n\");\r\n//       addText(cols.desc, bits);\r\n//     }\r\n\r\n//     // Dates and grouped PN/SN/DOM example\r\n//     if (cols.date && plain(date)) fields.push({ column_id: cols.date, value: { date: plain(date) } });\r\n//     if (cols.pn) {\r\n//       const pnStr = joinArr(pn), snStr = joinArr(sn);\r\n//       const combo = [pnStr && `PN: ${pnStr}`, snStr && `SN: ${snStr}`, plain(dom) && `DOM: ${plain(dom)}`]\r\n//         .filter(Boolean).join(\"  \");\r\n//       addText(cols.pn, combo);\r\n//     }\r\n//     if (cols.track) {\r\n//       const t = [plain(trackingNumber) && `RL: ${plain(trackingNumber)}`, plain(poNumber) && `PO: ${plain(poNumber)}`]\r\n//         .filter(Boolean).join(\"  \");\r\n//       addText(cols.track, t);\r\n//     }\r\n//     if (cols.wo && plain(workOrder)) addText(cols.wo, `WO: ${plain(workOrder)}`);\r\n//     if (cols.lsn && plain(localSN)) addText(cols.lsn, plain(localSN));\r\n\r\n//     if (fields.length) {\r\n//       await slack(\"slackLists.items.update\", { list_id: cfg.id, item_id: created.item.id, fields });\r\n//     }\r\n\r\n//     return res.status(200).json({\r\n//       ok: true,\r\n//       mode: \"list\",\r\n//       list_id: cfg.id,\r\n//       item_id: created.item.id,\r\n//       used_title_col: titleCol.colId || null,\r\n//       title_col_source: titleCol.source || null,\r\n//       sent_title: safeTitle,\r\n//     });\r\n//   } catch (err) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", err);\r\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n//   }\r\n// }\r\n\r\n\r\n\r\n// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  try {\r\n    if (req.method !== \"POST\") {\r\n      return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\r\n    }\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) {\r\n      return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\r\n    }\r\n\r\n    // payload from client\r\n    const {\r\n      listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\r\n      title,               // item title (what shows in the primary column)\r\n      // keeping minimal per your request: PN/SN only for now\r\n      pn, sn,\r\n    } = req.body || {};\r\n\r\n    // list ids from env\r\n    const LIST_IDS = {\r\n      tasks: process.env.SLACK_LIST_TASKS_ID,\r\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\r\n      receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n    };\r\n\r\n    const list_id = LIST_IDS[listKey];\r\n    if (!list_id) {\r\n      return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\r\n    }\r\n\r\n    // ---- Slack helpers ----\r\n    async function slackJson(method, payload) {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: {\r\n          Authorization: `Bearer ${token}`,\r\n          \"Content-Type\": \"application/json; charset=utf-8\",\r\n        },\r\n        body: JSON.stringify(payload),\r\n      });\r\n      return r.json();\r\n    }\r\n\r\n    const plain = (v) => (v ?? \"\").toString().trim();\r\n    const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n    function toRichText(text) {\r\n      const t = plain(text);\r\n      return [{\r\n        type: \"rich_text\",\r\n        elements: [{\r\n          type: \"rich_text_section\",\r\n          elements: [{ type: \"text\", text: t }],\r\n        }],\r\n      }];\r\n    }\r\n\r\n    // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\r\n    async function resolveTitleColId(listId) {\r\n      const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\r\n      if (!probe?.ok) return null;\r\n\r\n      // Heuristics: prefer a text field whose key looks like 'item' or 'task'\r\n      let fallback = null;\r\n      for (const it of probe.items || []) {\r\n        for (const f of it.fields || []) {\r\n          const key = (f.key || \"\").toLowerCase();\r\n          const hasText = !!f.text || Array.isArray(f.rich_text);\r\n          if (f.column_id && hasText) {\r\n            if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\r\n            if (!fallback) fallback = f.column_id;\r\n          }\r\n        }\r\n      }\r\n      return fallback; // first text-like field if we didn't find a perfect match\r\n    }\r\n\r\n    // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\r\n    async function resolvePnSnColId(listId) {\r\n      const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\r\n      if (!probe?.ok) return null;\r\n\r\n      let candidate = null;\r\n      for (const it of probe.items || []) {\r\n        for (const f of it.fields || []) {\r\n          if (!f.column_id) continue;\r\n          const key = (f.key || \"\").toLowerCase();\r\n          const text = (f.text || \"\").toLowerCase();\r\n\r\n          const looksPnSn =\r\n            key.includes(\"pn\") || key.includes(\"sn\") ||\r\n            text.includes(\"pn:\") || text.includes(\"sn:\");\r\n\r\n          if (looksPnSn) return f.column_id;\r\n          if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\r\n            candidate = f.column_id;\r\n          }\r\n        }\r\n      }\r\n      return candidate;\r\n    }\r\n\r\n    // 1) Resolve columns\r\n    const titleColId = await resolveTitleColId(list_id);\r\n    if (!titleColId) {\r\n      return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\r\n    }\r\n\r\n    // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\r\n    const safeTitle = plain(title) || \"New Item\";\r\n    const createBody = {\r\n      list_id,\r\n      initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\r\n    };\r\n\r\n    const created = await slackJson(\"slackLists.items.create\", createBody);\r\n    if (!created?.ok) {\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: created?.error || \"create_failed\",\r\n        mode: \"list\",\r\n        sent: createBody,\r\n      });\r\n    }\r\n\r\n    // 3) (Minimal) update: PN/SN only, per your request\r\n    const pn0 = Array.isArray(pn) ? pn[0] : pn;\r\n    const sn0 = Array.isArray(sn) ? sn[0] : sn;\r\n    const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\r\n    const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\r\n    const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\r\n\r\n    let updated = null;\r\n    let usedPnSnCol = null;\r\n\r\n    if (pnSnText) {\r\n      const pnSnColId = await resolvePnSnColId(list_id);\r\n      if (pnSnColId) {\r\n        const cells = [{\r\n          row_id: created.item.id,\r\n          column_id: pnSnColId,\r\n          rich_text: toRichText(pnSnText),\r\n        }];\r\n\r\n        updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\r\n        usedPnSnCol = pnSnColId;\r\n        // If update fails, we still return ok:false so you can see the error\r\n        if (!updated?.ok) {\r\n          return res.status(200).json({\r\n            ok: false,\r\n            error: updated?.error || \"update_failed\",\r\n            mode: \"list\",\r\n            list_id,\r\n            item_id: created.item.id,\r\n            used_title_col: titleColId,\r\n            used_pnsn_col: usedPnSnCol,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return res.status(200).json({\r\n      ok: true,\r\n      mode: \"list\",\r\n      list_id,\r\n      item_id: created.item.id,\r\n      used_title_col: titleColId,\r\n      used_pnsn_col: usedPnSnCol || null,\r\n      sent_title: safeTitle,\r\n    });\r\n  } catch (err) {\r\n    console.error(\"API /slack/add-to-list crashed:\", err);\r\n    return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\r\n  }\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}