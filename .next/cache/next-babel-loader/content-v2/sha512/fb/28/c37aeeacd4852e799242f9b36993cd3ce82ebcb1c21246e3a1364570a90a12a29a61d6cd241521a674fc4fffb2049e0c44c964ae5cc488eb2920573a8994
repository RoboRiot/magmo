{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { useEffect, useState, useRef, useCallback, useMemo } from \"react\";\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport { Form, Button, Card, Container, Row, Col, Modal, FormControl, Collapse, InputGroup, ButtonGroup, Spinner } from \"react-bootstrap\";\nimport Link from \"next/link\";\nimport dynamic from \"next/dynamic\";\nimport { useAuth } from \"../../../context/AuthUserContext\";\nimport firebase from \"../../../context/Firebase\";\nimport LoggedIn from \"../../LoggedIn\";\nimport { useRouter } from \"next/router\";\nimport { fetchClients } from \"../../../utils/fetchAssociations\";\nimport ClientTable from \"../../../utils/ClientTable\";\nimport ClientInfoModal from \"../ClientInfoModal\";\nimport ParentModal from \"./parentModal\";\nimport MachineSelectionModal from \"../item/[id]/MachineSelectionModal\";\nimport InfoModal from \"../InfoModal\";\nimport InflowAPI from \"../../../utils/inflowAPI\";\nimport NewLocal from \"../item/[id]/NewLocal\";\nimport { buildLocalLocObject, formatLoc, updateMachineFields, buildNameTokens } from \"../../../utils/itemFormShared\";\nimport MultiSelectDropdown from \"../../../components/MultiSelectDropdown\";\nimport { fetchTrackerCatalog, buildAllOems, buildModelsForSelection, syncTrackerFromSelections, deleteTrackerOem, deleteTrackerModel } from \"../../../utils/trackerCatalog\";\nimport styles from \"./NewItem.module.css\"; // Load BarcodeScannerComponent only on the client-side.\n\nconst BarcodeScannerComponent = dynamic(() => import(\"react-qr-barcode-scanner\"), {\n  ssr: false,\n  loadableGenerated: {\n    webpack: () => [require.resolveWeak(\"react-qr-barcode-scanner\")],\n    modules: [\"NewSearch\\\\AddItem\\\\NewItem.js -> \" + \"react-qr-barcode-scanner\"]\n  }\n}); // Simulate network delay.\n\nfunction simulateNetworkRequest() {\n  return new Promise(resolve => setTimeout(resolve, 2000));\n} // Custom LoadingButton component.\n\n\nfunction LoadingButton({\n  type,\n  name,\n  route\n}) {\n  const {\n    0: isLoading,\n    1: setLoading\n  } = useState(false);\n  useEffect(() => {\n    if (isLoading) {\n      let cancelled = false;\n      simulateNetworkRequest().then(() => {\n        if (!cancelled) setLoading(false);\n      });\n      return () => {\n        cancelled = true;\n      };\n    }\n  }, [isLoading]);\n\n  const handleClick = () => setLoading(true);\n\n  return __jsx(Link, {\n    href: `/${route}`\n  }, __jsx(\"a\", {\n    className: `btn btn-${type}`,\n    disabled: isLoading,\n    onClick: !isLoading ? handleClick : null\n  }, isLoading ? \"Loading…\" : name));\n}\n\nexport default function NewItem() {\n  var _descriptions$selecte, _descriptions$selecte4, _descriptions$selecte5, _newLocalFrom$section, _newLocalFrom$section2, _newLocalCurrent$sect, _newLocalCurrent$sect2;\n\n  const router = useRouter();\n  const {\n    signOut\n  } = useAuth();\n  const SHOW_SLACK_BUTTONS = process.env.NEXT_PUBLIC_SHOW_SLACK_BUTTONS === \"true\"; // Initialize item state – for a new item, these start empty.\n  // We store PN and SN as arrays.\n\n  const {\n    0: items,\n    1: setItems\n  } = useState({\n    name: \"\",\n    pn: [\"\"],\n    sn: [\"\"],\n    // This will be overridden on submit.\n    localSN: \"\",\n    // NEW FIELD: holds user input for a local serial number.\n    date: new Date().toISOString().split(\"T\")[0],\n    // auto-fill current date\n    price: \"\",\n    status: \"\",\n    poNumber: \"\",\n    trackingNumber: \"\",\n    length: \"\",\n    width: \"\",\n    height: \"\",\n    arrival_date: \"\",\n    // NEW FIELD: Arrival Date\n    visible: true\n  });\n  const {\n    0: editingPn,\n    1: setEditingPn\n  } = useState(true); // const [newPn, setNewPn] = useState(\"\"); // for the input value when editing\n\n  const {\n    0: editingSn,\n    1: setEditingSn\n  } = useState(true); // const [newSn, setNewSn] = useState(\"\");\n  // DOM is the Date of Manufacture input (user provided).\n\n  const {\n    0: DOM,\n    1: setDOM\n  } = useState(\"\"); // OEM, Modality, Model fields (multi-select).\n\n  const {\n    0: selectedModalities,\n    1: setSelectedModalities\n  } = useState([]);\n  const {\n    0: selectedOems,\n    1: setSelectedOems\n  } = useState([]);\n  const {\n    0: selectedModels,\n    1: setSelectedModels\n  } = useState([]); // Local location states.\n\n  const {\n    0: newLocalFrom,\n    1: setNewLocalFrom\n  } = useState({\n    region: \"\",\n    section: {\n      letter: \"\",\n      number: \"\"\n    },\n    bin: \"\",\n    pallet: \"\"\n  });\n  const {\n    0: newLocalCurrent,\n    1: setNewLocalCurrent\n  } = useState({\n    region: \"\",\n    section: {\n      letter: \"\",\n      number: \"\"\n    },\n    bin: \"\",\n    pallet: \"\"\n  }); // Other states.\n\n  const {\n    0: pnOptions,\n    1: setPnOptions\n  } = useState([]);\n  const {\n    0: snOptions,\n    1: setSnOptions\n  } = useState([]);\n  const {\n    0: pnSnLoaded,\n    1: setPnSnLoaded\n  } = useState(false);\n  const {\n    0: pnSnLoading,\n    1: setPnSnLoading\n  } = useState(false);\n  const {\n    0: descriptions,\n    1: setDescriptions\n  } = useState([{\n    description: \"\",\n    date: \"\"\n  }]);\n  const {\n    0: workOrders,\n    1: setWorkOrders\n  } = useState([{\n    workOrder: \"\",\n    date: \"\"\n  }]);\n  const {\n    0: clients,\n    1: setClients\n  } = useState([]);\n  const {\n    0: photos,\n    1: setPhotos\n  } = useState([]);\n  const {\n    0: show,\n    1: setShow\n  } = useState(false); // error modal for missing required fields\n\n  const {\n    0: showErr,\n    1: setShowErr\n  } = useState(false);\n  const {\n    0: Err,\n    1: setErr\n  } = useState(\"Missing required field: Name and Description\");\n  const {\n    0: showDescModal,\n    1: setShowDescModal\n  } = useState(false);\n  const {\n    0: showWoModal,\n    1: setShowWoModal\n  } = useState(false);\n  const {\n    0: showClientModal,\n    1: setShowClientModal\n  } = useState(false);\n  const {\n    0: showMachineModal,\n    1: setShowMachineModal\n  } = useState(false);\n  const {\n    0: showParentModal,\n    1: setShowParentModal\n  } = useState(false);\n  const {\n    0: showCameraModal,\n    1: setShowCameraModal\n  } = useState(false);\n  const {\n    0: showSaveModal,\n    1: setShowSaveModal\n  } = useState(false);\n  const {\n    0: machineSelectionModal,\n    1: setMachineSelectionModal\n  } = useState(false);\n  const {\n    0: selectedDesc,\n    1: setSelectedDesc\n  } = useState(0);\n  const {\n    0: selectedClient,\n    1: setSelectedClient\n  } = useState(null);\n  const {\n    0: selectedMachine,\n    1: setSelectedMachine\n  } = useState(null);\n  const {\n    0: selectedCurrentMachine,\n    1: setSelectedCurrentMachine\n  } = useState(null);\n  const {\n    0: selectedParent,\n    1: setSelectedParent\n  } = useState(null);\n  const {\n    0: TheMachine,\n    1: setTheMachine\n  } = useState(null);\n  const {\n    0: machineOptions,\n    1: setMachineOptions\n  } = useState([]);\n  const {\n    0: search,\n    1: setSearch\n  } = useState(\"\");\n  const {\n    0: capturedPhoto,\n    1: setCapturedPhoto\n  } = useState(null);\n  const {\n    0: cameraFacing,\n    1: setCameraFacing\n  } = useState(\"environment\");\n  const {\n    0: addToWebsite,\n    1: setAddToWebsite\n  } = useState(false);\n  const {\n    0: machinePick,\n    1: setMachinePick\n  } = useState(false);\n  const {\n    0: freqItem,\n    1: setFreqItem\n  } = useState(0);\n  const {\n    0: usagePastYear,\n    1: setUsagePastYear\n  } = useState(0);\n  const {\n    0: machineFrequency,\n    1: setMachineFrequency\n  } = useState(0); // For extra (dimensions/price/DOM) section collapse.\n\n  const {\n    0: showExtra,\n    1: setShowExtra\n  } = useState(false);\n  const {\n    0: trackerCatalog,\n    1: setTrackerCatalog\n  } = useState({\n    modalities: [],\n    oemsByModality: {},\n    modelsByModalityOem: {},\n    meta: {}\n  });\n  const {\n    0: trackerLoading,\n    1: setTrackerLoading\n  } = useState(false); // For PN/SN \"add new\" functionality.\n\n  const {\n    0: addingNewPn,\n    1: setAddingNewPn\n  } = useState(false);\n  const {\n    0: newPn,\n    1: setNewPn\n  } = useState(\"\");\n  const {\n    0: addingNewSn,\n    1: setAddingNewSn\n  } = useState(false);\n  const {\n    0: newSn,\n    1: setNewSn\n  } = useState(\"\"); // For browsing photos.\n\n  const browseInputRef = useRef(null);\n  const cloneSeedRef = useRef(null); // Inside your NewItem component:\n\n  const {\n    0: loading,\n    1: setLoading\n  } = useState(false);\n  const {\n    0: savedDocId,\n    1: setSavedDocId\n  } = useState(null);\n  const isMountedRef = useRef(true);\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  const safeSetLoading = value => {\n    if (isMountedRef.current) setLoading(value);\n  };\n\n  const withTimeout = (promise, ms, label = \"Operation\") => new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      reject(new Error(`${label} timed out after ${Math.ceil(ms / 1000)}s`));\n    }, ms);\n    promise.then(result => {\n      clearTimeout(timer);\n      resolve(result);\n    }).catch(err => {\n      clearTimeout(timer);\n      reject(err);\n    });\n  });\n\n  const shallowClean = obj => {\n    const newObj = {};\n    Object.keys(obj || {}).forEach(key => {\n      newObj[key] = obj[key] === undefined ? \"\" : obj[key];\n    });\n    return newObj;\n  };\n\n  const normalizeSelection = value => {\n    if (Array.isArray(value)) {\n      return value.map(v => String(v).trim()).filter(v => v && v.toLowerCase() !== \"n/a\");\n    }\n\n    if (value == null) return [];\n    const normalized = String(value).trim();\n    if (!normalized || normalized.toLowerCase() === \"n/a\") return [];\n    return [normalized];\n  };\n\n  const uniqueSelection = values => Array.from(new Set(values || []));\n\n  const selectionToStoredValue = values => {\n    const cleaned = uniqueSelection(normalizeSelection(values));\n    if (cleaned.length === 0) return \"\";\n    if (cleaned.length === 1) return cleaned[0];\n    return cleaned;\n  };\n\n  const selectionToPrintValue = values => {\n    const cleaned = uniqueSelection(normalizeSelection(values));\n    if (cleaned.length === 0) return \"\";\n    if (cleaned.length === 1) return cleaned[0];\n    return \"Multi\";\n  };\n\n  const mergeOptionsWithSelection = (options, selected) => {\n    const map = new Map();\n    (options || []).forEach(value => {\n      if (value == null) return;\n      const normalized = String(value).trim();\n      if (!normalized) return;\n      map.set(normalized.toLowerCase(), normalized);\n    });\n    (selected || []).forEach(value => {\n      if (value == null) return;\n      const normalized = String(value).trim();\n      if (!normalized) return;\n      map.set(normalized.toLowerCase(), normalized);\n    });\n    return Array.from(map.values());\n  };\n\n  useEffect(() => {\n    if (!router.isReady) return;\n    const cloneFrom = router.query.cloneFrom;\n    if (!cloneFrom || cloneSeedRef.current === cloneFrom) return;\n    cloneSeedRef.current = cloneFrom;\n    let cancelled = false;\n    const db = firebase.firestore();\n\n    const toArray = value => {\n      if (Array.isArray(value)) return value;\n      if (value === null || value === undefined || value === \"\") return [\"\"];\n      return [value];\n    };\n\n    const toDateString = value => {\n      if (!value) return \"\";\n\n      if (value !== null && value !== void 0 && value.toDate) {\n        const d = value.toDate();\n        return isNaN(d.getTime()) ? \"\" : d.toISOString().slice(0, 10);\n      }\n\n      if (value instanceof Date) {\n        return isNaN(value.getTime()) ? \"\" : value.toISOString().slice(0, 10);\n      }\n\n      if (typeof value === \"string\") {\n        if (/^\\d{4}-\\d{2}-\\d{2}/.test(value)) return value.slice(0, 10);\n        const parsed = Date.parse(value);\n        if (!isNaN(parsed)) return new Date(parsed).toISOString().slice(0, 10);\n      }\n\n      return \"\";\n    };\n\n    const resolveDoc = async (ref, collection) => {\n      if (!ref) return null;\n\n      try {\n        if (typeof ref.get === \"function\") {\n          const doc = await ref.get();\n          return doc.exists ? _objectSpread({\n            id: doc.id\n          }, doc.data()) : null;\n        }\n\n        if (typeof ref === \"string\") {\n          const doc = await db.collection(collection).doc(ref).get();\n          return doc.exists ? _objectSpread({\n            id: doc.id\n          }, doc.data()) : null;\n        }\n\n        if (ref !== null && ref !== void 0 && ref.id) {\n          const doc = await db.collection(collection).doc(ref.id).get();\n          return doc.exists ? _objectSpread({\n            id: doc.id\n          }, doc.data()) : null;\n        }\n\n        if (ref !== null && ref !== void 0 && ref.path) {\n          const doc = await db.doc(ref.path).get();\n          return doc.exists ? _objectSpread({\n            id: doc.id\n          }, doc.data()) : null;\n        }\n      } catch (error) {\n        console.error(`Clone ref lookup failed (${collection})`, error);\n      }\n\n      return null;\n    };\n\n    (async () => {\n      try {\n        const doc = await db.collection(\"Test\").doc(cloneFrom).get();\n\n        if (!doc.exists) {\n          if (!cancelled) {\n            setErr(\"Clone source not found.\");\n            setShowErr(true);\n          }\n\n          return;\n        }\n\n        const data = doc.data() || {};\n        const dateValue = toDateString(data.date);\n        const arrivalValue = toDateString(data.arrival_date) || (typeof data.arrival_date === \"string\" ? data.arrival_date : \"\");\n\n        if (!cancelled) {\n          setItems(prev => {\n            var _data$price, _data$status, _data$poNumber, _data$trackingNumber, _data$length, _data$width, _data$height;\n\n            return _objectSpread(_objectSpread({}, prev), {}, {\n              name: data.name || \"\",\n              pn: toArray(data.pn),\n              sn: toArray(data.sn),\n              localSN: \"\",\n              date: dateValue || prev.date || \"\",\n              price: (_data$price = data.price) !== null && _data$price !== void 0 ? _data$price : \"\",\n              status: (_data$status = data.status) !== null && _data$status !== void 0 ? _data$status : \"\",\n              poNumber: (_data$poNumber = data.poNumber) !== null && _data$poNumber !== void 0 ? _data$poNumber : \"\",\n              trackingNumber: (_data$trackingNumber = data.trackingNumber) !== null && _data$trackingNumber !== void 0 ? _data$trackingNumber : \"\",\n              length: (_data$length = data.length) !== null && _data$length !== void 0 ? _data$length : \"\",\n              width: (_data$width = data.width) !== null && _data$width !== void 0 ? _data$width : \"\",\n              height: (_data$height = data.height) !== null && _data$height !== void 0 ? _data$height : \"\",\n              arrival_date: arrivalValue || \"\",\n              visible: data.visible !== undefined ? data.visible : true\n            });\n          });\n          setDescriptions(Array.isArray(data.descriptions) && data.descriptions.length ? data.descriptions : [{\n            description: \"\",\n            date: \"\"\n          }]);\n          setWorkOrders(Array.isArray(data.workOrders) && data.workOrders.length ? data.workOrders : [{\n            workOrder: \"\",\n            date: \"\"\n          }]);\n          setDOM(data.DOM || \"\");\n          setNewLocalFrom(data.newLocalFrom || {\n            region: \"\",\n            section: {\n              letter: \"\",\n              number: \"\"\n            },\n            bin: \"\",\n            pallet: \"\"\n          });\n          setNewLocalCurrent(data.newLocalCurrent || {\n            region: \"\",\n            section: {\n              letter: \"\",\n              number: \"\"\n            },\n            bin: \"\",\n            pallet: \"\"\n          });\n          setAddToWebsite(Boolean(data.addedToWebsite));\n          setSavedDocId(null);\n          setSelectedDesc(0);\n        }\n\n        if (data.TheMachine && !cancelled) {\n          setTheMachine(data.TheMachine);\n          setMachineFieldsInitialized(false);\n\n          if (!selectedOems.length) {\n            setSelectedOems(uniqueSelection(normalizeSelection(data.TheMachine.oem || data.TheMachine.OEM)));\n          }\n\n          if (!selectedModalities.length) {\n            setSelectedModalities(uniqueSelection(normalizeSelection(data.TheMachine.modality || data.TheMachine.Modality)));\n          }\n\n          if (!selectedModels.length) {\n            setSelectedModels(uniqueSelection(normalizeSelection(data.TheMachine.model || data.TheMachine.Model)));\n          }\n        }\n\n        const parentDoc = await resolveDoc(data.Parent, \"Test\");\n\n        if (parentDoc && !cancelled) {\n          setSelectedParent({\n            id: parentDoc.id,\n            name: parentDoc.name || \"\"\n          });\n        }\n\n        const clientFromDoc = await resolveDoc(data.ClientFrom, \"Client\");\n\n        if (clientFromDoc && !cancelled) {\n          setSelectedClientFrom(_objectSpread({\n            id: clientFromDoc.id\n          }, clientFromDoc));\n        }\n\n        const clientCurrentDoc = await resolveDoc(data.ClientCurrent, \"Client\");\n\n        if (clientCurrentDoc && !cancelled) {\n          setSelectedClientCurrent(_objectSpread({\n            id: clientCurrentDoc.id\n          }, clientCurrentDoc));\n        }\n\n        const machineFromDoc = await resolveDoc(data.MachineFrom || data.Machine, \"Machine\");\n\n        if (machineFromDoc && !cancelled) {\n          setSelectedMachine({\n            id: machineFromDoc.id,\n            name: machineFromDoc.name || machineFromDoc.Model || \"\"\n          });\n\n          if (!data.TheMachine) {\n            setTheMachine(machineFromDoc);\n            setMachineFieldsInitialized(false);\n          }\n        }\n\n        const machineCurrentDoc = await resolveDoc(data.MachineCurrent || data.CurrentMachine, \"Machine\");\n\n        if (machineCurrentDoc && !cancelled) {\n          setSelectedCurrentMachine({\n            id: machineCurrentDoc.id,\n            name: machineCurrentDoc.name || machineCurrentDoc.Model || \"\"\n          });\n\n          if (!data.TheMachine && !machineFromDoc) {\n            setTheMachine(machineCurrentDoc);\n            setMachineFieldsInitialized(false);\n          }\n        }\n      } catch (error) {\n        console.error(\"Clone load failed:\", error);\n\n        if (!cancelled) {\n          setErr(\"Failed to load clone data.\");\n          setShowErr(true);\n        }\n      }\n    })();\n\n    return () => {\n      cancelled = true;\n    };\n  }, [router.isReady, router.query.cloneFrom, selectedOems, selectedModalities, selectedModels]); // -------------------- Since this is \"add\" mode, we do not fetch an existing document.\n  // However, we still fetch global PN and SN options and clients for selection.\n\n  useEffect(() => {\n    async function fetchClientsData() {\n      try {\n        const clientsData = await fetchClients();\n        console.log(\"Clients:\", clientsData);\n        setClients(clientsData);\n      } catch (error) {\n        console.error(\"Error fetching clients: \", error);\n      }\n    }\n\n    fetchClientsData();\n  }, []);\n  const loadTracker = useCallback(async (force = false) => {\n    if (trackerLoading) return;\n    if (!force && trackerCatalog.modalities.length) return;\n    setTrackerLoading(true);\n\n    try {\n      const catalog = await fetchTrackerCatalog();\n      setTrackerCatalog(catalog);\n    } catch (error) {\n      console.error(\"Failed to load tracker catalog:\", error);\n    } finally {\n      setTrackerLoading(false);\n    }\n  }, [trackerLoading, trackerCatalog.modalities.length]);\n  useEffect(() => {\n    loadTracker();\n  }, [loadTracker]);\n  const allOemOptions = useMemo(() => buildAllOems(trackerCatalog), [trackerCatalog]);\n  const modelOptions = useMemo(() => buildModelsForSelection(trackerCatalog, selectedModalities, selectedOems), [trackerCatalog, selectedModalities, selectedOems]); // Keep selected models even if they are not in the catalog yet.\n  // The tracker sync will add any missing models automatically.\n\n  const modalityOptionsForUI = useMemo(() => mergeOptionsWithSelection(trackerCatalog.modalities, selectedModalities), [trackerCatalog.modalities, selectedModalities]);\n  const oemOptionsForUI = useMemo(() => mergeOptionsWithSelection(allOemOptions, selectedOems), [allOemOptions, selectedOems]);\n  const modelOptionsForUI = useMemo(() => mergeOptionsWithSelection(modelOptions, selectedModels), [modelOptions, selectedModels]); // Tracker updates are only performed on Save.\n\n  const loadPnSnOptions = async () => {\n    if (pnSnLoaded || pnSnLoading) return;\n    setPnSnLoading(true);\n\n    try {\n      const db = firebase.firestore();\n      const snapshot = await db.collection(\"Test\").orderBy(firebase.firestore.FieldPath.documentId()).limit(500).get();\n      let pnSet = new Set();\n      let snSet = new Set();\n      snapshot.forEach(doc => {\n        const data = doc.data();\n\n        if (Array.isArray(data.pn)) {\n          data.pn.forEach(pn => pn && pnSet.add(pn));\n        } else if (data.pn) {\n          pnSet.add(data.pn);\n        }\n\n        if (Array.isArray(data.sn)) {\n          data.sn.forEach(sn => sn && snSet.add(sn));\n        } else if (data.sn) {\n          snSet.add(data.sn);\n        }\n      });\n      setPnOptions([...pnSet]);\n      setSnOptions([...snSet]);\n      setPnSnLoaded(true);\n    } catch (error) {\n      console.error(\"Error fetching PN/SN options:\", error);\n    } finally {\n      setPnSnLoading(false);\n    }\n  };\n\n  const {\n    0: machineFieldsInitialized,\n    1: setMachineFieldsInitialized\n  } = useState(false);\n  useEffect(() => {\n    if (!machineFieldsInitialized && (TheMachine || selectedCurrentMachine || selectedMachine)) {\n      const updatedFields = updateMachineFields(TheMachine, selectedCurrentMachine, selectedMachine); // Only set fields if they are empty\n\n      if (!selectedOems.length) {\n        setSelectedOems(uniqueSelection(normalizeSelection(updatedFields.oem)));\n      }\n\n      if (!selectedModalities.length) {\n        setSelectedModalities(uniqueSelection(normalizeSelection(updatedFields.modality)));\n      }\n\n      if (!selectedModels.length) {\n        setSelectedModels(uniqueSelection(normalizeSelection(updatedFields.model)));\n      }\n\n      setMachineFieldsInitialized(true);\n    }\n  }, [TheMachine, selectedCurrentMachine, selectedMachine, machineFieldsInitialized, selectedOems.length, selectedModalities.length, selectedModels.length]);\n  const {\n    0: signal,\n    1: setSignal\n  } = useState(null);\n  useEffect(() => {\n    if (router.isReady) {\n      setSignal(router.query.signal || null);\n    }\n  }, [router.isReady, router.query.signal]); // -------------------- Handlers for PN and SN dropdowns\n  // PN: when a user selects an existing PN value.\n\n  const handlePnSelect = e => {\n    const selected = e.target.value;\n    setItems(prev => {\n      let updatedPn = Array.isArray(prev.pn) ? [...prev.pn] : [];\n      updatedPn[0] = selected;\n      return _objectSpread(_objectSpread({}, prev), {}, {\n        pn: updatedPn\n      });\n    });\n  };\n\n  const handlePnChange = (index, value) => {\n    setItems(prev => {\n      const newPn = [...prev.pn];\n      newPn[index] = value;\n      return _objectSpread(_objectSpread({}, prev), {}, {\n        pn: newPn\n      });\n    });\n  };\n\n  const addPn = () => {\n    if (newPn.trim() !== \"\") {\n      setItems(prev => _objectSpread(_objectSpread({}, prev), {}, {\n        pn: [...prev.pn, newPn.trim()]\n      }));\n    }\n\n    setNewPn(\"\");\n    setAddingNewPn(false);\n  }; // SN: when a user selects an existing SN value.\n\n\n  const handleSnSelect = e => {\n    const selected = e.target.value;\n    setItems(prev => {\n      let updatedSn = Array.isArray(prev.sn) ? [...prev.sn] : [];\n      updatedSn[0] = selected;\n      return _objectSpread(_objectSpread({}, prev), {}, {\n        sn: updatedSn\n      });\n    });\n  };\n\n  const handleSnChange = (index, value) => {\n    setItems(prev => {\n      const newSn = [...prev.sn];\n      newSn[index] = value;\n      return _objectSpread(_objectSpread({}, prev), {}, {\n        sn: newSn\n      });\n    });\n  };\n\n  const addSn = () => {\n    if (newSn.trim() !== \"\") {\n      setItems(prev => _objectSpread(_objectSpread({}, prev), {}, {\n        sn: [...prev.sn, newSn.trim()]\n      }));\n    }\n\n    setNewSn(\"\");\n    setAddingNewSn(false);\n  }; // -------------------- Photo Browse Handlers\n\n\n  const handleBrowsePhotos = () => {\n    if (browseInputRef.current) {\n      browseInputRef.current.click();\n    }\n  };\n\n  const handleFilesSelected = e => {\n    const files = e.target.files;\n\n    if (files.length) {\n      const newPhotos = [];\n\n      for (let i = 0; i < files.length; i++) {\n        newPhotos.push({\n          file: files[i],\n          url: URL.createObjectURL(files[i])\n        });\n      }\n\n      setPhotos(prevPhotos => [...prevPhotos, ...newPhotos]);\n    }\n\n    e.target.value = \"\";\n  }; // -------------------- Photo Capture Handlers remain as in your index.js\n\n\n  const handleCapture = (err, result) => {\n    if (result) {\n      setCapturedPhoto(result);\n    }\n  };\n\n  const capturePhoto = () => {\n    const video = document.querySelector(\"video\");\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = video.videoWidth;\n    canvas.height = video.videoHeight;\n    const context = canvas.getContext(\"2d\");\n    context.drawImage(video, 0, 0, canvas.width, canvas.height);\n    canvas.toBlob(blob => {\n      setCapturedPhoto(blob);\n    }, \"image/png\");\n  };\n\n  const savePhoto = () => {\n    setPhotos(prevPhotos => [...prevPhotos, {\n      file: capturedPhoto,\n      url: URL.createObjectURL(capturedPhoto)\n    }]);\n    setCapturedPhoto(null);\n    setShowCameraModal(false);\n  };\n\n  const removePhoto = index => {\n    setPhotos(photos.filter((_, i) => i !== index));\n  }; // -------------------- Modal Handlers\n\n\n  const handleClose = () => setShow(false);\n\n  const handleShow = () => setShow(true);\n\n  const handleCloseErr = () => setShowErr(false);\n\n  const handleShowErr = () => setShowErr(true);\n\n  const handleCloseSaveModal = () => setShowSaveModal(false);\n\n  const handleShowSaveModal = () => setShowSaveModal(true);\n\n  const handleCloseDescModal = () => setShowDescModal(false);\n\n  const handleShowDescModal = () => setShowDescModal(true);\n\n  const handleCloseWoModal = () => setShowWoModal(false);\n\n  const handleShowWoModal = () => setShowWoModal(true);\n\n  const handleCloseClientModal = () => setShowClientModal(false);\n\n  const handleShowClientModal = () => setShowClientModal(true);\n\n  const handleCloseMachineModal = () => setShowMachineModal(false);\n\n  const handleShowMachineModal = () => {\n    setShowMachineModal(true);\n    setShowClientModal(false);\n  };\n\n  const handleCloseParentModal = () => setShowParentModal(false);\n\n  const handleShowParentModal = () => setShowParentModal(true);\n\n  const handleDeleteOemOption = async oemName => {\n    if (!oemName) return;\n\n    try {\n      await deleteTrackerOem({\n        oem: oemName,\n        catalog: trackerCatalog\n      });\n      setSelectedOems(prev => prev.filter(value => value !== oemName));\n      await loadTracker(true);\n    } catch (error) {\n      console.error(\"Failed to delete OEM:\", error);\n    }\n  };\n\n  const handleDeleteModelOption = async modelName => {\n    if (!modelName) return;\n    if (!selectedModalities.length || !selectedOems.length) return;\n\n    try {\n      const ops = [];\n      selectedModalities.forEach(modalityValue => {\n        selectedOems.forEach(oemValue => {\n          ops.push(deleteTrackerModel({\n            modality: modalityValue,\n            oem: oemValue,\n            model: modelName,\n            catalog: trackerCatalog\n          }));\n        });\n      });\n      await Promise.allSettled(ops);\n      setSelectedModels(prev => prev.filter(value => value !== modelName));\n      await loadTracker(true);\n    } catch (error) {\n      console.error(\"Failed to delete model:\", error);\n    }\n  }; // -------------------- Work Orders / Descriptions Handlers (unchanged)\n\n\n  const addDescription = () => {\n    setDescriptions([...descriptions, {\n      description: \"\",\n      date: \"\"\n    }]);\n  };\n\n  const removeDescription = index => {\n    setDescriptions(descriptions.filter((_, i) => i !== index));\n  };\n\n  const handleDescriptionChange = (index, field, value) => {\n    const newDescriptions = descriptions.map((desc, i) => i === index ? _objectSpread(_objectSpread({}, desc), {}, {\n      [field]: value\n    }) : desc);\n    setDescriptions(newDescriptions);\n  };\n\n  const addWorkOrder = () => {\n    setWorkOrders([...workOrders, {\n      workOrder: \"\",\n      date: \"\"\n    }]);\n  };\n\n  const removeWorkOrder = index => {\n    setWorkOrders(workOrders.filter((_, i) => i !== index));\n  };\n\n  const handleWorkOrderChange = (index, field, value) => {\n    const newWorkOrders = workOrders.map((wo, i) => i === index ? _objectSpread(_objectSpread({}, wo), {}, {\n      [field]: value\n    }) : wo);\n    setWorkOrders(newWorkOrders);\n  };\n\n  const listDescriptions = () => {\n    setShowDescModal(true);\n  };\n\n  const selectDescription = index => {\n    setSelectedDesc(index);\n    setShowDescModal(false);\n  }; // -------------------- Machine Selection (unchanged)\n\n\n  const handleClientInfo = async clientId => {\n    // Clear any previously selected machine/local loc for the branch\n    if (machinePick) {\n      setSelectedMachine(null);\n      setShowLocalLocFrom(false);\n    } else {\n      setSelectedCurrentMachine(null);\n      setShowLocalLocCurrent(false);\n    }\n\n    const db = firebase.firestore();\n    const clientDoc = await db.collection(\"Client\").doc(clientId).get();\n\n    if (clientDoc.exists) {\n      const clientData = clientDoc.data();\n\n      if (machinePick) {\n        setSelectedClientFrom(_objectSpread({\n          id: clientDoc.id\n        }, clientData));\n      } else {\n        setSelectedClientCurrent(_objectSpread({\n          id: clientDoc.id\n        }, clientData));\n      }\n\n      if (clientData.name === \"SoCalWarehouse\") {\n        if (machinePick) setShowLocalLocFrom(true);else setShowLocalLocCurrent(true);\n      } // Fetch machines for this client:\n\n\n      const machinePromises = clientData.machines.map(machineRef => machineRef.get());\n      const machineDocs = await Promise.all(machinePromises);\n      const machines = machineDocs.map(machineDoc => _objectSpread({\n        id: machineDoc.id\n      }, machineDoc.data()));\n      setMachineOptions(machines);\n      handleCloseClientModal();\n    }\n  };\n\n  const fetchMachine = async machineId => {\n    const db = firebase.firestore();\n    const doc = await db.collection(\"Machine\").doc(machineId).get();\n\n    if (doc.exists) {\n      const machineData = doc.data();\n      setTheMachine(machineData); // Ensure OEM, Modality, and Model update properly only if necessary\n\n      if (!selectedOems.length) {\n        setSelectedOems(uniqueSelection(normalizeSelection(machineData.oem || machineData.OEM)));\n      }\n\n      if (!selectedModalities.length) {\n        setSelectedModalities(uniqueSelection(normalizeSelection(machineData.modality || machineData.Modality)));\n      }\n\n      if (!selectedModels.length) {\n        setSelectedModels(uniqueSelection(normalizeSelection(machineData.model || machineData.Model)));\n      } // Set machine frequency count\n\n\n      const machinesSnapshot = await db.collection(\"Machine\").where(\"Model\", \"==\", machineData.Model || machineData.model).get();\n      setMachineFrequency(machinesSnapshot.size);\n    } else {\n      console.error(\"Machine not found\");\n    }\n  }; // -------------------- Frequency/Usage (unchanged)\n\n\n  const calculateItemFrequencyAndUsage = async pn => {\n    const db = firebase.firestore();\n    const currentDate = new Date();\n    const oneYearAgo = new Date();\n    oneYearAgo.setFullYear(currentDate.getFullYear() - 1);\n    const itemsSnapshot = await db.collection(\"Test\").where(\"pn\", \"==\", pn).get();\n    setFreqItem(itemsSnapshot.size);\n    let usagePastYear = 0;\n    itemsSnapshot.forEach(doc => {\n      const itemData = doc.data();\n      itemData.workOrders.forEach(workOrder => {\n        const workOrderDate = new Date(workOrder.date);\n\n        if (workOrderDate >= oneYearAgo && workOrderDate <= currentDate) {\n          usagePastYear++;\n        }\n      });\n    });\n    setUsagePastYear(usagePastYear);\n  }; // -------------------- Photo Upload (unchanged)\n\n\n  const uploadPhotos = async docID => {\n    const storageRef = firebase.storage().ref();\n\n    for (let i = 0; i < photos.length; i++) {\n      if (photos[i].file) {\n        const photoRef = storageRef.child(`Parts/${docID}/${docID}${i === 0 ? \".jpg\" : `.${i + 1}.jpg`}`);\n        const metadata = {\n          contentType: \"image/png\"\n        };\n        await photoRef.put(photos[i].file, metadata);\n        const url = await photoRef.getDownloadURL();\n        photos[i].url = url;\n      }\n    }\n  }; // -------------------- Submission Handler\n  // For NewItem, only require Name and Description.\n\n\n  async function handleSubmit(event) {\n    event.preventDefault();\n\n    if (!isReadyForActions) {\n      handleShow();\n    } else {\n      safeSetLoading(true); // start loading before async work\n\n      try {\n        const docId = await toSend();\n\n        if (!docId) {\n          setErr(\"Save failed. Please try again.\");\n          setShowErr(true);\n        }\n      } catch (error) {\n        console.error(error);\n        setErr((error === null || error === void 0 ? void 0 : error.message) || \"Save failed.\");\n        setShowErr(true);\n      } finally {\n        safeSetLoading(false); // end loading after async work completes\n      }\n    }\n  }\n\n  async function toSend(redirect = true, options = {}) {\n    const {\n      id\n    } = router.query;\n    const db = firebase.firestore();\n    const {\n      forceNew = false\n    } = options;\n    const existingId = forceNew ? null : savedDocId || id || null; // Get the current authenticated user\n\n    const currentUser = firebase.auth().currentUser;\n    const userEmail = currentUser ? currentUser.email : \"unknown\"; // Always use the current state values for OEM, modality, and model.\n\n    const storedOem = selectionToStoredValue(selectedOems);\n    const storedModality = selectionToStoredValue(selectedModalities);\n    const storedModel = selectionToStoredValue(selectedModels);\n\n    const machineData = _objectSpread(_objectSpread({}, TheMachine || {}), {}, {\n      oem: storedOem,\n      OEM: storedOem,\n      modality: storedModality,\n      Modality: storedModality,\n      model: storedModel,\n      Model: storedModel\n    });\n\n    const formattedItems = _objectSpread(_objectSpread({}, items), {}, {\n      descriptions,\n      workOrders\n    }); // Remove any unused fields.\n\n\n    formattedItems.status = items.status || \"\";\n    formattedItems.nameLower = (items.name || \"\").toLowerCase();\n    formattedItems.nameTokens = buildNameTokens(items.name);\n    formattedItems.DOM = DOM; // Date of Manufacture\n\n    const fromDetails = buildLocalLocObject(newLocalFrom);\n    const currentDetails = buildLocalLocObject(newLocalCurrent);\n\n    if (Object.keys(fromDetails).length) {\n      formattedItems.newLocalFrom = fromDetails;\n      formattedItems.localLocFrom = formatLoc(newLocalFrom) || \"\";\n    } else {\n      formattedItems.localLocFrom = \"\";\n      formattedItems.newLocalFrom = {};\n    }\n\n    if (Object.keys(currentDetails).length) {\n      formattedItems.newLocalCurrent = currentDetails;\n      formattedItems.localLocCurrent = formatLoc(newLocalCurrent) || \"\";\n    } else {\n      formattedItems.localLocCurrent = \"\";\n      formattedItems.newLocalCurrent = {};\n    }\n\n    formattedItems.date = items.date || \"\";\n    formattedItems.arrival_date = items.arrival_date || \"\"; // NEW: Arrival Date\n\n    formattedItems.poNumber = items.poNumber || \"\";\n    formattedItems.trackingNumber = items.trackingNumber || \"\";\n    formattedItems.TheMachine = machineData || {};\n    formattedItems.addedToWebsite = addToWebsite;\n    formattedItems.visible = items.visible; // Add the current user's email under the \"user\" field\n\n    formattedItems.user = userEmail;\n    formattedItems.lastEdited = userEmail; // Clean pn and sn arrays to replace undefined values with an empty string.\n\n    formattedItems.pn = (items.pn || []).map(value => value === undefined ? \"\" : value);\n    formattedItems.sn = (items.sn || []).map(value => value === undefined ? \"\" : value); // Set machine references for each branch.\n\n    if (selectedMachine && selectedMachine.id) {\n      formattedItems.MachineFrom = db.collection(\"Machine\").doc(selectedMachine.id);\n    }\n\n    if (selectedCurrentMachine && selectedCurrentMachine.id) {\n      formattedItems.MachineCurrent = db.collection(\"Machine\").doc(selectedCurrentMachine.id);\n    } // ***** NEW: Set client references for each branch *****\n\n\n    if (selectedClientFrom && selectedClientFrom.id) {\n      formattedItems.ClientFrom = db.collection(\"Client\").doc(selectedClientFrom.id);\n    }\n\n    if (selectedClientCurrent && selectedClientCurrent.id) {\n      formattedItems.ClientCurrent = db.collection(\"Client\").doc(selectedClientCurrent.id);\n    } // ******************************************************\n\n\n    if (selectedParent && selectedParent.id) {\n      formattedItems.Parent = db.collection(\"Test\").doc(selectedParent.id);\n    } // Only add dateCreated if this is a new document\n\n\n    if (!existingId) {\n      formattedItems.dateCreated = new Date().toISOString().split(\"T\")[0]; // \"YYYY-MM-DD\"\n    } // --- LOCAL SN LOGIC ---\n\n\n    let docId = existingId;\n\n    const queueAssociationUpdates = targetDocId => {\n      const updates = [];\n\n      if (selectedMachine && selectedMachine.id) {\n        updates.push(db.collection(\"Machine\").doc(selectedMachine.id).update({\n          associatedParts: firebase.firestore.FieldValue.arrayUnion(db.collection(\"Test\").doc(targetDocId))\n        }));\n      }\n\n      if (selectedCurrentMachine && selectedCurrentMachine.id) {\n        updates.push(db.collection(\"Machine\").doc(selectedCurrentMachine.id).update({\n          associatedParts: firebase.firestore.FieldValue.arrayUnion(db.collection(\"Test\").doc(targetDocId))\n        }));\n      }\n\n      if (updates.length) {\n        Promise.allSettled(updates).then(results => {\n          results.forEach(result => {\n            if (result.status === \"rejected\") {\n              console.error(\"Error updating associatedParts:\", result.reason);\n            }\n          });\n        });\n      }\n    };\n\n    const queuePhotoUpload = targetDocId => {\n      const hasNewPhotos = photos.some(photo => photo && photo.file);\n      if (!hasNewPhotos) return;\n      uploadPhotos(targetDocId).catch(error => {\n        console.error(\"Error uploading photos:\", error);\n      });\n    };\n\n    try {\n      if (docId) {\n        // Check if a localSN is provided and if it differs from the current docId.\n        const newDocId = items.localSN && items.localSN.trim() !== \"\" ? items.localSN.trim() : docId;\n\n        if (docId !== newDocId) {\n          // Migrate: Create a new document with the newDocId.\n          await withTimeout(db.collection(\"Test\").doc(newDocId).set(formattedItems), 45000, \"Firestore save\");\n          queueAssociationUpdates(newDocId);\n          queuePhotoUpload(newDocId); // Delete the old document.\n\n          try {\n            await withTimeout(db.collection(\"Test\").doc(docId).delete(), 20000, \"Delete old item\");\n          } catch (deleteError) {\n            console.error(\"Error deleting old item:\", deleteError);\n          } // Set docId to the new document ID.\n\n\n          docId = newDocId;\n        } else {\n          // Deep-clean the formattedItems to remove any undefined nested values.\n          const cleanFormattedItems = shallowClean(formattedItems);\n          await withTimeout(db.collection(\"Test\").doc(docId).update(cleanFormattedItems), 45000, \"Firestore save\");\n          queueAssociationUpdates(docId);\n          queuePhotoUpload(docId);\n        }\n      } else {\n        // For a new item, if localSN is provided, use it; otherwise, generate a custom ID.\n        docId = items.localSN && items.localSN.trim() !== \"\" ? items.localSN.trim() : generateCustomID();\n        await withTimeout(db.collection(\"Test\").doc(docId).set(formattedItems), 45000, \"Firestore save\");\n        queueAssociationUpdates(docId);\n        queuePhotoUpload(docId);\n      }\n\n      console.log(\"Item saved!\");\n\n      try {\n        const selections = {\n          modalities: selectedModalities,\n          oems: selectedOems,\n          models: selectedModels\n        };\n        const updated = await syncTrackerFromSelections({\n          selections,\n          catalog: trackerCatalog\n        });\n\n        if (updated) {\n          loadTracker(true);\n        }\n      } catch (error) {\n        console.error(\"Failed to sync tracker selections:\", error);\n      }\n\n      if (!forceNew) {\n        setSavedDocId(docId);\n      } // Redirect to the new URL using the new document id.\n\n\n      if (redirect) {\n        router.push(`/NewSearch/item/${docId}`);\n      } else {\n        // Optionally, show a save confirmation modal.\n        handleShowSaveModal();\n      }\n\n      return docId;\n    } catch (error) {\n      console.error(\"Error saving data:\", error);\n      return null;\n    }\n  }\n\n  const isReadyForActions = (items.name || \"\").trim() !== \"\" && (((_descriptions$selecte = descriptions[selectedDesc]) === null || _descriptions$selecte === void 0 ? void 0 : _descriptions$selecte.description) || \"\").trim() !== \"\";\n\n  const ensureSaved = async () => {\n    if (!isReadyForActions) {\n      handleShow();\n      return null;\n    }\n\n    if (savedDocId) return savedDocId;\n    const docId = await toSend(false);\n\n    if (!docId) {\n      setErr(\"Failed to save item before action.\");\n      setShowErr(true);\n    }\n\n    return docId;\n  }; // -------------------- Info Modal Handlers (unchanged)\n\n\n  const {\n    0: showInfoModal,\n    1: setShowInfoModal\n  } = useState(false);\n  const {\n    0: itemName,\n    1: setItemName\n  } = useState(\"\");\n\n  const handleShowInfoModal = async () => {\n    const db = firebase.firestore();\n\n    try {\n      const docId = savedDocId || router.query.id;\n\n      if (!docId) {\n        setErr(\"Save the item before viewing info.\");\n        setShowErr(true);\n        return;\n      }\n\n      const doc = await db.collection(\"Test\").doc(docId).get();\n\n      if (doc.exists) {\n        const data = doc.data();\n        setItemName(data.name || \"N/A\");\n        setShowInfoModal(true);\n      } else {\n        console.error(\"Item not found\");\n      }\n    } catch (error) {\n      console.error(\"Error fetching item info:\", error);\n    }\n  };\n\n  const handleCloseInfoModal = () => setShowInfoModal(false);\n\n  const handleCloseCameraModal = () => {\n    setShowCameraModal(false);\n    setCapturedPhoto(null);\n  };\n\n  const handleChange = field => event => {\n    const value = event.target ? event.target.value : event.value;\n    setItems(prevItems => _objectSpread(_objectSpread({}, prevItems), {}, {\n      [field]: value\n    }));\n  };\n\n  const mostRecentWorkOrder = workOrders && workOrders.length > 0 ? workOrders.reduce((latest, current) => {\n    const latestDate = new Date(latest.date);\n    const currentDate = new Date(current.date);\n    return currentDate > latestDate ? current : latest;\n  }, workOrders[0]) : {};\n\n  const handleShowCameraModal = () => {\n    setShowCameraModal(true);\n  };\n\n  const generateCustomID = () => {\n    const randomNum = Math.floor(10000 + Math.random() * 90000);\n    return `AIS${randomNum}`;\n  };\n\n  const handlePrint = async () => {\n    const docId = await ensureSaved();\n    if (!docId) return;\n    const payload = {\n      name: items.name,\n      pn: items.pn,\n      sn: items.sn,\n      wo: workOrders && workOrders.length > 0 ? workOrders[0].workOrder : \"\",\n      status: items.status,\n      local_sn: docId,\n      descriptions: descriptions,\n      date: items.date || new Date().toISOString().split(\"T\")[0],\n      DOM: DOM,\n      oem: selectionToPrintValue(selectedOems),\n      modality: selectionToPrintValue(selectedModalities),\n      model: selectionToPrintValue(selectedModels),\n      poNumber: items.poNumber,\n      arrival_date: items.arrival_date,\n      trackingNumber: items.trackingNumber\n    };\n    console.log(\"Payload for printing:\", payload);\n\n    try {\n      const response = await fetch(\"https://9d70-174-76-22-138.ngrok-free.app/print-label\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(payload)\n      });\n      const result = await response.json();\n      console.log(\"Print result:\", result);\n    } catch (error) {\n      console.error(\"Error printing label:\", error);\n    }\n  };\n\n  const handleSendToInflow = async () => {\n    try {\n      var _descriptions$selecte2;\n\n      const docId = await ensureSaved();\n      if (!docId) return;\n      const name = (items.name || \"\").trim();\n\n      if (!name) {\n        alert(\"Item needs a name before sending to inFlow.\");\n        return;\n      }\n\n      const description = (((_descriptions$selecte2 = descriptions[selectedDesc]) === null || _descriptions$selecte2 === void 0 ? void 0 : _descriptions$selecte2.description) || \"\").trim();\n      const imageUrls = photos.map(p => p.url).filter(Boolean);\n      const sku = docId.toString();\n      const arrivalISO = items.arrival_date ? new Date(items.arrival_date).toISOString().slice(0, 10) : \"\";\n      const pnStr = Array.isArray(items.pn) ? items.pn.filter(Boolean).join(\", \") : items.pn || \"\";\n      const snStr = Array.isArray(items.sn) ? items.sn.filter(Boolean).join(\", \") : items.sn || \"\";\n      const mostRecentWO = workOrders !== null && workOrders !== void 0 && workOrders.length ? workOrders.reduce((latest, cur) => new Date(cur.date) > new Date(latest.date) ? cur : latest) : {\n        workOrder: \"\",\n        date: \"\"\n      };\n      const customFields = {\n        custom1: selectionToPrintValue(selectedOems),\n        custom2: selectionToPrintValue(selectedModalities),\n        custom3: selectionToPrintValue(selectedModels),\n        custom4: (description || \"\").trim(),\n        custom5: (mostRecentWO.workOrder || \"\").trim(),\n        custom6: ((selectedClientFrom === null || selectedClientFrom === void 0 ? void 0 : selectedClientFrom.name) || \"\").trim(),\n        custom7: pnStr,\n        custom8: snStr,\n        custom9: arrivalISO,\n        custom10: ((selectedClientCurrent === null || selectedClientCurrent === void 0 ? void 0 : selectedClientCurrent.name) || \"\").trim()\n      };\n      const created = await InflowAPI.upsertProduct({\n        name,\n        description,\n        sku,\n        imageUrls,\n        customFields\n      });\n      alert(`Sent to inFlow successfully. ID: ${(created === null || created === void 0 ? void 0 : created.productId) || (created === null || created === void 0 ? void 0 : created.id) || \"(unknown)\"}`);\n    } catch (err) {\n      console.error(err);\n      alert(\"Error sending to inFlow: \" + err.message);\n    }\n  };\n\n  const handleBluefolderButton = async () => {\n    var _descriptions$selecte3;\n\n    const docId = await ensureSaved();\n    if (!docId) return;\n    const currentWorkOrder = workOrders && workOrders.length > 0 ? workOrders[0].workOrder : \"\";\n\n    if (!currentWorkOrder) {\n      alert(\"Please fill out the work order field before adding to BlueFolder.\");\n      return;\n    }\n\n    const payload = {\n      name: items.name,\n      pn: items.pn[0] || \"\",\n      sn: items.sn[0] || \"\",\n      status: items.status,\n      description: ((_descriptions$selecte3 = descriptions[selectedDesc]) === null || _descriptions$selecte3 === void 0 ? void 0 : _descriptions$selecte3.description) || \"\",\n      workOrder: currentWorkOrder,\n      localsn: docId\n    };\n\n    try {\n      const response = await fetch(\"https://9d70-174-76-22-138.ngrok-free.app/bluefolder\", {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify(payload)\n      });\n      const result = await response.json();\n      alert(\"BlueFolder service item added successfully!\");\n      console.log(\"BlueFolder result:\", result);\n    } catch (error) {\n      console.error(\"BlueFolder error:\", error);\n      alert(\"Error adding data to BlueFolder.\");\n    }\n  };\n\n  const handleAddToSlack = async (which = \"shipping\") => {\n    try {\n      var _sort$, _ref, _items$trackingNumber, _firebase$auth$curren, _json$debug, _json$debug2;\n\n      const docId = await ensureSaved();\n      if (!docId) return;\n      const safeName = ((items === null || items === void 0 ? void 0 : items.name) || docId || \"Untitled\").trim();\n      const title = `${safeName}${docId ? ` (${docId})` : \"\"}`;\n      const pn0 = Array.isArray(items === null || items === void 0 ? void 0 : items.pn) ? items.pn[0] : items === null || items === void 0 ? void 0 : items.pn;\n      const sn0 = Array.isArray(items === null || items === void 0 ? void 0 : items.sn) ? items.sn[0] : items === null || items === void 0 ? void 0 : items.sn;\n      const pn_sn = [pn0 && `PN: ${pn0}`, sn0 && `SN: ${sn0}`].filter(Boolean).join(\"  \");\n      const mostRecentWO = workOrders && workOrders.length ? (_sort$ = [...workOrders].sort((a, b) => new Date((b === null || b === void 0 ? void 0 : b.date) || 0) - new Date((a === null || a === void 0 ? void 0 : a.date) || 0))[0]) === null || _sort$ === void 0 ? void 0 : _sort$.workOrder : \"\";\n      const description = selectedDesc != null && descriptions !== null && descriptions !== void 0 && descriptions[selectedDesc] ? descriptions[selectedDesc].description || \"\" : (items === null || items === void 0 ? void 0 : items.description) || \"\";\n      const tracking = (_ref = (_items$trackingNumber = items === null || items === void 0 ? void 0 : items.trackingNumber) !== null && _items$trackingNumber !== void 0 ? _items$trackingNumber : items === null || items === void 0 ? void 0 : items.tracking) !== null && _ref !== void 0 ? _ref : \"\";\n      const local_sn = docId || (items === null || items === void 0 ? void 0 : items.localSN) || \"\";\n      const photoUrls = Array.isArray(photos) ? photos.map(p => p === null || p === void 0 ? void 0 : p.url).filter(Boolean) : [];\n      const idToken = await ((_firebase$auth$curren = firebase.auth().currentUser) === null || _firebase$auth$curren === void 0 ? void 0 : _firebase$auth$curren.getIdToken());\n      const resp = await fetch(\"/api/slack/add-to-list\", {\n        method: \"POST\",\n        headers: _objectSpread({\n          \"Content-Type\": \"application/json\"\n        }, idToken ? {\n          Authorization: `Bearer ${idToken}`\n        } : {}),\n        body: JSON.stringify({\n          listKey: which,\n          title,\n          pn_sn,\n          work_order: mostRecentWO || \"\",\n          local_sn,\n          tracking,\n          description: (description || \"\").trim(),\n          photoUrls\n        })\n      });\n      const json = await resp.json();\n      console.log(\"[SLACK][handleAddToSlack] response:\", json);\n      if (json !== null && json !== void 0 && (_json$debug = json.debug) !== null && _json$debug !== void 0 && _json$debug.steps) console.table(json.debug.steps);\n      if (json !== null && json !== void 0 && (_json$debug2 = json.debug) !== null && _json$debug2 !== void 0 && _json$debug2.photos) console.table(json.debug.photos);\n\n      if (!resp.ok || !(json !== null && json !== void 0 && json.ok)) {\n        setErr(`Slack add failed: ${(json === null || json === void 0 ? void 0 : json.error) || \"unknown error\"}`);\n        setShowErr(true);\n        return;\n      }\n\n      alert(`Added to Slack ${which === \"shipping\" ? \"Shipping\" : which === \"receiving\" ? \"Receiving\" : \"Tasks\"} list.`);\n    } catch (e) {\n      console.error(e);\n      setErr(\"Error adding to Slack\");\n      setShowErr(true);\n    }\n  };\n\n  const handleToggleAddToWebsite = async () => {\n    const docId = await ensureSaved();\n    if (!docId) return;\n    const next = !addToWebsite;\n    setAddToWebsite(next);\n\n    try {\n      await firebase.firestore().collection(\"Test\").doc(docId).update({\n        addedToWebsite: next\n      });\n    } catch (error) {\n      console.error(\"Error updating addedToWebsite:\", error);\n    }\n  };\n\n  const handleAddNewPn = () => {\n    if (newPn.trim() !== \"\") {\n      setItems(prev => _objectSpread(_objectSpread({}, prev), {}, {\n        pn: [...prev.pn, newPn.trim()]\n      }));\n    }\n\n    setNewPn(\"\");\n    setAddingNewPn(false);\n  };\n\n  const handleAddNewSn = () => {\n    if (newSn.trim() !== \"\") {\n      setItems(prev => _objectSpread(_objectSpread({}, prev), {}, {\n        sn: [...prev.sn, newSn.trim()]\n      }));\n    }\n\n    setNewSn(\"\");\n    setAddingNewSn(false);\n  };\n\n  const {\n    0: showLocalLocFrom,\n    1: setShowLocalLocFrom\n  } = useState(false);\n  const {\n    0: showLocalLocCurrent,\n    1: setShowLocalLocCurrent\n  } = useState(false);\n  const {\n    0: showNewLocalModalFrom,\n    1: setShowNewLocalModalFrom\n  } = useState(false);\n  const {\n    0: showNewLocalModalCurrent,\n    1: setShowNewLocalModalCurrent\n  } = useState(false);\n\n  async function handleClone(event) {\n    event.preventDefault();\n\n    if (!isReadyForActions) {\n      handleShow(); // your existing error modal\n\n      return;\n    }\n\n    safeSetLoading(true);\n\n    try {\n      // save but don’t redirect\n      const docId = await toSend(false, {\n        forceNew: true\n      });\n\n      if (!docId) {\n        setErr(\"Save failed. Please try again.\");\n        setShowErr(true);\n      } else {\n        // Prepare for the next clone without overwriting the last one.\n        setSavedDocId(null);\n        setItems(prev => _objectSpread(_objectSpread({}, prev), {}, {\n          localSN: \"\"\n        }));\n      }\n    } catch (err) {\n      console.error(err);\n      setErr((err === null || err === void 0 ? void 0 : err.message) || \"Save failed.\");\n      setShowErr(true);\n    } finally {\n      safeSetLoading(false);\n    }\n  }\n\n  const condition = name => {\n    return name && name.toLowerCase() === \"interior socal\";\n  };\n\n  const handleSetSelectedMachine = machine => {\n    var _machine$name;\n\n    const isSocalInterior = ((_machine$name = machine.name) === null || _machine$name === void 0 ? void 0 : _machine$name.toLowerCase()) === \"interior socal\";\n\n    if (machinePick) {\n      var _selectedClientFrom$n;\n\n      setSelectedMachine({\n        id: machine.id,\n        name: machine.name\n      });\n      setShowLocalLocFrom(isSocalInterior || (selectedClientFrom === null || selectedClientFrom === void 0 ? void 0 : (_selectedClientFrom$n = selectedClientFrom.name) === null || _selectedClientFrom$n === void 0 ? void 0 : _selectedClientFrom$n.toLowerCase()) === \"socalwarehouse\");\n    } else {\n      var _selectedClientCurren;\n\n      setSelectedCurrentMachine({\n        id: machine.id,\n        name: machine.name\n      });\n      setShowLocalLocCurrent(isSocalInterior || (selectedClientCurrent === null || selectedClientCurrent === void 0 ? void 0 : (_selectedClientCurren = selectedClientCurrent.name) === null || _selectedClientCurren === void 0 ? void 0 : _selectedClientCurren.toLowerCase()) === \"socalwarehouse\");\n    }\n\n    fetchMachine(machine.id);\n    setShowMachineModal(false);\n  };\n\n  const {\n    0: currentPnIndex,\n    1: setCurrentPnIndex\n  } = useState(0);\n  const {\n    0: showDropdown,\n    1: setShowDropdown\n  } = useState(false);\n  const {\n    0: currentSnIndex,\n    1: setCurrentSnIndex\n  } = useState(0);\n  const {\n    0: showSnDropdown,\n    1: setShowSnDropdown\n  } = useState(false);\n  useEffect(() => {\n    if (showDropdown || showSnDropdown) {\n      loadPnSnOptions();\n    }\n  }, [showDropdown, showSnDropdown]);\n\n  const handleAddNewClient = () => {\n    // Generate a random client number as part of the URL.\n    const randomNum = Math.floor(10000 + Math.random() * 90000); // When pushing, include a query parameter (from=item) and the current item id if available.\n\n    router.push(`/NewSearch/client/AIS${randomNum}/addClient?from=addItem`);\n  };\n\n  const {\n    0: showMachineSelect,\n    1: setShowMachineSelect\n  } = useState(false);\n  const {\n    0: selectedClientFrom,\n    1: setSelectedClientFrom\n  } = useState(null);\n  const {\n    0: selectedClientCurrent,\n    1: setSelectedClientCurrent\n  } = useState(null);\n  useEffect(() => {\n    var _selectedClientFrom$n2;\n\n    setShowLocalLocFrom((selectedClientFrom === null || selectedClientFrom === void 0 ? void 0 : (_selectedClientFrom$n2 = selectedClientFrom.name) === null || _selectedClientFrom$n2 === void 0 ? void 0 : _selectedClientFrom$n2.toLowerCase()) === \"socalwarehouse\");\n  }, [selectedClientFrom]);\n  useEffect(() => {\n    var _selectedClientCurren2;\n\n    setShowLocalLocCurrent((selectedClientCurrent === null || selectedClientCurrent === void 0 ? void 0 : (_selectedClientCurren2 = selectedClientCurrent.name) === null || _selectedClientCurren2 === void 0 ? void 0 : _selectedClientCurren2.toLowerCase()) === \"socalwarehouse\");\n  }, [selectedClientCurrent]);\n  return __jsx(LoggedIn, null, __jsx(MachineSelectionModal, {\n    show: machineSelectionModal,\n    handleClose: () => setMachineSelectionModal(false),\n    setMachine: handleSetSelectedMachine,\n    machineOptions: machineOptions // if your modal needs the list of machines\n\n  }), __jsx(Modal, {\n    show: show,\n    onHide: handleClose\n  }, __jsx(Modal.Header, {\n    closeButton: true\n  }, __jsx(Modal.Title, null, \"Error\")), __jsx(Modal.Body, null, \"Missing required field: Name and Description\"), __jsx(Modal.Footer, null, __jsx(Button, {\n    variant: \"primary\",\n    onClick: handleClose\n  }, \"Ok\"))), __jsx(Modal, {\n    show: showErr,\n    onHide: handleCloseErr\n  }, __jsx(Modal.Header, {\n    closeButton: true\n  }, __jsx(Modal.Title, null, \"Error\")), __jsx(Modal.Body, null, Err), __jsx(Modal.Footer, null, __jsx(Button, {\n    variant: \"primary\",\n    onClick: handleCloseErr\n  }, \"Ok\"))), __jsx(Modal, {\n    show: showSaveModal,\n    onHide: handleCloseSaveModal\n  }, __jsx(Modal.Header, {\n    closeButton: true\n  }, __jsx(Modal.Title, null, \"Save Confirmation\")), __jsx(Modal.Body, null, \"Data has been saved successfully.\"), __jsx(Modal.Footer, null, __jsx(Button, {\n    variant: \"primary\",\n    onClick: handleCloseSaveModal\n  }, \"Ok\"))), __jsx(Modal, {\n    show: showDescModal,\n    onHide: handleCloseDescModal\n  }, __jsx(Modal.Header, {\n    closeButton: true\n  }, __jsx(Modal.Title, null, \"Descriptions\")), __jsx(Modal.Body, null, __jsx(Button, {\n    variant: \"primary\",\n    className: \"mb-3\",\n    onClick: addDescription\n  }, \"Add Description\"), descriptions.map((desc, index) => __jsx(Row, {\n    key: index,\n    className: \"mb-3\"\n  }, __jsx(Button, {\n    variant: \"outline-secondary\",\n    className: \"w-100\",\n    onClick: () => selectDescription(index),\n    style: {\n      cursor: \"pointer\"\n    }\n  }, __jsx(\"div\", {\n    className: \"d-flex justify-content-between\"\n  }, __jsx(\"span\", null, desc.description || \"Description\"), __jsx(\"span\", {\n    style: {\n      borderLeft: \"1px solid #ccc\",\n      paddingLeft: \"10px\"\n    }\n  }, desc.date || \"Date\"))))), __jsx(Button, {\n    variant: \"primary\",\n    onClick: handleCloseDescModal\n  }, \"OK\"))), __jsx(Modal, {\n    show: showWoModal,\n    onHide: handleCloseWoModal\n  }, __jsx(Modal.Header, {\n    closeButton: true\n  }, __jsx(Modal.Title, null, \"Work Orders\")), __jsx(Modal.Body, null, __jsx(Button, {\n    variant: \"primary\",\n    className: \"mb-3\",\n    onClick: addWorkOrder,\n    style: {\n      marginBottom: \"1rem\"\n    }\n  }, \"Add Work Order\"), workOrders.map((wo, index) => __jsx(Row, {\n    key: index,\n    className: \"mb-3\"\n  }, __jsx(Col, null, __jsx(Form.Control, {\n    type: \"text\",\n    placeholder: \"Work Order\",\n    value: wo.workOrder,\n    onChange: e => handleWorkOrderChange(index, \"workOrder\", e.target.value),\n    style: {\n      marginBottom: \"0.5rem\"\n    }\n  })), __jsx(Col, null, __jsx(Form.Control, {\n    type: \"date\",\n    placeholder: \"Date\",\n    value: wo.date,\n    onChange: e => handleWorkOrderChange(index, \"date\", e.target.value)\n  })), __jsx(Col, null, __jsx(Button, {\n    variant: \"danger\",\n    onClick: () => removeWorkOrder(index)\n  }, \"Remove\")))), __jsx(Button, {\n    variant: \"primary\",\n    onClick: handleCloseWoModal\n  }, \"OK\"))), __jsx(ClientInfoModal, {\n    show: showMachineModal,\n    handleClose: handleCloseMachineModal,\n    selectedClient: selectedClient,\n    machineOptions: machineOptions,\n    setSelectedMachine: handleSetSelectedMachine\n  }), __jsx(Modal, {\n    show: showClientModal,\n    onHide: handleCloseClientModal\n  }, __jsx(Modal.Header, {\n    closeButton: true\n  }, __jsx(Modal.Title, null, \"Select Client\")), __jsx(Modal.Body, null, __jsx(FormControl, {\n    type: \"text\",\n    placeholder: \"Search by name\",\n    className: \"mb-3\",\n    value: search,\n    onChange: e => setSearch(e.target.value)\n  }), __jsx(ClientTable, {\n    clients: clients.filter(client => client.name.toLowerCase().includes(search.toLowerCase())),\n    onSelectClient: handleClientInfo,\n    onInfoClick: handleClientInfo,\n    clearSelection: () => handleClientInfo(null),\n    onAddClient: handleAddNewClient // new prop\n\n  }))), __jsx(ParentModal, {\n    show: showParentModal,\n    handleClose: handleCloseParentModal,\n    setSelectedParent: setSelectedParent\n  }), __jsx(MachineSelectionModal, {\n    show: machineSelectionModal,\n    handleClose: () => setMachineSelectionModal(false),\n    setMachine: setTheMachine\n  }), __jsx(Modal, {\n    show: showCameraModal,\n    onHide: handleCloseCameraModal\n  }, __jsx(Modal.Header, {\n    closeButton: true\n  }, __jsx(Modal.Title, null, \"Take a Photo\")), __jsx(Modal.Body, null, __jsx(\"div\", {\n    className: \"camera\"\n  }, !capturedPhoto ? __jsx(BarcodeScannerComponent, {\n    width: \"100%\",\n    height: 300,\n    onUpdate: handleCapture,\n    facingMode: cameraFacing\n  }) : __jsx(\"div\", {\n    className: \"photo-preview\"\n  }, __jsx(\"img\", {\n    src: URL.createObjectURL(capturedPhoto),\n    alt: \"captured\",\n    style: {\n      width: \"100%\"\n    }\n  })))), __jsx(Modal.Footer, null, !capturedPhoto ? __jsx(React.Fragment, null, __jsx(Button, {\n    onClick: capturePhoto,\n    style: {\n      borderRadius: \"50%\",\n      width: \"60px\",\n      height: \"60px\",\n      position: \"absolute\",\n      left: \"50%\",\n      transform: \"translateX(-50%)\",\n      bottom: \"10px\"\n    }\n  }, \"\\uD83D\\uDCF7\"), __jsx(Button, {\n    onClick: () => setCameraFacing(prev => prev === \"environment\" ? \"user\" : \"environment\")\n  }, \"Flip Camera\"), __jsx(Button, {\n    variant: \"secondary\",\n    onClick: handleCloseCameraModal\n  }, \"Cancel\")) : __jsx(React.Fragment, null, __jsx(Button, {\n    variant: \"secondary\",\n    onClick: () => setCapturedPhoto(null)\n  }, \"Retake\"), __jsx(Button, {\n    variant: \"primary\",\n    onClick: savePhoto\n  }, \"OK\")))), __jsx(Modal, {\n    show: showDescModal,\n    onHide: handleCloseDescModal\n  }, __jsx(Modal.Header, {\n    closeButton: true\n  }, __jsx(Modal.Title, null, \"Descriptions\")), __jsx(Modal.Body, null, __jsx(Button, {\n    variant: \"primary\",\n    className: \"mb-3\",\n    onClick: addDescription\n  }, \"Add Description\"), descriptions.map((desc, index) => __jsx(Row, {\n    key: index,\n    className: \"mb-3\"\n  }, __jsx(Button, {\n    variant: \"outline-secondary\",\n    className: \"w-100\",\n    onClick: () => selectDescription(index),\n    style: {\n      cursor: \"pointer\"\n    }\n  }, __jsx(\"div\", {\n    className: \"d-flex justify-content-between\"\n  }, __jsx(\"span\", null, desc.description || \"Description\"), __jsx(\"span\", {\n    style: {\n      borderLeft: \"1px solid #ccc\",\n      paddingLeft: \"10px\"\n    }\n  }, desc.date || \"Date\"))))), __jsx(Button, {\n    variant: \"primary\",\n    onClick: handleCloseDescModal\n  }, \"OK\"))), __jsx(InfoModal, {\n    show: showInfoModal,\n    handleClose: handleCloseInfoModal,\n    itemName: items.name,\n    dimensions: `${items.length},${items.width},${items.height}`,\n    price: items.price,\n    freqI: freqItem,\n    freqM: machineFrequency,\n    usage: usagePastYear\n  }), loading && __jsx(\"div\", {\n    style: {\n      position: \"fixed\",\n      top: 0,\n      left: 0,\n      width: \"100%\",\n      height: \"100%\",\n      backgroundColor: \"rgba(255, 255, 255, 0.7)\",\n      backdropFilter: \"blur(5px)\",\n      display: \"flex\",\n      alignItems: \"center\",\n      justifyContent: \"center\",\n      zIndex: 9999 // Make sure it's above everything else\n\n    }\n  }, __jsx(Spinner, {\n    animation: \"border\",\n    variant: \"primary\",\n    role: \"status\"\n  }, __jsx(\"span\", {\n    className: \"visually-hidden\"\n  }, \"Loading...\"))), __jsx(Container, {\n    fluid: true,\n    className: styles.page\n  }, __jsx(\"div\", {\n    className: styles.shell\n  }, __jsx(Card, {\n    className: styles.card\n  }, __jsx(Card.Body, {\n    className: styles.cardBody\n  }, __jsx(\"div\", {\n    className: styles.header\n  }, __jsx(\"div\", {\n    className: styles.kicker\n  }, \"New Item\"), __jsx(\"h2\", {\n    className: styles.title\n  }, \"Add New Item\"), __jsx(\"div\", {\n    className: styles.subtitle\n  }, \"Capture details, photos, and routing before saving.\")), __jsx(Form, {\n    onSubmit: handleSubmit\n  }, __jsx(Row, {\n    className: \"mb-3\"\n  }, __jsx(Col, null, __jsx(Form.Group, {\n    controlId: \"name\"\n  }, __jsx(Form.Label, null, \"Name\"), __jsx(Form.Control, {\n    type: \"text\",\n    value: items.name,\n    onChange: handleChange(\"name\")\n  }))), __jsx(Col, null, __jsx(Form.Group, {\n    controlId: \"pn\"\n  }, __jsx(Form.Label, null, \"Product Number\"), __jsx(\"div\", {\n    style: {\n      position: \"relative\"\n    }\n  }, __jsx(InputGroup, null, __jsx(Form.Control, {\n    type: \"text\",\n    value: items.pn[currentPnIndex] || \"\",\n    onChange: e => handlePnChange(currentPnIndex, e.target.value)\n  }), __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: () => setShowDropdown(!showDropdown)\n  }, \"\\u25BE\"), __jsx(InputGroup.Text, null, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: () => setAddingNewPn(true)\n  }, \"+\"))), showDropdown && __jsx(\"div\", {\n    style: {\n      position: \"absolute\",\n      top: \"100%\",\n      left: 0,\n      right: 0,\n      backgroundColor: \"white\",\n      border: \"1px solid #ccc\",\n      zIndex: 1000,\n      maxHeight: \"150px\",\n      overflowY: \"auto\"\n    }\n  }, items.pn.map((pnOption, idx) => __jsx(\"div\", {\n    key: idx,\n    style: {\n      padding: \"8px\",\n      cursor: \"pointer\"\n    },\n    onClick: () => {\n      setCurrentPnIndex(idx);\n      setShowDropdown(false);\n    }\n  }, pnOption)))), addingNewPn && __jsx(Form.Control, {\n    type: \"text\",\n    placeholder: \"Enter new PN\",\n    value: newPn,\n    onChange: e => setNewPn(e.target.value),\n    onBlur: handleAddNewPn,\n    onKeyDown: e => {\n      if (e.key === \"Enter\") {\n        handleAddNewPn();\n      }\n    }\n  })))), __jsx(Row, {\n    className: \"mb-3\"\n  }, __jsx(Col, null, __jsx(Form.Group, {\n    controlId: \"sn\"\n  }, __jsx(Form.Label, null, \"Serial Number\"), __jsx(\"div\", {\n    style: {\n      position: \"relative\"\n    }\n  }, __jsx(InputGroup, null, __jsx(Form.Control, {\n    type: \"text\",\n    value: items.sn[currentSnIndex] || \"\",\n    onChange: e => handleSnChange(currentSnIndex, e.target.value)\n  }), __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: () => setShowSnDropdown(!showSnDropdown)\n  }, \"\\u25BE\"), __jsx(InputGroup.Text, null, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: () => setAddingNewSn(true)\n  }, \"+\"))), showSnDropdown && __jsx(\"div\", {\n    style: {\n      position: \"absolute\",\n      top: \"100%\",\n      left: 0,\n      right: 0,\n      backgroundColor: \"white\",\n      border: \"1px solid #ccc\",\n      zIndex: 1000,\n      maxHeight: \"150px\",\n      overflowY: \"auto\"\n    }\n  }, items.sn.map((snOption, idx) => __jsx(\"div\", {\n    key: idx,\n    style: {\n      padding: \"8px\",\n      cursor: \"pointer\"\n    },\n    onClick: () => {\n      setCurrentSnIndex(idx);\n      setShowSnDropdown(false);\n    }\n  }, snOption)))), addingNewSn && __jsx(Form.Control, {\n    type: \"text\",\n    placeholder: \"Enter new SN\",\n    value: newSn,\n    onChange: e => setNewSn(e.target.value),\n    onBlur: handleAddNewSn,\n    onKeyDown: e => {\n      if (e.key === \"Enter\") {\n        handleAddNewSn();\n      }\n    }\n  }))), __jsx(Col, null, __jsx(Form.Group, {\n    controlId: \"status\"\n  }, __jsx(Form.Label, null, \"Status\"), __jsx(Form.Select, {\n    value: items.status || \"\",\n    onChange: handleChange(\"status\")\n  }, __jsx(\"option\", {\n    value: \"\"\n  }, \"Select status\"), __jsx(\"option\", {\n    value: \"Good\"\n  }, \"Good\"), __jsx(\"option\", {\n    value: \"Bad\"\n  }, \"Bad\"), __jsx(\"option\", {\n    value: \"Unknown\"\n  }, \"Unknown\"))))), __jsx(Row, {\n    className: \"mb-3\"\n  }, __jsx(Col, null, __jsx(Form.Group, {\n    controlId: \"localSN\"\n  }, __jsx(Form.Label, null, \"Local SN\"), __jsx(Form.Control, {\n    type: \"text\",\n    placeholder: \"Enter Local SN\",\n    value: items.localSN || \"\",\n    onChange: handleChange(\"localSN\")\n  }))), __jsx(Col, null, __jsx(Form.Group, {\n    controlId: \"arrivalDate\"\n  }, __jsx(Form.Label, null, \"Arrival Date\"), __jsx(Form.Control, {\n    placeholder: \"Enter Arrival Date\",\n    type: \"date\",\n    value: items.arrival_date,\n    onChange: e => {\n      const value = e.target.value;\n      setItems(prev => _objectSpread(_objectSpread({}, prev), {}, {\n        arrival_date: value\n      }));\n    }\n  }))), __jsx(Col, null, __jsx(Form.Group, {\n    controlId: \"trackingNumber\"\n  }, __jsx(Form.Label, null, \"Tracking Number\"), __jsx(Form.Control, {\n    placeholder: \"Tracking Number\",\n    type: \"text\",\n    value: items.trackingNumber,\n    onChange: handleChange(\"trackingNumber\")\n  })))), __jsx(Row, {\n    className: \"mb-3\"\n  }, __jsx(Col, null, __jsx(MultiSelectDropdown, {\n    label: \"OEM\",\n    placeholder: trackerLoading ? \"Loading...\" : \"Select OEM\",\n    options: oemOptionsForUI,\n    selected: selectedOems,\n    onChange: setSelectedOems,\n    enableDelete: true,\n    onDeleteOption: handleDeleteOemOption,\n    disabled: trackerLoading\n  })), __jsx(Col, null, __jsx(MultiSelectDropdown, {\n    label: \"Modality\",\n    placeholder: trackerLoading ? \"Loading...\" : \"Select Modality\",\n    options: modalityOptionsForUI,\n    selected: selectedModalities,\n    onChange: setSelectedModalities,\n    disabled: trackerLoading\n  })), __jsx(Col, null, __jsx(MultiSelectDropdown, {\n    label: \"Model\",\n    placeholder: selectedModalities.length && selectedOems.length ? \"Select Model\" : \"Select Modality + OEM\",\n    options: modelOptionsForUI,\n    selected: selectedModels,\n    onChange: setSelectedModels,\n    enableDelete: true,\n    onDeleteOption: handleDeleteModelOption,\n    disabled: trackerLoading || !selectedModalities.length || !selectedOems.length\n  }))), __jsx(\"div\", {\n    style: {\n      marginBottom: \"1rem\",\n      marginTop: \"1rem\"\n    }\n  }, __jsx(\"div\", {\n    className: \"d-flex align-items-center\"\n  }, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: handleShowWoModal,\n    className: \"me-2\"\n  }, \"Manage Work Orders\"), workOrders.length > 0 && __jsx(\"div\", {\n    className: \"d-flex flex-column align-items-start\"\n  }, __jsx(Form.Label, null, \"Work Order\"), __jsx(Form.Control, {\n    type: \"text\",\n    placeholder: \"Most Recent Work Order\",\n    value: (mostRecentWorkOrder === null || mostRecentWorkOrder === void 0 ? void 0 : mostRecentWorkOrder.workOrder) || \"\",\n    onChange: e => handleWorkOrderChange(workOrders.indexOf(mostRecentWorkOrder), \"workOrder\", e.target.value),\n    style: {\n      marginBottom: \"0.5rem\"\n    }\n  }), __jsx(Form.Label, null, \"Date\"), __jsx(Form.Control, {\n    type: \"date\",\n    placeholder: \"Work Order Date\",\n    value: (mostRecentWorkOrder === null || mostRecentWorkOrder === void 0 ? void 0 : mostRecentWorkOrder.date) || \"\",\n    onChange: e => handleWorkOrderChange(workOrders.indexOf(mostRecentWorkOrder), \"date\", e.target.value),\n    style: {\n      marginBottom: \"0.5rem\"\n    }\n  })))), __jsx(\"div\", {\n    style: {\n      marginBottom: \"1rem\"\n    }\n  }, __jsx(Form.Group, {\n    controlId: \"desc\"\n  }, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: listDescriptions,\n    className: \"mb-2 me-2\"\n  }, \"List Descriptions\"), __jsx(Form.Control, {\n    as: \"textarea\",\n    rows: 3,\n    placeholder: \"Enter description\",\n    value: ((_descriptions$selecte4 = descriptions[selectedDesc]) === null || _descriptions$selecte4 === void 0 ? void 0 : _descriptions$selecte4.description) || \"\",\n    onChange: e => handleDescriptionChange(selectedDesc, \"description\", e.target.value),\n    style: {\n      marginBottom: \"0.5rem\"\n    }\n  }), __jsx(Form.Control, {\n    type: \"date\",\n    value: ((_descriptions$selecte5 = descriptions[selectedDesc]) === null || _descriptions$selecte5 === void 0 ? void 0 : _descriptions$selecte5.date) || \"\",\n    onChange: e => handleDescriptionChange(selectedDesc, \"date\", e.target.value),\n    style: {\n      marginTop: \"0.5rem\",\n      marginBottom: \"0.5rem\"\n    }\n  }))), __jsx(\"div\", {\n    style: {\n      marginBottom: \"1rem\"\n    }\n  }, __jsx(Row, {\n    className: \"mb-3\"\n  }, __jsx(Col, null, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: () => {\n      setMachinePick(true);\n      handleShowClientModal();\n    },\n    className: \"me-2\"\n  }, \"Select From\"), selectedClientFrom && __jsx(\"div\", {\n    style: {\n      border: \"1px solid #ccc\",\n      padding: \"0.75rem\",\n      borderRadius: \"4px\",\n      marginBottom: \"1rem\"\n    }\n  }, __jsx(\"p\", null, __jsx(\"strong\", null, \"Selected Client (From):\"), \" \", selectedClientFrom.name), __jsx(\"div\", {\n    style: {\n      marginTop: \"0.5rem\"\n    }\n  }, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: () => setShowMachineModal(true)\n  }, \"Select Machine for \", selectedClientFrom.name), selectedMachine && __jsx(React.Fragment, null, __jsx(\"p\", {\n    style: {\n      marginTop: \"0.5rem\"\n    }\n  }, __jsx(\"strong\", null, \"Selected Machine (From):\"), \" \", selectedMachine.name), showLocalLocFrom && __jsx(React.Fragment, null, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: () => setShowNewLocalModalFrom(true),\n    className: \"w-100 mb-2\"\n  }, [newLocalFrom.region, ((_newLocalFrom$section = newLocalFrom.section) === null || _newLocalFrom$section === void 0 ? void 0 : _newLocalFrom$section.letter) + ((_newLocalFrom$section2 = newLocalFrom.section) === null || _newLocalFrom$section2 === void 0 ? void 0 : _newLocalFrom$section2.number), newLocalFrom.bin && `B${newLocalFrom.bin}`, newLocalFrom.pallet && `P${newLocalFrom.pallet}`].filter(Boolean).join(\"-\") || \"Set Local Location\"), __jsx(Modal, {\n    show: showNewLocalModalFrom,\n    onHide: () => setShowNewLocalModalFrom(false),\n    centered: true\n  }, __jsx(Modal.Header, null, __jsx(Modal.Title, null, \"Edit Local Loc (From)\")), __jsx(Modal.Body, null, __jsx(NewLocal, {\n    selectedClient: selectedClientFrom,\n    showLocalLoc: showNewLocalModalFrom,\n    value: newLocalFrom,\n    onChange: setNewLocalFrom,\n    onSave: p => {\n      setNewLocalFrom(p);\n      setShowNewLocalModalFrom(false);\n    },\n    onCancel: () => setShowNewLocalModalFrom(false)\n  })))))))), __jsx(Col, null, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: () => {\n      setMachinePick(false);\n      handleShowClientModal();\n    },\n    className: \"me-2\"\n  }, \"Select Current\"), selectedClientCurrent && __jsx(\"div\", {\n    style: {\n      border: \"1px solid #ccc\",\n      padding: \"0.75rem\",\n      borderRadius: \"4px\",\n      marginBottom: \"1rem\"\n    }\n  }, __jsx(\"p\", null, __jsx(\"strong\", null, \"Selected Client (Current):\"), \" \", selectedClientCurrent.name), __jsx(\"div\", {\n    style: {\n      marginTop: \"0.5rem\"\n    }\n  }, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: () => setShowMachineModal(true)\n  }, \"Select Machine for \", selectedClientCurrent.name), selectedCurrentMachine && __jsx(React.Fragment, null, __jsx(\"p\", {\n    style: {\n      marginTop: \"0.5rem\"\n    }\n  }, __jsx(\"strong\", null, \"Selected Machine (Current):\"), \" \", selectedCurrentMachine.name), showLocalLocCurrent && __jsx(React.Fragment, null, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: () => setShowNewLocalModalCurrent(true),\n    className: \"w-100 mb-2\"\n  }, [newLocalCurrent.region, ((_newLocalCurrent$sect = newLocalCurrent.section) === null || _newLocalCurrent$sect === void 0 ? void 0 : _newLocalCurrent$sect.letter) + ((_newLocalCurrent$sect2 = newLocalCurrent.section) === null || _newLocalCurrent$sect2 === void 0 ? void 0 : _newLocalCurrent$sect2.number), newLocalCurrent.bin && `B${newLocalCurrent.bin}`, newLocalCurrent.pallet && `P${newLocalCurrent.pallet}`].filter(Boolean).join(\"-\") || \"Set Local Location\"), __jsx(Modal, {\n    show: showNewLocalModalCurrent,\n    onHide: () => setShowNewLocalModalCurrent(false),\n    centered: true\n  }, __jsx(Modal.Header, null, __jsx(Modal.Title, null, \"Edit Local Loc (Current)\")), __jsx(Modal.Body, null, __jsx(NewLocal, {\n    selectedClient: selectedClientCurrent,\n    showLocalLoc: showNewLocalModalCurrent,\n    value: newLocalCurrent,\n    onChange: setNewLocalCurrent,\n    onSave: p => {\n      setNewLocalCurrent(p);\n      setShowNewLocalModalCurrent(false);\n    },\n    onCancel: () => setShowNewLocalModalCurrent(false)\n  })))))))), __jsx(Col, null, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: handleShowParentModal,\n    className: \"me-2\"\n  }, \"Select Parent\"), selectedParent && __jsx(Form.Control, {\n    type: \"text\",\n    placeholder: \"Selected Parent\",\n    value: selectedParent.name,\n    readOnly: true,\n    style: {\n      cursor: \"default\",\n      marginTop: \"0.5rem\"\n    }\n  })))), __jsx(\"div\", {\n    style: {\n      marginBottom: \"1rem\"\n    }\n  }, __jsx(Row, {\n    className: `mb-3 ${styles.photoActionsRow}`\n  }, __jsx(Col, {\n    xs: 12,\n    md: 6\n  }, __jsx(ButtonGroup, null, __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: handleShowCameraModal\n  }, \"Take Photo\"), __jsx(Button, {\n    variant: \"outline-secondary\",\n    onClick: handleBrowsePhotos\n  }, \"Browse\"))), __jsx(Col, {\n    xs: 12,\n    md: 6,\n    className: styles.photoActionsRight\n  }, __jsx(Button, {\n    variant: \"success\",\n    onClick: handleSendToInflow,\n    disabled: !isReadyForActions,\n    style: {\n      marginLeft: \"auto\"\n    }\n  }, \"Send to inFlow\"), __jsx(Button, {\n    variant: \"secondary\",\n    onClick: handleBluefolderButton,\n    disabled: !isReadyForActions,\n    style: {\n      marginLeft: \"0.5rem\",\n      marginRight: \".5rem\"\n    }\n  }, \"BlueFolder\"), __jsx(Button, {\n    variant: addToWebsite ? \"primary\" : \"outline-primary\",\n    onClick: handleToggleAddToWebsite,\n    disabled: !isReadyForActions\n  }, addToWebsite ? \"Added to Website\" : \"Add to Website\"), __jsx(Form.Check, {\n    type: \"checkbox\",\n    id: \"hide-checkbox\",\n    label: \"Hide\",\n    checked: !items.visible,\n    onChange: e => {\n      const isHidden = e.currentTarget.checked;\n      setItems(prev => _objectSpread(_objectSpread({}, prev), {}, {\n        visible: !isHidden\n      }));\n    },\n    className: \"ms-3\"\n  }))), __jsx(\"input\", {\n    type: \"file\",\n    accept: \"image/*\",\n    multiple: true,\n    ref: browseInputRef,\n    style: {\n      display: \"none\"\n    },\n    onChange: handleFilesSelected\n  })), __jsx(\"div\", {\n    className: \"mt-3 d-flex flex-wrap\"\n  }, photos.map((photo, index) => __jsx(\"div\", {\n    key: index,\n    className: \"d-flex flex-column align-items-center mb-2 me-2\",\n    style: {\n      width: \"100px\",\n      height: \"100px\",\n      position: \"relative\"\n    }\n  }, __jsx(\"img\", {\n    src: photo.url,\n    alt: `Photo ${index + 1}`,\n    style: {\n      width: \"100%\",\n      height: \"100%\",\n      objectFit: \"cover\"\n    }\n  }), photo.file && __jsx(Button, {\n    variant: \"danger\",\n    size: \"sm\",\n    style: {\n      position: \"absolute\",\n      top: 0,\n      right: 0,\n      padding: \"0 5px\"\n    },\n    onClick: () => removePhoto(index)\n  }, \"X\")))), __jsx(\"div\", {\n    className: `mt-3 d-flex flex-wrap align-items-center ${styles.actionRow}`\n  }, __jsx(Button, {\n    variant: \"primary\",\n    type: \"submit\",\n    style: {\n      marginRight: \"1rem\"\n    }\n  }, \"Save\"), __jsx(Button, {\n    variant: \"info\",\n    onClick: handleClone,\n    style: {\n      marginRight: \"1rem\"\n    }\n  }, \"Clone\"), __jsx(LoadingButton, {\n    type: \"secondary\",\n    name: \"Back\",\n    route: \"NewSearch/mainSearch\"\n  }), SHOW_SLACK_BUTTONS && __jsx(\"div\", {\n    style: {\n      display: \"flex\",\n      flexDirection: \"column\",\n      marginLeft: \".5rem\"\n    }\n  }, __jsx(\"span\", {\n    style: {\n      fontSize: 12,\n      lineHeight: \"12px\",\n      textAlign: \"center\"\n    }\n  }, \"Slack\"), __jsx(\"div\", {\n    style: {\n      display: \"flex\",\n      border: \"1px solid #ced4da\",\n      borderRadius: 6,\n      overflow: \"hidden\"\n    }\n  }, __jsx(Button, {\n    variant: \"outline-primary\",\n    onClick: () => handleAddToSlack(\"receiving\"),\n    disabled: !isReadyForActions,\n    style: {\n      border: \"none\",\n      borderRight: \"1px solid #ced4da\"\n    }\n  }, \"Receiving\"), __jsx(Button, {\n    variant: \"outline-primary\",\n    onClick: () => handleAddToSlack(\"shipping\"),\n    disabled: !isReadyForActions,\n    style: {\n      border: \"none\"\n    }\n  }, \"Shipping\"))), __jsx(Button, {\n    variant: \"info\",\n    onClick: handlePrint,\n    disabled: !isReadyForActions,\n    style: {\n      marginLeft: \"auto\"\n    }\n  }, \"Print Label\")), __jsx(\"div\", {\n    style: {\n      textAlign: \"center\",\n      margin: \"1rem 0\"\n    }\n  }, __jsx(Button, {\n    variant: \"link\",\n    style: {\n      textDecoration: \"none\",\n      color: \"black\",\n      fontSize: \"24px\"\n    },\n    onClick: () => setShowExtra(!showExtra)\n  }, \"\\u25BC\")), __jsx(Collapse, {\n    in: showExtra\n  }, __jsx(\"div\", {\n    id: \"extra-collapse\",\n    className: \"mt-3\"\n  }, __jsx(Row, null, __jsx(Form.Group, {\n    as: Col,\n    controlId: \"dimensions\"\n  }, __jsx(Form.Label, null, \"Dimensions (L x W x H)\"), __jsx(Row, null, __jsx(Col, null, __jsx(Form.Control, {\n    placeholder: \"Length\",\n    type: \"text\",\n    value: items.length,\n    onChange: handleChange(\"length\")\n  })), \"x\", __jsx(Col, null, __jsx(Form.Control, {\n    placeholder: \"Width\",\n    type: \"text\",\n    value: items.width,\n    onChange: handleChange(\"width\")\n  })), \"x\", __jsx(Col, null, __jsx(Form.Control, {\n    placeholder: \"Height\",\n    type: \"text\",\n    value: items.height,\n    onChange: handleChange(\"height\")\n  })))), __jsx(Form.Group, {\n    as: Col,\n    controlId: \"price\"\n  }, __jsx(Form.Label, null, \"Price\"), __jsx(Form.Control, {\n    placeholder: \"Price\",\n    type: \"text\",\n    value: items.price,\n    onChange: handleChange(\"price\")\n  }))), __jsx(Row, {\n    className: \"mt-3\"\n  }, __jsx(Form.Group, {\n    as: Col,\n    controlId: \"DOM\"\n  }, __jsx(Form.Label, null, \"DOM (Date of Manufacture)\"), __jsx(Form.Control, {\n    placeholder: \"Enter DOM\",\n    type: \"date\",\n    value: DOM,\n    onChange: e => setDOM(e.target.value)\n  }))), __jsx(Row, null, __jsx(Form.Group, {\n    as: Col,\n    controlId: \"poNumber\"\n  }, __jsx(Form.Label, null, \"PO Number\"), __jsx(Form.Control, {\n    type: \"text\",\n    placeholder: \"PO Number\",\n    value: items.poNumber || \"\",\n    onChange: handleChange(\"poNumber\")\n  })))))))))));\n}","map":null,"metadata":{},"sourceType":"module"}