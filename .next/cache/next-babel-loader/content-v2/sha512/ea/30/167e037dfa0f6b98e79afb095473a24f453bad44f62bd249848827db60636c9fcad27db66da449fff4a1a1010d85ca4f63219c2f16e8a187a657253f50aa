{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/mack2/Desktop/code/node_modules/next/node_modules/@babel/runtime/regenerator\";\nimport _defineProperty from \"C:/Users/mack2/Desktop/code/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"C:/Users/mack2/Desktop/code/node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/mack2/Desktop/code/node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _asyncToGenerator from \"C:/Users/mack2/Desktop/code/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// // inflowAPI.js\n// const BASE_URL   = 'https://cloudapi.inflowinventory.com';\n// const COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\n// // (Move this to env vars in prod)\n// const API_KEY    = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\n// const headers = {\n//   'Authorization': `Bearer ${API_KEY}`,\n//   'Content-Type':  'application/json',\n//   // Use the latest you saw in server responses; older also works, but stay current:\n//   'Accept':        'application/json;version=2025-06-24',\n// };\n// async function parseErr(res) {\n//   const t = await res.text();\n//   try { return JSON.parse(t); } catch { return t; }\n// }\n// // --- Look up existing product by name on the collection endpoint ---\n// // Use filter[name] if your tenant supports it; otherwise fall back to filter[smart].\n// async function findProductByName(name) {\n//   // Try exact name filter first\n//   let url = `${BASE_URL}/${COMPANY_ID}/products?filter[name]=${encodeURIComponent(name)}&count=1`;\n//   let res = await fetch(url, { headers });\n//   if (res.ok) {\n//     const data = await res.json();\n//     const items = Array.isArray(data?.items) ? data.items : (Array.isArray(data) ? data : []);\n//     if (items.length) return items[0];\n//   }\n//   // Fallback: smart filter (searches common fields)\n//   url = `${BASE_URL}/${COMPANY_ID}/products?filter[smart]=${encodeURIComponent(name)}&count=1`;\n//   res = await fetch(url, { headers });\n//   if (!res.ok) return null;\n//   const data2 = await res.json();\n//   const items2 = Array.isArray(data2?.items) ? data2.items : (Array.isArray(data2) ? data2 : []);\n//   return items2.length ? items2[0] : null;\n// }\n// class InflowAPI {\n//   /**\n//    * Upsert a product in inFlow via PUT to the collection.\n//    * @param {{ productId?: string, name: string, description: string, imageUrls?: string[], sku?: string }} params\n//    */\n//   static async upsertProduct({ productId, name, description, imageUrls = [], sku }) {\n//     if (!name || !name.trim()) throw new Error('Name is required');\n//     // If no productId, check if one already exists with this name to avoid the unique-name error.\n//     if (!productId) {\n//       const existing = await findProductByName(name.trim());\n//       if (existing && (existing.productId || existing.id)) {\n//         productId = existing.productId || existing.id;\n//       }\n//     }\n//     // If still no id, generate one (this matched your previously-working flow)\n//     const id = productId || crypto.randomUUID();\n//     // Build the payload exactly like your original—PUT to the collection with productId\n//     const payload = {\n//       productId: id,\n//       name,\n//       description,\n//       ...(sku ? { sku } : {}),\n//       ...(imageUrls.length > 0 && {\n//         images: imageUrls.map(u => ({\n//           imageId: crypto.randomUUID(),\n//           originalUrl: u,\n//         })),\n//       }),\n//     };\n//     const url = `${BASE_URL}/${COMPANY_ID}/products`;\n//     const res = await fetch(url, {\n//       method: 'PUT',\n//       headers,\n//       body: JSON.stringify(payload),\n//     });\n//     if (!res.ok) {\n//       const err = await parseErr(res);\n//       throw new Error(`inFlow API error (${res.status}): ${typeof err === 'string' ? err : JSON.stringify(err)}`);\n//     }\n//     return res.json();\n//   }\n// }\n// export default InflowAPI;\n// utils/inflowAPI.js (only the changed bits)\nvar BASE_URL = 'https://cloudapi.inflowinventory.com';\nvar COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\nvar API_KEY = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\nvar headers = {\n  Authorization: \"Bearer \".concat(API_KEY),\n  'Content-Type': 'application/json',\n  // stick to a stable version you know works in your tenant:\n  Accept: 'application/json;version=2024-10-01'\n};\n\nvar n = function n(s) {\n  return (s !== null && s !== void 0 ? s : '').toString().trim();\n};\n\nfunction parseText(_x) {\n  return _parseText.apply(this, arguments);\n} // ---- EXACT lookup helpers (no fuzzy/SMART fallback) ------------------------\n\n\nfunction _parseText() {\n  _parseText = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(res) {\n    var t;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return res.text();\n\n          case 2:\n            t = _context2.sent;\n            _context2.prev = 3;\n            return _context2.abrupt(\"return\", {\n              json: JSON.parse(t),\n              raw: t\n            });\n\n          case 7:\n            _context2.prev = 7;\n            _context2.t0 = _context2[\"catch\"](3);\n            return _context2.abrupt(\"return\", {\n              json: null,\n              raw: t\n            });\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[3, 7]]);\n  }));\n  return _parseText.apply(this, arguments);\n}\n\nfunction findProductIdByExactName(_x2) {\n  return _findProductIdByExactName.apply(this, arguments);\n} // Prefer direct GET /products/{id}; fallback to collection filter by id\n\n\nfunction _findProductIdByExactName() {\n  _findProductIdByExactName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(name) {\n    var nameNorm, url, res, data, items, item;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            nameNorm = n(name);\n\n            if (nameNorm) {\n              _context3.next = 3;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 3:\n            url = \"\".concat(BASE_URL, \"/\").concat(COMPANY_ID, \"/products?filter[name]=\") + \"\".concat(encodeURIComponent(nameNorm), \"&count=1\");\n            _context3.next = 6;\n            return fetch(url, {\n              headers: headers\n            });\n\n          case 6:\n            res = _context3.sent;\n\n            if (res.ok) {\n              _context3.next = 9;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 9:\n            _context3.next = 11;\n            return res.json();\n\n          case 11:\n            data = _context3.sent;\n            items = Array.isArray(data === null || data === void 0 ? void 0 : data.items) ? data.items : Array.isArray(data) ? data : [];\n            item = items[0];\n\n            if (item) {\n              _context3.next = 16;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 16:\n            if (!(n(item.name).toLowerCase() !== nameNorm.toLowerCase())) {\n              _context3.next = 18;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 18:\n            return _context3.abrupt(\"return\", item.productId || item.id || null);\n\n          case 19:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _findProductIdByExactName.apply(this, arguments);\n}\n\nfunction getProductById(_x3) {\n  return _getProductById.apply(this, arguments);\n}\n\nfunction _getProductById() {\n  _getProductById = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(productId) {\n    var res, data, items;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return fetch(\"\".concat(BASE_URL, \"/\").concat(COMPANY_ID, \"/products/\").concat(encodeURIComponent(productId)), {\n              headers: headers\n            });\n\n          case 2:\n            res = _context4.sent;\n\n            if (!res.ok) {\n              _context4.next = 5;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", res.json());\n\n          case 5:\n            _context4.next = 7;\n            return fetch(\"\".concat(BASE_URL, \"/\").concat(COMPANY_ID, \"/products?filter[productId]=\").concat(encodeURIComponent(productId), \"&count=1\"), {\n              headers: headers\n            });\n\n          case 7:\n            res = _context4.sent;\n\n            if (res.ok) {\n              _context4.next = 10;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", null);\n\n          case 10:\n            _context4.next = 12;\n            return res.json();\n\n          case 12:\n            data = _context4.sent;\n            items = Array.isArray(data === null || data === void 0 ? void 0 : data.items) ? data.items : Array.isArray(data) ? data : [];\n            return _context4.abrupt(\"return\", items[0] || null);\n\n          case 15:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _getProductById.apply(this, arguments);\n}\n\nfunction buildImages() {\n  var imageUrls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return imageUrls.filter(Boolean).map(function (u) {\n    return {\n      imageId: crypto.randomUUID(),\n      originalUrl: u\n    };\n  });\n}\n\nvar InflowAPI = /*#__PURE__*/function () {\n  function InflowAPI() {\n    _classCallCheck(this, InflowAPI);\n  }\n\n  _createClass(InflowAPI, null, [{\n    key: \"upsertProduct\",\n\n    /**\n     * Strict upsert: exact-name reuse only; verify by id afterward.\n     */\n    value: function () {\n      var _upsertProduct = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n        var _ref2, _after$isActive;\n\n        var productId, name, description, _ref$imageUrls, imageUrls, sku, customFields, nameNorm, id, payload, res, _yield$parseText, json, raw, resolvedId, after;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                productId = _ref.productId, name = _ref.name, description = _ref.description, _ref$imageUrls = _ref.imageUrls, imageUrls = _ref$imageUrls === void 0 ? [] : _ref$imageUrls, sku = _ref.sku, customFields = _ref.customFields;\n                nameNorm = n(name);\n\n                if (nameNorm) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw new Error('Name is required');\n\n              case 4:\n                if (productId) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 7;\n                return findProductIdByExactName(nameNorm);\n\n              case 7:\n                productId = _context.sent;\n\n              case 8:\n                id = productId || crypto.randomUUID();\n                payload = _objectSpread(_objectSpread(_objectSpread(_objectSpread({\n                  productId: id,\n                  name: nameNorm,\n                  isActive: true\n                }, n(description) ? {\n                  description: n(description)\n                } : {}), n(sku) ? {\n                  sku: n(sku)\n                } : {}), imageUrls.length ? {\n                  images: buildImages(imageUrls)\n                } : {}), customFields && Object.keys(customFields).length ? {\n                  customFields: customFields\n                } : {});\n                console.log('[inFlow] PUT payload:', payload);\n                _context.next = 13;\n                return fetch(\"\".concat(BASE_URL, \"/\").concat(COMPANY_ID, \"/products\"), {\n                  method: 'PUT',\n                  headers: headers,\n                  body: JSON.stringify(payload)\n                });\n\n              case 13:\n                res = _context.sent;\n                _context.next = 16;\n                return parseText(res);\n\n              case 16:\n                _yield$parseText = _context.sent;\n                json = _yield$parseText.json;\n                raw = _yield$parseText.raw;\n                console.log('[inFlow] Raw PUT response:', res.status, raw);\n\n                if (res.ok) {\n                  _context.next = 22;\n                  break;\n                }\n\n                throw new Error(\"inFlow API error (\".concat(res.status, \"): \").concat(raw));\n\n              case 22:\n                // prefer the id the server gave us (if any), else the one we sent\n                resolvedId = json && (json.productId || json.id) || id; // Verify by ID only (no fuzzy). This prevents false “success”.\n\n                _context.next = 25;\n                return getProductById(resolvedId);\n\n              case 25:\n                after = _context.sent;\n                console.log('[inFlow] Verified by ID:', {\n                  productId: resolvedId,\n                  name: after === null || after === void 0 ? void 0 : after.name,\n                  sku: after === null || after === void 0 ? void 0 : after.sku,\n                  // many tenants surface one of these; log whatever exists so you can tell if it’s hidden\n                  isActive: (_ref2 = (_after$isActive = after === null || after === void 0 ? void 0 : after.isActive) !== null && _after$isActive !== void 0 ? _after$isActive : after === null || after === void 0 ? void 0 : after.active) !== null && _ref2 !== void 0 ? _ref2 : after === null || after === void 0 ? void 0 : after.status,\n                  categoryId: after === null || after === void 0 ? void 0 : after.categoryId\n                });\n\n                if (after) {\n                  _context.next = 29;\n                  break;\n                }\n\n                throw new Error('Write appeared to succeed, but GET by id returned nothing.');\n\n              case 29:\n                return _context.abrupt(\"return\", after);\n\n              case 30:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function upsertProduct(_x4) {\n        return _upsertProduct.apply(this, arguments);\n      }\n\n      return upsertProduct;\n    }()\n  }]);\n\n  return InflowAPI;\n}();\n\nexport default InflowAPI;","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/utils/inflowAPI.js"],"names":["BASE_URL","COMPANY_ID","API_KEY","headers","Authorization","Accept","n","s","toString","trim","parseText","res","text","t","json","JSON","parse","raw","findProductIdByExactName","name","nameNorm","url","encodeURIComponent","fetch","ok","data","items","Array","isArray","item","toLowerCase","productId","id","getProductById","buildImages","imageUrls","filter","Boolean","map","u","imageId","crypto","randomUUID","originalUrl","InflowAPI","description","sku","customFields","Error","payload","isActive","length","images","Object","keys","console","log","method","body","stringify","status","resolvedId","after","active","categoryId"],"mappings":"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","sourcesContent":["// // inflowAPI.js\n\n// const BASE_URL   = 'https://cloudapi.inflowinventory.com';\n// const COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\n// // (Move this to env vars in prod)\n// const API_KEY    = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\n\n// const headers = {\n//   'Authorization': `Bearer ${API_KEY}`,\n//   'Content-Type':  'application/json',\n//   // Use the latest you saw in server responses; older also works, but stay current:\n//   'Accept':        'application/json;version=2025-06-24',\n// };\n\n// async function parseErr(res) {\n//   const t = await res.text();\n//   try { return JSON.parse(t); } catch { return t; }\n// }\n\n// // --- Look up existing product by name on the collection endpoint ---\n// // Use filter[name] if your tenant supports it; otherwise fall back to filter[smart].\n// async function findProductByName(name) {\n//   // Try exact name filter first\n//   let url = `${BASE_URL}/${COMPANY_ID}/products?filter[name]=${encodeURIComponent(name)}&count=1`;\n//   let res = await fetch(url, { headers });\n//   if (res.ok) {\n//     const data = await res.json();\n//     const items = Array.isArray(data?.items) ? data.items : (Array.isArray(data) ? data : []);\n//     if (items.length) return items[0];\n//   }\n//   // Fallback: smart filter (searches common fields)\n//   url = `${BASE_URL}/${COMPANY_ID}/products?filter[smart]=${encodeURIComponent(name)}&count=1`;\n//   res = await fetch(url, { headers });\n//   if (!res.ok) return null;\n//   const data2 = await res.json();\n//   const items2 = Array.isArray(data2?.items) ? data2.items : (Array.isArray(data2) ? data2 : []);\n//   return items2.length ? items2[0] : null;\n// }\n\n// class InflowAPI {\n//   /**\n//    * Upsert a product in inFlow via PUT to the collection.\n//    * @param {{ productId?: string, name: string, description: string, imageUrls?: string[], sku?: string }} params\n//    */\n//   static async upsertProduct({ productId, name, description, imageUrls = [], sku }) {\n//     if (!name || !name.trim()) throw new Error('Name is required');\n\n//     // If no productId, check if one already exists with this name to avoid the unique-name error.\n//     if (!productId) {\n//       const existing = await findProductByName(name.trim());\n//       if (existing && (existing.productId || existing.id)) {\n//         productId = existing.productId || existing.id;\n//       }\n//     }\n\n//     // If still no id, generate one (this matched your previously-working flow)\n//     const id = productId || crypto.randomUUID();\n\n//     // Build the payload exactly like your original—PUT to the collection with productId\n//     const payload = {\n//       productId: id,\n//       name,\n//       description,\n//       ...(sku ? { sku } : {}),\n//       ...(imageUrls.length > 0 && {\n//         images: imageUrls.map(u => ({\n//           imageId: crypto.randomUUID(),\n//           originalUrl: u,\n//         })),\n//       }),\n//     };\n\n//     const url = `${BASE_URL}/${COMPANY_ID}/products`;\n//     const res = await fetch(url, {\n//       method: 'PUT',\n//       headers,\n//       body: JSON.stringify(payload),\n//     });\n\n//     if (!res.ok) {\n//       const err = await parseErr(res);\n//       throw new Error(`inFlow API error (${res.status}): ${typeof err === 'string' ? err : JSON.stringify(err)}`);\n//     }\n\n//     return res.json();\n//   }\n// }\n\n// export default InflowAPI;\n\n// utils/inflowAPI.js (only the changed bits)\n\nconst BASE_URL   = 'https://cloudapi.inflowinventory.com';\nconst COMPANY_ID = 'e28dc600-32a4-4438-a374-68df72caebbd';\nconst API_KEY    = '10336E10F0BF982AB7AEB639D2FEB3B2B1C9BD73634D153EA81EE2130A70F9C4-1';\n\nconst headers = {\n  Authorization: `Bearer ${API_KEY}`,\n  'Content-Type': 'application/json',\n  // stick to a stable version you know works in your tenant:\n  Accept: 'application/json;version=2024-10-01',\n};\n\nconst n = s => (s ?? '').toString().trim();\n\nasync function parseText(res) {\n  const t = await res.text();\n  try { return { json: JSON.parse(t), raw: t }; }\n  catch { return { json: null, raw: t }; }\n}\n\n// ---- EXACT lookup helpers (no fuzzy/SMART fallback) ------------------------\n\nasync function findProductIdByExactName(name) {\n  const nameNorm = n(name);\n  if (!nameNorm) return null;\n\n  const url = `${BASE_URL}/${COMPANY_ID}/products?filter[name]=` +\n              `${encodeURIComponent(nameNorm)}&count=1`;\n  const res = await fetch(url, { headers });\n  if (!res.ok) return null;\n\n  const data = await res.json();\n  const items = Array.isArray(data?.items) ? data.items\n              : Array.isArray(data)          ? data\n              : [];\n  const item = items[0];\n  if (!item) return null;\n\n  // guard: only accept if name is an exact (case-insensitive) match\n  if (n(item.name).toLowerCase() !== nameNorm.toLowerCase()) return null;\n  return item.productId || item.id || null;\n}\n\n// Prefer direct GET /products/{id}; fallback to collection filter by id\nasync function getProductById(productId) {\n  // Try item endpoint\n  let res = await fetch(`${BASE_URL}/${COMPANY_ID}/products/${encodeURIComponent(productId)}`, { headers });\n  if (res.ok) return res.json();\n\n  // Fallback: filter by id on collection\n  res = await fetch(`${BASE_URL}/${COMPANY_ID}/products?filter[productId]=${encodeURIComponent(productId)}&count=1`, { headers });\n  if (!res.ok) return null;\n  const data = await res.json();\n  const items = Array.isArray(data?.items) ? data.items\n              : Array.isArray(data)          ? data\n              : [];\n  return items[0] || null;\n}\n\nfunction buildImages(imageUrls = []) {\n  return imageUrls\n    .filter(Boolean)\n    .map(u => ({ imageId: crypto.randomUUID(), originalUrl: u }));\n}\n\nclass InflowAPI {\n  /**\n   * Strict upsert: exact-name reuse only; verify by id afterward.\n   */\n  static async upsertProduct({ productId, name, description, imageUrls = [], sku, customFields }) {\n    const nameNorm = n(name);\n    if (!nameNorm) throw new Error('Name is required');\n\n    // Only reuse an id if the name is an exact match. No SMART search.\n    if (!productId) productId = await findProductIdByExactName(nameNorm);\n    const id = productId || crypto.randomUUID();\n\n    const payload = {\n      productId: id,\n      name: nameNorm,\n      isActive: true, // ← keep new items visible in the UI\n      ...(n(description) ? { description: n(description) } : {}),\n      ...(n(sku) ? { sku: n(sku) } : {}),\n      ...(imageUrls.length ? { images: buildImages(imageUrls) } : {}),\n      ...(customFields && Object.keys(customFields).length ? { customFields } : {}),\n    };\n\n    console.log('[inFlow] PUT payload:', payload);\n    const res = await fetch(`${BASE_URL}/${COMPANY_ID}/products`, {\n      method: 'PUT',\n      headers,\n      body: JSON.stringify(payload),\n    });\n\n    const { json, raw } = await parseText(res);\n    console.log('[inFlow] Raw PUT response:', res.status, raw);\n\n    if (!res.ok) {\n      throw new Error(`inFlow API error (${res.status}): ${raw}`);\n    }\n\n    // prefer the id the server gave us (if any), else the one we sent\n    const resolvedId = (json && (json.productId || json.id)) || id;\n\n    // Verify by ID only (no fuzzy). This prevents false “success”.\n    const after = await getProductById(resolvedId);\n    console.log('[inFlow] Verified by ID:', {\n      productId: resolvedId,\n      name: after?.name,\n      sku: after?.sku,\n      // many tenants surface one of these; log whatever exists so you can tell if it’s hidden\n      isActive: after?.isActive ?? after?.active ?? after?.status,\n      categoryId: after?.categoryId,\n    });\n\n    if (!after) {\n      throw new Error('Write appeared to succeed, but GET by id returned nothing.');\n    }\n\n    return after;\n  }\n}\n\nexport default InflowAPI;\n"]},"metadata":{},"sourceType":"module"}