{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React from 'react';\nimport firebase from \"../context/Firebase\";\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(partsSnapshot.docs.map(async partDoc => {\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n    // console.log(partData);\n\n    if (partData.Machine && partData.Machine instanceof firebase.firestore.DocumentReference) {\n      console.log(partData.Machine);\n      const machineDoc = await partData.Machine.get();\n      partData.machineData = machineDoc.exists ? machineDoc.data() : {};\n\n      if (partData.machineData.client) {\n        const clientDoc = await partData.machineData.client.get();\n        partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    } else {\n      partData.machineData = {};\n    }\n\n    return partData;\n  }));\n  return parts;\n} // Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\n\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const buildPart = async partDoc => {\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n\n    if (partData.Machine && partData.Machine instanceof firebase.firestore.DocumentReference) {\n      const machineDoc = await partData.Machine.get();\n      partData.machineData = machineDoc.exists ? machineDoc.data() : {};\n\n      if (partData.machineData.client) {\n        const clientDoc = await partData.machineData.client.get();\n        partData.machineData.Client = clientDoc.exists ? clientDoc.data().name : \"\";\n      }\n    } else {\n      partData.machineData = {};\n    }\n\n    return partData;\n  };\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let hasNextPage = false;\n\n  while (parts.length < pageSize) {\n    let query = db.collection(\"Test\").limit(limit);\n    if (cursor) query = query.startAfter(cursor);\n    const snap = await query.get();\n\n    if (snap.empty) {\n      hasNextPage = false;\n      break;\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = snap.docs[i];\n      cursor = doc;\n      lastDoc = doc;\n      const raw = doc.data();\n\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      parts.push(await buildPart(doc));\n\n      if (parts.length >= pageSize) {\n        // If there are docs after this one in the current batch, we definitely have a next page.\n        // If we used the full limit, there may also be more beyond this batch.\n        hasNextPage = i < snap.docs.length - 1 || snap.size === limit;\n        return {\n          parts,\n          lastDoc,\n          hasNextPage\n        };\n      }\n    } // We exhausted this batch without filling the page.\n\n\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    } // There might be more docs; continue scanning for visible items.\n\n\n    hasNextPage = true;\n  }\n\n  return {\n    parts,\n    lastDoc,\n    hasNextPage\n  };\n}\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map(doc => _objectSpread({\n    id: doc.id\n  }, doc.data())); // Filter clients based on OEM and Modality if selected\n\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n\n    for (const client of clients) {\n      let match = true;\n\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n\n          if (selectedOEM && machineData.OEM === selectedOEM || selectedModality && machineData.Modality === selectedModality) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n\n    return filteredClients;\n  }\n\n  return clients;\n}\nexport async function fetchModels(selectedOEM, selectedModality, selectedClient) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n  await Promise.all(machinesSnapshot.docs.map(async machineDoc => {\n    const machineData = machineDoc.data();\n    let isValid = true;\n    if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n    if (selectedModality && machineData.Modality !== selectedModality) isValid = false;\n\n    if (selectedClient && machineData.client) {\n      const clientDoc = await machineData.client.get();\n      if (!clientDoc.exists || clientDoc.data().name !== selectedClient) isValid = false;\n    }\n\n    if (isValid) {\n      models.add(machineData.Model);\n    }\n  }));\n  return Array.from(models);\n}\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/utils/fetchAssociations.js"],"names":["React","firebase","fetchPartsWithMachineData","db","firestore","partsSnapshot","collection","get","parts","Promise","all","docs","map","partDoc","partData","data","id","Machine","DocumentReference","console","log","machineDoc","machineData","exists","client","clientDoc","Client","name","fetchPartsWithMachineDataPage","pageSize","startAfterDoc","visibleOnly","limit","buildPart","cursor","lastDoc","hasNextPage","length","query","startAfter","snap","empty","i","doc","raw","visible","push","size","fetchClients","selectedOEM","selectedModality","clientsSnapshot","clients","filteredClients","match","machineRef","machines","OEM","Modality","fetchModels","selectedClient","machinesSnapshot","models","Set","isValid","add","Model","Array","from","formatDate","timestamp","date","toDate","Date","day","String","getDate","padStart","month","getMonth","year","getFullYear"],"mappings":"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","sourcesContent":["import React from 'react'\nimport firebase from \"../context/Firebase\";\n\nexport async function fetchPartsWithMachineData() {\n  const db = firebase.firestore();\n  const partsSnapshot = await db.collection(\"Test\").get();\n  const parts = await Promise.all(\n    partsSnapshot.docs.map(async (partDoc) => {\n      const partData = partDoc.data();\n      partData.id = partDoc.id; // Add document ID here\n      // console.log(partData);\n      if (\n        partData.Machine &&\n        partData.Machine instanceof firebase.firestore.DocumentReference\n      ) {\n        console.log(partData.Machine);\n        const machineDoc = await partData.Machine.get();\n        partData.machineData = machineDoc.exists ? machineDoc.data() : {};\n        if (partData.machineData.client) {\n          const clientDoc = await partData.machineData.client.get();\n          partData.machineData.Client = clientDoc.exists\n            ? clientDoc.data().name\n            : \"\";\n        }\n      } else {\n        partData.machineData = {};\n      }\n      return partData;\n    })\n  );\n  return parts;\n}\n\n// Paginated version for faster list views (e.g., mainSearch).\n// Uses documentId order for stable pagination.\nexport async function fetchPartsWithMachineDataPage({\n  pageSize = 25,\n  startAfterDoc = null,\n  visibleOnly = false,\n} = {}) {\n  const db = firebase.firestore();\n  const limit = pageSize + 1;\n\n  const buildPart = async (partDoc) => {\n    const partData = partDoc.data();\n    partData.id = partDoc.id; // Add document ID here\n    if (\n      partData.Machine &&\n      partData.Machine instanceof firebase.firestore.DocumentReference\n    ) {\n      const machineDoc = await partData.Machine.get();\n      partData.machineData = machineDoc.exists ? machineDoc.data() : {};\n      if (partData.machineData.client) {\n        const clientDoc = await partData.machineData.client.get();\n        partData.machineData.Client = clientDoc.exists\n          ? clientDoc.data().name\n          : \"\";\n      }\n    } else {\n      partData.machineData = {};\n    }\n    return partData;\n  };\n\n  let parts = [];\n  let cursor = startAfterDoc || null;\n  let lastDoc = null;\n  let hasNextPage = false;\n\n  while (parts.length < pageSize) {\n    let query = db.collection(\"Test\").limit(limit);\n    if (cursor) query = query.startAfter(cursor);\n\n    const snap = await query.get();\n    if (snap.empty) {\n      hasNextPage = false;\n      break;\n    }\n\n    for (let i = 0; i < snap.docs.length; i++) {\n      const doc = snap.docs[i];\n      cursor = doc;\n      lastDoc = doc;\n\n      const raw = doc.data();\n      if (visibleOnly && raw.visible === false) {\n        continue; // skip hidden items but keep advancing the cursor\n      }\n\n      parts.push(await buildPart(doc));\n      if (parts.length >= pageSize) {\n        // If there are docs after this one in the current batch, we definitely have a next page.\n        // If we used the full limit, there may also be more beyond this batch.\n        hasNextPage = i < snap.docs.length - 1 || snap.size === limit;\n        return { parts, lastDoc, hasNextPage };\n      }\n    }\n\n    // We exhausted this batch without filling the page.\n    if (snap.size < limit) {\n      hasNextPage = false;\n      break;\n    }\n\n    // There might be more docs; continue scanning for visible items.\n    hasNextPage = true;\n  }\n\n  return { parts, lastDoc, hasNextPage };\n}\n\nexport async function fetchClients(selectedOEM, selectedModality) {\n  const db = firebase.firestore();\n  const clientsSnapshot = await db.collection(\"Client\").get();\n  const clients = clientsSnapshot.docs.map((doc) => ({\n    id: doc.id,\n    ...doc.data(),\n  }));\n\n  // Filter clients based on OEM and Modality if selected\n  if (selectedOEM || selectedModality) {\n    const filteredClients = [];\n    for (const client of clients) {\n      let match = true;\n      if (selectedOEM || selectedModality) {\n        for (const machineRef of client.machines) {\n          const machineDoc = await machineRef.get();\n          const machineData = machineDoc.data();\n          if (\n            (selectedOEM && machineData.OEM === selectedOEM) ||\n            (selectedModality && machineData.Modality === selectedModality)\n          ) {\n            match = true;\n            break;\n          } else {\n            match = false;\n          }\n        }\n      }\n      if (match) {\n        filteredClients.push(client);\n      }\n    }\n    return filteredClients;\n  }\n\n  return clients;\n}\n\nexport async function fetchModels(\n  selectedOEM,\n  selectedModality,\n  selectedClient\n) {\n  const db = firebase.firestore();\n  const machinesSnapshot = await db.collection(\"Machine\").get();\n  const models = new Set();\n\n  await Promise.all(\n    machinesSnapshot.docs.map(async (machineDoc) => {\n      const machineData = machineDoc.data();\n      let isValid = true;\n\n      if (selectedOEM && machineData.OEM !== selectedOEM) isValid = false;\n      if (selectedModality && machineData.Modality !== selectedModality)\n        isValid = false;\n      if (selectedClient && machineData.client) {\n        const clientDoc = await machineData.client.get();\n        if (!clientDoc.exists || clientDoc.data().name !== selectedClient)\n          isValid = false;\n      }\n\n      if (isValid) {\n        models.add(machineData.Model);\n      }\n    })\n  );\n\n  return Array.from(models);\n}\n\nexport function formatDate(timestamp) {\n  if (!timestamp) return \"\";\n  let date;\n  if (timestamp.toDate) {\n    date = timestamp.toDate();\n  } else if (typeof timestamp === \"string\" || typeof timestamp === \"number\") {\n    date = new Date(timestamp);\n  } else {\n    return \"\"; // handle unexpected formats\n  }\n  const day = String(date.getDate()).padStart(2, \"0\");\n  const month = String(date.getMonth() + 1).padStart(2, \"0\");\n  const year = date.getFullYear();\n  return `${month}/${day}/${year}`;\n}\n"]},"metadata":{},"sourceType":"module"}