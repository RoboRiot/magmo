{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  if (req.method !== \"POST\") return res.status(405).json({\n    error: \"Method not allowed\"\n  });\n\n  try {\n    const {\n      listKey,\n      // \"tasks\" | \"shipping\" | \"receiving\"\n      // common\n      title,\n      // fallback text if nothing else\n      linkUrl,\n      // Magmo item URL (we'll put it in the Description bottom)\n      bodyText,\n      // used by Tasks as multiline description blob\n      // shipping/receiving specific (all optional; fill what you have)\n      date,\n      // \"YYYY-MM-DD\"\n      pn,\n      // string | string[]\n      sn,\n      // string | string[]\n      dom,\n      // string (DOM)\n      trackingNumber,\n      // string\n      poNumber,\n      // string\n      workOrder,\n      // string\n      localSN,\n      // string\n      description,\n      // string (we’ll append the Magmo link to this)\n      photoUrls = [] // array of image URLs (optional)\n\n    } = req.body;\n    const LIST_IDS = {\n      receiving: process.env.SLACK_LIST_RECEIVING_ID,\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\n      tasks: process.env.SLACK_LIST_TASKS_ID\n    };\n    const list_id = LIST_IDS[listKey];\n    if (!list_id) return res.status(400).json({\n      error: \"Unknown listKey\"\n    });\n    const token = process.env.SLACK_BOT_TOKEN;\n    if (!token) return res.status(500).json({\n      error: \"Missing bot token\"\n    }); // Helper to call Slack Web API\n\n    const slack = async (method, body, headers = {}) => {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: _objectSpread({\n          Authorization: `Bearer ${token}`\n        }, headers),\n        body\n      }).then(r => r.json());\n      return r;\n    }; // 1) Discover columns for the target list\n\n\n    const colsResp = await slack(\"slackLists.columns.list\", new URLSearchParams({\n      list_id\n    }));\n\n    if (!(colsResp !== null && colsResp !== void 0 && colsResp.ok)) {\n      return res.status(400).json({\n        error: (colsResp === null || colsResp === void 0 ? void 0 : colsResp.error) || \"Failed to list columns\",\n        raw: colsResp\n      });\n    }\n\n    const columns = colsResp.columns || []; // Utility: find a column by a loose title match\n\n    const byTitle = needleArr => columns.find(c => {\n      const t = (c.title || \"\").toLowerCase();\n      return needleArr.some(n => t.includes(n));\n    }); // 2) Decide which columns we’ll fill for each list type\n    // Adjust the names below to match your exact column headers in Slack\n\n\n    const map = listKey === \"tasks\" ? {\n      primary: byTitle([\"task\"]) || columns[0],\n      // where the rich_text blob goes\n      description: byTitle([\"description\"]) // optional second rich_text column\n\n    } : {\n      item: byTitle([\"item\"]) || columns[0],\n      date: byTitle([\"received\", \"shipping date\", \"date\"]),\n      pnSnDom: byTitle([\"pn\", \"sn\", \"dom\"]),\n      // if you have one combined column\n      tracking: byTitle([\"tracking\"]),\n      po: byTitle([\"po\"]),\n      wo: byTitle([\"work order\", \"wo\"]),\n      localSNCol: byTitle([\"local sn\"]),\n      description: byTitle([\"description\"]),\n      photos: byTitle([\"photos\", \"receiving photos\", \"shipping photos\"]) // should be Files type\n\n    }; // 3) Build field payloads per column\n\n    const fields = []; // --- TASKS behavior (rich_text blob; Magmo link moved to bottom of description if present) ---\n\n    if (listKey === \"tasks\") {\n      var _map$primary, _map$description;\n\n      // Decide the \"primary\" rich_text column id to write into\n      const primaryColId = (_map$primary = map.primary) === null || _map$primary === void 0 ? void 0 : _map$primary.id;\n      if (!primaryColId) return res.status(500).json({\n        error: \"Could not determine a Task text column\"\n      });\n\n      const mkSections = lines => lines.map(line => ({\n        type: \"rich_text_section\",\n        elements: [{\n          type: \"text\",\n          text: line\n        }]\n      })); // If you want to use bodyText lines, otherwise fallback to title\n\n\n      const elements = bodyText && bodyText.trim() ? mkSections(bodyText.replace(/\\r\\n/g, \"\\n\").split(\"\\n\").map(s => s.trim()).filter(Boolean)) : mkSections([title || \"Untitled item\"]); // If you have a dedicated Description column, put the Magmo link there instead of title\n\n      if ((_map$description = map.description) !== null && _map$description !== void 0 && _map$description.id && linkUrl) {\n        fields.push({\n          column_id: map.description.id,\n          rich_text: [{\n            type: \"rich_text\",\n            elements: [{\n              type: \"rich_text_section\",\n              elements: [{\n                type: \"text\",\n                text: bodyText || title || \"—\"\n              }]\n            }, {\n              type: \"rich_text_section\",\n              elements: [{\n                type: \"link\",\n                url: linkUrl,\n                text: \"Open in Magmo\"\n              }]\n            }]\n          }]\n        });\n      } else if (linkUrl) {\n        // otherwise append link at the end of the primary blob\n        elements.push({\n          type: \"rich_text_section\",\n          elements: [{\n            type: \"link\",\n            url: linkUrl,\n            text: \"Open in Magmo\"\n          }]\n        });\n      }\n\n      fields.push({\n        column_id: primaryColId,\n        rich_text: [{\n          type: \"rich_text\",\n          elements\n        }]\n      });\n    } // --- SHIPPING / RECEIVING behavior ---\n    else {\n        var _map$date, _map$pnSnDom, _map$photos;\n\n        // Helper: add text cell if column exists\n        const addText = (col, text) => {\n          if (col !== null && col !== void 0 && col.id && text != null && String(text).trim() !== \"\") {\n            fields.push({\n              column_id: col.id,\n              text: String(text)\n            });\n          }\n        }; // Helper: add rich_text cell (for Description so we can put link at bottom)\n\n\n        const addRich = (col, lines, linkUrl) => {\n          if (!(col !== null && col !== void 0 && col.id)) return;\n          const elements = [];\n\n          if (lines !== null && lines !== void 0 && lines.length) {\n            for (const line of lines) {\n              elements.push({\n                type: \"rich_text_section\",\n                elements: [{\n                  type: \"text\",\n                  text: line\n                }]\n              });\n            }\n          }\n\n          if (linkUrl) {\n            elements.push({\n              type: \"rich_text_section\",\n              elements: [{\n                type: \"link\",\n                url: linkUrl,\n                text: \"Open in Magmo\"\n              }]\n            });\n          }\n\n          fields.push({\n            column_id: col.id,\n            rich_text: [{\n              type: \"rich_text\",\n              elements\n            }]\n          });\n        }; // Item / Title\n\n\n        addText(map.item, title || \"Untitled item\"); // Date (Slack’s list date cells accept \"YYYY-MM-DD\")\n\n        if ((_map$date = map.date) !== null && _map$date !== void 0 && _map$date.id && date) fields.push({\n          column_id: map.date.id,\n          date\n        }); // PN/SN/DOM combined\n\n        if ((_map$pnSnDom = map.pnSnDom) !== null && _map$pnSnDom !== void 0 && _map$pnSnDom.id) {\n          const pnStr = Array.isArray(pn) ? pn.filter(Boolean).join(\", \") : pn || \"\";\n          const snStr = Array.isArray(sn) ? sn.filter(Boolean).join(\", \") : sn || \"\";\n          const lines = [];\n          if (pnStr) lines.push(`PN: ${pnStr}`);\n          if (snStr) lines.push(`SN: ${snStr}`);\n          if (dom) lines.push(`DOM: ${dom}`);\n          addRich(map.pnSnDom, lines);\n        }\n\n        addText(map.tracking, trackingNumber);\n        addText(map.po, poNumber);\n        addText(map.wo, workOrder);\n        addText(map.localSNCol, localSN); // Description with the link at the bottom\n\n        addRich(map.description, description ? [description] : [], linkUrl); // Photos: optional – requires files:write scope and a Files column\n\n        if ((_map$photos = map.photos) !== null && _map$photos !== void 0 && _map$photos.id && Array.isArray(photoUrls) && photoUrls.length) {\n          // Use Slack’s External upload flow so you don’t have to stream the image through your server\n          // If you’d rather use files.upload, swap the flow accordingly.\n          const fileIds = [];\n\n          for (const url of photoUrls) {\n            var _complete$files, _complete$files$;\n\n            // 1) ask Slack for an upload URL\n            const up = await slack(\"files.getUploadURLExternal\", new URLSearchParams({\n              filename: url.split(\"/\").pop() || \"image.jpg\"\n            }));\n            if (!(up !== null && up !== void 0 && up.ok) || !(up !== null && up !== void 0 && up.upload_url)) continue; // 2) fetch the image from your source & PUT to upload_url\n\n            try {\n              const img = await fetch(url);\n              const buf = await img.arrayBuffer();\n              await fetch(up.upload_url, {\n                method: \"PUT\",\n                body: Buffer.from(buf)\n              });\n            } catch (e) {\n              /* swallow */\n            } // 3) complete the upload and get a file id\n\n\n            const complete = await slack(\"files.completeUploadExternal\", JSON.stringify({\n              files: [{\n                id: up.file_id,\n                title: \"photo\"\n              }]\n            }), {\n              \"Content-Type\": \"application/json\"\n            });\n\n            if (complete !== null && complete !== void 0 && complete.ok && complete !== null && complete !== void 0 && (_complete$files = complete.files) !== null && _complete$files !== void 0 && (_complete$files$ = _complete$files[0]) !== null && _complete$files$ !== void 0 && _complete$files$.id) {\n              fileIds.push(complete.files[0].id);\n            }\n          }\n\n          if (fileIds.length) {\n            fields.push({\n              column_id: map.photos.id,\n              files: fileIds.map(id => ({\n                file_id: id\n              }))\n            });\n          }\n        }\n      } // 4) Create the item with all fields\n\n\n    const payload = {\n      list_id,\n      initial_fields: fields\n    };\n    const createResp = await slack(\"slackLists.items.create\", JSON.stringify(payload), {\n      \"Content-Type\": \"application/json; charset=utf-8\"\n    });\n\n    if (!(createResp !== null && createResp !== void 0 && createResp.ok)) {\n      return res.status(400).json({\n        error: (createResp === null || createResp === void 0 ? void 0 : createResp.error) || \"Slack API error\",\n        raw: createResp\n      });\n    }\n\n    return res.status(200).json({\n      ok: true,\n      item: createResp.item\n    });\n  } catch (e) {\n    console.error(e);\n    return res.status(500).json({\n      error: \"Server error\"\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","error","listKey","title","linkUrl","bodyText","date","pn","sn","dom","trackingNumber","poNumber","workOrder","localSN","description","photoUrls","body","LIST_IDS","receiving","process","env","SLACK_LIST_RECEIVING_ID","shipping","SLACK_LIST_SHIPPING_ID","tasks","SLACK_LIST_TASKS_ID","list_id","token","SLACK_BOT_TOKEN","slack","headers","r","fetch","Authorization","then","colsResp","URLSearchParams","ok","raw","columns","byTitle","needleArr","find","c","t","toLowerCase","some","n","includes","map","primary","item","pnSnDom","tracking","po","wo","localSNCol","photos","fields","primaryColId","id","mkSections","lines","line","type","elements","text","trim","replace","split","s","filter","Boolean","push","column_id","rich_text","url","addText","col","String","addRich","length","pnStr","Array","isArray","join","snStr","fileIds","up","filename","pop","upload_url","img","buf","arrayBuffer","Buffer","from","e","complete","JSON","stringify","files","file_id","payload","initial_fields","createResp","console"],"mappings":"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","sourcesContent":["// pages/api/slack/add-to-list.js\r\nexport default async function handler(req, res) {\r\n  if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\r\n\r\n  try {\r\n    const {\r\n      listKey,                // \"tasks\" | \"shipping\" | \"receiving\"\r\n      // common\r\n      title,                  // fallback text if nothing else\r\n      linkUrl,                // Magmo item URL (we'll put it in the Description bottom)\r\n      bodyText,               // used by Tasks as multiline description blob\r\n\r\n      // shipping/receiving specific (all optional; fill what you have)\r\n      date,                   // \"YYYY-MM-DD\"\r\n      pn,                     // string | string[]\r\n      sn,                     // string | string[]\r\n      dom,                    // string (DOM)\r\n      trackingNumber,         // string\r\n      poNumber,               // string\r\n      workOrder,              // string\r\n      localSN,                // string\r\n      description,            // string (we’ll append the Magmo link to this)\r\n      photoUrls = [],         // array of image URLs (optional)\r\n    } = req.body;\r\n\r\n    const LIST_IDS = {\r\n      receiving: process.env.SLACK_LIST_RECEIVING_ID,\r\n      shipping:  process.env.SLACK_LIST_SHIPPING_ID,\r\n      tasks:     process.env.SLACK_LIST_TASKS_ID,\r\n    };\r\n\r\n    const list_id = LIST_IDS[listKey];\r\n    if (!list_id) return res.status(400).json({ error: \"Unknown listKey\" });\r\n\r\n    const token = process.env.SLACK_BOT_TOKEN;\r\n    if (!token) return res.status(500).json({ error: \"Missing bot token\" });\r\n\r\n    // Helper to call Slack Web API\r\n    const slack = async (method, body, headers = {}) => {\r\n      const r = await fetch(`https://slack.com/api/${method}`, {\r\n        method: \"POST\",\r\n        headers: { Authorization: `Bearer ${token}`, ...headers },\r\n        body\r\n      }).then(r => r.json());\r\n      return r;\r\n    };\r\n\r\n    // 1) Discover columns for the target list\r\n    const colsResp = await slack(\r\n      \"slackLists.columns.list\",\r\n      new URLSearchParams({ list_id })\r\n    );\r\n    if (!colsResp?.ok) {\r\n      return res.status(400).json({ error: colsResp?.error || \"Failed to list columns\", raw: colsResp });\r\n    }\r\n\r\n    const columns = colsResp.columns || [];\r\n\r\n    // Utility: find a column by a loose title match\r\n    const byTitle = (needleArr) => columns.find(c => {\r\n      const t = (c.title || \"\").toLowerCase();\r\n      return needleArr.some(n => t.includes(n));\r\n    });\r\n\r\n    // 2) Decide which columns we’ll fill for each list type\r\n    // Adjust the names below to match your exact column headers in Slack\r\n    const map = (listKey === \"tasks\")\r\n      ? {\r\n          primary: byTitle([\"task\"]) || columns[0],               // where the rich_text blob goes\r\n          description: byTitle([\"description\"]),                  // optional second rich_text column\r\n        }\r\n      : {\r\n          item:        byTitle([\"item\"]) || columns[0],\r\n          date:        byTitle([\"received\", \"shipping date\", \"date\"]),\r\n          pnSnDom:     byTitle([\"pn\", \"sn\", \"dom\"]),              // if you have one combined column\r\n          tracking:    byTitle([\"tracking\"]),\r\n          po:          byTitle([\"po\"]),\r\n          wo:          byTitle([\"work order\",\"wo\"]),\r\n          localSNCol:  byTitle([\"local sn\"]),\r\n          description: byTitle([\"description\"]),\r\n          photos:      byTitle([\"photos\", \"receiving photos\", \"shipping photos\"]), // should be Files type\r\n        };\r\n\r\n    // 3) Build field payloads per column\r\n    const fields = [];\r\n\r\n    // --- TASKS behavior (rich_text blob; Magmo link moved to bottom of description if present) ---\r\n    if (listKey === \"tasks\") {\r\n      // Decide the \"primary\" rich_text column id to write into\r\n      const primaryColId = map.primary?.id;\r\n      if (!primaryColId) return res.status(500).json({ error: \"Could not determine a Task text column\" });\r\n\r\n      const mkSections = (lines) => lines.map(line => ({\r\n        type: \"rich_text_section\",\r\n        elements: [{ type: \"text\", text: line }]\r\n      }));\r\n\r\n      // If you want to use bodyText lines, otherwise fallback to title\r\n      const elements = (bodyText && bodyText.trim())\r\n        ? mkSections(bodyText.replace(/\\r\\n/g, \"\\n\").split(\"\\n\").map(s => s.trim()).filter(Boolean))\r\n        : mkSections([title || \"Untitled item\"]);\r\n\r\n      // If you have a dedicated Description column, put the Magmo link there instead of title\r\n      if (map.description?.id && linkUrl) {\r\n        fields.push({\r\n          column_id: map.description.id,\r\n          rich_text: [{\r\n            type: \"rich_text\",\r\n            elements: [\r\n              { type: \"rich_text_section\", elements: [{ type: \"text\", text: bodyText || title || \"—\" }] },\r\n              { type: \"rich_text_section\", elements: [{ type: \"link\", url: linkUrl, text: \"Open in Magmo\" }] },\r\n            ]\r\n          }]\r\n        });\r\n      } else if (linkUrl) {\r\n        // otherwise append link at the end of the primary blob\r\n        elements.push({ type: \"rich_text_section\", elements: [{ type: \"link\", url: linkUrl, text: \"Open in Magmo\" }] });\r\n      }\r\n\r\n      fields.push({\r\n        column_id: primaryColId,\r\n        rich_text: [{ type: \"rich_text\", elements }]\r\n      });\r\n    }\r\n\r\n    // --- SHIPPING / RECEIVING behavior ---\r\n    else {\r\n      // Helper: add text cell if column exists\r\n      const addText = (col, text) => {\r\n        if (col?.id && text != null && String(text).trim() !== \"\") {\r\n          fields.push({ column_id: col.id, text: String(text) });\r\n        }\r\n      };\r\n\r\n      // Helper: add rich_text cell (for Description so we can put link at bottom)\r\n      const addRich = (col, lines, linkUrl) => {\r\n        if (!col?.id) return;\r\n        const elements = [];\r\n        if (lines?.length) {\r\n          for (const line of lines) {\r\n            elements.push({ type: \"rich_text_section\", elements: [{ type: \"text\", text: line }] });\r\n          }\r\n        }\r\n        if (linkUrl) {\r\n          elements.push({ type: \"rich_text_section\", elements: [{ type: \"link\", url: linkUrl, text: \"Open in Magmo\" }] });\r\n        }\r\n        fields.push({ column_id: col.id, rich_text: [{ type: \"rich_text\", elements }] });\r\n      };\r\n\r\n      // Item / Title\r\n      addText(map.item, title || \"Untitled item\");\r\n\r\n      // Date (Slack’s list date cells accept \"YYYY-MM-DD\")\r\n      if (map.date?.id && date) fields.push({ column_id: map.date.id, date });\r\n\r\n      // PN/SN/DOM combined\r\n      if (map.pnSnDom?.id) {\r\n        const pnStr = Array.isArray(pn) ? pn.filter(Boolean).join(\", \") : (pn || \"\");\r\n        const snStr = Array.isArray(sn) ? sn.filter(Boolean).join(\", \") : (sn || \"\");\r\n        const lines = [];\r\n        if (pnStr) lines.push(`PN: ${pnStr}`);\r\n        if (snStr) lines.push(`SN: ${snStr}`);\r\n        if (dom)  lines.push(`DOM: ${dom}`);\r\n        addRich(map.pnSnDom, lines);\r\n      }\r\n\r\n      addText(map.tracking,    trackingNumber);\r\n      addText(map.po,          poNumber);\r\n      addText(map.wo,          workOrder);\r\n      addText(map.localSNCol,  localSN);\r\n\r\n      // Description with the link at the bottom\r\n      addRich(map.description, (description ? [description] : []), linkUrl);\r\n\r\n      // Photos: optional – requires files:write scope and a Files column\r\n      if (map.photos?.id && Array.isArray(photoUrls) && photoUrls.length) {\r\n        // Use Slack’s External upload flow so you don’t have to stream the image through your server\r\n        // If you’d rather use files.upload, swap the flow accordingly.\r\n        const fileIds = [];\r\n        for (const url of photoUrls) {\r\n          // 1) ask Slack for an upload URL\r\n          const up = await slack(\r\n            \"files.getUploadURLExternal\",\r\n            new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" })\r\n          );\r\n          if (!up?.ok || !up?.upload_url) continue;\r\n\r\n          // 2) fetch the image from your source & PUT to upload_url\r\n          try {\r\n            const img = await fetch(url);\r\n            const buf = await img.arrayBuffer();\r\n            await fetch(up.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\r\n          } catch (e) { /* swallow */ }\r\n\r\n          // 3) complete the upload and get a file id\r\n          const complete = await slack(\r\n            \"files.completeUploadExternal\",\r\n            JSON.stringify({\r\n              files: [{ id: up.file_id, title: \"photo\" }],\r\n            }),\r\n            { \"Content-Type\": \"application/json\" }\r\n          );\r\n          if (complete?.ok && complete?.files?.[0]?.id) {\r\n            fileIds.push(complete.files[0].id);\r\n          }\r\n        }\r\n\r\n        if (fileIds.length) {\r\n          fields.push({\r\n            column_id: map.photos.id,\r\n            files: fileIds.map(id => ({ file_id: id }))\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // 4) Create the item with all fields\r\n    const payload = { list_id, initial_fields: fields };\r\n    const createResp = await slack(\r\n      \"slackLists.items.create\",\r\n      JSON.stringify(payload),\r\n      { \"Content-Type\": \"application/json; charset=utf-8\" }\r\n    );\r\n\r\n    if (!createResp?.ok) {\r\n      return res.status(400).json({ error: createResp?.error || \"Slack API error\", raw: createResp });\r\n    }\r\n\r\n    return res.status(200).json({ ok: true, item: createResp.item });\r\n  } catch (e) {\r\n    console.error(e);\r\n    return res.status(500).json({ error: \"Server error\" });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}