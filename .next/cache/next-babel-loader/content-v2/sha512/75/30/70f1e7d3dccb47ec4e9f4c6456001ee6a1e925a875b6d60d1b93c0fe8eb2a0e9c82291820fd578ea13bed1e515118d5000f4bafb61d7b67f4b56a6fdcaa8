{"ast":null,"code":"// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\n//   try {\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\n//     const {\n//       listKey,            // \"receiving\" | \"shipping\" | \"tasks\"\n//       title, linkUrl, bodyText,\n//       date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\n//       photoUrls = [],\n//     } = req.body;\n//     const LISTS = {\n//       receiving: {\n//         id: process.env.SLACK_LIST_RECEIVING_ID,\n//         cols: {\n//           desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n//           date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\n//           pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n//           track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n//           wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\n//           lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n//           photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // attachment\n//         },\n//       },\n//       shipping: {\n//         id: process.env.SLACK_LIST_SHIPPING_ID,\n//         cols: {\n//           desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n//           date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\n//           pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n//           track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n//           wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\n//           lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n//           photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,  // attachment\n//         },\n//       },\n//       tasks: {\n//         id: process.env.SLACK_LIST_TASKS_ID,\n//         cols: {\n//           desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\n//         },\n//       },\n//     };\n//     const CHANNELS = {\n//       receiving: process.env.SLACK_CHANNEL_RECEIVING_ID,\n//       shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,\n//       tasks:     process.env.SLACK_CHANNEL_TASKS_ID,\n//     };\n//     const headersJson = {\n//       Authorization: `Bearer ${token}`,\n//       \"Content-Type\": \"application/json; charset=utf-8\",\n//     };\n//     const slack = (method, body, headers = headersJson) =>\n//       fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body })\n//         .then(r => r.json());\n//     const plain = v => (v ?? \"\").toString().trim();\n//     const safe  = plain;\n//     const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     // ---------- PATH A: Write to a LIST ----------\n//     const cfg = LISTS[listKey];\n//     if (cfg?.id) {\n//       const fields = [];\n//       // Description column\n//       if (cfg.cols.desc && (description || bodyText || linkUrl)) {\n//         const textBits = [\n//           description,\n//           (listKey === \"tasks\" && bodyText) ? bodyText : null,\n//           linkUrl ? `<${linkUrl}|Open in Magmo>` : null,\n//         ].filter(Boolean).join(\"\\n\");\n//         fields.push({ column_id: cfg.cols.desc, value: { text: textBits } });\n//       }\n//       if (cfg.cols.date && date) fields.push({ column_id: cfg.cols.date, value: { date } });\n//       if (cfg.cols.pn && (pn || sn || dom)) {\n//         const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : (pn ? `PN: ${pn}` : \"\");\n//         const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : (sn ? `SN: ${sn}` : \"\");\n//         const domLine = dom ? `DOM: ${dom}` : \"\";\n//         const pnBlock = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\n//         if (pnBlock) fields.push({ column_id: cfg.cols.pn, value: { text: pnBlock } });\n//       }\n//       if (cfg.cols.track && (trackingNumber || poNumber)) {\n//         const t = [\n//           trackingNumber ? `RL: ${trackingNumber}` : \"\",\n//           poNumber ? `PO: ${poNumber}` : \"\",\n//         ].filter(Boolean).join(\"  \");\n//         if (t) fields.push({ column_id: cfg.cols.track, value: { text: t } });\n//       }\n//       if (cfg.cols.wo && workOrder) fields.push({ column_id: cfg.cols.wo,  value: { text: `WO: ${workOrder}` } });\n//       if (cfg.cols.lsn && localSN)  fields.push({ column_id: cfg.cols.lsn, value: { text: localSN } });\n//       // NOW build the create body (cfg & fields exist)\n//       const createBody = {\n//         list_id: cfg.id,\n//         title: plain(title) || plain(localSN) || \"Untitled\",\n//         fields,\n//       };\n//       const created = await slack(\"slackLists.items.create\", JSON.stringify(createBody));\n//       if (!created?.ok) {\n//         console.error(\"slackLists.items.create error:\", created);\n//         return res.status(400).json({ error: created?.error || \"Slack Lists API error\", raw: created });\n//       }\n//       // Photos -> attachment column\n//       if (cfg.cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\n//         const fileIds = [];\n//         for (const url of photoUrls) {\n//           const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\n//             method: \"POST\",\n//             headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\n//             body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\n//           }).then(r => r.json());\n//           if (!init?.ok || !init?.upload_url) continue;\n//           try {\n//             const img = await fetch(url);\n//             const buf = await img.arrayBuffer();\n//             await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\n//           } catch (_) {}\n//           const complete = await slack(\"files.completeUploadExternal\",\n//             JSON.stringify({ files: [{ id: init.file_id, title: \"photo\" }] })\n//           );\n//           if (complete?.ok && complete?.files?.[0]?.id) fileIds.push(complete.files[0].id);\n//         }\n//         if (fileIds.length) {\n//           await slack(\"slackLists.items.update\", JSON.stringify({\n//             list_id: cfg.id,\n//             item_id: created.item.id,\n//             fields: [{ column_id: cfg.cols.photos, value: { attachment: { file_ids: fileIds } } }],\n//           }));\n//         }\n//       }\n//       return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: created.item.id });\n//     }\n//     // ---------- PATH B: Fallback to a channel post ----------\n//     const channel = CHANNELS[listKey];\n//     if (!channel) return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\n//     // Try to join public channels to avoid channel_not_found\n//     await fetch(\"https://slack.com/api/conversations.join\", {\n//       method: \"POST\",\n//       headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\n//       body: new URLSearchParams({ channel }),\n//     });\n//     const safeId = plain(linkUrl?.split(\"/\").pop()) || plain(localSN) || \"\";\n//     const safeTitle = plain(title) || plain(req.body?.title) || (safeId ? `Item ${safeId}` : \"New Item\");\n//     const lines = [];\n//     lines.push(`*${safeTitle}*`);\n//     const pnStr = joinArr(pn);\n//     const snStr = joinArr(sn);\n//     if (pnStr) lines.push(`PN: ${pnStr}`);\n//     if (snStr) lines.push(`SN: ${snStr}`);\n//     if (safe(workOrder)) lines.push(`WO: ${safe(workOrder)}`);\n//     if (safe(poNumber)) lines.push(`PO: ${safe(poNumber)}`);\n//     if (safe(trackingNumber)) lines.push(`RL: ${safe(trackingNumber)}`);\n//     if (safe(dom)) lines.push(`DOM: ${safe(dom)}`);\n//     if (safe(localSN)) lines.push(`Local SN: ${safe(localSN)}`);\n//     if (safe(date)) lines.push(`Date: ${safe(date)}`);\n//     const desc = safe(description);\n//     if (desc) lines.push(desc);\n//     else if (listKey === \"tasks\" && safe(bodyText)) lines.push(safe(bodyText));\n//     if (safe(linkUrl)) lines.push(`<${safe(linkUrl)}|Open in Magmo>`);\n//     const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\n//     const posted = await slack(\"chat.postMessage\", JSON.stringify({ channel, text }));\n//     if (!posted?.ok) {\n//       console.error(\"chat.postMessage error:\", posted);\n//       return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\n//     }\n//     return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\n//   } catch (e) {\n//     console.error(\"API /slack/add-to-list crashed:\", e);\n//     return res.status(500).json({ error: \"Server error\" });\n//   }\n// }\n// pages/api/slack/add-to-list.js\n// Requires Slack scopes: lists:write (and lists:read if you want auto-detection)\nexport default async function handler(req, res) {\n  var _LISTS$which;\n\n  if (req.method !== 'POST') {\n    return res.status(405).json({\n      ok: false,\n      error: 'method_not_allowed'\n    });\n  }\n\n  const {\n    which = 'tasks',\n    // 'tasks' | 'shipping' | 'receiving'\n    name,\n    // string to show in the Task column\n    debug = true // include verbose debug in API response\n\n  } = req.body || {};\n\n  if (!process.env.SLACK_BOT_TOKEN) {\n    return res.status(500).json({\n      ok: false,\n      error: 'missing_SLACK_BOT_TOKEN'\n    });\n  }\n\n  if (!name || typeof name !== 'string') {\n    return res.status(400).json({\n      ok: false,\n      error: 'missing_or_invalid_name'\n    });\n  } // ---- Lists you use (IDs come from your .env) ----\n\n\n  const LISTS = {\n    tasks: {\n      listId: process.env.SLACK_LIST_TASKS_ID,\n      // Optional: set this if you already know the ID of the \"Task\" text column\n      titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null\n    },\n    shipping: {\n      listId: process.env.SLACK_LIST_SHIPPING_ID,\n      titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null\n    },\n    receiving: {\n      listId: process.env.SLACK_LIST_RECEIVING_ID,\n      titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null\n    }\n  };\n\n  if (!((_LISTS$which = LISTS[which]) !== null && _LISTS$which !== void 0 && _LISTS$which.listId)) {\n    return res.status(400).json({\n      ok: false,\n      error: `missing_list_id_for_${which}`\n    });\n  }\n\n  const token = process.env.SLACK_BOT_TOKEN;\n\n  async function slack(method, payload) {\n    const resp = await fetch(`https://slack.com/api/${method}`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json; charset=utf-8'\n      },\n      body: JSON.stringify(payload)\n    });\n    const json = await resp.json();\n    return json;\n  } // Convert plain text to Slack rich_text for a text column\n\n\n  function toRichText(text) {\n    return [{\n      type: 'rich_text',\n      elements: [{\n        type: 'rich_text_section',\n        elements: [{\n          type: 'text',\n          text\n        }]\n      }]\n    }];\n  } // Try to discover the text column that represents the \"Task\" header\n\n\n  async function resolveTitleColumnId(listId, providedColId) {\n    if (providedColId) return {\n      colId: providedColId,\n      source: 'env'\n    }; // Heuristic: read a few items and look for a field whose key looks like \"Task\",\n    // otherwise fall back to the first field with 'text' or 'rich_text'.\n\n    const probe = await slack('slackLists.items.list', {\n      list_id: listId,\n      limit: 50\n    });\n\n    if (!(probe !== null && probe !== void 0 && probe.ok)) {\n      return {\n        colId: null,\n        source: 'auto',\n        error: (probe === null || probe === void 0 ? void 0 : probe.error) || 'items.list_failed'\n      };\n    }\n\n    let candidate = null;\n\n    for (const item of probe.items || []) {\n      for (const f of item.fields || []) {\n        // Prefer a column literally called \"Task\"\n        const key = (f.key || '').trim().toLowerCase();\n        const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\n\n        if (key === 'task' && f.column_id && hasText) {\n          return {\n            colId: f.column_id,\n            source: 'auto:key_task'\n          };\n        }\n\n        if (!candidate && f.column_id && hasText) {\n          candidate = f.column_id;\n        }\n      }\n    }\n\n    return {\n      colId: candidate,\n      source: 'auto:first_text',\n      note: 'best_effort'\n    };\n  }\n\n  try {\n    var _created$item;\n\n    const {\n      listId\n    } = LISTS[which];\n    const title = String(name).trim(); // 1) Figure out which column to write the title into\n\n    const titleCol = await resolveTitleColumnId(listId, LISTS[which].titleColId);\n\n    if (!titleCol.colId) {\n      return res.status(500).json({\n        ok: false,\n        error: 'could_not_determine_title_column',\n        hint: 'Set SLACK_LIST_TASKS_TITLE_COL in .env (or Shipping/Receiving variants).',\n        docs: 'https://docs.slack.dev/reference/methods/slackLists.items.create',\n        debug: titleCol\n      });\n    } // 2) Create the item with the name written into the Task column\n\n\n    const createPayload = {\n      list_id: listId,\n      initial_fields: [{\n        column_id: titleCol.colId,\n        rich_text: toRichText(title)\n      }]\n    };\n    const created = await slack('slackLists.items.create', createPayload); // Slack returns ok=false with an error code on shape or auth problems\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(200).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || 'unknown_create_error',\n        docs: 'https://docs.slack.dev/reference/methods/slackLists.items.create',\n        sent: createPayload\n      });\n    } // 3) Respond with verbose debug so you can console.log it in the browser\n\n\n    return res.status(200).json({\n      ok: true,\n      which,\n      name: title,\n      created_item_id: (created === null || created === void 0 ? void 0 : (_created$item = created.item) === null || _created$item === void 0 ? void 0 : _created$item.id) || (created === null || created === void 0 ? void 0 : created.id),\n      list_id: listId,\n      used_column_id: titleCol.colId,\n      column_source: titleCol.source,\n      docs: {\n        create: 'https://docs.slack.dev/reference/methods/slackLists.items.create',\n        list: 'https://docs.slack.dev/reference/methods/slackLists.items.list'\n      }\n    });\n  } catch (err) {\n    return res.status(500).json({\n      ok: false,\n      error: 'exception',\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err)\n    });\n  }\n}","map":{"version":3,"sources":["C:/Users/mack2/Desktop/code/pages/api/slack/add-to-list.js"],"names":["handler","req","res","method","status","json","ok","error","which","name","debug","body","process","env","SLACK_BOT_TOKEN","LISTS","tasks","listId","SLACK_LIST_TASKS_ID","titleColId","SLACK_LIST_TASKS_TITLE_COL","shipping","SLACK_LIST_SHIPPING_ID","SLACK_LIST_SHIPPING_TITLE_COL","receiving","SLACK_LIST_RECEIVING_ID","SLACK_LIST_RECEIVING_TITLE_COL","token","slack","payload","resp","fetch","headers","JSON","stringify","toRichText","text","type","elements","resolveTitleColumnId","providedColId","colId","source","probe","list_id","limit","candidate","item","items","f","fields","key","trim","toLowerCase","hasText","Boolean","Array","isArray","rich_text","column_id","note","title","String","titleCol","hint","docs","createPayload","initial_fields","created","sent","created_item_id","id","used_column_id","column_source","create","list","err","message"],"mappings":"AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA,eAAe,eAAeA,OAAf,CAAuBC,GAAvB,EAA4BC,GAA5B,EAAiC;AAAA;;AAC9C,MAAID,GAAG,CAACE,MAAJ,KAAe,MAAnB,EAA2B;AACzB,WAAOD,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE;AAApB,KAArB,CAAP;AACD;;AAED,QAAM;AACJC,IAAAA,KAAK,GAAG,OADJ;AAC0B;AAC9BC,IAAAA,IAFI;AAE0B;AAC9BC,IAAAA,KAAK,GAAG,IAHJ,CAG0B;;AAH1B,MAIFT,GAAG,CAACU,IAAJ,IAAY,EAJhB;;AAMA,MAAI,CAACC,OAAO,CAACC,GAAR,CAAYC,eAAjB,EAAkC;AAChC,WAAOZ,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE;AAApB,KAArB,CAAP;AACD;;AACD,MAAI,CAACE,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B,EAAuC;AACrC,WAAOP,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAE;AAApB,KAArB,CAAP;AACD,GAhB6C,CAkB9C;;;AACA,QAAMQ,KAAK,GAAG;AACZC,IAAAA,KAAK,EAAE;AACLC,MAAAA,MAAM,EAAEL,OAAO,CAACC,GAAR,CAAYK,mBADf;AAEL;AACAC,MAAAA,UAAU,EAAEP,OAAO,CAACC,GAAR,CAAYO,0BAAZ,IAA0C;AAHjD,KADK;AAMZC,IAAAA,QAAQ,EAAE;AACRJ,MAAAA,MAAM,EAAEL,OAAO,CAACC,GAAR,CAAYS,sBADZ;AAERH,MAAAA,UAAU,EAAEP,OAAO,CAACC,GAAR,CAAYU,6BAAZ,IAA6C;AAFjD,KANE;AAUZC,IAAAA,SAAS,EAAE;AACTP,MAAAA,MAAM,EAAEL,OAAO,CAACC,GAAR,CAAYY,uBADX;AAETN,MAAAA,UAAU,EAAEP,OAAO,CAACC,GAAR,CAAYa,8BAAZ,IAA8C;AAFjD;AAVC,GAAd;;AAgBA,MAAI,kBAACX,KAAK,CAACP,KAAD,CAAN,yCAAC,aAAcS,MAAf,CAAJ,EAA2B;AACzB,WAAOf,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEC,MAAAA,EAAE,EAAE,KAAN;AAAaC,MAAAA,KAAK,EAAG,uBAAsBC,KAAM;AAAjD,KAArB,CAAP;AACD;;AAED,QAAMmB,KAAK,GAAGf,OAAO,CAACC,GAAR,CAAYC,eAA1B;;AAEA,iBAAec,KAAf,CAAqBzB,MAArB,EAA6B0B,OAA7B,EAAsC;AACpC,UAAMC,IAAI,GAAG,MAAMC,KAAK,CAAE,yBAAwB5B,MAAO,EAAjC,EAAoC;AAC1DA,MAAAA,MAAM,EAAE,MADkD;AAE1D6B,MAAAA,OAAO,EAAE;AACP,yBAAkB,UAASL,KAAM,EAD1B;AAEP,wBAAgB;AAFT,OAFiD;AAM1DhB,MAAAA,IAAI,EAAEsB,IAAI,CAACC,SAAL,CAAeL,OAAf;AANoD,KAApC,CAAxB;AAQA,UAAMxB,IAAI,GAAG,MAAMyB,IAAI,CAACzB,IAAL,EAAnB;AACA,WAAOA,IAAP;AACD,GApD6C,CAsD9C;;;AACA,WAAS8B,UAAT,CAAoBC,IAApB,EAA0B;AACxB,WAAO,CACL;AACEC,MAAAA,IAAI,EAAE,WADR;AAEEC,MAAAA,QAAQ,EAAE,CACR;AACED,QAAAA,IAAI,EAAE,mBADR;AAEEC,QAAAA,QAAQ,EAAE,CAAC;AAAED,UAAAA,IAAI,EAAE,MAAR;AAAgBD,UAAAA;AAAhB,SAAD;AAFZ,OADQ;AAFZ,KADK,CAAP;AAWD,GAnE6C,CAqE9C;;;AACA,iBAAeG,oBAAf,CAAoCtB,MAApC,EAA4CuB,aAA5C,EAA2D;AACzD,QAAIA,aAAJ,EAAmB,OAAO;AAAEC,MAAAA,KAAK,EAAED,aAAT;AAAwBE,MAAAA,MAAM,EAAE;AAAhC,KAAP,CADsC,CAGzD;AACA;;AACA,UAAMC,KAAK,GAAG,MAAMf,KAAK,CAAC,uBAAD,EAA0B;AAAEgB,MAAAA,OAAO,EAAE3B,MAAX;AAAmB4B,MAAAA,KAAK,EAAE;AAA1B,KAA1B,CAAzB;;AACA,QAAI,EAACF,KAAD,aAACA,KAAD,eAACA,KAAK,CAAErC,EAAR,CAAJ,EAAgB;AACd,aAAO;AAAEmC,QAAAA,KAAK,EAAE,IAAT;AAAeC,QAAAA,MAAM,EAAE,MAAvB;AAA+BnC,QAAAA,KAAK,EAAE,CAAAoC,KAAK,SAAL,IAAAA,KAAK,WAAL,YAAAA,KAAK,CAAEpC,KAAP,KAAgB;AAAtD,OAAP;AACD;;AAED,QAAIuC,SAAS,GAAG,IAAhB;;AAEA,SAAK,MAAMC,IAAX,IAAmBJ,KAAK,CAACK,KAAN,IAAe,EAAlC,EAAsC;AACpC,WAAK,MAAMC,CAAX,IAAgBF,IAAI,CAACG,MAAL,IAAe,EAA/B,EAAmC;AACjC;AACA,cAAMC,GAAG,GAAG,CAACF,CAAC,CAACE,GAAF,IAAS,EAAV,EAAcC,IAAd,GAAqBC,WAArB,EAAZ;AACA,cAAMC,OAAO,GAAGC,OAAO,CAACN,CAAC,CAACb,IAAH,CAAP,IAAmBoB,KAAK,CAACC,OAAN,CAAcR,CAAC,CAACS,SAAhB,CAAnC;;AACA,YAAIP,GAAG,KAAK,MAAR,IAAkBF,CAAC,CAACU,SAApB,IAAiCL,OAArC,EAA8C;AAC5C,iBAAO;AAAEb,YAAAA,KAAK,EAAEQ,CAAC,CAACU,SAAX;AAAsBjB,YAAAA,MAAM,EAAE;AAA9B,WAAP;AACD;;AACD,YAAI,CAACI,SAAD,IAAcG,CAAC,CAACU,SAAhB,IAA6BL,OAAjC,EAA0C;AACxCR,UAAAA,SAAS,GAAGG,CAAC,CAACU,SAAd;AACD;AACF;AACF;;AAED,WAAO;AAAElB,MAAAA,KAAK,EAAEK,SAAT;AAAoBJ,MAAAA,MAAM,EAAE,iBAA5B;AAA+CkB,MAAAA,IAAI,EAAE;AAArD,KAAP;AACD;;AAED,MAAI;AAAA;;AACF,UAAM;AAAE3C,MAAAA;AAAF,QAAaF,KAAK,CAACP,KAAD,CAAxB;AACA,UAAMqD,KAAK,GAAGC,MAAM,CAACrD,IAAD,CAAN,CAAa2C,IAAb,EAAd,CAFE,CAIF;;AACA,UAAMW,QAAQ,GAAG,MAAMxB,oBAAoB,CAACtB,MAAD,EAASF,KAAK,CAACP,KAAD,CAAL,CAAaW,UAAtB,CAA3C;;AACA,QAAI,CAAC4C,QAAQ,CAACtB,KAAd,EAAqB;AACnB,aAAOvC,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,QAAAA,EAAE,EAAE,KADsB;AAE1BC,QAAAA,KAAK,EAAE,kCAFmB;AAG1ByD,QAAAA,IAAI,EAAE,0EAHoB;AAI1BC,QAAAA,IAAI,EAAE,kEAJoB;AAK1BvD,QAAAA,KAAK,EAAEqD;AALmB,OAArB,CAAP;AAOD,KAdC,CAgBF;;;AACA,UAAMG,aAAa,GAAG;AACpBtB,MAAAA,OAAO,EAAE3B,MADW;AAEpBkD,MAAAA,cAAc,EAAE,CACd;AACER,QAAAA,SAAS,EAAEI,QAAQ,CAACtB,KADtB;AAEEiB,QAAAA,SAAS,EAAEvB,UAAU,CAAC0B,KAAD;AAFvB,OADc;AAFI,KAAtB;AAUA,UAAMO,OAAO,GAAG,MAAMxC,KAAK,CAAC,yBAAD,EAA4BsC,aAA5B,CAA3B,CA3BE,CA6BF;;AACA,QAAI,EAACE,OAAD,aAACA,OAAD,eAACA,OAAO,CAAE9D,EAAV,CAAJ,EAAkB;AAChB,aAAOJ,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,QAAAA,EAAE,EAAE,KADsB;AAE1BC,QAAAA,KAAK,EAAE,CAAA6D,OAAO,SAAP,IAAAA,OAAO,WAAP,YAAAA,OAAO,CAAE7D,KAAT,KAAkB,sBAFC;AAG1B0D,QAAAA,IAAI,EAAE,kEAHoB;AAI1BI,QAAAA,IAAI,EAAEH;AAJoB,OAArB,CAAP;AAMD,KArCC,CAuCF;;;AACA,WAAOhE,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,MAAAA,EAAE,EAAE,IADsB;AAE1BE,MAAAA,KAF0B;AAG1BC,MAAAA,IAAI,EAAEoD,KAHoB;AAI1BS,MAAAA,eAAe,EAAE,CAAAF,OAAO,SAAP,IAAAA,OAAO,WAAP,6BAAAA,OAAO,CAAErB,IAAT,gEAAewB,EAAf,MAAqBH,OAArB,aAAqBA,OAArB,uBAAqBA,OAAO,CAAEG,EAA9B,CAJS;AAK1B3B,MAAAA,OAAO,EAAE3B,MALiB;AAM1BuD,MAAAA,cAAc,EAAET,QAAQ,CAACtB,KANC;AAO1BgC,MAAAA,aAAa,EAAEV,QAAQ,CAACrB,MAPE;AAQ1BuB,MAAAA,IAAI,EAAE;AACJS,QAAAA,MAAM,EAAE,kEADJ;AAEJC,QAAAA,IAAI,EAAE;AAFF;AARoB,KAArB,CAAP;AAaD,GArDD,CAqDE,OAAOC,GAAP,EAAY;AACZ,WAAO1E,GAAG,CAACE,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAC1BC,MAAAA,EAAE,EAAE,KADsB;AAE1BC,MAAAA,KAAK,EAAE,WAFmB;AAG1BsE,MAAAA,OAAO,EAAE,CAAAD,GAAG,SAAH,IAAAA,GAAG,WAAH,YAAAA,GAAG,CAAEC,OAAL,KAAgBf,MAAM,CAACc,GAAD;AAHL,KAArB,CAAP;AAKD;AACF","sourcesContent":["// // pages/api/slack/add-to-list.js\r\n// export default async function handler(req, res) {\r\n//   if (req.method !== \"POST\") return res.status(405).json({ error: \"Method not allowed\" });\r\n\r\n//   try {\r\n//     const token = process.env.SLACK_BOT_TOKEN;\r\n//     if (!token) return res.status(500).json({ error: \"Missing SLACK_BOT_TOKEN\" });\r\n\r\n//     const {\r\n//       listKey,            // \"receiving\" | \"shipping\" | \"tasks\"\r\n//       title, linkUrl, bodyText,\r\n//       date, pn, sn, dom, trackingNumber, poNumber, workOrder, localSN, description,\r\n//       photoUrls = [],\r\n//     } = req.body;\r\n\r\n//     const LISTS = {\r\n//       receiving: {\r\n//         id: process.env.SLACK_LIST_RECEIVING_ID,\r\n//         cols: {\r\n//           desc:   process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\r\n//           date:   process.env.SLACK_LIST_RECEIVING_DATE_COL,\r\n//           pn:     process.env.SLACK_LIST_RECEIVING_PNSN_COL,\r\n//           track:  process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\r\n//           wo:     process.env.SLACK_LIST_RECEIVING_WO_COL,\r\n//           lsn:    process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\r\n//           photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL, // attachment\r\n//         },\r\n//       },\r\n//       shipping: {\r\n//         id: process.env.SLACK_LIST_SHIPPING_ID,\r\n//         cols: {\r\n//           desc:   process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\r\n//           date:   process.env.SLACK_LIST_SHIPPING_DATE_COL,\r\n//           pn:     process.env.SLACK_LIST_SHIPPING_PNSN_COL,\r\n//           track:  process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\r\n//           wo:     process.env.SLACK_LIST_SHIPPING_WO_COL,\r\n//           lsn:    process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\r\n//           photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL,  // attachment\r\n//         },\r\n//       },\r\n//       tasks: {\r\n//         id: process.env.SLACK_LIST_TASKS_ID,\r\n//         cols: {\r\n//           desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL,\r\n//         },\r\n//       },\r\n//     };\r\n\r\n//     const CHANNELS = {\r\n//       receiving: process.env.SLACK_CHANNEL_RECEIVING_ID,\r\n//       shipping:  process.env.SLACK_CHANNEL_SHIPPING_ID,\r\n//       tasks:     process.env.SLACK_CHANNEL_TASKS_ID,\r\n//     };\r\n\r\n//     const headersJson = {\r\n//       Authorization: `Bearer ${token}`,\r\n//       \"Content-Type\": \"application/json; charset=utf-8\",\r\n//     };\r\n//     const slack = (method, body, headers = headersJson) =>\r\n//       fetch(`https://slack.com/api/${method}`, { method: \"POST\", headers, body })\r\n//         .then(r => r.json());\r\n\r\n//     const plain = v => (v ?? \"\").toString().trim();\r\n//     const safe  = plain;\r\n//     const joinArr = a => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\r\n\r\n//     // ---------- PATH A: Write to a LIST ----------\r\n//     const cfg = LISTS[listKey];\r\n//     if (cfg?.id) {\r\n//       const fields = [];\r\n\r\n//       // Description column\r\n//       if (cfg.cols.desc && (description || bodyText || linkUrl)) {\r\n//         const textBits = [\r\n//           description,\r\n//           (listKey === \"tasks\" && bodyText) ? bodyText : null,\r\n//           linkUrl ? `<${linkUrl}|Open in Magmo>` : null,\r\n//         ].filter(Boolean).join(\"\\n\");\r\n//         fields.push({ column_id: cfg.cols.desc, value: { text: textBits } });\r\n//       }\r\n\r\n//       if (cfg.cols.date && date) fields.push({ column_id: cfg.cols.date, value: { date } });\r\n\r\n//       if (cfg.cols.pn && (pn || sn || dom)) {\r\n//         const pnLine = Array.isArray(pn) ? `PN: ${pn.filter(Boolean).join(\", \")}` : (pn ? `PN: ${pn}` : \"\");\r\n//         const snLine = Array.isArray(sn) ? `SN: ${sn.filter(Boolean).join(\", \")}` : (sn ? `SN: ${sn}` : \"\");\r\n//         const domLine = dom ? `DOM: ${dom}` : \"\";\r\n//         const pnBlock = [pnLine, snLine, domLine].filter(Boolean).join(\"  \");\r\n//         if (pnBlock) fields.push({ column_id: cfg.cols.pn, value: { text: pnBlock } });\r\n//       }\r\n\r\n//       if (cfg.cols.track && (trackingNumber || poNumber)) {\r\n//         const t = [\r\n//           trackingNumber ? `RL: ${trackingNumber}` : \"\",\r\n//           poNumber ? `PO: ${poNumber}` : \"\",\r\n//         ].filter(Boolean).join(\"  \");\r\n//         if (t) fields.push({ column_id: cfg.cols.track, value: { text: t } });\r\n//       }\r\n\r\n//       if (cfg.cols.wo && workOrder) fields.push({ column_id: cfg.cols.wo,  value: { text: `WO: ${workOrder}` } });\r\n//       if (cfg.cols.lsn && localSN)  fields.push({ column_id: cfg.cols.lsn, value: { text: localSN } });\r\n\r\n//       // NOW build the create body (cfg & fields exist)\r\n//       const createBody = {\r\n//         list_id: cfg.id,\r\n//         title: plain(title) || plain(localSN) || \"Untitled\",\r\n//         fields,\r\n//       };\r\n\r\n//       const created = await slack(\"slackLists.items.create\", JSON.stringify(createBody));\r\n//       if (!created?.ok) {\r\n//         console.error(\"slackLists.items.create error:\", created);\r\n//         return res.status(400).json({ error: created?.error || \"Slack Lists API error\", raw: created });\r\n//       }\r\n\r\n//       // Photos -> attachment column\r\n//       if (cfg.cols.photos && Array.isArray(photoUrls) && photoUrls.length) {\r\n//         const fileIds = [];\r\n//         for (const url of photoUrls) {\r\n//           const init = await fetch(\"https://slack.com/api/files.getUploadURLExternal\", {\r\n//             method: \"POST\",\r\n//             headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n//             body: new URLSearchParams({ filename: url.split(\"/\").pop() || \"image.jpg\" }),\r\n//           }).then(r => r.json());\r\n\r\n//           if (!init?.ok || !init?.upload_url) continue;\r\n\r\n//           try {\r\n//             const img = await fetch(url);\r\n//             const buf = await img.arrayBuffer();\r\n//             await fetch(init.upload_url, { method: \"PUT\", body: Buffer.from(buf) });\r\n//           } catch (_) {}\r\n\r\n//           const complete = await slack(\"files.completeUploadExternal\",\r\n//             JSON.stringify({ files: [{ id: init.file_id, title: \"photo\" }] })\r\n//           );\r\n//           if (complete?.ok && complete?.files?.[0]?.id) fileIds.push(complete.files[0].id);\r\n//         }\r\n\r\n//         if (fileIds.length) {\r\n//           await slack(\"slackLists.items.update\", JSON.stringify({\r\n//             list_id: cfg.id,\r\n//             item_id: created.item.id,\r\n//             fields: [{ column_id: cfg.cols.photos, value: { attachment: { file_ids: fileIds } } }],\r\n//           }));\r\n//         }\r\n//       }\r\n\r\n//       return res.status(200).json({ ok: true, mode: \"list\", list_id: cfg.id, item_id: created.item.id });\r\n//     }\r\n\r\n//     // ---------- PATH B: Fallback to a channel post ----------\r\n//     const channel = CHANNELS[listKey];\r\n//     if (!channel) return res.status(400).json({ error: \"Unknown listKey (no list or channel configured)\" });\r\n\r\n//     // Try to join public channels to avoid channel_not_found\r\n//     await fetch(\"https://slack.com/api/conversations.join\", {\r\n//       method: \"POST\",\r\n//       headers: { Authorization: `Bearer ${token}`, \"Content-Type\": \"application/x-www-form-urlencoded\" },\r\n//       body: new URLSearchParams({ channel }),\r\n//     });\r\n\r\n//     const safeId = plain(linkUrl?.split(\"/\").pop()) || plain(localSN) || \"\";\r\n//     const safeTitle = plain(title) || plain(req.body?.title) || (safeId ? `Item ${safeId}` : \"New Item\");\r\n\r\n//     const lines = [];\r\n//     lines.push(`*${safeTitle}*`);\r\n\r\n//     const pnStr = joinArr(pn);\r\n//     const snStr = joinArr(sn);\r\n//     if (pnStr) lines.push(`PN: ${pnStr}`);\r\n//     if (snStr) lines.push(`SN: ${snStr}`);\r\n//     if (safe(workOrder)) lines.push(`WO: ${safe(workOrder)}`);\r\n//     if (safe(poNumber)) lines.push(`PO: ${safe(poNumber)}`);\r\n//     if (safe(trackingNumber)) lines.push(`RL: ${safe(trackingNumber)}`);\r\n//     if (safe(dom)) lines.push(`DOM: ${safe(dom)}`);\r\n//     if (safe(localSN)) lines.push(`Local SN: ${safe(localSN)}`);\r\n//     if (safe(date)) lines.push(`Date: ${safe(date)}`);\r\n\r\n//     const desc = safe(description);\r\n//     if (desc) lines.push(desc);\r\n//     else if (listKey === \"tasks\" && safe(bodyText)) lines.push(safe(bodyText));\r\n\r\n//     if (safe(linkUrl)) lines.push(`<${safe(linkUrl)}|Open in Magmo>`);\r\n\r\n//     const text = lines.filter(Boolean).join(\"\\n\") || \"(no details provided)\";\r\n\r\n//     const posted = await slack(\"chat.postMessage\", JSON.stringify({ channel, text }));\r\n//     if (!posted?.ok) {\r\n//       console.error(\"chat.postMessage error:\", posted);\r\n//       return res.status(400).json({ error: posted?.error || \"Slack API error\", raw: posted });\r\n//     }\r\n\r\n//     return res.status(200).json({ ok: true, mode: \"channel\", channel, ts: posted.ts });\r\n//   } catch (e) {\r\n//     console.error(\"API /slack/add-to-list crashed:\", e);\r\n//     return res.status(500).json({ error: \"Server error\" });\r\n//   }\r\n// }\r\n\r\n\r\n// pages/api/slack/add-to-list.js\r\n// Requires Slack scopes: lists:write (and lists:read if you want auto-detection)\r\n\r\nexport default async function handler(req, res) {\r\n  if (req.method !== 'POST') {\r\n    return res.status(405).json({ ok: false, error: 'method_not_allowed' });\r\n  }\r\n\r\n  const {\r\n    which = 'tasks',              // 'tasks' | 'shipping' | 'receiving'\r\n    name,                         // string to show in the Task column\r\n    debug = true                  // include verbose debug in API response\r\n  } = req.body || {};\r\n\r\n  if (!process.env.SLACK_BOT_TOKEN) {\r\n    return res.status(500).json({ ok: false, error: 'missing_SLACK_BOT_TOKEN' });\r\n  }\r\n  if (!name || typeof name !== 'string') {\r\n    return res.status(400).json({ ok: false, error: 'missing_or_invalid_name' });\r\n  }\r\n\r\n  // ---- Lists you use (IDs come from your .env) ----\r\n  const LISTS = {\r\n    tasks: {\r\n      listId: process.env.SLACK_LIST_TASKS_ID,\r\n      // Optional: set this if you already know the ID of the \"Task\" text column\r\n      titleColId: process.env.SLACK_LIST_TASKS_TITLE_COL || null\r\n    },\r\n    shipping: {\r\n      listId: process.env.SLACK_LIST_SHIPPING_ID,\r\n      titleColId: process.env.SLACK_LIST_SHIPPING_TITLE_COL || null\r\n    },\r\n    receiving: {\r\n      listId: process.env.SLACK_LIST_RECEIVING_ID,\r\n      titleColId: process.env.SLACK_LIST_RECEIVING_TITLE_COL || null\r\n    }\r\n  };\r\n\r\n  if (!LISTS[which]?.listId) {\r\n    return res.status(400).json({ ok: false, error: `missing_list_id_for_${which}` });\r\n  }\r\n\r\n  const token = process.env.SLACK_BOT_TOKEN;\r\n\r\n  async function slack(method, payload) {\r\n    const resp = await fetch(`https://slack.com/api/${method}`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Authorization': `Bearer ${token}`,\r\n        'Content-Type': 'application/json; charset=utf-8'\r\n      },\r\n      body: JSON.stringify(payload)\r\n    });\r\n    const json = await resp.json();\r\n    return json;\r\n  }\r\n\r\n  // Convert plain text to Slack rich_text for a text column\r\n  function toRichText(text) {\r\n    return [\r\n      {\r\n        type: 'rich_text',\r\n        elements: [\r\n          {\r\n            type: 'rich_text_section',\r\n            elements: [{ type: 'text', text }]\r\n          }\r\n        ]\r\n      }\r\n    ];\r\n  }\r\n\r\n  // Try to discover the text column that represents the \"Task\" header\r\n  async function resolveTitleColumnId(listId, providedColId) {\r\n    if (providedColId) return { colId: providedColId, source: 'env' };\r\n\r\n    // Heuristic: read a few items and look for a field whose key looks like \"Task\",\r\n    // otherwise fall back to the first field with 'text' or 'rich_text'.\r\n    const probe = await slack('slackLists.items.list', { list_id: listId, limit: 50 });\r\n    if (!probe?.ok) {\r\n      return { colId: null, source: 'auto', error: probe?.error || 'items.list_failed' };\r\n    }\r\n\r\n    let candidate = null;\r\n\r\n    for (const item of probe.items || []) {\r\n      for (const f of item.fields || []) {\r\n        // Prefer a column literally called \"Task\"\r\n        const key = (f.key || '').trim().toLowerCase();\r\n        const hasText = Boolean(f.text) || Array.isArray(f.rich_text);\r\n        if (key === 'task' && f.column_id && hasText) {\r\n          return { colId: f.column_id, source: 'auto:key_task' };\r\n        }\r\n        if (!candidate && f.column_id && hasText) {\r\n          candidate = f.column_id;\r\n        }\r\n      }\r\n    }\r\n\r\n    return { colId: candidate, source: 'auto:first_text', note: 'best_effort' };\r\n  }\r\n\r\n  try {\r\n    const { listId } = LISTS[which];\r\n    const title = String(name).trim();\r\n\r\n    // 1) Figure out which column to write the title into\r\n    const titleCol = await resolveTitleColumnId(listId, LISTS[which].titleColId);\r\n    if (!titleCol.colId) {\r\n      return res.status(500).json({\r\n        ok: false,\r\n        error: 'could_not_determine_title_column',\r\n        hint: 'Set SLACK_LIST_TASKS_TITLE_COL in .env (or Shipping/Receiving variants).',\r\n        docs: 'https://docs.slack.dev/reference/methods/slackLists.items.create',\r\n        debug: titleCol\r\n      });\r\n    }\r\n\r\n    // 2) Create the item with the name written into the Task column\r\n    const createPayload = {\r\n      list_id: listId,\r\n      initial_fields: [\r\n        {\r\n          column_id: titleCol.colId,\r\n          rich_text: toRichText(title)\r\n        }\r\n      ]\r\n    };\r\n\r\n    const created = await slack('slackLists.items.create', createPayload);\r\n\r\n    // Slack returns ok=false with an error code on shape or auth problems\r\n    if (!created?.ok) {\r\n      return res.status(200).json({\r\n        ok: false,\r\n        error: created?.error || 'unknown_create_error',\r\n        docs: 'https://docs.slack.dev/reference/methods/slackLists.items.create',\r\n        sent: createPayload\r\n      });\r\n    }\r\n\r\n    // 3) Respond with verbose debug so you can console.log it in the browser\r\n    return res.status(200).json({\r\n      ok: true,\r\n      which,\r\n      name: title,\r\n      created_item_id: created?.item?.id || created?.id,\r\n      list_id: listId,\r\n      used_column_id: titleCol.colId,\r\n      column_source: titleCol.source,\r\n      docs: {\r\n        create: 'https://docs.slack.dev/reference/methods/slackLists.items.create',\r\n        list: 'https://docs.slack.dev/reference/methods/slackLists.items.list'\r\n      }\r\n    });\r\n  } catch (err) {\r\n    return res.status(500).json({\r\n      ok: false,\r\n      error: 'exception',\r\n      message: err?.message || String(err)\r\n    });\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}