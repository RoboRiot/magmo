{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// // pages/api/slack/add-to-list.js\n// export default async function handler(req, res) {\n//   try {\n//     if (req.method !== \"POST\") {\n//       return res.status(405).json({ ok: false, error: \"method_not_allowed\" });\n//     }\n//     const token = process.env.SLACK_BOT_TOKEN;\n//     if (!token) {\n//       return res.status(500).json({ ok: false, error: \"missing_SLACK_BOT_TOKEN\" });\n//     }\n//     // payload from client\n//     const {\n//       listKey,             // \"tasks\" | \"shipping\" | \"receiving\"\n//       title,               // item title (what shows in the primary column)\n//       // keeping minimal per your request: PN/SN only for now\n//       pn, sn,\n//     } = req.body || {};\n//     // list ids from env\n//     const LIST_IDS = {\n//       tasks: process.env.SLACK_LIST_TASKS_ID,\n//       shipping: process.env.SLACK_LIST_SHIPPING_ID,\n//       receiving: process.env.SLACK_LIST_RECEIVING_ID,\n//     };\n//     const list_id = LIST_IDS[listKey];\n//     if (!list_id) {\n//       return res.status(400).json({ ok: false, error: `unknown_listKey_${listKey}` });\n//     }\n//     // ---- Slack helpers ----\n//     async function slackJson(method, payload) {\n//       const r = await fetch(`https://slack.com/api/${method}`, {\n//         method: \"POST\",\n//         headers: {\n//           Authorization: `Bearer ${token}`,\n//           \"Content-Type\": \"application/json; charset=utf-8\",\n//         },\n//         body: JSON.stringify(payload),\n//       });\n//       return r.json();\n//     }\n//     const plain = (v) => (v ?? \"\").toString().trim();\n//     const joinArr = (a) => Array.isArray(a) ? a.filter(Boolean).map(plain).join(\", \") : plain(a);\n//     function toRichText(text) {\n//       const t = plain(text);\n//       return [{\n//         type: \"rich_text\",\n//         elements: [{\n//           type: \"rich_text_section\",\n//           elements: [{ type: \"text\", text: t }],\n//         }],\n//       }];\n//     }\n//     // Try to resolve primary/text column id (\"Item\"/\"Task\") by scanning existing rows\n//     async function resolveTitleColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 50 });\n//       if (!probe?.ok) return null;\n//       // Heuristics: prefer a text field whose key looks like 'item' or 'task'\n//       let fallback = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           const key = (f.key || \"\").toLowerCase();\n//           const hasText = !!f.text || Array.isArray(f.rich_text);\n//           if (f.column_id && hasText) {\n//             if (key.includes(\"item\") || key.includes(\"task\")) return f.column_id;\n//             if (!fallback) fallback = f.column_id;\n//           }\n//         }\n//       }\n//       return fallback; // first text-like field if we didn't find a perfect match\n//     }\n//     // Find the PN/SN column id by scanning for a field with key or text like \"PN\" / \"SN\"\n//     async function resolvePnSnColId(listId) {\n//       const probe = await slackJson(\"slackLists.items.list\", { list_id: listId, limit: 100 });\n//       if (!probe?.ok) return null;\n//       let candidate = null;\n//       for (const it of probe.items || []) {\n//         for (const f of it.fields || []) {\n//           if (!f.column_id) continue;\n//           const key = (f.key || \"\").toLowerCase();\n//           const text = (f.text || \"\").toLowerCase();\n//           const looksPnSn =\n//             key.includes(\"pn\") || key.includes(\"sn\") ||\n//             text.includes(\"pn:\") || text.includes(\"sn:\");\n//           if (looksPnSn) return f.column_id;\n//           if (!candidate && (key.includes(\"part\") || key.includes(\"serial\"))) {\n//             candidate = f.column_id;\n//           }\n//         }\n//       }\n//       return candidate;\n//     }\n//     // 1) Resolve columns\n//     const titleColId = await resolveTitleColId(list_id);\n//     if (!titleColId) {\n//       return res.status(400).json({ ok: false, error: \"could_not_resolve_title_column\" });\n//     }\n//     // 2) Create the item with the title in the title column (must use initial_fields with a real column_id)\n//     const safeTitle = plain(title) || \"New Item\";\n//     const createBody = {\n//       list_id,\n//       initial_fields: [{ column_id: titleColId, rich_text: toRichText(safeTitle) }],\n//     };\n//     const created = await slackJson(\"slackLists.items.create\", createBody);\n//     if (!created?.ok) {\n//       return res.status(200).json({\n//         ok: false,\n//         error: created?.error || \"create_failed\",\n//         mode: \"list\",\n//         sent: createBody,\n//       });\n//     }\n//     // 3) (Minimal) update: PN/SN only, per your request\n//     const pn0 = Array.isArray(pn) ? pn[0] : pn;\n//     const sn0 = Array.isArray(sn) ? sn[0] : sn;\n//     const pnPart = plain(pn0) ? `PN: ${plain(pn0)}` : \"\";\n//     const snPart = plain(sn0) ? `SN: ${plain(sn0)}` : \"\";\n//     const pnSnText = [pnPart, snPart].filter(Boolean).join(\"  \");\n//     let updated = null;\n//     let usedPnSnCol = null;\n//     if (pnSnText) {\n//       const pnSnColId = await resolvePnSnColId(list_id);\n//       if (pnSnColId) {\n//         const cells = [{\n//           row_id: created.item.id,\n//           column_id: pnSnColId,\n//           rich_text: toRichText(pnSnText),\n//         }];\n//         updated = await slackJson(\"slackLists.items.update\", { list_id, cells });\n//         usedPnSnCol = pnSnColId;\n//         // If update fails, we still return ok:false so you can see the error\n//         if (!updated?.ok) {\n//           return res.status(200).json({\n//             ok: false,\n//             error: updated?.error || \"update_failed\",\n//             mode: \"list\",\n//             list_id,\n//             item_id: created.item.id,\n//             used_title_col: titleColId,\n//             used_pnsn_col: usedPnSnCol,\n//           });\n//         }\n//       }\n//     }\n//     return res.status(200).json({\n//       ok: true,\n//       mode: \"list\",\n//       list_id,\n//       item_id: created.item.id,\n//       used_title_col: titleColId,\n//       used_pnsn_col: usedPnSnCol || null,\n//       sent_title: safeTitle,\n//     });\n//   } catch (err) {\n//     console.error(\"API /slack/add-to-list crashed:\", err);\n//     return res.status(500).json({ ok: false, error: \"exception\", message: err?.message || String(err) });\n//   }\n// }\n// pages/api/slack/add-to-list.js\nexport default async function handler(req, res) {\n  const t0 = Date.now();\n  const steps = [];\n\n  const logStep = (step, extra = {}) => steps.push(_objectSpread({\n    t: new Date().toISOString(),\n    step\n  }, extra));\n\n  try {\n    var _created$item;\n\n    if (req.method !== \"POST\") {\n      return res.status(405).json({\n        ok: false,\n        error: \"method_not_allowed\"\n      });\n    }\n\n    const token = process.env.SLACK_BOT_TOKEN;\n\n    if (!token) {\n      return res.status(500).json({\n        ok: false,\n        error: \"missing_SLACK_BOT_TOKEN\"\n      });\n    } // ---------- payload from client ----------\n\n\n    const {\n      listKey,\n      // \"tasks\" | \"shipping\" | \"receiving\"\n      title,\n      // item title\n      pn_sn,\n      // preferred input: \"PN: 123  SN: 456\"\n      work_order,\n      // preferred input\n      tracking,\n      local_sn,\n      // preferred input\n      description,\n      photoUrls,\n      // preferred input: array\n      // legacy keys we still accept for safety:\n      pn,\n      sn,\n      workOrder,\n      localSN,\n      trackingNumber,\n      photo_urls,\n      photos\n    } = req.body || {}; // Normalize inputs so both old & new callers work\n\n    const plain = v => (v !== null && v !== void 0 ? v : \"\").toString().trim();\n\n    const pn_sn_norm = (() => {\n      if (plain(pn_sn)) return plain(pn_sn);\n      const pn0 = plain(pn);\n      const sn0 = plain(sn);\n      const parts = [];\n      if (pn0) parts.push(`PN: ${pn0}`);\n      if (sn0) parts.push(`SN: ${sn0}`);\n      return parts.join(\"  \");\n    })();\n\n    const work_order_norm = plain(work_order || workOrder || \"\");\n    const local_sn_norm = plain(local_sn || localSN || \"\");\n    const tracking_norm = plain(tracking || trackingNumber || \"\");\n    const description_norm = plain(description || \"\");\n    let photoUrls_norm = Array.isArray(photoUrls) ? photoUrls : Array.isArray(photo_urls) ? photo_urls : Array.isArray(photos) ? photos : []; // ---------- env: list + column ids ----------\n\n    const LIST_IDS = {\n      tasks: process.env.SLACK_LIST_TASKS_ID,\n      shipping: process.env.SLACK_LIST_SHIPPING_ID,\n      receiving: process.env.SLACK_LIST_RECEIVING_ID\n    };\n    const COLS = {\n      tasks: {\n        title: process.env.SLACK_LIST_TASKS_TITLE_COL,\n        desc: process.env.SLACK_LIST_TASKS_DESCRIPTION_COL\n      },\n      shipping: {\n        title: process.env.SLACK_LIST_SHIPPING_TITLE_COL,\n        desc: process.env.SLACK_LIST_SHIPPING_DESCRIPTION_COL,\n        pnsn: process.env.SLACK_LIST_SHIPPING_PNSN_COL,\n        wo: process.env.SLACK_LIST_SHIPPING_WO_COL,\n        localsn: process.env.SLACK_LIST_SHIPPING_LOCALSN_COL,\n        tracking: process.env.SLACK_LIST_SHIPPING_TRACKING_COL,\n        photos: process.env.SLACK_LIST_SHIPPING_PHOTOS_COL\n      },\n      receiving: {\n        title: process.env.SLACK_LIST_RECEIVING_TITLE_COL,\n        desc: process.env.SLACK_LIST_RECEIVING_DESCRIPTION_COL,\n        pnsn: process.env.SLACK_LIST_RECEIVING_PNSN_COL,\n        wo: process.env.SLACK_LIST_RECEIVING_WO_COL,\n        localsn: process.env.SLACK_LIST_RECEIVING_LOCALSN_COL,\n        tracking: process.env.SLACK_LIST_RECEIVING_TRACKING_COL,\n        photos: process.env.SLACK_LIST_RECEIVING_PHOTOS_COL\n      }\n    };\n    const list_id = LIST_IDS[listKey];\n    const CFG = COLS[listKey] || {};\n\n    if (!list_id) {\n      return res.status(400).json({\n        ok: false,\n        error: `unknown_listKey_${listKey}`\n      });\n    }\n\n    if (!CFG.title) {\n      return res.status(400).json({\n        ok: false,\n        error: \"missing_title_column_env\"\n      });\n    } // ---------- helpers ----------\n\n\n    async function slackJson(method, payload) {\n      const r = await fetch(`https://slack.com/api/${method}`, {\n        method: \"POST\",\n        headers: {\n          Authorization: `Bearer ${token}`,\n          \"Content-Type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify(payload)\n      });\n      const json = await r.json();\n      return json;\n    }\n\n    function richText(text) {\n      const t = plain(text);\n      return [{\n        type: \"rich_text\",\n        elements: [{\n          type: \"rich_text_section\",\n          elements: [{\n            type: \"text\",\n            text: t || \"\"\n          }]\n        }]\n      }];\n    }\n\n    const safeFilenameFromUrl = (url, i) => {\n      try {\n        // last path piece (may be the encoded \"Parts%2F...jpg\")\n        const last = (url.split(\"/\").pop() || \"\").split(\"?\")[0]; // decode, THEN take last segment again (in case it contains '/')\n\n        const decoded = decodeURIComponent(last);\n        const basename = decoded.split(\"/\").pop() || decoded; // replace anything unsafe (slashes, spaces, etc.)\n\n        const safe = basename.replace(/[^\\w.\\-]+/g, \"_\");\n        return safe || `photo_${i + 1}.jpg`;\n      } catch {\n        return `photo_${i + 1}.jpg`;\n      }\n    }; // ---------- 1) create the row with title ----------\n\n\n    const titleText = plain(title) || \"Untitled item\";\n    const createPayload = {\n      list_id,\n      initial_fields: [{\n        column_id: CFG.title,\n        rich_text: richText(titleText)\n      }]\n    };\n    const created = await slackJson(\"slackLists.items.create\", createPayload);\n    logStep(\"[LISTS][CREATE-RICH]\", {\n      ok: (created === null || created === void 0 ? void 0 : created.ok) === true,\n      status: 200,\n      error: created === null || created === void 0 ? void 0 : created.error\n    });\n\n    if (!(created !== null && created !== void 0 && created.ok)) {\n      return res.status(200).json({\n        ok: false,\n        error: (created === null || created === void 0 ? void 0 : created.error) || \"create_failed\",\n        debug: {\n          steps\n        }\n      });\n    }\n\n    const rowId = (_created$item = created.item) === null || _created$item === void 0 ? void 0 : _created$item.id;\n    logStep(\"[LISTS][CREATED]\", {\n      rowId\n    }); // ---------- 2) update rich_text fields ----------\n\n    const cells = [];\n    if (CFG.pnsn && pn_sn_norm) cells.push({\n      row_id: rowId,\n      column_id: CFG.pnsn,\n      rich_text: richText(pn_sn_norm)\n    });\n    if (CFG.localsn && local_sn_norm) cells.push({\n      row_id: rowId,\n      column_id: CFG.localsn,\n      rich_text: richText(local_sn_norm)\n    });\n    if (CFG.wo && work_order_norm) cells.push({\n      row_id: rowId,\n      column_id: CFG.wo,\n      rich_text: richText(work_order_norm)\n    });\n    if (CFG.tracking && tracking_norm) cells.push({\n      row_id: rowId,\n      column_id: CFG.tracking,\n      rich_text: richText(tracking_norm)\n    });\n    if (CFG.desc && description_norm) cells.push({\n      row_id: rowId,\n      column_id: CFG.desc,\n      rich_text: richText(description_norm)\n    });\n\n    if (cells.length) {\n      const updated = await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells\n      });\n      if (CFG.pnsn && pn_sn_norm) logStep(\"[LISTS][SET-RICH][PN/SN]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.localsn && local_sn_norm) logStep(\"[LISTS][SET-RICH][LOCAL_SN]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.desc && description_norm) logStep(\"[LISTS][SET-RICH][DESCRIPTION]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.wo && work_order_norm) logStep(\"[LISTS][SET-RICH][WO]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n      if (CFG.tracking && tracking_norm) logStep(\"[LISTS][SET-RICH][TRACKING]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n\n      if (!(updated !== null && updated !== void 0 && updated.ok)) {\n        return res.status(200).json({\n          ok: false,\n          error: (updated === null || updated === void 0 ? void 0 : updated.error) || \"update_failed\",\n          debug: {\n            steps\n          }\n        });\n      }\n    } // ---------- 3) upload photos ----------\n\n\n    async function uploadViaExternal(fileUrl, filename) {\n      // 3a. fetch bytes\n      const resp = await fetch(fileUrl);\n      const buf = await resp.arrayBuffer();\n      const byteLen = buf.byteLength;\n      logStep(\"[FILES.BYTES]\", {\n        byteLen,\n        filename\n      }); // 3b. get upload url (filename MUST be a single segment; no '/')\n\n      const up = await slackJson(\"files.getUploadURLExternal\", {\n        filename,\n        length: byteLen\n      });\n      logStep(\"[FILES.GETUPLOAD]\", {\n        ok: (up === null || up === void 0 ? void 0 : up.ok) === true,\n        status: 200,\n        byteLen,\n        filename,\n        error: up === null || up === void 0 ? void 0 : up.error\n      });\n      if (!(up !== null && up !== void 0 && up.ok) || !(up !== null && up !== void 0 && up.upload_url) || !(up !== null && up !== void 0 && up.file_id)) return {\n        ok: false,\n        error: (up === null || up === void 0 ? void 0 : up.error) || \"get_upload_url_failed\"\n      }; // 3c. post bytes to the upload_url\n\n      const post = await fetch(up.upload_url, {\n        method: \"POST\",\n        body: Buffer.from(buf)\n      });\n      logStep(\"[FILES.UPLOAD.POST]\", {\n        ok: (post === null || post === void 0 ? void 0 : post.ok) === true,\n        status: post === null || post === void 0 ? void 0 : post.status\n      });\n      if (!post.ok) return {\n        ok: false,\n        error: \"upload_post_failed\"\n      }; // 3d. complete\n\n      const complete = await slackJson(\"files.completeUploadExternal\", {\n        files: [{\n          id: up.file_id,\n          title: filename\n        }]\n      });\n      logStep(\"[FILES.COMPLETE]\", {\n        ok: (complete === null || complete === void 0 ? void 0 : complete.ok) === true,\n        status: 200,\n        error: complete === null || complete === void 0 ? void 0 : complete.error\n      });\n      if (!(complete !== null && complete !== void 0 && complete.ok)) return {\n        ok: false,\n        error: (complete === null || complete === void 0 ? void 0 : complete.error) || \"complete_failed\"\n      };\n      return {\n        ok: true,\n        file: {\n          id: up.file_id\n        }\n      };\n    }\n\n    async function attachFilesToCell(listId, row, col, fileIds) {\n      var _r, _r2, _r3, _r4, _r5, _r6, _r7, _r8, _r9, _r10, _r11;\n\n      // Try a few shapes. Different list column types accept different shapes.\n      // A) \"attachment\": [ \"F...\" ]\n      let r = await slackJson(\"slackLists.items.update\", {\n        list_id: listId,\n        cells: [{\n          row_id: row,\n          column_id: col,\n          attachment: fileIds\n        }]\n      });\n      logStep(\"[LISTS][ATTACH-A][PHOTOS]\", {\n        ok: ((_r = r) === null || _r === void 0 ? void 0 : _r.ok) === true,\n        status: 200,\n        error: (_r2 = r) === null || _r2 === void 0 ? void 0 : _r2.error\n      });\n      if ((_r3 = r) !== null && _r3 !== void 0 && _r3.ok) return r; // B) \"files\": [{ id: 'F...' }]\n\n      r = await slackJson(\"slackLists.items.update\", {\n        list_id: listId,\n        cells: [{\n          row_id: row,\n          column_id: col,\n          files: fileIds.map(id => ({\n            id\n          }))\n        }]\n      });\n      logStep(\"[LISTS][ATTACH-B][PHOTOS]\", {\n        ok: ((_r4 = r) === null || _r4 === void 0 ? void 0 : _r4.ok) === true,\n        status: 200,\n        error: (_r5 = r) === null || _r5 === void 0 ? void 0 : _r5.error\n      });\n      if ((_r6 = r) !== null && _r6 !== void 0 && _r6.ok) return r; // C) \"files\": [{ file_id: 'F...' }]\n\n      r = await slackJson(\"slackLists.items.update\", {\n        list_id: listId,\n        cells: [{\n          row_id: row,\n          column_id: col,\n          files: fileIds.map(id => ({\n            file_id: id\n          }))\n        }]\n      });\n      logStep(\"[LISTS][ATTACH-C][PHOTOS]\", {\n        ok: ((_r7 = r) === null || _r7 === void 0 ? void 0 : _r7.ok) === true,\n        status: 200,\n        error: (_r8 = r) === null || _r8 === void 0 ? void 0 : _r8.error\n      });\n      if ((_r9 = r) !== null && _r9 !== void 0 && _r9.ok) return r; // D) \"reference\": [{ file: { file_id: 'F...' } }]\n\n      r = await slackJson(\"slackLists.items.update\", {\n        list_id: listId,\n        cells: [{\n          row_id: row,\n          column_id: col,\n          reference: fileIds.map(id => ({\n            file: {\n              file_id: id\n            }\n          }))\n        }]\n      });\n      logStep(\"[LISTS][ATTACH-D][PHOTOS]\", {\n        ok: ((_r10 = r) === null || _r10 === void 0 ? void 0 : _r10.ok) === true,\n        status: 200,\n        error: (_r11 = r) === null || _r11 === void 0 ? void 0 : _r11.error\n      });\n      return r;\n    }\n\n    let attachedOk = false;\n    let uploadedFileIds = [];\n\n    if (CFG.photos && Array.isArray(photoUrls_norm) && photoUrls_norm.length) {\n      for (let i = 0; i < Math.min(photoUrls_norm.length, 10); i++) {\n        var _up$file, _up$file2;\n\n        const url = plain(photoUrls_norm[i]);\n        if (!/^https?:\\/\\//i.test(url)) continue;\n        const filename = safeFilenameFromUrl(url, i);\n        const up = await uploadViaExternal(url, filename);\n        logStep(\"[PHOTOS][UPLOADED]\", {\n          ok: (up === null || up === void 0 ? void 0 : up.ok) === true,\n          file_id: up === null || up === void 0 ? void 0 : (_up$file = up.file) === null || _up$file === void 0 ? void 0 : _up$file.id,\n          filename\n        });\n        if (up !== null && up !== void 0 && up.ok && (_up$file2 = up.file) !== null && _up$file2 !== void 0 && _up$file2.id) uploadedFileIds.push(up.file.id);\n      }\n\n      if (uploadedFileIds.length) {\n        const att = await attachFilesToCell(list_id, rowId, CFG.photos, uploadedFileIds);\n        attachedOk = !!(att !== null && att !== void 0 && att.ok);\n\n        if (!attachedOk) {\n          logStep(\"[PHOTOS][FAILED-ATTACH]\", {\n            error: att === null || att === void 0 ? void 0 : att.error,\n            ids: uploadedFileIds\n          });\n        }\n      } else {\n        logStep(\"[PHOTOS][NO-IDS]\", {\n          reason: \"upload_failed_or_empty\"\n        });\n      }\n    } // Fallback: drop photo URLs into Description so nothing is lost\n\n\n    if (!attachedOk && CFG.desc && photoUrls_norm !== null && photoUrls_norm !== void 0 && photoUrls_norm.length) {\n      const updated = await slackJson(\"slackLists.items.update\", {\n        list_id,\n        cells: [{\n          row_id: rowId,\n          column_id: CFG.desc,\n          rich_text: richText(`${description_norm}\\n\\nPhotos:\\n${photoUrls_norm.join(\"\\n\")}`)\n        }]\n      });\n      logStep(\"[LISTS][SET-RICH][PHOTOS->DESC-FALLBACK]\", {\n        ok: (updated === null || updated === void 0 ? void 0 : updated.ok) === true,\n        status: 200,\n        error: updated === null || updated === void 0 ? void 0 : updated.error\n      });\n    }\n\n    return res.status(200).json({\n      ok: true,\n      list_id,\n      item_id: rowId,\n      used_cols: {\n        title_col: CFG.title || null,\n        pnsn_col: CFG.pnsn || null,\n        description_col: CFG.desc || null,\n        workorder_col: CFG.wo || null,\n        localsn_col: CFG.localsn || null,\n        tracking_col: CFG.tracking || null,\n        photos_col: CFG.photos || null\n      },\n      debug: {\n        steps,\n        photos: uploadedFileIds\n      },\n      ms: Date.now() - t0\n    });\n  } catch (err) {\n    logStep(\"[EXCEPTION]\", {\n      message: err === null || err === void 0 ? void 0 : err.message\n    });\n    console.error(\"API /slack/add-to-list crashed:\", err);\n    return res.status(500).json({\n      ok: false,\n      error: \"exception\",\n      message: (err === null || err === void 0 ? void 0 : err.message) || String(err),\n      debug: {\n        steps\n      }\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"module"}