(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[1],{

/***/ "./node_modules/@zxing/library/esm5/browser.js":
/*!*****************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/browser.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
// browser
__export(__webpack_require__(/*! ./browser/BrowserAztecCodeReader */ "./node_modules/@zxing/library/esm5/browser/BrowserAztecCodeReader.js"));
__export(__webpack_require__(/*! ./browser/BrowserBarcodeReader */ "./node_modules/@zxing/library/esm5/browser/BrowserBarcodeReader.js"));
__export(__webpack_require__(/*! ./browser/BrowserCodeReader */ "./node_modules/@zxing/library/esm5/browser/BrowserCodeReader.js"));
__export(__webpack_require__(/*! ./browser/BrowserDatamatrixCodeReader */ "./node_modules/@zxing/library/esm5/browser/BrowserDatamatrixCodeReader.js"));
__export(__webpack_require__(/*! ./browser/BrowserMultiFormatReader */ "./node_modules/@zxing/library/esm5/browser/BrowserMultiFormatReader.js"));
__export(__webpack_require__(/*! ./browser/BrowserPDF417Reader */ "./node_modules/@zxing/library/esm5/browser/BrowserPDF417Reader.js"));
__export(__webpack_require__(/*! ./browser/BrowserQRCodeReader */ "./node_modules/@zxing/library/esm5/browser/BrowserQRCodeReader.js"));
__export(__webpack_require__(/*! ./browser/BrowserQRCodeSvgWriter */ "./node_modules/@zxing/library/esm5/browser/BrowserQRCodeSvgWriter.js"));
__export(__webpack_require__(/*! ./browser/HTMLCanvasElementLuminanceSource */ "./node_modules/@zxing/library/esm5/browser/HTMLCanvasElementLuminanceSource.js"));
__export(__webpack_require__(/*! ./browser/VideoInputDevice */ "./node_modules/@zxing/library/esm5/browser/VideoInputDevice.js"));
//# sourceMappingURL=browser.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/browser/BrowserAztecCodeReader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/browser/BrowserAztecCodeReader.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ "./node_modules/@zxing/library/esm5/browser/BrowserCodeReader.js");
var AztecReader_1 = __webpack_require__(/*! ../core/aztec/AztecReader */ "./node_modules/@zxing/library/esm5/core/aztec/AztecReader.js");
/**
 * Aztec Code reader to use from browser.
 *
 * @class BrowserAztecCodeReader
 * @extends {BrowserCodeReader}
 */
var BrowserAztecCodeReader = /** @class */ (function (_super) {
    __extends(BrowserAztecCodeReader, _super);
    /**
     * Creates an instance of BrowserAztecCodeReader.
     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
     *
     * @memberOf BrowserAztecCodeReader
     */
    function BrowserAztecCodeReader(timeBetweenScansMillis) {
        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
        return _super.call(this, new AztecReader_1.default(), timeBetweenScansMillis) || this;
    }
    return BrowserAztecCodeReader;
}(BrowserCodeReader_1.BrowserCodeReader));
exports.BrowserAztecCodeReader = BrowserAztecCodeReader;
//# sourceMappingURL=BrowserAztecCodeReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/browser/BrowserBarcodeReader.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/browser/BrowserBarcodeReader.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ "./node_modules/@zxing/library/esm5/browser/BrowserCodeReader.js");
var MultiFormatOneDReader_1 = __webpack_require__(/*! ../core/oned/MultiFormatOneDReader */ "./node_modules/@zxing/library/esm5/core/oned/MultiFormatOneDReader.js");
/**
 * @deprecated Moving to @zxing/browser
 *
 * Barcode reader reader to use from browser.
 */
var BrowserBarcodeReader = /** @class */ (function (_super) {
    __extends(BrowserBarcodeReader, _super);
    /**
     * Creates an instance of BrowserBarcodeReader.
     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
     * @param {Map<DecodeHintType, any>} hints
     */
    function BrowserBarcodeReader(timeBetweenScansMillis, hints) {
        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
        return _super.call(this, new MultiFormatOneDReader_1.default(hints), timeBetweenScansMillis, hints) || this;
    }
    return BrowserBarcodeReader;
}(BrowserCodeReader_1.BrowserCodeReader));
exports.BrowserBarcodeReader = BrowserBarcodeReader;
//# sourceMappingURL=BrowserBarcodeReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/browser/BrowserCodeReader.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/browser/BrowserCodeReader.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentException_1 = __webpack_require__(/*! ../core/ArgumentException */ "./node_modules/@zxing/library/esm5/core/ArgumentException.js");
var BinaryBitmap_1 = __webpack_require__(/*! ../core/BinaryBitmap */ "./node_modules/@zxing/library/esm5/core/BinaryBitmap.js");
var ChecksumException_1 = __webpack_require__(/*! ../core/ChecksumException */ "./node_modules/@zxing/library/esm5/core/ChecksumException.js");
var HybridBinarizer_1 = __webpack_require__(/*! ../core/common/HybridBinarizer */ "./node_modules/@zxing/library/esm5/core/common/HybridBinarizer.js");
var FormatException_1 = __webpack_require__(/*! ../core/FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
var NotFoundException_1 = __webpack_require__(/*! ../core/NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var HTMLCanvasElementLuminanceSource_1 = __webpack_require__(/*! ./HTMLCanvasElementLuminanceSource */ "./node_modules/@zxing/library/esm5/browser/HTMLCanvasElementLuminanceSource.js");
var VideoInputDevice_1 = __webpack_require__(/*! ./VideoInputDevice */ "./node_modules/@zxing/library/esm5/browser/VideoInputDevice.js");
/**
 * @deprecated Moving to @zxing/browser
 *
 * Base class for browser code reader.
 */
var BrowserCodeReader = /** @class */ (function () {
    /**
     * Creates an instance of BrowserCodeReader.
     * @param {Reader} reader The reader instance to decode the barcode
     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent successful decode tries
     *
     * @memberOf BrowserCodeReader
     */
    function BrowserCodeReader(reader, timeBetweenScansMillis, _hints) {
        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
        this.reader = reader;
        this.timeBetweenScansMillis = timeBetweenScansMillis;
        this._hints = _hints;
        /**
         * This will break the loop.
         */
        this._stopContinuousDecode = false;
        /**
         * This will break the loop.
         */
        this._stopAsyncDecode = false;
        /**
         * Delay time between decode attempts made by the scanner.
         */
        this._timeBetweenDecodingAttempts = 0;
    }
    Object.defineProperty(BrowserCodeReader.prototype, "hasNavigator", {
        /**
         * If navigator is present.
         */
        get: function () {
            return typeof navigator !== 'undefined';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrowserCodeReader.prototype, "isMediaDevicesSuported", {
        /**
         * If mediaDevices under navigator is supported.
         */
        get: function () {
            return this.hasNavigator && !!navigator.mediaDevices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrowserCodeReader.prototype, "canEnumerateDevices", {
        /**
         * If enumerateDevices under navigator is supported.
         */
        get: function () {
            return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrowserCodeReader.prototype, "timeBetweenDecodingAttempts", {
        /** Time between two decoding tries in milli seconds. */
        get: function () {
            return this._timeBetweenDecodingAttempts;
        },
        /**
         * Change the time span the decoder waits between two decoding tries.
         *
         * @param {number} millis Time between two decoding tries in milli seconds.
         */
        set: function (millis) {
            this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BrowserCodeReader.prototype, "hints", {
        /**
         * Sets the hints.
         */
        get: function () {
            return this._hints;
        },
        /**
         * Sets the hints.
         */
        set: function (hints) {
            this._hints = hints || null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Lists all the available video input devices.
     */
    BrowserCodeReader.prototype.listVideoInputDevices = function () {
        return __awaiter(this, void 0, void 0, function () {
            var e_1, _a, devices, videoDevices, devices_1, devices_1_1, device, kind, deviceId, label, groupId, videoDevice;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.hasNavigator) {
                            throw new Error('Can\'t enumerate devices, navigator is not present.');
                        }
                        if (!this.canEnumerateDevices) {
                            throw new Error('Can\'t enumerate devices, method not supported.');
                        }
                        return [4 /*yield*/, navigator.mediaDevices.enumerateDevices()];
                    case 1:
                        devices = _b.sent();
                        videoDevices = [];
                        try {
                            for (devices_1 = __values(devices), devices_1_1 = devices_1.next(); !devices_1_1.done; devices_1_1 = devices_1.next()) {
                                device = devices_1_1.value;
                                kind = device.kind === 'video' ? 'videoinput' : device.kind;
                                if (kind !== 'videoinput') {
                                    continue;
                                }
                                deviceId = device.deviceId || device.id;
                                label = device.label || "Video device " + (videoDevices.length + 1);
                                groupId = device.groupId;
                                videoDevice = { deviceId: deviceId, label: label, kind: kind, groupId: groupId };
                                videoDevices.push(videoDevice);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (devices_1_1 && !devices_1_1.done && (_a = devices_1.return)) _a.call(devices_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        return [2 /*return*/, videoDevices];
                }
            });
        });
    };
    /**
     * Obtain the list of available devices with type 'videoinput'.
     *
     * @returns {Promise<VideoInputDevice[]>} an array of available video input devices
     *
     * @memberOf BrowserCodeReader
     *
     * @deprecated Use `listVideoInputDevices` instead.
     */
    BrowserCodeReader.prototype.getVideoInputDevices = function () {
        return __awaiter(this, void 0, void 0, function () {
            var devices;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.listVideoInputDevices()];
                    case 1:
                        devices = _a.sent();
                        return [2 /*return*/, devices.map(function (d) { return new VideoInputDevice_1.VideoInputDevice(d.deviceId, d.label); })];
                }
            });
        });
    };
    /**
     * Let's you find a device using it's Id.
     */
    BrowserCodeReader.prototype.findDeviceById = function (deviceId) {
        return __awaiter(this, void 0, void 0, function () {
            var devices;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.listVideoInputDevices()];
                    case 1:
                        devices = _a.sent();
                        if (!devices) {
                            return [2 /*return*/, null];
                        }
                        return [2 /*return*/, devices.find(function (x) { return x.deviceId === deviceId; })];
                }
            });
        });
    };
    /**
     * Decodes the barcode from the device specified by deviceId while showing the video in the specified video element.
     *
     * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
     * @returns The decoding result.
     *
     * @memberOf BrowserCodeReader
     *
     * @deprecated Use `decodeOnceFromVideoDevice` instead.
     */
    BrowserCodeReader.prototype.decodeFromInputVideoDevice = function (deviceId, videoSource) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.decodeOnceFromVideoDevice(deviceId, videoSource)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * In one attempt, tries to decode the barcode from the device specified by deviceId while showing the video in the specified video element.
     *
     * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
     * @returns The decoding result.
     *
     * @memberOf BrowserCodeReader
     */
    BrowserCodeReader.prototype.decodeOnceFromVideoDevice = function (deviceId, videoSource) {
        return __awaiter(this, void 0, void 0, function () {
            var videoConstraints, constraints;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.reset();
                        if (!deviceId) {
                            videoConstraints = { facingMode: 'environment' };
                        }
                        else {
                            videoConstraints = { deviceId: { exact: deviceId } };
                        }
                        constraints = { video: videoConstraints };
                        return [4 /*yield*/, this.decodeOnceFromConstraints(constraints, videoSource)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
     *
     * @param constraints the media stream constraints to get s valid media stream to decode from
     * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
     * @returns The decoding result.
     *
     * @memberOf BrowserCodeReader
     */
    BrowserCodeReader.prototype.decodeOnceFromConstraints = function (constraints, videoSource) {
        return __awaiter(this, void 0, void 0, function () {
            var stream;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraints)];
                    case 1:
                        stream = _a.sent();
                        return [4 /*yield*/, this.decodeOnceFromStream(stream, videoSource)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
     *
     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
     * @returns {Promise<Result>} The decoding result.
     *
     * @memberOf BrowserCodeReader
     */
    BrowserCodeReader.prototype.decodeOnceFromStream = function (stream, videoSource) {
        return __awaiter(this, void 0, void 0, function () {
            var video, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.reset();
                        return [4 /*yield*/, this.attachStreamToVideo(stream, videoSource)];
                    case 1:
                        video = _a.sent();
                        return [4 /*yield*/, this.decodeOnce(video)];
                    case 2:
                        result = _a.sent();
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Continuously decodes the barcode from the device specified by device while showing the video in the specified video element.
     *
     * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
     * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
     * @returns {Promise<void>}
     *
     * @memberOf BrowserCodeReader
     *
     * @deprecated Use `decodeFromVideoDevice` instead.
     */
    BrowserCodeReader.prototype.decodeFromInputVideoDeviceContinuously = function (deviceId, videoSource, callbackFn) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.decodeFromVideoDevice(deviceId, videoSource, callbackFn)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Continuously tries to decode the barcode from the device specified by device while showing the video in the specified video element.
     *
     * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
     * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
     * @returns {Promise<void>}
     *
     * @memberOf BrowserCodeReader
     */
    BrowserCodeReader.prototype.decodeFromVideoDevice = function (deviceId, videoSource, callbackFn) {
        return __awaiter(this, void 0, void 0, function () {
            var videoConstraints, constraints;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!deviceId) {
                            videoConstraints = { facingMode: 'environment' };
                        }
                        else {
                            videoConstraints = { deviceId: { exact: deviceId } };
                        }
                        constraints = { video: videoConstraints };
                        return [4 /*yield*/, this.decodeFromConstraints(constraints, videoSource, callbackFn)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Continuously tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
     *
     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
     * @returns {Promise<Result>} The decoding result.
     *
     * @memberOf BrowserCodeReader
     */
    BrowserCodeReader.prototype.decodeFromConstraints = function (constraints, videoSource, callbackFn) {
        return __awaiter(this, void 0, void 0, function () {
            var stream;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, navigator.mediaDevices.getUserMedia(constraints)];
                    case 1:
                        stream = _a.sent();
                        return [4 /*yield*/, this.decodeFromStream(stream, videoSource, callbackFn)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
     *
     * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
     * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
     * @returns {Promise<Result>} The decoding result.
     *
     * @memberOf BrowserCodeReader
     */
    BrowserCodeReader.prototype.decodeFromStream = function (stream, videoSource, callbackFn) {
        return __awaiter(this, void 0, void 0, function () {
            var video;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.reset();
                        return [4 /*yield*/, this.attachStreamToVideo(stream, videoSource)];
                    case 1:
                        video = _a.sent();
                        return [4 /*yield*/, this.decodeContinuously(video, callbackFn)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Breaks the decoding loop.
     */
    BrowserCodeReader.prototype.stopAsyncDecode = function () {
        this._stopAsyncDecode = true;
    };
    /**
     * Breaks the decoding loop.
     */
    BrowserCodeReader.prototype.stopContinuousDecode = function () {
        this._stopContinuousDecode = true;
    };
    /**
     * Sets the new stream and request a new decoding-with-delay.
     *
     * @param stream The stream to be shown in the video element.
     * @param decodeFn A callback for the decode method.
     */
    BrowserCodeReader.prototype.attachStreamToVideo = function (stream, videoSource) {
        return __awaiter(this, void 0, void 0, function () {
            var videoElement;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        videoElement = this.prepareVideoElement(videoSource);
                        this.addVideoSource(videoElement, stream);
                        this.videoElement = videoElement;
                        this.stream = stream;
                        return [4 /*yield*/, this.playVideoOnLoadAsync(videoElement)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, videoElement];
                }
            });
        });
    };
    /**
     *
     * @param videoElement
     */
    BrowserCodeReader.prototype.playVideoOnLoadAsync = function (videoElement) {
        var _this = this;
        return new Promise(function (resolve, reject) { return _this.playVideoOnLoad(videoElement, function () { return resolve(); }); });
    };
    /**
     * Binds listeners and callbacks to the videoElement.
     *
     * @param element
     * @param callbackFn
     */
    BrowserCodeReader.prototype.playVideoOnLoad = function (element, callbackFn) {
        var _this = this;
        this.videoEndedListener = function () { return _this.stopStreams(); };
        this.videoCanPlayListener = function () { return _this.tryPlayVideo(element); };
        element.addEventListener('ended', this.videoEndedListener);
        element.addEventListener('canplay', this.videoCanPlayListener);
        element.addEventListener('playing', callbackFn);
        // if canplay was already fired, we won't know when to play, so just give it a try
        this.tryPlayVideo(element);
    };
    /**
     * Checks if the given video element is currently playing.
     */
    BrowserCodeReader.prototype.isVideoPlaying = function (video) {
        return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
    };
    /**
     * Just tries to play the video and logs any errors.
     * The play call is only made is the video is not already playing.
     */
    BrowserCodeReader.prototype.tryPlayVideo = function (videoElement) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.isVideoPlaying(videoElement)) {
                            console.warn('Trying to play video that is already playing.');
                            return [2 /*return*/];
                        }
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, videoElement.play()];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        console.warn('It was not possible to play the video.');
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Searches and validates a media element.
     */
    BrowserCodeReader.prototype.getMediaElement = function (mediaElementId, type) {
        var mediaElement = document.getElementById(mediaElementId);
        if (!mediaElement) {
            throw new ArgumentException_1.default("element with id '" + mediaElementId + "' not found");
        }
        if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {
            throw new ArgumentException_1.default("element with id '" + mediaElementId + "' must be an " + type + " element");
        }
        return mediaElement;
    };
    /**
     * Decodes the barcode from an image.
     *
     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
     * @param {string} [url]
     * @returns {Promise<Result>} The decoding result.
     *
     * @memberOf BrowserCodeReader
     */
    BrowserCodeReader.prototype.decodeFromImage = function (source, url) {
        if (!source && !url) {
            throw new ArgumentException_1.default('either imageElement with a src set or an url must be provided');
        }
        if (url && !source) {
            return this.decodeFromImageUrl(url);
        }
        return this.decodeFromImageElement(source);
    };
    /**
     * Decodes the barcode from a video.
     *
     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
     * @param {string} [url]
     * @returns {Promise<Result>} The decoding result.
     *
     * @memberOf BrowserCodeReader
     */
    BrowserCodeReader.prototype.decodeFromVideo = function (source, url) {
        if (!source && !url) {
            throw new ArgumentException_1.default('Either an element with a src set or an URL must be provided');
        }
        if (url && !source) {
            return this.decodeFromVideoUrl(url);
        }
        return this.decodeFromVideoElement(source);
    };
    /**
     * Decodes continuously the barcode from a video.
     *
     * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
     * @param {string} [url]
     * @returns {Promise<Result>} The decoding result.
     *
     * @memberOf BrowserCodeReader
     *
     * @experimental
     */
    BrowserCodeReader.prototype.decodeFromVideoContinuously = function (source, url, callbackFn) {
        if (undefined === source && undefined === url) {
            throw new ArgumentException_1.default('Either an element with a src set or an URL must be provided');
        }
        if (url && !source) {
            return this.decodeFromVideoUrlContinuously(url, callbackFn);
        }
        return this.decodeFromVideoElementContinuously(source, callbackFn);
    };
    /**
     * Decodes something from an image HTML element.
     */
    BrowserCodeReader.prototype.decodeFromImageElement = function (source) {
        if (!source) {
            throw new ArgumentException_1.default('An image element must be provided.');
        }
        this.reset();
        var element = this.prepareImageElement(source);
        this.imageElement = element;
        var task;
        if (this.isImageLoaded(element)) {
            task = this.decodeOnce(element, false, true);
        }
        else {
            task = this._decodeOnLoadImage(element);
        }
        return task;
    };
    /**
     * Decodes something from an image HTML element.
     */
    BrowserCodeReader.prototype.decodeFromVideoElement = function (source) {
        var element = this._decodeFromVideoElementSetup(source);
        return this._decodeOnLoadVideo(element);
    };
    /**
     * Decodes something from an image HTML element.
     */
    BrowserCodeReader.prototype.decodeFromVideoElementContinuously = function (source, callbackFn) {
        var element = this._decodeFromVideoElementSetup(source);
        return this._decodeOnLoadVideoContinuously(element, callbackFn);
    };
    /**
     * Sets up the video source so it can be decoded when loaded.
     *
     * @param source The video source element.
     */
    BrowserCodeReader.prototype._decodeFromVideoElementSetup = function (source) {
        if (!source) {
            throw new ArgumentException_1.default('A video element must be provided.');
        }
        this.reset();
        var element = this.prepareVideoElement(source);
        // defines the video element before starts decoding
        this.videoElement = element;
        return element;
    };
    /**
     * Decodes an image from a URL.
     */
    BrowserCodeReader.prototype.decodeFromImageUrl = function (url) {
        if (!url) {
            throw new ArgumentException_1.default('An URL must be provided.');
        }
        this.reset();
        var element = this.prepareImageElement();
        this.imageElement = element;
        var decodeTask = this._decodeOnLoadImage(element);
        element.src = url;
        return decodeTask;
    };
    /**
     * Decodes an image from a URL.
     */
    BrowserCodeReader.prototype.decodeFromVideoUrl = function (url) {
        if (!url) {
            throw new ArgumentException_1.default('An URL must be provided.');
        }
        this.reset();
        // creates a new element
        var element = this.prepareVideoElement();
        var decodeTask = this.decodeFromVideoElement(element);
        element.src = url;
        return decodeTask;
    };
    /**
     * Decodes an image from a URL.
     *
     * @experimental
     */
    BrowserCodeReader.prototype.decodeFromVideoUrlContinuously = function (url, callbackFn) {
        if (!url) {
            throw new ArgumentException_1.default('An URL must be provided.');
        }
        this.reset();
        // creates a new element
        var element = this.prepareVideoElement();
        var decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);
        element.src = url;
        return decodeTask;
    };
    BrowserCodeReader.prototype._decodeOnLoadImage = function (element) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.imageLoadedListener = function () { return _this.decodeOnce(element, false, true).then(resolve, reject); };
            element.addEventListener('load', _this.imageLoadedListener);
        });
    };
    BrowserCodeReader.prototype._decodeOnLoadVideo = function (videoElement) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    // plays the video
                    return [4 /*yield*/, this.playVideoOnLoadAsync(videoElement)];
                    case 1:
                        // plays the video
                        _a.sent();
                        return [4 /*yield*/, this.decodeOnce(videoElement)];
                    case 2: 
                    // starts decoding after played the video
                    return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    BrowserCodeReader.prototype._decodeOnLoadVideoContinuously = function (videoElement, callbackFn) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: 
                    // plays the video
                    return [4 /*yield*/, this.playVideoOnLoadAsync(videoElement)];
                    case 1:
                        // plays the video
                        _a.sent();
                        // starts decoding after played the video
                        this.decodeContinuously(videoElement, callbackFn);
                        return [2 /*return*/];
                }
            });
        });
    };
    BrowserCodeReader.prototype.isImageLoaded = function (img) {
        // During the onload event, IE correctly identifies any images that
        // werenâ€™t downloaded as not complete. Others should too. Gecko-based
        // browsers act like NS4 in that they report this incorrectly.
        if (!img.complete) {
            return false;
        }
        // However, they do have two very useful properties: naturalWidth and
        // naturalHeight. These give the true size of the image. If it failed
        // to load, either of these should be zero.
        if (img.naturalWidth === 0) {
            return false;
        }
        // No other way of checking: assume itâ€™s ok.
        return true;
    };
    BrowserCodeReader.prototype.prepareImageElement = function (imageSource) {
        var imageElement;
        if (typeof imageSource === 'undefined') {
            imageElement = document.createElement('img');
            imageElement.width = 200;
            imageElement.height = 200;
        }
        if (typeof imageSource === 'string') {
            imageElement = this.getMediaElement(imageSource, 'img');
        }
        if (imageSource instanceof HTMLImageElement) {
            imageElement = imageSource;
        }
        return imageElement;
    };
    /**
     * Sets a HTMLVideoElement for scanning or creates a new one.
     *
     * @param videoSource The HTMLVideoElement to be set.
     */
    BrowserCodeReader.prototype.prepareVideoElement = function (videoSource) {
        var videoElement;
        if (!videoSource && typeof document !== 'undefined') {
            videoElement = document.createElement('video');
            videoElement.width = 200;
            videoElement.height = 200;
        }
        if (typeof videoSource === 'string') {
            videoElement = this.getMediaElement(videoSource, 'video');
        }
        if (videoSource instanceof HTMLVideoElement) {
            videoElement = videoSource;
        }
        // Needed for iOS 11
        videoElement.setAttribute('autoplay', 'true');
        videoElement.setAttribute('muted', 'true');
        videoElement.setAttribute('playsinline', 'true');
        return videoElement;
    };
    /**
     * Tries to decode from the video input until it finds some value.
     */
    BrowserCodeReader.prototype.decodeOnce = function (element, retryIfNotFound, retryIfChecksumOrFormatError) {
        var _this = this;
        if (retryIfNotFound === void 0) { retryIfNotFound = true; }
        if (retryIfChecksumOrFormatError === void 0) { retryIfChecksumOrFormatError = true; }
        this._stopAsyncDecode = false;
        var loop = function (resolve, reject) {
            if (_this._stopAsyncDecode) {
                reject(new NotFoundException_1.default('Video stream has ended before any code could be detected.'));
                _this._stopAsyncDecode = undefined;
                return;
            }
            try {
                var result = _this.decode(element);
                resolve(result);
            }
            catch (e) {
                var ifNotFound = retryIfNotFound && e instanceof NotFoundException_1.default;
                var isChecksumOrFormatError = e instanceof ChecksumException_1.default || e instanceof FormatException_1.default;
                var ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;
                if (ifNotFound || ifChecksumOrFormat) {
                    // trying again
                    return setTimeout(loop, _this._timeBetweenDecodingAttempts, resolve, reject);
                }
                reject(e);
            }
        };
        return new Promise(function (resolve, reject) { return loop(resolve, reject); });
    };
    /**
     * Continuously decodes from video input.
     */
    BrowserCodeReader.prototype.decodeContinuously = function (element, callbackFn) {
        var _this = this;
        this._stopContinuousDecode = false;
        var loop = function () {
            if (_this._stopContinuousDecode) {
                _this._stopContinuousDecode = undefined;
                return;
            }
            try {
                var result = _this.decode(element);
                callbackFn(result, null);
                setTimeout(loop, _this.timeBetweenScansMillis);
            }
            catch (e) {
                callbackFn(null, e);
                var isChecksumOrFormatError = e instanceof ChecksumException_1.default || e instanceof FormatException_1.default;
                var isNotFound = e instanceof NotFoundException_1.default;
                if (isChecksumOrFormatError || isNotFound) {
                    // trying again
                    setTimeout(loop, _this._timeBetweenDecodingAttempts);
                }
            }
        };
        loop();
    };
    /**
     * Gets the BinaryBitmap for ya! (and decodes it)
     */
    BrowserCodeReader.prototype.decode = function (element) {
        // get binary bitmap for decode function
        var binaryBitmap = this.createBinaryBitmap(element);
        return this.decodeBitmap(binaryBitmap);
    };
    /**
     * Creates a binaryBitmap based in some image source.
     *
     * @param mediaElement HTML element containing drawable image source.
     */
    BrowserCodeReader.prototype.createBinaryBitmap = function (mediaElement) {
        var ctx = this.getCaptureCanvasContext(mediaElement);
        this.drawImageOnCanvas(ctx, mediaElement);
        var canvas = this.getCaptureCanvas(mediaElement);
        var luminanceSource = new HTMLCanvasElementLuminanceSource_1.HTMLCanvasElementLuminanceSource(canvas);
        var hybridBinarizer = new HybridBinarizer_1.default(luminanceSource);
        return new BinaryBitmap_1.default(hybridBinarizer);
    };
    /**
     *
     */
    BrowserCodeReader.prototype.getCaptureCanvasContext = function (mediaElement) {
        if (!this.captureCanvasContext) {
            var elem = this.getCaptureCanvas(mediaElement);
            var ctx = elem.getContext('2d');
            this.captureCanvasContext = ctx;
        }
        return this.captureCanvasContext;
    };
    /**
     *
     */
    BrowserCodeReader.prototype.getCaptureCanvas = function (mediaElement) {
        if (!this.captureCanvas) {
            var elem = this.createCaptureCanvas(mediaElement);
            this.captureCanvas = elem;
        }
        return this.captureCanvas;
    };
    /**
     * Ovewriting this allows you to manipulate the snapshot image in anyway you want before decode.
     */
    BrowserCodeReader.prototype.drawImageOnCanvas = function (canvasElementContext, srcElement) {
        canvasElementContext.drawImage(srcElement, 0, 0);
    };
    /**
     * Call the encapsulated readers decode
     */
    BrowserCodeReader.prototype.decodeBitmap = function (binaryBitmap) {
        return this.reader.decode(binaryBitmap, this._hints);
    };
    /**
     * ðŸ–Œ Prepares the canvas for capture and scan frames.
     */
    BrowserCodeReader.prototype.createCaptureCanvas = function (mediaElement) {
        if (typeof document === 'undefined') {
            this._destroyCaptureCanvas();
            return null;
        }
        var canvasElement = document.createElement('canvas');
        var width;
        var height;
        if (typeof mediaElement !== 'undefined') {
            if (mediaElement instanceof HTMLVideoElement) {
                width = mediaElement.videoWidth;
                height = mediaElement.videoHeight;
            }
            else if (mediaElement instanceof HTMLImageElement) {
                width = mediaElement.naturalWidth || mediaElement.width;
                height = mediaElement.naturalHeight || mediaElement.height;
            }
        }
        canvasElement.style.width = width + 'px';
        canvasElement.style.height = height + 'px';
        canvasElement.width = width;
        canvasElement.height = height;
        return canvasElement;
    };
    /**
     * Stops the continuous scan and cleans the stream.
     */
    BrowserCodeReader.prototype.stopStreams = function () {
        if (this.stream) {
            this.stream.getVideoTracks().forEach(function (t) { return t.stop(); });
            this.stream = undefined;
        }
        if (this._stopAsyncDecode === false) {
            this.stopAsyncDecode();
        }
        if (this._stopContinuousDecode === false) {
            this.stopContinuousDecode();
        }
    };
    /**
     * Resets the code reader to the initial state. Cancels any ongoing barcode scanning from video or camera.
     *
     * @memberOf BrowserCodeReader
     */
    BrowserCodeReader.prototype.reset = function () {
        // stops the camera, preview and scan ðŸ”´
        this.stopStreams();
        // clean and forget about HTML elements
        this._destroyVideoElement();
        this._destroyImageElement();
        this._destroyCaptureCanvas();
    };
    BrowserCodeReader.prototype._destroyVideoElement = function () {
        if (!this.videoElement) {
            return;
        }
        // first gives freedon to the element ðŸ•Š
        if (typeof this.videoEndedListener !== 'undefined') {
            this.videoElement.removeEventListener('ended', this.videoEndedListener);
        }
        if (typeof this.videoPlayingEventListener !== 'undefined') {
            this.videoElement.removeEventListener('playing', this.videoPlayingEventListener);
        }
        if (typeof this.videoCanPlayListener !== 'undefined') {
            this.videoElement.removeEventListener('loadedmetadata', this.videoCanPlayListener);
        }
        // then forgets about that element ðŸ˜¢
        this.cleanVideoSource(this.videoElement);
        this.videoElement = undefined;
    };
    BrowserCodeReader.prototype._destroyImageElement = function () {
        if (!this.imageElement) {
            return;
        }
        // first gives freedon to the element ðŸ•Š
        if (undefined !== this.imageLoadedListener) {
            this.imageElement.removeEventListener('load', this.imageLoadedListener);
        }
        // then forget about that element ðŸ˜¢
        this.imageElement.src = undefined;
        this.imageElement.removeAttribute('src');
        this.imageElement = undefined;
    };
    /**
     * Cleans canvas references ðŸ–Œ
     */
    BrowserCodeReader.prototype._destroyCaptureCanvas = function () {
        // then forget about that element ðŸ˜¢
        this.captureCanvasContext = undefined;
        this.captureCanvas = undefined;
    };
    /**
     * Defines what the videoElement src will be.
     *
     * @param videoElement
     * @param stream
     */
    BrowserCodeReader.prototype.addVideoSource = function (videoElement, stream) {
        // Older browsers may not have `srcObject`
        try {
            // @note Throws Exception if interrupted by a new loaded request
            videoElement.srcObject = stream;
        }
        catch (err) {
            // @note Avoid using this in new browsers, as it is going away.
            videoElement.src = URL.createObjectURL(stream);
        }
    };
    /**
     * Unbinds a HTML video src property.
     *
     * @param videoElement
     */
    BrowserCodeReader.prototype.cleanVideoSource = function (videoElement) {
        try {
            videoElement.srcObject = null;
        }
        catch (err) {
            videoElement.src = '';
        }
        this.videoElement.removeAttribute('src');
    };
    return BrowserCodeReader;
}());
exports.BrowserCodeReader = BrowserCodeReader;
//# sourceMappingURL=BrowserCodeReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/browser/BrowserDatamatrixCodeReader.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/browser/BrowserDatamatrixCodeReader.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ "./node_modules/@zxing/library/esm5/browser/BrowserCodeReader.js");
var DataMatrixReader_1 = __webpack_require__(/*! ../core/datamatrix/DataMatrixReader */ "./node_modules/@zxing/library/esm5/core/datamatrix/DataMatrixReader.js");
/**
 * @deprecated Moving to @zxing/browser
 *
 * QR Code reader to use from browser.
 */
var BrowserDatamatrixCodeReader = /** @class */ (function (_super) {
    __extends(BrowserDatamatrixCodeReader, _super);
    /**
     * Creates an instance of BrowserQRCodeReader.
     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
     */
    function BrowserDatamatrixCodeReader(timeBetweenScansMillis) {
        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
        return _super.call(this, new DataMatrixReader_1.default(), timeBetweenScansMillis) || this;
    }
    return BrowserDatamatrixCodeReader;
}(BrowserCodeReader_1.BrowserCodeReader));
exports.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;
//# sourceMappingURL=BrowserDatamatrixCodeReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/browser/BrowserMultiFormatReader.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/browser/BrowserMultiFormatReader.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ "./node_modules/@zxing/library/esm5/browser/BrowserCodeReader.js");
var MultiFormatReader_1 = __webpack_require__(/*! ../core/MultiFormatReader */ "./node_modules/@zxing/library/esm5/core/MultiFormatReader.js");
var BrowserMultiFormatReader = /** @class */ (function (_super) {
    __extends(BrowserMultiFormatReader, _super);
    function BrowserMultiFormatReader(hints, timeBetweenScansMillis) {
        if (hints === void 0) { hints = null; }
        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
        var _this = this;
        var reader = new MultiFormatReader_1.default();
        reader.setHints(hints);
        _this = _super.call(this, reader, timeBetweenScansMillis) || this;
        return _this;
    }
    /**
     * Overwrite decodeBitmap to call decodeWithState, which will pay
     * attention to the hints set in the constructor function
     */
    BrowserMultiFormatReader.prototype.decodeBitmap = function (binaryBitmap) {
        return this.reader.decodeWithState(binaryBitmap);
    };
    return BrowserMultiFormatReader;
}(BrowserCodeReader_1.BrowserCodeReader));
exports.BrowserMultiFormatReader = BrowserMultiFormatReader;
//# sourceMappingURL=BrowserMultiFormatReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/browser/BrowserPDF417Reader.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/browser/BrowserPDF417Reader.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ "./node_modules/@zxing/library/esm5/browser/BrowserCodeReader.js");
var PDF417Reader_1 = __webpack_require__(/*! ../core/pdf417/PDF417Reader */ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417Reader.js");
/**
 * @deprecated Moving to @zxing/browser
 *
 * QR Code reader to use from browser.
 */
var BrowserPDF417Reader = /** @class */ (function (_super) {
    __extends(BrowserPDF417Reader, _super);
    /**
     * Creates an instance of BrowserPDF417Reader.
     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
     */
    function BrowserPDF417Reader(timeBetweenScansMillis) {
        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
        return _super.call(this, new PDF417Reader_1.default(), timeBetweenScansMillis) || this;
    }
    return BrowserPDF417Reader;
}(BrowserCodeReader_1.BrowserCodeReader));
exports.BrowserPDF417Reader = BrowserPDF417Reader;
//# sourceMappingURL=BrowserPDF417Reader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/browser/BrowserQRCodeReader.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/browser/BrowserQRCodeReader.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserCodeReader_1 = __webpack_require__(/*! ./BrowserCodeReader */ "./node_modules/@zxing/library/esm5/browser/BrowserCodeReader.js");
var QRCodeReader_1 = __webpack_require__(/*! ../core/qrcode/QRCodeReader */ "./node_modules/@zxing/library/esm5/core/qrcode/QRCodeReader.js");
/**
 * @deprecated Moving to @zxing/browser
 *
 * QR Code reader to use from browser.
 */
var BrowserQRCodeReader = /** @class */ (function (_super) {
    __extends(BrowserQRCodeReader, _super);
    /**
     * Creates an instance of BrowserQRCodeReader.
     * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
     */
    function BrowserQRCodeReader(timeBetweenScansMillis) {
        if (timeBetweenScansMillis === void 0) { timeBetweenScansMillis = 500; }
        return _super.call(this, new QRCodeReader_1.default(), timeBetweenScansMillis) || this;
    }
    return BrowserQRCodeReader;
}(BrowserCodeReader_1.BrowserCodeReader));
exports.BrowserQRCodeReader = BrowserQRCodeReader;
//# sourceMappingURL=BrowserQRCodeReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/browser/BrowserQRCodeSvgWriter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/browser/BrowserQRCodeSvgWriter.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EncodeHintType_1 = __webpack_require__(/*! ../core/EncodeHintType */ "./node_modules/@zxing/library/esm5/core/EncodeHintType.js");
var Encoder_1 = __webpack_require__(/*! ../core/qrcode/encoder/Encoder */ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/Encoder.js");
var ErrorCorrectionLevel_1 = __webpack_require__(/*! ../core/qrcode/decoder/ErrorCorrectionLevel */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/ErrorCorrectionLevel.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../core/IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
var IllegalStateException_1 = __webpack_require__(/*! ../core/IllegalStateException */ "./node_modules/@zxing/library/esm5/core/IllegalStateException.js");
/**
 * @deprecated Moving to @zxing/browser
 */
var BrowserQRCodeSvgWriter = /** @class */ (function () {
    function BrowserQRCodeSvgWriter() {
    }
    /**
     * Writes and renders a QRCode SVG element.
     *
     * @param contents
     * @param width
     * @param height
     * @param hints
     */
    BrowserQRCodeSvgWriter.prototype.write = function (contents, width, height, hints) {
        if (hints === void 0) { hints = null; }
        if (contents.length === 0) {
            throw new IllegalArgumentException_1.default('Found empty contents');
        }
        // if (format != BarcodeFormat.QR_CODE) {
        //   throw new IllegalArgumentException("Can only encode QR_CODE, but got " + format)
        // }
        if (width < 0 || height < 0) {
            throw new IllegalArgumentException_1.default('Requested dimensions are too small: ' + width + 'x' + height);
        }
        var errorCorrectionLevel = ErrorCorrectionLevel_1.default.L;
        var quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;
        if (hints !== null) {
            if (undefined !== hints.get(EncodeHintType_1.default.ERROR_CORRECTION)) {
                errorCorrectionLevel = ErrorCorrectionLevel_1.default.fromString(hints.get(EncodeHintType_1.default.ERROR_CORRECTION).toString());
            }
            if (undefined !== hints.get(EncodeHintType_1.default.MARGIN)) {
                quietZone = Number.parseInt(hints.get(EncodeHintType_1.default.MARGIN).toString(), 10);
            }
        }
        var code = Encoder_1.default.encode(contents, errorCorrectionLevel, hints);
        return this.renderResult(code, width, height, quietZone);
    };
    /**
     * Renders the result and then appends it to the DOM.
     */
    BrowserQRCodeSvgWriter.prototype.writeToDom = function (containerElement, contents, width, height, hints) {
        if (hints === void 0) { hints = null; }
        if (typeof containerElement === 'string') {
            containerElement = document.querySelector(containerElement);
        }
        var svgElement = this.write(contents, width, height, hints);
        if (containerElement)
            containerElement.appendChild(svgElement);
    };
    /**
     * Note that the input matrix uses 0 == white, 1 == black.
     * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
     */
    BrowserQRCodeSvgWriter.prototype.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {
        var input = code.getMatrix();
        if (input === null) {
            throw new IllegalStateException_1.default();
        }
        var inputWidth = input.getWidth();
        var inputHeight = input.getHeight();
        var qrWidth = inputWidth + (quietZone * 2);
        var qrHeight = inputHeight + (quietZone * 2);
        var outputWidth = Math.max(width, qrWidth);
        var outputHeight = Math.max(height, qrHeight);
        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        // Padding includes both the quiet zone and the extra white pixels to accommodate the requested
        // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.
        // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will
        // handle all the padding from 100x100 (the actual QR) up to 200x160.
        var leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);
        var topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);
        var svgElement = this.createSVGElement(outputWidth, outputHeight);
        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
            // Write the contents of this row of the barcode
            for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                if (input.get(inputX, inputY) === 1) {
                    var svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
                    svgElement.appendChild(svgRectElement);
                }
            }
        }
        return svgElement;
    };
    /**
     * Creates a SVG element.
     *
     * @param w SVG's width attribute
     * @param h SVG's height attribute
     */
    BrowserQRCodeSvgWriter.prototype.createSVGElement = function (w, h) {
        var svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'svg');
        svgElement.setAttributeNS(null, 'height', w.toString());
        svgElement.setAttributeNS(null, 'width', h.toString());
        return svgElement;
    };
    /**
     * Creates a SVG rect element.
     *
     * @param x Element's x coordinate
     * @param y Element's y coordinate
     * @param w Element's width attribute
     * @param h Element's height attribute
     */
    BrowserQRCodeSvgWriter.prototype.createSvgRectElement = function (x, y, w, h) {
        var rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, 'rect');
        rect.setAttributeNS(null, 'x', x.toString());
        rect.setAttributeNS(null, 'y', y.toString());
        rect.setAttributeNS(null, 'height', w.toString());
        rect.setAttributeNS(null, 'width', h.toString());
        rect.setAttributeNS(null, 'fill', '#000000');
        return rect;
    };
    BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;
    /**
     * SVG markup NameSpace
     */
    BrowserQRCodeSvgWriter.SVG_NS = 'http://www.w3.org/2000/svg';
    return BrowserQRCodeSvgWriter;
}());
exports.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;
//# sourceMappingURL=BrowserQRCodeSvgWriter.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/browser/HTMLCanvasElementLuminanceSource.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/browser/HTMLCanvasElementLuminanceSource.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var InvertedLuminanceSource_1 = __webpack_require__(/*! ../core/InvertedLuminanceSource */ "./node_modules/@zxing/library/esm5/core/InvertedLuminanceSource.js");
var LuminanceSource_1 = __webpack_require__(/*! ../core/LuminanceSource */ "./node_modules/@zxing/library/esm5/core/LuminanceSource.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../core/IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * @deprecated Moving to @zxing/browser
 */
var HTMLCanvasElementLuminanceSource = /** @class */ (function (_super) {
    __extends(HTMLCanvasElementLuminanceSource, _super);
    function HTMLCanvasElementLuminanceSource(canvas) {
        var _this = _super.call(this, canvas.width, canvas.height) || this;
        _this.canvas = canvas;
        _this.tempCanvasElement = null;
        _this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);
        return _this;
    }
    HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData = function (canvas) {
        var imageData = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
        return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
    };
    HTMLCanvasElementLuminanceSource.toGrayscaleBuffer = function (imageBuffer, width, height) {
        var grayscaleBuffer = new Uint8ClampedArray(width * height);
        for (var i = 0, j = 0, length_1 = imageBuffer.length; i < length_1; i += 4, j++) {
            var gray = void 0;
            var alpha = imageBuffer[i + 3];
            // The color of fully-transparent pixels is irrelevant. They are often, technically, fully-transparent
            // black (0 alpha, and then 0 RGB). They are often used, of course as the "white" area in a
            // barcode image. Force any such pixel to be white:
            if (alpha === 0) {
                gray = 0xFF;
            }
            else {
                var pixelR = imageBuffer[i];
                var pixelG = imageBuffer[i + 1];
                var pixelB = imageBuffer[i + 2];
                // .299R + 0.587G + 0.114B (YUV/YIQ for PAL and NTSC),
                // (306*R) >> 10 is approximately equal to R*0.299, and so on.
                // 0x200 >> 10 is 0.5, it implements rounding.
                gray = (306 * pixelR +
                    601 * pixelG +
                    117 * pixelB +
                    0x200) >> 10;
            }
            grayscaleBuffer[j] = gray;
        }
        return grayscaleBuffer;
    };
    HTMLCanvasElementLuminanceSource.prototype.getRow = function (y /*int*/, row) {
        if (y < 0 || y >= this.getHeight()) {
            throw new IllegalArgumentException_1.default('Requested row is outside the image: ' + y);
        }
        var width = this.getWidth();
        var start = y * width;
        if (row === null) {
            row = this.buffer.slice(start, start + width);
        }
        else {
            if (row.length < width) {
                row = new Uint8ClampedArray(width);
            }
            // The underlying raster of image consists of bytes with the luminance values
            // TODO: can avoid set/slice?
            row.set(this.buffer.slice(start, start + width));
        }
        return row;
    };
    HTMLCanvasElementLuminanceSource.prototype.getMatrix = function () {
        return this.buffer;
    };
    HTMLCanvasElementLuminanceSource.prototype.isCropSupported = function () {
        return true;
    };
    HTMLCanvasElementLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        _super.prototype.crop.call(this, left, top, width, height);
        return this;
    };
    /**
     * This is always true, since the image is a gray-scale image.
     *
     * @return true
     */
    HTMLCanvasElementLuminanceSource.prototype.isRotateSupported = function () {
        return true;
    };
    HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise = function () {
        this.rotate(-90);
        return this;
    };
    HTMLCanvasElementLuminanceSource.prototype.rotateCounterClockwise45 = function () {
        this.rotate(-45);
        return this;
    };
    HTMLCanvasElementLuminanceSource.prototype.getTempCanvasElement = function () {
        if (null === this.tempCanvasElement) {
            var tempCanvasElement = this.canvas.ownerDocument.createElement('canvas');
            tempCanvasElement.width = this.canvas.width;
            tempCanvasElement.height = this.canvas.height;
            this.tempCanvasElement = tempCanvasElement;
        }
        return this.tempCanvasElement;
    };
    HTMLCanvasElementLuminanceSource.prototype.rotate = function (angle) {
        var tempCanvasElement = this.getTempCanvasElement();
        var tempContext = tempCanvasElement.getContext('2d');
        var angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;
        // Calculate and set new dimensions for temp canvas
        var width = this.canvas.width;
        var height = this.canvas.height;
        var newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);
        var newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);
        tempCanvasElement.width = newWidth;
        tempCanvasElement.height = newHeight;
        // Draw at center of temp canvas to prevent clipping of image data
        tempContext.translate(newWidth / 2, newHeight / 2);
        tempContext.rotate(angleRadians);
        tempContext.drawImage(this.canvas, width / -2, height / -2);
        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);
        return this;
    };
    HTMLCanvasElementLuminanceSource.prototype.invert = function () {
        return new InvertedLuminanceSource_1.default(this);
    };
    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;
    return HTMLCanvasElementLuminanceSource;
}(LuminanceSource_1.default));
exports.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;
//# sourceMappingURL=HTMLCanvasElementLuminanceSource.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/browser/VideoInputDevice.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/browser/VideoInputDevice.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @deprecated Moving to @zxing/browser
 *
 * Video input device metadata containing the id and label of the device if available.
 */
var VideoInputDevice = /** @class */ (function () {
    /**
     * Creates an instance of VideoInputDevice.
     *
     * @param {string} deviceId the video input device id
     * @param {string} label the label of the device if available
     */
    function VideoInputDevice(deviceId, label, groupId) {
        this.deviceId = deviceId;
        this.label = label;
        /** @inheritdoc */
        this.kind = 'videoinput';
        this.groupId = groupId || undefined;
    }
    /** @inheritdoc */
    VideoInputDevice.prototype.toJSON = function () {
        return {
            kind: this.kind,
            groupId: this.groupId,
            deviceId: this.deviceId,
            label: this.label,
        };
    };
    return VideoInputDevice;
}());
exports.VideoInputDevice = VideoInputDevice;
//# sourceMappingURL=VideoInputDevice.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/ArgumentException.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/ArgumentException.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var ArgumentException = /** @class */ (function (_super) {
    __extends(ArgumentException, _super);
    function ArgumentException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ArgumentException;
}(Exception_1.default));
exports.default = ArgumentException;
//# sourceMappingURL=ArgumentException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/ArithmeticException.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/ArithmeticException.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var ArithmeticException = /** @class */ (function (_super) {
    __extends(ArithmeticException, _super);
    function ArithmeticException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ArithmeticException;
}(Exception_1.default));
exports.default = ArithmeticException;
//# sourceMappingURL=ArithmeticException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/ArrayIndexOutOfBoundsException.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/ArrayIndexOutOfBoundsException.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var IndexOutOfBoundsException_1 = __webpack_require__(/*! ./IndexOutOfBoundsException */ "./node_modules/@zxing/library/esm5/core/IndexOutOfBoundsException.js");
/**
 * Custom Error class of type Exception.
 */
var ArrayIndexOutOfBoundsException = /** @class */ (function (_super) {
    __extends(ArrayIndexOutOfBoundsException, _super);
    function ArrayIndexOutOfBoundsException(index, message) {
        if (index === void 0) { index = undefined; }
        if (message === void 0) { message = undefined; }
        var _this = _super.call(this, message) || this;
        _this.index = index;
        _this.message = message;
        return _this;
    }
    return ArrayIndexOutOfBoundsException;
}(IndexOutOfBoundsException_1.default));
exports.default = ArrayIndexOutOfBoundsException;
//# sourceMappingURL=ArrayIndexOutOfBoundsException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js":
/*!****************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/BarcodeFormat.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Direct port to TypeScript of ZXing by Adrian ToÈ™cÄƒ
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*namespace com.google.zxing {*/
/**
 * Enumerates barcode formats known to this package. Please keep alphabetized.
 *
 * @author Sean Owen
 */
var BarcodeFormat;
(function (BarcodeFormat) {
    /** Aztec 2D barcode format. */
    BarcodeFormat[BarcodeFormat["AZTEC"] = 0] = "AZTEC";
    /** CODABAR 1D format. */
    BarcodeFormat[BarcodeFormat["CODABAR"] = 1] = "CODABAR";
    /** Code 39 1D format. */
    BarcodeFormat[BarcodeFormat["CODE_39"] = 2] = "CODE_39";
    /** Code 93 1D format. */
    BarcodeFormat[BarcodeFormat["CODE_93"] = 3] = "CODE_93";
    /** Code 128 1D format. */
    BarcodeFormat[BarcodeFormat["CODE_128"] = 4] = "CODE_128";
    /** Data Matrix 2D barcode format. */
    BarcodeFormat[BarcodeFormat["DATA_MATRIX"] = 5] = "DATA_MATRIX";
    /** EAN-8 1D format. */
    BarcodeFormat[BarcodeFormat["EAN_8"] = 6] = "EAN_8";
    /** EAN-13 1D format. */
    BarcodeFormat[BarcodeFormat["EAN_13"] = 7] = "EAN_13";
    /** ITF (Interleaved Two of Five) 1D format. */
    BarcodeFormat[BarcodeFormat["ITF"] = 8] = "ITF";
    /** MaxiCode 2D barcode format. */
    BarcodeFormat[BarcodeFormat["MAXICODE"] = 9] = "MAXICODE";
    /** PDF417 format. */
    BarcodeFormat[BarcodeFormat["PDF_417"] = 10] = "PDF_417";
    /** QR Code 2D barcode format. */
    BarcodeFormat[BarcodeFormat["QR_CODE"] = 11] = "QR_CODE";
    /** RSS 14 */
    BarcodeFormat[BarcodeFormat["RSS_14"] = 12] = "RSS_14";
    /** RSS EXPANDED */
    BarcodeFormat[BarcodeFormat["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
    /** UPC-A 1D format. */
    BarcodeFormat[BarcodeFormat["UPC_A"] = 14] = "UPC_A";
    /** UPC-E 1D format. */
    BarcodeFormat[BarcodeFormat["UPC_E"] = 15] = "UPC_E";
    /** UPC/EAN extension format. Not a stand-alone format. */
    BarcodeFormat[BarcodeFormat["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
})(BarcodeFormat || (BarcodeFormat = {}));
exports.default = BarcodeFormat;
//# sourceMappingURL=BarcodeFormat.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/Binarizer.js":
/*!************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/Binarizer.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This class hierarchy provides a set of methods to convert luminance data to 1 bit data.
 * It allows the algorithm to vary polymorphically, for example allowing a very expensive
 * thresholding technique for servers and a fast one for mobile. It also permits the implementation
 * to vary, e.g. a JNI version for Android and a Java fallback version for other platforms.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 */
var Binarizer = /** @class */ (function () {
    function Binarizer(source) {
        this.source = source;
    }
    Binarizer.prototype.getLuminanceSource = function () {
        return this.source;
    };
    Binarizer.prototype.getWidth = function () {
        return this.source.getWidth();
    };
    Binarizer.prototype.getHeight = function () {
        return this.source.getHeight();
    };
    return Binarizer;
}());
exports.default = Binarizer;
//# sourceMappingURL=Binarizer.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/BinaryBitmap.js":
/*!***************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/BinaryBitmap.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var IllegalArgumentException_1 = __webpack_require__(/*! ./IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
var BinaryBitmap = /** @class */ (function () {
    function BinaryBitmap(binarizer) {
        this.binarizer = binarizer;
        if (binarizer === null) {
            throw new IllegalArgumentException_1.default('Binarizer must be non-null.');
        }
    }
    /**
     * @return The width of the bitmap.
     */
    BinaryBitmap.prototype.getWidth = function () {
        return this.binarizer.getWidth();
    };
    /**
     * @return The height of the bitmap.
     */
    BinaryBitmap.prototype.getHeight = function () {
        return this.binarizer.getHeight();
    };
    /**
     * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return
     * cached data. Callers should assume this method is expensive and call it as seldom as possible.
     * This method is intended for decoding 1D barcodes and may choose to apply sharpening.
     *
     * @param y The row to fetch, which must be in [0, bitmap height)
     * @param row An optional preallocated array. If null or too small, it will be ignored.
     *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.
     * @return The array of bits for this row (true means black).
     * @throws NotFoundException if row can't be binarized
     */
    BinaryBitmap.prototype.getBlackRow = function (y /*int*/, row) {
        return this.binarizer.getBlackRow(y, row);
    };
    /**
     * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive
     * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or
     * may not apply sharpening. Therefore, a row from this matrix may not be identical to one
     * fetched using getBlackRow(), so don't mix and match between them.
     *
     * @return The 2D array of bits for the image (true means black).
     * @throws NotFoundException if image can't be binarized to make a matrix
     */
    BinaryBitmap.prototype.getBlackMatrix = function () {
        // The matrix is created on demand the first time it is requested, then cached. There are two
        // reasons for this:
        // 1. This work will never be done if the caller only installs 1D Reader objects, or if a
        //    1D Reader finds a barcode before the 2D Readers run.
        // 2. This work will only be done once even if the caller installs multiple 2D Readers.
        if (this.matrix === null || this.matrix === undefined) {
            this.matrix = this.binarizer.getBlackMatrix();
        }
        return this.matrix;
    };
    /**
     * @return Whether this bitmap can be cropped.
     */
    BinaryBitmap.prototype.isCropSupported = function () {
        return this.binarizer.getLuminanceSource().isCropSupported();
    };
    /**
     * Returns a new object with cropped image data. Implementations may keep a reference to the
     * original data rather than a copy. Only callable if isCropSupported() is true.
     *
     * @param left The left coordinate, which must be in [0,getWidth())
     * @param top The top coordinate, which must be in [0,getHeight())
     * @param width The width of the rectangle to crop.
     * @param height The height of the rectangle to crop.
     * @return A cropped version of this object.
     */
    BinaryBitmap.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        var newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
    };
    /**
     * @return Whether this bitmap supports counter-clockwise rotation.
     */
    BinaryBitmap.prototype.isRotateSupported = function () {
        return this.binarizer.getLuminanceSource().isRotateSupported();
    };
    /**
     * Returns a new object with rotated image data by 90 degrees counterclockwise.
     * Only callable if {@link #isRotateSupported()} is true.
     *
     * @return A rotated version of this object.
     */
    BinaryBitmap.prototype.rotateCounterClockwise = function () {
        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
    };
    /**
     * Returns a new object with rotated image data by 45 degrees counterclockwise.
     * Only callable if {@link #isRotateSupported()} is true.
     *
     * @return A rotated version of this object.
     */
    BinaryBitmap.prototype.rotateCounterClockwise45 = function () {
        var newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
    };
    /*@Override*/
    BinaryBitmap.prototype.toString = function () {
        try {
            return this.getBlackMatrix().toString();
        }
        catch (e /*: NotFoundException*/) {
            return '';
        }
    };
    return BinaryBitmap;
}());
exports.default = BinaryBitmap;
//# sourceMappingURL=BinaryBitmap.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/ChecksumException.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/ChecksumException.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var ChecksumException = /** @class */ (function (_super) {
    __extends(ChecksumException, _super);
    function ChecksumException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ChecksumException.getChecksumInstance = function () {
        return new ChecksumException();
    };
    return ChecksumException;
}(Exception_1.default));
exports.default = ChecksumException;
//# sourceMappingURL=ChecksumException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/DecodeHintType.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing {*/
/**
 * Encapsulates a type of hint that a caller may pass to a barcode reader to help it
 * more quickly or accurately decode it. It is up to implementations to decide what,
 * if anything, to do with the information that is supplied.
 *
 * @author Sean Owen
 * @author dswitkin@google.com (Daniel Switkin)
 * @see Reader#decode(BinaryBitmap,java.util.Map)
 */
var DecodeHintType;
(function (DecodeHintType) {
    /**
     * Unspecified, application-specific hint. Maps to an unspecified {@link Object}.
     */
    DecodeHintType[DecodeHintType["OTHER"] = 0] = "OTHER"; /*(Object.class)*/
    /**
     * Image is a pure monochrome image of a barcode. Doesn't matter what it maps to;
     * use {@link Boolean#TRUE}.
     */
    DecodeHintType[DecodeHintType["PURE_BARCODE"] = 1] = "PURE_BARCODE"; /*(Void.class)*/
    /**
     * Image is known to be of one of a few possible formats.
     * Maps to a {@link List} of {@link BarcodeFormat}s.
     */
    DecodeHintType[DecodeHintType["POSSIBLE_FORMATS"] = 2] = "POSSIBLE_FORMATS"; /*(List.class)*/
    /**
     * Spend more time to try to find a barcode; optimize for accuracy, not speed.
     * Doesn't matter what it maps to; use {@link Boolean#TRUE}.
     */
    DecodeHintType[DecodeHintType["TRY_HARDER"] = 3] = "TRY_HARDER"; /*(Void.class)*/
    /**
     * Specifies what character encoding to use when decoding, where applicable (type String)
     */
    DecodeHintType[DecodeHintType["CHARACTER_SET"] = 4] = "CHARACTER_SET"; /*(String.class)*/
    /**
     * Allowed lengths of encoded data -- reject anything else. Maps to an {@code Int32Array}.
     */
    DecodeHintType[DecodeHintType["ALLOWED_LENGTHS"] = 5] = "ALLOWED_LENGTHS"; /*(Int32Array.class)*/
    /**
     * Assume Code 39 codes employ a check digit. Doesn't matter what it maps to;
     * use {@link Boolean#TRUE}.
     */
    DecodeHintType[DecodeHintType["ASSUME_CODE_39_CHECK_DIGIT"] = 6] = "ASSUME_CODE_39_CHECK_DIGIT"; /*(Void.class)*/
    /**
     * Assume the barcode is being processed as a GS1 barcode, and modify behavior as needed.
     * For example this affects FNC1 handling for Code 128 (aka GS1-128). Doesn't matter what it maps to;
     * use {@link Boolean#TRUE}.
     */
    DecodeHintType[DecodeHintType["ASSUME_GS1"] = 7] = "ASSUME_GS1"; /*(Void.class)*/
    /**
     * If true, return the start and end digits in a Codabar barcode instead of stripping them. They
     * are alpha, whereas the rest are numeric. By default, they are stripped, but this causes them
     * to not be. Doesn't matter what it maps to; use {@link Boolean#TRUE}.
     */
    DecodeHintType[DecodeHintType["RETURN_CODABAR_START_END"] = 8] = "RETURN_CODABAR_START_END"; /*(Void.class)*/
    /**
     * The caller needs to be notified via callback when a possible {@link ResultPoint}
     * is found. Maps to a {@link ResultPointCallback}.
     */
    DecodeHintType[DecodeHintType["NEED_RESULT_POINT_CALLBACK"] = 9] = "NEED_RESULT_POINT_CALLBACK"; /*(ResultPointCallback.class)*/
    /**
     * Allowed extension lengths for EAN or UPC barcodes. Other formats will ignore this.
     * Maps to an {@code Int32Array} of the allowed extension lengths, for example [2], [5], or [2, 5].
     * If it is optional to have an extension, do not set this hint. If this is set,
     * and a UPC or EAN barcode is found but an extension is not, then no result will be returned
     * at all.
     */
    DecodeHintType[DecodeHintType["ALLOWED_EAN_EXTENSIONS"] = 10] = "ALLOWED_EAN_EXTENSIONS"; /*(Int32Array.class)*/
    // End of enumeration values.
    /**
     * Data type the hint is expecting.
     * Among the possible values the {@link Void} stands out as being used for
     * hints that do not expect a value to be supplied (flag hints). Such hints
     * will possibly have their value ignored, or replaced by a
     * {@link Boolean#TRUE}. Hint suppliers should probably use
     * {@link Boolean#TRUE} as directed by the actual hint documentation.
     */
    // private valueType: Class<?>
    // DecodeHintType(valueType: Class<?>) {
    //   this.valueType = valueType
    // }
    // public getValueType(): Class<?> {
    //   return valueType
    // }
})(DecodeHintType || (DecodeHintType = {}));
exports.default = DecodeHintType;
//# sourceMappingURL=DecodeHintType.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/EncodeHintType.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/EncodeHintType.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing {*/
/**
 * These are a set of hints that you may pass to Writers to specify their behavior.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 */
var EncodeHintType;
(function (EncodeHintType) {
    /**
     * Specifies what degree of error correction to use, for example in QR Codes.
     * Type depends on the encoder. For example for QR codes it's type
     * {@link com.google.zxing.qrcode.decoder.ErrorCorrectionLevel ErrorCorrectionLevel}.
     * For Aztec it is of type {@link Integer}, representing the minimal percentage of error correction words.
     * For PDF417 it is of type {@link Integer}, valid values being 0 to 8.
     * In all cases, it can also be a {@link String} representation of the desired value as well.
     * Note: an Aztec symbol should have a minimum of 25% EC words.
     */
    EncodeHintType[EncodeHintType["ERROR_CORRECTION"] = 0] = "ERROR_CORRECTION";
    /**
     * Specifies what character encoding to use where applicable (type {@link String})
     */
    EncodeHintType[EncodeHintType["CHARACTER_SET"] = 1] = "CHARACTER_SET";
    /**
     * Specifies the matrix shape for Data Matrix (type {@link com.google.zxing.datamatrix.encoder.SymbolShapeHint})
     */
    EncodeHintType[EncodeHintType["DATA_MATRIX_SHAPE"] = 2] = "DATA_MATRIX_SHAPE";
    /**
     * Specifies a minimum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.
     *
     * @deprecated use width/height params in
     * {@link com.google.zxing.datamatrix.DataMatrixWriter#encode(String, BarcodeFormat, int, int)}
     */
    /*@Deprecated*/
    EncodeHintType[EncodeHintType["MIN_SIZE"] = 3] = "MIN_SIZE";
    /**
     * Specifies a maximum barcode size (type {@link Dimension}). Only applicable to Data Matrix now.
     *
     * @deprecated without replacement
     */
    /*@Deprecated*/
    EncodeHintType[EncodeHintType["MAX_SIZE"] = 4] = "MAX_SIZE";
    /**
     * Specifies margin, in pixels, to use when generating the barcode. The meaning can vary
     * by format; for example it controls margin before and after the barcode horizontally for
     * most 1D formats. (Type {@link Integer}, or {@link String} representation of the integer value).
     */
    EncodeHintType[EncodeHintType["MARGIN"] = 5] = "MARGIN";
    /**
     * Specifies whether to use compact mode for PDF417 (type {@link Boolean}, or "true" or "false"
     * {@link String} value).
     */
    EncodeHintType[EncodeHintType["PDF417_COMPACT"] = 6] = "PDF417_COMPACT";
    /**
     * Specifies what compaction mode to use for PDF417 (type
     * {@link com.google.zxing.pdf417.encoder.Compaction Compaction} or {@link String} value of one of its
     * enum values).
     */
    EncodeHintType[EncodeHintType["PDF417_COMPACTION"] = 7] = "PDF417_COMPACTION";
    /**
     * Specifies the minimum and maximum number of rows and columns for PDF417 (type
     * {@link com.google.zxing.pdf417.encoder.Dimensions Dimensions}).
     */
    EncodeHintType[EncodeHintType["PDF417_DIMENSIONS"] = 8] = "PDF417_DIMENSIONS";
    /**
     * Specifies the required number of layers for an Aztec code.
     * A negative number (-1, -2, -3, -4) specifies a compact Aztec code.
     * 0 indicates to use the minimum number of layers (the default).
     * A positive number (1, 2, .. 32) specifies a normal (non-compact) Aztec code.
     * (Type {@link Integer}, or {@link String} representation of the integer value).
     */
    EncodeHintType[EncodeHintType["AZTEC_LAYERS"] = 9] = "AZTEC_LAYERS";
    /**
     * Specifies the exact version of QR code to be encoded.
     * (Type {@link Integer}, or {@link String} representation of the integer value).
     */
    EncodeHintType[EncodeHintType["QR_VERSION"] = 10] = "QR_VERSION";
})(EncodeHintType || (EncodeHintType = {}));
exports.default = EncodeHintType;
//# sourceMappingURL=EncodeHintType.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/Exception.js":
/*!************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/Exception.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ts_custom_error_1 = __webpack_require__(/*! ts-custom-error */ "./node_modules/ts-custom-error/dist/custom-error.mjs");
/**
 * Custom Error class of type Exception.
 */
var Exception = /** @class */ (function (_super) {
    __extends(Exception, _super);
    /**
     * Allows Exception to be constructed directly
     * with some message and prototype definition.
     */
    function Exception(message) {
        if (message === void 0) { message = undefined; }
        var _this = _super.call(this, message) || this;
        _this.message = message;
        return _this;
    }
    return Exception;
}(ts_custom_error_1.CustomError));
exports.default = Exception;
//# sourceMappingURL=Exception.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/FormatException.js":
/*!******************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/FormatException.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var FormatException = /** @class */ (function (_super) {
    __extends(FormatException, _super);
    function FormatException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FormatException.getFormatInstance = function () {
        return new FormatException();
    };
    return FormatException;
}(Exception_1.default));
exports.default = FormatException;
//# sourceMappingURL=FormatException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var IllegalArgumentException = /** @class */ (function (_super) {
    __extends(IllegalArgumentException, _super);
    function IllegalArgumentException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IllegalArgumentException;
}(Exception_1.default));
exports.default = IllegalArgumentException;
//# sourceMappingURL=IllegalArgumentException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/IllegalStateException.js":
/*!************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/IllegalStateException.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var IllegalStateException = /** @class */ (function (_super) {
    __extends(IllegalStateException, _super);
    function IllegalStateException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IllegalStateException;
}(Exception_1.default));
exports.default = IllegalStateException;
//# sourceMappingURL=IllegalStateException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/IndexOutOfBoundsException.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/IndexOutOfBoundsException.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var IndexOutOfBoundsException = /** @class */ (function (_super) {
    __extends(IndexOutOfBoundsException, _super);
    function IndexOutOfBoundsException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return IndexOutOfBoundsException;
}(Exception_1.default));
exports.default = IndexOutOfBoundsException;
//# sourceMappingURL=IndexOutOfBoundsException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/InvertedLuminanceSource.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/InvertedLuminanceSource.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var LuminanceSource_1 = __webpack_require__(/*! ./LuminanceSource */ "./node_modules/@zxing/library/esm5/core/LuminanceSource.js");
/*namespace com.google.zxing {*/
/**
 * A wrapper implementation of {@link LuminanceSource} which inverts the luminances it returns -- black becomes
 * white and vice versa, and each value becomes (255-value).
 *
 * @author Sean Owen
 */
var InvertedLuminanceSource = /** @class */ (function (_super) {
    __extends(InvertedLuminanceSource, _super);
    function InvertedLuminanceSource(delegate) {
        var _this = _super.call(this, delegate.getWidth(), delegate.getHeight()) || this;
        _this.delegate = delegate;
        return _this;
    }
    /*@Override*/
    InvertedLuminanceSource.prototype.getRow = function (y /*int*/, row) {
        var sourceRow = this.delegate.getRow(y, row);
        var width = this.getWidth();
        for (var i = 0; i < width; i++) {
            sourceRow[i] = /*(byte)*/ (255 - (sourceRow[i] & 0xFF));
        }
        return sourceRow;
    };
    /*@Override*/
    InvertedLuminanceSource.prototype.getMatrix = function () {
        var matrix = this.delegate.getMatrix();
        var length = this.getWidth() * this.getHeight();
        var invertedMatrix = new Uint8ClampedArray(length);
        for (var i = 0; i < length; i++) {
            invertedMatrix[i] = /*(byte)*/ (255 - (matrix[i] & 0xFF));
        }
        return invertedMatrix;
    };
    /*@Override*/
    InvertedLuminanceSource.prototype.isCropSupported = function () {
        return this.delegate.isCropSupported();
    };
    /*@Override*/
    InvertedLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));
    };
    /*@Override*/
    InvertedLuminanceSource.prototype.isRotateSupported = function () {
        return this.delegate.isRotateSupported();
    };
    /**
     * @return original delegate {@link LuminanceSource} since invert undoes itself
     */
    /*@Override*/
    InvertedLuminanceSource.prototype.invert = function () {
        return this.delegate;
    };
    /*@Override*/
    InvertedLuminanceSource.prototype.rotateCounterClockwise = function () {
        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());
    };
    /*@Override*/
    InvertedLuminanceSource.prototype.rotateCounterClockwise45 = function () {
        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());
    };
    return InvertedLuminanceSource;
}(LuminanceSource_1.default));
exports.default = InvertedLuminanceSource;
//# sourceMappingURL=InvertedLuminanceSource.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/LuminanceSource.js":
/*!******************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/LuminanceSource.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var StringBuilder_1 = __webpack_require__(/*! ./util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var UnsupportedOperationException_1 = __webpack_require__(/*! ./UnsupportedOperationException */ "./node_modules/@zxing/library/esm5/core/UnsupportedOperationException.js");
/*namespace com.google.zxing {*/
/**
 * The purpose of this class hierarchy is to abstract different bitmap implementations across
 * platforms into a standard interface for requesting greyscale luminance values. The interface
 * only provides immutable methods; therefore crop and rotation create copies. This is to ensure
 * that one Reader does not modify the original luminance source and leave it in an unknown state
 * for other Readers in the chain.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 */
var LuminanceSource = /** @class */ (function () {
    function LuminanceSource(width /*int*/, height /*int*/) {
        this.width = width;
        this.height = height;
    }
    /**
     * @return The width of the bitmap.
     */
    LuminanceSource.prototype.getWidth = function () {
        return this.width;
    };
    /**
     * @return The height of the bitmap.
     */
    LuminanceSource.prototype.getHeight = function () {
        return this.height;
    };
    /**
     * @return Whether this subclass supports cropping.
     */
    LuminanceSource.prototype.isCropSupported = function () {
        return false;
    };
    /**
     * Returns a new object with cropped image data. Implementations may keep a reference to the
     * original data rather than a copy. Only callable if isCropSupported() is true.
     *
     * @param left The left coordinate, which must be in [0,getWidth())
     * @param top The top coordinate, which must be in [0,getHeight())
     * @param width The width of the rectangle to crop.
     * @param height The height of the rectangle to crop.
     * @return A cropped version of this object.
     */
    LuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        throw new UnsupportedOperationException_1.default('This luminance source does not support cropping.');
    };
    /**
     * @return Whether this subclass supports counter-clockwise rotation.
     */
    LuminanceSource.prototype.isRotateSupported = function () {
        return false;
    };
    /**
     * Returns a new object with rotated image data by 90 degrees counterclockwise.
     * Only callable if {@link #isRotateSupported()} is true.
     *
     * @return A rotated version of this object.
     */
    LuminanceSource.prototype.rotateCounterClockwise = function () {
        throw new UnsupportedOperationException_1.default('This luminance source does not support rotation by 90 degrees.');
    };
    /**
     * Returns a new object with rotated image data by 45 degrees counterclockwise.
     * Only callable if {@link #isRotateSupported()} is true.
     *
     * @return A rotated version of this object.
     */
    LuminanceSource.prototype.rotateCounterClockwise45 = function () {
        throw new UnsupportedOperationException_1.default('This luminance source does not support rotation by 45 degrees.');
    };
    /*@Override*/
    LuminanceSource.prototype.toString = function () {
        var row = new Uint8ClampedArray(this.width);
        var result = new StringBuilder_1.default();
        for (var y = 0; y < this.height; y++) {
            var sourceRow = this.getRow(y, row);
            for (var x = 0; x < this.width; x++) {
                var luminance = sourceRow[x] & 0xFF;
                var c = void 0;
                if (luminance < 0x40) {
                    c = '#';
                }
                else if (luminance < 0x80) {
                    c = '+';
                }
                else if (luminance < 0xC0) {
                    c = '.';
                }
                else {
                    c = ' ';
                }
                result.append(c);
            }
            result.append('\n');
        }
        return result.toString();
    };
    return LuminanceSource;
}());
exports.default = LuminanceSource;
//# sourceMappingURL=LuminanceSource.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/MultiFormatReader.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/MultiFormatReader.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var DecodeHintType_1 = __webpack_require__(/*! ./DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var BarcodeFormat_1 = __webpack_require__(/*! ./BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var QRCodeReader_1 = __webpack_require__(/*! ./qrcode/QRCodeReader */ "./node_modules/@zxing/library/esm5/core/qrcode/QRCodeReader.js");
var AztecReader_1 = __webpack_require__(/*! ./aztec/AztecReader */ "./node_modules/@zxing/library/esm5/core/aztec/AztecReader.js");
var MultiFormatOneDReader_1 = __webpack_require__(/*! ./oned/MultiFormatOneDReader */ "./node_modules/@zxing/library/esm5/core/oned/MultiFormatOneDReader.js");
var DataMatrixReader_1 = __webpack_require__(/*! ./datamatrix/DataMatrixReader */ "./node_modules/@zxing/library/esm5/core/datamatrix/DataMatrixReader.js");
var NotFoundException_1 = __webpack_require__(/*! ./NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var PDF417Reader_1 = __webpack_require__(/*! ./pdf417/PDF417Reader */ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417Reader.js");
var ReaderException_1 = __webpack_require__(/*! ./ReaderException */ "./node_modules/@zxing/library/esm5/core/ReaderException.js");
/*namespace com.google.zxing {*/
/**
 * MultiFormatReader is a convenience class and the main entry point into the library for most uses.
 * By default it attempts to decode all barcode formats that the library supports. Optionally, you
 * can provide a hints object to request different behavior, for example only decoding QR codes.
 *
 * @author Sean Owen
 * @author dswitkin@google.com (Daniel Switkin)
 */
var MultiFormatReader = /** @class */ (function () {
    function MultiFormatReader() {
    }
    /**
     * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it
     * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.
     * Use setHints() followed by decodeWithState() for continuous scan applications.
     *
     * @param image The pixel data to decode
     * @return The contents of the image
     *
     * @throws NotFoundException Any errors which occurred
     */
    /*@Override*/
    // public decode(image: BinaryBitmap): Result {
    //   setHints(null)
    //   return decodeInternal(image)
    // }
    /**
     * Decode an image using the hints provided. Does not honor existing state.
     *
     * @param image The pixel data to decode
     * @param hints The hints to use, clearing the previous state.
     * @return The contents of the image
     *
     * @throws NotFoundException Any errors which occurred
     */
    /*@Override*/
    MultiFormatReader.prototype.decode = function (image, hints) {
        this.setHints(hints);
        return this.decodeInternal(image);
    };
    /**
     * Decode an image using the state set up by calling setHints() previously. Continuous scan
     * clients will get a <b>large</b> speed increase by using this instead of decode().
     *
     * @param image The pixel data to decode
     * @return The contents of the image
     *
     * @throws NotFoundException Any errors which occurred
     */
    MultiFormatReader.prototype.decodeWithState = function (image) {
        // Make sure to set up the default state so we don't crash
        if (this.readers === null || this.readers === undefined) {
            this.setHints(null);
        }
        return this.decodeInternal(image);
    };
    /**
     * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls
     * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This
     * is important for performance in continuous scan clients.
     *
     * @param hints The set of hints to use for subsequent calls to decode(image)
     */
    MultiFormatReader.prototype.setHints = function (hints) {
        this.hints = hints;
        var tryHarder = hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType_1.default.TRY_HARDER);
        /*@SuppressWarnings("unchecked")*/
        var formats = hints === null || hints === undefined ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);
        var readers = new Array();
        if (formats !== null && formats !== undefined) {
            var addOneDReader = formats.some(function (f) {
                return f === BarcodeFormat_1.default.UPC_A ||
                    f === BarcodeFormat_1.default.UPC_E ||
                    f === BarcodeFormat_1.default.EAN_13 ||
                    f === BarcodeFormat_1.default.EAN_8 ||
                    f === BarcodeFormat_1.default.CODABAR ||
                    f === BarcodeFormat_1.default.CODE_39 ||
                    f === BarcodeFormat_1.default.CODE_93 ||
                    f === BarcodeFormat_1.default.CODE_128 ||
                    f === BarcodeFormat_1.default.ITF ||
                    f === BarcodeFormat_1.default.RSS_14 ||
                    f === BarcodeFormat_1.default.RSS_EXPANDED;
            });
            // Put 1D readers upfront in "normal" mode
            // TYPESCRIPTPORT: TODO: uncomment below as they are ported
            if (addOneDReader && !tryHarder) {
                readers.push(new MultiFormatOneDReader_1.default(hints));
            }
            if (formats.includes(BarcodeFormat_1.default.QR_CODE)) {
                readers.push(new QRCodeReader_1.default());
            }
            if (formats.includes(BarcodeFormat_1.default.DATA_MATRIX)) {
                readers.push(new DataMatrixReader_1.default());
            }
            if (formats.includes(BarcodeFormat_1.default.AZTEC)) {
                readers.push(new AztecReader_1.default());
            }
            if (formats.includes(BarcodeFormat_1.default.PDF_417)) {
                readers.push(new PDF417Reader_1.default());
            }
            // if (formats.includes(BarcodeFormat.MAXICODE)) {
            //    readers.push(new MaxiCodeReader())
            // }
            // At end in "try harder" mode
            if (addOneDReader && tryHarder) {
                readers.push(new MultiFormatOneDReader_1.default(hints));
            }
        }
        if (readers.length === 0) {
            if (!tryHarder) {
                readers.push(new MultiFormatOneDReader_1.default(hints));
            }
            readers.push(new QRCodeReader_1.default());
            readers.push(new DataMatrixReader_1.default());
            readers.push(new AztecReader_1.default());
            readers.push(new PDF417Reader_1.default());
            // readers.push(new MaxiCodeReader())
            if (tryHarder) {
                readers.push(new MultiFormatOneDReader_1.default(hints));
            }
        }
        this.readers = readers; // .toArray(new Reader[readers.size()])
    };
    /*@Override*/
    MultiFormatReader.prototype.reset = function () {
        var e_1, _a;
        if (this.readers !== null) {
            try {
                for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var reader = _c.value;
                    reader.reset();
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    };
    /**
     * @throws NotFoundException
     */
    MultiFormatReader.prototype.decodeInternal = function (image) {
        var e_2, _a;
        if (this.readers === null) {
            throw new ReaderException_1.default('No readers where selected, nothing can be read.');
        }
        try {
            for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var reader = _c.value;
                // Trying to decode with ${reader} reader.
                try {
                    return reader.decode(image, this.hints);
                }
                catch (ex) {
                    if (ex instanceof ReaderException_1.default) {
                        continue;
                    }
                    // Bad Exception.
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        throw new NotFoundException_1.default('No MultiFormat Readers were able to detect the code.');
    };
    return MultiFormatReader;
}());
exports.default = MultiFormatReader;
//# sourceMappingURL=MultiFormatReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/MultiFormatWriter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/MultiFormatWriter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// import DataMatrixWriter from './datamatrix/DataMatrixWriter'
// import CodaBarWriter from './oned/CodaBarWriter'
// import Code128Writer from './oned/Code128Writer'
// import Code39Writer from './oned/Code39Writer'
// import Code93Writer from './oned/Code93Writer'
// import EAN13Writer from './oned/EAN13Writer'
// import EAN8Writer from './oned/EAN8Writer'
// import ITFWriter from './oned/ITFWriter'
// import UPCAWriter from './oned/UPCAWriter'
// import UPCEWriter from './oned/UPCEWriter'
// import PDF417Writer from './pdf417/PDF417Writer'
var QRCodeWriter_1 = __webpack_require__(/*! ./qrcode/QRCodeWriter */ "./node_modules/@zxing/library/esm5/core/qrcode/QRCodeWriter.js");
var BarcodeFormat_1 = __webpack_require__(/*! ./BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ./IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/*import java.util.Map;*/
/**
 * This is a factory class which finds the appropriate Writer subclass for the BarcodeFormat
 * requested and encodes the barcode with the supplied contents.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 */
var MultiFormatWriter = /** @class */ (function () {
    function MultiFormatWriter() {
    }
    /*@Override*/
    // public encode(contents: string,
    //                         format: BarcodeFormat,
    //                         width: number /*int*/,
    //                         height: number /*int*/): BitMatrix /*throws WriterException */ {
    //   return encode(contents, format, width, height, null)
    // }
    /*@Override*/
    MultiFormatWriter.prototype.encode = function (contents, format, width /*int*/, height /*int*/, hints) {
        var writer;
        switch (format) {
            // case BarcodeFormat.EAN_8:
            //   writer = new EAN8Writer()
            //   break
            // case BarcodeFormat.UPC_E:
            //   writer = new UPCEWriter()
            //   break
            // case BarcodeFormat.EAN_13:
            //   writer = new EAN13Writer()
            //   break
            // case BarcodeFormat.UPC_A:
            //   writer = new UPCAWriter()
            //   break
            case BarcodeFormat_1.default.QR_CODE:
                writer = new QRCodeWriter_1.default();
                break;
            // case BarcodeFormat.CODE_39:
            //   writer = new Code39Writer()
            //   break
            // case BarcodeFormat.CODE_93:
            //   writer = new Code93Writer()
            //   break
            // case BarcodeFormat.CODE_128:
            //   writer = new Code128Writer()
            //   break
            // case BarcodeFormat.ITF:
            //   writer = new ITFWriter()
            //   break
            // case BarcodeFormat.PDF_417:
            //   writer = new PDF417Writer()
            //   break
            // case BarcodeFormat.CODABAR:
            //   writer = new CodaBarWriter()
            //   break
            // case BarcodeFormat.DATA_MATRIX:
            //   writer = new DataMatrixWriter()
            //   break
            // case BarcodeFormat.AZTEC:
            //   writer = new AztecWriter()
            //   break
            default:
                throw new IllegalArgumentException_1.default('No encoder available for format ' + format);
        }
        return writer.encode(contents, format, width, height, hints);
    };
    return MultiFormatWriter;
}());
exports.default = MultiFormatWriter;
//# sourceMappingURL=MultiFormatWriter.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/NotFoundException.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/NotFoundException.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var NotFoundException = /** @class */ (function (_super) {
    __extends(NotFoundException, _super);
    function NotFoundException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NotFoundException.getNotFoundInstance = function () {
        return new NotFoundException();
    };
    return NotFoundException;
}(Exception_1.default));
exports.default = NotFoundException;
//# sourceMappingURL=NotFoundException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/NullPointerException.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/NullPointerException.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var NullPointerException = /** @class */ (function (_super) {
    __extends(NullPointerException, _super);
    function NullPointerException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NullPointerException;
}(Exception_1.default));
exports.default = NullPointerException;
//# sourceMappingURL=NullPointerException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/OutOfMemoryError.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/OutOfMemoryError.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var OutOfMemoryError = /** @class */ (function (_super) {
    __extends(OutOfMemoryError, _super);
    function OutOfMemoryError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return OutOfMemoryError;
}(Exception_1.default));
exports.default = OutOfMemoryError;
//# sourceMappingURL=OutOfMemoryError.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/PlanarYUVLuminanceSource.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/PlanarYUVLuminanceSource.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing {*/
var System_1 = __webpack_require__(/*! ./util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var LuminanceSource_1 = __webpack_require__(/*! ./LuminanceSource */ "./node_modules/@zxing/library/esm5/core/LuminanceSource.js");
var InvertedLuminanceSource_1 = __webpack_require__(/*! ./InvertedLuminanceSource */ "./node_modules/@zxing/library/esm5/core/InvertedLuminanceSource.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ./IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * This object extends LuminanceSource around an array of YUV data returned from the camera driver,
 * with the option to crop to a rectangle within the full data. This can be used to exclude
 * superfluous pixels around the perimeter and speed up decoding.
 *
 * It works for any pixel format where the Y channel is planar and appears first, including
 * YCbCr_420_SP and YCbCr_422_SP.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 */
var PlanarYUVLuminanceSource = /** @class */ (function (_super) {
    __extends(PlanarYUVLuminanceSource, _super);
    function PlanarYUVLuminanceSource(yuvData, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/, width /*int*/, height /*int*/, reverseHorizontal) {
        var _this = _super.call(this, width, height) || this;
        _this.yuvData = yuvData;
        _this.dataWidth = dataWidth;
        _this.dataHeight = dataHeight;
        _this.left = left;
        _this.top = top;
        if (left + width > dataWidth || top + height > dataHeight) {
            throw new IllegalArgumentException_1.default('Crop rectangle does not fit within image data.');
        }
        if (reverseHorizontal) {
            _this.reverseHorizontal(width, height);
        }
        return _this;
    }
    /*@Override*/
    PlanarYUVLuminanceSource.prototype.getRow = function (y /*int*/, row) {
        if (y < 0 || y >= this.getHeight()) {
            throw new IllegalArgumentException_1.default('Requested row is outside the image: ' + y);
        }
        var width = this.getWidth();
        if (row === null || row === undefined || row.length < width) {
            row = new Uint8ClampedArray(width);
        }
        var offset = (y + this.top) * this.dataWidth + this.left;
        System_1.default.arraycopy(this.yuvData, offset, row, 0, width);
        return row;
    };
    /*@Override*/
    PlanarYUVLuminanceSource.prototype.getMatrix = function () {
        var width = this.getWidth();
        var height = this.getHeight();
        // If the caller asks for the entire underlying image, save the copy and give them the
        // original data. The docs specifically warn that result.length must be ignored.
        if (width === this.dataWidth && height === this.dataHeight) {
            return this.yuvData;
        }
        var area = width * height;
        var matrix = new Uint8ClampedArray(area);
        var inputOffset = this.top * this.dataWidth + this.left;
        // If the width matches the full width of the underlying data, perform a single copy.
        if (width === this.dataWidth) {
            System_1.default.arraycopy(this.yuvData, inputOffset, matrix, 0, area);
            return matrix;
        }
        // Otherwise copy one cropped row at a time.
        for (var y = 0; y < height; y++) {
            var outputOffset = y * width;
            System_1.default.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);
            inputOffset += this.dataWidth;
        }
        return matrix;
    };
    /*@Override*/
    PlanarYUVLuminanceSource.prototype.isCropSupported = function () {
        return true;
    };
    /*@Override*/
    PlanarYUVLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);
    };
    PlanarYUVLuminanceSource.prototype.renderThumbnail = function () {
        var width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        var height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        var pixels = new Int32Array(width * height);
        var yuv = this.yuvData;
        var inputOffset = this.top * this.dataWidth + this.left;
        for (var y = 0; y < height; y++) {
            var outputOffset = y * width;
            for (var x = 0; x < width; x++) {
                var grey = yuv[inputOffset + x * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 0xff;
                pixels[outputOffset + x] = 0xFF000000 | (grey * 0x00010101);
            }
            inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        }
        return pixels;
    };
    /**
     * @return width of image from {@link #renderThumbnail()}
     */
    PlanarYUVLuminanceSource.prototype.getThumbnailWidth = function () {
        return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
    };
    /**
     * @return height of image from {@link #renderThumbnail()}
     */
    PlanarYUVLuminanceSource.prototype.getThumbnailHeight = function () {
        return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
    };
    PlanarYUVLuminanceSource.prototype.reverseHorizontal = function (width /*int*/, height /*int*/) {
        var yuvData = this.yuvData;
        for (var y = 0, rowStart = this.top * this.dataWidth + this.left; y < height; y++, rowStart += this.dataWidth) {
            var middle = rowStart + width / 2;
            for (var x1 = rowStart, x2 = rowStart + width - 1; x1 < middle; x1++, x2--) {
                var temp = yuvData[x1];
                yuvData[x1] = yuvData[x2];
                yuvData[x2] = temp;
            }
        }
    };
    PlanarYUVLuminanceSource.prototype.invert = function () {
        return new InvertedLuminanceSource_1.default(this);
    };
    PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;
    return PlanarYUVLuminanceSource;
}(LuminanceSource_1.default));
exports.default = PlanarYUVLuminanceSource;
//# sourceMappingURL=PlanarYUVLuminanceSource.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/RGBLuminanceSource.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/RGBLuminanceSource.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing {*/
__webpack_require__(/*! ./InvertedLuminanceSource */ "./node_modules/@zxing/library/esm5/core/InvertedLuminanceSource.js"); // required because of circular dependencies between LuminanceSource and InvertedLuminanceSource
var InvertedLuminanceSource_1 = __webpack_require__(/*! ./InvertedLuminanceSource */ "./node_modules/@zxing/library/esm5/core/InvertedLuminanceSource.js");
var LuminanceSource_1 = __webpack_require__(/*! ./LuminanceSource */ "./node_modules/@zxing/library/esm5/core/LuminanceSource.js");
var System_1 = __webpack_require__(/*! ./util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ./IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * This class is used to help decode images from files which arrive as RGB data from
 * an ARGB pixel array. It does not support rotation.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 * @author Betaminos
 */
var RGBLuminanceSource = /** @class */ (function (_super) {
    __extends(RGBLuminanceSource, _super);
    function RGBLuminanceSource(luminances, width /*int*/, height /*int*/, dataWidth /*int*/, dataHeight /*int*/, left /*int*/, top /*int*/) {
        var _this = _super.call(this, width, height) || this;
        _this.dataWidth = dataWidth;
        _this.dataHeight = dataHeight;
        _this.left = left;
        _this.top = top;
        if (luminances.BYTES_PER_ELEMENT === 4) { // Int32Array
            var size = width * height;
            var luminancesUint8Array = new Uint8ClampedArray(size);
            for (var offset = 0; offset < size; offset++) {
                var pixel = luminances[offset];
                var r = (pixel >> 16) & 0xff; // red
                var g2 = (pixel >> 7) & 0x1fe; // 2 * green
                var b = pixel & 0xff; // blue
                // Calculate green-favouring average cheaply
                luminancesUint8Array[offset] = /*(byte) */ ((r + g2 + b) / 4) & 0xFF;
            }
            _this.luminances = luminancesUint8Array;
        }
        else {
            _this.luminances = luminances;
        }
        if (undefined === dataWidth) {
            _this.dataWidth = width;
        }
        if (undefined === dataHeight) {
            _this.dataHeight = height;
        }
        if (undefined === left) {
            _this.left = 0;
        }
        if (undefined === top) {
            _this.top = 0;
        }
        if (_this.left + width > _this.dataWidth || _this.top + height > _this.dataHeight) {
            throw new IllegalArgumentException_1.default('Crop rectangle does not fit within image data.');
        }
        return _this;
    }
    /*@Override*/
    RGBLuminanceSource.prototype.getRow = function (y /*int*/, row) {
        if (y < 0 || y >= this.getHeight()) {
            throw new IllegalArgumentException_1.default('Requested row is outside the image: ' + y);
        }
        var width = this.getWidth();
        if (row === null || row === undefined || row.length < width) {
            row = new Uint8ClampedArray(width);
        }
        var offset = (y + this.top) * this.dataWidth + this.left;
        System_1.default.arraycopy(this.luminances, offset, row, 0, width);
        return row;
    };
    /*@Override*/
    RGBLuminanceSource.prototype.getMatrix = function () {
        var width = this.getWidth();
        var height = this.getHeight();
        // If the caller asks for the entire underlying image, save the copy and give them the
        // original data. The docs specifically warn that result.length must be ignored.
        if (width === this.dataWidth && height === this.dataHeight) {
            return this.luminances;
        }
        var area = width * height;
        var matrix = new Uint8ClampedArray(area);
        var inputOffset = this.top * this.dataWidth + this.left;
        // If the width matches the full width of the underlying data, perform a single copy.
        if (width === this.dataWidth) {
            System_1.default.arraycopy(this.luminances, inputOffset, matrix, 0, area);
            return matrix;
        }
        // Otherwise copy one cropped row at a time.
        for (var y = 0; y < height; y++) {
            var outputOffset = y * width;
            System_1.default.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);
            inputOffset += this.dataWidth;
        }
        return matrix;
    };
    /*@Override*/
    RGBLuminanceSource.prototype.isCropSupported = function () {
        return true;
    };
    /*@Override*/
    RGBLuminanceSource.prototype.crop = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);
    };
    RGBLuminanceSource.prototype.invert = function () {
        return new InvertedLuminanceSource_1.default(this);
    };
    return RGBLuminanceSource;
}(LuminanceSource_1.default));
exports.default = RGBLuminanceSource;
//# sourceMappingURL=RGBLuminanceSource.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/ReaderException.js":
/*!******************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/ReaderException.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var ReaderException = /** @class */ (function (_super) {
    __extends(ReaderException, _super);
    function ReaderException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ReaderException;
}(Exception_1.default));
exports.default = ReaderException;
//# sourceMappingURL=ReaderException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/ReedSolomonException.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/ReedSolomonException.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var ReedSolomonException = /** @class */ (function (_super) {
    __extends(ReedSolomonException, _super);
    function ReedSolomonException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ReedSolomonException;
}(Exception_1.default));
exports.default = ReedSolomonException;
//# sourceMappingURL=ReedSolomonException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/Result.js":
/*!*********************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/Result.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var System_1 = __webpack_require__(/*! ./util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
/**
 * <p>Encapsulates the result of decoding a barcode within an image.</p>
 *
 * @author Sean Owen
 */
var Result = /** @class */ (function () {
    // public constructor(private text: string,
    //               Uint8Array rawBytes,
    //               ResultPoconst resultPoints: Int32Array,
    //               BarcodeFormat format) {
    //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())
    // }
    // public constructor(text: string,
    //               Uint8Array rawBytes,
    //               ResultPoconst resultPoints: Int32Array,
    //               BarcodeFormat format,
    //               long timestamp) {
    //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,
    //        resultPoints, format, timestamp)
    // }
    function Result(text, rawBytes, numBits, resultPoints, format, timestamp) {
        if (numBits === void 0) { numBits = rawBytes == null ? 0 : 8 * rawBytes.length; }
        if (timestamp === void 0) { timestamp = System_1.default.currentTimeMillis(); }
        this.text = text;
        this.rawBytes = rawBytes;
        this.numBits = numBits;
        this.resultPoints = resultPoints;
        this.format = format;
        this.timestamp = timestamp;
        this.text = text;
        this.rawBytes = rawBytes;
        if (undefined === numBits || null === numBits) {
            this.numBits = (rawBytes === null || rawBytes === undefined) ? 0 : 8 * rawBytes.length;
        }
        else {
            this.numBits = numBits;
        }
        this.resultPoints = resultPoints;
        this.format = format;
        this.resultMetadata = null;
        if (undefined === timestamp || null === timestamp) {
            this.timestamp = System_1.default.currentTimeMillis();
        }
        else {
            this.timestamp = timestamp;
        }
    }
    /**
     * @return raw text encoded by the barcode
     */
    Result.prototype.getText = function () {
        return this.text;
    };
    /**
     * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}
     */
    Result.prototype.getRawBytes = function () {
        return this.rawBytes;
    };
    /**
     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
     * @since 3.3.0
     */
    Result.prototype.getNumBits = function () {
        return this.numBits;
    };
    /**
     * @return points related to the barcode in the image. These are typically points
     *         identifying finder patterns or the corners of the barcode. The exact meaning is
     *         specific to the type of barcode that was decoded.
     */
    Result.prototype.getResultPoints = function () {
        return this.resultPoints;
    };
    /**
     * @return {@link BarcodeFormat} representing the format of the barcode that was decoded
     */
    Result.prototype.getBarcodeFormat = function () {
        return this.format;
    };
    /**
     * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be
     *   {@code null}. This contains optional metadata about what was detected about the barcode,
     *   like orientation.
     */
    Result.prototype.getResultMetadata = function () {
        return this.resultMetadata;
    };
    Result.prototype.putMetadata = function (type, value) {
        if (this.resultMetadata === null) {
            this.resultMetadata = new Map();
        }
        this.resultMetadata.set(type, value);
    };
    Result.prototype.putAllMetadata = function (metadata) {
        if (metadata !== null) {
            if (this.resultMetadata === null) {
                this.resultMetadata = metadata;
            }
            else {
                this.resultMetadata = new Map(metadata);
            }
        }
    };
    Result.prototype.addResultPoints = function (newPoints) {
        var oldPoints = this.resultPoints;
        if (oldPoints === null) {
            this.resultPoints = newPoints;
        }
        else if (newPoints !== null && newPoints.length > 0) {
            var allPoints = new Array(oldPoints.length + newPoints.length);
            System_1.default.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);
            System_1.default.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);
            this.resultPoints = allPoints;
        }
    };
    Result.prototype.getTimestamp = function () {
        return this.timestamp;
    };
    /*@Override*/
    Result.prototype.toString = function () {
        return this.text;
    };
    return Result;
}());
exports.default = Result;
//# sourceMappingURL=Result.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/ResultMetadataType.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/ResultMetadataType.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing {*/
/**
 * Represents some type of metadata about the result of the decoding that the decoder
 * wishes to communicate back to the caller.
 *
 * @author Sean Owen
 */
var ResultMetadataType;
(function (ResultMetadataType) {
    /**
     * Unspecified, application-specific metadata. Maps to an unspecified {@link Object}.
     */
    ResultMetadataType[ResultMetadataType["OTHER"] = 0] = "OTHER";
    /**
     * Denotes the likely approximate orientation of the barcode in the image. This value
     * is given as degrees rotated clockwise from the normal, upright orientation.
     * For example a 1D barcode which was found by reading top-to-bottom would be
     * said to have orientation "90". This key maps to an {@link Integer} whose
     * value is in the range [0,360).
     */
    ResultMetadataType[ResultMetadataType["ORIENTATION"] = 1] = "ORIENTATION";
    /**
     * <p>2D barcode formats typically encode text, but allow for a sort of 'byte mode'
     * which is sometimes used to encode binary data. While {@link Result} makes available
     * the complete raw bytes in the barcode for these formats, it does not offer the bytes
     * from the byte segments alone.</p>
     *
     * <p>This maps to a {@link java.util.List} of byte arrays corresponding to the
     * raw bytes in the byte segments in the barcode, in order.</p>
     */
    ResultMetadataType[ResultMetadataType["BYTE_SEGMENTS"] = 2] = "BYTE_SEGMENTS";
    /**
     * Error correction level used, if applicable. The value type depends on the
     * format, but is typically a String.
     */
    ResultMetadataType[ResultMetadataType["ERROR_CORRECTION_LEVEL"] = 3] = "ERROR_CORRECTION_LEVEL";
    /**
     * For some periodicals, indicates the issue number as an {@link Integer}.
     */
    ResultMetadataType[ResultMetadataType["ISSUE_NUMBER"] = 4] = "ISSUE_NUMBER";
    /**
     * For some products, indicates the suggested retail price in the barcode as a
     * formatted {@link String}.
     */
    ResultMetadataType[ResultMetadataType["SUGGESTED_PRICE"] = 5] = "SUGGESTED_PRICE";
    /**
     * For some products, the possible country of manufacture as a {@link String} denoting the
     * ISO country code. Some map to multiple possible countries, like "US/CA".
     */
    ResultMetadataType[ResultMetadataType["POSSIBLE_COUNTRY"] = 6] = "POSSIBLE_COUNTRY";
    /**
     * For some products, the extension text
     */
    ResultMetadataType[ResultMetadataType["UPC_EAN_EXTENSION"] = 7] = "UPC_EAN_EXTENSION";
    /**
     * PDF417-specific metadata
     */
    ResultMetadataType[ResultMetadataType["PDF417_EXTRA_METADATA"] = 8] = "PDF417_EXTRA_METADATA";
    /**
     * If the code format supports structured append and the current scanned code is part of one then the
     * sequence number is given with it.
     */
    ResultMetadataType[ResultMetadataType["STRUCTURED_APPEND_SEQUENCE"] = 9] = "STRUCTURED_APPEND_SEQUENCE";
    /**
     * If the code format supports structured append and the current scanned code is part of one then the
     * parity is given with it.
     */
    ResultMetadataType[ResultMetadataType["STRUCTURED_APPEND_PARITY"] = 10] = "STRUCTURED_APPEND_PARITY";
})(ResultMetadataType || (ResultMetadataType = {}));
exports.default = ResultMetadataType;
//# sourceMappingURL=ResultMetadataType.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/ResultPoint.js":
/*!**************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/ResultPoint.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing {*/
var MathUtils_1 = __webpack_require__(/*! ./common/detector/MathUtils */ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js");
var Float_1 = __webpack_require__(/*! ./util/Float */ "./node_modules/@zxing/library/esm5/core/util/Float.js");
/**
 * <p>Encapsulates a point of interest in an image containing a barcode. Typically, this
 * would be the location of a finder pattern or the corner of the barcode, for example.</p>
 *
 * @author Sean Owen
 */
var ResultPoint = /** @class */ (function () {
    function ResultPoint(x, y) {
        this.x = x;
        this.y = y;
    }
    ResultPoint.prototype.getX = function () {
        return this.x;
    };
    ResultPoint.prototype.getY = function () {
        return this.y;
    };
    /*@Override*/
    ResultPoint.prototype.equals = function (other) {
        if (other instanceof ResultPoint) {
            var otherPoint = other;
            return this.x === otherPoint.x && this.y === otherPoint.y;
        }
        return false;
    };
    /*@Override*/
    ResultPoint.prototype.hashCode = function () {
        return 31 * Float_1.default.floatToIntBits(this.x) + Float_1.default.floatToIntBits(this.y);
    };
    /*@Override*/
    ResultPoint.prototype.toString = function () {
        return '(' + this.x + ',' + this.y + ')';
    };
    /**
     * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC
     * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.
     *
     * @param patterns array of three {@code ResultPoint} to order
     */
    ResultPoint.orderBestPatterns = function (patterns) {
        // Find distances between pattern centers
        var zeroOneDistance = this.distance(patterns[0], patterns[1]);
        var oneTwoDistance = this.distance(patterns[1], patterns[2]);
        var zeroTwoDistance = this.distance(patterns[0], patterns[2]);
        var pointA;
        var pointB;
        var pointC;
        // Assume one closest to other two is B; A and C will just be guesses at first
        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
            pointB = patterns[0];
            pointA = patterns[1];
            pointC = patterns[2];
        }
        else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
            pointB = patterns[1];
            pointA = patterns[0];
            pointC = patterns[2];
        }
        else {
            pointB = patterns[2];
            pointA = patterns[0];
            pointC = patterns[1];
        }
        // Use cross product to figure out whether A and C are correct or flipped.
        // This asks whether BC x BA has a positive z component, which is the arrangement
        // we want for A, B, C. If it's negative, then we've got it flipped around and
        // should swap A and C.
        if (this.crossProductZ(pointA, pointB, pointC) < 0.0) {
            var temp = pointA;
            pointA = pointC;
            pointC = temp;
        }
        patterns[0] = pointA;
        patterns[1] = pointB;
        patterns[2] = pointC;
    };
    /**
     * @param pattern1 first pattern
     * @param pattern2 second pattern
     * @return distance between two points
     */
    ResultPoint.distance = function (pattern1, pattern2) {
        return MathUtils_1.default.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);
    };
    /**
     * Returns the z component of the cross product between vectors BC and BA.
     */
    ResultPoint.crossProductZ = function (pointA, pointB, pointC) {
        var bX = pointB.x;
        var bY = pointB.y;
        return ((pointC.x - bX) * (pointA.y - bY)) - ((pointC.y - bY) * (pointA.x - bX));
    };
    return ResultPoint;
}());
exports.default = ResultPoint;
//# sourceMappingURL=ResultPoint.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/UnsupportedOperationException.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/UnsupportedOperationException.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var UnsupportedOperationException = /** @class */ (function (_super) {
    __extends(UnsupportedOperationException, _super);
    function UnsupportedOperationException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return UnsupportedOperationException;
}(Exception_1.default));
exports.default = UnsupportedOperationException;
//# sourceMappingURL=UnsupportedOperationException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/WriterException.js":
/*!******************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/WriterException.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Exception_1 = __webpack_require__(/*! ./Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
/**
 * Custom Error class of type Exception.
 */
var WriterException = /** @class */ (function (_super) {
    __extends(WriterException, _super);
    function WriterException() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return WriterException;
}(Exception_1.default));
exports.default = WriterException;
//# sourceMappingURL=WriterException.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/aztec/AztecDetectorResult.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/aztec/AztecDetectorResult.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2010 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var DetectorResult_1 = __webpack_require__(/*! ../common/DetectorResult */ "./node_modules/@zxing/library/esm5/core/common/DetectorResult.js");
/**
 * <p>Extends {@link DetectorResult} with more information specific to the Aztec format,
 * like the number of layers and whether it's compact.</p>
 *
 * @author Sean Owen
 */
var AztecDetectorResult = /** @class */ (function (_super) {
    __extends(AztecDetectorResult, _super);
    function AztecDetectorResult(bits, points, compact, nbDatablocks, nbLayers) {
        var _this = _super.call(this, bits, points) || this;
        _this.compact = compact;
        _this.nbDatablocks = nbDatablocks;
        _this.nbLayers = nbLayers;
        return _this;
    }
    AztecDetectorResult.prototype.getNbLayers = function () {
        return this.nbLayers;
    };
    AztecDetectorResult.prototype.getNbDatablocks = function () {
        return this.nbDatablocks;
    };
    AztecDetectorResult.prototype.isCompact = function () {
        return this.compact;
    };
    return AztecDetectorResult;
}(DetectorResult_1.default));
exports.default = AztecDetectorResult;
//# sourceMappingURL=AztecDetectorResult.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/aztec/AztecReader.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/aztec/AztecReader.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2010 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Result_1 = __webpack_require__(/*! ../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ "./node_modules/@zxing/library/esm5/core/ResultMetadataType.js");
var System_1 = __webpack_require__(/*! ../util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var Decoder_1 = __webpack_require__(/*! ./decoder/Decoder */ "./node_modules/@zxing/library/esm5/core/aztec/decoder/Decoder.js");
var Detector_1 = __webpack_require__(/*! ./detector/Detector */ "./node_modules/@zxing/library/esm5/core/aztec/detector/Detector.js");
// import java.util.List;
// import java.util.Map;
/**
 * This implementation can detect and decode Aztec codes in an image.
 *
 * @author David Olivier
 */
var AztecReader = /** @class */ (function () {
    function AztecReader() {
    }
    /**
     * Locates and decodes a Data Matrix code in an image.
     *
     * @return a String representing the content encoded by the Data Matrix code
     * @throws NotFoundException if a Data Matrix code cannot be found
     * @throws FormatException if a Data Matrix code cannot be decoded
     */
    AztecReader.prototype.decode = function (image, hints) {
        if (hints === void 0) { hints = null; }
        var exception = null;
        var detector = new Detector_1.default(image.getBlackMatrix());
        var points = null;
        var decoderResult = null;
        try {
            var detectorResult = detector.detectMirror(false);
            points = detectorResult.getPoints();
            this.reportFoundResultPoints(hints, points);
            decoderResult = new Decoder_1.default().decode(detectorResult);
        }
        catch (e) {
            exception = e;
        }
        if (decoderResult == null) {
            try {
                var detectorResult = detector.detectMirror(true);
                points = detectorResult.getPoints();
                this.reportFoundResultPoints(hints, points);
                decoderResult = new Decoder_1.default().decode(detectorResult);
            }
            catch (e) {
                if (exception != null) {
                    throw exception;
                }
                throw e;
            }
        }
        var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat_1.default.AZTEC, System_1.default.currentTimeMillis());
        var byteSegments = decoderResult.getByteSegments();
        if (byteSegments != null) {
            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);
        }
        var ecLevel = decoderResult.getECLevel();
        if (ecLevel != null) {
            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        return result;
    };
    AztecReader.prototype.reportFoundResultPoints = function (hints, points) {
        if (hints != null) {
            var rpcb_1 = hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);
            if (rpcb_1 != null) {
                points.forEach(function (point, idx, arr) {
                    rpcb_1.foundPossibleResultPoint(point);
                });
            }
        }
    };
    // @Override
    AztecReader.prototype.reset = function () {
        // do nothing
    };
    return AztecReader;
}());
exports.default = AztecReader;
//# sourceMappingURL=AztecReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/aztec/decoder/Decoder.js":
/*!************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/aztec/decoder/Decoder.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2010 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var DecoderResult_1 = __webpack_require__(/*! ../../common/DecoderResult */ "./node_modules/@zxing/library/esm5/core/common/DecoderResult.js");
var GenericGF_1 = __webpack_require__(/*! ../../common/reedsolomon/GenericGF */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGF.js");
var ReedSolomonDecoder_1 = __webpack_require__(/*! ../../common/reedsolomon/ReedSolomonDecoder */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/ReedSolomonDecoder.js");
var IllegalStateException_1 = __webpack_require__(/*! ../../IllegalStateException */ "./node_modules/@zxing/library/esm5/core/IllegalStateException.js");
var FormatException_1 = __webpack_require__(/*! ../../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
var __1 = __webpack_require__(/*! ../../.. */ "./node_modules/@zxing/library/esm5/index.js");
var Integer_1 = __webpack_require__(/*! ../../util/Integer */ "./node_modules/@zxing/library/esm5/core/util/Integer.js");
// import java.util.Arrays;
var Table;
(function (Table) {
    Table[Table["UPPER"] = 0] = "UPPER";
    Table[Table["LOWER"] = 1] = "LOWER";
    Table[Table["MIXED"] = 2] = "MIXED";
    Table[Table["DIGIT"] = 3] = "DIGIT";
    Table[Table["PUNCT"] = 4] = "PUNCT";
    Table[Table["BINARY"] = 5] = "BINARY";
})(Table || (Table = {}));
/**
 * <p>The main class which implements Aztec Code decoding -- as opposed to locating and extracting
 * the Aztec Code from an image.</p>
 *
 * @author David Olivier
 */
var Decoder = /** @class */ (function () {
    function Decoder() {
    }
    Decoder.prototype.decode = function (detectorResult) {
        this.ddata = detectorResult;
        var matrix = detectorResult.getBits();
        var rawbits = this.extractBits(matrix);
        var correctedBits = this.correctBits(rawbits);
        var rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);
        var result = Decoder.getEncodedData(correctedBits);
        var decoderResult = new DecoderResult_1.default(rawBytes, result, null, null);
        decoderResult.setNumBits(correctedBits.length);
        return decoderResult;
    };
    // This method is used for testing the high-level encoder
    Decoder.highLevelDecode = function (correctedBits) {
        return this.getEncodedData(correctedBits);
    };
    /**
     * Gets the string encoded in the aztec code bits
     *
     * @return the decoded string
     */
    Decoder.getEncodedData = function (correctedBits) {
        var endIndex = correctedBits.length;
        var latchTable = Table.UPPER; // table most recently latched to
        var shiftTable = Table.UPPER; // table to use for the next read
        var result = '';
        var index = 0;
        while (index < endIndex) {
            if (shiftTable === Table.BINARY) {
                if (endIndex - index < 5) {
                    break;
                }
                var length_1 = Decoder.readCode(correctedBits, index, 5);
                index += 5;
                if (length_1 === 0) {
                    if (endIndex - index < 11) {
                        break;
                    }
                    length_1 = Decoder.readCode(correctedBits, index, 11) + 31;
                    index += 11;
                }
                for (var charCount = 0; charCount < length_1; charCount++) {
                    if (endIndex - index < 8) {
                        index = endIndex; // Force outer loop to exit
                        break;
                    }
                    var code = Decoder.readCode(correctedBits, index, 8);
                    result += /*(char)*/ __1.StringUtils.castAsNonUtf8Char(code);
                    index += 8;
                }
                // Go back to whatever mode we had been in
                shiftTable = latchTable;
            }
            else {
                var size = shiftTable === Table.DIGIT ? 4 : 5;
                if (endIndex - index < size) {
                    break;
                }
                var code = Decoder.readCode(correctedBits, index, size);
                index += size;
                var str = Decoder.getCharacter(shiftTable, code);
                if (str.startsWith('CTRL_')) {
                    // Table changes
                    // ISO/IEC 24778:2008 prescribes ending a shift sequence in the mode from which it was invoked.
                    // That's including when that mode is a shift.
                    // Our test case dlusbs.png for issue #642 exercises that.
                    latchTable = shiftTable; // Latch the current mode, so as to return to Upper after U/S B/S
                    shiftTable = Decoder.getTable(str.charAt(5));
                    if (str.charAt(6) === 'L') {
                        latchTable = shiftTable;
                    }
                }
                else {
                    result += str;
                    // Go back to whatever mode we had been in
                    shiftTable = latchTable;
                }
            }
        }
        return result;
    };
    /**
     * gets the table corresponding to the char passed
     */
    Decoder.getTable = function (t) {
        switch (t) {
            case 'L':
                return Table.LOWER;
            case 'P':
                return Table.PUNCT;
            case 'M':
                return Table.MIXED;
            case 'D':
                return Table.DIGIT;
            case 'B':
                return Table.BINARY;
            case 'U':
            default:
                return Table.UPPER;
        }
    };
    /**
     * Gets the character (or string) corresponding to the passed code in the given table
     *
     * @param table the table used
     * @param code the code of the character
     */
    Decoder.getCharacter = function (table, code) {
        switch (table) {
            case Table.UPPER:
                return Decoder.UPPER_TABLE[code];
            case Table.LOWER:
                return Decoder.LOWER_TABLE[code];
            case Table.MIXED:
                return Decoder.MIXED_TABLE[code];
            case Table.PUNCT:
                return Decoder.PUNCT_TABLE[code];
            case Table.DIGIT:
                return Decoder.DIGIT_TABLE[code];
            default:
                // Should not reach here.
                throw new IllegalStateException_1.default('Bad table');
        }
    };
    /**
     * <p>Performs RS error correction on an array of bits.</p>
     *
     * @return the corrected array
     * @throws FormatException if the input contains too many errors
     */
    Decoder.prototype.correctBits = function (rawbits) {
        var gf;
        var codewordSize;
        if (this.ddata.getNbLayers() <= 2) {
            codewordSize = 6;
            gf = GenericGF_1.default.AZTEC_DATA_6;
        }
        else if (this.ddata.getNbLayers() <= 8) {
            codewordSize = 8;
            gf = GenericGF_1.default.AZTEC_DATA_8;
        }
        else if (this.ddata.getNbLayers() <= 22) {
            codewordSize = 10;
            gf = GenericGF_1.default.AZTEC_DATA_10;
        }
        else {
            codewordSize = 12;
            gf = GenericGF_1.default.AZTEC_DATA_12;
        }
        var numDataCodewords = this.ddata.getNbDatablocks();
        var numCodewords = rawbits.length / codewordSize;
        if (numCodewords < numDataCodewords) {
            throw new FormatException_1.default();
        }
        var offset = rawbits.length % codewordSize;
        var dataWords = new Int32Array(numCodewords);
        for (var i = 0; i < numCodewords; i++, offset += codewordSize) {
            dataWords[i] = Decoder.readCode(rawbits, offset, codewordSize);
        }
        try {
            var rsDecoder = new ReedSolomonDecoder_1.default(gf);
            rsDecoder.decode(dataWords, numCodewords - numDataCodewords);
        }
        catch (ex) {
            throw new FormatException_1.default(ex);
        }
        // Now perform the unstuffing operation.
        // First, count how many bits are going to be thrown out as stuffing
        var mask = (1 << codewordSize) - 1;
        var stuffedBits = 0;
        for (var i = 0; i < numDataCodewords; i++) {
            var dataWord = dataWords[i];
            if (dataWord === 0 || dataWord === mask) {
                throw new FormatException_1.default();
            }
            else if (dataWord === 1 || dataWord === mask - 1) {
                stuffedBits++;
            }
        }
        // Now, actually unpack the bits and remove the stuffing
        var correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);
        var index = 0;
        for (var i = 0; i < numDataCodewords; i++) {
            var dataWord = dataWords[i];
            if (dataWord === 1 || dataWord === mask - 1) {
                // next codewordSize-1 bits are all zeros or all ones
                correctedBits.fill(dataWord > 1, index, index + codewordSize - 1);
                // Arrays.fill(correctedBits, index, index + codewordSize - 1, dataWord > 1);
                index += codewordSize - 1;
            }
            else {
                for (var bit = codewordSize - 1; bit >= 0; --bit) {
                    correctedBits[index++] = (dataWord & (1 << bit)) !== 0;
                }
            }
        }
        return correctedBits;
    };
    /**
     * Gets the array of bits from an Aztec Code matrix
     *
     * @return the array of bits
     */
    Decoder.prototype.extractBits = function (matrix) {
        var compact = this.ddata.isCompact();
        var layers = this.ddata.getNbLayers();
        var baseMatrixSize = (compact ? 11 : 14) + layers * 4; // not including alignment lines
        var alignmentMap = new Int32Array(baseMatrixSize);
        var rawbits = new Array(this.totalBitsInLayer(layers, compact));
        if (compact) {
            for (var i = 0; i < alignmentMap.length; i++) {
                alignmentMap[i] = i;
            }
        }
        else {
            var matrixSize = baseMatrixSize + 1 + 2 * Integer_1.default.truncDivision((Integer_1.default.truncDivision(baseMatrixSize, 2) - 1), 15);
            var origCenter = baseMatrixSize / 2;
            var center = Integer_1.default.truncDivision(matrixSize, 2);
            for (var i = 0; i < origCenter; i++) {
                var newOffset = i + Integer_1.default.truncDivision(i, 15);
                alignmentMap[origCenter - i - 1] = center - newOffset - 1;
                alignmentMap[origCenter + i] = center + newOffset + 1;
            }
        }
        for (var i = 0, rowOffset = 0; i < layers; i++) {
            var rowSize = (layers - i) * 4 + (compact ? 9 : 12);
            // The top-left most point of this layer is <low, low> (not including alignment lines)
            var low = i * 2;
            // The bottom-right most point of this layer is <high, high> (not including alignment lines)
            var high = baseMatrixSize - 1 - low;
            // We pull bits from the two 2 x rowSize columns and two rowSize x 2 rows
            for (var j = 0; j < rowSize; j++) {
                var columnOffset = j * 2;
                for (var k = 0; k < 2; k++) {
                    // left column
                    rawbits[rowOffset + columnOffset + k] =
                        matrix.get(alignmentMap[low + k], alignmentMap[low + j]);
                    // bottom row
                    rawbits[rowOffset + 2 * rowSize + columnOffset + k] =
                        matrix.get(alignmentMap[low + j], alignmentMap[high - k]);
                    // right column
                    rawbits[rowOffset + 4 * rowSize + columnOffset + k] =
                        matrix.get(alignmentMap[high - k], alignmentMap[high - j]);
                    // top row
                    rawbits[rowOffset + 6 * rowSize + columnOffset + k] =
                        matrix.get(alignmentMap[high - j], alignmentMap[low + k]);
                }
            }
            rowOffset += rowSize * 8;
        }
        return rawbits;
    };
    /**
     * Reads a code of given length and at given index in an array of bits
     */
    Decoder.readCode = function (rawbits, startIndex, length) {
        var res = 0;
        for (var i = startIndex; i < startIndex + length; i++) {
            res <<= 1;
            if (rawbits[i]) {
                res |= 0x01;
            }
        }
        return res;
    };
    /**
     * Reads a code of length 8 in an array of bits, padding with zeros
     */
    Decoder.readByte = function (rawbits, startIndex) {
        var n = rawbits.length - startIndex;
        if (n >= 8) {
            return Decoder.readCode(rawbits, startIndex, 8);
        }
        return Decoder.readCode(rawbits, startIndex, n) << (8 - n);
    };
    /**
     * Packs a bit array into bytes, most significant bit first
     */
    Decoder.convertBoolArrayToByteArray = function (boolArr) {
        var byteArr = new Uint8Array((boolArr.length + 7) / 8);
        for (var i = 0; i < byteArr.length; i++) {
            byteArr[i] = Decoder.readByte(boolArr, 8 * i);
        }
        return byteArr;
    };
    Decoder.prototype.totalBitsInLayer = function (layers, compact) {
        return ((compact ? 88 : 112) + 16 * layers) * layers;
    };
    Decoder.UPPER_TABLE = [
        'CTRL_PS', ' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'CTRL_LL', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'
    ];
    Decoder.LOWER_TABLE = [
        'CTRL_PS', ' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
        'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'CTRL_US', 'CTRL_ML', 'CTRL_DL', 'CTRL_BS'
    ];
    Decoder.MIXED_TABLE = [
        // Module parse failed: Octal literal in strict mode (50:29)
        // so number string were scaped
        'CTRL_PS', ' ', '\\1', '\\2', '\\3', '\\4', '\\5', '\\6', '\\7', '\b', '\t', '\n',
        '\\13', '\f', '\r', '\\33', '\\34', '\\35', '\\36', '\\37', '@', '\\', '^', '_',
        '`', '|', '~', '\\177', 'CTRL_LL', 'CTRL_UL', 'CTRL_PL', 'CTRL_BS'
    ];
    Decoder.PUNCT_TABLE = [
        '', '\r', '\r\n', '. ', ', ', ': ', '!', '"', '#', '$', '%', '&', '\'', '(', ')',
        '*', '+', ',', '-', '.', '/', ':', ';', '<', '=', '>', '?', '[', ']', '{', '}', 'CTRL_UL'
    ];
    Decoder.DIGIT_TABLE = [
        'CTRL_PS', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', '.', 'CTRL_UL', 'CTRL_US'
    ];
    return Decoder;
}());
exports.default = Decoder;
//# sourceMappingURL=Decoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/aztec/detector/Detector.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/aztec/detector/Detector.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2010 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var AztecDetectorResult_1 = __webpack_require__(/*! ../AztecDetectorResult */ "./node_modules/@zxing/library/esm5/core/aztec/AztecDetectorResult.js");
var MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js");
var WhiteRectangleDetector_1 = __webpack_require__(/*! ../../common/detector/WhiteRectangleDetector */ "./node_modules/@zxing/library/esm5/core/common/detector/WhiteRectangleDetector.js");
var GenericGF_1 = __webpack_require__(/*! ../../common/reedsolomon/GenericGF */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGF.js");
var ReedSolomonDecoder_1 = __webpack_require__(/*! ../../common/reedsolomon/ReedSolomonDecoder */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/ReedSolomonDecoder.js");
var NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var GridSamplerInstance_1 = __webpack_require__(/*! ../../common/GridSamplerInstance */ "./node_modules/@zxing/library/esm5/core/common/GridSamplerInstance.js");
var Integer_1 = __webpack_require__(/*! ../../util/Integer */ "./node_modules/@zxing/library/esm5/core/util/Integer.js");
var Point = /** @class */ (function () {
    function Point(x, y) {
        this.x = x;
        this.y = y;
    }
    Point.prototype.toResultPoint = function () {
        return new ResultPoint_1.default(this.getX(), this.getY());
    };
    Point.prototype.getX = function () {
        return this.x;
    };
    Point.prototype.getY = function () {
        return this.y;
    };
    return Point;
}());
exports.Point = Point;
/**
 * Encapsulates logic that can detect an Aztec Code in an image, even if the Aztec Code
 * is rotated or skewed, or partially obscured.
 *
 * @author David Olivier
 * @author Frank Yellin
 */
var Detector = /** @class */ (function () {
    function Detector(image) {
        this.EXPECTED_CORNER_BITS = new Int32Array([
            0xee0,
            0x1dc,
            0x83b,
            0x707,
        ]);
        this.image = image;
    }
    Detector.prototype.detect = function () {
        return this.detectMirror(false);
    };
    /**
     * Detects an Aztec Code in an image.
     *
     * @param isMirror if true, image is a mirror-image of original
     * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code
     * @throws NotFoundException if no Aztec Code can be found
     */
    Detector.prototype.detectMirror = function (isMirror) {
        // 1. Get the center of the aztec matrix
        var pCenter = this.getMatrixCenter();
        // 2. Get the center points of the four diagonal points just outside the bull's eye
        //  [topRight, bottomRight, bottomLeft, topLeft]
        var bullsEyeCorners = this.getBullsEyeCorners(pCenter);
        if (isMirror) {
            var temp = bullsEyeCorners[0];
            bullsEyeCorners[0] = bullsEyeCorners[2];
            bullsEyeCorners[2] = temp;
        }
        // 3. Get the size of the matrix and other parameters from the bull's eye
        this.extractParameters(bullsEyeCorners);
        // 4. Sample the grid
        var bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);
        // 5. Get the corners of the matrix.
        var corners = this.getMatrixCornerPoints(bullsEyeCorners);
        return new AztecDetectorResult_1.default(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);
    };
    /**
     * Extracts the number of data layers and data blocks from the layer around the bull's eye.
     *
     * @param bullsEyeCorners the array of bull's eye corners
     * @throws NotFoundException in case of too many errors or invalid parameters
     */
    Detector.prototype.extractParameters = function (bullsEyeCorners) {
        if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) ||
            !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {
            throw new NotFoundException_1.default();
        }
        var length = 2 * this.nbCenterLayers;
        // Get the bits around the bull's eye
        var sides = new Int32Array([
            this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),
            this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),
            this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),
            this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length) // Top
        ]);
        // bullsEyeCorners[shift] is the corner of the bulls'eye that has three
        // orientation marks.
        // sides[shift] is the row/column that goes from the corner with three
        // orientation marks to the corner with two.
        this.shift = this.getRotation(sides, length);
        // Flatten the parameter bits into a single 28- or 40-bit long
        var parameterData = 0;
        for (var i = 0; i < 4; i++) {
            var side = sides[(this.shift + i) % 4];
            if (this.compact) {
                // Each side of the form ..XXXXXXX. where Xs are parameter data
                parameterData <<= 7;
                parameterData += (side >> 1) & 0x7F;
            }
            else {
                // Each side of the form ..XXXXX.XXXXX. where Xs are parameter data
                parameterData <<= 10;
                parameterData += ((side >> 2) & (0x1f << 5)) + ((side >> 1) & 0x1F);
            }
        }
        // Corrects parameter data using RS.  Returns just the data portion
        // without the error correction.
        var correctedData = this.getCorrectedParameterData(parameterData, this.compact);
        if (this.compact) {
            // 8 bits:  2 bits layers and 6 bits data blocks
            this.nbLayers = (correctedData >> 6) + 1;
            this.nbDataBlocks = (correctedData & 0x3F) + 1;
        }
        else {
            // 16 bits:  5 bits layers and 11 bits data blocks
            this.nbLayers = (correctedData >> 11) + 1;
            this.nbDataBlocks = (correctedData & 0x7FF) + 1;
        }
    };
    Detector.prototype.getRotation = function (sides, length) {
        // In a normal pattern, we expect to See
        //   **    .*             D       A
        //   *      *
        //
        //   .      *
        //   ..    ..             C       B
        //
        // Grab the 3 bits from each of the sides the form the locator pattern and concatenate
        // into a 12-bit integer.  Start with the bit at A
        var cornerBits = 0;
        sides.forEach(function (side, idx, arr) {
            // XX......X where X's are orientation marks
            var t = ((side >> (length - 2)) << 1) + (side & 1);
            cornerBits = (cornerBits << 3) + t;
        });
        // for (var side in sides) {
        //     // XX......X where X's are orientation marks
        //     var t = ((side >> (length - 2)) << 1) + (side & 1);
        //     cornerBits = (cornerBits << 3) + t;
        // }
        // Mov the bottom bit to the top, so that the three bits of the locator pattern at A are
        // together.  cornerBits is now:
        //  3 orientation bits at A || 3 orientation bits at B || ... || 3 orientation bits at D
        cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);
        // The result shift indicates which element of BullsEyeCorners[] goes into the top-left
        // corner. Since the four rotation values have a Hamming distance of 8, we
        // can easily tolerate two errors.
        for (var shift = 0; shift < 4; shift++) {
            if (Integer_1.default.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift]) <= 2) {
                return shift;
            }
        }
        throw new NotFoundException_1.default();
    };
    /**
     * Corrects the parameter bits using Reed-Solomon algorithm.
     *
     * @param parameterData parameter bits
     * @param compact true if this is a compact Aztec code
     * @throws NotFoundException if the array contains too many errors
     */
    Detector.prototype.getCorrectedParameterData = function (parameterData, compact) {
        var numCodewords;
        var numDataCodewords;
        if (compact) {
            numCodewords = 7;
            numDataCodewords = 2;
        }
        else {
            numCodewords = 10;
            numDataCodewords = 4;
        }
        var numECCodewords = numCodewords - numDataCodewords;
        var parameterWords = new Int32Array(numCodewords);
        for (var i = numCodewords - 1; i >= 0; --i) {
            parameterWords[i] = parameterData & 0xF;
            parameterData >>= 4;
        }
        try {
            var rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.AZTEC_PARAM);
            rsDecoder.decode(parameterWords, numECCodewords);
        }
        catch (ignored) {
            throw new NotFoundException_1.default();
        }
        // Toss the error correction.  Just return the data as an integer
        var result = 0;
        for (var i = 0; i < numDataCodewords; i++) {
            result = (result << 4) + parameterWords[i];
        }
        return result;
    };
    /**
     * Finds the corners of a bull-eye centered on the passed point.
     * This returns the centers of the diagonal points just outside the bull's eye
     * Returns [topRight, bottomRight, bottomLeft, topLeft]
     *
     * @param pCenter Center point
     * @return The corners of the bull-eye
     * @throws NotFoundException If no valid bull-eye can be found
     */
    Detector.prototype.getBullsEyeCorners = function (pCenter) {
        var pina = pCenter;
        var pinb = pCenter;
        var pinc = pCenter;
        var pind = pCenter;
        var color = true;
        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
            var pouta = this.getFirstDifferent(pina, color, 1, -1);
            var poutb = this.getFirstDifferent(pinb, color, 1, 1);
            var poutc = this.getFirstDifferent(pinc, color, -1, 1);
            var poutd = this.getFirstDifferent(pind, color, -1, -1);
            // d      a
            //
            // c      b
            if (this.nbCenterLayers > 2) {
                var q = (this.distancePoint(poutd, pouta) * this.nbCenterLayers) / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));
                if (q < 0.75 || q > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {
                    break;
                }
            }
            pina = pouta;
            pinb = poutb;
            pinc = poutc;
            pind = poutd;
            color = !color;
        }
        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {
            throw new NotFoundException_1.default();
        }
        this.compact = this.nbCenterLayers === 5;
        // Expand the square by .5 pixel in each direction so that we're on the border
        // between the white square and the black square
        var pinax = new ResultPoint_1.default(pina.getX() + 0.5, pina.getY() - 0.5);
        var pinbx = new ResultPoint_1.default(pinb.getX() + 0.5, pinb.getY() + 0.5);
        var pincx = new ResultPoint_1.default(pinc.getX() - 0.5, pinc.getY() + 0.5);
        var pindx = new ResultPoint_1.default(pind.getX() - 0.5, pind.getY() - 0.5);
        // Expand the square so that its corners are the centers of the points
        // just outside the bull's eye.
        return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);
    };
    /**
     * Finds a candidate center point of an Aztec code from an image
     *
     * @return the center point
     */
    Detector.prototype.getMatrixCenter = function () {
        var pointA;
        var pointB;
        var pointC;
        var pointD;
        // Get a white rectangle that can be the border of the matrix in center bull's eye or
        try {
            var cornerPoints = new WhiteRectangleDetector_1.default(this.image).detect();
            pointA = cornerPoints[0];
            pointB = cornerPoints[1];
            pointC = cornerPoints[2];
            pointD = cornerPoints[3];
        }
        catch (e) {
            // This exception can be in case the initial rectangle is white
            // In that case, surely in the bull's eye, we try to expand the rectangle.
            var cx_1 = this.image.getWidth() / 2;
            var cy_1 = this.image.getHeight() / 2;
            pointA = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 - 7), false, 1, -1).toResultPoint();
            pointB = this.getFirstDifferent(new Point(cx_1 + 7, cy_1 + 7), false, 1, 1).toResultPoint();
            pointC = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 + 7), false, -1, 1).toResultPoint();
            pointD = this.getFirstDifferent(new Point(cx_1 - 7, cy_1 - 7), false, -1, -1).toResultPoint();
        }
        // Compute the center of the rectangle
        var cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);
        var cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);
        // Redetermine the white rectangle starting from previously computed center.
        // This will ensure that we end up with a white rectangle in center bull's eye
        // in order to compute a more accurate center.
        try {
            var cornerPoints = new WhiteRectangleDetector_1.default(this.image, 15, cx, cy).detect();
            pointA = cornerPoints[0];
            pointB = cornerPoints[1];
            pointC = cornerPoints[2];
            pointD = cornerPoints[3];
        }
        catch (e) {
            // This exception can be in case the initial rectangle is white
            // In that case we try to expand the rectangle.
            pointA = this.getFirstDifferent(new Point(cx + 7, cy - 7), false, 1, -1).toResultPoint();
            pointB = this.getFirstDifferent(new Point(cx + 7, cy + 7), false, 1, 1).toResultPoint();
            pointC = this.getFirstDifferent(new Point(cx - 7, cy + 7), false, -1, 1).toResultPoint();
            pointD = this.getFirstDifferent(new Point(cx - 7, cy - 7), false, -1, -1).toResultPoint();
        }
        // Recompute the center of the rectangle
        cx = MathUtils_1.default.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4.0);
        cy = MathUtils_1.default.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4.0);
        return new Point(cx, cy);
    };
    /**
     * Gets the Aztec code corners from the bull's eye corners and the parameters.
     *
     * @param bullsEyeCorners the array of bull's eye corners
     * @return the array of aztec code corners
     */
    Detector.prototype.getMatrixCornerPoints = function (bullsEyeCorners) {
        return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());
    };
    /**
     * Creates a BitMatrix by sampling the provided image.
     * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the
     * diagonal just outside the bull's eye.
     */
    Detector.prototype.sampleGrid = function (image, topLeft, topRight, bottomRight, bottomLeft) {
        var sampler = GridSamplerInstance_1.default.getInstance();
        var dimension = this.getDimension();
        var low = dimension / 2 - this.nbCenterLayers;
        var high = dimension / 2 + this.nbCenterLayers;
        return sampler.sampleGrid(image, dimension, dimension, low, low, // topleft
        high, low, // topright
        high, high, // bottomright
        low, high, // bottomleft
        topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
    };
    /**
     * Samples a line.
     *
     * @param p1   start point (inclusive)
     * @param p2   end point (exclusive)
     * @param size number of bits
     * @return the array of bits as an int (first bit is high-order bit of result)
     */
    Detector.prototype.sampleLine = function (p1, p2, size) {
        var result = 0;
        var d = this.distanceResultPoint(p1, p2);
        var moduleSize = d / size;
        var px = p1.getX();
        var py = p1.getY();
        var dx = moduleSize * (p2.getX() - p1.getX()) / d;
        var dy = moduleSize * (p2.getY() - p1.getY()) / d;
        for (var i = 0; i < size; i++) {
            if (this.image.get(MathUtils_1.default.round(px + i * dx), MathUtils_1.default.round(py + i * dy))) {
                result |= 1 << (size - i - 1);
            }
        }
        return result;
    };
    /**
     * @return true if the border of the rectangle passed in parameter is compound of white points only
     *         or black points only
     */
    Detector.prototype.isWhiteOrBlackRectangle = function (p1, p2, p3, p4) {
        var corr = 3;
        p1 = new Point(p1.getX() - corr, p1.getY() + corr);
        p2 = new Point(p2.getX() - corr, p2.getY() - corr);
        p3 = new Point(p3.getX() + corr, p3.getY() - corr);
        p4 = new Point(p4.getX() + corr, p4.getY() + corr);
        var cInit = this.getColor(p4, p1);
        if (cInit === 0) {
            return false;
        }
        var c = this.getColor(p1, p2);
        if (c !== cInit) {
            return false;
        }
        c = this.getColor(p2, p3);
        if (c !== cInit) {
            return false;
        }
        c = this.getColor(p3, p4);
        return c === cInit;
    };
    /**
     * Gets the color of a segment
     *
     * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else
     */
    Detector.prototype.getColor = function (p1, p2) {
        var d = this.distancePoint(p1, p2);
        var dx = (p2.getX() - p1.getX()) / d;
        var dy = (p2.getY() - p1.getY()) / d;
        var error = 0;
        var px = p1.getX();
        var py = p1.getY();
        var colorModel = this.image.get(p1.getX(), p1.getY());
        var iMax = Math.ceil(d);
        for (var i = 0; i < iMax; i++) {
            px += dx;
            py += dy;
            if (this.image.get(MathUtils_1.default.round(px), MathUtils_1.default.round(py)) !== colorModel) {
                error++;
            }
        }
        var errRatio = error / d;
        if (errRatio > 0.1 && errRatio < 0.9) {
            return 0;
        }
        return (errRatio <= 0.1) === colorModel ? 1 : -1;
    };
    /**
     * Gets the coordinate of the first point with a different color in the given direction
     */
    Detector.prototype.getFirstDifferent = function (init, color, dx, dy) {
        var x = init.getX() + dx;
        var y = init.getY() + dy;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
            x += dx;
            y += dy;
        }
        x -= dx;
        y -= dy;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
            x += dx;
        }
        x -= dx;
        while (this.isValid(x, y) && this.image.get(x, y) === color) {
            y += dy;
        }
        y -= dy;
        return new Point(x, y);
    };
    /**
     * Expand the square represented by the corner points by pushing out equally in all directions
     *
     * @param cornerPoints the corners of the square, which has the bull's eye at its center
     * @param oldSide the original length of the side of the square in the target bit matrix
     * @param newSide the new length of the size of the square in the target bit matrix
     * @return the corners of the expanded square
     */
    Detector.prototype.expandSquare = function (cornerPoints, oldSide, newSide) {
        var ratio = newSide / (2.0 * oldSide);
        var dx = cornerPoints[0].getX() - cornerPoints[2].getX();
        var dy = cornerPoints[0].getY() - cornerPoints[2].getY();
        var centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2.0;
        var centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2.0;
        var result0 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);
        var result2 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);
        dx = cornerPoints[1].getX() - cornerPoints[3].getX();
        dy = cornerPoints[1].getY() - cornerPoints[3].getY();
        centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2.0;
        centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2.0;
        var result1 = new ResultPoint_1.default(centerx + ratio * dx, centery + ratio * dy);
        var result3 = new ResultPoint_1.default(centerx - ratio * dx, centery - ratio * dy);
        var results = [result0, result1, result2, result3];
        return results;
    };
    Detector.prototype.isValid = function (x, y) {
        return x >= 0 && x < this.image.getWidth() && y > 0 && y < this.image.getHeight();
    };
    Detector.prototype.isValidPoint = function (point) {
        var x = MathUtils_1.default.round(point.getX());
        var y = MathUtils_1.default.round(point.getY());
        return this.isValid(x, y);
    };
    Detector.prototype.distancePoint = function (a, b) {
        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());
    };
    Detector.prototype.distanceResultPoint = function (a, b) {
        return MathUtils_1.default.distance(a.getX(), a.getY(), b.getX(), b.getY());
    };
    Detector.prototype.getDimension = function () {
        if (this.compact) {
            return 4 * this.nbLayers + 11;
        }
        if (this.nbLayers <= 4) {
            return 4 * this.nbLayers + 15;
        }
        return 4 * this.nbLayers + 2 * (Integer_1.default.truncDivision((this.nbLayers - 4), 8) + 1) + 15;
    };
    return Detector;
}());
exports.default = Detector;
//# sourceMappingURL=Detector.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/BitArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/BitArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common {*/
/*import java.util.Arrays;*/
var System_1 = __webpack_require__(/*! ../util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var Integer_1 = __webpack_require__(/*! ../util/Integer */ "./node_modules/@zxing/library/esm5/core/util/Integer.js");
var Arrays_1 = __webpack_require__(/*! ../util/Arrays */ "./node_modules/@zxing/library/esm5/core/util/Arrays.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * <p>A simple, fast array of bits, represented compactly by an array of ints internally.</p>
 *
 * @author Sean Owen
 */
var BitArray /*implements Cloneable*/ = /** @class */ (function () {
    // public constructor() {
    //   this.size = 0
    //   this.bits = new Int32Array(1)
    // }
    // public constructor(size?: number /*int*/) {
    //   if (undefined === size) {
    //     this.size = 0
    //   } else {
    //     this.size = size
    //   }
    //   this.bits = this.makeArray(size)
    // }
    // For testing only
    function BitArray(size /*int*/, bits) {
        if (undefined === size) {
            this.size = 0;
            this.bits = new Int32Array(1);
        }
        else {
            this.size = size;
            if (undefined === bits || null === bits) {
                this.bits = BitArray.makeArray(size);
            }
            else {
                this.bits = bits;
            }
        }
    }
    BitArray.prototype.getSize = function () {
        return this.size;
    };
    BitArray.prototype.getSizeInBytes = function () {
        return Math.floor((this.size + 7) / 8);
    };
    BitArray.prototype.ensureCapacity = function (size /*int*/) {
        if (size > this.bits.length * 32) {
            var newBits = BitArray.makeArray(size);
            System_1.default.arraycopy(this.bits, 0, newBits, 0, this.bits.length);
            this.bits = newBits;
        }
    };
    /**
     * @param i bit to get
     * @return true iff bit i is set
     */
    BitArray.prototype.get = function (i /*int*/) {
        return (this.bits[Math.floor(i / 32)] & (1 << (i & 0x1F))) !== 0;
    };
    /**
     * Sets bit i.
     *
     * @param i bit to set
     */
    BitArray.prototype.set = function (i /*int*/) {
        this.bits[Math.floor(i / 32)] |= 1 << (i & 0x1F);
    };
    /**
     * Flips bit i.
     *
     * @param i bit to set
     */
    BitArray.prototype.flip = function (i /*int*/) {
        this.bits[Math.floor(i / 32)] ^= 1 << (i & 0x1F);
    };
    /**
     * @param from first bit to check
     * @return index of first bit that is set, starting from the given index, or size if none are set
     *  at or beyond this given index
     * @see #getNextUnset(int)
     */
    BitArray.prototype.getNextSet = function (from /*int*/) {
        var size = this.size;
        if (from >= size) {
            return size;
        }
        var bits = this.bits;
        var bitsOffset = Math.floor(from / 32);
        var currentBits = bits[bitsOffset];
        // mask off lesser bits first
        currentBits &= ~((1 << (from & 0x1F)) - 1);
        var length = bits.length;
        while (currentBits === 0) {
            if (++bitsOffset === length) {
                return size;
            }
            currentBits = bits[bitsOffset];
        }
        var result = (bitsOffset * 32) + Integer_1.default.numberOfTrailingZeros(currentBits);
        return result > size ? size : result;
    };
    /**
     * @param from index to start looking for unset bit
     * @return index of next unset bit, or {@code size} if none are unset until the end
     * @see #getNextSet(int)
     */
    BitArray.prototype.getNextUnset = function (from /*int*/) {
        var size = this.size;
        if (from >= size) {
            return size;
        }
        var bits = this.bits;
        var bitsOffset = Math.floor(from / 32);
        var currentBits = ~bits[bitsOffset];
        // mask off lesser bits first
        currentBits &= ~((1 << (from & 0x1F)) - 1);
        var length = bits.length;
        while (currentBits === 0) {
            if (++bitsOffset === length) {
                return size;
            }
            currentBits = ~bits[bitsOffset];
        }
        var result = (bitsOffset * 32) + Integer_1.default.numberOfTrailingZeros(currentBits);
        return result > size ? size : result;
    };
    /**
     * Sets a block of 32 bits, starting at bit i.
     *
     * @param i first bit to set
     * @param newBits the new value of the next 32 bits. Note again that the least-significant bit
     * corresponds to bit i, the next-least-significant to i+1, and so on.
     */
    BitArray.prototype.setBulk = function (i /*int*/, newBits /*int*/) {
        this.bits[Math.floor(i / 32)] = newBits;
    };
    /**
     * Sets a range of bits.
     *
     * @param start start of range, inclusive.
     * @param end end of range, exclusive
     */
    BitArray.prototype.setRange = function (start /*int*/, end /*int*/) {
        if (end < start || start < 0 || end > this.size) {
            throw new IllegalArgumentException_1.default();
        }
        if (end === start) {
            return;
        }
        end--; // will be easier to treat this as the last actually set bit -- inclusive
        var firstInt = Math.floor(start / 32);
        var lastInt = Math.floor(end / 32);
        var bits = this.bits;
        for (var i = firstInt; i <= lastInt; i++) {
            var firstBit = i > firstInt ? 0 : start & 0x1F;
            var lastBit = i < lastInt ? 31 : end & 0x1F;
            // Ones from firstBit to lastBit, inclusive
            var mask = (2 << lastBit) - (1 << firstBit);
            bits[i] |= mask;
        }
    };
    /**
     * Clears all bits (sets to false).
     */
    BitArray.prototype.clear = function () {
        var max = this.bits.length;
        var bits = this.bits;
        for (var i = 0; i < max; i++) {
            bits[i] = 0;
        }
    };
    /**
     * Efficient method to check if a range of bits is set, or not set.
     *
     * @param start start of range, inclusive.
     * @param end end of range, exclusive
     * @param value if true, checks that bits in range are set, otherwise checks that they are not set
     * @return true iff all bits are set or not set in range, according to value argument
     * @throws IllegalArgumentException if end is less than start or the range is not contained in the array
     */
    BitArray.prototype.isRange = function (start /*int*/, end /*int*/, value) {
        if (end < start || start < 0 || end > this.size) {
            throw new IllegalArgumentException_1.default();
        }
        if (end === start) {
            return true; // empty range matches
        }
        end--; // will be easier to treat this as the last actually set bit -- inclusive
        var firstInt = Math.floor(start / 32);
        var lastInt = Math.floor(end / 32);
        var bits = this.bits;
        for (var i = firstInt; i <= lastInt; i++) {
            var firstBit = i > firstInt ? 0 : start & 0x1F;
            var lastBit = i < lastInt ? 31 : end & 0x1F;
            // Ones from firstBit to lastBit, inclusive
            var mask = (2 << lastBit) - (1 << firstBit) & 0xFFFFFFFF;
            // TYPESCRIPTPORT: & 0xFFFFFFFF added to discard anything after 32 bits, as ES has 53 bits
            // Return false if we're looking for 1s and the masked bits[i] isn't all 1s (is: that,
            // equals the mask, or we're looking for 0s and the masked portion is not all 0s
            if ((bits[i] & mask) !== (value ? mask : 0)) {
                return false;
            }
        }
        return true;
    };
    BitArray.prototype.appendBit = function (bit) {
        this.ensureCapacity(this.size + 1);
        if (bit) {
            this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 0x1F);
        }
        this.size++;
    };
    /**
     * Appends the least-significant bits, from value, in order from most-significant to
     * least-significant. For example, appending 6 bits from 0x000001E will append the bits
     * 0, 1, 1, 1, 1, 0 in that order.
     *
     * @param value {@code int} containing bits to append
     * @param numBits bits from value to append
     */
    BitArray.prototype.appendBits = function (value /*int*/, numBits /*int*/) {
        if (numBits < 0 || numBits > 32) {
            throw new IllegalArgumentException_1.default('Num bits must be between 0 and 32');
        }
        this.ensureCapacity(this.size + numBits);
        var appendBit = this.appendBit;
        for (var numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
            this.appendBit(((value >> (numBitsLeft - 1)) & 0x01) === 1);
        }
    };
    BitArray.prototype.appendBitArray = function (other) {
        var otherSize = other.size;
        this.ensureCapacity(this.size + otherSize);
        var appendBit = this.appendBit;
        for (var i = 0; i < otherSize; i++) {
            this.appendBit(other.get(i));
        }
    };
    BitArray.prototype.xor = function (other) {
        if (this.size !== other.size) {
            throw new IllegalArgumentException_1.default('Sizes don\'t match');
        }
        var bits = this.bits;
        for (var i = 0, length_1 = bits.length; i < length_1; i++) {
            // The last int could be incomplete (i.e. not have 32 bits in
            // it) but there is no problem since 0 XOR 0 == 0.
            bits[i] ^= other.bits[i];
        }
    };
    /**
     *
     * @param bitOffset first bit to start writing
     * @param array array to write into. Bytes are written most-significant byte first. This is the opposite
     *  of the internal representation, which is exposed by {@link #getBitArray()}
     * @param offset position in array to start writing
     * @param numBytes how many bytes to write
     */
    BitArray.prototype.toBytes = function (bitOffset /*int*/, array, offset /*int*/, numBytes /*int*/) {
        for (var i = 0; i < numBytes; i++) {
            var theByte = 0;
            for (var j = 0; j < 8; j++) {
                if (this.get(bitOffset)) {
                    theByte |= 1 << (7 - j);
                }
                bitOffset++;
            }
            array[offset + i] = /*(byte)*/ theByte;
        }
    };
    /**
     * @return underlying array of ints. The first element holds the first 32 bits, and the least
     *         significant bit is bit 0.
     */
    BitArray.prototype.getBitArray = function () {
        return this.bits;
    };
    /**
     * Reverses all bits in the array.
     */
    BitArray.prototype.reverse = function () {
        var newBits = new Int32Array(this.bits.length);
        // reverse all int's first
        var len = Math.floor((this.size - 1) / 32);
        var oldBitsLen = len + 1;
        var bits = this.bits;
        for (var i = 0; i < oldBitsLen; i++) {
            var x = bits[i];
            x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);
            x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);
            x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);
            x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);
            x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);
            newBits[len - i] = /*(int)*/ x;
        }
        // now correct the int's if the bit size isn't a multiple of 32
        if (this.size !== oldBitsLen * 32) {
            var leftOffset = oldBitsLen * 32 - this.size;
            var currentInt = newBits[0] >>> leftOffset;
            for (var i = 1; i < oldBitsLen; i++) {
                var nextInt = newBits[i];
                currentInt |= nextInt << (32 - leftOffset);
                newBits[i - 1] = currentInt;
                currentInt = nextInt >>> leftOffset;
            }
            newBits[oldBitsLen - 1] = currentInt;
        }
        this.bits = newBits;
    };
    BitArray.makeArray = function (size /*int*/) {
        return new Int32Array(Math.floor((size + 31) / 32));
    };
    /*@Override*/
    BitArray.prototype.equals = function (o) {
        if (!(o instanceof BitArray)) {
            return false;
        }
        var other = o;
        return this.size === other.size && Arrays_1.default.equals(this.bits, other.bits);
    };
    /*@Override*/
    BitArray.prototype.hashCode = function () {
        return 31 * this.size + Arrays_1.default.hashCode(this.bits);
    };
    /*@Override*/
    BitArray.prototype.toString = function () {
        var result = '';
        for (var i = 0, size = this.size; i < size; i++) {
            if ((i & 0x07) === 0) {
                result += ' ';
            }
            result += this.get(i) ? 'X' : '.';
        }
        return result;
    };
    /*@Override*/
    BitArray.prototype.clone = function () {
        return new BitArray(this.size, this.bits.slice());
    };
    return BitArray;
}());
exports.default = BitArray;
//# sourceMappingURL=BitArray.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/BitMatrix.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/BitMatrix.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common {*/
/*import java.util.Arrays;*/
var BitArray_1 = __webpack_require__(/*! ./BitArray */ "./node_modules/@zxing/library/esm5/core/common/BitArray.js");
var System_1 = __webpack_require__(/*! ../util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var Arrays_1 = __webpack_require__(/*! ../util/Arrays */ "./node_modules/@zxing/library/esm5/core/util/Arrays.js");
var StringBuilder_1 = __webpack_require__(/*! ../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * <p>Represents a 2D matrix of bits. In function arguments below, and throughout the common
 * module, x is the column position, and y is the row position. The ordering is always x, y.
 * The origin is at the top-left.</p>
 *
 * <p>Internally the bits are represented in a 1-D array of 32-bit ints. However, each row begins
 * with a new int. This is done intentionally so that we can copy out a row into a BitArray very
 * efficiently.</p>
 *
 * <p>The ordering of bits is row-major. Within each int, the least significant bits are used first,
 * meaning they represent lower x values. This is compatible with BitArray's implementation.</p>
 *
 * @author Sean Owen
 * @author dswitkin@google.com (Daniel Switkin)
 */
var BitMatrix /*implements Cloneable*/ = /** @class */ (function () {
    /**
     * Creates an empty square {@link BitMatrix}.
     *
     * @param dimension height and width
     */
    // public constructor(dimension: number /*int*/) {
    //   this(dimension, dimension)
    // }
    /**
     * Creates an empty {@link BitMatrix}.
     *
     * @param width bit matrix width
     * @param height bit matrix height
     */
    // public constructor(width: number /*int*/, height: number /*int*/) {
    //   if (width < 1 || height < 1) {
    //     throw new IllegalArgumentException("Both dimensions must be greater than 0")
    //   }
    //   this.width = width
    //   this.height = height
    //   this.rowSize = (width + 31) / 32
    //   bits = new int[rowSize * height];
    // }
    function BitMatrix(width /*int*/, height /*int*/, rowSize /*int*/, bits) {
        this.width = width;
        this.height = height;
        this.rowSize = rowSize;
        this.bits = bits;
        if (undefined === height || null === height) {
            height = width;
        }
        this.height = height;
        if (width < 1 || height < 1) {
            throw new IllegalArgumentException_1.default('Both dimensions must be greater than 0');
        }
        if (undefined === rowSize || null === rowSize) {
            rowSize = Math.floor((width + 31) / 32);
        }
        this.rowSize = rowSize;
        if (undefined === bits || null === bits) {
            this.bits = new Int32Array(this.rowSize * this.height);
        }
    }
    /**
     * Interprets a 2D array of booleans as a {@link BitMatrix}, where "true" means an "on" bit.
     *
     * @function parse
     * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows
     * @return {@link BitMatrix} representation of image
     */
    BitMatrix.parseFromBooleanArray = function (image) {
        var height = image.length;
        var width = image[0].length;
        var bits = new BitMatrix(width, height);
        for (var i = 0; i < height; i++) {
            var imageI = image[i];
            for (var j = 0; j < width; j++) {
                if (imageI[j]) {
                    bits.set(j, i);
                }
            }
        }
        return bits;
    };
    /**
     *
     * @function parse
     * @param stringRepresentation
     * @param setString
     * @param unsetString
     */
    BitMatrix.parseFromString = function (stringRepresentation, setString, unsetString) {
        if (stringRepresentation === null) {
            throw new IllegalArgumentException_1.default('stringRepresentation cannot be null');
        }
        var bits = new Array(stringRepresentation.length);
        var bitsPos = 0;
        var rowStartPos = 0;
        var rowLength = -1;
        var nRows = 0;
        var pos = 0;
        while (pos < stringRepresentation.length) {
            if (stringRepresentation.charAt(pos) === '\n' ||
                stringRepresentation.charAt(pos) === '\r') {
                if (bitsPos > rowStartPos) {
                    if (rowLength === -1) {
                        rowLength = bitsPos - rowStartPos;
                    }
                    else if (bitsPos - rowStartPos !== rowLength) {
                        throw new IllegalArgumentException_1.default('row lengths do not match');
                    }
                    rowStartPos = bitsPos;
                    nRows++;
                }
                pos++;
            }
            else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {
                pos += setString.length;
                bits[bitsPos] = true;
                bitsPos++;
            }
            else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {
                pos += unsetString.length;
                bits[bitsPos] = false;
                bitsPos++;
            }
            else {
                throw new IllegalArgumentException_1.default('illegal character encountered: ' + stringRepresentation.substring(pos));
            }
        }
        // no EOL at end?
        if (bitsPos > rowStartPos) {
            if (rowLength === -1) {
                rowLength = bitsPos - rowStartPos;
            }
            else if (bitsPos - rowStartPos !== rowLength) {
                throw new IllegalArgumentException_1.default('row lengths do not match');
            }
            nRows++;
        }
        var matrix = new BitMatrix(rowLength, nRows);
        for (var i = 0; i < bitsPos; i++) {
            if (bits[i]) {
                matrix.set(Math.floor(i % rowLength), Math.floor(i / rowLength));
            }
        }
        return matrix;
    };
    /**
     * <p>Gets the requested bit, where true means black.</p>
     *
     * @param x The horizontal component (i.e. which column)
     * @param y The vertical component (i.e. which row)
     * @return value of given bit in matrix
     */
    BitMatrix.prototype.get = function (x /*int*/, y /*int*/) {
        var offset = y * this.rowSize + Math.floor(x / 32);
        return ((this.bits[offset] >>> (x & 0x1f)) & 1) !== 0;
    };
    /**
     * <p>Sets the given bit to true.</p>
     *
     * @param x The horizontal component (i.e. which column)
     * @param y The vertical component (i.e. which row)
     */
    BitMatrix.prototype.set = function (x /*int*/, y /*int*/) {
        var offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] |= (1 << (x & 0x1f)) & 0xFFFFFFFF;
    };
    BitMatrix.prototype.unset = function (x /*int*/, y /*int*/) {
        var offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] &= ~((1 << (x & 0x1f)) & 0xFFFFFFFF);
    };
    /**
     * <p>Flips the given bit.</p>
     *
     * @param x The horizontal component (i.e. which column)
     * @param y The vertical component (i.e. which row)
     */
    BitMatrix.prototype.flip = function (x /*int*/, y /*int*/) {
        var offset = y * this.rowSize + Math.floor(x / 32);
        this.bits[offset] ^= ((1 << (x & 0x1f)) & 0xFFFFFFFF);
    };
    /**
     * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding
     * mask bit is set.
     *
     * @param mask XOR mask
     */
    BitMatrix.prototype.xor = function (mask) {
        if (this.width !== mask.getWidth() || this.height !== mask.getHeight()
            || this.rowSize !== mask.getRowSize()) {
            throw new IllegalArgumentException_1.default('input matrix dimensions do not match');
        }
        var rowArray = new BitArray_1.default(Math.floor(this.width / 32) + 1);
        var rowSize = this.rowSize;
        var bits = this.bits;
        for (var y = 0, height = this.height; y < height; y++) {
            var offset = y * rowSize;
            var row = mask.getRow(y, rowArray).getBitArray();
            for (var x = 0; x < rowSize; x++) {
                bits[offset + x] ^= row[x];
            }
        }
    };
    /**
     * Clears all bits (sets to false).
     */
    BitMatrix.prototype.clear = function () {
        var bits = this.bits;
        var max = bits.length;
        for (var i = 0; i < max; i++) {
            bits[i] = 0;
        }
    };
    /**
     * <p>Sets a square region of the bit matrix to true.</p>
     *
     * @param left The horizontal position to begin at (inclusive)
     * @param top The vertical position to begin at (inclusive)
     * @param width The width of the region
     * @param height The height of the region
     */
    BitMatrix.prototype.setRegion = function (left /*int*/, top /*int*/, width /*int*/, height /*int*/) {
        if (top < 0 || left < 0) {
            throw new IllegalArgumentException_1.default('Left and top must be nonnegative');
        }
        if (height < 1 || width < 1) {
            throw new IllegalArgumentException_1.default('Height and width must be at least 1');
        }
        var right = left + width;
        var bottom = top + height;
        if (bottom > this.height || right > this.width) {
            throw new IllegalArgumentException_1.default('The region must fit inside the matrix');
        }
        var rowSize = this.rowSize;
        var bits = this.bits;
        for (var y = top; y < bottom; y++) {
            var offset = y * rowSize;
            for (var x = left; x < right; x++) {
                bits[offset + Math.floor(x / 32)] |= ((1 << (x & 0x1f)) & 0xFFFFFFFF);
            }
        }
    };
    /**
     * A fast method to retrieve one row of data from the matrix as a BitArray.
     *
     * @param y The row to retrieve
     * @param row An optional caller-allocated BitArray, will be allocated if null or too small
     * @return The resulting BitArray - this reference should always be used even when passing
     *         your own row
     */
    BitMatrix.prototype.getRow = function (y /*int*/, row) {
        if (row === null || row === undefined || row.getSize() < this.width) {
            row = new BitArray_1.default(this.width);
        }
        else {
            row.clear();
        }
        var rowSize = this.rowSize;
        var bits = this.bits;
        var offset = y * rowSize;
        for (var x = 0; x < rowSize; x++) {
            row.setBulk(x * 32, bits[offset + x]);
        }
        return row;
    };
    /**
     * @param y row to set
     * @param row {@link BitArray} to copy from
     */
    BitMatrix.prototype.setRow = function (y /*int*/, row) {
        System_1.default.arraycopy(row.getBitArray(), 0, this.bits, y * this.rowSize, this.rowSize);
    };
    /**
     * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees
     */
    BitMatrix.prototype.rotate180 = function () {
        var width = this.getWidth();
        var height = this.getHeight();
        var topRow = new BitArray_1.default(width);
        var bottomRow = new BitArray_1.default(width);
        for (var i = 0, length_1 = Math.floor((height + 1) / 2); i < length_1; i++) {
            topRow = this.getRow(i, topRow);
            bottomRow = this.getRow(height - 1 - i, bottomRow);
            topRow.reverse();
            bottomRow.reverse();
            this.setRow(i, bottomRow);
            this.setRow(height - 1 - i, topRow);
        }
    };
    /**
     * This is useful in detecting the enclosing rectangle of a 'pure' barcode.
     *
     * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white
     */
    BitMatrix.prototype.getEnclosingRectangle = function () {
        var width = this.width;
        var height = this.height;
        var rowSize = this.rowSize;
        var bits = this.bits;
        var left = width;
        var top = height;
        var right = -1;
        var bottom = -1;
        for (var y = 0; y < height; y++) {
            for (var x32 = 0; x32 < rowSize; x32++) {
                var theBits = bits[y * rowSize + x32];
                if (theBits !== 0) {
                    if (y < top) {
                        top = y;
                    }
                    if (y > bottom) {
                        bottom = y;
                    }
                    if (x32 * 32 < left) {
                        var bit = 0;
                        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {
                            bit++;
                        }
                        if ((x32 * 32 + bit) < left) {
                            left = x32 * 32 + bit;
                        }
                    }
                    if (x32 * 32 + 31 > right) {
                        var bit = 31;
                        while ((theBits >>> bit) === 0) {
                            bit--;
                        }
                        if ((x32 * 32 + bit) > right) {
                            right = x32 * 32 + bit;
                        }
                    }
                }
            }
        }
        if (right < left || bottom < top) {
            return null;
        }
        return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);
    };
    /**
     * This is useful in detecting a corner of a 'pure' barcode.
     *
     * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white
     */
    BitMatrix.prototype.getTopLeftOnBit = function () {
        var rowSize = this.rowSize;
        var bits = this.bits;
        var bitsOffset = 0;
        while (bitsOffset < bits.length && bits[bitsOffset] === 0) {
            bitsOffset++;
        }
        if (bitsOffset === bits.length) {
            return null;
        }
        var y = bitsOffset / rowSize;
        var x = (bitsOffset % rowSize) * 32;
        var theBits = bits[bitsOffset];
        var bit = 0;
        while (((theBits << (31 - bit)) & 0xFFFFFFFF) === 0) {
            bit++;
        }
        x += bit;
        return Int32Array.from([x, y]);
    };
    BitMatrix.prototype.getBottomRightOnBit = function () {
        var rowSize = this.rowSize;
        var bits = this.bits;
        var bitsOffset = bits.length - 1;
        while (bitsOffset >= 0 && bits[bitsOffset] === 0) {
            bitsOffset--;
        }
        if (bitsOffset < 0) {
            return null;
        }
        var y = Math.floor(bitsOffset / rowSize);
        var x = Math.floor(bitsOffset % rowSize) * 32;
        var theBits = bits[bitsOffset];
        var bit = 31;
        while ((theBits >>> bit) === 0) {
            bit--;
        }
        x += bit;
        return Int32Array.from([x, y]);
    };
    /**
     * @return The width of the matrix
     */
    BitMatrix.prototype.getWidth = function () {
        return this.width;
    };
    /**
     * @return The height of the matrix
     */
    BitMatrix.prototype.getHeight = function () {
        return this.height;
    };
    /**
     * @return The row size of the matrix
     */
    BitMatrix.prototype.getRowSize = function () {
        return this.rowSize;
    };
    /*@Override*/
    BitMatrix.prototype.equals = function (o) {
        if (!(o instanceof BitMatrix)) {
            return false;
        }
        var other = o;
        return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize &&
            Arrays_1.default.equals(this.bits, other.bits);
    };
    /*@Override*/
    BitMatrix.prototype.hashCode = function () {
        var hash = this.width;
        hash = 31 * hash + this.width;
        hash = 31 * hash + this.height;
        hash = 31 * hash + this.rowSize;
        hash = 31 * hash + Arrays_1.default.hashCode(this.bits);
        return hash;
    };
    /**
     * @return string representation using "X" for set and " " for unset bits
     */
    /*@Override*/
    // public toString(): string {
    //   return toString(": "X, "  ")
    // }
    /**
     * @param setString representation of a set bit
     * @param unsetString representation of an unset bit
     * @return string representation of entire matrix utilizing given strings
     */
    // public toString(setString: string = "X ", unsetString: string = "  "): string {
    //   return this.buildToString(setString, unsetString, "\n")
    // }
    /**
     * @param setString representation of a set bit
     * @param unsetString representation of an unset bit
     * @param lineSeparator newline character in string representation
     * @return string representation of entire matrix utilizing given strings and line separator
     * @deprecated call {@link #toString(String,String)} only, which uses \n line separator always
     */
    // @Deprecated
    BitMatrix.prototype.toString = function (setString, unsetString, lineSeparator) {
        if (setString === void 0) { setString = 'X '; }
        if (unsetString === void 0) { unsetString = '  '; }
        if (lineSeparator === void 0) { lineSeparator = '\n'; }
        return this.buildToString(setString, unsetString, lineSeparator);
    };
    BitMatrix.prototype.buildToString = function (setString, unsetString, lineSeparator) {
        var result = new StringBuilder_1.default();
        // result.append(lineSeparator);
        for (var y = 0, height = this.height; y < height; y++) {
            for (var x = 0, width = this.width; x < width; x++) {
                result.append(this.get(x, y) ? setString : unsetString);
            }
            result.append(lineSeparator);
        }
        return result.toString();
    };
    /*@Override*/
    BitMatrix.prototype.clone = function () {
        return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());
    };
    return BitMatrix;
}());
exports.default = BitMatrix;
//# sourceMappingURL=BitMatrix.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/BitSource.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/BitSource.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common {*/
var IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * <p>This provides an easy abstraction to read bits at a time from a sequence of bytes, where the
 * number of bits read is not often a multiple of 8.</p>
 *
 * <p>This class is thread-safe but not reentrant -- unless the caller modifies the bytes array
 * it passed in, in which case all bets are off.</p>
 *
 * @author Sean Owen
 */
var BitSource = /** @class */ (function () {
    /**
     * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.
     * Bits are read within a byte from most-significant to least-significant bit.
     */
    function BitSource(bytes) {
        this.bytes = bytes;
        this.byteOffset = 0;
        this.bitOffset = 0;
    }
    /**
     * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.
     */
    BitSource.prototype.getBitOffset = function () {
        return this.bitOffset;
    };
    /**
     * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.
     */
    BitSource.prototype.getByteOffset = function () {
        return this.byteOffset;
    };
    /**
     * @param numBits number of bits to read
     * @return int representing the bits read. The bits will appear as the least-significant
     *         bits of the int
     * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available
     */
    BitSource.prototype.readBits = function (numBits /*int*/) {
        if (numBits < 1 || numBits > 32 || numBits > this.available()) {
            throw new IllegalArgumentException_1.default('' + numBits);
        }
        var result = 0;
        var bitOffset = this.bitOffset;
        var byteOffset = this.byteOffset;
        var bytes = this.bytes;
        // First, read remainder from current byte
        if (bitOffset > 0) {
            var bitsLeft = 8 - bitOffset;
            var toRead = numBits < bitsLeft ? numBits : bitsLeft;
            var bitsToNotRead = bitsLeft - toRead;
            var mask = (0xFF >> (8 - toRead)) << bitsToNotRead;
            result = (bytes[byteOffset] & mask) >> bitsToNotRead;
            numBits -= toRead;
            bitOffset += toRead;
            if (bitOffset === 8) {
                bitOffset = 0;
                byteOffset++;
            }
        }
        // Next read whole bytes
        if (numBits > 0) {
            while (numBits >= 8) {
                result = (result << 8) | (bytes[byteOffset] & 0xFF);
                byteOffset++;
                numBits -= 8;
            }
            // Finally read a partial byte
            if (numBits > 0) {
                var bitsToNotRead = 8 - numBits;
                var mask = (0xFF >> bitsToNotRead) << bitsToNotRead;
                result = (result << numBits) | ((bytes[byteOffset] & mask) >> bitsToNotRead);
                bitOffset += numBits;
            }
        }
        this.bitOffset = bitOffset;
        this.byteOffset = byteOffset;
        return result;
    };
    /**
     * @return number of bits that can be read successfully
     */
    BitSource.prototype.available = function () {
        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
    };
    return BitSource;
}());
exports.default = BitSource;
//# sourceMappingURL=BitSource.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/CharacterSetECI.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/CharacterSetECI.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common {*/
var FormatException_1 = __webpack_require__(/*! ../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
/*import java.util.HashMap;*/
/*import java.util.Map;*/
var CharacterSetValueIdentifiers;
(function (CharacterSetValueIdentifiers) {
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp437"] = 0] = "Cp437";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_1"] = 1] = "ISO8859_1";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_2"] = 2] = "ISO8859_2";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_3"] = 3] = "ISO8859_3";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_4"] = 4] = "ISO8859_4";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_5"] = 5] = "ISO8859_5";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_6"] = 6] = "ISO8859_6";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_7"] = 7] = "ISO8859_7";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_8"] = 8] = "ISO8859_8";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_9"] = 9] = "ISO8859_9";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_10"] = 10] = "ISO8859_10";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_11"] = 11] = "ISO8859_11";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_13"] = 12] = "ISO8859_13";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_14"] = 13] = "ISO8859_14";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_15"] = 14] = "ISO8859_15";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ISO8859_16"] = 15] = "ISO8859_16";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["SJIS"] = 16] = "SJIS";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1250"] = 17] = "Cp1250";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1251"] = 18] = "Cp1251";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1252"] = 19] = "Cp1252";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Cp1256"] = 20] = "Cp1256";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["UnicodeBigUnmarked"] = 21] = "UnicodeBigUnmarked";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["UTF8"] = 22] = "UTF8";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["ASCII"] = 23] = "ASCII";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["Big5"] = 24] = "Big5";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["GB18030"] = 25] = "GB18030";
    CharacterSetValueIdentifiers[CharacterSetValueIdentifiers["EUC_KR"] = 26] = "EUC_KR";
})(CharacterSetValueIdentifiers = exports.CharacterSetValueIdentifiers || (exports.CharacterSetValueIdentifiers = {}));
/**
 * Encapsulates a Character Set ECI, according to "Extended Channel Interpretations" 5.3.1.1
 * of ISO 18004.
 *
 * @author Sean Owen
 */
var CharacterSetECI = /** @class */ (function () {
    function CharacterSetECI(valueIdentifier, valuesParam, name) {
        var e_1, _a;
        var otherEncodingNames = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            otherEncodingNames[_i - 3] = arguments[_i];
        }
        this.valueIdentifier = valueIdentifier;
        this.name = name;
        if (typeof valuesParam === 'number') {
            this.values = Int32Array.from([valuesParam]);
        }
        else {
            this.values = valuesParam;
        }
        this.otherEncodingNames = otherEncodingNames;
        CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);
        CharacterSetECI.NAME_TO_ECI.set(name, this);
        var values = this.values;
        for (var i = 0, length_1 = values.length; i !== length_1; i++) {
            var v = values[i];
            CharacterSetECI.VALUES_TO_ECI.set(v, this);
        }
        try {
            for (var otherEncodingNames_1 = __values(otherEncodingNames), otherEncodingNames_1_1 = otherEncodingNames_1.next(); !otherEncodingNames_1_1.done; otherEncodingNames_1_1 = otherEncodingNames_1.next()) {
                var otherName = otherEncodingNames_1_1.value;
                CharacterSetECI.NAME_TO_ECI.set(otherName, this);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (otherEncodingNames_1_1 && !otherEncodingNames_1_1.done && (_a = otherEncodingNames_1.return)) _a.call(otherEncodingNames_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    // CharacterSetECI(value: number /*int*/) {
    //   this(new Int32Array {value})
    // }
    // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {
    //   this.values = new Int32Array {value}
    //   this.otherEncodingNames = otherEncodingNames
    // }
    // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {
    //   this.values = values
    //   this.otherEncodingNames = otherEncodingNames
    // }
    CharacterSetECI.prototype.getValueIdentifier = function () {
        return this.valueIdentifier;
    };
    CharacterSetECI.prototype.getName = function () {
        return this.name;
    };
    CharacterSetECI.prototype.getValue = function () {
        return this.values[0];
    };
    /**
     * @param value character set ECI value
     * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but
     *   unsupported
     * @throws FormatException if ECI value is invalid
     */
    CharacterSetECI.getCharacterSetECIByValue = function (value /*int*/) {
        if (value < 0 || value >= 900) {
            throw new FormatException_1.default('incorect value');
        }
        var characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);
        if (undefined === characterSet) {
            throw new FormatException_1.default('incorect value');
        }
        return characterSet;
    };
    /**
     * @param name character set ECI encoding name
     * @return CharacterSetECI representing ECI for character encoding, or null if it is legal
     *   but unsupported
     */
    CharacterSetECI.getCharacterSetECIByName = function (name) {
        var characterSet = CharacterSetECI.NAME_TO_ECI.get(name);
        if (undefined === characterSet) {
            throw new FormatException_1.default('incorect value');
        }
        return characterSet;
    };
    CharacterSetECI.prototype.equals = function (o) {
        if (!(o instanceof CharacterSetECI)) {
            return false;
        }
        var other = o;
        return this.getName() === other.getName();
    };
    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = new Map();
    CharacterSetECI.VALUES_TO_ECI = new Map();
    CharacterSetECI.NAME_TO_ECI = new Map();
    // Enum name is a Java encoding valid for java.lang and java.io
    // TYPESCRIPTPORT: changed the main label for ISO as the TextEncoder did not recognized them in the form from java
    // (eg ISO8859_1 must be ISO88591 or ISO8859-1 or ISO-8859-1)
    // later on: well, except 16 wich does not work with ISO885916 so used ISO-8859-1 form for default
    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), 'Cp437');
    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), 'ISO-8859-1', 'ISO88591', 'ISO8859_1');
    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, 'ISO-8859-2', 'ISO88592', 'ISO8859_2');
    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, 'ISO-8859-3', 'ISO88593', 'ISO8859_3');
    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, 'ISO-8859-4', 'ISO88594', 'ISO8859_4');
    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, 'ISO-8859-5', 'ISO88595', 'ISO8859_5');
    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, 'ISO-8859-6', 'ISO88596', 'ISO8859_6');
    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, 'ISO-8859-7', 'ISO88597', 'ISO8859_7');
    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, 'ISO-8859-8', 'ISO88598', 'ISO8859_8');
    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, 'ISO-8859-9', 'ISO88599', 'ISO8859_9');
    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, 'ISO-8859-10', 'ISO885910', 'ISO8859_10');
    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, 'ISO-8859-11', 'ISO885911', 'ISO8859_11');
    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, 'ISO-8859-13', 'ISO885913', 'ISO8859_13');
    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, 'ISO-8859-14', 'ISO885914', 'ISO8859_14');
    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, 'ISO-8859-15', 'ISO885915', 'ISO8859_15');
    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, 'ISO-8859-16', 'ISO885916', 'ISO8859_16');
    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, 'SJIS', 'Shift_JIS');
    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, 'Cp1250', 'windows-1250');
    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, 'Cp1251', 'windows-1251');
    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, 'Cp1252', 'windows-1252');
    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, 'Cp1256', 'windows-1256');
    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, 'UnicodeBigUnmarked', 'UTF-16BE', 'UnicodeBig');
    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, 'UTF8', 'UTF-8');
    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), 'ASCII', 'US-ASCII');
    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, 'Big5');
    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, 'GB18030', 'GB2312', 'EUC_CN', 'GBK');
    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, 'EUC_KR', 'EUC-KR');
    return CharacterSetECI;
}());
exports.default = CharacterSetECI;
//# sourceMappingURL=CharacterSetECI.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/DecoderResult.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/DecoderResult.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common {*/
/*import java.util.List;*/
/**
 * <p>Encapsulates the result of decoding a matrix of bits. This typically
 * applies to 2D barcode formats. For now it contains the raw bytes obtained,
 * as well as a String interpretation of those bytes, if applicable.</p>
 *
 * @author Sean Owen
 */
var DecoderResult = /** @class */ (function () {
    // public constructor(rawBytes: Uint8Array,
    //                      text: string,
    //                      List<Uint8Array> byteSegments,
    //                      String ecLevel) {
    //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)
    // }
    function DecoderResult(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber, structuredAppendParity) {
        if (structuredAppendSequenceNumber === void 0) { structuredAppendSequenceNumber = -1; }
        if (structuredAppendParity === void 0) { structuredAppendParity = -1; }
        this.rawBytes = rawBytes;
        this.text = text;
        this.byteSegments = byteSegments;
        this.ecLevel = ecLevel;
        this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;
        this.structuredAppendParity = structuredAppendParity;
        this.numBits = (rawBytes === undefined || rawBytes === null) ? 0 : 8 * rawBytes.length;
    }
    /**
     * @return raw bytes representing the result, or {@code null} if not applicable
     */
    DecoderResult.prototype.getRawBytes = function () {
        return this.rawBytes;
    };
    /**
     * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
     * @since 3.3.0
     */
    DecoderResult.prototype.getNumBits = function () {
        return this.numBits;
    };
    /**
     * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}
     * @since 3.3.0
     */
    DecoderResult.prototype.setNumBits = function (numBits /*int*/) {
        this.numBits = numBits;
    };
    /**
     * @return text representation of the result
     */
    DecoderResult.prototype.getText = function () {
        return this.text;
    };
    /**
     * @return list of byte segments in the result, or {@code null} if not applicable
     */
    DecoderResult.prototype.getByteSegments = function () {
        return this.byteSegments;
    };
    /**
     * @return name of error correction level used, or {@code null} if not applicable
     */
    DecoderResult.prototype.getECLevel = function () {
        return this.ecLevel;
    };
    /**
     * @return number of errors corrected, or {@code null} if not applicable
     */
    DecoderResult.prototype.getErrorsCorrected = function () {
        return this.errorsCorrected;
    };
    DecoderResult.prototype.setErrorsCorrected = function (errorsCorrected /*Integer*/) {
        this.errorsCorrected = errorsCorrected;
    };
    /**
     * @return number of erasures corrected, or {@code null} if not applicable
     */
    DecoderResult.prototype.getErasures = function () {
        return this.erasures;
    };
    DecoderResult.prototype.setErasures = function (erasures /*Integer*/) {
        this.erasures = erasures;
    };
    /**
     * @return arbitrary additional metadata
     */
    DecoderResult.prototype.getOther = function () {
        return this.other;
    };
    DecoderResult.prototype.setOther = function (other) {
        this.other = other;
    };
    DecoderResult.prototype.hasStructuredAppend = function () {
        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
    };
    DecoderResult.prototype.getStructuredAppendParity = function () {
        return this.structuredAppendParity;
    };
    DecoderResult.prototype.getStructuredAppendSequenceNumber = function () {
        return this.structuredAppendSequenceNumber;
    };
    return DecoderResult;
}());
exports.default = DecoderResult;
//# sourceMappingURL=DecoderResult.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/DefaultGridSampler.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/DefaultGridSampler.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common {*/
var GridSampler_1 = __webpack_require__(/*! ./GridSampler */ "./node_modules/@zxing/library/esm5/core/common/GridSampler.js");
var BitMatrix_1 = __webpack_require__(/*! ./BitMatrix */ "./node_modules/@zxing/library/esm5/core/common/BitMatrix.js");
var PerspectiveTransform_1 = __webpack_require__(/*! ./PerspectiveTransform */ "./node_modules/@zxing/library/esm5/core/common/PerspectiveTransform.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/**
 * @author Sean Owen
 */
var DefaultGridSampler = /** @class */ (function (_super) {
    __extends(DefaultGridSampler, _super);
    function DefaultGridSampler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*@Override*/
    DefaultGridSampler.prototype.sampleGrid = function (image, dimensionX /*int*/, dimensionY /*int*/, p1ToX /*float*/, p1ToY /*float*/, p2ToX /*float*/, p2ToY /*float*/, p3ToX /*float*/, p3ToY /*float*/, p4ToX /*float*/, p4ToY /*float*/, p1FromX /*float*/, p1FromY /*float*/, p2FromX /*float*/, p2FromY /*float*/, p3FromX /*float*/, p3FromY /*float*/, p4FromX /*float*/, p4FromY /*float*/) {
        var transform = PerspectiveTransform_1.default.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);
        return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);
    };
    /*@Override*/
    DefaultGridSampler.prototype.sampleGridWithTransform = function (image, dimensionX /*int*/, dimensionY /*int*/, transform) {
        if (dimensionX <= 0 || dimensionY <= 0) {
            throw new NotFoundException_1.default();
        }
        var bits = new BitMatrix_1.default(dimensionX, dimensionY);
        var points = new Float32Array(2 * dimensionX);
        for (var y = 0; y < dimensionY; y++) {
            var max = points.length;
            var iValue = y + 0.5;
            for (var x = 0; x < max; x += 2) {
                points[x] = (x / 2) + 0.5;
                points[x + 1] = iValue;
            }
            transform.transformPoints(points);
            // Quick check to see if points transformed to something inside the image
            // sufficient to check the endpoints
            GridSampler_1.default.checkAndNudgePoints(image, points);
            try {
                for (var x = 0; x < max; x += 2) {
                    if (image.get(Math.floor(points[x]), Math.floor(points[x + 1]))) {
                        // Black(-ish) pixel
                        bits.set(x / 2, y);
                    }
                }
            }
            catch (aioobe /*: ArrayIndexOutOfBoundsException*/) {
                // This feels wrong, but, sometimes if the finder patterns are misidentified, the resulting
                // transform gets "twisted" such that it maps a straight line of points to a set of points
                // whose endpoints are in bounds, but others are not. There is probably some mathematical
                // way to detect this about the transformation that I don't know yet.
                // This results in an ugly runtime exception despite our clever checks above -- can't have
                // that. We could check each point's coordinates but that feels duplicative. We settle for
                // catching and wrapping ArrayIndexOutOfBoundsException.
                throw new NotFoundException_1.default();
            }
        }
        return bits;
    };
    return DefaultGridSampler;
}(GridSampler_1.default));
exports.default = DefaultGridSampler;
//# sourceMappingURL=DefaultGridSampler.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/DetectorResult.js":
/*!************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/DetectorResult.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * <p>Encapsulates the result of detecting a barcode in an image. This includes the raw
 * matrix of black/white pixels corresponding to the barcode, and possibly points of interest
 * in the image, like the location of finder patterns or corners of the barcode in the image.</p>
 *
 * @author Sean Owen
 */
var DetectorResult = /** @class */ (function () {
    function DetectorResult(bits, points) {
        this.bits = bits;
        this.points = points;
    }
    DetectorResult.prototype.getBits = function () {
        return this.bits;
    };
    DetectorResult.prototype.getPoints = function () {
        return this.points;
    };
    return DetectorResult;
}());
exports.default = DetectorResult;
//# sourceMappingURL=DetectorResult.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/GlobalHistogramBinarizer.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/GlobalHistogramBinarizer.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common {*/
var Binarizer_1 = __webpack_require__(/*! ../Binarizer */ "./node_modules/@zxing/library/esm5/core/Binarizer.js");
var BitArray_1 = __webpack_require__(/*! ./BitArray */ "./node_modules/@zxing/library/esm5/core/common/BitArray.js");
var BitMatrix_1 = __webpack_require__(/*! ./BitMatrix */ "./node_modules/@zxing/library/esm5/core/common/BitMatrix.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/**
 * This Binarizer implementation uses the old ZXing global histogram approach. It is suitable
 * for low-end mobile devices which don't have enough CPU or memory to use a local thresholding
 * algorithm. However, because it picks a global black point, it cannot handle difficult shadows
 * and gradients.
 *
 * Faster mobile devices and all desktop applications should probably use HybridBinarizer instead.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 * @author Sean Owen
 */
var GlobalHistogramBinarizer = /** @class */ (function (_super) {
    __extends(GlobalHistogramBinarizer, _super);
    function GlobalHistogramBinarizer(source) {
        var _this = _super.call(this, source) || this;
        _this.luminances = GlobalHistogramBinarizer.EMPTY;
        _this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);
        return _this;
    }
    // Applies simple sharpening to the row data to improve performance of the 1D Readers.
    /*@Override*/
    GlobalHistogramBinarizer.prototype.getBlackRow = function (y /*int*/, row) {
        var source = this.getLuminanceSource();
        var width = source.getWidth();
        if (row === undefined || row === null || row.getSize() < width) {
            row = new BitArray_1.default(width);
        }
        else {
            row.clear();
        }
        this.initArrays(width);
        var localLuminances = source.getRow(y, this.luminances);
        var localBuckets = this.buckets;
        for (var x = 0; x < width; x++) {
            localBuckets[(localLuminances[x] & 0xff) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
        }
        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
        if (width < 3) {
            // Special case for very small images
            for (var x = 0; x < width; x++) {
                if ((localLuminances[x] & 0xff) < blackPoint) {
                    row.set(x);
                }
            }
        }
        else {
            var left = localLuminances[0] & 0xff;
            var center = localLuminances[1] & 0xff;
            for (var x = 1; x < width - 1; x++) {
                var right = localLuminances[x + 1] & 0xff;
                // A simple -1 4 -1 box filter with a weight of 2.
                if (((center * 4) - left - right) / 2 < blackPoint) {
                    row.set(x);
                }
                left = center;
                center = right;
            }
        }
        return row;
    };
    // Does not sharpen the data, as this call is intended to only be used by 2D Readers.
    /*@Override*/
    GlobalHistogramBinarizer.prototype.getBlackMatrix = function () {
        var source = this.getLuminanceSource();
        var width = source.getWidth();
        var height = source.getHeight();
        var matrix = new BitMatrix_1.default(width, height);
        // Quickly calculates the histogram by sampling four rows from the image. This proved to be
        // more robust on the blackbox tests than sampling a diagonal as we used to do.
        this.initArrays(width);
        var localBuckets = this.buckets;
        for (var y = 1; y < 5; y++) {
            var row = Math.floor((height * y) / 5);
            var localLuminances_1 = source.getRow(row, this.luminances);
            var right = Math.floor((width * 4) / 5);
            for (var x = Math.floor(width / 5); x < right; x++) {
                var pixel = localLuminances_1[x] & 0xff;
                localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
            }
        }
        var blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
        // We delay reading the entire image luminance until the black point estimation succeeds.
        // Although we end up reading four rows twice, it is consistent with our motto of
        // "fail quickly" which is necessary for continuous scanning.
        var localLuminances = source.getMatrix();
        for (var y = 0; y < height; y++) {
            var offset = y * width;
            for (var x = 0; x < width; x++) {
                var pixel = localLuminances[offset + x] & 0xff;
                if (pixel < blackPoint) {
                    matrix.set(x, y);
                }
            }
        }
        return matrix;
    };
    /*@Override*/
    GlobalHistogramBinarizer.prototype.createBinarizer = function (source) {
        return new GlobalHistogramBinarizer(source);
    };
    GlobalHistogramBinarizer.prototype.initArrays = function (luminanceSize /*int*/) {
        if (this.luminances.length < luminanceSize) {
            this.luminances = new Uint8ClampedArray(luminanceSize);
        }
        var buckets = this.buckets;
        for (var x = 0; x < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x++) {
            buckets[x] = 0;
        }
    };
    GlobalHistogramBinarizer.estimateBlackPoint = function (buckets) {
        // Find the tallest peak in the histogram.
        var numBuckets = buckets.length;
        var maxBucketCount = 0;
        var firstPeak = 0;
        var firstPeakSize = 0;
        for (var x = 0; x < numBuckets; x++) {
            if (buckets[x] > firstPeakSize) {
                firstPeak = x;
                firstPeakSize = buckets[x];
            }
            if (buckets[x] > maxBucketCount) {
                maxBucketCount = buckets[x];
            }
        }
        // Find the second-tallest peak which is somewhat far from the tallest peak.
        var secondPeak = 0;
        var secondPeakScore = 0;
        for (var x = 0; x < numBuckets; x++) {
            var distanceToBiggest = x - firstPeak;
            // Encourage more distant second peaks by multiplying by square of distance.
            var score = buckets[x] * distanceToBiggest * distanceToBiggest;
            if (score > secondPeakScore) {
                secondPeak = x;
                secondPeakScore = score;
            }
        }
        // Make sure firstPeak corresponds to the black peak.
        if (firstPeak > secondPeak) {
            var temp = firstPeak;
            firstPeak = secondPeak;
            secondPeak = temp;
        }
        // If there is too little contrast in the image to pick a meaningful black point, throw rather
        // than waste time trying to decode the image, and risk false positives.
        if (secondPeak - firstPeak <= numBuckets / 16) {
            throw new NotFoundException_1.default();
        }
        // Find a valley between them that is low and closer to the white peak.
        var bestValley = secondPeak - 1;
        var bestValleyScore = -1;
        for (var x = secondPeak - 1; x > firstPeak; x--) {
            var fromFirst = x - firstPeak;
            var score = fromFirst * fromFirst * (secondPeak - x) * (maxBucketCount - buckets[x]);
            if (score > bestValleyScore) {
                bestValley = x;
                bestValleyScore = score;
            }
        }
        return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;
    };
    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;
    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);
    return GlobalHistogramBinarizer;
}(Binarizer_1.default));
exports.default = GlobalHistogramBinarizer;
//# sourceMappingURL=GlobalHistogramBinarizer.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/GridSampler.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/GridSampler.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/**
 * Implementations of this class can, given locations of finder patterns for a QR code in an
 * image, sample the right points in the image to reconstruct the QR code, accounting for
 * perspective distortion. It is abstracted since it is relatively expensive and should be allowed
 * to take advantage of platform-specific optimized implementations, like Sun's Java Advanced
 * Imaging library, but which may not be available in other environments such as J2ME, and vice
 * versa.
 *
 * The implementation used can be controlled by calling {@link #setGridSampler(GridSampler)}
 * with an instance of a class which implements this interface.
 *
 * @author Sean Owen
 */
var GridSampler = /** @class */ (function () {
    function GridSampler() {
    }
    /**
     * <p>Checks a set of points that have been transformed to sample points on an image against
     * the image's dimensions to see if the point are even within the image.</p>
     *
     * <p>This method will actually "nudge" the endpoints back onto the image if they are found to be
     * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder
     * patterns in an image where the QR Code runs all the way to the image border.</p>
     *
     * <p>For efficiency, the method will check points from either end of the line until one is found
     * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>
     *
     * @param image image into which the points should map
     * @param points actual points in x1,y1,...,xn,yn form
     * @throws NotFoundException if an endpoint is lies outside the image boundaries
     */
    GridSampler.checkAndNudgePoints = function (image, points) {
        var width = image.getWidth();
        var height = image.getHeight();
        // Check and nudge points from start until we see some that are OK:
        var nudged = true;
        for (var offset = 0; offset < points.length && nudged; offset += 2) {
            var x = Math.floor(points[offset]);
            var y = Math.floor(points[offset + 1]);
            if (x < -1 || x > width || y < -1 || y > height) {
                throw new NotFoundException_1.default();
            }
            nudged = false;
            if (x === -1) {
                points[offset] = 0.0;
                nudged = true;
            }
            else if (x === width) {
                points[offset] = width - 1;
                nudged = true;
            }
            if (y === -1) {
                points[offset + 1] = 0.0;
                nudged = true;
            }
            else if (y === height) {
                points[offset + 1] = height - 1;
                nudged = true;
            }
        }
        // Check and nudge points from end:
        nudged = true;
        for (var offset = points.length - 2; offset >= 0 && nudged; offset -= 2) {
            var x = Math.floor(points[offset]);
            var y = Math.floor(points[offset + 1]);
            if (x < -1 || x > width || y < -1 || y > height) {
                throw new NotFoundException_1.default();
            }
            nudged = false;
            if (x === -1) {
                points[offset] = 0.0;
                nudged = true;
            }
            else if (x === width) {
                points[offset] = width - 1;
                nudged = true;
            }
            if (y === -1) {
                points[offset + 1] = 0.0;
                nudged = true;
            }
            else if (y === height) {
                points[offset + 1] = height - 1;
                nudged = true;
            }
        }
    };
    return GridSampler;
}());
exports.default = GridSampler;
//# sourceMappingURL=GridSampler.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/GridSamplerInstance.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/GridSamplerInstance.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DefaultGridSampler_1 = __webpack_require__(/*! ./DefaultGridSampler */ "./node_modules/@zxing/library/esm5/core/common/DefaultGridSampler.js");
var GridSamplerInstance = /** @class */ (function () {
    function GridSamplerInstance() {
    }
    /**
     * Sets the implementation of GridSampler used by the library. One global
     * instance is stored, which may sound problematic. But, the implementation provided
     * ought to be appropriate for the entire platform, and all uses of this library
     * in the whole lifetime of the JVM. For instance, an Android activity can swap in
     * an implementation that takes advantage of native platform libraries.
     *
     * @param newGridSampler The platform-specific object to install.
     */
    GridSamplerInstance.setGridSampler = function (newGridSampler) {
        GridSamplerInstance.gridSampler = newGridSampler;
    };
    /**
     * @return the current implementation of GridSampler
     */
    GridSamplerInstance.getInstance = function () {
        return GridSamplerInstance.gridSampler;
    };
    GridSamplerInstance.gridSampler = new DefaultGridSampler_1.default();
    return GridSamplerInstance;
}());
exports.default = GridSamplerInstance;
//# sourceMappingURL=GridSamplerInstance.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/HybridBinarizer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/HybridBinarizer.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GlobalHistogramBinarizer_1 = __webpack_require__(/*! ./GlobalHistogramBinarizer */ "./node_modules/@zxing/library/esm5/core/common/GlobalHistogramBinarizer.js");
var BitMatrix_1 = __webpack_require__(/*! ./BitMatrix */ "./node_modules/@zxing/library/esm5/core/common/BitMatrix.js");
/**
 * This class implements a local thresholding algorithm, which while slower than the
 * GlobalHistogramBinarizer, is fairly efficient for what it does. It is designed for
 * high frequency images of barcodes with black data on white backgrounds. For this application,
 * it does a much better job than a global blackpoint with severe shadows and gradients.
 * However it tends to produce artifacts on lower frequency images and is therefore not
 * a good general purpose binarizer for uses outside ZXing.
 *
 * This class extends GlobalHistogramBinarizer, using the older histogram approach for 1D readers,
 * and the newer local approach for 2D readers. 1D decoding using a per-row histogram is already
 * inherently local, and only fails for horizontal gradients. We can revisit that problem later,
 * but for now it was not a win to use local blocks for 1D.
 *
 * This Binarizer is the default for the unit tests and the recommended class for library users.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 */
var HybridBinarizer = /** @class */ (function (_super) {
    __extends(HybridBinarizer, _super);
    function HybridBinarizer(source) {
        var _this = _super.call(this, source) || this;
        _this.matrix = null;
        return _this;
    }
    /**
     * Calculates the final BitMatrix once for all requests. This could be called once from the
     * constructor instead, but there are some advantages to doing it lazily, such as making
     * profiling easier, and not doing heavy lifting when callers don't expect it.
     */
    /*@Override*/
    HybridBinarizer.prototype.getBlackMatrix = function () {
        if (this.matrix !== null) {
            return this.matrix;
        }
        var source = this.getLuminanceSource();
        var width = source.getWidth();
        var height = source.getHeight();
        if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {
            var luminances = source.getMatrix();
            var subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;
            if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
                subWidth++;
            }
            var subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;
            if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
                subHeight++;
            }
            var blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);
            var newMatrix = new BitMatrix_1.default(width, height);
            HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);
            this.matrix = newMatrix;
        }
        else {
            // If the image is too small, fall back to the global histogram approach.
            this.matrix = _super.prototype.getBlackMatrix.call(this);
        }
        return this.matrix;
    };
    /*@Override*/
    HybridBinarizer.prototype.createBinarizer = function (source) {
        return new HybridBinarizer(source);
    };
    /**
     * For each block in the image, calculate the average black point using a 5x5 grid
     * of the blocks around it. Also handles the corner cases (fractional blocks are computed based
     * on the last pixels in the row/column which are also used in the previous block).
     */
    HybridBinarizer.calculateThresholdForBlock = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/, blackPoints, matrix) {
        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
        for (var y = 0; y < subHeight; y++) {
            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
            if (yoffset > maxYOffset) {
                yoffset = maxYOffset;
            }
            var top_1 = HybridBinarizer.cap(y, 2, subHeight - 3);
            for (var x = 0; x < subWidth; x++) {
                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
                if (xoffset > maxXOffset) {
                    xoffset = maxXOffset;
                }
                var left = HybridBinarizer.cap(x, 2, subWidth - 3);
                var sum = 0;
                for (var z = -2; z <= 2; z++) {
                    var blackRow = blackPoints[top_1 + z];
                    sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];
                }
                var average = sum / 25;
                HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
            }
        }
    };
    HybridBinarizer.cap = function (value /*int*/, min /*int*/, max /*int*/) {
        return value < min ? min : value > max ? max : value;
    };
    /**
     * Applies a single threshold to a block of pixels.
     */
    HybridBinarizer.thresholdBlock = function (luminances, xoffset /*int*/, yoffset /*int*/, threshold /*int*/, stride /*int*/, matrix) {
        for (var y = 0, offset = yoffset * stride + xoffset; y < HybridBinarizer.BLOCK_SIZE; y++, offset += stride) {
            for (var x = 0; x < HybridBinarizer.BLOCK_SIZE; x++) {
                // Comparison needs to be <= so that black == 0 pixels are black even if the threshold is 0.
                if ((luminances[offset + x] & 0xFF) <= threshold) {
                    matrix.set(xoffset + x, yoffset + y);
                }
            }
        }
    };
    /**
     * Calculates a single black point for each block of pixels and saves it away.
     * See the following thread for a discussion of this algorithm:
     *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
     */
    HybridBinarizer.calculateBlackPoints = function (luminances, subWidth /*int*/, subHeight /*int*/, width /*int*/, height /*int*/) {
        var maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
        var maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
        // tslint:disable-next-line:whitespace
        var blackPoints = new Array(subHeight); // subWidth
        for (var y = 0; y < subHeight; y++) {
            blackPoints[y] = new Int32Array(subWidth);
            var yoffset = y << HybridBinarizer.BLOCK_SIZE_POWER;
            if (yoffset > maxYOffset) {
                yoffset = maxYOffset;
            }
            for (var x = 0; x < subWidth; x++) {
                var xoffset = x << HybridBinarizer.BLOCK_SIZE_POWER;
                if (xoffset > maxXOffset) {
                    xoffset = maxXOffset;
                }
                var sum = 0;
                var min = 0xFF;
                var max = 0;
                for (var yy = 0, offset = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
                    for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                        var pixel = luminances[offset + xx] & 0xFF;
                        sum += pixel;
                        // still looking for good contrast
                        if (pixel < min) {
                            min = pixel;
                        }
                        if (pixel > max) {
                            max = pixel;
                        }
                    }
                    // short-circuit min/max tests once dynamic range is met
                    if (max - min > HybridBinarizer.MIN_DYNAMIC_RANGE) {
                        // finish the rest of the rows quickly
                        for (yy++, offset += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset += width) {
                            for (var xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                                sum += luminances[offset + xx] & 0xFF;
                            }
                        }
                    }
                }
                // The default estimate is the average of the values in the block.
                var average = sum >> (HybridBinarizer.BLOCK_SIZE_POWER * 2);
                if (max - min <= HybridBinarizer.MIN_DYNAMIC_RANGE) {
                    // If variation within the block is low, assume this is a block with only light or only
                    // dark pixels. In that case we do not want to use the average, as it would divide this
                    // low contrast area into black and white pixels, essentially creating data out of noise.
                    //
                    // The default assumption is that the block is light/background. Since no estimate for
                    // the level of dark pixels exists locally, use half the min for the block.
                    average = min / 2;
                    if (y > 0 && x > 0) {
                        // Correct the "white background" assumption for blocks that have neighbors by comparing
                        // the pixels in this block to the previously calculated black points. This is based on
                        // the fact that dark barcode symbology is always surrounded by some amount of light
                        // background for which reasonable black point estimates were made. The bp estimated at
                        // the boundaries is used for the interior.
                        // The (min < bp) is arbitrary but works better than other heuristics that were tried.
                        var averageNeighborBlackPoint = (blackPoints[y - 1][x] + (2 * blackPoints[y][x - 1]) + blackPoints[y - 1][x - 1]) / 4;
                        if (min < averageNeighborBlackPoint) {
                            average = averageNeighborBlackPoint;
                        }
                    }
                }
                blackPoints[y][x] = average;
            }
        }
        return blackPoints;
    };
    // This class uses 5x5 blocks to compute local luminance, where each block is 8x8 pixels.
    // So this is the smallest dimension in each axis we can accept.
    HybridBinarizer.BLOCK_SIZE_POWER = 3;
    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER; // ...0100...00
    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1; // ...0011...11
    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;
    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;
    return HybridBinarizer;
}(GlobalHistogramBinarizer_1.default));
exports.default = HybridBinarizer;
//# sourceMappingURL=HybridBinarizer.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/PerspectiveTransform.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/PerspectiveTransform.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common {*/
/**
 * <p>This class implements a perspective transform in two dimensions. Given four source and four
 * destination points, it will compute the transformation implied between them. The code is based
 * directly upon section 3.4.2 of George Wolberg's "Digital Image Warping"; see pages 54-56.</p>
 *
 * @author Sean Owen
 */
var PerspectiveTransform = /** @class */ (function () {
    function PerspectiveTransform(a11 /*float*/, a21 /*float*/, a31 /*float*/, a12 /*float*/, a22 /*float*/, a32 /*float*/, a13 /*float*/, a23 /*float*/, a33 /*float*/) {
        this.a11 = a11;
        this.a21 = a21;
        this.a31 = a31;
        this.a12 = a12;
        this.a22 = a22;
        this.a32 = a32;
        this.a13 = a13;
        this.a23 = a23;
        this.a33 = a33;
    }
    PerspectiveTransform.quadrilateralToQuadrilateral = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/, x0p /*float*/, y0p /*float*/, x1p /*float*/, y1p /*float*/, x2p /*float*/, y2p /*float*/, x3p /*float*/, y3p /*float*/) {
        var qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x2, y2, x3, y3);
        var sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
        return sToQ.times(qToS);
    };
    PerspectiveTransform.prototype.transformPoints = function (points) {
        var max = points.length;
        var a11 = this.a11;
        var a12 = this.a12;
        var a13 = this.a13;
        var a21 = this.a21;
        var a22 = this.a22;
        var a23 = this.a23;
        var a31 = this.a31;
        var a32 = this.a32;
        var a33 = this.a33;
        for (var i = 0; i < max; i += 2) {
            var x = points[i];
            var y = points[i + 1];
            var denominator = a13 * x + a23 * y + a33;
            points[i] = (a11 * x + a21 * y + a31) / denominator;
            points[i + 1] = (a12 * x + a22 * y + a32) / denominator;
        }
    };
    PerspectiveTransform.prototype.transformPointsWithValues = function (xValues, yValues) {
        var a11 = this.a11;
        var a12 = this.a12;
        var a13 = this.a13;
        var a21 = this.a21;
        var a22 = this.a22;
        var a23 = this.a23;
        var a31 = this.a31;
        var a32 = this.a32;
        var a33 = this.a33;
        var n = xValues.length;
        for (var i = 0; i < n; i++) {
            var x = xValues[i];
            var y = yValues[i];
            var denominator = a13 * x + a23 * y + a33;
            xValues[i] = (a11 * x + a21 * y + a31) / denominator;
            yValues[i] = (a12 * x + a22 * y + a32) / denominator;
        }
    };
    PerspectiveTransform.squareToQuadrilateral = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {
        var dx3 = x0 - x1 + x2 - x3;
        var dy3 = y0 - y1 + y2 - y3;
        if (dx3 === 0.0 && dy3 === 0.0) {
            // Affine
            return new PerspectiveTransform(x1 - x0, x2 - x1, x0, y1 - y0, y2 - y1, y0, 0.0, 0.0, 1.0);
        }
        else {
            var dx1 = x1 - x2;
            var dx2 = x3 - x2;
            var dy1 = y1 - y2;
            var dy2 = y3 - y2;
            var denominator = dx1 * dy2 - dx2 * dy1;
            var a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
            var a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
            return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y3 - y0 + a23 * y3, y0, a13, a23, 1.0);
        }
    };
    PerspectiveTransform.quadrilateralToSquare = function (x0 /*float*/, y0 /*float*/, x1 /*float*/, y1 /*float*/, x2 /*float*/, y2 /*float*/, x3 /*float*/, y3 /*float*/) {
        // Here, the adjoint serves as the inverse:
        return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x2, y2, x3, y3).buildAdjoint();
    };
    PerspectiveTransform.prototype.buildAdjoint = function () {
        // Adjoint is the transpose of the cofactor matrix:
        return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
    };
    PerspectiveTransform.prototype.times = function (other) {
        return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
    };
    return PerspectiveTransform;
}());
exports.default = PerspectiveTransform;
//# sourceMappingURL=PerspectiveTransform.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/StringUtils.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/StringUtils.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2010 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common {*/
/*import java.nio.charset.Charset;*/
/*import java.util.Map;*/
var DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var CharacterSetECI_1 = __webpack_require__(/*! ./CharacterSetECI */ "./node_modules/@zxing/library/esm5/core/common/CharacterSetECI.js");
var StringEncoding_1 = __webpack_require__(/*! ../util/StringEncoding */ "./node_modules/@zxing/library/esm5/core/util/StringEncoding.js");
/**
 * Common string-related functions.
 *
 * @author Sean Owen
 * @author Alex Dupre
 */
var StringUtils = /** @class */ (function () {
    function StringUtils() {
    }
    // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||
    // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);
    StringUtils.castAsNonUtf8Char = function (code, encoding) {
        if (encoding === void 0) { encoding = null; }
        // ISO 8859-1 is the Java default as UTF-8 is JavaScripts
        // you can see this method as a Java version of String.fromCharCode
        var e = encoding ? encoding.getName() : this.ISO88591;
        // use passed format (fromCharCode will return UTF8 encoding)
        return StringEncoding_1.default.decode(new Uint8Array([code]), e);
    };
    /**
     * @param bytes bytes encoding a string, whose encoding should be guessed
     * @param hints decode hints if applicable
     * @return name of guessed encoding; at the moment will only guess one of:
     *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform
     *  default encoding if none of these can possibly be correct
     */
    StringUtils.guessEncoding = function (bytes, hints) {
        if (hints !== null && hints !== undefined && undefined !== hints.get(DecodeHintType_1.default.CHARACTER_SET)) {
            return hints.get(DecodeHintType_1.default.CHARACTER_SET).toString();
        }
        // For now, merely tries to distinguish ISO-8859-1, UTF-8 and Shift_JIS,
        // which should be by far the most common encodings.
        var length = bytes.length;
        var canBeISO88591 = true;
        var canBeShiftJIS = true;
        var canBeUTF8 = true;
        var utf8BytesLeft = 0;
        // int utf8LowChars = 0
        var utf2BytesChars = 0;
        var utf3BytesChars = 0;
        var utf4BytesChars = 0;
        var sjisBytesLeft = 0;
        // int sjisLowChars = 0
        var sjisKatakanaChars = 0;
        // int sjisDoubleBytesChars = 0
        var sjisCurKatakanaWordLength = 0;
        var sjisCurDoubleBytesWordLength = 0;
        var sjisMaxKatakanaWordLength = 0;
        var sjisMaxDoubleBytesWordLength = 0;
        // int isoLowChars = 0
        // int isoHighChars = 0
        var isoHighOther = 0;
        var utf8bom = bytes.length > 3 &&
            bytes[0] === /*(byte) */ 0xEF &&
            bytes[1] === /*(byte) */ 0xBB &&
            bytes[2] === /*(byte) */ 0xBF;
        for (var i = 0; i < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i++) {
            var value = bytes[i] & 0xFF;
            // UTF-8 stuff
            if (canBeUTF8) {
                if (utf8BytesLeft > 0) {
                    if ((value & 0x80) === 0) {
                        canBeUTF8 = false;
                    }
                    else {
                        utf8BytesLeft--;
                    }
                }
                else if ((value & 0x80) !== 0) {
                    if ((value & 0x40) === 0) {
                        canBeUTF8 = false;
                    }
                    else {
                        utf8BytesLeft++;
                        if ((value & 0x20) === 0) {
                            utf2BytesChars++;
                        }
                        else {
                            utf8BytesLeft++;
                            if ((value & 0x10) === 0) {
                                utf3BytesChars++;
                            }
                            else {
                                utf8BytesLeft++;
                                if ((value & 0x08) === 0) {
                                    utf4BytesChars++;
                                }
                                else {
                                    canBeUTF8 = false;
                                }
                            }
                        }
                    }
                } // else {
                // utf8LowChars++
                // }
            }
            // ISO-8859-1 stuff
            if (canBeISO88591) {
                if (value > 0x7F && value < 0xA0) {
                    canBeISO88591 = false;
                }
                else if (value > 0x9F) {
                    if (value < 0xC0 || value === 0xD7 || value === 0xF7) {
                        isoHighOther++;
                    } // else {
                    // isoHighChars++
                    // }
                } // else {
                // isoLowChars++
                // }
            }
            // Shift_JIS stuff
            if (canBeShiftJIS) {
                if (sjisBytesLeft > 0) {
                    if (value < 0x40 || value === 0x7F || value > 0xFC) {
                        canBeShiftJIS = false;
                    }
                    else {
                        sjisBytesLeft--;
                    }
                }
                else if (value === 0x80 || value === 0xA0 || value > 0xEF) {
                    canBeShiftJIS = false;
                }
                else if (value > 0xA0 && value < 0xE0) {
                    sjisKatakanaChars++;
                    sjisCurDoubleBytesWordLength = 0;
                    sjisCurKatakanaWordLength++;
                    if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
                        sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
                    }
                }
                else if (value > 0x7F) {
                    sjisBytesLeft++;
                    // sjisDoubleBytesChars++
                    sjisCurKatakanaWordLength = 0;
                    sjisCurDoubleBytesWordLength++;
                    if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
                        sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
                    }
                }
                else {
                    // sjisLowChars++
                    sjisCurKatakanaWordLength = 0;
                    sjisCurDoubleBytesWordLength = 0;
                }
            }
        }
        if (canBeUTF8 && utf8BytesLeft > 0) {
            canBeUTF8 = false;
        }
        if (canBeShiftJIS && sjisBytesLeft > 0) {
            canBeShiftJIS = false;
        }
        // Easy -- if there is BOM or at least 1 valid not-single byte character (and no evidence it can't be UTF-8), done
        if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
            return StringUtils.UTF8;
        }
        // Easy -- if assuming Shift_JIS or at least 3 valid consecutive not-ascii characters (and no evidence it can't be), done
        if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {
            return StringUtils.SHIFT_JIS;
        }
        // Distinguishing Shift_JIS and ISO-8859-1 can be a little tough for short words. The crude heuristic is:
        // - If we saw
        //   - only two consecutive katakana chars in the whole text, or
        //   - at least 10% of bytes that could be "upper" not-alphanumeric Latin1,
        // - then we conclude Shift_JIS, else ISO-8859-1
        if (canBeISO88591 && canBeShiftJIS) {
            return (sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2) || isoHighOther * 10 >= length
                ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;
        }
        // Otherwise, try in order ISO-8859-1, Shift JIS, UTF-8 and fall back to default platform encoding
        if (canBeISO88591) {
            return StringUtils.ISO88591;
        }
        if (canBeShiftJIS) {
            return StringUtils.SHIFT_JIS;
        }
        if (canBeUTF8) {
            return StringUtils.UTF8;
        }
        // Otherwise, we take a wild guess with platform encoding
        return StringUtils.PLATFORM_DEFAULT_ENCODING;
    };
    /**
     *
     * @see https://stackoverflow.com/a/13439711/4367683
     *
     * @param append The new string to append.
     * @param args Argumets values to be formated.
     */
    StringUtils.format = function (append) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var i = -1;
        function callback(exp, p0, p1, p2, p3, p4) {
            if (exp === '%%')
                return '%';
            if (args[++i] === undefined)
                return undefined;
            exp = p2 ? parseInt(p2.substr(1)) : undefined;
            var base = p3 ? parseInt(p3.substr(1)) : undefined;
            var val;
            switch (p4) {
                case 's':
                    val = args[i];
                    break;
                case 'c':
                    val = args[i][0];
                    break;
                case 'f':
                    val = parseFloat(args[i]).toFixed(exp);
                    break;
                case 'p':
                    val = parseFloat(args[i]).toPrecision(exp);
                    break;
                case 'e':
                    val = parseFloat(args[i]).toExponential(exp);
                    break;
                case 'x':
                    val = parseInt(args[i]).toString(base ? base : 16);
                    break;
                case 'd':
                    val = parseFloat(parseInt(args[i], base ? base : 10).toPrecision(exp)).toFixed(0);
                    break;
            }
            val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);
            var size = parseInt(p1); /* padding size */
            var ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */
            while (val.length < size)
                val = p0 !== undefined ? val + ch : ch + val; /* isminus? */
            return val;
        }
        var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
        return append.replace(regex, callback);
    };
    /**
     *
     */
    StringUtils.getBytes = function (str, encoding) {
        return StringEncoding_1.default.encode(str, encoding);
    };
    /**
     * Returns the charcode at the specified index or at index zero.
     */
    StringUtils.getCharCode = function (str, index) {
        if (index === void 0) { index = 0; }
        return str.charCodeAt(index);
    };
    /**
     * Returns char for given charcode
     */
    StringUtils.getCharAt = function (charCode) {
        return String.fromCharCode(charCode);
    };
    StringUtils.SHIFT_JIS = CharacterSetECI_1.default.SJIS.getName(); // "SJIS"
    StringUtils.GB2312 = 'GB2312';
    StringUtils.ISO88591 = CharacterSetECI_1.default.ISO8859_1.getName(); // "ISO8859_1"
    StringUtils.EUC_JP = 'EUC_JP';
    StringUtils.UTF8 = CharacterSetECI_1.default.UTF8.getName(); // "UTF8"
    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8; // "UTF8"//Charset.defaultCharset().name()
    StringUtils.ASSUME_SHIFT_JIS = false;
    return StringUtils;
}());
exports.default = StringUtils;
//# sourceMappingURL=StringUtils.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2012 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common.detector {*/
/**
 * General math-related and numeric utility functions.
 */
var MathUtils = /** @class */ (function () {
    function MathUtils() {
    }
    MathUtils.prototype.MathUtils = function () {
    };
    /**
     * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its
     * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut
     * differ slightly from {@link Math#round(float)} in that half rounds down for negative
     * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.
     *
     * @param d real value to round
     * @return nearest {@code int}
     */
    MathUtils.round = function (d /*float*/) {
        if (NaN === d)
            return 0;
        if (d <= Number.MIN_SAFE_INTEGER)
            return Number.MIN_SAFE_INTEGER;
        if (d >= Number.MAX_SAFE_INTEGER)
            return Number.MAX_SAFE_INTEGER;
        return /*(int) */ (d + (d < 0.0 ? -0.5 : 0.5)) | 0;
    };
    // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js
    /**
     * @param aX point A x coordinate
     * @param aY point A y coordinate
     * @param bX point B x coordinate
     * @param bY point B y coordinate
     * @return Euclidean distance between points A and B
     */
    MathUtils.distance = function (aX /*float|int*/, aY /*float|int*/, bX /*float|int*/, bY /*float|int*/) {
        var xDiff = aX - bX;
        var yDiff = aY - bY;
        return /*(float) */ Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    };
    /**
     * @param aX point A x coordinate
     * @param aY point A y coordinate
     * @param bX point B x coordinate
     * @param bY point B y coordinate
     * @return Euclidean distance between points A and B
     */
    // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {
    //   const xDiff = aX - bX
    //   const yDiff = aY - bY
    //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    // }
    /**
     * @param array values to sum
     * @return sum of values in array
     */
    MathUtils.sum = function (array) {
        var count = 0;
        for (var i = 0, length_1 = array.length; i !== length_1; i++) {
            var a = array[i];
            count += a;
        }
        return count;
    };
    return MathUtils;
}());
exports.default = MathUtils;
//# sourceMappingURL=MathUtils.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/detector/WhiteRectangleDetector.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/detector/WhiteRectangleDetector.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2010 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common.detector {*/
var ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var MathUtils_1 = __webpack_require__(/*! ./MathUtils */ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js");
var NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/**
 * <p>
 * Detects a candidate barcode-like rectangular region within an image. It
 * starts around the center of the image, increases the size of the candidate
 * region until it finds a white rectangular region. By keeping track of the
 * last black points it encountered, it determines the corners of the barcode.
 * </p>
 *
 * @author David Olivier
 */
var WhiteRectangleDetector = /** @class */ (function () {
    // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {
    //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)
    // }
    /**
     * @param image barcode image to find a rectangle in
     * @param initSize initial size of search area around center
     * @param x x position of search center
     * @param y y position of search center
     * @throws NotFoundException if image is too small to accommodate {@code initSize}
     */
    function WhiteRectangleDetector(image, initSize /*int*/, x /*int*/, y /*int*/) {
        this.image = image;
        this.height = image.getHeight();
        this.width = image.getWidth();
        if (undefined === initSize || null === initSize) {
            initSize = WhiteRectangleDetector.INIT_SIZE;
        }
        if (undefined === x || null === x) {
            x = image.getWidth() / 2 | 0;
        }
        if (undefined === y || null === y) {
            y = image.getHeight() / 2 | 0;
        }
        var halfsize = initSize / 2 | 0;
        this.leftInit = x - halfsize;
        this.rightInit = x + halfsize;
        this.upInit = y - halfsize;
        this.downInit = y + halfsize;
        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {
            throw new NotFoundException_1.default();
        }
    }
    /**
     * <p>
     * Detects a candidate barcode-like rectangular region within an image. It
     * starts around the center of the image, increases the size of the candidate
     * region until it finds a white rectangular region.
     * </p>
     *
     * @return {@link ResultPoint}[] describing the corners of the rectangular
     *         region. The first and last points are opposed on the diagonal, as
     *         are the second and third. The first point will be the topmost
     *         point and the last, the bottommost. The second point will be
     *         leftmost and the third, the rightmost
     * @throws NotFoundException if no Data Matrix Code can be found
     */
    WhiteRectangleDetector.prototype.detect = function () {
        var left = this.leftInit;
        var right = this.rightInit;
        var up = this.upInit;
        var down = this.downInit;
        var sizeExceeded = false;
        var aBlackPointFoundOnBorder = true;
        var atLeastOneBlackPointFoundOnBorder = false;
        var atLeastOneBlackPointFoundOnRight = false;
        var atLeastOneBlackPointFoundOnBottom = false;
        var atLeastOneBlackPointFoundOnLeft = false;
        var atLeastOneBlackPointFoundOnTop = false;
        var width = this.width;
        var height = this.height;
        while (aBlackPointFoundOnBorder) {
            aBlackPointFoundOnBorder = false;
            // .....
            // .   |
            // .....
            var rightBorderNotWhite = true;
            while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {
                rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);
                if (rightBorderNotWhite) {
                    right++;
                    aBlackPointFoundOnBorder = true;
                    atLeastOneBlackPointFoundOnRight = true;
                }
                else if (!atLeastOneBlackPointFoundOnRight) {
                    right++;
                }
            }
            if (right >= width) {
                sizeExceeded = true;
                break;
            }
            // .....
            // .   .
            // .___.
            var bottomBorderNotWhite = true;
            while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {
                bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);
                if (bottomBorderNotWhite) {
                    down++;
                    aBlackPointFoundOnBorder = true;
                    atLeastOneBlackPointFoundOnBottom = true;
                }
                else if (!atLeastOneBlackPointFoundOnBottom) {
                    down++;
                }
            }
            if (down >= height) {
                sizeExceeded = true;
                break;
            }
            // .....
            // |   .
            // .....
            var leftBorderNotWhite = true;
            while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {
                leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);
                if (leftBorderNotWhite) {
                    left--;
                    aBlackPointFoundOnBorder = true;
                    atLeastOneBlackPointFoundOnLeft = true;
                }
                else if (!atLeastOneBlackPointFoundOnLeft) {
                    left--;
                }
            }
            if (left < 0) {
                sizeExceeded = true;
                break;
            }
            // .___.
            // .   .
            // .....
            var topBorderNotWhite = true;
            while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {
                topBorderNotWhite = this.containsBlackPoint(left, right, up, true);
                if (topBorderNotWhite) {
                    up--;
                    aBlackPointFoundOnBorder = true;
                    atLeastOneBlackPointFoundOnTop = true;
                }
                else if (!atLeastOneBlackPointFoundOnTop) {
                    up--;
                }
            }
            if (up < 0) {
                sizeExceeded = true;
                break;
            }
            if (aBlackPointFoundOnBorder) {
                atLeastOneBlackPointFoundOnBorder = true;
            }
        }
        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {
            var maxSize = right - left;
            var z = null;
            for (var i = 1; z === null && i < maxSize; i++) {
                z = this.getBlackPointOnSegment(left, down - i, left + i, down);
            }
            if (z == null) {
                throw new NotFoundException_1.default();
            }
            var t = null;
            // go down right
            for (var i = 1; t === null && i < maxSize; i++) {
                t = this.getBlackPointOnSegment(left, up + i, left + i, up);
            }
            if (t == null) {
                throw new NotFoundException_1.default();
            }
            var x = null;
            // go down left
            for (var i = 1; x === null && i < maxSize; i++) {
                x = this.getBlackPointOnSegment(right, up + i, right - i, up);
            }
            if (x == null) {
                throw new NotFoundException_1.default();
            }
            var y = null;
            // go up left
            for (var i = 1; y === null && i < maxSize; i++) {
                y = this.getBlackPointOnSegment(right, down - i, right - i, down);
            }
            if (y == null) {
                throw new NotFoundException_1.default();
            }
            return this.centerEdges(y, z, x, t);
        }
        else {
            throw new NotFoundException_1.default();
        }
    };
    WhiteRectangleDetector.prototype.getBlackPointOnSegment = function (aX /*float*/, aY /*float*/, bX /*float*/, bY /*float*/) {
        var dist = MathUtils_1.default.round(MathUtils_1.default.distance(aX, aY, bX, bY));
        var xStep = (bX - aX) / dist;
        var yStep = (bY - aY) / dist;
        var image = this.image;
        for (var i = 0; i < dist; i++) {
            var x = MathUtils_1.default.round(aX + i * xStep);
            var y = MathUtils_1.default.round(aY + i * yStep);
            if (image.get(x, y)) {
                return new ResultPoint_1.default(x, y);
            }
        }
        return null;
    };
    /**
     * recenters the points of a constant distance towards the center
     *
     * @param y bottom most point
     * @param z left most point
     * @param x right most point
     * @param t top most point
     * @return {@link ResultPoint}[] describing the corners of the rectangular
     *         region. The first and last points are opposed on the diagonal, as
     *         are the second and third. The first point will be the topmost
     *         point and the last, the bottommost. The second point will be
     *         leftmost and the third, the rightmost
     */
    WhiteRectangleDetector.prototype.centerEdges = function (y, z, x, t) {
        //
        //       t            t
        //  z                      x
        //        x    OR    z
        //   y                    y
        //
        var yi = y.getX();
        var yj = y.getY();
        var zi = z.getX();
        var zj = z.getY();
        var xi = x.getX();
        var xj = x.getY();
        var ti = t.getX();
        var tj = t.getY();
        var CORR = WhiteRectangleDetector.CORR;
        if (yi < this.width / 2.0) {
            return [
                new ResultPoint_1.default(ti - CORR, tj + CORR),
                new ResultPoint_1.default(zi + CORR, zj + CORR),
                new ResultPoint_1.default(xi - CORR, xj - CORR),
                new ResultPoint_1.default(yi + CORR, yj - CORR)
            ];
        }
        else {
            return [
                new ResultPoint_1.default(ti + CORR, tj + CORR),
                new ResultPoint_1.default(zi + CORR, zj - CORR),
                new ResultPoint_1.default(xi - CORR, xj + CORR),
                new ResultPoint_1.default(yi - CORR, yj - CORR)
            ];
        }
    };
    /**
     * Determines whether a segment contains a black point
     *
     * @param a          min value of the scanned coordinate
     * @param b          max value of the scanned coordinate
     * @param fixed      value of fixed coordinate
     * @param horizontal set to true if scan must be horizontal, false if vertical
     * @return true if a black point has been found, else false.
     */
    WhiteRectangleDetector.prototype.containsBlackPoint = function (a /*int*/, b /*int*/, fixed /*int*/, horizontal) {
        var image = this.image;
        if (horizontal) {
            for (var x = a; x <= b; x++) {
                if (image.get(x, fixed)) {
                    return true;
                }
            }
        }
        else {
            for (var y = a; y <= b; y++) {
                if (image.get(fixed, y)) {
                    return true;
                }
            }
        }
        return false;
    };
    WhiteRectangleDetector.INIT_SIZE = 10;
    WhiteRectangleDetector.CORR = 1;
    return WhiteRectangleDetector;
}());
exports.default = WhiteRectangleDetector;
//# sourceMappingURL=WhiteRectangleDetector.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/AbstractGenericGF.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/reedsolomon/AbstractGenericGF.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * <p>This class contains utility methods for performing mathematical operations over
 * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>
 *
 * <p>Throughout this package, elements of the GF are represented as an {@code int}
 * for convenience and speed (but at the cost of memory).
 * </p>
 *
 * @author Sean Owen
 * @author David Olivier
 */
var AbstractGenericGF = /** @class */ (function () {
    function AbstractGenericGF() {
    }
    /**
     * @return 2 to the power of a in GF(size)
     */
    AbstractGenericGF.prototype.exp = function (a) {
        return this.expTable[a];
    };
    /**
     * @return base 2 log of a in GF(size)
     */
    AbstractGenericGF.prototype.log = function (a /*int*/) {
        if (a === 0) {
            throw new IllegalArgumentException_1.default();
        }
        return this.logTable[a];
    };
    /**
     * Implements both addition and subtraction -- they are the same in GF(size).
     *
     * @return sum/difference of a and b
     */
    AbstractGenericGF.addOrSubtract = function (a /*int*/, b /*int*/) {
        return a ^ b;
    };
    return AbstractGenericGF;
}());
exports.default = AbstractGenericGF;
//# sourceMappingURL=AbstractGenericGF.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGF.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGF.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common.reedsolomon {*/
var GenericGFPoly_1 = __webpack_require__(/*! ./GenericGFPoly */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGFPoly.js");
var AbstractGenericGF_1 = __webpack_require__(/*! ./AbstractGenericGF */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/AbstractGenericGF.js");
var Integer_1 = __webpack_require__(/*! ../../util/Integer */ "./node_modules/@zxing/library/esm5/core/util/Integer.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
var ArithmeticException_1 = __webpack_require__(/*! ../../ArithmeticException */ "./node_modules/@zxing/library/esm5/core/ArithmeticException.js");
/**
 * <p>This class contains utility methods for performing mathematical operations over
 * the Galois Fields. Operations use a given primitive polynomial in calculations.</p>
 *
 * <p>Throughout this package, elements of the GF are represented as an {@code int}
 * for convenience and speed (but at the cost of memory).
 * </p>
 *
 * @author Sean Owen
 * @author David Olivier
 */
var GenericGF = /** @class */ (function (_super) {
    __extends(GenericGF, _super);
    /**
     * Create a representation of GF(size) using the given primitive polynomial.
     *
     * @param primitive irreducible polynomial whose coefficients are represented by
     *  the bits of an int, where the least-significant bit represents the constant
     *  coefficient
     * @param size the size of the field
     * @param b the factor b in the generator polynomial can be 0- or 1-based
     *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).
     *  In most cases it should be 1, but for QR code it is 0.
     */
    function GenericGF(primitive /*int*/, size /*int*/, generatorBase /*int*/) {
        var _this = _super.call(this) || this;
        _this.primitive = primitive;
        _this.size = size;
        _this.generatorBase = generatorBase;
        var expTable = new Int32Array(size);
        var x = 1;
        for (var i = 0; i < size; i++) {
            expTable[i] = x;
            x *= 2; // we're assuming the generator alpha is 2
            if (x >= size) {
                x ^= primitive;
                x &= size - 1;
            }
        }
        _this.expTable = expTable;
        var logTable = new Int32Array(size);
        for (var i = 0; i < size - 1; i++) {
            logTable[expTable[i]] = i;
        }
        _this.logTable = logTable;
        // logTable[0] == 0 but this should never be used
        _this.zero = new GenericGFPoly_1.default(_this, Int32Array.from([0]));
        _this.one = new GenericGFPoly_1.default(_this, Int32Array.from([1]));
        return _this;
    }
    GenericGF.prototype.getZero = function () {
        return this.zero;
    };
    GenericGF.prototype.getOne = function () {
        return this.one;
    };
    /**
     * @return the monomial representing coefficient * x^degree
     */
    GenericGF.prototype.buildMonomial = function (degree /*int*/, coefficient /*int*/) {
        if (degree < 0) {
            throw new IllegalArgumentException_1.default();
        }
        if (coefficient === 0) {
            return this.zero;
        }
        var coefficients = new Int32Array(degree + 1);
        coefficients[0] = coefficient;
        return new GenericGFPoly_1.default(this, coefficients);
    };
    /**
     * @return multiplicative inverse of a
     */
    GenericGF.prototype.inverse = function (a /*int*/) {
        if (a === 0) {
            throw new ArithmeticException_1.default();
        }
        return this.expTable[this.size - this.logTable[a] - 1];
    };
    /**
     * @return product of a and b in GF(size)
     */
    GenericGF.prototype.multiply = function (a /*int*/, b /*int*/) {
        if (a === 0 || b === 0) {
            return 0;
        }
        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.size - 1)];
    };
    GenericGF.prototype.getSize = function () {
        return this.size;
    };
    GenericGF.prototype.getGeneratorBase = function () {
        return this.generatorBase;
    };
    /*@Override*/
    GenericGF.prototype.toString = function () {
        return ('GF(0x' + Integer_1.default.toHexString(this.primitive) + ',' + this.size + ')');
    };
    GenericGF.prototype.equals = function (o) {
        return o === this;
    };
    GenericGF.AZTEC_DATA_12 = new GenericGF(0x1069, 4096, 1); // x^12 + x^6 + x^5 + x^3 + 1
    GenericGF.AZTEC_DATA_10 = new GenericGF(0x409, 1024, 1); // x^10 + x^3 + 1
    GenericGF.AZTEC_DATA_6 = new GenericGF(0x43, 64, 1); // x^6 + x + 1
    GenericGF.AZTEC_PARAM = new GenericGF(0x13, 16, 1); // x^4 + x + 1
    GenericGF.QR_CODE_FIELD_256 = new GenericGF(0x011d, 256, 0); // x^8 + x^4 + x^3 + x^2 + 1
    GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(0x012d, 256, 1); // x^8 + x^5 + x^3 + x^2 + 1
    GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;
    GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;
    return GenericGF;
}(AbstractGenericGF_1.default));
exports.default = GenericGF;
//# sourceMappingURL=GenericGF.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGFPoly.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGFPoly.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common.reedsolomon {*/
var AbstractGenericGF_1 = __webpack_require__(/*! ./AbstractGenericGF */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/AbstractGenericGF.js");
var System_1 = __webpack_require__(/*! ../../util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * <p>Represents a polynomial whose coefficients are elements of a GF.
 * Instances of this class are immutable.</p>
 *
 * <p>Much credit is due to William Rucklidge since portions of this code are an indirect
 * port of his C++ Reed-Solomon implementation.</p>
 *
 * @author Sean Owen
 */
var GenericGFPoly = /** @class */ (function () {
    /**
     * @param field the {@link GenericGF} instance representing the field to use
     * to perform computations
     * @param coefficients coefficients as ints representing elements of GF(size), arranged
     * from most significant (highest-power term) coefficient to least significant
     * @throws IllegalArgumentException if argument is null or empty,
     * or if leading coefficient is 0 and this is not a
     * constant polynomial (that is, it is not the monomial "0")
     */
    function GenericGFPoly(field, coefficients) {
        if (coefficients.length === 0) {
            throw new IllegalArgumentException_1.default();
        }
        this.field = field;
        var coefficientsLength = coefficients.length;
        if (coefficientsLength > 1 && coefficients[0] === 0) {
            // Leading term must be non-zero for anything except the constant polynomial "0"
            var firstNonZero = 1;
            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                firstNonZero++;
            }
            if (firstNonZero === coefficientsLength) {
                this.coefficients = Int32Array.from([0]);
            }
            else {
                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
                System_1.default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
            }
        }
        else {
            this.coefficients = coefficients;
        }
    }
    GenericGFPoly.prototype.getCoefficients = function () {
        return this.coefficients;
    };
    /**
     * @return degree of this polynomial
     */
    GenericGFPoly.prototype.getDegree = function () {
        return this.coefficients.length - 1;
    };
    /**
     * @return true iff this polynomial is the monomial "0"
     */
    GenericGFPoly.prototype.isZero = function () {
        return this.coefficients[0] === 0;
    };
    /**
     * @return coefficient of x^degree term in this polynomial
     */
    GenericGFPoly.prototype.getCoefficient = function (degree /*int*/) {
        return this.coefficients[this.coefficients.length - 1 - degree];
    };
    /**
     * @return evaluation of this polynomial at a given point
     */
    GenericGFPoly.prototype.evaluateAt = function (a /*int*/) {
        if (a === 0) {
            // Just return the x^0 coefficient
            return this.getCoefficient(0);
        }
        var coefficients = this.coefficients;
        var result;
        if (a === 1) {
            // Just the sum of the coefficients
            result = 0;
            for (var i = 0, length_1 = coefficients.length; i !== length_1; i++) {
                var coefficient = coefficients[i];
                result = AbstractGenericGF_1.default.addOrSubtract(result, coefficient);
            }
            return result;
        }
        result = coefficients[0];
        var size = coefficients.length;
        var field = this.field;
        for (var i = 1; i < size; i++) {
            result = AbstractGenericGF_1.default.addOrSubtract(field.multiply(a, result), coefficients[i]);
        }
        return result;
    };
    GenericGFPoly.prototype.addOrSubtract = function (other) {
        if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');
        }
        if (this.isZero()) {
            return other;
        }
        if (other.isZero()) {
            return this;
        }
        var smallerCoefficients = this.coefficients;
        var largerCoefficients = other.coefficients;
        if (smallerCoefficients.length > largerCoefficients.length) {
            var temp = smallerCoefficients;
            smallerCoefficients = largerCoefficients;
            largerCoefficients = temp;
        }
        var sumDiff = new Int32Array(largerCoefficients.length);
        var lengthDiff = largerCoefficients.length - smallerCoefficients.length;
        // Copy high-order terms only found in higher-degree polynomial's coefficients
        System_1.default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
        for (var i = lengthDiff; i < largerCoefficients.length; i++) {
            sumDiff[i] = AbstractGenericGF_1.default.addOrSubtract(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
        }
        return new GenericGFPoly(this.field, sumDiff);
    };
    GenericGFPoly.prototype.multiply = function (other) {
        if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');
        }
        if (this.isZero() || other.isZero()) {
            return this.field.getZero();
        }
        var aCoefficients = this.coefficients;
        var aLength = aCoefficients.length;
        var bCoefficients = other.coefficients;
        var bLength = bCoefficients.length;
        var product = new Int32Array(aLength + bLength - 1);
        var field = this.field;
        for (var i = 0; i < aLength; i++) {
            var aCoeff = aCoefficients[i];
            for (var j = 0; j < bLength; j++) {
                product[i + j] = AbstractGenericGF_1.default.addOrSubtract(product[i + j], field.multiply(aCoeff, bCoefficients[j]));
            }
        }
        return new GenericGFPoly(field, product);
    };
    GenericGFPoly.prototype.multiplyScalar = function (scalar /*int*/) {
        if (scalar === 0) {
            return this.field.getZero();
        }
        if (scalar === 1) {
            return this;
        }
        var size = this.coefficients.length;
        var field = this.field;
        var product = new Int32Array(size);
        var coefficients = this.coefficients;
        for (var i = 0; i < size; i++) {
            product[i] = field.multiply(coefficients[i], scalar);
        }
        return new GenericGFPoly(field, product);
    };
    GenericGFPoly.prototype.multiplyByMonomial = function (degree /*int*/, coefficient /*int*/) {
        if (degree < 0) {
            throw new IllegalArgumentException_1.default();
        }
        if (coefficient === 0) {
            return this.field.getZero();
        }
        var coefficients = this.coefficients;
        var size = coefficients.length;
        var product = new Int32Array(size + degree);
        var field = this.field;
        for (var i = 0; i < size; i++) {
            product[i] = field.multiply(coefficients[i], coefficient);
        }
        return new GenericGFPoly(field, product);
    };
    GenericGFPoly.prototype.divide = function (other) {
        if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException_1.default('GenericGFPolys do not have same GenericGF field');
        }
        if (other.isZero()) {
            throw new IllegalArgumentException_1.default('Divide by 0');
        }
        var field = this.field;
        var quotient = field.getZero();
        var remainder = this;
        var denominatorLeadingTerm = other.getCoefficient(other.getDegree());
        var inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);
        while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
            var degreeDifference = remainder.getDegree() - other.getDegree();
            var scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
            var term = other.multiplyByMonomial(degreeDifference, scale);
            var iterationQuotient = field.buildMonomial(degreeDifference, scale);
            quotient = quotient.addOrSubtract(iterationQuotient);
            remainder = remainder.addOrSubtract(term);
        }
        return [quotient, remainder];
    };
    /*@Override*/
    GenericGFPoly.prototype.toString = function () {
        var result = '';
        for (var degree = this.getDegree(); degree >= 0; degree--) {
            var coefficient = this.getCoefficient(degree);
            if (coefficient !== 0) {
                if (coefficient < 0) {
                    result += ' - ';
                    coefficient = -coefficient;
                }
                else {
                    if (result.length > 0) {
                        result += ' + ';
                    }
                }
                if (degree === 0 || coefficient !== 1) {
                    var alphaPower = this.field.log(coefficient);
                    if (alphaPower === 0) {
                        result += '1';
                    }
                    else if (alphaPower === 1) {
                        result += 'a';
                    }
                    else {
                        result += 'a^';
                        result += alphaPower;
                    }
                }
                if (degree !== 0) {
                    if (degree === 1) {
                        result += 'x';
                    }
                    else {
                        result += 'x^';
                        result += degree;
                    }
                }
            }
        }
        return result;
    };
    return GenericGFPoly;
}());
exports.default = GenericGFPoly;
//# sourceMappingURL=GenericGFPoly.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/ReedSolomonDecoder.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/reedsolomon/ReedSolomonDecoder.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.common.reedsolomon {*/
var GenericGF_1 = __webpack_require__(/*! ./GenericGF */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGF.js");
var GenericGFPoly_1 = __webpack_require__(/*! ./GenericGFPoly */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGFPoly.js");
var ReedSolomonException_1 = __webpack_require__(/*! ../../ReedSolomonException */ "./node_modules/@zxing/library/esm5/core/ReedSolomonException.js");
var IllegalStateException_1 = __webpack_require__(/*! ../../IllegalStateException */ "./node_modules/@zxing/library/esm5/core/IllegalStateException.js");
/**
 * <p>Implements Reed-Solomon decoding, as the name implies.</p>
 *
 * <p>The algorithm will not be explained here, but the following references were helpful
 * in creating this implementation:</p>
 *
 * <ul>
 * <li>Bruce Maggs.
 * <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/pscico-guyb/realworld/www/rs_decode.ps">
 * "Decoding Reed-Solomon Codes"</a> (see discussion of Forney's Formula)</li>
 * <li>J.I. Hall. <a href="www.mth.msu.edu/~jhall/classes/codenotes/GRS.pdf">
 * "Chapter 5. Generalized Reed-Solomon Codes"</a>
 * (see discussion of Euclidean algorithm)</li>
 * </ul>
 *
 * <p>Much credit is due to William Rucklidge since portions of this code are an indirect
 * port of his C++ Reed-Solomon implementation.</p>
 *
 * @author Sean Owen
 * @author William Rucklidge
 * @author sanfordsquires
 */
var ReedSolomonDecoder = /** @class */ (function () {
    function ReedSolomonDecoder(field) {
        this.field = field;
    }
    /**
     * <p>Decodes given set of received codewords, which include both data and error-correction
     * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,
     * in the input.</p>
     *
     * @param received data and error-correction codewords
     * @param twoS number of error-correction codewords available
     * @throws ReedSolomonException if decoding fails for any reason
     */
    ReedSolomonDecoder.prototype.decode = function (received, twoS /*int*/) {
        var field = this.field;
        var poly = new GenericGFPoly_1.default(field, received);
        var syndromeCoefficients = new Int32Array(twoS);
        var noError = true;
        for (var i = 0; i < twoS; i++) {
            var evalResult = poly.evaluateAt(field.exp(i + field.getGeneratorBase()));
            syndromeCoefficients[syndromeCoefficients.length - 1 - i] = evalResult;
            if (evalResult !== 0) {
                noError = false;
            }
        }
        if (noError) {
            return;
        }
        var syndrome = new GenericGFPoly_1.default(field, syndromeCoefficients);
        var sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
        var sigma = sigmaOmega[0];
        var omega = sigmaOmega[1];
        var errorLocations = this.findErrorLocations(sigma);
        var errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);
        for (var i = 0; i < errorLocations.length; i++) {
            var position = received.length - 1 - field.log(errorLocations[i]);
            if (position < 0) {
                throw new ReedSolomonException_1.default('Bad error location');
            }
            received[position] = GenericGF_1.default.addOrSubtract(received[position], errorMagnitudes[i]);
        }
    };
    ReedSolomonDecoder.prototype.runEuclideanAlgorithm = function (a, b, R /*int*/) {
        // Assume a's degree is >= b's
        if (a.getDegree() < b.getDegree()) {
            var temp = a;
            a = b;
            b = temp;
        }
        var field = this.field;
        var rLast = a;
        var r = b;
        var tLast = field.getZero();
        var t = field.getOne();
        // Run Euclidean algorithm until r's degree is less than R/2
        while (r.getDegree() >= (R / 2 | 0)) {
            var rLastLast = rLast;
            var tLastLast = tLast;
            rLast = r;
            tLast = t;
            // Divide rLastLast by rLast, with quotient in q and remainder in r
            if (rLast.isZero()) {
                // Oops, Euclidean algorithm already terminated?
                throw new ReedSolomonException_1.default('r_{i-1} was zero');
            }
            r = rLastLast;
            var q = field.getZero();
            var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
            var dltInverse = field.inverse(denominatorLeadingTerm);
            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
                var degreeDiff = r.getDegree() - rLast.getDegree();
                var scale = field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
                q = q.addOrSubtract(field.buildMonomial(degreeDiff, scale));
                r = r.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
            }
            t = q.multiply(tLast).addOrSubtract(tLastLast);
            if (r.getDegree() >= rLast.getDegree()) {
                throw new IllegalStateException_1.default('Division algorithm failed to reduce polynomial?');
            }
        }
        var sigmaTildeAtZero = t.getCoefficient(0);
        if (sigmaTildeAtZero === 0) {
            throw new ReedSolomonException_1.default('sigmaTilde(0) was zero');
        }
        var inverse = field.inverse(sigmaTildeAtZero);
        var sigma = t.multiplyScalar(inverse);
        var omega = r.multiplyScalar(inverse);
        return [sigma, omega];
    };
    ReedSolomonDecoder.prototype.findErrorLocations = function (errorLocator) {
        // This is a direct application of Chien's search
        var numErrors = errorLocator.getDegree();
        if (numErrors === 1) { // shortcut
            return Int32Array.from([errorLocator.getCoefficient(1)]);
        }
        var result = new Int32Array(numErrors);
        var e = 0;
        var field = this.field;
        for (var i = 1; i < field.getSize() && e < numErrors; i++) {
            if (errorLocator.evaluateAt(i) === 0) {
                result[e] = field.inverse(i);
                e++;
            }
        }
        if (e !== numErrors) {
            throw new ReedSolomonException_1.default('Error locator degree does not match number of roots');
        }
        return result;
    };
    ReedSolomonDecoder.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocations) {
        // This is directly applying Forney's Formula
        var s = errorLocations.length;
        var result = new Int32Array(s);
        var field = this.field;
        for (var i = 0; i < s; i++) {
            var xiInverse = field.inverse(errorLocations[i]);
            var denominator = 1;
            for (var j = 0; j < s; j++) {
                if (i !== j) {
                    // denominator = field.multiply(denominator,
                    //    GenericGF.addOrSubtract(1, field.multiply(errorLocations[j], xiInverse)))
                    // Above should work but fails on some Apple and Linux JDKs due to a Hotspot bug.
                    // Below is a funny-looking workaround from Steven Parkes
                    var term = field.multiply(errorLocations[j], xiInverse);
                    var termPlus1 = (term & 0x1) === 0 ? term | 1 : term & ~1;
                    denominator = field.multiply(denominator, termPlus1);
                }
            }
            result[i] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
            if (field.getGeneratorBase() !== 0) {
                result[i] = field.multiply(result[i], xiInverse);
            }
        }
        return result;
    };
    return ReedSolomonDecoder;
}());
exports.default = ReedSolomonDecoder;
//# sourceMappingURL=ReedSolomonDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/ReedSolomonEncoder.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/common/reedsolomon/ReedSolomonEncoder.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var GenericGFPoly_1 = __webpack_require__(/*! ./GenericGFPoly */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGFPoly.js");
var System_1 = __webpack_require__(/*! ../../util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * <p>Implements Reed-Solomon encoding, as the name implies.</p>
 *
 * @author Sean Owen
 * @author William Rucklidge
 */
var ReedSolomonEncoder = /** @class */ (function () {
    /**
     * A reed solomon error-correcting encoding constructor is created by
     * passing as Galois Field with of size equal to the number of code
     * words (symbols) in the alphabet (the number of values in each
     * element of arrays that are encoded/decoded).
     * @param field A galois field with a number of elements equal to the size
     * of the alphabet of symbols to encode.
     */
    function ReedSolomonEncoder(field) {
        this.field = field;
        this.cachedGenerators = [];
        this.cachedGenerators.push(new GenericGFPoly_1.default(field, Int32Array.from([1])));
    }
    ReedSolomonEncoder.prototype.buildGenerator = function (degree /*int*/) {
        var cachedGenerators = this.cachedGenerators;
        if (degree >= cachedGenerators.length) {
            var lastGenerator = cachedGenerators[cachedGenerators.length - 1];
            var field = this.field;
            for (var d = cachedGenerators.length; d <= degree; d++) {
                var nextGenerator = lastGenerator.multiply(new GenericGFPoly_1.default(field, Int32Array.from([1, field.exp(d - 1 + field.getGeneratorBase())])));
                cachedGenerators.push(nextGenerator);
                lastGenerator = nextGenerator;
            }
        }
        return cachedGenerators[degree];
    };
    /**
     * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders
     * to detect and correct errors that may have been introduced when the resulting
     * data is stored or transmitted.</p>
     *
     * @param toEncode array used for both and output. Caller initializes the array with
     * the code words (symbols) to be encoded followed by empty elements allocated to make
     * space for error-correction code words in the encoded output. The array contains
     * the encdoded output when encode returns. Code words are encoded as numbers from
     * 0 to n-1, where n is the number of possible code words (symbols), as determined
     * by the size of the Galois Field passed in the constructor of this object.
     * @param ecBytes the number of elements reserved in the array (first parameter)
     * to store error-correction code words. Thus, the number of code words (symbols)
     * to encode in the first parameter is thus toEncode.length - ecBytes.
     * Note, the use of "bytes" in the name of this parameter is misleading, as there may
     * be more or fewer than 256 symbols being encoded, as determined by the number of
     * elements in the Galois Field passed as a constructor to this object.
     * @throws IllegalArgumentException thrown in response to validation errros.
     */
    ReedSolomonEncoder.prototype.encode = function (toEncode, ecBytes /*int*/) {
        if (ecBytes === 0) {
            throw new IllegalArgumentException_1.default('No error correction bytes');
        }
        var dataBytes = toEncode.length - ecBytes;
        if (dataBytes <= 0) {
            throw new IllegalArgumentException_1.default('No data bytes provided');
        }
        var generator = this.buildGenerator(ecBytes);
        var infoCoefficients = new Int32Array(dataBytes);
        System_1.default.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);
        var info = new GenericGFPoly_1.default(this.field, infoCoefficients);
        info = info.multiplyByMonomial(ecBytes, 1);
        var remainder = info.divide(generator)[1];
        var coefficients = remainder.getCoefficients();
        var numZeroCoefficients = ecBytes - coefficients.length;
        for (var i = 0; i < numZeroCoefficients; i++) {
            toEncode[dataBytes + i] = 0;
        }
        System_1.default.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);
    };
    return ReedSolomonEncoder;
}());
exports.default = ReedSolomonEncoder;
//# sourceMappingURL=ReedSolomonEncoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/datamatrix/DataMatrixReader.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/datamatrix/DataMatrixReader.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Decoder_1 = __webpack_require__(/*! ./decoder/Decoder */ "./node_modules/@zxing/library/esm5/core/datamatrix/decoder/Decoder.js");
var Result_1 = __webpack_require__(/*! ../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ "./node_modules/@zxing/library/esm5/core/ResultMetadataType.js");
var BitMatrix_1 = __webpack_require__(/*! ../common/BitMatrix */ "./node_modules/@zxing/library/esm5/core/common/BitMatrix.js");
var Detector_1 = __webpack_require__(/*! ./detector/Detector */ "./node_modules/@zxing/library/esm5/core/datamatrix/detector/Detector.js");
var System_1 = __webpack_require__(/*! ../util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This implementation can detect and decode Data Matrix codes in an image.
 *
 * @author bbrown@google.com (Brian Brown)
 */
var DataMatrixReader = /** @class */ (function () {
    function DataMatrixReader() {
        this.decoder = new Decoder_1.default();
    }
    /**
     * Locates and decodes a Data Matrix code in an image.
     *
     * @return a String representing the content encoded by the Data Matrix code
     * @throws NotFoundException if a Data Matrix code cannot be found
     * @throws FormatException if a Data Matrix code cannot be decoded
     * @throws ChecksumException if error correction fails
     */
    // @Override
    // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {
    //   return decode(image, null);
    // }
    // @Override
    DataMatrixReader.prototype.decode = function (image, hints) {
        if (hints === void 0) { hints = null; }
        var decoderResult;
        var points;
        if (hints != null && hints.has(DecodeHintType_1.default.PURE_BARCODE)) {
            var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());
            decoderResult = this.decoder.decode(bits);
            points = DataMatrixReader.NO_POINTS;
        }
        else {
            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect();
            decoderResult = this.decoder.decode(detectorResult.getBits());
            points = detectorResult.getPoints();
        }
        var rawBytes = decoderResult.getRawBytes();
        var result = new Result_1.default(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat_1.default.DATA_MATRIX, System_1.default.currentTimeMillis());
        var byteSegments = decoderResult.getByteSegments();
        if (byteSegments != null) {
            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);
        }
        var ecLevel = decoderResult.getECLevel();
        if (ecLevel != null) {
            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        return result;
    };
    // @Override
    DataMatrixReader.prototype.reset = function () {
        // do nothing
    };
    /**
     * This method detects a code in a "pure" image -- that is, pure monochrome image
     * which contains only an unrotated, unskewed, image of a code, with some white border
     * around it. This is a specialized method that works exceptionally fast in this special
     * case.
     *
     * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)
     */
    DataMatrixReader.extractPureBits = function (image) {
        var leftTopBlack = image.getTopLeftOnBit();
        var rightBottomBlack = image.getBottomRightOnBit();
        if (leftTopBlack == null || rightBottomBlack == null) {
            throw new NotFoundException_1.default();
        }
        var moduleSize = this.moduleSize(leftTopBlack, image);
        var top = leftTopBlack[1];
        var bottom = rightBottomBlack[1];
        var left = leftTopBlack[0];
        var right = rightBottomBlack[0];
        var matrixWidth = (right - left + 1) / moduleSize;
        var matrixHeight = (bottom - top + 1) / moduleSize;
        if (matrixWidth <= 0 || matrixHeight <= 0) {
            throw new NotFoundException_1.default();
        }
        // Push in the "border" by half the module width so that we start
        // sampling in the middle of the module. Just in case the image is a
        // little off, this will help recover.
        var nudge = moduleSize / 2;
        top += nudge;
        left += nudge;
        // Now just read off the bits
        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);
        for (var y = 0; y < matrixHeight; y++) {
            var iOffset = top + y * moduleSize;
            for (var x = 0; x < matrixWidth; x++) {
                if (image.get(left + x * moduleSize, iOffset)) {
                    bits.set(x, y);
                }
            }
        }
        return bits;
    };
    DataMatrixReader.moduleSize = function (leftTopBlack, image) {
        var width = image.getWidth();
        var x = leftTopBlack[0];
        var y = leftTopBlack[1];
        while (x < width && image.get(x, y)) {
            x++;
        }
        if (x === width) {
            throw new NotFoundException_1.default();
        }
        var moduleSize = x - leftTopBlack[0];
        if (moduleSize === 0) {
            throw new NotFoundException_1.default();
        }
        return moduleSize;
    };
    DataMatrixReader.NO_POINTS = [];
    return DataMatrixReader;
}());
exports.default = DataMatrixReader;
//# sourceMappingURL=DataMatrixReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/datamatrix/decoder/BitMatrixParser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/datamatrix/decoder/BitMatrixParser.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BitMatrix_1 = __webpack_require__(/*! ../../common/BitMatrix */ "./node_modules/@zxing/library/esm5/core/common/BitMatrix.js");
var Version_1 = __webpack_require__(/*! ./Version */ "./node_modules/@zxing/library/esm5/core/datamatrix/decoder/Version.js");
var FormatException_1 = __webpack_require__(/*! ../../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @author bbrown@google.com (Brian Brown)
 */
var BitMatrixParser = /** @class */ (function () {
    /**
     * @param bitMatrix {@link BitMatrix} to parse
     * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2
     */
    function BitMatrixParser(bitMatrix) {
        var dimension = bitMatrix.getHeight();
        if (dimension < 8 || dimension > 144 || (dimension & 0x01) !== 0) {
            throw new FormatException_1.default();
        }
        this.version = BitMatrixParser.readVersion(bitMatrix);
        this.mappingBitMatrix = this.extractDataRegion(bitMatrix);
        this.readMappingMatrix = new BitMatrix_1.default(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());
    }
    BitMatrixParser.prototype.getVersion = function () {
        return this.version;
    };
    /**
     * <p>Creates the version object based on the dimension of the original bit matrix from
     * the datamatrix code.</p>
     *
     * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>
     *
     * @param bitMatrix Original {@link BitMatrix} including alignment patterns
     * @return {@link Version} encapsulating the Data Matrix Code's "version"
     * @throws FormatException if the dimensions of the mapping matrix are not valid
     * Data Matrix dimensions.
     */
    BitMatrixParser.readVersion = function (bitMatrix) {
        var numRows = bitMatrix.getHeight();
        var numColumns = bitMatrix.getWidth();
        return Version_1.default.getVersionForDimensions(numRows, numColumns);
    };
    /**
     * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)
     * in the correct order in order to reconstitute the codewords bytes contained within the
     * Data Matrix Code.</p>
     *
     * @return bytes encoded within the Data Matrix Code
     * @throws FormatException if the exact number of bytes expected is not read
     */
    BitMatrixParser.prototype.readCodewords = function () {
        var result = new Int8Array(this.version.getTotalCodewords());
        var resultOffset = 0;
        var row = 4;
        var column = 0;
        var numRows = this.mappingBitMatrix.getHeight();
        var numColumns = this.mappingBitMatrix.getWidth();
        var corner1Read = false;
        var corner2Read = false;
        var corner3Read = false;
        var corner4Read = false;
        // Read all of the codewords
        do {
            // Check the four corner cases
            if ((row === numRows) && (column === 0) && !corner1Read) {
                result[resultOffset++] = this.readCorner1(numRows, numColumns) & 0xff;
                row -= 2;
                column += 2;
                corner1Read = true;
            }
            else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x03) !== 0) && !corner2Read) {
                result[resultOffset++] = this.readCorner2(numRows, numColumns) & 0xff;
                row -= 2;
                column += 2;
                corner2Read = true;
            }
            else if ((row === numRows + 4) && (column === 2) && ((numColumns & 0x07) === 0) && !corner3Read) {
                result[resultOffset++] = this.readCorner3(numRows, numColumns) & 0xff;
                row -= 2;
                column += 2;
                corner3Read = true;
            }
            else if ((row === numRows - 2) && (column === 0) && ((numColumns & 0x07) === 4) && !corner4Read) {
                result[resultOffset++] = this.readCorner4(numRows, numColumns) & 0xff;
                row -= 2;
                column += 2;
                corner4Read = true;
            }
            else {
                // Sweep upward diagonally to the right
                do {
                    if ((row < numRows) && (column >= 0) && !this.readMappingMatrix.get(column, row)) {
                        result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;
                    }
                    row -= 2;
                    column += 2;
                } while ((row >= 0) && (column < numColumns));
                row += 1;
                column += 3;
                // Sweep downward diagonally to the left
                do {
                    if ((row >= 0) && (column < numColumns) && !this.readMappingMatrix.get(column, row)) {
                        result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 0xff;
                    }
                    row += 2;
                    column -= 2;
                } while ((row < numRows) && (column >= 0));
                row += 3;
                column += 1;
            }
        } while ((row < numRows) || (column < numColumns));
        if (resultOffset !== this.version.getTotalCodewords()) {
            throw new FormatException_1.default();
        }
        return result;
    };
    /**
     * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>
     *
     * @param row Row to read in the mapping matrix
     * @param column Column to read in the mapping matrix
     * @param numRows Number of rows in the mapping matrix
     * @param numColumns Number of columns in the mapping matrix
     * @return value of the given bit in the mapping matrix
     */
    BitMatrixParser.prototype.readModule = function (row, column, numRows, numColumns) {
        // Adjust the row and column indices based on boundary wrapping
        if (row < 0) {
            row += numRows;
            column += 4 - ((numRows + 4) & 0x07);
        }
        if (column < 0) {
            column += numColumns;
            row += 4 - ((numColumns + 4) & 0x07);
        }
        this.readMappingMatrix.set(column, row);
        return this.mappingBitMatrix.get(column, row);
    };
    /**
     * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>
     *
     * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>
     *
     * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern
     * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern
     * @param numRows Number of rows in the mapping matrix
     * @param numColumns Number of columns in the mapping matrix
     * @return byte from the utah shape
     */
    BitMatrixParser.prototype.readUtah = function (row, column, numRows, numColumns) {
        var currentByte = 0;
        if (this.readModule(row - 2, column - 2, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 2, column - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column - 2, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column - 2, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column, numRows, numColumns)) {
            currentByte |= 1;
        }
        return currentByte;
    };
    /**
     * <p>Reads the 8 bits of the special corner condition 1.</p>
     *
     * <p>See ISO 16022:2006, Figure F.3</p>
     *
     * @param numRows Number of rows in the mapping matrix
     * @param numColumns Number of columns in the mapping matrix
     * @return byte from the Corner condition 1
     */
    BitMatrixParser.prototype.readCorner1 = function (numRows, numColumns) {
        var currentByte = 0;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 2, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        return currentByte;
    };
    /**
     * <p>Reads the 8 bits of the special corner condition 2.</p>
     *
     * <p>See ISO 16022:2006, Figure F.4</p>
     *
     * @param numRows Number of rows in the mapping matrix
     * @param numColumns Number of columns in the mapping matrix
     * @return byte from the Corner condition 2
     */
    BitMatrixParser.prototype.readCorner2 = function (numRows, numColumns) {
        var currentByte = 0;
        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 4, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        return currentByte;
    };
    /**
     * <p>Reads the 8 bits of the special corner condition 3.</p>
     *
     * <p>See ISO 16022:2006, Figure F.5</p>
     *
     * @param numRows Number of rows in the mapping matrix
     * @param numColumns Number of columns in the mapping matrix
     * @return byte from the Corner condition 3
     */
    BitMatrixParser.prototype.readCorner3 = function (numRows, numColumns) {
        var currentByte = 0;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 3, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 2, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        return currentByte;
    };
    /**
     * <p>Reads the 8 bits of the special corner condition 4.</p>
     *
     * <p>See ISO 16022:2006, Figure F.6</p>
     *
     * @param numRows Number of rows in the mapping matrix
     * @param numColumns Number of columns in the mapping matrix
     * @return byte from the Corner condition 4
     */
    BitMatrixParser.prototype.readCorner4 = function (numRows, numColumns) {
        var currentByte = 0;
        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
            currentByte |= 1;
        }
        return currentByte;
    };
    /**
     * <p>Extracts the data region from a {@link BitMatrix} that contains
     * alignment patterns.</p>
     *
     * @param bitMatrix Original {@link BitMatrix} with alignment patterns
     * @return BitMatrix that has the alignment patterns removed
     */
    BitMatrixParser.prototype.extractDataRegion = function (bitMatrix) {
        var symbolSizeRows = this.version.getSymbolSizeRows();
        var symbolSizeColumns = this.version.getSymbolSizeColumns();
        if (bitMatrix.getHeight() !== symbolSizeRows) {
            throw new IllegalArgumentException_1.default('Dimension of bitMatrix must match the version size');
        }
        var dataRegionSizeRows = this.version.getDataRegionSizeRows();
        var dataRegionSizeColumns = this.version.getDataRegionSizeColumns();
        var numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;
        var numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;
        var sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;
        var sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;
        var bitMatrixWithoutAlignment = new BitMatrix_1.default(sizeDataRegionColumn, sizeDataRegionRow);
        for (var dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {
            var dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;
            for (var dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {
                var dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;
                for (var i = 0; i < dataRegionSizeRows; ++i) {
                    var readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i;
                    var writeRowOffset = dataRegionRowOffset + i;
                    for (var j = 0; j < dataRegionSizeColumns; ++j) {
                        var readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j;
                        if (bitMatrix.get(readColumnOffset, readRowOffset)) {
                            var writeColumnOffset = dataRegionColumnOffset + j;
                            bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);
                        }
                    }
                }
            }
        }
        return bitMatrixWithoutAlignment;
    };
    return BitMatrixParser;
}());
exports.default = BitMatrixParser;
//# sourceMappingURL=BitMatrixParser.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/datamatrix/decoder/DataBlock.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/datamatrix/decoder/DataBlock.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>Encapsulates a block of data within a Data Matrix Code. Data Matrix Codes may split their data into
 * multiple blocks, each of which is a unit of data and error-correction codewords. Each
 * is represented by an instance of this class.</p>
 *
 * @author bbrown@google.com (Brian Brown)
 */
var DataBlock = /** @class */ (function () {
    function DataBlock(numDataCodewords, codewords) {
        this.numDataCodewords = numDataCodewords;
        this.codewords = codewords;
    }
    /**
     * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.
     * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
     * method will separate the data into original blocks.</p>
     *
     * @param rawCodewords bytes as read directly from the Data Matrix Code
     * @param version version of the Data Matrix Code
     * @return DataBlocks containing original bytes, "de-interleaved" from representation in the
     *         Data Matrix Code
     */
    DataBlock.getDataBlocks = function (rawCodewords, version) {
        var e_1, _a, e_2, _b;
        // Figure out the number and size of data blocks used by this version
        var ecBlocks = version.getECBlocks();
        // First count the total number of data blocks
        var totalBlocks = 0;
        var ecBlockArray = ecBlocks.getECBlocks();
        try {
            for (var ecBlockArray_1 = __values(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {
                var ecBlock = ecBlockArray_1_1.value;
                totalBlocks += ecBlock.getCount();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return)) _a.call(ecBlockArray_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Now establish DataBlocks of the appropriate size and number of data codewords
        var result = new Array(totalBlocks);
        var numResultBlocks = 0;
        try {
            for (var ecBlockArray_2 = __values(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {
                var ecBlock = ecBlockArray_2_1.value;
                for (var i = 0; i < ecBlock.getCount(); i++) {
                    var numDataCodewords = ecBlock.getDataCodewords();
                    var numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;
                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // All blocks have the same amount of data, except that the last n
        // (where n may be 0) have 1 less byte. Figure out where these start.
        // TODO(bbrown): There is only one case where there is a difference for Data Matrix for size 144
        var longerBlocksTotalCodewords = result[0].codewords.length;
        // int shorterBlocksTotalCodewords = longerBlocksTotalCodewords - 1;
        var longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();
        var shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;
        // The last elements of result may be 1 element shorter for 144 matrix
        // first fill out as many elements as all of them have minus 1
        var rawCodewordsOffset = 0;
        for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {
            for (var j = 0; j < numResultBlocks; j++) {
                result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
            }
        }
        // Fill out the last data block in the longer ones
        var specialVersion = version.getVersionNumber() === 24;
        var numLongerBlocks = specialVersion ? 8 : numResultBlocks;
        for (var j = 0; j < numLongerBlocks; j++) {
            result[j].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];
        }
        // Now add in error correction blocks
        var max = result[0].codewords.length;
        for (var i = longerBlocksNumDataCodewords; i < max; i++) {
            for (var j = 0; j < numResultBlocks; j++) {
                var jOffset = specialVersion ? (j + 8) % numResultBlocks : j;
                var iOffset = specialVersion && jOffset > 7 ? i - 1 : i;
                result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
            }
        }
        if (rawCodewordsOffset !== rawCodewords.length) {
            throw new IllegalArgumentException_1.default();
        }
        return result;
    };
    DataBlock.prototype.getNumDataCodewords = function () {
        return this.numDataCodewords;
    };
    DataBlock.prototype.getCodewords = function () {
        return this.codewords;
    };
    return DataBlock;
}());
exports.default = DataBlock;
//# sourceMappingURL=DataBlock.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/datamatrix/decoder/DecodedBitStreamParser.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/datamatrix/decoder/DecodedBitStreamParser.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DecoderResult_1 = __webpack_require__(/*! ../../common/DecoderResult */ "./node_modules/@zxing/library/esm5/core/common/DecoderResult.js");
var BitSource_1 = __webpack_require__(/*! ../../common/BitSource */ "./node_modules/@zxing/library/esm5/core/common/BitSource.js");
var StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var StringEncoding_1 = __webpack_require__(/*! ../../util/StringEncoding */ "./node_modules/@zxing/library/esm5/core/util/StringEncoding.js");
var StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ "./node_modules/@zxing/library/esm5/core/common/StringUtils.js");
var FormatException_1 = __webpack_require__(/*! ../../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
var IllegalStateException_1 = __webpack_require__(/*! ../../IllegalStateException */ "./node_modules/@zxing/library/esm5/core/IllegalStateException.js");
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Mode;
(function (Mode) {
    Mode[Mode["PAD_ENCODE"] = 0] = "PAD_ENCODE";
    Mode[Mode["ASCII_ENCODE"] = 1] = "ASCII_ENCODE";
    Mode[Mode["C40_ENCODE"] = 2] = "C40_ENCODE";
    Mode[Mode["TEXT_ENCODE"] = 3] = "TEXT_ENCODE";
    Mode[Mode["ANSIX12_ENCODE"] = 4] = "ANSIX12_ENCODE";
    Mode[Mode["EDIFACT_ENCODE"] = 5] = "EDIFACT_ENCODE";
    Mode[Mode["BASE256_ENCODE"] = 6] = "BASE256_ENCODE";
})(Mode || (Mode = {}));
/**
 * <p>Data Matrix Codes can encode text as bits in one of several modes, and can use multiple modes
 * in one Data Matrix Code. This class decodes the bits back into text.</p>
 *
 * <p>See ISO 16022:2006, 5.2.1 - 5.2.9.2</p>
 *
 * @author bbrown@google.com (Brian Brown)
 * @author Sean Owen
 */
var DecodedBitStreamParser = /** @class */ (function () {
    function DecodedBitStreamParser() {
    }
    DecodedBitStreamParser.decode = function (bytes) {
        var bits = new BitSource_1.default(bytes);
        var result = new StringBuilder_1.default();
        var resultTrailer = new StringBuilder_1.default();
        var byteSegments = new Array();
        var mode = Mode.ASCII_ENCODE;
        do {
            if (mode === Mode.ASCII_ENCODE) {
                mode = this.decodeAsciiSegment(bits, result, resultTrailer);
            }
            else {
                switch (mode) {
                    case Mode.C40_ENCODE:
                        this.decodeC40Segment(bits, result);
                        break;
                    case Mode.TEXT_ENCODE:
                        this.decodeTextSegment(bits, result);
                        break;
                    case Mode.ANSIX12_ENCODE:
                        this.decodeAnsiX12Segment(bits, result);
                        break;
                    case Mode.EDIFACT_ENCODE:
                        this.decodeEdifactSegment(bits, result);
                        break;
                    case Mode.BASE256_ENCODE:
                        this.decodeBase256Segment(bits, result, byteSegments);
                        break;
                    default:
                        throw new FormatException_1.default();
                }
                mode = Mode.ASCII_ENCODE;
            }
        } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);
        if (resultTrailer.length() > 0) {
            result.append(resultTrailer.toString());
        }
        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);
    };
    /**
     * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2
     */
    DecodedBitStreamParser.decodeAsciiSegment = function (bits, result, resultTrailer) {
        var upperShift = false;
        do {
            var oneByte = bits.readBits(8);
            if (oneByte === 0) {
                throw new FormatException_1.default();
            }
            else if (oneByte <= 128) { // ASCII data (ASCII value + 1)
                if (upperShift) {
                    oneByte += 128;
                    // upperShift = false;
                }
                result.append(String.fromCharCode(oneByte - 1));
                return Mode.ASCII_ENCODE;
            }
            else if (oneByte === 129) { // Pad
                return Mode.PAD_ENCODE;
            }
            else if (oneByte <= 229) { // 2-digit data 00-99 (Numeric Value + 130)
                var value = oneByte - 130;
                if (value < 10) { // pad with '0' for single digit values
                    result.append('0');
                }
                result.append('' + value);
            }
            else {
                switch (oneByte) {
                    case 230: // Latch to C40 encodation
                        return Mode.C40_ENCODE;
                    case 231: // Latch to Base 256 encodation
                        return Mode.BASE256_ENCODE;
                    case 232: // FNC1
                        result.append(String.fromCharCode(29)); // translate as ASCII 29
                        break;
                    case 233: // Structured Append
                    case 234: // Reader Programming
                        // Ignore these symbols for now
                        // throw ReaderException.getInstance();
                        break;
                    case 235: // Upper Shift (shift to Extended ASCII)
                        upperShift = true;
                        break;
                    case 236: // 05 Macro
                        result.append('[)>\u001E05\u001D');
                        resultTrailer.insert(0, '\u001E\u0004');
                        break;
                    case 237: // 06 Macro
                        result.append('[)>\u001E06\u001D');
                        resultTrailer.insert(0, '\u001E\u0004');
                        break;
                    case 238: // Latch to ANSI X12 encodation
                        return Mode.ANSIX12_ENCODE;
                    case 239: // Latch to Text encodation
                        return Mode.TEXT_ENCODE;
                    case 240: // Latch to EDIFACT encodation
                        return Mode.EDIFACT_ENCODE;
                    case 241: // ECI Character
                        // TODO(bbrown): I think we need to support ECI
                        // throw ReaderException.getInstance();
                        // Ignore this symbol for now
                        break;
                    default:
                        // Not to be used in ASCII encodation
                        // but work around encoders that end with 254, latch back to ASCII
                        if (oneByte !== 254 || bits.available() !== 0) {
                            throw new FormatException_1.default();
                        }
                        break;
                }
            }
        } while (bits.available() > 0);
        return Mode.ASCII_ENCODE;
    };
    /**
     * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1
     */
    DecodedBitStreamParser.decodeC40Segment = function (bits, result) {
        // Three C40 values are encoded in a 16-bit value as
        // (1600 * C1) + (40 * C2) + C3 + 1
        // TODO(bbrown): The Upper Shift with C40 doesn't work in the 4 value scenario all the time
        var upperShift = false;
        var cValues = [];
        var shift = 0;
        do {
            // If there is only one byte left then it will be encoded as ASCII
            if (bits.available() === 8) {
                return;
            }
            var firstByte = bits.readBits(8);
            if (firstByte === 254) { // Unlatch codeword
                return;
            }
            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
            for (var i = 0; i < 3; i++) {
                var cValue = cValues[i];
                switch (shift) {
                    case 0:
                        if (cValue < 3) {
                            shift = cValue + 1;
                        }
                        else if (cValue < this.C40_BASIC_SET_CHARS.length) {
                            var c40char = this.C40_BASIC_SET_CHARS[cValue];
                            if (upperShift) {
                                result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                                upperShift = false;
                            }
                            else {
                                result.append(c40char);
                            }
                        }
                        else {
                            throw new FormatException_1.default();
                        }
                        break;
                    case 1:
                        if (upperShift) {
                            result.append(String.fromCharCode(cValue + 128));
                            upperShift = false;
                        }
                        else {
                            result.append(String.fromCharCode(cValue));
                        }
                        shift = 0;
                        break;
                    case 2:
                        if (cValue < this.C40_SHIFT2_SET_CHARS.length) {
                            var c40char = this.C40_SHIFT2_SET_CHARS[cValue];
                            if (upperShift) {
                                result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                                upperShift = false;
                            }
                            else {
                                result.append(c40char);
                            }
                        }
                        else {
                            switch (cValue) {
                                case 27: // FNC1
                                    result.append(String.fromCharCode(29)); // translate as ASCII 29
                                    break;
                                case 30: // Upper Shift
                                    upperShift = true;
                                    break;
                                default:
                                    throw new FormatException_1.default();
                            }
                        }
                        shift = 0;
                        break;
                    case 3:
                        if (upperShift) {
                            result.append(String.fromCharCode(cValue + 224));
                            upperShift = false;
                        }
                        else {
                            result.append(String.fromCharCode(cValue + 96));
                        }
                        shift = 0;
                        break;
                    default:
                        throw new FormatException_1.default();
                }
            }
        } while (bits.available() > 0);
    };
    /**
     * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2
     */
    DecodedBitStreamParser.decodeTextSegment = function (bits, result) {
        // Three Text values are encoded in a 16-bit value as
        // (1600 * C1) + (40 * C2) + C3 + 1
        // TODO(bbrown): The Upper Shift with Text doesn't work in the 4 value scenario all the time
        var upperShift = false;
        var cValues = [];
        var shift = 0;
        do {
            // If there is only one byte left then it will be encoded as ASCII
            if (bits.available() === 8) {
                return;
            }
            var firstByte = bits.readBits(8);
            if (firstByte === 254) { // Unlatch codeword
                return;
            }
            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
            for (var i = 0; i < 3; i++) {
                var cValue = cValues[i];
                switch (shift) {
                    case 0:
                        if (cValue < 3) {
                            shift = cValue + 1;
                        }
                        else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {
                            var textChar = this.TEXT_BASIC_SET_CHARS[cValue];
                            if (upperShift) {
                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                                upperShift = false;
                            }
                            else {
                                result.append(textChar);
                            }
                        }
                        else {
                            throw new FormatException_1.default();
                        }
                        break;
                    case 1:
                        if (upperShift) {
                            result.append(String.fromCharCode(cValue + 128));
                            upperShift = false;
                        }
                        else {
                            result.append(String.fromCharCode(cValue));
                        }
                        shift = 0;
                        break;
                    case 2:
                        // Shift 2 for Text is the same encoding as C40
                        if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {
                            var textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];
                            if (upperShift) {
                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                                upperShift = false;
                            }
                            else {
                                result.append(textChar);
                            }
                        }
                        else {
                            switch (cValue) {
                                case 27: // FNC1
                                    result.append(String.fromCharCode(29)); // translate as ASCII 29
                                    break;
                                case 30: // Upper Shift
                                    upperShift = true;
                                    break;
                                default:
                                    throw new FormatException_1.default();
                            }
                        }
                        shift = 0;
                        break;
                    case 3:
                        if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {
                            var textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];
                            if (upperShift) {
                                result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                                upperShift = false;
                            }
                            else {
                                result.append(textChar);
                            }
                            shift = 0;
                        }
                        else {
                            throw new FormatException_1.default();
                        }
                        break;
                    default:
                        throw new FormatException_1.default();
                }
            }
        } while (bits.available() > 0);
    };
    /**
     * See ISO 16022:2006, 5.2.7
     */
    DecodedBitStreamParser.decodeAnsiX12Segment = function (bits, result) {
        // Three ANSI X12 values are encoded in a 16-bit value as
        // (1600 * C1) + (40 * C2) + C3 + 1
        var cValues = [];
        do {
            // If there is only one byte left then it will be encoded as ASCII
            if (bits.available() === 8) {
                return;
            }
            var firstByte = bits.readBits(8);
            if (firstByte === 254) { // Unlatch codeword
                return;
            }
            this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
            for (var i = 0; i < 3; i++) {
                var cValue = cValues[i];
                switch (cValue) {
                    case 0: // X12 segment terminator <CR>
                        result.append('\r');
                        break;
                    case 1: // X12 segment separator *
                        result.append('*');
                        break;
                    case 2: // X12 sub-element separator >
                        result.append('>');
                        break;
                    case 3: // space
                        result.append(' ');
                        break;
                    default:
                        if (cValue < 14) { // 0 - 9
                            result.append(String.fromCharCode(cValue + 44));
                        }
                        else if (cValue < 40) { // A - Z
                            result.append(String.fromCharCode(cValue + 51));
                        }
                        else {
                            throw new FormatException_1.default();
                        }
                        break;
                }
            }
        } while (bits.available() > 0);
    };
    DecodedBitStreamParser.parseTwoBytes = function (firstByte, secondByte, result) {
        var fullBitValue = (firstByte << 8) + secondByte - 1;
        var temp = Math.floor(fullBitValue / 1600);
        result[0] = temp;
        fullBitValue -= temp * 1600;
        temp = Math.floor(fullBitValue / 40);
        result[1] = temp;
        result[2] = fullBitValue - temp * 40;
    };
    /**
     * See ISO 16022:2006, 5.2.8 and Annex C Table C.3
     */
    DecodedBitStreamParser.decodeEdifactSegment = function (bits, result) {
        do {
            // If there is only two or less bytes left then it will be encoded as ASCII
            if (bits.available() <= 16) {
                return;
            }
            for (var i = 0; i < 4; i++) {
                var edifactValue = bits.readBits(6);
                // Check for the unlatch character
                if (edifactValue === 0x1F) { // 011111
                    // Read rest of byte, which should be 0, and stop
                    var bitsLeft = 8 - bits.getBitOffset();
                    if (bitsLeft !== 8) {
                        bits.readBits(bitsLeft);
                    }
                    return;
                }
                if ((edifactValue & 0x20) === 0) { // no 1 in the leading (6th) bit
                    edifactValue |= 0x40; // Add a leading 01 to the 6 bit binary value
                }
                result.append(String.fromCharCode(edifactValue));
            }
        } while (bits.available() > 0);
    };
    /**
     * See ISO 16022:2006, 5.2.9 and Annex B, B.2
     */
    DecodedBitStreamParser.decodeBase256Segment = function (bits, result, byteSegments) {
        // Figure out how long the Base 256 Segment is.
        var codewordPosition = 1 + bits.getByteOffset(); // position is 1-indexed
        var d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);
        var count;
        if (d1 === 0) { // Read the remainder of the symbol
            count = bits.available() / 8 | 0;
        }
        else if (d1 < 250) {
            count = d1;
        }
        else {
            count = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);
        }
        // We're seeing NegativeArraySizeException errors from users.
        if (count < 0) {
            throw new FormatException_1.default();
        }
        var bytes = new Uint8Array(count);
        for (var i = 0; i < count; i++) {
            // Have seen this particular error in the wild, such as at
            // http://www.bcgen.com/demo/IDAutomationStreamingDataMatrix.aspx?MODE=3&D=Fred&PFMT=3&PT=F&X=0.3&O=0&LM=0.2
            if (bits.available() < 8) {
                throw new FormatException_1.default();
            }
            bytes[i] = this.unrandomize255State(bits.readBits(8), codewordPosition++);
        }
        byteSegments.push(bytes);
        try {
            result.append(StringEncoding_1.default.decode(bytes, StringUtils_1.default.ISO88591));
        }
        catch (uee) {
            throw new IllegalStateException_1.default('Platform does not support required encoding: ' + uee.message);
        }
    };
    /**
     * See ISO 16022:2006, Annex B, B.2
     */
    DecodedBitStreamParser.unrandomize255State = function (randomizedBase256Codeword, base256CodewordPosition) {
        var pseudoRandomNumber = ((149 * base256CodewordPosition) % 255) + 1;
        var tempVariable = randomizedBase256Codeword - pseudoRandomNumber;
        return tempVariable >= 0 ? tempVariable : tempVariable + 256;
    };
    /**
     * See ISO 16022:2006, Annex C Table C.1
     * The C40 Basic Character Set (*'s used for placeholders for the shift values)
     */
    DecodedBitStreamParser.C40_BASIC_SET_CHARS = [
        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
    ];
    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [
        '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.',
        '/', ':', ';', '<', '=', '>', '?', '@', '[', '\\', ']', '^', '_'
    ];
    /**
     * See ISO 16022:2006, Annex C Table C.2
     * The Text Basic Character Set (*'s used for placeholders for the shift values)
     */
    DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [
        '*', '*', '*', ' ', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
        'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'
    ];
    // Shift 2 for Text is the same encoding as C40
    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;
    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [
        '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',
        'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', String.fromCharCode(127)
    ];
    return DecodedBitStreamParser;
}());
exports.default = DecodedBitStreamParser;
//# sourceMappingURL=DecodedBitStreamParser.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/datamatrix/decoder/Decoder.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/datamatrix/decoder/Decoder.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ReedSolomonDecoder_1 = __webpack_require__(/*! ../../common/reedsolomon/ReedSolomonDecoder */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/ReedSolomonDecoder.js");
var GenericGF_1 = __webpack_require__(/*! ../../common/reedsolomon/GenericGF */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGF.js");
var BitMatrixParser_1 = __webpack_require__(/*! ./BitMatrixParser */ "./node_modules/@zxing/library/esm5/core/datamatrix/decoder/BitMatrixParser.js");
var DataBlock_1 = __webpack_require__(/*! ./DataBlock */ "./node_modules/@zxing/library/esm5/core/datamatrix/decoder/DataBlock.js");
var DecodedBitStreamParser_1 = __webpack_require__(/*! ./DecodedBitStreamParser */ "./node_modules/@zxing/library/esm5/core/datamatrix/decoder/DecodedBitStreamParser.js");
var ChecksumException_1 = __webpack_require__(/*! ../../ChecksumException */ "./node_modules/@zxing/library/esm5/core/ChecksumException.js");
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>The main class which implements Data Matrix Code decoding -- as opposed to locating and extracting
 * the Data Matrix Code from an image.</p>
 *
 * @author bbrown@google.com (Brian Brown)
 */
var Decoder = /** @class */ (function () {
    function Decoder() {
        this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.DATA_MATRIX_FIELD_256);
    }
    /**
     * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or "true" is taken
     * to mean a black module.</p>
     *
     * @param bits booleans representing white/black Data Matrix Code modules
     * @return text and bytes encoded within the Data Matrix Code
     * @throws FormatException if the Data Matrix Code cannot be decoded
     * @throws ChecksumException if error correction fails
     */
    Decoder.prototype.decode = function (bits) {
        var e_1, _a;
        // Construct a parser and read version, error-correction level
        var parser = new BitMatrixParser_1.default(bits);
        var version = parser.getVersion();
        // Read codewords
        var codewords = parser.readCodewords();
        // Separate into data blocks
        var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version);
        // Count total number of data bytes
        var totalBytes = 0;
        try {
            for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {
                var db = dataBlocks_1_1.value;
                totalBytes += db.getNumDataCodewords();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var resultBytes = new Uint8Array(totalBytes);
        var dataBlocksCount = dataBlocks.length;
        // Error-correct and copy data blocks together into a stream of bytes
        for (var j = 0; j < dataBlocksCount; j++) {
            var dataBlock = dataBlocks[j];
            var codewordBytes = dataBlock.getCodewords();
            var numDataCodewords = dataBlock.getNumDataCodewords();
            this.correctErrors(codewordBytes, numDataCodewords);
            for (var i = 0; i < numDataCodewords; i++) {
                // De-interlace data blocks.
                resultBytes[i * dataBlocksCount + j] = codewordBytes[i];
            }
        }
        // Decode the contents of that stream of bytes
        return DecodedBitStreamParser_1.default.decode(resultBytes);
    };
    /**
     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
     * correct the errors in-place using Reed-Solomon error correction.</p>
     *
     * @param codewordBytes data and error correction codewords
     * @param numDataCodewords number of codewords that are data bytes
     * @throws ChecksumException if error correction fails
     */
    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords) {
        var numCodewords = codewordBytes.length;
        // First read into an array of ints
        var codewordsInts = new Int32Array(codewordBytes);
        // for (let i = 0; i < numCodewords; i++) {
        //   codewordsInts[i] = codewordBytes[i] & 0xFF;
        // }
        try {
            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
        }
        catch (ignored /* ReedSolomonException */) {
            throw new ChecksumException_1.default();
        }
        // Copy back into array of bytes -- only need to worry about the bytes that were data
        // We don't care about errors in the error-correction codewords
        for (var i = 0; i < numDataCodewords; i++) {
            codewordBytes[i] = codewordsInts[i];
        }
    };
    return Decoder;
}());
exports.default = Decoder;
//# sourceMappingURL=Decoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/datamatrix/decoder/Version.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/datamatrix/decoder/Version.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var FormatException_1 = __webpack_require__(/*! ../../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will
 * use blocks of differing sizes within one version, so, this encapsulates the parameters for
 * each set of blocks. It also holds the number of error-correction codewords per block since it
 * will be the same across all blocks within one version.</p>
 */
var ECBlocks = /** @class */ (function () {
    function ECBlocks(ecCodewords, ecBlocks1, ecBlocks2) {
        this.ecCodewords = ecCodewords;
        this.ecBlocks = [ecBlocks1];
        ecBlocks2 && this.ecBlocks.push(ecBlocks2);
    }
    ECBlocks.prototype.getECCodewords = function () {
        return this.ecCodewords;
    };
    ECBlocks.prototype.getECBlocks = function () {
        return this.ecBlocks;
    };
    return ECBlocks;
}());
exports.ECBlocks = ECBlocks;
/**
 * <p>Encapsulates the parameters for one error-correction block in one symbol version.
 * This includes the number of data codewords, and the number of times a block with these
 * parameters is used consecutively in the Data Matrix code version's format.</p>
 */
var ECB = /** @class */ (function () {
    function ECB(count, dataCodewords) {
        this.count = count;
        this.dataCodewords = dataCodewords;
    }
    ECB.prototype.getCount = function () {
        return this.count;
    };
    ECB.prototype.getDataCodewords = function () {
        return this.dataCodewords;
    };
    return ECB;
}());
exports.ECB = ECB;
/**
 * The Version object encapsulates attributes about a particular
 * size Data Matrix Code.
 *
 * @author bbrown@google.com (Brian Brown)
 */
var Version = /** @class */ (function () {
    function Version(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {
        var e_1, _a;
        this.versionNumber = versionNumber;
        this.symbolSizeRows = symbolSizeRows;
        this.symbolSizeColumns = symbolSizeColumns;
        this.dataRegionSizeRows = dataRegionSizeRows;
        this.dataRegionSizeColumns = dataRegionSizeColumns;
        this.ecBlocks = ecBlocks;
        // Calculate the total number of codewords
        var total = 0;
        var ecCodewords = ecBlocks.getECCodewords();
        var ecbArray = ecBlocks.getECBlocks();
        try {
            for (var ecbArray_1 = __values(ecbArray), ecbArray_1_1 = ecbArray_1.next(); !ecbArray_1_1.done; ecbArray_1_1 = ecbArray_1.next()) {
                var ecBlock = ecbArray_1_1.value;
                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ecbArray_1_1 && !ecbArray_1_1.done && (_a = ecbArray_1.return)) _a.call(ecbArray_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.totalCodewords = total;
    }
    Version.prototype.getVersionNumber = function () {
        return this.versionNumber;
    };
    Version.prototype.getSymbolSizeRows = function () {
        return this.symbolSizeRows;
    };
    Version.prototype.getSymbolSizeColumns = function () {
        return this.symbolSizeColumns;
    };
    Version.prototype.getDataRegionSizeRows = function () {
        return this.dataRegionSizeRows;
    };
    Version.prototype.getDataRegionSizeColumns = function () {
        return this.dataRegionSizeColumns;
    };
    Version.prototype.getTotalCodewords = function () {
        return this.totalCodewords;
    };
    Version.prototype.getECBlocks = function () {
        return this.ecBlocks;
    };
    /**
     * <p>Deduces version information from Data Matrix dimensions.</p>
     *
     * @param numRows Number of rows in modules
     * @param numColumns Number of columns in modules
     * @return Version for a Data Matrix Code of those dimensions
     * @throws FormatException if dimensions do correspond to a valid Data Matrix size
     */
    Version.getVersionForDimensions = function (numRows, numColumns) {
        var e_2, _a;
        if ((numRows & 0x01) !== 0 || (numColumns & 0x01) !== 0) {
            throw new FormatException_1.default();
        }
        try {
            for (var _b = __values(Version.VERSIONS), _c = _b.next(); !_c.done; _c = _b.next()) {
                var version = _c.value;
                if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {
                    return version;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        throw new FormatException_1.default();
    };
    //  @Override
    Version.prototype.toString = function () {
        return '' + this.versionNumber;
    };
    /**
     * See ISO 16022:2006 5.5.1 Table 7
     */
    Version.buildVersions = function () {
        return [
            new Version(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),
            new Version(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),
            new Version(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),
            new Version(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),
            new Version(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),
            new Version(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),
            new Version(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),
            new Version(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),
            new Version(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),
            new Version(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),
            new Version(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),
            new Version(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),
            new Version(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),
            new Version(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),
            new Version(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),
            new Version(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),
            new Version(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),
            new Version(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),
            new Version(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),
            new Version(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),
            new Version(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),
            new Version(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),
            new Version(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),
            new Version(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),
            new Version(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),
            new Version(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),
            new Version(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),
            new Version(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),
            new Version(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),
            new Version(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))
        ];
    };
    Version.VERSIONS = Version.buildVersions();
    return Version;
}());
exports.default = Version;
//# sourceMappingURL=Version.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/datamatrix/detector/Detector.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/datamatrix/detector/Detector.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var DetectorResult_1 = __webpack_require__(/*! ../../common/DetectorResult */ "./node_modules/@zxing/library/esm5/core/common/DetectorResult.js");
var GridSamplerInstance_1 = __webpack_require__(/*! ../../common/GridSamplerInstance */ "./node_modules/@zxing/library/esm5/core/common/GridSamplerInstance.js");
var WhiteRectangleDetector_1 = __webpack_require__(/*! ../../common/detector/WhiteRectangleDetector */ "./node_modules/@zxing/library/esm5/core/common/detector/WhiteRectangleDetector.js");
var NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * <p>Encapsulates logic that can detect a Data Matrix Code in an image, even if the Data Matrix Code
 * is rotated or skewed, or partially obscured.</p>
 *
 * @author Sean Owen
 */
var Detector = /** @class */ (function () {
    function Detector(image) {
        this.image = image;
        this.rectangleDetector = new WhiteRectangleDetector_1.default(this.image);
    }
    /**
     * <p>Detects a Data Matrix Code in an image.</p>
     *
     * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code
     * @throws NotFoundException if no Data Matrix Code can be found
     */
    Detector.prototype.detect = function () {
        var cornerPoints = this.rectangleDetector.detect();
        var points = this.detectSolid1(cornerPoints);
        points = this.detectSolid2(points);
        points[3] = this.correctTopRight(points);
        if (!points[3]) {
            throw new NotFoundException_1.default();
        }
        points = this.shiftToModuleCenter(points);
        var topLeft = points[0];
        var bottomLeft = points[1];
        var bottomRight = points[2];
        var topRight = points[3];
        var dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;
        var dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;
        if ((dimensionTop & 0x01) === 1) {
            dimensionTop += 1;
        }
        if ((dimensionRight & 0x01) === 1) {
            dimensionRight += 1;
        }
        if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {
            // The matrix is square
            dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);
        }
        var bits = Detector.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);
        return new DetectorResult_1.default(bits, [topLeft, bottomLeft, bottomRight, topRight]);
    };
    Detector.shiftPoint = function (point, to, div) {
        var x = (to.getX() - point.getX()) / (div + 1);
        var y = (to.getY() - point.getY()) / (div + 1);
        return new ResultPoint_1.default(point.getX() + x, point.getY() + y);
    };
    Detector.moveAway = function (point, fromX, fromY) {
        var x = point.getX();
        var y = point.getY();
        if (x < fromX) {
            x -= 1;
        }
        else {
            x += 1;
        }
        if (y < fromY) {
            y -= 1;
        }
        else {
            y += 1;
        }
        return new ResultPoint_1.default(x, y);
    };
    /**
     * Detect a solid side which has minimum transition.
     */
    Detector.prototype.detectSolid1 = function (cornerPoints) {
        // 0  2
        // 1  3
        var pointA = cornerPoints[0];
        var pointB = cornerPoints[1];
        var pointC = cornerPoints[3];
        var pointD = cornerPoints[2];
        var trAB = this.transitionsBetween(pointA, pointB);
        var trBC = this.transitionsBetween(pointB, pointC);
        var trCD = this.transitionsBetween(pointC, pointD);
        var trDA = this.transitionsBetween(pointD, pointA);
        // 0..3
        // :  :
        // 1--2
        var min = trAB;
        var points = [pointD, pointA, pointB, pointC];
        if (min > trBC) {
            min = trBC;
            points[0] = pointA;
            points[1] = pointB;
            points[2] = pointC;
            points[3] = pointD;
        }
        if (min > trCD) {
            min = trCD;
            points[0] = pointB;
            points[1] = pointC;
            points[2] = pointD;
            points[3] = pointA;
        }
        if (min > trDA) {
            points[0] = pointC;
            points[1] = pointD;
            points[2] = pointA;
            points[3] = pointB;
        }
        return points;
    };
    /**
     * Detect a second solid side next to first solid side.
     */
    Detector.prototype.detectSolid2 = function (points) {
        // A..D
        // :  :
        // B--C
        var pointA = points[0];
        var pointB = points[1];
        var pointC = points[2];
        var pointD = points[3];
        // Transition detection on the edge is not stable.
        // To safely detect, shift the points to the module center.
        var tr = this.transitionsBetween(pointA, pointD);
        var pointBs = Detector.shiftPoint(pointB, pointC, (tr + 1) * 4);
        var pointCs = Detector.shiftPoint(pointC, pointB, (tr + 1) * 4);
        var trBA = this.transitionsBetween(pointBs, pointA);
        var trCD = this.transitionsBetween(pointCs, pointD);
        // 0..3
        // |  :
        // 1--2
        if (trBA < trCD) {
            // solid sides: A-B-C
            points[0] = pointA;
            points[1] = pointB;
            points[2] = pointC;
            points[3] = pointD;
        }
        else {
            // solid sides: B-C-D
            points[0] = pointB;
            points[1] = pointC;
            points[2] = pointD;
            points[3] = pointA;
        }
        return points;
    };
    /**
     * Calculates the corner position of the white top right module.
     */
    Detector.prototype.correctTopRight = function (points) {
        // A..D
        // |  :
        // B--C
        var pointA = points[0];
        var pointB = points[1];
        var pointC = points[2];
        var pointD = points[3];
        // shift points for safe transition detection.
        var trTop = this.transitionsBetween(pointA, pointD);
        var trRight = this.transitionsBetween(pointB, pointD);
        var pointAs = Detector.shiftPoint(pointA, pointB, (trRight + 1) * 4);
        var pointCs = Detector.shiftPoint(pointC, pointB, (trTop + 1) * 4);
        trTop = this.transitionsBetween(pointAs, pointD);
        trRight = this.transitionsBetween(pointCs, pointD);
        var candidate1 = new ResultPoint_1.default(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));
        var candidate2 = new ResultPoint_1.default(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));
        if (!this.isValid(candidate1)) {
            if (this.isValid(candidate2)) {
                return candidate2;
            }
            return null;
        }
        if (!this.isValid(candidate2)) {
            return candidate1;
        }
        var sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);
        var sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);
        if (sumc1 > sumc2) {
            return candidate1;
        }
        else {
            return candidate2;
        }
    };
    /**
     * Shift the edge points to the module center.
     */
    Detector.prototype.shiftToModuleCenter = function (points) {
        // A..D
        // |  :
        // B--C
        var pointA = points[0];
        var pointB = points[1];
        var pointC = points[2];
        var pointD = points[3];
        // calculate pseudo dimensions
        var dimH = this.transitionsBetween(pointA, pointD) + 1;
        var dimV = this.transitionsBetween(pointC, pointD) + 1;
        // shift points for safe dimension detection
        var pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);
        var pointCs = Detector.shiftPoint(pointC, pointB, dimH * 4);
        //  calculate more precise dimensions
        dimH = this.transitionsBetween(pointAs, pointD) + 1;
        dimV = this.transitionsBetween(pointCs, pointD) + 1;
        if ((dimH & 0x01) === 1) {
            dimH += 1;
        }
        if ((dimV & 0x01) === 1) {
            dimV += 1;
        }
        // WhiteRectangleDetector returns points inside of the rectangle.
        // I want points on the edges.
        var centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;
        var centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;
        pointA = Detector.moveAway(pointA, centerX, centerY);
        pointB = Detector.moveAway(pointB, centerX, centerY);
        pointC = Detector.moveAway(pointC, centerX, centerY);
        pointD = Detector.moveAway(pointD, centerX, centerY);
        var pointBs;
        var pointDs;
        // shift points to the center of each modules
        pointAs = Detector.shiftPoint(pointA, pointB, dimV * 4);
        pointAs = Detector.shiftPoint(pointAs, pointD, dimH * 4);
        pointBs = Detector.shiftPoint(pointB, pointA, dimV * 4);
        pointBs = Detector.shiftPoint(pointBs, pointC, dimH * 4);
        pointCs = Detector.shiftPoint(pointC, pointD, dimV * 4);
        pointCs = Detector.shiftPoint(pointCs, pointB, dimH * 4);
        pointDs = Detector.shiftPoint(pointD, pointC, dimV * 4);
        pointDs = Detector.shiftPoint(pointDs, pointA, dimH * 4);
        return [pointAs, pointBs, pointCs, pointDs];
    };
    Detector.prototype.isValid = function (p) {
        return p.getX() >= 0 && p.getX() < this.image.getWidth() && p.getY() > 0 && p.getY() < this.image.getHeight();
    };
    Detector.sampleGrid = function (image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {
        var sampler = GridSamplerInstance_1.default.getInstance();
        return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
    };
    /**
     * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.
     */
    Detector.prototype.transitionsBetween = function (from, to) {
        // See QR Code Detector, sizeOfBlackWhiteBlackRun()
        var fromX = Math.trunc(from.getX());
        var fromY = Math.trunc(from.getY());
        var toX = Math.trunc(to.getX());
        var toY = Math.trunc(to.getY());
        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
        if (steep) {
            var temp = fromX;
            fromX = fromY;
            fromY = temp;
            temp = toX;
            toX = toY;
            toY = temp;
        }
        var dx = Math.abs(toX - fromX);
        var dy = Math.abs(toY - fromY);
        var error = -dx / 2;
        var ystep = fromY < toY ? 1 : -1;
        var xstep = fromX < toX ? 1 : -1;
        var transitions = 0;
        var inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);
        for (var x = fromX, y = fromY; x !== toX; x += xstep) {
            var isBlack = this.image.get(steep ? y : x, steep ? x : y);
            if (isBlack !== inBlack) {
                transitions++;
                inBlack = isBlack;
            }
            error += dy;
            if (error > 0) {
                if (y === toY) {
                    break;
                }
                y += ystep;
                error -= dx;
            }
        }
        return transitions;
    };
    return Detector;
}());
exports.default = Detector;
//# sourceMappingURL=Detector.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/AbstractUPCEANReader.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/AbstractUPCEANReader.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var OneDReader_1 = __webpack_require__(/*! ./OneDReader */ "./node_modules/@zxing/library/esm5/core/oned/OneDReader.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var FormatException_1 = __webpack_require__(/*! ../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
/**
 * <p>Encapsulates functionality and implementation that is common to UPC and EAN families
 * of one-dimensional barcodes.</p>
 *
 * @author dswitkin@google.com (Daniel Switkin)
 * @author Sean Owen
 * @author alasdair@google.com (Alasdair Mackintosh)
 */
var AbstractUPCEANReader = /** @class */ (function (_super) {
    __extends(AbstractUPCEANReader, _super);
    function AbstractUPCEANReader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.decodeRowStringBuffer = '';
        return _this;
    }
    // private final UPCEANExtensionSupport extensionReader;
    // private final EANManufacturerOrgSupport eanManSupport;
    /*
    protected UPCEANReader() {
        decodeRowStringBuffer = new StringBuilder(20);
        extensionReader = new UPCEANExtensionSupport();
        eanManSupport = new EANManufacturerOrgSupport();
    }
    */
    AbstractUPCEANReader.findStartGuardPattern = function (row) {
        var foundStart = false;
        var startRange = null;
        var nextStart = 0;
        var counters = [0, 0, 0];
        while (!foundStart) {
            counters = [0, 0, 0];
            startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);
            var start = startRange[0];
            nextStart = startRange[1];
            var quietStart = start - (nextStart - start);
            if (quietStart >= 0) {
                foundStart = row.isRange(quietStart, start, false);
            }
        }
        return startRange;
    };
    AbstractUPCEANReader.checkChecksum = function (s) {
        return AbstractUPCEANReader.checkStandardUPCEANChecksum(s);
    };
    AbstractUPCEANReader.checkStandardUPCEANChecksum = function (s) {
        var length = s.length;
        if (length === 0)
            return false;
        var check = parseInt(s.charAt(length - 1), 10);
        return AbstractUPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
    };
    AbstractUPCEANReader.getStandardUPCEANChecksum = function (s) {
        var length = s.length;
        var sum = 0;
        for (var i = length - 1; i >= 0; i -= 2) {
            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
            if (digit < 0 || digit > 9) {
                throw new FormatException_1.default();
            }
            sum += digit;
        }
        sum *= 3;
        for (var i = length - 2; i >= 0; i -= 2) {
            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
            if (digit < 0 || digit > 9) {
                throw new FormatException_1.default();
            }
            sum += digit;
        }
        return (1000 - sum) % 10;
    };
    AbstractUPCEANReader.decodeEnd = function (row, endStart) {
        return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));
    };
    AbstractUPCEANReader.findGuardPattern = function (row, rowOffset, whiteFirst, pattern, counters) {
        var width = row.getSize();
        rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);
        var counterPosition = 0;
        var patternStart = rowOffset;
        var patternLength = pattern.length;
        var isWhite = whiteFirst;
        for (var x = rowOffset; x < width; x++) {
            if (row.get(x) !== isWhite) {
                counters[counterPosition]++;
            }
            else {
                if (counterPosition === patternLength - 1) {
                    if (OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {
                        return [patternStart, x];
                    }
                    patternStart += counters[0] + counters[1];
                    var slice = counters.slice(2, counters.length);
                    for (var i = 0; i < counterPosition - 1; i++) {
                        counters[i] = slice[i];
                    }
                    counters[counterPosition - 1] = 0;
                    counters[counterPosition] = 0;
                    counterPosition--;
                }
                else {
                    counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
            }
        }
        throw new NotFoundException_1.default();
    };
    AbstractUPCEANReader.decodeDigit = function (row, counters, rowOffset, patterns) {
        this.recordPattern(row, rowOffset, counters);
        var bestVariance = this.MAX_AVG_VARIANCE;
        var bestMatch = -1;
        var max = patterns.length;
        for (var i = 0; i < max; i++) {
            var pattern = patterns[i];
            var variance = OneDReader_1.default.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);
            if (variance < bestVariance) {
                bestVariance = variance;
                bestMatch = i;
            }
        }
        if (bestMatch >= 0) {
            return bestMatch;
        }
        else {
            throw new NotFoundException_1.default();
        }
    };
    // These two values are critical for determining how permissive the decoding will be.
    // We've arrived at these values through a lot of trial and error. Setting them any higher
    // lets false positives creep in quickly.
    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;
    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;
    /**
     * Start/end guard pattern.
     */
    AbstractUPCEANReader.START_END_PATTERN = [1, 1, 1];
    /**
     * Pattern marking the middle of a UPC/EAN pattern, separating the two halves.
     */
    AbstractUPCEANReader.MIDDLE_PATTERN = [1, 1, 1, 1, 1];
    /**
     * end guard pattern.
     */
    AbstractUPCEANReader.END_PATTERN = [1, 1, 1, 1, 1, 1];
    /**
     * "Odd", or "L" patterns used to encode UPC/EAN digits.
     */
    AbstractUPCEANReader.L_PATTERNS = [
        [3, 2, 1, 1],
        [2, 2, 2, 1],
        [2, 1, 2, 2],
        [1, 4, 1, 1],
        [1, 1, 3, 2],
        [1, 2, 3, 1],
        [1, 1, 1, 4],
        [1, 3, 1, 2],
        [1, 2, 1, 3],
        [3, 1, 1, 2],
    ];
    return AbstractUPCEANReader;
}(OneDReader_1.default));
exports.default = AbstractUPCEANReader;
//# sourceMappingURL=AbstractUPCEANReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/Code128Reader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/Code128Reader.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.oned {*/
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var Result_1 = __webpack_require__(/*! ../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
var ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var OneDReader_1 = __webpack_require__(/*! ./OneDReader */ "./node_modules/@zxing/library/esm5/core/oned/OneDReader.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var FormatException_1 = __webpack_require__(/*! ../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
var ChecksumException_1 = __webpack_require__(/*! ../ChecksumException */ "./node_modules/@zxing/library/esm5/core/ChecksumException.js");
/**
 * <p>Decodes Code 128 barcodes.</p>
 *
 * @author Sean Owen
 */
var Code128Reader = /** @class */ (function (_super) {
    __extends(Code128Reader, _super);
    function Code128Reader() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Code128Reader.findStartPattern = function (row) {
        var width = row.getSize();
        var rowOffset = row.getNextSet(0);
        var counterPosition = 0;
        var counters = [0, 0, 0, 0, 0, 0];
        var patternStart = rowOffset;
        var isWhite = false;
        var patternLength = 6;
        for (var i = rowOffset; i < width; i++) {
            if (row.get(i) !== isWhite) {
                counters[counterPosition]++;
            }
            else {
                if (counterPosition === (patternLength - 1)) {
                    var bestVariance = Code128Reader.MAX_AVG_VARIANCE;
                    var bestMatch = -1;
                    for (var startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {
                        var variance = OneDReader_1.default.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);
                        if (variance < bestVariance) {
                            bestVariance = variance;
                            bestMatch = startCode;
                        }
                    }
                    // Look for whitespace before start pattern, >= 50% of width of start pattern
                    if (bestMatch >= 0 &&
                        row.isRange(Math.max(0, patternStart - (i - patternStart) / 2), patternStart, false)) {
                        return [patternStart, i, bestMatch];
                    }
                    patternStart += counters[0] + counters[1];
                    counters.splice(0, 2);
                    counters[counterPosition - 1] = 0;
                    counters[counterPosition] = 0;
                    counterPosition--;
                }
                else {
                    counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
            }
        }
        throw new NotFoundException_1.default();
    };
    Code128Reader.decodeCode = function (row, counters, rowOffset) {
        OneDReader_1.default.recordPattern(row, rowOffset, counters);
        var bestVariance = Code128Reader.MAX_AVG_VARIANCE; // worst variance we'll accept
        var bestMatch = -1;
        for (var d = 0; d < Code128Reader.CODE_PATTERNS.length; d++) {
            var pattern = Code128Reader.CODE_PATTERNS[d];
            var variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);
            if (variance < bestVariance) {
                bestVariance = variance;
                bestMatch = d;
            }
        }
        // TODO We're overlooking the fact that the STOP pattern has 7 values, not 6.
        if (bestMatch >= 0) {
            return bestMatch;
        }
        else {
            throw new NotFoundException_1.default();
        }
    };
    Code128Reader.prototype.decodeRow = function (rowNumber, row, hints) {
        var convertFNC1 = hints && (hints.get(DecodeHintType_1.default.ASSUME_GS1) === true);
        var startPatternInfo = Code128Reader.findStartPattern(row);
        var startCode = startPatternInfo[2];
        var currentRawCodesIndex = 0;
        var rawCodes = new Uint8Array(20);
        rawCodes[currentRawCodesIndex++] = startCode;
        var codeSet;
        switch (startCode) {
            case Code128Reader.CODE_START_A:
                codeSet = Code128Reader.CODE_CODE_A;
                break;
            case Code128Reader.CODE_START_B:
                codeSet = Code128Reader.CODE_CODE_B;
                break;
            case Code128Reader.CODE_START_C:
                codeSet = Code128Reader.CODE_CODE_C;
                break;
            default:
                throw new FormatException_1.default();
        }
        var done = false;
        var isNextShifted = false;
        var result = '';
        var lastStart = startPatternInfo[0];
        var nextStart = startPatternInfo[1];
        var counters = [0, 0, 0, 0, 0, 0];
        var lastCode = 0;
        var code = 0;
        var checksumTotal = startCode;
        var multiplier = 0;
        var lastCharacterWasPrintable = true;
        var upperMode = false;
        var shiftUpperMode = false;
        while (!done) {
            var unshift = isNextShifted;
            isNextShifted = false;
            // Save off last code
            lastCode = code;
            // Decode another code from image
            code = Code128Reader.decodeCode(row, counters, nextStart);
            rawCodes[currentRawCodesIndex++] = code;
            // Remember whether the last code was printable or not (excluding CODE_STOP)
            if (code !== Code128Reader.CODE_STOP) {
                lastCharacterWasPrintable = true;
            }
            // Add to checksum computation (if not CODE_STOP of course)
            if (code !== Code128Reader.CODE_STOP) {
                multiplier++;
                checksumTotal += multiplier * code;
            }
            // Advance to where the next code will to start
            lastStart = nextStart;
            nextStart += counters.reduce(function (previous, current) { return previous + current; }, 0);
            // Take care of illegal start codes
            switch (code) {
                case Code128Reader.CODE_START_A:
                case Code128Reader.CODE_START_B:
                case Code128Reader.CODE_START_C:
                    throw new FormatException_1.default();
            }
            switch (codeSet) {
                case Code128Reader.CODE_CODE_A:
                    if (code < 64) {
                        if (shiftUpperMode === upperMode) {
                            result += String.fromCharCode((' '.charCodeAt(0) + code));
                        }
                        else {
                            result += String.fromCharCode((' '.charCodeAt(0) + code + 128));
                        }
                        shiftUpperMode = false;
                    }
                    else if (code < 96) {
                        if (shiftUpperMode === upperMode) {
                            result += String.fromCharCode((code - 64));
                        }
                        else {
                            result += String.fromCharCode((code + 64));
                        }
                        shiftUpperMode = false;
                    }
                    else {
                        // Don't let CODE_STOP, which always appears, affect whether whether we think the last
                        // code was printable or not.
                        if (code !== Code128Reader.CODE_STOP) {
                            lastCharacterWasPrintable = false;
                        }
                        switch (code) {
                            case Code128Reader.CODE_FNC_1:
                                if (convertFNC1) {
                                    if (result.length === 0) {
                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code
                                        // is FNC1 then this is GS1-128. We add the symbology identifier.
                                        result += ']C1';
                                    }
                                    else {
                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)
                                        result += String.fromCharCode(29);
                                    }
                                }
                                break;
                            case Code128Reader.CODE_FNC_2:
                            case Code128Reader.CODE_FNC_3:
                                // do nothing?
                                break;
                            case Code128Reader.CODE_FNC_4_A:
                                if (!upperMode && shiftUpperMode) {
                                    upperMode = true;
                                    shiftUpperMode = false;
                                }
                                else if (upperMode && shiftUpperMode) {
                                    upperMode = false;
                                    shiftUpperMode = false;
                                }
                                else {
                                    shiftUpperMode = true;
                                }
                                break;
                            case Code128Reader.CODE_SHIFT:
                                isNextShifted = true;
                                codeSet = Code128Reader.CODE_CODE_B;
                                break;
                            case Code128Reader.CODE_CODE_B:
                                codeSet = Code128Reader.CODE_CODE_B;
                                break;
                            case Code128Reader.CODE_CODE_C:
                                codeSet = Code128Reader.CODE_CODE_C;
                                break;
                            case Code128Reader.CODE_STOP:
                                done = true;
                                break;
                        }
                    }
                    break;
                case Code128Reader.CODE_CODE_B:
                    if (code < 96) {
                        if (shiftUpperMode === upperMode) {
                            result += String.fromCharCode((' '.charCodeAt(0) + code));
                        }
                        else {
                            result += String.fromCharCode((' '.charCodeAt(0) + code + 128));
                        }
                        shiftUpperMode = false;
                    }
                    else {
                        if (code !== Code128Reader.CODE_STOP) {
                            lastCharacterWasPrintable = false;
                        }
                        switch (code) {
                            case Code128Reader.CODE_FNC_1:
                                if (convertFNC1) {
                                    if (result.length === 0) {
                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code
                                        // is FNC1 then this is GS1-128. We add the symbology identifier.
                                        result += ']C1';
                                    }
                                    else {
                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)
                                        result += String.fromCharCode(29);
                                    }
                                }
                                break;
                            case Code128Reader.CODE_FNC_2:
                            case Code128Reader.CODE_FNC_3:
                                // do nothing?
                                break;
                            case Code128Reader.CODE_FNC_4_B:
                                if (!upperMode && shiftUpperMode) {
                                    upperMode = true;
                                    shiftUpperMode = false;
                                }
                                else if (upperMode && shiftUpperMode) {
                                    upperMode = false;
                                    shiftUpperMode = false;
                                }
                                else {
                                    shiftUpperMode = true;
                                }
                                break;
                            case Code128Reader.CODE_SHIFT:
                                isNextShifted = true;
                                codeSet = Code128Reader.CODE_CODE_A;
                                break;
                            case Code128Reader.CODE_CODE_A:
                                codeSet = Code128Reader.CODE_CODE_A;
                                break;
                            case Code128Reader.CODE_CODE_C:
                                codeSet = Code128Reader.CODE_CODE_C;
                                break;
                            case Code128Reader.CODE_STOP:
                                done = true;
                                break;
                        }
                    }
                    break;
                case Code128Reader.CODE_CODE_C:
                    if (code < 100) {
                        if (code < 10) {
                            result += '0';
                        }
                        result += code;
                    }
                    else {
                        if (code !== Code128Reader.CODE_STOP) {
                            lastCharacterWasPrintable = false;
                        }
                        switch (code) {
                            case Code128Reader.CODE_FNC_1:
                                if (convertFNC1) {
                                    if (result.length === 0) {
                                        // GS1 specification 5.4.3.7. and 5.4.6.4. If the first char after the start code
                                        // is FNC1 then this is GS1-128. We add the symbology identifier.
                                        result += ']C1';
                                    }
                                    else {
                                        // GS1 specification 5.4.7.5. Every subsequent FNC1 is returned as ASCII 29 (GS)
                                        result += String.fromCharCode(29);
                                    }
                                }
                                break;
                            case Code128Reader.CODE_CODE_A:
                                codeSet = Code128Reader.CODE_CODE_A;
                                break;
                            case Code128Reader.CODE_CODE_B:
                                codeSet = Code128Reader.CODE_CODE_B;
                                break;
                            case Code128Reader.CODE_STOP:
                                done = true;
                                break;
                        }
                    }
                    break;
            }
            // Unshift back to another code set if we were shifted
            if (unshift) {
                codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;
            }
        }
        var lastPatternSize = nextStart - lastStart;
        // Check for ample whitespace following pattern, but, to do this we first need to remember that
        // we fudged decoding CODE_STOP since it actually has 7 bars, not 6. There is a black bar left
        // to read off. Would be slightly better to properly read. Here we just skip it:
        nextStart = row.getNextUnset(nextStart);
        if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {
            throw new NotFoundException_1.default();
        }
        // Pull out from sum the value of the penultimate check code
        checksumTotal -= multiplier * lastCode;
        // lastCode is the checksum then:
        if (checksumTotal % 103 !== lastCode) {
            throw new ChecksumException_1.default();
        }
        // Need to pull out the check digits from string
        var resultLength = result.length;
        if (resultLength === 0) {
            // false positive
            throw new NotFoundException_1.default();
        }
        // Only bother if the result had at least one character, and if the checksum digit happened to
        // be a printable character. If it was just interpreted as a control code, nothing to remove.
        if (resultLength > 0 && lastCharacterWasPrintable) {
            if (codeSet === Code128Reader.CODE_CODE_C) {
                result = result.substring(0, resultLength - 2);
            }
            else {
                result = result.substring(0, resultLength - 1);
            }
        }
        var left = (startPatternInfo[1] + startPatternInfo[0]) / 2.0;
        var right = lastStart + lastPatternSize / 2.0;
        var rawCodesSize = rawCodes.length;
        var rawBytes = new Uint8Array(rawCodesSize);
        for (var i = 0; i < rawCodesSize; i++) {
            rawBytes[i] = rawCodes[i];
        }
        var points = [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)];
        return new Result_1.default(result, rawBytes, 0, points, BarcodeFormat_1.default.CODE_128, new Date().getTime());
    };
    Code128Reader.CODE_PATTERNS = [
        [2, 1, 2, 2, 2, 2],
        [2, 2, 2, 1, 2, 2],
        [2, 2, 2, 2, 2, 1],
        [1, 2, 1, 2, 2, 3],
        [1, 2, 1, 3, 2, 2],
        [1, 3, 1, 2, 2, 2],
        [1, 2, 2, 2, 1, 3],
        [1, 2, 2, 3, 1, 2],
        [1, 3, 2, 2, 1, 2],
        [2, 2, 1, 2, 1, 3],
        [2, 2, 1, 3, 1, 2],
        [2, 3, 1, 2, 1, 2],
        [1, 1, 2, 2, 3, 2],
        [1, 2, 2, 1, 3, 2],
        [1, 2, 2, 2, 3, 1],
        [1, 1, 3, 2, 2, 2],
        [1, 2, 3, 1, 2, 2],
        [1, 2, 3, 2, 2, 1],
        [2, 2, 3, 2, 1, 1],
        [2, 2, 1, 1, 3, 2],
        [2, 2, 1, 2, 3, 1],
        [2, 1, 3, 2, 1, 2],
        [2, 2, 3, 1, 1, 2],
        [3, 1, 2, 1, 3, 1],
        [3, 1, 1, 2, 2, 2],
        [3, 2, 1, 1, 2, 2],
        [3, 2, 1, 2, 2, 1],
        [3, 1, 2, 2, 1, 2],
        [3, 2, 2, 1, 1, 2],
        [3, 2, 2, 2, 1, 1],
        [2, 1, 2, 1, 2, 3],
        [2, 1, 2, 3, 2, 1],
        [2, 3, 2, 1, 2, 1],
        [1, 1, 1, 3, 2, 3],
        [1, 3, 1, 1, 2, 3],
        [1, 3, 1, 3, 2, 1],
        [1, 1, 2, 3, 1, 3],
        [1, 3, 2, 1, 1, 3],
        [1, 3, 2, 3, 1, 1],
        [2, 1, 1, 3, 1, 3],
        [2, 3, 1, 1, 1, 3],
        [2, 3, 1, 3, 1, 1],
        [1, 1, 2, 1, 3, 3],
        [1, 1, 2, 3, 3, 1],
        [1, 3, 2, 1, 3, 1],
        [1, 1, 3, 1, 2, 3],
        [1, 1, 3, 3, 2, 1],
        [1, 3, 3, 1, 2, 1],
        [3, 1, 3, 1, 2, 1],
        [2, 1, 1, 3, 3, 1],
        [2, 3, 1, 1, 3, 1],
        [2, 1, 3, 1, 1, 3],
        [2, 1, 3, 3, 1, 1],
        [2, 1, 3, 1, 3, 1],
        [3, 1, 1, 1, 2, 3],
        [3, 1, 1, 3, 2, 1],
        [3, 3, 1, 1, 2, 1],
        [3, 1, 2, 1, 1, 3],
        [3, 1, 2, 3, 1, 1],
        [3, 3, 2, 1, 1, 1],
        [3, 1, 4, 1, 1, 1],
        [2, 2, 1, 4, 1, 1],
        [4, 3, 1, 1, 1, 1],
        [1, 1, 1, 2, 2, 4],
        [1, 1, 1, 4, 2, 2],
        [1, 2, 1, 1, 2, 4],
        [1, 2, 1, 4, 2, 1],
        [1, 4, 1, 1, 2, 2],
        [1, 4, 1, 2, 2, 1],
        [1, 1, 2, 2, 1, 4],
        [1, 1, 2, 4, 1, 2],
        [1, 2, 2, 1, 1, 4],
        [1, 2, 2, 4, 1, 1],
        [1, 4, 2, 1, 1, 2],
        [1, 4, 2, 2, 1, 1],
        [2, 4, 1, 2, 1, 1],
        [2, 2, 1, 1, 1, 4],
        [4, 1, 3, 1, 1, 1],
        [2, 4, 1, 1, 1, 2],
        [1, 3, 4, 1, 1, 1],
        [1, 1, 1, 2, 4, 2],
        [1, 2, 1, 1, 4, 2],
        [1, 2, 1, 2, 4, 1],
        [1, 1, 4, 2, 1, 2],
        [1, 2, 4, 1, 1, 2],
        [1, 2, 4, 2, 1, 1],
        [4, 1, 1, 2, 1, 2],
        [4, 2, 1, 1, 1, 2],
        [4, 2, 1, 2, 1, 1],
        [2, 1, 2, 1, 4, 1],
        [2, 1, 4, 1, 2, 1],
        [4, 1, 2, 1, 2, 1],
        [1, 1, 1, 1, 4, 3],
        [1, 1, 1, 3, 4, 1],
        [1, 3, 1, 1, 4, 1],
        [1, 1, 4, 1, 1, 3],
        [1, 1, 4, 3, 1, 1],
        [4, 1, 1, 1, 1, 3],
        [4, 1, 1, 3, 1, 1],
        [1, 1, 3, 1, 4, 1],
        [1, 1, 4, 1, 3, 1],
        [3, 1, 1, 1, 4, 1],
        [4, 1, 1, 1, 3, 1],
        [2, 1, 1, 4, 1, 2],
        [2, 1, 1, 2, 1, 4],
        [2, 1, 1, 2, 3, 2],
        [2, 3, 3, 1, 1, 1, 2]
    ];
    Code128Reader.MAX_AVG_VARIANCE = 0.25;
    Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;
    Code128Reader.CODE_SHIFT = 98;
    Code128Reader.CODE_CODE_C = 99;
    Code128Reader.CODE_CODE_B = 100;
    Code128Reader.CODE_CODE_A = 101;
    Code128Reader.CODE_FNC_1 = 102;
    Code128Reader.CODE_FNC_2 = 97;
    Code128Reader.CODE_FNC_3 = 96;
    Code128Reader.CODE_FNC_4_A = 101;
    Code128Reader.CODE_FNC_4_B = 100;
    Code128Reader.CODE_START_A = 103;
    Code128Reader.CODE_START_B = 104;
    Code128Reader.CODE_START_C = 105;
    Code128Reader.CODE_STOP = 106;
    return Code128Reader;
}(OneDReader_1.default));
exports.default = Code128Reader;
//# sourceMappingURL=Code128Reader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/Code39Reader.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/Code39Reader.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.oned {*/
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var ChecksumException_1 = __webpack_require__(/*! ../ChecksumException */ "./node_modules/@zxing/library/esm5/core/ChecksumException.js");
var FormatException_1 = __webpack_require__(/*! ../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var OneDReader_1 = __webpack_require__(/*! ./OneDReader */ "./node_modules/@zxing/library/esm5/core/oned/OneDReader.js");
var Result_1 = __webpack_require__(/*! ../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
var ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
/**
 * <p>Decodes Code 39 barcodes. Supports "Full ASCII Code 39" if USE_CODE_39_EXTENDED_MODE is set.</p>
 *
 * @author Sean Owen
 * @see Code93Reader
 */
var Code39Reader = /** @class */ (function (_super) {
    __extends(Code39Reader, _super);
    /**
     * Creates a reader that assumes all encoded data is data, and does not treat the final
     * character as a check digit. It will not decoded "extended Code 39" sequences.
     */
    // public Code39Reader() {
    //   this(false);
    // }
    /**
     * Creates a reader that can be configured to check the last character as a check digit.
     * It will not decoded "extended Code 39" sequences.
     *
     * @param usingCheckDigit if true, treat the last data character as a check digit, not
     * data, and verify that the checksum passes.
     */
    // public Code39Reader(boolean usingCheckDigit) {
    //   this(usingCheckDigit, false);
    // }
    /**
     * Creates a reader that can be configured to check the last character as a check digit,
     * or optionally attempt to decode "extended Code 39" sequences that are used to encode
     * the full ASCII character set.
     *
     * @param usingCheckDigit if true, treat the last data character as a check digit, not
     * data, and verify that the checksum passes.
     * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the
     * text.
     */
    function Code39Reader(usingCheckDigit, extendedMode) {
        if (usingCheckDigit === void 0) { usingCheckDigit = false; }
        if (extendedMode === void 0) { extendedMode = false; }
        var _this = _super.call(this) || this;
        _this.usingCheckDigit = usingCheckDigit;
        _this.extendedMode = extendedMode;
        _this.decodeRowResult = '';
        _this.counters = new Array(9);
        return _this;
    }
    Code39Reader.prototype.decodeRow = function (rowNumber, row, hints) {
        var e_1, _a, e_2, _b;
        var theCounters = this.counters;
        theCounters.fill(0);
        this.decodeRowResult = '';
        var start = Code39Reader.findAsteriskPattern(row, theCounters);
        // Read off white space
        var nextStart = row.getNextSet(start[1]);
        var end = row.getSize();
        var decodedChar;
        var lastStart;
        do {
            Code39Reader.recordPattern(row, nextStart, theCounters);
            var pattern = Code39Reader.toNarrowWidePattern(theCounters);
            if (pattern < 0) {
                throw new NotFoundException_1.default();
            }
            decodedChar = Code39Reader.patternToChar(pattern);
            this.decodeRowResult += decodedChar;
            lastStart = nextStart;
            try {
                for (var theCounters_1 = __values(theCounters), theCounters_1_1 = theCounters_1.next(); !theCounters_1_1.done; theCounters_1_1 = theCounters_1.next()) {
                    var counter = theCounters_1_1.value;
                    nextStart += counter;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (theCounters_1_1 && !theCounters_1_1.done && (_a = theCounters_1.return)) _a.call(theCounters_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // Read off white space
            nextStart = row.getNextSet(nextStart);
        } while (decodedChar !== '*');
        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1); // remove asterisk
        // Look for whitespace after pattern:
        var lastPatternSize = 0;
        try {
            for (var theCounters_2 = __values(theCounters), theCounters_2_1 = theCounters_2.next(); !theCounters_2_1.done; theCounters_2_1 = theCounters_2.next()) {
                var counter = theCounters_2_1.value;
                lastPatternSize += counter;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (theCounters_2_1 && !theCounters_2_1.done && (_b = theCounters_2.return)) _b.call(theCounters_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;
        // If 50% of last pattern size, following last pattern, is not whitespace, fail
        // (but if it's whitespace to the very end of the image, that's OK)
        if (nextStart !== end && (whiteSpaceAfterEnd * 2) < lastPatternSize) {
            throw new NotFoundException_1.default();
        }
        if (this.usingCheckDigit) {
            var max = this.decodeRowResult.length - 1;
            var total = 0;
            for (var i = 0; i < max; i++) {
                total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i));
            }
            if (this.decodeRowResult.charAt(max) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {
                throw new ChecksumException_1.default();
            }
            this.decodeRowResult = this.decodeRowResult.substring(0, max);
        }
        if (this.decodeRowResult.length === 0) {
            // false positive
            throw new NotFoundException_1.default();
        }
        var resultString;
        if (this.extendedMode) {
            resultString = Code39Reader.decodeExtended(this.decodeRowResult);
        }
        else {
            resultString = this.decodeRowResult;
        }
        var left = (start[1] + start[0]) / 2.0;
        var right = lastStart + lastPatternSize / 2.0;
        return new Result_1.default(resultString, null, 0, [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)], BarcodeFormat_1.default.CODE_39, new Date().getTime());
    };
    Code39Reader.findAsteriskPattern = function (row, counters) {
        var width = row.getSize();
        var rowOffset = row.getNextSet(0);
        var counterPosition = 0;
        var patternStart = rowOffset;
        var isWhite = false;
        var patternLength = counters.length;
        for (var i = rowOffset; i < width; i++) {
            if (row.get(i) !== isWhite) {
                counters[counterPosition]++;
            }
            else {
                if (counterPosition === patternLength - 1) {
                    // Look for whitespace before start pattern, >= 50% of width of start pattern
                    if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING &&
                        row.isRange(Math.max(0, patternStart - Math.floor((i - patternStart) / 2)), patternStart, false)) {
                        return [patternStart, i];
                    }
                    patternStart += counters[0] + counters[1];
                    counters.copyWithin(0, 2, 2 + counterPosition - 1);
                    counters[counterPosition - 1] = 0;
                    counters[counterPosition] = 0;
                    counterPosition--;
                }
                else {
                    counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
            }
        }
        throw new NotFoundException_1.default();
    };
    // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions
    // per image when using some of our blackbox images.
    Code39Reader.toNarrowWidePattern = function (counters) {
        var e_3, _a;
        var numCounters = counters.length;
        var maxNarrowCounter = 0;
        var wideCounters;
        do {
            var minCounter = 0x7fffffff;
            try {
                for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
                    var counter = counters_1_1.value;
                    if (counter < minCounter && counter > maxNarrowCounter) {
                        minCounter = counter;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
            maxNarrowCounter = minCounter;
            wideCounters = 0;
            var totalWideCountersWidth = 0;
            var pattern = 0;
            for (var i = 0; i < numCounters; i++) {
                var counter = counters[i];
                if (counter > maxNarrowCounter) {
                    pattern |= 1 << (numCounters - 1 - i);
                    wideCounters++;
                    totalWideCountersWidth += counter;
                }
            }
            if (wideCounters === 3) {
                // Found 3 wide counters, but are they close enough in width?
                // We can perform a cheap, conservative check to see if any individual
                // counter is more than 1.5 times the average:
                for (var i = 0; i < numCounters && wideCounters > 0; i++) {
                    var counter = counters[i];
                    if (counter > maxNarrowCounter) {
                        wideCounters--;
                        // totalWideCountersWidth = 3 * average, so this checks if counter >= 3/2 * average
                        if ((counter * 2) >= totalWideCountersWidth) {
                            return -1;
                        }
                    }
                }
                return pattern;
            }
        } while (wideCounters > 3);
        return -1;
    };
    Code39Reader.patternToChar = function (pattern) {
        for (var i = 0; i < Code39Reader.CHARACTER_ENCODINGS.length; i++) {
            if (Code39Reader.CHARACTER_ENCODINGS[i] === pattern) {
                return Code39Reader.ALPHABET_STRING.charAt(i);
            }
        }
        if (pattern === Code39Reader.ASTERISK_ENCODING) {
            return '*';
        }
        throw new NotFoundException_1.default();
    };
    Code39Reader.decodeExtended = function (encoded) {
        var length = encoded.length;
        var decoded = '';
        for (var i = 0; i < length; i++) {
            var c = encoded.charAt(i);
            if (c === '+' || c === '$' || c === '%' || c === '/') {
                var next = encoded.charAt(i + 1);
                var decodedChar = '\0';
                switch (c) {
                    case '+':
                        // +A to +Z map to a to z
                        if (next >= 'A' && next <= 'Z') {
                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);
                        }
                        else {
                            throw new FormatException_1.default();
                        }
                        break;
                    case '$':
                        // $A to $Z map to control codes SH to SB
                        if (next >= 'A' && next <= 'Z') {
                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);
                        }
                        else {
                            throw new FormatException_1.default();
                        }
                        break;
                    case '%':
                        // %A to %E map to control codes ESC to US
                        if (next >= 'A' && next <= 'E') {
                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);
                        }
                        else if (next >= 'F' && next <= 'J') {
                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);
                        }
                        else if (next >= 'K' && next <= 'O') {
                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);
                        }
                        else if (next >= 'P' && next <= 'T') {
                            decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);
                        }
                        else if (next === 'U') {
                            decodedChar = '\0';
                        }
                        else if (next === 'V') {
                            decodedChar = '@';
                        }
                        else if (next === 'W') {
                            decodedChar = '`';
                        }
                        else if (next === 'X' || next === 'Y' || next === 'Z') {
                            decodedChar = '\x7f';
                        }
                        else {
                            throw new FormatException_1.default();
                        }
                        break;
                    case '/':
                        // /A to /O map to ! to , and /Z maps to :
                        if (next >= 'A' && next <= 'O') {
                            decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);
                        }
                        else if (next === 'Z') {
                            decodedChar = ':';
                        }
                        else {
                            throw new FormatException_1.default();
                        }
                        break;
                }
                decoded += decodedChar;
                // bump up i again since we read two characters
                i++;
            }
            else {
                decoded += c;
            }
        }
        return decoded;
    };
    Code39Reader.ALPHABET_STRING = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%';
    /**
     * These represent the encodings of characters, as patterns of wide and narrow bars.
     * The 9 least-significant bits of each int correspond to the pattern of wide and narrow,
     * with 1s representing "wide" and 0s representing narrow.
     */
    Code39Reader.CHARACTER_ENCODINGS = [
        0x034, 0x121, 0x061, 0x160, 0x031, 0x130, 0x070, 0x025, 0x124, 0x064,
        0x109, 0x049, 0x148, 0x019, 0x118, 0x058, 0x00D, 0x10C, 0x04C, 0x01C,
        0x103, 0x043, 0x142, 0x013, 0x112, 0x052, 0x007, 0x106, 0x046, 0x016,
        0x181, 0x0C1, 0x1C0, 0x091, 0x190, 0x0D0, 0x085, 0x184, 0x0C4, 0x0A8,
        0x0A2, 0x08A, 0x02A // /-%
    ];
    Code39Reader.ASTERISK_ENCODING = 0x094;
    return Code39Reader;
}(OneDReader_1.default));
exports.default = Code39Reader;
//# sourceMappingURL=Code39Reader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/EAN13Reader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/EAN13Reader.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var UPCEANReader_1 = __webpack_require__(/*! ./UPCEANReader */ "./node_modules/@zxing/library/esm5/core/oned/UPCEANReader.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/**
 * <p>Implements decoding of the EAN-13 format.</p>
 *
 * @author dswitkin@google.com (Daniel Switkin)
 * @author Sean Owen
 * @author alasdair@google.com (Alasdair Mackintosh)
 */
var EAN13Reader = /** @class */ (function (_super) {
    __extends(EAN13Reader, _super);
    function EAN13Reader() {
        var _this = _super.call(this) || this;
        _this.decodeMiddleCounters = [0, 0, 0, 0];
        return _this;
    }
    EAN13Reader.prototype.decodeMiddle = function (row, startRange, resultString) {
        var e_1, _a, e_2, _b;
        var counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var end = row.getSize();
        var rowOffset = startRange[1];
        var lgPatternFound = 0;
        for (var x = 0; x < 6 && rowOffset < end; x++) {
            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_AND_G_PATTERNS);
            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));
            try {
                for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
                    var counter = counters_1_1.value;
                    rowOffset += counter;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (bestMatch >= 10) {
                lgPatternFound |= 1 << (5 - x);
            }
        }
        resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);
        var middleRange = UPCEANReader_1.default.findGuardPattern(row, rowOffset, true, UPCEANReader_1.default.MIDDLE_PATTERN, new Array(UPCEANReader_1.default.MIDDLE_PATTERN.length).fill(0));
        rowOffset = middleRange[1];
        for (var x = 0; x < 6 && rowOffset < end; x++) {
            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_PATTERNS);
            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));
            try {
                for (var counters_2 = __values(counters), counters_2_1 = counters_2.next(); !counters_2_1.done; counters_2_1 = counters_2.next()) {
                    var counter = counters_2_1.value;
                    rowOffset += counter;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (counters_2_1 && !counters_2_1.done && (_b = counters_2.return)) _b.call(counters_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        return { rowOffset: rowOffset, resultString: resultString };
    };
    EAN13Reader.prototype.getBarcodeFormat = function () {
        return BarcodeFormat_1.default.EAN_13;
    };
    EAN13Reader.determineFirstDigit = function (resultString, lgPatternFound) {
        for (var d = 0; d < 10; d++) {
            if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d]) {
                resultString = String.fromCharCode(('0'.charCodeAt(0) + d)) + resultString;
                return resultString;
            }
        }
        throw new NotFoundException_1.default();
    };
    EAN13Reader.FIRST_DIGIT_ENCODINGS = [0x00, 0x0B, 0x0D, 0xE, 0x13, 0x19, 0x1C, 0x15, 0x16, 0x1A];
    return EAN13Reader;
}(UPCEANReader_1.default));
exports.default = EAN13Reader;
//# sourceMappingURL=EAN13Reader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/EAN8Reader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/EAN8Reader.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var UPCEANReader_1 = __webpack_require__(/*! ./UPCEANReader */ "./node_modules/@zxing/library/esm5/core/oned/UPCEANReader.js");
/**
 * <p>Implements decoding of the EAN-8 format.</p>
 *
 * @author Sean Owen
 */
var EAN8Reader = /** @class */ (function (_super) {
    __extends(EAN8Reader, _super);
    function EAN8Reader() {
        var _this = _super.call(this) || this;
        _this.decodeMiddleCounters = [0, 0, 0, 0];
        return _this;
    }
    EAN8Reader.prototype.decodeMiddle = function (row, startRange, resultString) {
        var e_1, _a, e_2, _b;
        var counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var end = row.getSize();
        var rowOffset = startRange[1];
        for (var x = 0; x < 4 && rowOffset < end; x++) {
            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_PATTERNS);
            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));
            try {
                for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
                    var counter = counters_1_1.value;
                    rowOffset += counter;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        var middleRange = UPCEANReader_1.default.findGuardPattern(row, rowOffset, true, UPCEANReader_1.default.MIDDLE_PATTERN, new Array(UPCEANReader_1.default.MIDDLE_PATTERN.length).fill(0));
        rowOffset = middleRange[1];
        for (var x = 0; x < 4 && rowOffset < end; x++) {
            var bestMatch = UPCEANReader_1.default.decodeDigit(row, counters, rowOffset, UPCEANReader_1.default.L_PATTERNS);
            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch));
            try {
                for (var counters_2 = __values(counters), counters_2_1 = counters_2.next(); !counters_2_1.done; counters_2_1 = counters_2.next()) {
                    var counter = counters_2_1.value;
                    rowOffset += counter;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (counters_2_1 && !counters_2_1.done && (_b = counters_2.return)) _b.call(counters_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        return { rowOffset: rowOffset, resultString: resultString };
    };
    EAN8Reader.prototype.getBarcodeFormat = function () {
        return BarcodeFormat_1.default.EAN_8;
    };
    return EAN8Reader;
}(UPCEANReader_1.default));
exports.default = EAN8Reader;
//# sourceMappingURL=EAN8Reader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/ITFReader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/ITFReader.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.oned {*/
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var Result_1 = __webpack_require__(/*! ../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
var ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var OneDReader_1 = __webpack_require__(/*! ./OneDReader */ "./node_modules/@zxing/library/esm5/core/oned/OneDReader.js");
var StringBuilder_1 = __webpack_require__(/*! ../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var System_1 = __webpack_require__(/*! ../util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var FormatException_1 = __webpack_require__(/*! ../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/**
 * <p>Decodes ITF barcodes.</p>
 *
 * @author Tjieco
 */
var ITFReader = /** @class */ (function (_super) {
    __extends(ITFReader, _super);
    function ITFReader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // Stores the actual narrow line width of the image being decoded.
        _this.narrowLineWidth = -1;
        return _this;
    }
    // See ITFWriter.PATTERNS
    /*

    /!**
     * Patterns of Wide / Narrow lines to indicate each digit
     *!/
    */
    ITFReader.prototype.decodeRow = function (rowNumber, row, hints) {
        var e_1, _a;
        // Find out where the Middle section (payload) starts & ends
        var startRange = this.decodeStart(row);
        var endRange = this.decodeEnd(row);
        var result = new StringBuilder_1.default();
        ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);
        var resultString = result.toString();
        var allowedLengths = null;
        if (hints != null) {
            allowedLengths = hints.get(DecodeHintType_1.default.ALLOWED_LENGTHS);
        }
        if (allowedLengths == null) {
            allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;
        }
        // To avoid false positives with 2D barcodes (and other patterns), make
        // an assumption that the decoded string must be a 'standard' length if it's short
        var length = resultString.length;
        var lengthOK = false;
        var maxAllowedLength = 0;
        try {
            for (var allowedLengths_1 = __values(allowedLengths), allowedLengths_1_1 = allowedLengths_1.next(); !allowedLengths_1_1.done; allowedLengths_1_1 = allowedLengths_1.next()) {
                var value = allowedLengths_1_1.value;
                if (length === value) {
                    lengthOK = true;
                    break;
                }
                if (value > maxAllowedLength) {
                    maxAllowedLength = value;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (allowedLengths_1_1 && !allowedLengths_1_1.done && (_a = allowedLengths_1.return)) _a.call(allowedLengths_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (!lengthOK && length > maxAllowedLength) {
            lengthOK = true;
        }
        if (!lengthOK) {
            throw new FormatException_1.default();
        }
        var points = [new ResultPoint_1.default(startRange[1], rowNumber), new ResultPoint_1.default(endRange[0], rowNumber)];
        var resultReturn = new Result_1.default(resultString, null, // no natural byte representation for these barcodes
        0, points, BarcodeFormat_1.default.ITF, new Date().getTime());
        return resultReturn;
    };
    /*
    /!**
     * @param row          row of black/white values to search
     * @param payloadStart offset of start pattern
     * @param resultString {@link StringBuilder} to append decoded chars to
     * @throws NotFoundException if decoding could not complete successfully
     *!/*/
    ITFReader.decodeMiddle = function (row, payloadStart, payloadEnd, resultString) {
        // Digits are interleaved in pairs - 5 black lines for one digit, and the
        // 5
        // interleaved white lines for the second digit.
        // Therefore, need to scan 10 lines and then
        // split these into two arrays
        var counterDigitPair = new Array(10); // 10
        var counterBlack = new Array(5); // 5
        var counterWhite = new Array(5); // 5
        counterDigitPair.fill(0);
        counterBlack.fill(0);
        counterWhite.fill(0);
        while (payloadStart < payloadEnd) {
            // Get 10 runs of black/white.
            OneDReader_1.default.recordPattern(row, payloadStart, counterDigitPair);
            // Split them into each array
            for (var k = 0; k < 5; k++) {
                var twoK = 2 * k;
                counterBlack[k] = counterDigitPair[twoK];
                counterWhite[k] = counterDigitPair[twoK + 1];
            }
            var bestMatch = ITFReader.decodeDigit(counterBlack);
            resultString.append(bestMatch.toString());
            bestMatch = this.decodeDigit(counterWhite);
            resultString.append(bestMatch.toString());
            counterDigitPair.forEach(function (counterDigit) {
                payloadStart += counterDigit;
            });
        }
    };
    /*/!**
     * Identify where the start of the middle / payload section starts.
     *
     * @param row row of black/white values to search
     * @return Array, containing index of start of 'start block' and end of
     *         'start block'
     *!/*/
    ITFReader.prototype.decodeStart = function (row) {
        var endStart = ITFReader.skipWhiteSpace(row);
        var startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);
        // Determine the width of a narrow line in pixels. We can do this by
        // getting the width of the start pattern and dividing by 4 because its
        // made up of 4 narrow lines.
        this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;
        this.validateQuietZone(row, startPattern[0]);
        return startPattern;
    };
    /*/!**
     * The start & end patterns must be pre/post fixed by a quiet zone. This
     * zone must be at least 10 times the width of a narrow line.  Scan back until
     * we either get to the start of the barcode or match the necessary number of
     * quiet zone pixels.
     *
     * Note: Its assumed the row is reversed when using this method to find
     * quiet zone after the end pattern.
     *
     * ref: http://www.barcode-1.net/i25code.html
     *
     * @param row bit array representing the scanned barcode.
     * @param startPattern index into row of the start or end pattern.
     * @throws NotFoundException if the quiet zone cannot be found
     *!/*/
    ITFReader.prototype.validateQuietZone = function (row, startPattern) {
        var quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone
        // if there are not so many pixel at all let's try as many as possible
        quietCount = quietCount < startPattern ? quietCount : startPattern;
        for (var i = startPattern - 1; quietCount > 0 && i >= 0; i--) {
            if (row.get(i)) {
                break;
            }
            quietCount--;
        }
        if (quietCount !== 0) {
            // Unable to find the necessary number of quiet zone pixels.
            throw new NotFoundException_1.default();
        }
    };
    /*
    /!**
     * Skip all whitespace until we get to the first black line.
     *
     * @param row row of black/white values to search
     * @return index of the first black line.
     * @throws NotFoundException Throws exception if no black lines are found in the row
     *!/*/
    ITFReader.skipWhiteSpace = function (row) {
        var width = row.getSize();
        var endStart = row.getNextSet(0);
        if (endStart === width) {
            throw new NotFoundException_1.default();
        }
        return endStart;
    };
    /*/!**
     * Identify where the end of the middle / payload section ends.
     *
     * @param row row of black/white values to search
     * @return Array, containing index of start of 'end block' and end of 'end
     *         block'
     *!/*/
    ITFReader.prototype.decodeEnd = function (row) {
        // For convenience, reverse the row and then
        // search from 'the start' for the end block
        row.reverse();
        try {
            var endStart = ITFReader.skipWhiteSpace(row);
            var endPattern = void 0;
            try {
                endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);
            }
            catch (NotFoundException) {
                endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);
            }
            // The start & end patterns must be pre/post fixed by a quiet zone. This
            // zone must be at least 10 times the width of a narrow line.
            // ref: http://www.barcode-1.net/i25code.html
            this.validateQuietZone(row, endPattern[0]);
            // Now recalculate the indices of where the 'endblock' starts & stops to
            // accommodate
            // the reversed nature of the search
            var temp = endPattern[0];
            endPattern[0] = row.getSize() - endPattern[1];
            endPattern[1] = row.getSize() - temp;
            return endPattern;
        }
        finally {
            // Put the row back the right way.
            row.reverse();
        }
    };
    /*
    /!**
     * @param row       row of black/white values to search
     * @param rowOffset position to start search
     * @param pattern   pattern of counts of number of black and white pixels that are
     *                  being searched for as a pattern
     * @return start/end horizontal offset of guard pattern, as an array of two
     *         ints
     * @throws NotFoundException if pattern is not found
     *!/*/
    ITFReader.findGuardPattern = function (row, rowOffset, pattern) {
        var patternLength = pattern.length;
        var counters = new Array(patternLength);
        var width = row.getSize();
        var isWhite = false;
        var counterPosition = 0;
        var patternStart = rowOffset;
        counters.fill(0);
        for (var x = rowOffset; x < width; x++) {
            if (row.get(x) !== isWhite) {
                counters[counterPosition]++;
            }
            else {
                if (counterPosition === patternLength - 1) {
                    if (OneDReader_1.default.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {
                        return [patternStart, x];
                    }
                    patternStart += counters[0] + counters[1];
                    System_1.default.arraycopy(counters, 2, counters, 0, counterPosition - 1);
                    counters[counterPosition - 1] = 0;
                    counters[counterPosition] = 0;
                    counterPosition--;
                }
                else {
                    counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
            }
        }
        throw new NotFoundException_1.default();
    };
    /*/!**
     * Attempts to decode a sequence of ITF black/white lines into single
     * digit.
     *
     * @param counters the counts of runs of observed black/white/black/... values
     * @return The decoded digit
     * @throws NotFoundException if digit cannot be decoded
     *!/*/
    ITFReader.decodeDigit = function (counters) {
        var bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept
        var bestMatch = -1;
        var max = ITFReader.PATTERNS.length;
        for (var i = 0; i < max; i++) {
            var pattern = ITFReader.PATTERNS[i];
            var variance = OneDReader_1.default.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);
            if (variance < bestVariance) {
                bestVariance = variance;
                bestMatch = i;
            }
            else if (variance === bestVariance) {
                // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match
                bestMatch = -1;
            }
        }
        if (bestMatch >= 0) {
            return bestMatch % 10;
        }
        else {
            throw new NotFoundException_1.default();
        }
    };
    ITFReader.W = 3; // Pixel width of a 3x wide line
    ITFReader.w = 2; // Pixel width of a 2x wide line
    ITFReader.N = 1; // Pixed width of a narrow line
    ITFReader.PATTERNS = [
        [1, 1, 2, 2, 1],
        [2, 1, 1, 1, 2],
        [1, 2, 1, 1, 2],
        [2, 2, 1, 1, 1],
        [1, 1, 2, 1, 2],
        [2, 1, 2, 1, 1],
        [1, 2, 2, 1, 1],
        [1, 1, 1, 2, 2],
        [2, 1, 1, 2, 1],
        [1, 2, 1, 2, 1],
        [1, 1, 3, 3, 1],
        [3, 1, 1, 1, 3],
        [1, 3, 1, 1, 3],
        [3, 3, 1, 1, 1],
        [1, 1, 3, 1, 3],
        [3, 1, 3, 1, 1],
        [1, 3, 3, 1, 1],
        [1, 1, 1, 3, 3],
        [3, 1, 1, 3, 1],
        [1, 3, 1, 3, 1] // 9
    ];
    ITFReader.MAX_AVG_VARIANCE = 0.38;
    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;
    /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/
    ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];
    /*/!**
     * Start/end guard pattern.
     *
     * Note: The end pattern is reversed because the row is reversed before
     * searching for the END_PATTERN
     *!/*/
    ITFReader.START_PATTERN = [1, 1, 1, 1];
    ITFReader.END_PATTERN_REVERSED = [
        [1, 1, 2],
        [1, 1, 3] // 3x
    ];
    return ITFReader;
}(OneDReader_1.default));
exports.default = ITFReader;
//# sourceMappingURL=ITFReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/MultiFormatOneDReader.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/MultiFormatOneDReader.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.oned {*/
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var Code39Reader_1 = __webpack_require__(/*! ./Code39Reader */ "./node_modules/@zxing/library/esm5/core/oned/Code39Reader.js");
var Code128Reader_1 = __webpack_require__(/*! ./Code128Reader */ "./node_modules/@zxing/library/esm5/core/oned/Code128Reader.js");
var RSS14Reader_1 = __webpack_require__(/*! ./rss/RSS14Reader */ "./node_modules/@zxing/library/esm5/core/oned/rss/RSS14Reader.js");
var DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var ITFReader_1 = __webpack_require__(/*! ./ITFReader */ "./node_modules/@zxing/library/esm5/core/oned/ITFReader.js");
var MultiFormatUPCEANReader_1 = __webpack_require__(/*! ./MultiFormatUPCEANReader */ "./node_modules/@zxing/library/esm5/core/oned/MultiFormatUPCEANReader.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var OneDReader_1 = __webpack_require__(/*! ./OneDReader */ "./node_modules/@zxing/library/esm5/core/oned/OneDReader.js");
/**
 * @author Daniel Switkin <dswitkin@google.com>
 * @author Sean Owen
 */
var MultiFormatOneDReader = /** @class */ (function (_super) {
    __extends(MultiFormatOneDReader, _super);
    function MultiFormatOneDReader(hints) {
        var _this = _super.call(this) || this;
        _this.readers = [];
        var possibleFormats = !hints ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);
        var useCode39CheckDigit = hints && hints.get(DecodeHintType_1.default.ASSUME_CODE_39_CHECK_DIGIT) !== undefined;
        if (possibleFormats) {
            if (possibleFormats.includes(BarcodeFormat_1.default.EAN_13) ||
                possibleFormats.includes(BarcodeFormat_1.default.EAN_8)) {
                _this.readers.push(new MultiFormatUPCEANReader_1.default(hints));
            }
            // if (possibleFormats.includes(BarcodeFormat.EAN_13) ||
            //     possibleFormats.includes(BarcodeFormat.UPC_A) ||
            //     possibleFormats.includes(BarcodeFormat.EAN_8) ||
            //     possibleFormats.includes(BarcodeFormat.UPC_E)) {
            //   readers.push(new MultiFormatUPCEANReader(hints));
            // }
            if (possibleFormats.includes(BarcodeFormat_1.default.CODE_39)) {
                _this.readers.push(new Code39Reader_1.default(useCode39CheckDigit));
            }
            // if (possibleFormats.includes(BarcodeFormat.CODE_93)) {
            //    this.readers.push(new Code93Reader());
            // }
            if (possibleFormats.includes(BarcodeFormat_1.default.CODE_128)) {
                _this.readers.push(new Code128Reader_1.default());
            }
            if (possibleFormats.includes(BarcodeFormat_1.default.ITF)) {
                _this.readers.push(new ITFReader_1.default());
            }
            // if (possibleFormats.includes(BarcodeFormat.CODABAR)) {
            //    this.readers.push(new CodaBarReader());
            // }
            if (possibleFormats.includes(BarcodeFormat_1.default.RSS_14)) {
                _this.readers.push(new RSS14Reader_1.default());
            }
            // if (possibleFormats.includes(BarcodeFormat.RSS_EXPANDED)) {
            //   this.readers.push(new RSSExpandedReader());
            // }
        }
        if (_this.readers.length === 0) {
            // this.readers.push(new MultiFormatUPCEANReader(hints));
            _this.readers.push(new Code39Reader_1.default());
            // this.readers.push(new CodaBarReader());
            // this.readers.push(new Code93Reader());
            _this.readers.push(new MultiFormatUPCEANReader_1.default(hints));
            _this.readers.push(new Code128Reader_1.default());
            _this.readers.push(new ITFReader_1.default());
            _this.readers.push(new RSS14Reader_1.default());
            // this.readers.push(new RSSExpandedReader());
        }
        return _this;
    }
    // @Override
    MultiFormatOneDReader.prototype.decodeRow = function (rowNumber, row, hints) {
        for (var i = 0; i < this.readers.length; i++) {
            try {
                return this.readers[i].decodeRow(rowNumber, row, hints);
            }
            catch (re) {
                // continue
            }
        }
        throw new NotFoundException_1.default();
    };
    // @Override
    MultiFormatOneDReader.prototype.reset = function () {
        this.readers.forEach(function (reader) { return reader.reset(); });
    };
    return MultiFormatOneDReader;
}(OneDReader_1.default));
exports.default = MultiFormatOneDReader;
//# sourceMappingURL=MultiFormatOneDReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/MultiFormatUPCEANReader.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/MultiFormatUPCEANReader.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var OneDReader_1 = __webpack_require__(/*! ./OneDReader */ "./node_modules/@zxing/library/esm5/core/oned/OneDReader.js");
var EAN13Reader_1 = __webpack_require__(/*! ./EAN13Reader */ "./node_modules/@zxing/library/esm5/core/oned/EAN13Reader.js");
var EAN8Reader_1 = __webpack_require__(/*! ./EAN8Reader */ "./node_modules/@zxing/library/esm5/core/oned/EAN8Reader.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/**
 * <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to
 * read all such formats, it is most efficient to use this implementation rather than invoke
 * individual readers.</p>
 *
 * @author Sean Owen
 */
var MultiFormatUPCEANReader = /** @class */ (function (_super) {
    __extends(MultiFormatUPCEANReader, _super);
    function MultiFormatUPCEANReader(hints) {
        var _this = _super.call(this) || this;
        var possibleFormats = hints == null ? null : hints.get(DecodeHintType_1.default.POSSIBLE_FORMATS);
        var readers = [];
        if (possibleFormats != null) {
            if (possibleFormats.indexOf(BarcodeFormat_1.default.EAN_13) > -1) {
                readers.push(new EAN13Reader_1.default());
            }
            if (possibleFormats.indexOf(BarcodeFormat_1.default.EAN_8) > -1) {
                readers.push(new EAN8Reader_1.default());
            }
            // todo add UPC_A, UPC_E
        }
        if (readers.length === 0) {
            readers.push(new EAN13Reader_1.default());
            readers.push(new EAN8Reader_1.default());
            // todo add UPC_A, UPC_E
        }
        _this.readers = readers;
        return _this;
    }
    MultiFormatUPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {
        var e_1, _a;
        try {
            for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var reader = _c.value;
                try {
                    return reader.decodeRow(rowNumber, row, hints);
                    // TODO ean13MayBeUPCA
                }
                catch (err) {
                    // continue;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        throw new NotFoundException_1.default();
    };
    MultiFormatUPCEANReader.prototype.reset = function () {
        var e_2, _a;
        try {
            for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var reader = _c.value;
                reader.reset();
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    return MultiFormatUPCEANReader;
}(OneDReader_1.default));
exports.default = MultiFormatUPCEANReader;
//# sourceMappingURL=MultiFormatUPCEANReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/OneDReader.js":
/*!******************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/OneDReader.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var BitArray_1 = __webpack_require__(/*! ../common/BitArray */ "./node_modules/@zxing/library/esm5/core/common/BitArray.js");
var DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ "./node_modules/@zxing/library/esm5/core/ResultMetadataType.js");
var ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/**
 * Encapsulates functionality and implementation that is common to all families
 * of one-dimensional barcodes.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 * @author Sean Owen
 */
var OneDReader = /** @class */ (function () {
    function OneDReader() {
    }
    /*
    @Override
    public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {
      return decode(image, null);
    }
    */
    // Note that we don't try rotation without the try harder flag, even if rotation was supported.
    // @Override
    OneDReader.prototype.decode = function (image, hints) {
        try {
            return this.doDecode(image, hints);
        }
        catch (nfe) {
            var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);
            if (tryHarder && image.isRotateSupported()) {
                var rotatedImage = image.rotateCounterClockwise();
                var result = this.doDecode(rotatedImage, hints);
                // Record that we found it rotated 90 degrees CCW / 270 degrees CW
                var metadata = result.getResultMetadata();
                var orientation_1 = 270;
                if (metadata !== null && (metadata.get(ResultMetadataType_1.default.ORIENTATION) === true)) {
                    // But if we found it reversed in doDecode(), add in that result here:
                    orientation_1 = (orientation_1 + metadata.get(ResultMetadataType_1.default.ORIENTATION) % 360);
                }
                result.putMetadata(ResultMetadataType_1.default.ORIENTATION, orientation_1);
                // Update result points
                var points = result.getResultPoints();
                if (points !== null) {
                    var height = rotatedImage.getHeight();
                    for (var i = 0; i < points.length; i++) {
                        points[i] = new ResultPoint_1.default(height - points[i].getY() - 1, points[i].getX());
                    }
                }
                return result;
            }
            else {
                throw new NotFoundException_1.default();
            }
        }
    };
    // @Override
    OneDReader.prototype.reset = function () {
        // do nothing
    };
    /**
     * We're going to examine rows from the middle outward, searching alternately above and below the
     * middle, and farther out each time. rowStep is the number of rows between each successive
     * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then
     * middle + rowStep, then middle - (2 * rowStep), etc.
     * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily
     * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the
     * image if "trying harder".
     *
     * @param image The image to decode
     * @param hints Any hints that were requested
     * @return The contents of the decoded barcode
     * @throws NotFoundException Any spontaneous errors which occur
     */
    OneDReader.prototype.doDecode = function (image, hints) {
        var width = image.getWidth();
        var height = image.getHeight();
        var row = new BitArray_1.default(width);
        var tryHarder = hints && (hints.get(DecodeHintType_1.default.TRY_HARDER) === true);
        var rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));
        var maxLines;
        if (tryHarder) {
            maxLines = height; // Look at the whole image, not just the center
        }
        else {
            maxLines = 15; // 15 rows spaced 1/32 apart is roughly the middle half of the image
        }
        var middle = Math.trunc(height / 2);
        for (var x = 0; x < maxLines; x++) {
            // Scanning from the middle out. Determine which row we're looking at next:
            var rowStepsAboveOrBelow = Math.trunc((x + 1) / 2);
            var isAbove = (x & 0x01) === 0; // i.e. is x even?
            var rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);
            if (rowNumber < 0 || rowNumber >= height) {
                // Oops, if we run off the top or bottom, stop
                break;
            }
            // Estimate black point for this row and load it:
            try {
                row = image.getBlackRow(rowNumber, row);
            }
            catch (ignored) {
                continue;
            }
            var _loop_1 = function (attempt) {
                if (attempt === 1) { // trying again?
                    row.reverse(); // reverse the row and continue
                    // This means we will only ever draw result points *once* in the life of this method
                    // since we want to avoid drawing the wrong points after flipping the row, and,
                    // don't want to clutter with noise from every single row scan -- just the scans
                    // that start on the center line.
                    if (hints && (hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK) === true)) {
                        var newHints_1 = new Map();
                        hints.forEach(function (hint, key) { return newHints_1.set(key, hint); });
                        newHints_1.delete(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);
                        hints = newHints_1;
                    }
                }
                try {
                    // Look for a barcode
                    var result = this_1.decodeRow(rowNumber, row, hints);
                    // We found our barcode
                    if (attempt === 1) {
                        // But it was upside down, so note that
                        result.putMetadata(ResultMetadataType_1.default.ORIENTATION, 180);
                        // And remember to flip the result points horizontally.
                        var points = result.getResultPoints();
                        if (points !== null) {
                            points[0] = new ResultPoint_1.default(width - points[0].getX() - 1, points[0].getY());
                            points[1] = new ResultPoint_1.default(width - points[1].getX() - 1, points[1].getY());
                        }
                    }
                    return { value: result };
                }
                catch (re) {
                    // continue -- just couldn't decode this row
                }
            };
            var this_1 = this;
            // While we have the image data in a BitArray, it's fairly cheap to reverse it in place to
            // handle decoding upside down barcodes.
            for (var attempt = 0; attempt < 2; attempt++) {
                var state_1 = _loop_1(attempt);
                if (typeof state_1 === "object")
                    return state_1.value;
            }
        }
        throw new NotFoundException_1.default();
    };
    /**
     * Records the size of successive runs of white and black pixels in a row, starting at a given point.
     * The values are recorded in the given array, and the number of runs recorded is equal to the size
     * of the array. If the row starts on a white pixel at the given start point, then the first count
     * recorded is the run of white pixels starting from that point; likewise it is the count of a run
     * of black pixels if the row begin on a black pixels at that point.
     *
     * @param row row to count from
     * @param start offset into row to start at
     * @param counters array into which to record counts
     * @throws NotFoundException if counters cannot be filled entirely from row before running out
     *  of pixels
     */
    OneDReader.recordPattern = function (row, start, counters) {
        var numCounters = counters.length;
        for (var index = 0; index < numCounters; index++)
            counters[index] = 0;
        var end = row.getSize();
        if (start >= end) {
            throw new NotFoundException_1.default();
        }
        var isWhite = !row.get(start);
        var counterPosition = 0;
        var i = start;
        while (i < end) {
            if (row.get(i) !== isWhite) {
                counters[counterPosition]++;
            }
            else {
                if (++counterPosition === numCounters) {
                    break;
                }
                else {
                    counters[counterPosition] = 1;
                    isWhite = !isWhite;
                }
            }
            i++;
        }
        // If we read fully the last section of pixels and filled up our counters -- or filled
        // the last counter but ran off the side of the image, OK. Otherwise, a problem.
        if (!(counterPosition === numCounters || (counterPosition === numCounters - 1 && i === end))) {
            throw new NotFoundException_1.default();
        }
    };
    OneDReader.recordPatternInReverse = function (row, start, counters) {
        // This could be more efficient I guess
        var numTransitionsLeft = counters.length;
        var last = row.get(start);
        while (start > 0 && numTransitionsLeft >= 0) {
            if (row.get(--start) !== last) {
                numTransitionsLeft--;
                last = !last;
            }
        }
        if (numTransitionsLeft >= 0) {
            throw new NotFoundException_1.default();
        }
        OneDReader.recordPattern(row, start + 1, counters);
    };
    /**
     * Determines how closely a set of observed counts of runs of black/white values matches a given
     * target pattern. This is reported as the ratio of the total variance from the expected pattern
     * proportions across all pattern elements, to the length of the pattern.
     *
     * @param counters observed counters
     * @param pattern expected pattern
     * @param maxIndividualVariance The most any counter can differ before we give up
     * @return ratio of total variance between counters and pattern compared to total pattern size
     */
    OneDReader.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {
        var numCounters = counters.length;
        var total = 0;
        var patternLength = 0;
        for (var i = 0; i < numCounters; i++) {
            total += counters[i];
            patternLength += pattern[i];
        }
        if (total < patternLength) {
            // If we don't even have one pixel per unit of bar width, assume this is too small
            // to reliably match, so fail:
            return Number.POSITIVE_INFINITY;
        }
        var unitBarWidth = total / patternLength;
        maxIndividualVariance *= unitBarWidth;
        var totalVariance = 0.0;
        for (var x = 0; x < numCounters; x++) {
            var counter = counters[x];
            var scaledPattern = pattern[x] * unitBarWidth;
            var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
            if (variance > maxIndividualVariance) {
                return Number.POSITIVE_INFINITY;
            }
            totalVariance += variance;
        }
        return totalVariance / total;
    };
    return OneDReader;
}());
exports.default = OneDReader;
//# sourceMappingURL=OneDReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/UPCEANExtension2Support.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/UPCEANExtension2Support.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2012 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var AbstractUPCEANReader_1 = __webpack_require__(/*! ./AbstractUPCEANReader */ "./node_modules/@zxing/library/esm5/core/oned/AbstractUPCEANReader.js");
var Result_1 = __webpack_require__(/*! ../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
var ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ "./node_modules/@zxing/library/esm5/core/ResultMetadataType.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/**
 * @see UPCEANExtension5Support
 */
var UPCEANExtension2Support = /** @class */ (function () {
    function UPCEANExtension2Support() {
        this.decodeMiddleCounters = [0, 0, 0, 0];
        this.decodeRowStringBuffer = '';
    }
    UPCEANExtension2Support.prototype.decodeRow = function (rowNumber, row, extensionStartRange) {
        var result = this.decodeRowStringBuffer;
        var end = this.decodeMiddle(row, extensionStartRange, result);
        var resultString = result.toString();
        var extensionData = UPCEANExtension2Support.parseExtensionString(resultString);
        var resultPoints = [
            new ResultPoint_1.default((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),
            new ResultPoint_1.default(end, rowNumber)
        ];
        var extensionResult = new Result_1.default(resultString, null, 0, resultPoints, BarcodeFormat_1.default.UPC_EAN_EXTENSION, new Date().getTime());
        if (extensionData != null) {
            extensionResult.putAllMetadata(extensionData);
        }
        return extensionResult;
    };
    UPCEANExtension2Support.prototype.decodeMiddle = function (row, startRange, resultString) {
        var e_1, _a;
        var counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var end = row.getSize();
        var rowOffset = startRange[1];
        var checkParity = 0;
        for (var x = 0; x < 2 && rowOffset < end; x++) {
            var bestMatch = AbstractUPCEANReader_1.default.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader_1.default.L_AND_G_PATTERNS);
            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));
            try {
                for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
                    var counter = counters_1_1.value;
                    rowOffset += counter;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (bestMatch >= 10) {
                checkParity |= 1 << (1 - x);
            }
            if (x !== 1) {
                // Read off separator if not last
                rowOffset = row.getNextSet(rowOffset);
                rowOffset = row.getNextUnset(rowOffset);
            }
        }
        if (resultString.length !== 2) {
            throw new NotFoundException_1.default();
        }
        if (parseInt(resultString.toString()) % 4 !== checkParity) {
            throw new NotFoundException_1.default();
        }
        return rowOffset;
    };
    UPCEANExtension2Support.parseExtensionString = function (raw) {
        if (raw.length !== 2) {
            return null;
        }
        return new Map([[ResultMetadataType_1.default.ISSUE_NUMBER, parseInt(raw)]]);
    };
    return UPCEANExtension2Support;
}());
exports.default = UPCEANExtension2Support;
//# sourceMappingURL=UPCEANExtension2Support.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/UPCEANExtension5Support.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/UPCEANExtension5Support.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2010 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
// import UPCEANReader from './UPCEANReader';
var AbstractUPCEANReader_1 = __webpack_require__(/*! ./AbstractUPCEANReader */ "./node_modules/@zxing/library/esm5/core/oned/AbstractUPCEANReader.js");
var Result_1 = __webpack_require__(/*! ../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
var ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ "./node_modules/@zxing/library/esm5/core/ResultMetadataType.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/**
 * @see UPCEANExtension2Support
 */
var UPCEANExtension5Support = /** @class */ (function () {
    function UPCEANExtension5Support() {
        this.CHECK_DIGIT_ENCODINGS = [0x18, 0x14, 0x12, 0x11, 0x0C, 0x06, 0x03, 0x0A, 0x09, 0x05];
        this.decodeMiddleCounters = [0, 0, 0, 0];
        this.decodeRowStringBuffer = '';
    }
    UPCEANExtension5Support.prototype.decodeRow = function (rowNumber, row, extensionStartRange) {
        var result = this.decodeRowStringBuffer;
        var end = this.decodeMiddle(row, extensionStartRange, result);
        var resultString = result.toString();
        var extensionData = UPCEANExtension5Support.parseExtensionString(resultString);
        var resultPoints = [
            new ResultPoint_1.default((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber),
            new ResultPoint_1.default(end, rowNumber)
        ];
        var extensionResult = new Result_1.default(resultString, null, 0, resultPoints, BarcodeFormat_1.default.UPC_EAN_EXTENSION, new Date().getTime());
        if (extensionData != null) {
            extensionResult.putAllMetadata(extensionData);
        }
        return extensionResult;
    };
    UPCEANExtension5Support.prototype.decodeMiddle = function (row, startRange, resultString) {
        var e_1, _a;
        var counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var end = row.getSize();
        var rowOffset = startRange[1];
        var lgPatternFound = 0;
        for (var x = 0; x < 5 && rowOffset < end; x++) {
            var bestMatch = AbstractUPCEANReader_1.default.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader_1.default.L_AND_G_PATTERNS);
            resultString += String.fromCharCode(('0'.charCodeAt(0) + bestMatch % 10));
            try {
                for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
                    var counter = counters_1_1.value;
                    rowOffset += counter;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (bestMatch >= 10) {
                lgPatternFound |= 1 << (4 - x);
            }
            if (x !== 4) {
                // Read off separator if not last
                rowOffset = row.getNextSet(rowOffset);
                rowOffset = row.getNextUnset(rowOffset);
            }
        }
        if (resultString.length !== 5) {
            throw new NotFoundException_1.default();
        }
        var checkDigit = this.determineCheckDigit(lgPatternFound);
        if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {
            throw new NotFoundException_1.default();
        }
        return rowOffset;
    };
    UPCEANExtension5Support.extensionChecksum = function (s) {
        var length = s.length;
        var sum = 0;
        for (var i = length - 2; i >= 0; i -= 2) {
            sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
        }
        sum *= 3;
        for (var i = length - 1; i >= 0; i -= 2) {
            sum += s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
        }
        sum *= 3;
        return sum % 10;
    };
    UPCEANExtension5Support.prototype.determineCheckDigit = function (lgPatternFound) {
        for (var d = 0; d < 10; d++) {
            if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d]) {
                return d;
            }
        }
        throw new NotFoundException_1.default();
    };
    UPCEANExtension5Support.parseExtensionString = function (raw) {
        if (raw.length !== 5) {
            return null;
        }
        var value = UPCEANExtension5Support.parseExtension5String(raw);
        if (value == null) {
            return null;
        }
        return new Map([[ResultMetadataType_1.default.SUGGESTED_PRICE, value]]);
    };
    UPCEANExtension5Support.parseExtension5String = function (raw) {
        var currency;
        switch (raw.charAt(0)) {
            case '0':
                currency = 'Â£';
                break;
            case '5':
                currency = '$';
                break;
            case '9':
                // Reference: http://www.jollytech.com
                switch (raw) {
                    case '90000':
                        // No suggested retail price
                        return null;
                    case '99991':
                        // Complementary
                        return '0.00';
                    case '99990':
                        return 'Used';
                }
                // Otherwise... unknown currency?
                currency = '';
                break;
            default:
                currency = '';
                break;
        }
        var rawAmount = parseInt(raw.substring(1));
        var unitsString = (rawAmount / 100).toString();
        var hundredths = rawAmount % 100;
        var hundredthsString = hundredths < 10 ? '0' + hundredths : hundredths.toString(); // fixme
        return currency + unitsString + '.' + hundredthsString;
    };
    return UPCEANExtension5Support;
}());
exports.default = UPCEANExtension5Support;
//# sourceMappingURL=UPCEANExtension5Support.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/UPCEANExtensionSupport.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/UPCEANExtensionSupport.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (C) 2010 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var AbstractUPCEANReader_1 = __webpack_require__(/*! ./AbstractUPCEANReader */ "./node_modules/@zxing/library/esm5/core/oned/AbstractUPCEANReader.js");
var UPCEANExtension5Support_1 = __webpack_require__(/*! ./UPCEANExtension5Support */ "./node_modules/@zxing/library/esm5/core/oned/UPCEANExtension5Support.js");
var UPCEANExtension2Support_1 = __webpack_require__(/*! ./UPCEANExtension2Support */ "./node_modules/@zxing/library/esm5/core/oned/UPCEANExtension2Support.js");
var UPCEANExtensionSupport = /** @class */ (function () {
    function UPCEANExtensionSupport() {
    }
    UPCEANExtensionSupport.decodeRow = function (rowNumber, row, rowOffset) {
        var extensionStartRange = AbstractUPCEANReader_1.default.findGuardPattern(row, rowOffset, false, this.EXTENSION_START_PATTERN, new Array(this.EXTENSION_START_PATTERN.length).fill(0));
        try {
            // return null;
            var fiveSupport = new UPCEANExtension5Support_1.default();
            return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);
        }
        catch (err) {
            // return null;
            var twoSupport = new UPCEANExtension2Support_1.default();
            return twoSupport.decodeRow(rowNumber, row, extensionStartRange);
        }
    };
    UPCEANExtensionSupport.EXTENSION_START_PATTERN = [1, 1, 2];
    return UPCEANExtensionSupport;
}());
exports.default = UPCEANExtensionSupport;
//# sourceMappingURL=UPCEANExtensionSupport.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/UPCEANReader.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/UPCEANReader.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var Result_1 = __webpack_require__(/*! ../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
var ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ "./node_modules/@zxing/library/esm5/core/ResultMetadataType.js");
var ResultPoint_1 = __webpack_require__(/*! ../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var UPCEANExtensionSupport_1 = __webpack_require__(/*! ./UPCEANExtensionSupport */ "./node_modules/@zxing/library/esm5/core/oned/UPCEANExtensionSupport.js");
var AbstractUPCEANReader_1 = __webpack_require__(/*! ./AbstractUPCEANReader */ "./node_modules/@zxing/library/esm5/core/oned/AbstractUPCEANReader.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var FormatException_1 = __webpack_require__(/*! ../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
var ChecksumException_1 = __webpack_require__(/*! ../ChecksumException */ "./node_modules/@zxing/library/esm5/core/ChecksumException.js");
/**
 * <p>Encapsulates functionality and implementation that is common to UPC and EAN families
 * of one-dimensional barcodes.</p>
 *
 * @author dswitkin@google.com (Daniel Switkin)
 * @author Sean Owen
 * @author alasdair@google.com (Alasdair Mackintosh)
 */
var UPCEANReader = /** @class */ (function (_super) {
    __extends(UPCEANReader, _super);
    function UPCEANReader() {
        var _this = _super.call(this) || this;
        _this.decodeRowStringBuffer = '';
        UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map(function (arr) {
            return arr.slice();
        });
        for (var i = 10; i < 20; i++) {
            var widths = UPCEANReader.L_PATTERNS[i - 10];
            var reversedWidths = new Array(widths.length);
            for (var j = 0; j < widths.length; j++) {
                reversedWidths[j] = widths[widths.length - j - 1];
            }
            UPCEANReader.L_AND_G_PATTERNS[i] = reversedWidths;
        }
        return _this;
    }
    UPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {
        var startGuardRange = UPCEANReader.findStartGuardPattern(row);
        var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);
        if (resultPointCallback != null) {
            var resultPoint_1 = new ResultPoint_1.default((startGuardRange[0] + startGuardRange[1]) / 2.0, rowNumber);
            resultPointCallback.foundPossibleResultPoint(resultPoint_1);
        }
        var budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);
        var endStart = budello.rowOffset;
        var result = budello.resultString;
        if (resultPointCallback != null) {
            var resultPoint_2 = new ResultPoint_1.default(endStart, rowNumber);
            resultPointCallback.foundPossibleResultPoint(resultPoint_2);
        }
        var endRange = UPCEANReader.decodeEnd(row, endStart);
        if (resultPointCallback != null) {
            var resultPoint_3 = new ResultPoint_1.default((endRange[0] + endRange[1]) / 2.0, rowNumber);
            resultPointCallback.foundPossibleResultPoint(resultPoint_3);
        }
        // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The
        // spec might want more whitespace, but in practice this is the maximum we can count on.
        var end = endRange[1];
        var quietEnd = end + (end - endRange[0]);
        if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {
            throw new NotFoundException_1.default();
        }
        var resultString = result.toString();
        // UPC/EAN should never be less than 8 chars anyway
        if (resultString.length < 8) {
            throw new FormatException_1.default();
        }
        if (!UPCEANReader.checkChecksum(resultString)) {
            throw new ChecksumException_1.default();
        }
        var left = (startGuardRange[1] + startGuardRange[0]) / 2.0;
        var right = (endRange[1] + endRange[0]) / 2.0;
        var format = this.getBarcodeFormat();
        var resultPoint = [new ResultPoint_1.default(left, rowNumber), new ResultPoint_1.default(right, rowNumber)];
        var decodeResult = new Result_1.default(resultString, null, 0, resultPoint, format, new Date().getTime());
        var extensionLength = 0;
        try {
            var extensionResult = UPCEANExtensionSupport_1.default.decodeRow(rowNumber, row, endRange[1]);
            decodeResult.putMetadata(ResultMetadataType_1.default.UPC_EAN_EXTENSION, extensionResult.getText());
            decodeResult.putAllMetadata(extensionResult.getResultMetadata());
            decodeResult.addResultPoints(extensionResult.getResultPoints());
            extensionLength = extensionResult.getText().length;
        }
        catch (err) {
        }
        var allowedExtensions = hints == null ? null : hints.get(DecodeHintType_1.default.ALLOWED_EAN_EXTENSIONS);
        if (allowedExtensions != null) {
            var valid = false;
            for (var length_1 in allowedExtensions) {
                if (extensionLength.toString() === length_1) { // check me
                    valid = true;
                    break;
                }
            }
            if (!valid) {
                throw new NotFoundException_1.default();
            }
        }
        if (format === BarcodeFormat_1.default.EAN_13 || format === BarcodeFormat_1.default.UPC_A) {
            // let countryID = eanManSupport.lookupContryIdentifier(resultString); todo
            // if (countryID != null) {
            //     decodeResult.putMetadata(ResultMetadataType.POSSIBLE_COUNTRY, countryID);
            // }
        }
        return decodeResult;
    };
    UPCEANReader.checkChecksum = function (s) {
        return UPCEANReader.checkStandardUPCEANChecksum(s);
    };
    UPCEANReader.checkStandardUPCEANChecksum = function (s) {
        var length = s.length;
        if (length === 0)
            return false;
        var check = parseInt(s.charAt(length - 1), 10);
        return UPCEANReader.getStandardUPCEANChecksum(s.substring(0, length - 1)) === check;
    };
    UPCEANReader.getStandardUPCEANChecksum = function (s) {
        var length = s.length;
        var sum = 0;
        for (var i = length - 1; i >= 0; i -= 2) {
            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
            if (digit < 0 || digit > 9) {
                throw new FormatException_1.default();
            }
            sum += digit;
        }
        sum *= 3;
        for (var i = length - 2; i >= 0; i -= 2) {
            var digit = s.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
            if (digit < 0 || digit > 9) {
                throw new FormatException_1.default();
            }
            sum += digit;
        }
        return (1000 - sum) % 10;
    };
    UPCEANReader.decodeEnd = function (row, endStart) {
        return UPCEANReader.findGuardPattern(row, endStart, false, UPCEANReader.START_END_PATTERN, new Array(UPCEANReader.START_END_PATTERN.length).fill(0));
    };
    return UPCEANReader;
}(AbstractUPCEANReader_1.default));
exports.default = UPCEANReader;
//# sourceMappingURL=UPCEANReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/AbstractRSSReader.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/AbstractRSSReader.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var OneDReader_1 = __webpack_require__(/*! ../OneDReader */ "./node_modules/@zxing/library/esm5/core/oned/OneDReader.js");
var NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js");
var AbstractRSSReader = /** @class */ (function (_super) {
    __extends(AbstractRSSReader, _super);
    function AbstractRSSReader() {
        var _this = _super.call(this) || this;
        _this.decodeFinderCounters = new Array(4);
        _this.dataCharacterCounters = new Array(8);
        _this.oddRoundingErrors = new Array(4);
        _this.evenRoundingErrors = new Array(4);
        _this.oddCounts = new Array(_this.dataCharacterCounters.length / 2);
        _this.evenCounts = new Array(_this.dataCharacterCounters.length / 2);
        return _this;
    }
    AbstractRSSReader.prototype.getDecodeFinderCounters = function () {
        return this.decodeFinderCounters;
    };
    AbstractRSSReader.prototype.getDataCharacterCounters = function () {
        return this.dataCharacterCounters;
    };
    AbstractRSSReader.prototype.getOddRoundingErrors = function () {
        return this.oddRoundingErrors;
    };
    AbstractRSSReader.prototype.getEvenRoundingErrors = function () {
        return this.evenRoundingErrors;
    };
    AbstractRSSReader.prototype.getOddCounts = function () {
        return this.oddCounts;
    };
    AbstractRSSReader.prototype.getEvenCounts = function () {
        return this.evenCounts;
    };
    AbstractRSSReader.prototype.parseFinderValue = function (counters, finderPatterns) {
        for (var value = 0; value < finderPatterns.length; value++) {
            if (OneDReader_1.default.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {
                return value;
            }
        }
        throw new NotFoundException_1.default();
    };
    /**
     * @param array values to sum
     * @return sum of values
     * @deprecated call {@link MathUtils#sum(int[])}
     */
    AbstractRSSReader.count = function (array) {
        return MathUtils_1.default.sum(new Int32Array(array));
    };
    AbstractRSSReader.increment = function (array, errors) {
        var index = 0;
        var biggestError = errors[0];
        for (var i = 1; i < array.length; i++) {
            if (errors[i] > biggestError) {
                biggestError = errors[i];
                index = i;
            }
        }
        array[index]++;
    };
    AbstractRSSReader.decrement = function (array, errors) {
        var index = 0;
        var biggestError = errors[0];
        for (var i = 1; i < array.length; i++) {
            if (errors[i] < biggestError) {
                biggestError = errors[i];
                index = i;
            }
        }
        array[index]--;
    };
    AbstractRSSReader.isFinderPattern = function (counters) {
        var e_1, _a;
        var firstTwoSum = counters[0] + counters[1];
        var sum = firstTwoSum + counters[2] + counters[3];
        var ratio = firstTwoSum / sum;
        if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {
            // passes ratio test in spec, but see if the counts are unreasonable
            var minCounter = Number.MAX_SAFE_INTEGER;
            var maxCounter = Number.MIN_SAFE_INTEGER;
            try {
                for (var counters_1 = __values(counters), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {
                    var counter = counters_1_1.value;
                    if (counter > maxCounter) {
                        maxCounter = counter;
                    }
                    if (counter < minCounter) {
                        minCounter = counter;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return maxCounter < 10 * minCounter;
        }
        return false;
    };
    AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;
    AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;
    AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12.0;
    AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14.0;
    return AbstractRSSReader;
}(OneDReader_1.default));
exports.default = AbstractRSSReader;
//# sourceMappingURL=AbstractRSSReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/DataCharacter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/DataCharacter.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DataCharacter = /** @class */ (function () {
    function DataCharacter(value, checksumPortion) {
        this.value = value;
        this.checksumPortion = checksumPortion;
    }
    DataCharacter.prototype.getValue = function () {
        return this.value;
    };
    DataCharacter.prototype.getChecksumPortion = function () {
        return this.checksumPortion;
    };
    DataCharacter.prototype.toString = function () {
        return this.value + '(' + this.checksumPortion + ')';
    };
    DataCharacter.prototype.equals = function (o) {
        if (!(o instanceof DataCharacter)) {
            return false;
        }
        var that = o;
        return this.value === that.value && this.checksumPortion === that.checksumPortion;
    };
    DataCharacter.prototype.hashCode = function () {
        return this.value ^ this.checksumPortion;
    };
    return DataCharacter;
}());
exports.default = DataCharacter;
//# sourceMappingURL=DataCharacter.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/FinderPattern.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/FinderPattern.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var FinderPattern = /** @class */ (function () {
    function FinderPattern(value, startEnd, start, end, rowNumber) {
        this.value = value;
        this.startEnd = startEnd;
        this.value = value;
        this.startEnd = startEnd;
        this.resultPoints = new Array();
        this.resultPoints.push(new ResultPoint_1.default(start, rowNumber));
        this.resultPoints.push(new ResultPoint_1.default(end, rowNumber));
    }
    FinderPattern.prototype.getValue = function () {
        return this.value;
    };
    FinderPattern.prototype.getStartEnd = function () {
        return this.startEnd;
    };
    FinderPattern.prototype.getResultPoints = function () {
        return this.resultPoints;
    };
    FinderPattern.prototype.equals = function (o) {
        if (!(o instanceof FinderPattern)) {
            return false;
        }
        var that = o;
        return this.value === that.value;
    };
    FinderPattern.prototype.hashCode = function () {
        return this.value;
    };
    return FinderPattern;
}());
exports.default = FinderPattern;
//# sourceMappingURL=FinderPattern.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/Pair.js":
/*!****************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/Pair.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var DataCharacter_1 = __webpack_require__(/*! ./DataCharacter */ "./node_modules/@zxing/library/esm5/core/oned/rss/DataCharacter.js");
var Pair = /** @class */ (function (_super) {
    __extends(Pair, _super);
    function Pair(value, checksumPortion, finderPattern) {
        var _this = _super.call(this, value, checksumPortion) || this;
        _this.count = 0;
        _this.finderPattern = finderPattern;
        return _this;
    }
    Pair.prototype.getFinderPattern = function () {
        return this.finderPattern;
    };
    Pair.prototype.getCount = function () {
        return this.count;
    };
    Pair.prototype.incrementCount = function () {
        this.count++;
    };
    return Pair;
}(DataCharacter_1.default));
exports.default = Pair;
//# sourceMappingURL=Pair.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/RSS14Reader.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/RSS14Reader.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var AbstractRSSReader_1 = __webpack_require__(/*! ./AbstractRSSReader */ "./node_modules/@zxing/library/esm5/core/oned/rss/AbstractRSSReader.js");
var Pair_1 = __webpack_require__(/*! ./Pair */ "./node_modules/@zxing/library/esm5/core/oned/rss/Pair.js");
var Result_1 = __webpack_require__(/*! ../../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
var DecodeHintType_1 = __webpack_require__(/*! ../../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var BarcodeFormat_1 = __webpack_require__(/*! ../../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var FinderPattern_1 = __webpack_require__(/*! ./FinderPattern */ "./node_modules/@zxing/library/esm5/core/oned/rss/FinderPattern.js");
var DataCharacter_1 = __webpack_require__(/*! ./DataCharacter */ "./node_modules/@zxing/library/esm5/core/oned/rss/DataCharacter.js");
var MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js");
var RSSUtils_1 = __webpack_require__(/*! ./RSSUtils */ "./node_modules/@zxing/library/esm5/core/oned/rss/RSSUtils.js");
var System_1 = __webpack_require__(/*! ../../util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var OneDReader_1 = __webpack_require__(/*! ../OneDReader */ "./node_modules/@zxing/library/esm5/core/oned/OneDReader.js");
var RSS14Reader = /** @class */ (function (_super) {
    __extends(RSS14Reader, _super);
    function RSS14Reader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.possibleLeftPairs = [];
        _this.possibleRightPairs = [];
        return _this;
    }
    RSS14Reader.prototype.decodeRow = function (rowNumber, row, hints) {
        var e_1, _a, e_2, _b;
        var leftPair = this.decodePair(row, false, rowNumber, hints);
        RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);
        row.reverse();
        var rightPair = this.decodePair(row, true, rowNumber, hints);
        RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);
        row.reverse();
        try {
            for (var _c = __values(this.possibleLeftPairs), _d = _c.next(); !_d.done; _d = _c.next()) {
                var left = _d.value;
                if (left.getCount() > 1) {
                    try {
                        for (var _e = __values(this.possibleRightPairs), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var right = _f.value;
                            if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {
                                return RSS14Reader.constructResult(left, right);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        throw new NotFoundException_1.default();
    };
    RSS14Reader.addOrTally = function (possiblePairs, pair) {
        var e_3, _a;
        if (pair == null) {
            return;
        }
        var found = false;
        try {
            for (var possiblePairs_1 = __values(possiblePairs), possiblePairs_1_1 = possiblePairs_1.next(); !possiblePairs_1_1.done; possiblePairs_1_1 = possiblePairs_1.next()) {
                var other = possiblePairs_1_1.value;
                if (other.getValue() === pair.getValue()) {
                    other.incrementCount();
                    found = true;
                    break;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (possiblePairs_1_1 && !possiblePairs_1_1.done && (_a = possiblePairs_1.return)) _a.call(possiblePairs_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (!found) {
            possiblePairs.push(pair);
        }
    };
    RSS14Reader.prototype.reset = function () {
        this.possibleLeftPairs.length = 0;
        this.possibleRightPairs.length = 0;
    };
    RSS14Reader.constructResult = function (leftPair, rightPair) {
        var symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();
        var text = new String(symbolValue).toString();
        var buffer = new StringBuilder_1.default();
        for (var i = 13 - text.length; i > 0; i--) {
            buffer.append('0');
        }
        buffer.append(text);
        var checkDigit = 0;
        for (var i = 0; i < 13; i++) {
            var digit = buffer.charAt(i).charCodeAt(0) - '0'.charCodeAt(0);
            checkDigit += ((i & 0x01) === 0) ? 3 * digit : digit;
        }
        checkDigit = 10 - (checkDigit % 10);
        if (checkDigit === 10) {
            checkDigit = 0;
        }
        buffer.append(checkDigit.toString());
        var leftPoints = leftPair.getFinderPattern().getResultPoints();
        var rightPoints = rightPair.getFinderPattern().getResultPoints();
        return new Result_1.default(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat_1.default.RSS_14, new Date().getTime());
    };
    RSS14Reader.checkChecksum = function (leftPair, rightPair) {
        var checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;
        var targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();
        if (targetCheckValue > 72) {
            targetCheckValue--;
        }
        if (targetCheckValue > 8) {
            targetCheckValue--;
        }
        return checkValue === targetCheckValue;
    };
    RSS14Reader.prototype.decodePair = function (row, right, rowNumber, hints) {
        try {
            var startEnd = this.findFinderPattern(row, right);
            var pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);
            var resultPointCallback = hints == null ? null : hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);
            if (resultPointCallback != null) {
                var center = (startEnd[0] + startEnd[1]) / 2.0;
                if (right) {
                    // row is actually reversed
                    center = row.getSize() - 1 - center;
                }
                resultPointCallback.foundPossibleResultPoint(new ResultPoint_1.default(center, rowNumber));
            }
            var outside = this.decodeDataCharacter(row, pattern, true);
            var inside = this.decodeDataCharacter(row, pattern, false);
            return new Pair_1.default(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);
        }
        catch (err) {
            return null;
        }
    };
    RSS14Reader.prototype.decodeDataCharacter = function (row, pattern, outsideChar) {
        var counters = this.getDataCharacterCounters();
        for (var x = 0; x < counters.length; x++) {
            counters[x] = 0;
        }
        if (outsideChar) {
            OneDReader_1.default.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
        }
        else {
            OneDReader_1.default.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);
            // reverse it
            for (var i = 0, j = counters.length - 1; i < j; i++, j--) {
                var temp = counters[i];
                counters[i] = counters[j];
                counters[j] = temp;
            }
        }
        var numModules = outsideChar ? 16 : 15;
        var elementWidth = MathUtils_1.default.sum(new Int32Array(counters)) / numModules;
        var oddCounts = this.getOddCounts();
        var evenCounts = this.getEvenCounts();
        var oddRoundingErrors = this.getOddRoundingErrors();
        var evenRoundingErrors = this.getEvenRoundingErrors();
        for (var i = 0; i < counters.length; i++) {
            var value = counters[i] / elementWidth;
            var count = Math.floor(value + 0.5);
            if (count < 1) {
                count = 1;
            }
            else if (count > 8) {
                count = 8;
            }
            var offset = Math.floor(i / 2);
            if ((i & 0x01) === 0) {
                oddCounts[offset] = count;
                oddRoundingErrors[offset] = value - count;
            }
            else {
                evenCounts[offset] = count;
                evenRoundingErrors[offset] = value - count;
            }
        }
        this.adjustOddEvenCounts(outsideChar, numModules);
        var oddSum = 0;
        var oddChecksumPortion = 0;
        for (var i = oddCounts.length - 1; i >= 0; i--) {
            oddChecksumPortion *= 9;
            oddChecksumPortion += oddCounts[i];
            oddSum += oddCounts[i];
        }
        var evenChecksumPortion = 0;
        var evenSum = 0;
        for (var i = evenCounts.length - 1; i >= 0; i--) {
            evenChecksumPortion *= 9;
            evenChecksumPortion += evenCounts[i];
            evenSum += evenCounts[i];
        }
        var checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;
        if (outsideChar) {
            if ((oddSum & 0x01) !== 0 || oddSum > 12 || oddSum < 4) {
                throw new NotFoundException_1.default();
            }
            var group = (12 - oddSum) / 2;
            var oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];
            var evenWidest = 9 - oddWidest;
            var vOdd = RSSUtils_1.default.getRSSvalue(oddCounts, oddWidest, false);
            var vEven = RSSUtils_1.default.getRSSvalue(evenCounts, evenWidest, true);
            var tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];
            var gSum = RSS14Reader.OUTSIDE_GSUM[group];
            return new DataCharacter_1.default(vOdd * tEven + vEven + gSum, checksumPortion);
        }
        else {
            if ((evenSum & 0x01) !== 0 || evenSum > 10 || evenSum < 4) {
                throw new NotFoundException_1.default();
            }
            var group = (10 - evenSum) / 2;
            var oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];
            var evenWidest = 9 - oddWidest;
            var vOdd = RSSUtils_1.default.getRSSvalue(oddCounts, oddWidest, true);
            var vEven = RSSUtils_1.default.getRSSvalue(evenCounts, evenWidest, false);
            var tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];
            var gSum = RSS14Reader.INSIDE_GSUM[group];
            return new DataCharacter_1.default(vEven * tOdd + vOdd + gSum, checksumPortion);
        }
    };
    RSS14Reader.prototype.findFinderPattern = function (row, rightFinderPattern) {
        var counters = this.getDecodeFinderCounters();
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var width = row.getSize();
        var isWhite = false;
        var rowOffset = 0;
        while (rowOffset < width) {
            isWhite = !row.get(rowOffset);
            if (rightFinderPattern === isWhite) {
                // Will encounter white first when searching for right finder pattern
                break;
            }
            rowOffset++;
        }
        var counterPosition = 0;
        var patternStart = rowOffset;
        for (var x = rowOffset; x < width; x++) {
            if (row.get(x) !== isWhite) {
                counters[counterPosition]++;
            }
            else {
                if (counterPosition === 3) {
                    if (AbstractRSSReader_1.default.isFinderPattern(counters)) {
                        return [patternStart, x];
                    }
                    patternStart += counters[0] + counters[1];
                    counters[0] = counters[2];
                    counters[1] = counters[3];
                    counters[2] = 0;
                    counters[3] = 0;
                    counterPosition--;
                }
                else {
                    counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
            }
        }
        throw new NotFoundException_1.default();
    };
    RSS14Reader.prototype.parseFoundFinderPattern = function (row, rowNumber, right, startEnd) {
        // Actually we found elements 2-5
        var firstIsBlack = row.get(startEnd[0]);
        var firstElementStart = startEnd[0] - 1;
        // Locate element 1
        while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {
            firstElementStart--;
        }
        firstElementStart++;
        var firstCounter = startEnd[0] - firstElementStart;
        // Make 'counters' hold 1-4
        var counters = this.getDecodeFinderCounters();
        var copy = new Array(counters.length);
        System_1.default.arraycopy(counters, 0, copy, 1, counters.length - 1);
        copy[0] = firstCounter;
        var value = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);
        var start = firstElementStart;
        var end = startEnd[1];
        if (right) {
            // row is actually reversed
            start = row.getSize() - 1 - start;
            end = row.getSize() - 1 - end;
        }
        return new FinderPattern_1.default(value, [firstElementStart, startEnd[1]], start, end, rowNumber);
    };
    RSS14Reader.prototype.adjustOddEvenCounts = function (outsideChar, numModules) {
        var oddSum = MathUtils_1.default.sum(new Int32Array(this.getOddCounts()));
        var evenSum = MathUtils_1.default.sum(new Int32Array(this.getEvenCounts()));
        var incrementOdd = false;
        var decrementOdd = false;
        var incrementEven = false;
        var decrementEven = false;
        if (outsideChar) {
            if (oddSum > 12) {
                decrementOdd = true;
            }
            else if (oddSum < 4) {
                incrementOdd = true;
            }
            if (evenSum > 12) {
                decrementEven = true;
            }
            else if (evenSum < 4) {
                incrementEven = true;
            }
        }
        else {
            if (oddSum > 11) {
                decrementOdd = true;
            }
            else if (oddSum < 5) {
                incrementOdd = true;
            }
            if (evenSum > 10) {
                decrementEven = true;
            }
            else if (evenSum < 4) {
                incrementEven = true;
            }
        }
        var mismatch = oddSum + evenSum - numModules;
        var oddParityBad = (oddSum & 0x01) === (outsideChar ? 1 : 0);
        var evenParityBad = (evenSum & 0x01) === 1;
        if (mismatch === 1) {
            if (oddParityBad) {
                if (evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                decrementOdd = true;
            }
            else {
                if (!evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                decrementEven = true;
            }
        }
        else if (mismatch === -1) {
            if (oddParityBad) {
                if (evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                incrementOdd = true;
            }
            else {
                if (!evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                incrementEven = true;
            }
        }
        else if (mismatch === 0) {
            if (oddParityBad) {
                if (!evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                // Both bad
                if (oddSum < evenSum) {
                    incrementOdd = true;
                    decrementEven = true;
                }
                else {
                    decrementOdd = true;
                    incrementEven = true;
                }
            }
            else {
                if (evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                // Nothing to do!
            }
        }
        else {
            throw new NotFoundException_1.default();
        }
        if (incrementOdd) {
            if (decrementOdd) {
                throw new NotFoundException_1.default();
            }
            AbstractRSSReader_1.default.increment(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (decrementOdd) {
            AbstractRSSReader_1.default.decrement(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (incrementEven) {
            if (decrementEven) {
                throw new NotFoundException_1.default();
            }
            AbstractRSSReader_1.default.increment(this.getEvenCounts(), this.getOddRoundingErrors());
        }
        if (decrementEven) {
            AbstractRSSReader_1.default.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
        }
    };
    RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];
    RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];
    RSS14Reader.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];
    RSS14Reader.INSIDE_GSUM = [0, 336, 1036, 1516];
    RSS14Reader.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];
    RSS14Reader.INSIDE_ODD_WIDEST = [2, 4, 6, 8];
    RSS14Reader.FINDER_PATTERNS = [
        [3, 8, 2, 1],
        [3, 5, 5, 1],
        [3, 3, 7, 1],
        [3, 1, 9, 1],
        [2, 7, 4, 1],
        [2, 5, 6, 1],
        [2, 3, 8, 1],
        [1, 5, 7, 1],
        [1, 3, 9, 1],
    ];
    return RSS14Reader;
}(AbstractRSSReader_1.default));
exports.default = RSS14Reader;
//# sourceMappingURL=RSS14Reader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/RSSUtils.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/RSSUtils.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * RSS util functions.
 */
var RSSUtils = /** @class */ (function () {
    function RSSUtils() {
    }
    RSSUtils.prototype.RSSUtils = function () { };
    RSSUtils.getRSSvalue = function (widths, maxWidth, noNarrow) {
        var e_1, _a;
        var n = 0;
        try {
            for (var widths_1 = __values(widths), widths_1_1 = widths_1.next(); !widths_1_1.done; widths_1_1 = widths_1.next()) {
                var width = widths_1_1.value;
                n += width;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (widths_1_1 && !widths_1_1.done && (_a = widths_1.return)) _a.call(widths_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var val = 0;
        var narrowMask = 0;
        var elements = widths.length;
        for (var bar = 0; bar < elements - 1; bar++) {
            var elmWidth = void 0;
            for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {
                var subVal = RSSUtils.combins(n - elmWidth - 1, elements - bar - 2);
                if (noNarrow && (narrowMask === 0) && (n - elmWidth - (elements - bar - 1) >= elements - bar - 1)) {
                    subVal -= RSSUtils.combins(n - elmWidth - (elements - bar), elements - bar - 2);
                }
                if (elements - bar - 1 > 1) {
                    var lessVal = 0;
                    for (var mxwElement = n - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {
                        lessVal += RSSUtils.combins(n - elmWidth - mxwElement - 1, elements - bar - 3);
                    }
                    subVal -= lessVal * (elements - 1 - bar);
                }
                else if (n - elmWidth > maxWidth) {
                    subVal--;
                }
                val += subVal;
            }
            n -= elmWidth;
        }
        return val;
    };
    RSSUtils.combins = function (n, r) {
        var maxDenom;
        var minDenom;
        if (n - r > r) {
            minDenom = r;
            maxDenom = n - r;
        }
        else {
            minDenom = n - r;
            maxDenom = r;
        }
        var val = 1;
        var j = 1;
        for (var i = n; i > maxDenom; i--) {
            val *= i;
            if (j <= minDenom) {
                val /= j;
                j++;
            }
        }
        while ((j <= minDenom)) {
            val /= j;
            j++;
        }
        return val;
    };
    return RSSUtils;
}());
exports.default = RSSUtils;
//# sourceMappingURL=RSSUtils.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/BitArrayBuilder.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/BitArrayBuilder.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BitArray_1 = __webpack_require__(/*! ../../../common/BitArray */ "./node_modules/@zxing/library/esm5/core/common/BitArray.js");
var BitArrayBuilder = /** @class */ (function () {
    function BitArrayBuilder() {
    }
    BitArrayBuilder.buildBitArray = function (pairs) {
        var charNumber = (pairs.length * 2) - 1;
        if (pairs[pairs.length - 1].getRightChar() == null) {
            charNumber -= 1;
        }
        var size = 12 * charNumber;
        var binary = new BitArray_1.default(size);
        var accPos = 0;
        var firstPair = pairs[0];
        var firstValue = firstPair.getRightChar().getValue();
        for (var i = 11; i >= 0; --i) {
            if ((firstValue & (1 << i)) != 0) {
                binary.set(accPos);
            }
            accPos++;
        }
        for (var i = 1; i < pairs.length; ++i) {
            var currentPair = pairs[i];
            var leftValue = currentPair.getLeftChar().getValue();
            for (var j = 11; j >= 0; --j) {
                if ((leftValue & (1 << j)) != 0) {
                    binary.set(accPos);
                }
                accPos++;
            }
            if (currentPair.getRightChar() != null) {
                var rightValue = currentPair.getRightChar().getValue();
                for (var j = 11; j >= 0; --j) {
                    if ((rightValue & (1 << j)) != 0) {
                        binary.set(accPos);
                    }
                    accPos++;
                }
            }
        }
        return binary;
    };
    return BitArrayBuilder;
}());
exports.default = BitArrayBuilder;
//# sourceMappingURL=BitArrayBuilder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/ExpandedPair.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/ExpandedPair.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ExpandedPair = /** @class */ (function () {
    function ExpandedPair(leftChar, rightChar, finderPatter, mayBeLast) {
        this.leftchar = leftChar;
        this.rightchar = rightChar;
        this.finderpattern = finderPatter;
        this.maybeLast = mayBeLast;
    }
    ExpandedPair.prototype.mayBeLast = function () {
        return this.maybeLast;
    };
    ExpandedPair.prototype.getLeftChar = function () {
        return this.leftchar;
    };
    ExpandedPair.prototype.getRightChar = function () {
        return this.rightchar;
    };
    ExpandedPair.prototype.getFinderPattern = function () {
        return this.finderpattern;
    };
    ExpandedPair.prototype.mustBeLast = function () {
        return this.rightchar == null;
    };
    ExpandedPair.prototype.toString = function () {
        return '[ ' + this.leftchar + ', ' + this.rightchar + ' : ' + (this.finderpattern == null ? "null" : this.finderpattern.getValue()) + " ]";
    };
    ExpandedPair.equals = function (o1, o2) {
        if (!(o1 instanceof ExpandedPair)) {
            return false;
        }
        return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) &&
            ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) &&
            ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);
    };
    ExpandedPair.equalsOrNull = function (o1, o2) {
        return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);
    };
    ExpandedPair.prototype.hashCode = function () {
        //return ExpandedPair.hashNotNull(leftChar) ^ hashNotNull(rightChar) ^ hashNotNull(finderPattern);
        var value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();
        return value;
    };
    // To do - Re check the implementation
    ExpandedPair.hashNotNull = function (o) {
        return o === null ? 0 : o.hashCode();
    };
    return ExpandedPair;
}());
exports.default = ExpandedPair;
//# sourceMappingURL=ExpandedPair.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/ExpandedRow.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/ExpandedRow.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ExpandedRow = /** @class */ (function () {
    function ExpandedRow(pairs, rowNumber, wasReversed) {
        this.pairs = pairs;
        this.rowNumber = rowNumber;
        this.wasReversed = wasReversed;
    }
    ExpandedRow.prototype.getPairs = function () {
        return this.pairs;
    };
    ExpandedRow.prototype.getRowNumber = function () {
        return this.rowNumber;
    };
    ExpandedRow.prototype.isReversed = function () {
        return this.wasReversed;
    };
    // check implementation
    ExpandedRow.prototype.isEquivalent = function (otherPairs) {
        return this.checkEqualitity(this, otherPairs);
    };
    //@Override
    ExpandedRow.prototype.toString = function () {
        return "{ " + this.pairs + " }";
    };
    /**
     * Two rows are equal if they contain the same pairs in the same order.
     */
    //@Override
    // check implementation
    ExpandedRow.prototype.equals = function (o1, o2) {
        if (!(o1 instanceof ExpandedRow)) {
            return false;
        }
        return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;
    };
    ExpandedRow.prototype.checkEqualitity = function (pair1, pair2) {
        if (!pair1 || !pair2)
            return;
        var result;
        pair1.forEach(function (e1, i) {
            pair2.forEach(function (e2) {
                if (e1.getLeftChar().getValue() === e2.getLeftChar().getValue() && e1.getRightChar().getValue() === e2.getRightChar().getValue() && e1.getFinderPatter().getValue() === e2.getFinderPatter().getValue()) {
                    result = true;
                }
            });
        });
        return result;
    };
    return ExpandedRow;
}());
exports.default = ExpandedRow;
//# sourceMappingURL=ExpandedRow.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/RSSExpandedReader.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/RSSExpandedReader.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var BarcodeFormat_1 = __webpack_require__(/*! ../../../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var NotFoundException_1 = __webpack_require__(/*! ../../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var Result_1 = __webpack_require__(/*! ../../../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
var MathUtils_1 = __webpack_require__(/*! ../../../common/detector/MathUtils */ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js");
var AbstractRSSReader_1 = __webpack_require__(/*! ../../rss/AbstractRSSReader */ "./node_modules/@zxing/library/esm5/core/oned/rss/AbstractRSSReader.js");
var DataCharacter_1 = __webpack_require__(/*! ../../rss/DataCharacter */ "./node_modules/@zxing/library/esm5/core/oned/rss/DataCharacter.js");
var FinderPattern_1 = __webpack_require__(/*! ../../rss/FinderPattern */ "./node_modules/@zxing/library/esm5/core/oned/rss/FinderPattern.js");
var RSSUtils_1 = __webpack_require__(/*! ../../rss/RSSUtils */ "./node_modules/@zxing/library/esm5/core/oned/rss/RSSUtils.js");
var AbstractExpandedDecoderComplement_1 = __webpack_require__(/*! ./decoders/AbstractExpandedDecoderComplement */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js");
var ExpandedPair_1 = __webpack_require__(/*! ./ExpandedPair */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/ExpandedPair.js");
var ExpandedRow_1 = __webpack_require__(/*! ./ExpandedRow */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/ExpandedRow.js");
var BitArrayBuilder_1 = __webpack_require__(/*! ./BitArrayBuilder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/BitArrayBuilder.js");
var System_1 = __webpack_require__(/*! ../../../util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
// import java.util.ArrayList;
// import java.util.Iterator;
// import java.util.List;
// import java.util.Map;
// import java.util.Collections;
var RSSExpandedReader = /** @class */ (function (_super) {
    __extends(RSSExpandedReader, _super);
    function RSSExpandedReader() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);
        _this.rows = new Array();
        _this.startEnd = [2];
        return _this;
    }
    RSSExpandedReader.prototype.decodeRow = function (rowNumber, row, hints) {
        // Rows can start with even pattern in case in prev rows there where odd number of patters.
        // So lets try twice
        //this.pairs.clear();
        this.pairs.length = 0;
        this.startFromEven = false;
        try {
            return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
        }
        catch (e) {
            // OK
            console.log(e);
        }
        this.pairs.length = 0;
        this.startFromEven = true;
        return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
    };
    RSSExpandedReader.prototype.reset = function () {
        this.pairs.length = 0;
        this.rows.length = 0;
    };
    // Not private for testing
    RSSExpandedReader.prototype.decodeRow2pairs = function (rowNumber, row) {
        var done = false;
        while (!done) {
            try {
                this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));
            }
            catch (NotFoundException) {
                if (!this.pairs.length) {
                    throw new NotFoundException();
                }
                // exit this loop when retrieveNextPair() fails and throws
                done = true;
            }
        }
        // TODO: verify sequence of finder patterns as in checkPairSequence()
        if (this.checkChecksum()) {
            return this.pairs;
        }
        var tryStackedDecode;
        if (this.rows.length) {
            tryStackedDecode = true;
        }
        else {
            tryStackedDecode = false;
        }
        //let tryStackedDecode = !this.rows.isEmpty();
        this.storeRow(rowNumber, false); // TODO: deal with reversed rows
        if (tryStackedDecode) {
            // When the image is 180-rotated, then rows are sorted in wrong direction.
            // Try twice with both the directions.
            var ps = this.checkRowsBoolean(false);
            if (ps != null) {
                return ps;
            }
            ps = this.checkRowsBoolean(true);
            if (ps != null) {
                return ps;
            }
        }
        throw new NotFoundException_1.default();
    };
    //Need to Verify
    RSSExpandedReader.prototype.checkRowsBoolean = function (reverse) {
        // Limit number of rows we are checking
        // We use recursive algorithm with pure complexity and don't want it to take forever
        // Stacked barcode can have up to 11 rows, so 25 seems reasonable enough
        if (this.rows.length > 25) {
            this.rows.length = 0; // We will never have a chance to get result, so clear it
            return null;
        }
        this.pairs.length = 0;
        if (reverse) {
            this.rows = this.rows.reverse();
            //Collections.reverse(this.rows);
        }
        var ps = null;
        try {
            ps = this.checkRows(new Array(), 0);
        }
        catch (e) {
            // OK
            console.log(e);
        }
        if (reverse) {
            this.rows = this.rows.reverse();
            //Collections.reverse(this.rows);
        }
        return ps;
    };
    // Try to construct a valid rows sequence
    // Recursion is used to implement backtracking
    RSSExpandedReader.prototype.checkRows = function (collectedRows, currentRow) {
        var e_1, _a;
        for (var i = currentRow; i < this.rows.length; i++) {
            var row = this.rows[i];
            this.pairs.length = 0;
            try {
                for (var collectedRows_1 = __values(collectedRows), collectedRows_1_1 = collectedRows_1.next(); !collectedRows_1_1.done; collectedRows_1_1 = collectedRows_1.next()) {
                    var collectedRow = collectedRows_1_1.value;
                    this.pairs.push(collectedRow.getPairs());
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (collectedRows_1_1 && !collectedRows_1_1.done && (_a = collectedRows_1.return)) _a.call(collectedRows_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this.pairs.push(row.getPairs());
            if (!RSSExpandedReader.isValidSequence(this.pairs)) {
                continue;
            }
            if (this.checkChecksum()) {
                return this.pairs;
            }
            var rs = new Array(collectedRows);
            rs.push(row);
            try {
                // Recursion: try to add more rows
                return this.checkRows(rs, i + 1);
            }
            catch (e) {
                // We failed, try the next candidate
                console.log(e);
            }
        }
        throw new NotFoundException_1.default();
    };
    // Whether the pairs form a valid find pattern sequence,
    // either complete or a prefix
    RSSExpandedReader.isValidSequence = function (pairs) {
        var e_2, _a;
        try {
            for (var _b = __values(RSSExpandedReader.FINDER_PATTERN_SEQUENCES), _c = _b.next(); !_c.done; _c = _b.next()) {
                var sequence = _c.value;
                if (pairs.length > sequence.length) {
                    continue;
                }
                var stop_1 = true;
                for (var j = 0; j < pairs.length; j++) {
                    if (pairs[j].getFinderPattern().getValue() != sequence[j]) {
                        stop_1 = false;
                        break;
                    }
                }
                if (stop_1) {
                    return true;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return false;
    };
    RSSExpandedReader.prototype.storeRow = function (rowNumber, wasReversed) {
        // Discard if duplicate above or below; otherwise insert in order by row number.
        var insertPos = 0;
        var prevIsSame = false;
        var nextIsSame = false;
        while (insertPos < this.rows.length) {
            var erow = this.rows[insertPos];
            if (erow.getRowNumber() > rowNumber) {
                nextIsSame = erow.isEquivalent(this.pairs);
                break;
            }
            prevIsSame = erow.isEquivalent(this.pairs);
            insertPos++;
        }
        if (nextIsSame || prevIsSame) {
            return;
        }
        // When the row was partially decoded (e.g. 2 pairs found instead of 3),
        // it will prevent us from detecting the barcode.
        // Try to merge partial rows
        // Check whether the row is part of an allready detected row
        if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {
            return;
        }
        this.rows.push(insertPos, new ExpandedRow_1.default(this.pairs, rowNumber, wasReversed));
        this.removePartialRows(this.pairs, this.rows);
    };
    // Remove all the rows that contains only specified pairs
    RSSExpandedReader.prototype.removePartialRows = function (pairs, rows) {
        var e_3, _a, e_4, _b, e_5, _c;
        try {
            // for (Iterator<ExpandedRow> iterator = rows.iterator(); iterator.hasNext();) {
            //   ExpandedRow r = iterator.next();
            //   if (r.getPairs().size() == pairs.size()) {
            //     continue;
            //   }
            //   boolean allFound = true;
            //   for (ExpandedPair p : r.getPairs()) {
            //     boolean found = false;
            //     for (ExpandedPair pp : pairs) {
            //       if (p.equals(pp)) {
            //         found = true;
            //         break;
            //       }
            //     }
            //     if (!found) {
            //       allFound = false;
            //       break;
            //     }
            //   }
            //   if (allFound) {
            //     // 'pairs' contains all the pairs from the row 'r'
            //     iterator.remove();
            //   }
            // }
            for (var rows_1 = __values(rows), rows_1_1 = rows_1.next(); !rows_1_1.done; rows_1_1 = rows_1.next()) {
                var row = rows_1_1.value;
                if (row.getPairs().length === pairs.length) {
                    continue;
                }
                var allFound = true;
                try {
                    for (var _d = __values(row.getPairs()), _e = _d.next(); !_e.done; _e = _d.next()) {
                        var p = _e.value;
                        var found = false;
                        try {
                            for (var pairs_1 = __values(pairs), pairs_1_1 = pairs_1.next(); !pairs_1_1.done; pairs_1_1 = pairs_1.next()) {
                                var pp = pairs_1_1.value;
                                if (ExpandedPair_1.default.equals(p, pp)) {
                                    found = true;
                                    break;
                                }
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (pairs_1_1 && !pairs_1_1.done && (_c = pairs_1.return)) _c.call(pairs_1);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                        if (!found) {
                            allFound = false;
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (rows_1_1 && !rows_1_1.done && (_a = rows_1.return)) _a.call(rows_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    // Returns true when one of the rows already contains all the pairs
    RSSExpandedReader.isPartialRow = function (pairs, rows) {
        var e_6, _a, e_7, _b, e_8, _c;
        try {
            for (var rows_2 = __values(rows), rows_2_1 = rows_2.next(); !rows_2_1.done; rows_2_1 = rows_2.next()) {
                var r = rows_2_1.value;
                var allFound = true;
                try {
                    for (var pairs_2 = __values(pairs), pairs_2_1 = pairs_2.next(); !pairs_2_1.done; pairs_2_1 = pairs_2.next()) {
                        var p = pairs_2_1.value;
                        var found = false;
                        try {
                            for (var _d = __values(r.getPairs()), _e = _d.next(); !_e.done; _e = _d.next()) {
                                var pp = _e.value;
                                if (p.equals(pp)) {
                                    found = true;
                                    break;
                                }
                            }
                        }
                        catch (e_8_1) { e_8 = { error: e_8_1 }; }
                        finally {
                            try {
                                if (_e && !_e.done && (_c = _d.return)) _c.call(_d);
                            }
                            finally { if (e_8) throw e_8.error; }
                        }
                        if (!found) {
                            allFound = false;
                            break;
                        }
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (pairs_2_1 && !pairs_2_1.done && (_b = pairs_2.return)) _b.call(pairs_2);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
                if (allFound) {
                    // the row 'r' contain all the pairs from 'pairs'
                    return true;
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (rows_2_1 && !rows_2_1.done && (_a = rows_2.return)) _a.call(rows_2);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return false;
    };
    // Only used for unit testing
    RSSExpandedReader.prototype.getRows = function () {
        return this.rows;
    };
    // Not private for unit testing
    RSSExpandedReader.constructResult = function (pairs) {
        var binary = BitArrayBuilder_1.default.buildBitArray(pairs);
        var decoder = AbstractExpandedDecoderComplement_1.createDecoder(binary);
        var resultingString = decoder.parseInformation();
        var firstPoints = pairs[0].getFinderPattern().getResultPoints();
        var lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();
        var points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];
        return new Result_1.default(resultingString, null, null, points, BarcodeFormat_1.default.RSS_EXPANDED, null);
    };
    RSSExpandedReader.prototype.checkChecksum = function () {
        var firstPair = this.pairs.get(0);
        var checkCharacter = firstPair.getLeftChar();
        var firstCharacter = firstPair.getRightChar();
        if (firstCharacter == null) {
            return false;
        }
        var checksum = firstCharacter.getChecksumPortion();
        var s = 2;
        for (var i = 1; i < this.pairs.size(); ++i) {
            var currentPair = this.pairs.get(i);
            checksum += currentPair.getLeftChar().getChecksumPortion();
            s++;
            var currentRightChar = currentPair.getRightChar();
            if (currentRightChar != null) {
                checksum += currentRightChar.getChecksumPortion();
                s++;
            }
        }
        checksum %= 211;
        var checkCharacterValue = 211 * (s - 4) + checksum;
        return checkCharacterValue == checkCharacter.getValue();
    };
    RSSExpandedReader.getNextSecondBar = function (row, initialPos) {
        var currentPos;
        if (row.get(initialPos)) {
            currentPos = row.getNextUnset(initialPos);
            currentPos = row.getNextSet(currentPos);
        }
        else {
            currentPos = row.getNextSet(initialPos);
            currentPos = row.getNextUnset(currentPos);
        }
        return currentPos;
    };
    // not private for testing
    RSSExpandedReader.prototype.retrieveNextPair = function (row, previousPairs, rowNumber) {
        var isOddPattern = previousPairs.length % 2 == 0;
        if (this.startFromEven) {
            isOddPattern = !isOddPattern;
        }
        var pattern;
        var keepFinding = true;
        var forcedOffset = -1;
        do {
            this.findNextPair(row, previousPairs, forcedOffset);
            pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);
            if (pattern == null) {
                forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);
            }
            else {
                keepFinding = false;
            }
        } while (keepFinding);
        // When stacked symbol is split over multiple rows, there's no way to guess if this pair can be last or not.
        // boolean mayBeLast = checkPairSequence(previousPairs, pattern);
        var leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);
        if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {
            throw new NotFoundException_1.default();
        }
        var rightChar;
        try {
            rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);
        }
        catch (e) {
            rightChar = null;
            console.log(e);
        }
        return new ExpandedPair_1.default(leftChar, rightChar, pattern, true);
    };
    RSSExpandedReader.prototype.isEmptyPair = function (pairs) {
        if (pairs.length === 0) {
            return true;
        }
        return false;
    };
    RSSExpandedReader.prototype.findNextPair = function (row, previousPairs, forcedOffset) {
        var counters = this.getDecodeFinderCounters();
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        var width = row.getSize();
        var rowOffset;
        if (forcedOffset >= 0) {
            rowOffset = forcedOffset;
        }
        else if (this.isEmptyPair(previousPairs)) {
            rowOffset = 0;
        }
        else {
            var lastPair = previousPairs[previousPairs.length - 1];
            rowOffset = lastPair.getFinderPattern().getStartEnd()[1];
        }
        var searchingEvenPair = previousPairs.length % 2 != 0;
        if (this.startFromEven) {
            searchingEvenPair = !searchingEvenPair;
        }
        var isWhite = false;
        while (rowOffset < width) {
            isWhite = !row.get(rowOffset);
            if (!isWhite) {
                break;
            }
            rowOffset++;
        }
        var counterPosition = 0;
        var patternStart = rowOffset;
        for (var x = rowOffset; x < width; x++) {
            if (row.get(x) != isWhite) {
                counters[counterPosition]++;
            }
            else {
                if (counterPosition == 3) {
                    if (searchingEvenPair) {
                        RSSExpandedReader.reverseCounters(counters);
                    }
                    if (RSSExpandedReader.isFinderPattern(counters)) {
                        this.startEnd[0] = patternStart;
                        this.startEnd[1] = x;
                        return;
                    }
                    if (searchingEvenPair) {
                        RSSExpandedReader.reverseCounters(counters);
                    }
                    patternStart += counters[0] + counters[1];
                    counters[0] = counters[2];
                    counters[1] = counters[3];
                    counters[2] = 0;
                    counters[3] = 0;
                    counterPosition--;
                }
                else {
                    counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
            }
        }
        throw new NotFoundException_1.default();
    };
    RSSExpandedReader.reverseCounters = function (counters) {
        var length = counters.length;
        for (var i = 0; i < length / 2; ++i) {
            var tmp = counters[i];
            counters[i] = counters[length - i - 1];
            counters[length - i - 1] = tmp;
        }
    };
    RSSExpandedReader.prototype.parseFoundFinderPattern = function (row, rowNumber, oddPattern) {
        // Actually we found elements 2-5.
        var firstCounter;
        var start;
        var end;
        if (oddPattern) {
            // If pattern number is odd, we need to locate element 1 *before* the current block.
            var firstElementStart = this.startEnd[0] - 1;
            // Locate element 1
            while (firstElementStart >= 0 && !row.get(firstElementStart)) {
                firstElementStart--;
            }
            firstElementStart++;
            firstCounter = this.startEnd[0] - firstElementStart;
            start = firstElementStart;
            end = this.startEnd[1];
        }
        else {
            // If pattern number is even, the pattern is reversed, so we need to locate element 1 *after* the current block.
            start = this.startEnd[0];
            end = row.getNextUnset(this.startEnd[1] + 1);
            firstCounter = end - this.startEnd[1];
        }
        // Make 'counters' hold 1-4
        var counters = this.getDecodeFinderCounters();
        System_1.default.arraycopy(counters, 0, counters, 1, counters.length - 1);
        counters[0] = firstCounter;
        var value;
        try {
            value = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);
        }
        catch (e) {
            return null;
            console.log(e);
        }
        //return new FinderPattern(value, new int[] { start, end }, start, end, rowNumber});
        return new FinderPattern_1.default(value, [start, end], start, end, rowNumber);
    };
    RSSExpandedReader.prototype.decodeDataCharacter = function (row, pattern, isOddPattern, leftChar) {
        var counters = this.getDataCharacterCounters();
        for (var x = 0; x < counters.length; x++) {
            counters[x] = 0;
        }
        if (leftChar) {
            RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
        }
        else {
            RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);
            // reverse it
            for (var i = 0, j = counters.length - 1; i < j; i++, j--) {
                var temp = counters[i];
                counters[i] = counters[j];
                counters[j] = temp;
            }
        } //counters[] has the pixels of the module
        var numModules = 17; //left and right data characters have all the same length
        var elementWidth = MathUtils_1.default.sum(new Int32Array(counters)) / numModules;
        // Sanity check: element width for pattern and the character should match
        var expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15.0;
        if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {
            throw new NotFoundException_1.default();
        }
        var oddCounts = this.getOddCounts();
        var evenCounts = this.getEvenCounts();
        var oddRoundingErrors = this.getOddRoundingErrors();
        var evenRoundingErrors = this.getEvenRoundingErrors();
        for (var i = 0; i < counters.length; i++) {
            var value_1 = 1.0 * counters[i] / elementWidth;
            var count = value_1 + 0.5; // Round
            if (count < 1) {
                if (value_1 < 0.3) {
                    throw new NotFoundException_1.default();
                }
                count = 1;
            }
            else if (count > 8) {
                if (value_1 > 8.7) {
                    throw new NotFoundException_1.default();
                }
                count = 8;
            }
            var offset = i / 2;
            if ((i & 0x01) == 0) {
                oddCounts[offset] = count;
                oddRoundingErrors[offset] = value_1 - count;
            }
            else {
                evenCounts[offset] = count;
                evenRoundingErrors[offset] = value_1 - count;
            }
        }
        this.adjustOddEvenCounts(numModules);
        var weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;
        var oddSum = 0;
        var oddChecksumPortion = 0;
        for (var i = oddCounts.length - 1; i >= 0; i--) {
            if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
                var weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i];
                oddChecksumPortion += oddCounts[i] * weight;
            }
            oddSum += oddCounts[i];
        }
        var evenChecksumPortion = 0;
        //int evenSum = 0;
        for (var i = evenCounts.length - 1; i >= 0; i--) {
            if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
                var weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i + 1];
                evenChecksumPortion += evenCounts[i] * weight;
            }
            //evenSum += evenCounts[i];
        }
        var checksumPortion = oddChecksumPortion + evenChecksumPortion;
        if ((oddSum & 0x01) != 0 || oddSum > 13 || oddSum < 4) {
            throw new NotFoundException_1.default();
        }
        var group = (13 - oddSum) / 2;
        var oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];
        var evenWidest = 9 - oddWidest;
        var vOdd = RSSUtils_1.default.getRSSvalue(oddCounts, oddWidest, true);
        var vEven = RSSUtils_1.default.getRSSvalue(evenCounts, evenWidest, false);
        var tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];
        var gSum = RSSExpandedReader.GSUM[group];
        var value = vOdd * tEven + vEven + gSum;
        return new DataCharacter_1.default(value, checksumPortion);
    };
    RSSExpandedReader.isNotA1left = function (pattern, isOddPattern, leftChar) {
        // A1: pattern.getValue is 0 (A), and it's an oddPattern, and it is a left char
        return !(pattern.getValue() == 0 && isOddPattern && leftChar);
    };
    RSSExpandedReader.prototype.adjustOddEvenCounts = function (numModules) {
        var oddSum = MathUtils_1.default.sum(new Int32Array(this.getOddCounts()));
        var evenSum = MathUtils_1.default.sum(new Int32Array(this.getEvenCounts()));
        var incrementOdd = false;
        var decrementOdd = false;
        if (oddSum > 13) {
            decrementOdd = true;
        }
        else if (oddSum < 4) {
            incrementOdd = true;
        }
        var incrementEven = false;
        var decrementEven = false;
        if (evenSum > 13) {
            decrementEven = true;
        }
        else if (evenSum < 4) {
            incrementEven = true;
        }
        var mismatch = oddSum + evenSum - numModules;
        var oddParityBad = (oddSum & 0x01) == 1;
        var evenParityBad = (evenSum & 0x01) == 0;
        if (mismatch == 1) {
            if (oddParityBad) {
                if (evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                decrementOdd = true;
            }
            else {
                if (!evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                decrementEven = true;
            }
        }
        else if (mismatch == -1) {
            if (oddParityBad) {
                if (evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                incrementOdd = true;
            }
            else {
                if (!evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                incrementEven = true;
            }
        }
        else if (mismatch == 0) {
            if (oddParityBad) {
                if (!evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                // Both bad
                if (oddSum < evenSum) {
                    incrementOdd = true;
                    decrementEven = true;
                }
                else {
                    decrementOdd = true;
                    incrementEven = true;
                }
            }
            else {
                if (evenParityBad) {
                    throw new NotFoundException_1.default();
                }
                // Nothing to do!
            }
        }
        else {
            throw new NotFoundException_1.default();
        }
        if (incrementOdd) {
            if (decrementOdd) {
                throw new NotFoundException_1.default();
            }
            RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (decrementOdd) {
            RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (incrementEven) {
            if (decrementEven) {
                throw new NotFoundException_1.default();
            }
            RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
        }
        if (decrementEven) {
            RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
        }
    };
    RSSExpandedReader.SYMBOL_WIDEST = [7, 5, 4, 3, 1];
    RSSExpandedReader.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];
    RSSExpandedReader.GSUM = [0, 348, 1388, 2948, 3988];
    RSSExpandedReader.FINDER_PATTERNS = [
        [1, 8, 4, 1],
        [3, 6, 4, 1],
        [3, 4, 6, 1],
        [3, 2, 8, 1],
        [2, 6, 5, 1],
        [2, 2, 9, 1] // F
    ];
    RSSExpandedReader.WEIGHTS = [
        [1, 3, 9, 27, 81, 32, 96, 77],
        [20, 60, 180, 118, 143, 7, 21, 63],
        [189, 145, 13, 39, 117, 140, 209, 205],
        [193, 157, 49, 147, 19, 57, 171, 91],
        [62, 186, 136, 197, 169, 85, 44, 132],
        [185, 133, 188, 142, 4, 12, 36, 108],
        [113, 128, 173, 97, 80, 29, 87, 50],
        [150, 28, 84, 41, 123, 158, 52, 156],
        [46, 138, 203, 187, 139, 206, 196, 166],
        [76, 17, 51, 153, 37, 111, 122, 155],
        [43, 129, 176, 106, 107, 110, 119, 146],
        [16, 48, 144, 10, 30, 90, 59, 177],
        [109, 116, 137, 200, 178, 112, 125, 164],
        [70, 210, 208, 202, 184, 130, 179, 115],
        [134, 191, 151, 31, 93, 68, 204, 190],
        [148, 22, 66, 198, 172, 94, 71, 2],
        [6, 18, 54, 162, 64, 192, 154, 40],
        [120, 149, 25, 75, 14, 42, 126, 167],
        [79, 26, 78, 23, 69, 207, 199, 175],
        [103, 98, 83, 38, 114, 131, 182, 124],
        [161, 61, 183, 127, 170, 88, 53, 159],
        [55, 165, 73, 8, 24, 72, 5, 15],
        [45, 135, 194, 160, 58, 174, 100, 89]
    ];
    RSSExpandedReader.FINDER_PAT_A = 0;
    RSSExpandedReader.FINDER_PAT_B = 1;
    RSSExpandedReader.FINDER_PAT_C = 2;
    RSSExpandedReader.FINDER_PAT_D = 3;
    RSSExpandedReader.FINDER_PAT_E = 4;
    RSSExpandedReader.FINDER_PAT_F = 5;
    RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_C],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
        [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
    ];
    RSSExpandedReader.MAX_PAIRS = 11;
    return RSSExpandedReader;
}(AbstractRSSReader_1.default));
exports.default = RSSExpandedReader;
//# sourceMappingURL=RSSExpandedReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI013103decoder.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI013103decoder.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AI013x0xDecoder_1 = __webpack_require__(/*! ./AI013x0xDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI013x0xDecoder.js");
var AI013103decoder = /** @class */ (function (_super) {
    __extends(AI013103decoder, _super);
    function AI013103decoder(information) {
        return _super.call(this, information) || this;
    }
    AI013103decoder.prototype.addWeightCode = function (buf, weight) {
        buf.append("(3103)");
    };
    AI013103decoder.prototype.checkWeight = function (weight) {
        return weight;
    };
    return AI013103decoder;
}(AI013x0xDecoder_1.default));
exports.default = AI013103decoder;
//# sourceMappingURL=AI013103decoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01320xDecoder.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01320xDecoder.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AI013x0xDecoder_1 = __webpack_require__(/*! ./AI013x0xDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI013x0xDecoder.js");
var AI01320xDecoder = /** @class */ (function (_super) {
    __extends(AI01320xDecoder, _super);
    function AI01320xDecoder(information) {
        return _super.call(this, information) || this;
    }
    AI01320xDecoder.prototype.addWeightCode = function (buf, weight) {
        if (weight < 10000) {
            buf.append("(3202)");
        }
        else {
            buf.append("(3203)");
        }
    };
    AI01320xDecoder.prototype.checkWeight = function (weight) {
        if (weight < 10000) {
            return weight;
        }
        return weight - 10000;
    };
    return AI01320xDecoder;
}(AI013x0xDecoder_1.default));
exports.default = AI01320xDecoder;
//# sourceMappingURL=AI01320xDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01392xDecoder.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01392xDecoder.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AI01decoder_1 = __webpack_require__(/*! ./AI01decoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01decoder.js");
var NotFoundException_1 = __webpack_require__(/*! ../../../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var AI01392xDecoder = /** @class */ (function (_super) {
    __extends(AI01392xDecoder, _super);
    function AI01392xDecoder(information) {
        return _super.call(this, information) || this;
    }
    AI01392xDecoder.prototype.parseInformation = function () {
        if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE) {
            throw new NotFoundException_1.default();
        }
        var buf = new StringBuilder_1.default();
        this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);
        var lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);
        buf.append("(392");
        buf.append(lastAIdigit);
        buf.append(')');
        var decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);
        buf.append(decodedInformation.getNewString());
        return buf.toString();
    };
    AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;
    AI01392xDecoder.LAST_DIGIT_SIZE = 2;
    return AI01392xDecoder;
}(AI01decoder_1.default));
exports.default = AI01392xDecoder;
//# sourceMappingURL=AI01392xDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01393xDecoder.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01393xDecoder.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AI01decoder_1 = __webpack_require__(/*! ./AI01decoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01decoder.js");
var NotFoundException_1 = __webpack_require__(/*! ../../../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var AI01393xDecoder = /** @class */ (function (_super) {
    __extends(AI01393xDecoder, _super);
    function AI01393xDecoder(information) {
        return _super.call(this, information) || this;
    }
    AI01393xDecoder.prototype.parseInformation = function () {
        if (this.getInformation().getSize() < AI01393xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE) {
            throw new NotFoundException_1.default();
        }
        var buf = new StringBuilder_1.default();
        this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);
        var lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);
        buf.append("(393");
        buf.append(lastAIdigit);
        buf.append(')');
        var firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);
        if (firstThreeDigits / 100 == 0) {
            buf.append('0');
        }
        if (firstThreeDigits / 10 == 0) {
            buf.append('0');
        }
        buf.append(firstThreeDigits);
        var generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE + AI01decoder_1.default.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE + AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);
        buf.append(generalInformation.getNewString());
        return buf.toString();
    };
    AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;
    AI01393xDecoder.LAST_DIGIT_SIZE = 2;
    AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;
    return AI01393xDecoder;
}(AI01decoder_1.default));
exports.default = AI01393xDecoder;
//# sourceMappingURL=AI01393xDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AI01weightDecoder_1 = __webpack_require__(/*! ./AI01weightDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01weightDecoder.js");
var NotFoundException_1 = __webpack_require__(/*! ../../../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var AI013x0x1xDecoder = /** @class */ (function (_super) {
    __extends(AI013x0x1xDecoder, _super);
    function AI013x0x1xDecoder(information, firstAIdigits, dateCode) {
        var _this = _super.call(this, information) || this;
        _this.dateCode = dateCode;
        _this.firstAIdigits = firstAIdigits;
        return _this;
    }
    AI013x0x1xDecoder.prototype.parseInformation = function () {
        if (this.getInformation().getSize() != AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE + AI013x0x1xDecoder.DATE_SIZE) {
            throw new NotFoundException_1.default();
        }
        var buf = new StringBuilder_1.default();
        this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);
        this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);
        this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE);
        return buf.toString();
    };
    AI013x0x1xDecoder.prototype.encodeCompressedDate = function (buf, currentPos) {
        var numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);
        if (numericDate == 38400) {
            return;
        }
        buf.append('(');
        buf.append(this.dateCode);
        buf.append(')');
        var day = numericDate % 32;
        numericDate /= 32;
        var month = numericDate % 12 + 1;
        numericDate /= 12;
        var year = numericDate;
        if (year / 10 == 0) {
            buf.append('0');
        }
        buf.append(year);
        if (month / 10 == 0) {
            buf.append('0');
        }
        buf.append(month);
        if (day / 10 == 0) {
            buf.append('0');
        }
        buf.append(day);
    };
    AI013x0x1xDecoder.prototype.addWeightCode = function (buf, weight) {
        buf.append('(');
        buf.append(this.firstAIdigits);
        buf.append(weight / 100000);
        buf.append(')');
    };
    AI013x0x1xDecoder.prototype.checkWeight = function (weight) {
        return weight % 100000;
    };
    AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;
    AI013x0x1xDecoder.WEIGHT_SIZE = 20;
    AI013x0x1xDecoder.DATE_SIZE = 16;
    return AI013x0x1xDecoder;
}(AI01weightDecoder_1.default));
exports.default = AI013x0x1xDecoder;
//# sourceMappingURL=AI013x0x1xDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI013x0xDecoder.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI013x0xDecoder.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AI01weightDecoder_1 = __webpack_require__(/*! ./AI01weightDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01weightDecoder.js");
var StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var NotFoundException_1 = __webpack_require__(/*! ../../../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var AI013x0xDecoder = /** @class */ (function (_super) {
    __extends(AI013x0xDecoder, _super);
    function AI013x0xDecoder(information) {
        return _super.call(this, information) || this;
    }
    AI013x0xDecoder.prototype.parseInformation = function () {
        if (this.getInformation().getSize() != AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder_1.default.GTIN_SIZE + AI013x0xDecoder.WEIGHT_SIZE) {
            throw new NotFoundException_1.default();
        }
        var buf = new StringBuilder_1.default();
        this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);
        this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder_1.default.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);
        return buf.toString();
    };
    AI013x0xDecoder.HEADER_SIZE = 4 + 1;
    AI013x0xDecoder.WEIGHT_SIZE = 15;
    return AI013x0xDecoder;
}(AI01weightDecoder_1.default));
exports.default = AI013x0xDecoder;
//# sourceMappingURL=AI013x0xDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js ***!
  \*********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AI01decoder_1 = __webpack_require__(/*! ./AI01decoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01decoder.js");
var StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var AI01AndOtherAIs = /** @class */ (function (_super) {
    __extends(AI01AndOtherAIs, _super);
    //the second one is the encodation method, and the other two are for the variable length
    function AI01AndOtherAIs(information) {
        return _super.call(this, information) || this;
    }
    AI01AndOtherAIs.prototype.parseInformation = function () {
        var buff = new StringBuilder_1.default();
        buff.append("(01)");
        var initialGtinPosition = buff.length();
        var firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);
        buff.append(firstGtinDigit);
        this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);
        return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);
    };
    AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2; //first bit encodes the linkage flag,
    return AI01AndOtherAIs;
}(AI01decoder_1.default));
exports.default = AI01AndOtherAIs;
//# sourceMappingURL=AI01AndOtherAIs.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01decoder.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01decoder.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AbstractExpandedDecoder_1 = __webpack_require__(/*! ./AbstractExpandedDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js");
var AI01decoder = /** @class */ (function (_super) {
    __extends(AI01decoder, _super);
    function AI01decoder(information) {
        return _super.call(this, information) || this;
    }
    AI01decoder.prototype.encodeCompressedGtin = function (buf, currentPos) {
        buf.append("(01)");
        var initialPosition = buf.length();
        buf.append('9');
        this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);
    };
    AI01decoder.prototype.encodeCompressedGtinWithoutAI = function (buf, currentPos, initialBufferPosition) {
        for (var i = 0; i < 4; ++i) {
            var currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i, 10);
            if (currentBlock / 100 == 0) {
                buf.append('0');
            }
            if (currentBlock / 10 == 0) {
                buf.append('0');
            }
            buf.append(currentBlock);
        }
        AI01decoder.appendCheckDigit(buf, initialBufferPosition);
    };
    AI01decoder.appendCheckDigit = function (buf, currentPos) {
        var checkDigit = 0;
        for (var i = 0; i < 13; i++) {
            //let digit = buf.charAt(i + currentPos) - '0';
            //To be checked
            var digit = buf.charAt(i + currentPos).charCodeAt(0) - '0'.charCodeAt(0);
            checkDigit += (i & 0x01) == 0 ? 3 * digit : digit;
        }
        checkDigit = 10 - (checkDigit % 10);
        if (checkDigit == 10) {
            checkDigit = 0;
        }
        buf.append(checkDigit);
    };
    AI01decoder.GTIN_SIZE = 40;
    return AI01decoder;
}(AbstractExpandedDecoder_1.default));
exports.default = AI01decoder;
//# sourceMappingURL=AI01decoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01weightDecoder.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01weightDecoder.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var AI01decoder_1 = __webpack_require__(/*! ./AI01decoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01decoder.js");
var AI01weightDecoder = /** @class */ (function (_super) {
    __extends(AI01weightDecoder, _super);
    function AI01weightDecoder(information) {
        return _super.call(this, information) || this;
    }
    AI01weightDecoder.prototype.encodeCompressedWeight = function (buf, currentPos, weightSize) {
        var originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);
        this.addWeightCode(buf, originalWeightNumeric);
        var weightNumeric = this.checkWeight(originalWeightNumeric);
        var currentDivisor = 100000;
        for (var i = 0; i < 5; ++i) {
            if (weightNumeric / currentDivisor == 0) {
                buf.append('0');
            }
            currentDivisor /= 10;
        }
        buf.append(weightNumeric);
    };
    return AI01weightDecoder;
}(AI01decoder_1.default));
exports.default = AI01weightDecoder;
//# sourceMappingURL=AI01weightDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var GeneralAppIdDecoder_1 = __webpack_require__(/*! ./GeneralAppIdDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js");
var AbstractExpandedDecoder = /** @class */ (function () {
    function AbstractExpandedDecoder(information) {
        this.information = information;
        this.generalDecoder = new GeneralAppIdDecoder_1.default(information);
    }
    AbstractExpandedDecoder.prototype.getInformation = function () {
        return this.information;
    };
    AbstractExpandedDecoder.prototype.getGeneralDecoder = function () {
        return this.generalDecoder;
    };
    return AbstractExpandedDecoder;
}());
exports.default = AbstractExpandedDecoder;
//# sourceMappingURL=AbstractExpandedDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AbstractExpandedDecoderComplement.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var IllegalStateException_1 = __webpack_require__(/*! ../../../../IllegalStateException */ "./node_modules/@zxing/library/esm5/core/IllegalStateException.js");
var GeneralAppIdDecoder_1 = __webpack_require__(/*! ./GeneralAppIdDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js");
var AI01AndOtherAIs_1 = __webpack_require__(/*! ./AI01AndOtherAIs */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01AndOtherAIs.js");
var AnyAIDecoder_1 = __webpack_require__(/*! ./AnyAIDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AnyAIDecoder.js");
var AI013103decoder_1 = __webpack_require__(/*! ./AI013103decoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI013103decoder.js");
var AI01320xDecoder_1 = __webpack_require__(/*! ./AI01320xDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01320xDecoder.js");
var AI01392xDecoder_1 = __webpack_require__(/*! ./AI01392xDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01392xDecoder.js");
var AI01393xDecoder_1 = __webpack_require__(/*! ./AI01393xDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI01393xDecoder.js");
var AI013x0x1xDecoder_1 = __webpack_require__(/*! ./AI013x0x1xDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AI013x0x1xDecoder.js");
function createDecoder(information) {
    try {
        if (information.get(1)) {
            return new AI01AndOtherAIs_1.default(information);
        }
        if (!information.get(2)) {
            return new AnyAIDecoder_1.default(information);
        }
        var fourBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 4);
        switch (fourBitEncodationMethod) {
            case 4: return new AI013103decoder_1.default(information);
            case 5: return new AI01320xDecoder_1.default(information);
        }
        var fiveBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 5);
        switch (fiveBitEncodationMethod) {
            case 12: return new AI01392xDecoder_1.default(information);
            case 13: return new AI01393xDecoder_1.default(information);
        }
        var sevenBitEncodationMethod = GeneralAppIdDecoder_1.default.extractNumericValueFromBitArray(information, 1, 7);
        switch (sevenBitEncodationMethod) {
            case 56: return new AI013x0x1xDecoder_1.default(information, '310', '11');
            case 57: return new AI013x0x1xDecoder_1.default(information, '320', '11');
            case 58: return new AI013x0x1xDecoder_1.default(information, '310', '13');
            case 59: return new AI013x0x1xDecoder_1.default(information, '320', '13');
            case 60: return new AI013x0x1xDecoder_1.default(information, '310', '15');
            case 61: return new AI013x0x1xDecoder_1.default(information, '320', '15');
            case 62: return new AI013x0x1xDecoder_1.default(information, '310', '17');
            case 63: return new AI013x0x1xDecoder_1.default(information, '320', '17');
        }
    }
    catch (e) {
        console.log(e);
        throw new IllegalStateException_1.default('unknown decoder: ' + information);
    }
}
exports.createDecoder = createDecoder;
//# sourceMappingURL=AbstractExpandedDecoderComplement.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AnyAIDecoder.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AnyAIDecoder.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var AbstractExpandedDecoder_1 = __webpack_require__(/*! ./AbstractExpandedDecoder */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/AbstractExpandedDecoder.js");
var AnyAIDecoder = /** @class */ (function (_super) {
    __extends(AnyAIDecoder, _super);
    function AnyAIDecoder(information) {
        return _super.call(this, information) || this;
    }
    AnyAIDecoder.prototype.parseInformation = function () {
        var buf = new StringBuilder_1.default();
        return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);
    };
    AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;
    return AnyAIDecoder;
}(AbstractExpandedDecoder_1.default));
exports.default = AnyAIDecoder;
//# sourceMappingURL=AnyAIDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/BlockParsedResult.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/BlockParsedResult.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BlockParsedResult = /** @class */ (function () {
    function BlockParsedResult(finished, decodedInformation) {
        if (decodedInformation) {
            this.decodedInformation = null;
        }
        else {
            this.finished = finished;
            this.decodedInformation = decodedInformation;
        }
    }
    BlockParsedResult.prototype.getDecodedInformation = function () {
        return this.decodedInformation;
    };
    BlockParsedResult.prototype.isFinished = function () {
        return this.finished;
    };
    return BlockParsedResult;
}());
exports.default = BlockParsedResult;
//# sourceMappingURL=BlockParsedResult.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedChar.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedChar.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var DecodedObject_1 = __webpack_require__(/*! ./DecodedObject */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedObject.js");
var DecodedChar = /** @class */ (function (_super) {
    __extends(DecodedChar, _super);
    function DecodedChar(newPosition, value) {
        var _this = _super.call(this, newPosition) || this;
        _this.value = value;
        return _this;
    }
    DecodedChar.prototype.getValue = function () {
        return this.value;
    };
    DecodedChar.prototype.isFNC1 = function () {
        return this.value === DecodedChar.FNC1;
    };
    DecodedChar.FNC1 = '$';
    return DecodedChar;
}(DecodedObject_1.default));
exports.default = DecodedChar;
//# sourceMappingURL=DecodedChar.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedInformation.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedInformation.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var DecodedObject_1 = __webpack_require__(/*! ./DecodedObject */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedObject.js");
var DecodedInformation = /** @class */ (function (_super) {
    __extends(DecodedInformation, _super);
    function DecodedInformation(newPosition, newString, remainingValue) {
        var _this = _super.call(this, newPosition) || this;
        if (remainingValue) {
            _this.remaining = true;
            _this.remainingValue = _this.remainingValue;
        }
        else {
            _this.remaining = false;
            _this.remainingValue = 0;
        }
        _this.newString = newString;
        return _this;
    }
    DecodedInformation.prototype.getNewString = function () {
        return this.newString;
    };
    DecodedInformation.prototype.isRemaining = function () {
        return this.remaining;
    };
    DecodedInformation.prototype.getRemainingValue = function () {
        return this.remainingValue;
    };
    return DecodedInformation;
}(DecodedObject_1.default));
exports.default = DecodedInformation;
//# sourceMappingURL=DecodedInformation.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedNumeric.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedNumeric.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var FormatException_1 = __webpack_require__(/*! ../../../../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
var DecodedObject_1 = __webpack_require__(/*! ./DecodedObject */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedObject.js");
var DecodedNumeric = /** @class */ (function (_super) {
    __extends(DecodedNumeric, _super);
    function DecodedNumeric(newPosition, firstDigit, secondDigit) {
        var _this = _super.call(this, newPosition) || this;
        if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {
            throw new FormatException_1.default();
        }
        _this.firstDigit = firstDigit;
        _this.secondDigit = secondDigit;
        return _this;
    }
    DecodedNumeric.prototype.getFirstDigit = function () {
        return this.firstDigit;
    };
    DecodedNumeric.prototype.getSecondDigit = function () {
        return this.secondDigit;
    };
    DecodedNumeric.prototype.getValue = function () {
        return this.firstDigit * 10 + this.secondDigit;
    };
    DecodedNumeric.prototype.isFirstDigitFNC1 = function () {
        return this.firstDigit == DecodedNumeric.FNC1;
    };
    DecodedNumeric.prototype.isSecondDigitFNC1 = function () {
        return this.secondDigit == DecodedNumeric.FNC1;
    };
    DecodedNumeric.prototype.isAnyFNC1 = function () {
        return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;
    };
    DecodedNumeric.FNC1 = 10;
    return DecodedNumeric;
}(DecodedObject_1.default));
exports.default = DecodedNumeric;
//# sourceMappingURL=DecodedNumeric.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedObject.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedObject.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var DecodedObject = /** @class */ (function () {
    function DecodedObject(newPosition) {
        this.newPosition = newPosition;
    }
    DecodedObject.prototype.getNewPosition = function () {
        return this.newPosition;
    };
    return DecodedObject;
}());
exports.default = DecodedObject;
//# sourceMappingURL=DecodedObject.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/FieldParser.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/FieldParser.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var NotFoundException_1 = __webpack_require__(/*! ../../../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
var FieldParser = /** @class */ (function () {
    function FieldParser() {
    }
    FieldParser.parseFieldsInGeneralPurpose = function (rawInformation) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
        if (!rawInformation) {
            return null;
        }
        // Processing 2-digit AIs
        if (rawInformation.length < 2) {
            throw new NotFoundException_1.default();
        }
        var firstTwoDigits = rawInformation.substring(0, 2);
        try {
            for (var _e = __values(FieldParser.TWO_DIGIT_DATA_LENGTH), _f = _e.next(); !_f.done; _f = _e.next()) {
                var dataLength = _f.value;
                if (dataLength[0] === firstTwoDigits) {
                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                        return FieldParser.processVariableAI(2, dataLength[2], rawInformation);
                    }
                    return FieldParser.processFixedAI(2, dataLength[1], rawInformation);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (rawInformation.length < 3) {
            throw new NotFoundException_1.default();
        }
        var firstThreeDigits = rawInformation.substring(0, 3);
        try {
            for (var _g = __values(FieldParser.THREE_DIGIT_DATA_LENGTH), _h = _g.next(); !_h.done; _h = _g.next()) {
                var dataLength = _h.value;
                if (dataLength[0] === firstThreeDigits) {
                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                        return FieldParser.processVariableAI(3, dataLength[2], rawInformation);
                    }
                    return FieldParser.processFixedAI(3, dataLength[1], rawInformation);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
            }
            finally { if (e_2) throw e_2.error; }
        }
        try {
            for (var _j = __values(FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH), _k = _j.next(); !_k.done; _k = _j.next()) {
                var dataLength = _k.value;
                if (dataLength[0] === firstThreeDigits) {
                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
                    }
                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
            }
            finally { if (e_3) throw e_3.error; }
        }
        if (rawInformation.length < 4) {
            throw new NotFoundException_1.default();
        }
        var firstFourDigits = rawInformation.substring(0, 4);
        try {
            for (var _l = __values(FieldParser.FOUR_DIGIT_DATA_LENGTH), _m = _l.next(); !_m.done; _m = _l.next()) {
                var dataLength = _m.value;
                if (dataLength[0] === firstFourDigits) {
                    if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
                        return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
                    }
                    return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
            }
            finally { if (e_4) throw e_4.error; }
        }
        throw new NotFoundException_1.default();
    };
    FieldParser.processFixedAI = function (aiSize, fieldSize, rawInformation) {
        if (rawInformation.length < aiSize) {
            throw new NotFoundException_1.default();
        }
        var ai = rawInformation.substring(0, aiSize);
        if (rawInformation.length < aiSize + fieldSize) {
            throw new NotFoundException_1.default();
        }
        var field = rawInformation.substring(aiSize, aiSize + fieldSize);
        var remaining = rawInformation.substring(aiSize + fieldSize);
        var result = '(' + ai + ')' + field;
        var parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
        return parsedAI == null ? result : result + parsedAI;
    };
    FieldParser.processVariableAI = function (aiSize, variableFieldSize, rawInformation) {
        var ai = rawInformation.substring(0, aiSize);
        var maxSize;
        if (rawInformation.length < aiSize + variableFieldSize) {
            maxSize = rawInformation.length;
        }
        else {
            maxSize = aiSize + variableFieldSize;
        }
        var field = rawInformation.substring(aiSize, maxSize);
        var remaining = rawInformation.substring(maxSize);
        var result = '(' + ai + ')' + field;
        var parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
        return parsedAI == null ? result : result + parsedAI;
    };
    FieldParser.VARIABLE_LENGTH = [];
    FieldParser.TWO_DIGIT_DATA_LENGTH = [
        ["00", 18],
        ["01", 14],
        ["02", 14],
        ["10", FieldParser.VARIABLE_LENGTH, 20],
        ["11", 6],
        ["12", 6],
        ["13", 6],
        ["15", 6],
        ["17", 6],
        ["20", 2],
        ["21", FieldParser.VARIABLE_LENGTH, 20],
        ["22", FieldParser.VARIABLE_LENGTH, 29],
        ["30", FieldParser.VARIABLE_LENGTH, 8],
        ["37", FieldParser.VARIABLE_LENGTH, 8],
        //internal company codes
        ["90", FieldParser.VARIABLE_LENGTH, 30],
        ["91", FieldParser.VARIABLE_LENGTH, 30],
        ["92", FieldParser.VARIABLE_LENGTH, 30],
        ["93", FieldParser.VARIABLE_LENGTH, 30],
        ["94", FieldParser.VARIABLE_LENGTH, 30],
        ["95", FieldParser.VARIABLE_LENGTH, 30],
        ["96", FieldParser.VARIABLE_LENGTH, 30],
        ["97", FieldParser.VARIABLE_LENGTH, 3],
        ["98", FieldParser.VARIABLE_LENGTH, 30],
        ["99", FieldParser.VARIABLE_LENGTH, 30],
    ];
    FieldParser.THREE_DIGIT_DATA_LENGTH = [
        // Same format as above
        ["240", FieldParser.VARIABLE_LENGTH, 30],
        ["241", FieldParser.VARIABLE_LENGTH, 30],
        ["242", FieldParser.VARIABLE_LENGTH, 6],
        ["250", FieldParser.VARIABLE_LENGTH, 30],
        ["251", FieldParser.VARIABLE_LENGTH, 30],
        ["253", FieldParser.VARIABLE_LENGTH, 17],
        ["254", FieldParser.VARIABLE_LENGTH, 20],
        ["400", FieldParser.VARIABLE_LENGTH, 30],
        ["401", FieldParser.VARIABLE_LENGTH, 30],
        ["402", 17],
        ["403", FieldParser.VARIABLE_LENGTH, 30],
        ["410", 13],
        ["411", 13],
        ["412", 13],
        ["413", 13],
        ["414", 13],
        ["420", FieldParser.VARIABLE_LENGTH, 20],
        ["421", FieldParser.VARIABLE_LENGTH, 15],
        ["422", 3],
        ["423", FieldParser.VARIABLE_LENGTH, 15],
        ["424", 3],
        ["425", 3],
        ["426", 3],
    ];
    FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
        // Same format as above
        ["310", 6],
        ["311", 6],
        ["312", 6],
        ["313", 6],
        ["314", 6],
        ["315", 6],
        ["316", 6],
        ["320", 6],
        ["321", 6],
        ["322", 6],
        ["323", 6],
        ["324", 6],
        ["325", 6],
        ["326", 6],
        ["327", 6],
        ["328", 6],
        ["329", 6],
        ["330", 6],
        ["331", 6],
        ["332", 6],
        ["333", 6],
        ["334", 6],
        ["335", 6],
        ["336", 6],
        ["340", 6],
        ["341", 6],
        ["342", 6],
        ["343", 6],
        ["344", 6],
        ["345", 6],
        ["346", 6],
        ["347", 6],
        ["348", 6],
        ["349", 6],
        ["350", 6],
        ["351", 6],
        ["352", 6],
        ["353", 6],
        ["354", 6],
        ["355", 6],
        ["356", 6],
        ["357", 6],
        ["360", 6],
        ["361", 6],
        ["362", 6],
        ["363", 6],
        ["364", 6],
        ["365", 6],
        ["366", 6],
        ["367", 6],
        ["368", 6],
        ["369", 6],
        ["390", FieldParser.VARIABLE_LENGTH, 15],
        ["391", FieldParser.VARIABLE_LENGTH, 18],
        ["392", FieldParser.VARIABLE_LENGTH, 15],
        ["393", FieldParser.VARIABLE_LENGTH, 18],
        ["703", FieldParser.VARIABLE_LENGTH, 30],
    ];
    FieldParser.FOUR_DIGIT_DATA_LENGTH = [
        // Same format as above
        ["7001", 13],
        ["7002", FieldParser.VARIABLE_LENGTH, 30],
        ["7003", 10],
        ["8001", 14],
        ["8002", FieldParser.VARIABLE_LENGTH, 20],
        ["8003", FieldParser.VARIABLE_LENGTH, 30],
        ["8004", FieldParser.VARIABLE_LENGTH, 30],
        ["8005", 6],
        ["8006", 18],
        ["8007", FieldParser.VARIABLE_LENGTH, 30],
        ["8008", FieldParser.VARIABLE_LENGTH, 12],
        ["8018", 18],
        ["8020", FieldParser.VARIABLE_LENGTH, 25],
        ["8100", 6],
        ["8101", 10],
        ["8102", 2],
        ["8110", FieldParser.VARIABLE_LENGTH, 70],
        ["8200", FieldParser.VARIABLE_LENGTH, 70],
    ];
    return FieldParser;
}());
exports.default = FieldParser;
//# sourceMappingURL=FieldParser.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/GeneralAppIdDecoder.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var FormatException_1 = __webpack_require__(/*! ../../../../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
var IllegalStateException_1 = __webpack_require__(/*! ../../../../IllegalStateException */ "./node_modules/@zxing/library/esm5/core/IllegalStateException.js");
var StringBuilder_1 = __webpack_require__(/*! ../../../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var DecodedChar_1 = __webpack_require__(/*! ./DecodedChar */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedChar.js");
var DecodedNumeric_1 = __webpack_require__(/*! ./DecodedNumeric */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedNumeric.js");
var DecodedInformation_1 = __webpack_require__(/*! ./DecodedInformation */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/DecodedInformation.js");
var FieldParser_1 = __webpack_require__(/*! ./FieldParser */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/FieldParser.js");
var BlockParsedResult_1 = __webpack_require__(/*! ./BlockParsedResult */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/decoders/BlockParsedResult.js");
var GeneralAppIdDecoder = /** @class */ (function () {
    function GeneralAppIdDecoder(information) {
        this.buffer = new StringBuilder_1.default();
        this.information = information;
    }
    GeneralAppIdDecoder.prototype.decodeAllCodes = function (buff, initialPosition) {
        var currentPosition = initialPosition;
        var remaining = null;
        do {
            var info = this.decodeGeneralPurposeField(currentPosition, remaining);
            var parsedFields = FieldParser_1.default.parseFieldsInGeneralPurpose(info.getNewString());
            if (parsedFields != null) {
                buff.append(parsedFields);
            }
            if (info.isRemaining()) {
                remaining = "" + info.getRemainingValue();
            }
            else {
                remaining = null;
            }
            if (currentPosition == info.getNewPosition()) { // No step forward!
                break;
            }
            currentPosition = info.getNewPosition();
        } while (true);
        return buff.toString();
    };
    GeneralAppIdDecoder.prototype.isStillNumeric = function (pos) {
        // It's numeric if it still has 7 positions
        // and one of the first 4 bits is "1".
        if (pos + 7 > this.information.getSize()) {
            return pos + 4 <= this.information.getSize();
        }
        for (var i = pos; i < pos + 3; ++i) {
            if (this.information.get(i)) {
                return true;
            }
        }
        return this.information.get(pos + 3);
    };
    GeneralAppIdDecoder.prototype.decodeNumeric = function (pos) {
        if (pos + 7 > this.information.getSize()) {
            var numeric_1 = this.extractNumericValueFromBitArray(pos, 4);
            if (numeric_1 == 0) {
                return new DecodedNumeric_1.default(this.information.getSize(), DecodedNumeric_1.default.FNC1, DecodedNumeric_1.default.FNC1);
            }
            return new DecodedNumeric_1.default(this.information.getSize(), numeric_1 - 1, DecodedNumeric_1.default.FNC1);
        }
        var numeric = this.extractNumericValueFromBitArray(pos, 7);
        var digit1 = (numeric - 8) / 11;
        var digit2 = (numeric - 8) % 11;
        return new DecodedNumeric_1.default(pos + 7, digit1, digit2);
    };
    GeneralAppIdDecoder.prototype.extractNumericValueFromBitArray = function (pos, bits) {
        return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits);
    };
    GeneralAppIdDecoder.extractNumericValueFromBitArray = function (information, pos, bits) {
        var value = 0;
        for (var i = 0; i < bits; ++i) {
            if (information.get(pos + i)) {
                value |= 1 << (bits - i - 1);
            }
        }
        return value;
    };
    GeneralAppIdDecoder.prototype.decodeGeneralPurposeField = function (pos, remaining) {
        //this.buffer.setLength(0);
        this.buffer.setLengthToZero();
        if (remaining != null) {
            this.buffer.append(remaining);
        }
        this.current.setPosition(pos);
        var lastDecoded = this.parseBlocks();
        if (lastDecoded != null && lastDecoded.isRemaining()) {
            return new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());
        }
        return new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());
    };
    GeneralAppIdDecoder.prototype.parseBlocks = function () {
        var isFinished;
        var result;
        do {
            var initialPosition = this.current.getPosition();
            if (this.current.isAlpha()) {
                result = this.parseAlphaBlock();
                isFinished = result.isFinished();
            }
            else if (this.current.isIsoIec646()) {
                result = this.parseIsoIec646Block();
                isFinished = result.isFinished();
            }
            else { // it must be numeric
                result = this.parseNumericBlock();
                isFinished = result.isFinished();
            }
            var positionChanged = initialPosition != this.current.getPosition();
            if (!positionChanged && !isFinished) {
                break;
            }
        } while (!isFinished);
        return result.getDecodedInformation();
    };
    GeneralAppIdDecoder.prototype.parseNumericBlock = function () {
        while (this.isStillNumeric(this.current.getPosition())) {
            var numeric = this.decodeNumeric(this.current.getPosition());
            this.current.setPosition(numeric.getNewPosition());
            if (numeric.isFirstDigitFNC1()) {
                var information = void 0;
                if (numeric.isSecondDigitFNC1()) {
                    information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());
                }
                else {
                    information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());
                }
                return new BlockParsedResult_1.default(true, information);
            }
            this.buffer.append(numeric.getFirstDigit());
            if (numeric.isSecondDigitFNC1()) {
                var information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());
                return new BlockParsedResult_1.default(true, information);
            }
            this.buffer.append(numeric.getSecondDigit());
        }
        if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {
            this.current.setAlpha();
            this.current.incrementPosition(4);
        }
        return new BlockParsedResult_1.default(false);
    };
    GeneralAppIdDecoder.prototype.parseIsoIec646Block = function () {
        while (this.isStillIsoIec646(this.current.getPosition())) {
            var iso = this.decodeIsoIec646(this.current.getPosition());
            this.current.setPosition(iso.getNewPosition());
            if (iso.isFNC1()) {
                var information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());
                return new BlockParsedResult_1.default(true, information);
            }
            this.buffer.append(iso.getValue());
        }
        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
            this.current.incrementPosition(3);
            this.current.setNumeric();
        }
        else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
            if (this.current.getPosition() + 5 < this.information.getSize()) {
                this.current.incrementPosition(5);
            }
            else {
                this.current.setPosition(this.information.getSize());
            }
            this.current.setAlpha();
        }
        return new BlockParsedResult_1.default(false);
    };
    GeneralAppIdDecoder.prototype.parseAlphaBlock = function () {
        while (this.isStillAlpha(this.current.getPosition())) {
            var alpha = this.decodeAlphanumeric(this.current.getPosition());
            this.current.setPosition(alpha.getNewPosition());
            if (alpha.isFNC1()) {
                var information = new DecodedInformation_1.default(this.current.getPosition(), this.buffer.toString());
                return new BlockParsedResult_1.default(true, information); //end of the char block
            }
            this.buffer.append(alpha.getValue());
        }
        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
            this.current.incrementPosition(3);
            this.current.setNumeric();
        }
        else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
            if (this.current.getPosition() + 5 < this.information.getSize()) {
                this.current.incrementPosition(5);
            }
            else {
                this.current.setPosition(this.information.getSize());
            }
            this.current.setIsoIec646();
        }
        return new BlockParsedResult_1.default(false);
    };
    GeneralAppIdDecoder.prototype.isStillIsoIec646 = function (pos) {
        if (pos + 5 > this.information.getSize()) {
            return false;
        }
        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue >= 5 && fiveBitValue < 16) {
            return true;
        }
        if (pos + 7 > this.information.getSize()) {
            return false;
        }
        var sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
        if (sevenBitValue >= 64 && sevenBitValue < 116) {
            return true;
        }
        if (pos + 8 > this.information.getSize()) {
            return false;
        }
        var eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
        return eightBitValue >= 232 && eightBitValue < 253;
    };
    GeneralAppIdDecoder.prototype.decodeIsoIec646 = function (pos) {
        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue == 15) {
            return new DecodedChar_1.default(pos + 5, DecodedChar_1.default.FNC1);
        }
        if (fiveBitValue >= 5 && fiveBitValue < 15) {
            return new DecodedChar_1.default(pos + 5, ('0' + (fiveBitValue - 5)));
        }
        var sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
        if (sevenBitValue >= 64 && sevenBitValue < 90) {
            return new DecodedChar_1.default(pos + 7, ("" + (sevenBitValue + 1)));
        }
        if (sevenBitValue >= 90 && sevenBitValue < 116) {
            return new DecodedChar_1.default(pos + 7, ("" + (sevenBitValue + 7)));
        }
        var eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
        var c;
        switch (eightBitValue) {
            case 232:
                c = '!';
                break;
            case 233:
                c = '"';
                break;
            case 234:
                c = '%';
                break;
            case 235:
                c = '&';
                break;
            case 236:
                c = '\'';
                break;
            case 237:
                c = '(';
                break;
            case 238:
                c = ')';
                break;
            case 239:
                c = '*';
                break;
            case 240:
                c = '+';
                break;
            case 241:
                c = ',';
                break;
            case 242:
                c = '-';
                break;
            case 243:
                c = '.';
                break;
            case 244:
                c = '/';
                break;
            case 245:
                c = ':';
                break;
            case 246:
                c = ';';
                break;
            case 247:
                c = '<';
                break;
            case 248:
                c = '=';
                break;
            case 249:
                c = '>';
                break;
            case 250:
                c = '?';
                break;
            case 251:
                c = '_';
                break;
            case 252:
                c = ' ';
                break;
            default:
                throw new FormatException_1.default();
        }
        return new DecodedChar_1.default(pos + 8, c);
    };
    GeneralAppIdDecoder.prototype.isStillAlpha = function (pos) {
        if (pos + 5 > this.information.getSize()) {
            return false;
        }
        // We now check if it's a valid 5-bit value (0..9 and FNC1)
        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue >= 5 && fiveBitValue < 16) {
            return true;
        }
        if (pos + 6 > this.information.getSize()) {
            return false;
        }
        var sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
        return sixBitValue >= 16 && sixBitValue < 63; // 63 not included
    };
    GeneralAppIdDecoder.prototype.decodeAlphanumeric = function (pos) {
        var fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue == 15) {
            return new DecodedChar_1.default(pos + 5, DecodedChar_1.default.FNC1);
        }
        if (fiveBitValue >= 5 && fiveBitValue < 15) {
            return new DecodedChar_1.default(pos + 5, ('0' + (fiveBitValue - 5)));
        }
        var sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
        if (sixBitValue >= 32 && sixBitValue < 58) {
            return new DecodedChar_1.default(pos + 6, ('' + (sixBitValue + 33)));
        }
        var c;
        switch (sixBitValue) {
            case 58:
                c = '*';
                break;
            case 59:
                c = ',';
                break;
            case 60:
                c = '-';
                break;
            case 61:
                c = '.';
                break;
            case 62:
                c = '/';
                break;
            default:
                throw new IllegalStateException_1.default("Decoding invalid alphanumeric value: " + sixBitValue);
        }
        return new DecodedChar_1.default(pos + 6, c);
    };
    GeneralAppIdDecoder.prototype.isAlphaTo646ToAlphaLatch = function (pos) {
        if (pos + 1 > this.information.getSize()) {
            return false;
        }
        for (var i = 0; i < 5 && i + pos < this.information.getSize(); ++i) {
            if (i == 2) {
                if (!this.information.get(pos + 2)) {
                    return false;
                }
            }
            else if (this.information.get(pos + i)) {
                return false;
            }
        }
        return true;
    };
    GeneralAppIdDecoder.prototype.isAlphaOr646ToNumericLatch = function (pos) {
        // Next is alphanumeric if there are 3 positions and they are all zeros
        if (pos + 3 > this.information.getSize()) {
            return false;
        }
        for (var i = pos; i < pos + 3; ++i) {
            if (this.information.get(i)) {
                return false;
            }
        }
        return true;
    };
    GeneralAppIdDecoder.prototype.isNumericToAlphaNumericLatch = function (pos) {
        // Next is alphanumeric if there are 4 positions and they are all zeros, or
        // if there is a subset of this just before the end of the symbol
        if (pos + 1 > this.information.getSize()) {
            return false;
        }
        for (var i = 0; i < 4 && i + pos < this.information.getSize(); ++i) {
            if (this.information.get(pos + i)) {
                return false;
            }
        }
        return true;
    };
    return GeneralAppIdDecoder;
}());
exports.default = GeneralAppIdDecoder;
//# sourceMappingURL=GeneralAppIdDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417Common.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/PDF417Common.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
* Copyright 2009 ZXing authors
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
// package com.google.zxing.pdf417;
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// import java.util.Arrays;
var Arrays_1 = __webpack_require__(/*! ../util/Arrays */ "./node_modules/@zxing/library/esm5/core/util/Arrays.js");
// import java.util.Collection;
// import com.google.zxing.common.detector.MathUtils;
var MathUtils_1 = __webpack_require__(/*! ../common/detector/MathUtils */ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js");
/**
 * @author SITA Lab (kevin.osullivan@sita.aero)
 * @author Guenther Grau
 */
var PDF417Common = /** @class */ (function () {
    function PDF417Common() {
    }
    PDF417Common.prototype.PDF417Common = function () {
    };
    /**
     * @param moduleBitCount values to sum
     * @return sum of values
     * @deprecated call {@link MathUtils#sum(int[])}
     */
    // @Deprecated
    PDF417Common.getBitCountSum = function (moduleBitCount) {
        return MathUtils_1.default.sum(moduleBitCount);
    };
    PDF417Common.toIntArray = function (list) {
        var e_1, _a;
        if (list == null || !list.length) {
            return PDF417Common.EMPTY_INT_ARRAY;
        }
        var result = new Int32Array(list.length);
        var i = 0;
        try {
            for (var list_1 = __values(list), list_1_1 = list_1.next(); !list_1_1.done; list_1_1 = list_1.next()) {
                var integer = list_1_1.value;
                result[i++] = integer;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (list_1_1 && !list_1_1.done && (_a = list_1.return)) _a.call(list_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    };
    /**
     * @param symbol encoded symbol to translate to a codeword
     * @return the codeword corresponding to the symbol.
     */
    PDF417Common.getCodeword = function (symbol /*int*/) {
        var i = Arrays_1.default.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 0x3FFFF);
        if (i < 0) {
            return -1;
        }
        return (PDF417Common.CODEWORD_TABLE[i] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;
    };
    PDF417Common.NUMBER_OF_CODEWORDS = 929;
    // Maximum Codewords (Data + Error).
    PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;
    PDF417Common.MIN_ROWS_IN_BARCODE = 3;
    PDF417Common.MAX_ROWS_IN_BARCODE = 90;
    // One left row indication column + max 30 data columns + one right row indicator column
    // public static /*final*/ MAX_CODEWORDS_IN_ROW: /*int*/ number = 32;
    PDF417Common.MODULES_IN_CODEWORD = 17;
    PDF417Common.MODULES_IN_STOP_PATTERN = 18;
    PDF417Common.BARS_IN_MODULE = 8;
    PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);
    /**
     * The sorted table of all possible symbols. Extracted from the PDF417
     * specification. The index of a symbol in this table corresponds to the
     * index into the codeword table.
     */
    PDF417Common.SYMBOL_TABLE = Int32Array.from([
        0x1025e, 0x1027a, 0x1029e, 0x102bc, 0x102f2, 0x102f4, 0x1032e, 0x1034e, 0x1035c, 0x10396, 0x103a6, 0x103ac,
        0x10422, 0x10428, 0x10436, 0x10442, 0x10444, 0x10448, 0x10450, 0x1045e, 0x10466, 0x1046c, 0x1047a, 0x10482,
        0x1049e, 0x104a0, 0x104bc, 0x104c6, 0x104d8, 0x104ee, 0x104f2, 0x104f4, 0x10504, 0x10508, 0x10510, 0x1051e,
        0x10520, 0x1053c, 0x10540, 0x10578, 0x10586, 0x1058c, 0x10598, 0x105b0, 0x105be, 0x105ce, 0x105dc, 0x105e2,
        0x105e4, 0x105e8, 0x105f6, 0x1062e, 0x1064e, 0x1065c, 0x1068e, 0x1069c, 0x106b8, 0x106de, 0x106fa, 0x10716,
        0x10726, 0x1072c, 0x10746, 0x1074c, 0x10758, 0x1076e, 0x10792, 0x10794, 0x107a2, 0x107a4, 0x107a8, 0x107b6,
        0x10822, 0x10828, 0x10842, 0x10848, 0x10850, 0x1085e, 0x10866, 0x1086c, 0x1087a, 0x10882, 0x10884, 0x10890,
        0x1089e, 0x108a0, 0x108bc, 0x108c6, 0x108cc, 0x108d8, 0x108ee, 0x108f2, 0x108f4, 0x10902, 0x10908, 0x1091e,
        0x10920, 0x1093c, 0x10940, 0x10978, 0x10986, 0x10998, 0x109b0, 0x109be, 0x109ce, 0x109dc, 0x109e2, 0x109e4,
        0x109e8, 0x109f6, 0x10a08, 0x10a10, 0x10a1e, 0x10a20, 0x10a3c, 0x10a40, 0x10a78, 0x10af0, 0x10b06, 0x10b0c,
        0x10b18, 0x10b30, 0x10b3e, 0x10b60, 0x10b7c, 0x10b8e, 0x10b9c, 0x10bb8, 0x10bc2, 0x10bc4, 0x10bc8, 0x10bd0,
        0x10bde, 0x10be6, 0x10bec, 0x10c2e, 0x10c4e, 0x10c5c, 0x10c62, 0x10c64, 0x10c68, 0x10c76, 0x10c8e, 0x10c9c,
        0x10cb8, 0x10cc2, 0x10cc4, 0x10cc8, 0x10cd0, 0x10cde, 0x10ce6, 0x10cec, 0x10cfa, 0x10d0e, 0x10d1c, 0x10d38,
        0x10d70, 0x10d7e, 0x10d82, 0x10d84, 0x10d88, 0x10d90, 0x10d9e, 0x10da0, 0x10dbc, 0x10dc6, 0x10dcc, 0x10dd8,
        0x10dee, 0x10df2, 0x10df4, 0x10e16, 0x10e26, 0x10e2c, 0x10e46, 0x10e58, 0x10e6e, 0x10e86, 0x10e8c, 0x10e98,
        0x10eb0, 0x10ebe, 0x10ece, 0x10edc, 0x10f0a, 0x10f12, 0x10f14, 0x10f22, 0x10f28, 0x10f36, 0x10f42, 0x10f44,
        0x10f48, 0x10f50, 0x10f5e, 0x10f66, 0x10f6c, 0x10fb2, 0x10fb4, 0x11022, 0x11028, 0x11042, 0x11048, 0x11050,
        0x1105e, 0x1107a, 0x11082, 0x11084, 0x11090, 0x1109e, 0x110a0, 0x110bc, 0x110c6, 0x110cc, 0x110d8, 0x110ee,
        0x110f2, 0x110f4, 0x11102, 0x1111e, 0x11120, 0x1113c, 0x11140, 0x11178, 0x11186, 0x11198, 0x111b0, 0x111be,
        0x111ce, 0x111dc, 0x111e2, 0x111e4, 0x111e8, 0x111f6, 0x11208, 0x1121e, 0x11220, 0x11278, 0x112f0, 0x1130c,
        0x11330, 0x1133e, 0x11360, 0x1137c, 0x1138e, 0x1139c, 0x113b8, 0x113c2, 0x113c8, 0x113d0, 0x113de, 0x113e6,
        0x113ec, 0x11408, 0x11410, 0x1141e, 0x11420, 0x1143c, 0x11440, 0x11478, 0x114f0, 0x115e0, 0x1160c, 0x11618,
        0x11630, 0x1163e, 0x11660, 0x1167c, 0x116c0, 0x116f8, 0x1171c, 0x11738, 0x11770, 0x1177e, 0x11782, 0x11784,
        0x11788, 0x11790, 0x1179e, 0x117a0, 0x117bc, 0x117c6, 0x117cc, 0x117d8, 0x117ee, 0x1182e, 0x11834, 0x1184e,
        0x1185c, 0x11862, 0x11864, 0x11868, 0x11876, 0x1188e, 0x1189c, 0x118b8, 0x118c2, 0x118c8, 0x118d0, 0x118de,
        0x118e6, 0x118ec, 0x118fa, 0x1190e, 0x1191c, 0x11938, 0x11970, 0x1197e, 0x11982, 0x11984, 0x11990, 0x1199e,
        0x119a0, 0x119bc, 0x119c6, 0x119cc, 0x119d8, 0x119ee, 0x119f2, 0x119f4, 0x11a0e, 0x11a1c, 0x11a38, 0x11a70,
        0x11a7e, 0x11ae0, 0x11afc, 0x11b08, 0x11b10, 0x11b1e, 0x11b20, 0x11b3c, 0x11b40, 0x11b78, 0x11b8c, 0x11b98,
        0x11bb0, 0x11bbe, 0x11bce, 0x11bdc, 0x11be2, 0x11be4, 0x11be8, 0x11bf6, 0x11c16, 0x11c26, 0x11c2c, 0x11c46,
        0x11c4c, 0x11c58, 0x11c6e, 0x11c86, 0x11c98, 0x11cb0, 0x11cbe, 0x11cce, 0x11cdc, 0x11ce2, 0x11ce4, 0x11ce8,
        0x11cf6, 0x11d06, 0x11d0c, 0x11d18, 0x11d30, 0x11d3e, 0x11d60, 0x11d7c, 0x11d8e, 0x11d9c, 0x11db8, 0x11dc4,
        0x11dc8, 0x11dd0, 0x11dde, 0x11de6, 0x11dec, 0x11dfa, 0x11e0a, 0x11e12, 0x11e14, 0x11e22, 0x11e24, 0x11e28,
        0x11e36, 0x11e42, 0x11e44, 0x11e50, 0x11e5e, 0x11e66, 0x11e6c, 0x11e82, 0x11e84, 0x11e88, 0x11e90, 0x11e9e,
        0x11ea0, 0x11ebc, 0x11ec6, 0x11ecc, 0x11ed8, 0x11eee, 0x11f1a, 0x11f2e, 0x11f32, 0x11f34, 0x11f4e, 0x11f5c,
        0x11f62, 0x11f64, 0x11f68, 0x11f76, 0x12048, 0x1205e, 0x12082, 0x12084, 0x12090, 0x1209e, 0x120a0, 0x120bc,
        0x120d8, 0x120f2, 0x120f4, 0x12108, 0x1211e, 0x12120, 0x1213c, 0x12140, 0x12178, 0x12186, 0x12198, 0x121b0,
        0x121be, 0x121e2, 0x121e4, 0x121e8, 0x121f6, 0x12204, 0x12210, 0x1221e, 0x12220, 0x12278, 0x122f0, 0x12306,
        0x1230c, 0x12330, 0x1233e, 0x12360, 0x1237c, 0x1238e, 0x1239c, 0x123b8, 0x123c2, 0x123c8, 0x123d0, 0x123e6,
        0x123ec, 0x1241e, 0x12420, 0x1243c, 0x124f0, 0x125e0, 0x12618, 0x1263e, 0x12660, 0x1267c, 0x126c0, 0x126f8,
        0x12738, 0x12770, 0x1277e, 0x12782, 0x12784, 0x12790, 0x1279e, 0x127a0, 0x127bc, 0x127c6, 0x127cc, 0x127d8,
        0x127ee, 0x12820, 0x1283c, 0x12840, 0x12878, 0x128f0, 0x129e0, 0x12bc0, 0x12c18, 0x12c30, 0x12c3e, 0x12c60,
        0x12c7c, 0x12cc0, 0x12cf8, 0x12df0, 0x12e1c, 0x12e38, 0x12e70, 0x12e7e, 0x12ee0, 0x12efc, 0x12f04, 0x12f08,
        0x12f10, 0x12f20, 0x12f3c, 0x12f40, 0x12f78, 0x12f86, 0x12f8c, 0x12f98, 0x12fb0, 0x12fbe, 0x12fce, 0x12fdc,
        0x1302e, 0x1304e, 0x1305c, 0x13062, 0x13068, 0x1308e, 0x1309c, 0x130b8, 0x130c2, 0x130c8, 0x130d0, 0x130de,
        0x130ec, 0x130fa, 0x1310e, 0x13138, 0x13170, 0x1317e, 0x13182, 0x13184, 0x13190, 0x1319e, 0x131a0, 0x131bc,
        0x131c6, 0x131cc, 0x131d8, 0x131f2, 0x131f4, 0x1320e, 0x1321c, 0x13270, 0x1327e, 0x132e0, 0x132fc, 0x13308,
        0x1331e, 0x13320, 0x1333c, 0x13340, 0x13378, 0x13386, 0x13398, 0x133b0, 0x133be, 0x133ce, 0x133dc, 0x133e2,
        0x133e4, 0x133e8, 0x133f6, 0x1340e, 0x1341c, 0x13438, 0x13470, 0x1347e, 0x134e0, 0x134fc, 0x135c0, 0x135f8,
        0x13608, 0x13610, 0x1361e, 0x13620, 0x1363c, 0x13640, 0x13678, 0x136f0, 0x1370c, 0x13718, 0x13730, 0x1373e,
        0x13760, 0x1377c, 0x1379c, 0x137b8, 0x137c2, 0x137c4, 0x137c8, 0x137d0, 0x137de, 0x137e6, 0x137ec, 0x13816,
        0x13826, 0x1382c, 0x13846, 0x1384c, 0x13858, 0x1386e, 0x13874, 0x13886, 0x13898, 0x138b0, 0x138be, 0x138ce,
        0x138dc, 0x138e2, 0x138e4, 0x138e8, 0x13906, 0x1390c, 0x13930, 0x1393e, 0x13960, 0x1397c, 0x1398e, 0x1399c,
        0x139b8, 0x139c8, 0x139d0, 0x139de, 0x139e6, 0x139ec, 0x139fa, 0x13a06, 0x13a0c, 0x13a18, 0x13a30, 0x13a3e,
        0x13a60, 0x13a7c, 0x13ac0, 0x13af8, 0x13b0e, 0x13b1c, 0x13b38, 0x13b70, 0x13b7e, 0x13b88, 0x13b90, 0x13b9e,
        0x13ba0, 0x13bbc, 0x13bcc, 0x13bd8, 0x13bee, 0x13bf2, 0x13bf4, 0x13c12, 0x13c14, 0x13c22, 0x13c24, 0x13c28,
        0x13c36, 0x13c42, 0x13c48, 0x13c50, 0x13c5e, 0x13c66, 0x13c6c, 0x13c82, 0x13c84, 0x13c90, 0x13c9e, 0x13ca0,
        0x13cbc, 0x13cc6, 0x13ccc, 0x13cd8, 0x13cee, 0x13d02, 0x13d04, 0x13d08, 0x13d10, 0x13d1e, 0x13d20, 0x13d3c,
        0x13d40, 0x13d78, 0x13d86, 0x13d8c, 0x13d98, 0x13db0, 0x13dbe, 0x13dce, 0x13ddc, 0x13de4, 0x13de8, 0x13df6,
        0x13e1a, 0x13e2e, 0x13e32, 0x13e34, 0x13e4e, 0x13e5c, 0x13e62, 0x13e64, 0x13e68, 0x13e76, 0x13e8e, 0x13e9c,
        0x13eb8, 0x13ec2, 0x13ec4, 0x13ec8, 0x13ed0, 0x13ede, 0x13ee6, 0x13eec, 0x13f26, 0x13f2c, 0x13f3a, 0x13f46,
        0x13f4c, 0x13f58, 0x13f6e, 0x13f72, 0x13f74, 0x14082, 0x1409e, 0x140a0, 0x140bc, 0x14104, 0x14108, 0x14110,
        0x1411e, 0x14120, 0x1413c, 0x14140, 0x14178, 0x1418c, 0x14198, 0x141b0, 0x141be, 0x141e2, 0x141e4, 0x141e8,
        0x14208, 0x14210, 0x1421e, 0x14220, 0x1423c, 0x14240, 0x14278, 0x142f0, 0x14306, 0x1430c, 0x14318, 0x14330,
        0x1433e, 0x14360, 0x1437c, 0x1438e, 0x143c2, 0x143c4, 0x143c8, 0x143d0, 0x143e6, 0x143ec, 0x14408, 0x14410,
        0x1441e, 0x14420, 0x1443c, 0x14440, 0x14478, 0x144f0, 0x145e0, 0x1460c, 0x14618, 0x14630, 0x1463e, 0x14660,
        0x1467c, 0x146c0, 0x146f8, 0x1471c, 0x14738, 0x14770, 0x1477e, 0x14782, 0x14784, 0x14788, 0x14790, 0x147a0,
        0x147bc, 0x147c6, 0x147cc, 0x147d8, 0x147ee, 0x14810, 0x14820, 0x1483c, 0x14840, 0x14878, 0x148f0, 0x149e0,
        0x14bc0, 0x14c30, 0x14c3e, 0x14c60, 0x14c7c, 0x14cc0, 0x14cf8, 0x14df0, 0x14e38, 0x14e70, 0x14e7e, 0x14ee0,
        0x14efc, 0x14f04, 0x14f08, 0x14f10, 0x14f1e, 0x14f20, 0x14f3c, 0x14f40, 0x14f78, 0x14f86, 0x14f8c, 0x14f98,
        0x14fb0, 0x14fce, 0x14fdc, 0x15020, 0x15040, 0x15078, 0x150f0, 0x151e0, 0x153c0, 0x15860, 0x1587c, 0x158c0,
        0x158f8, 0x159f0, 0x15be0, 0x15c70, 0x15c7e, 0x15ce0, 0x15cfc, 0x15dc0, 0x15df8, 0x15e08, 0x15e10, 0x15e20,
        0x15e40, 0x15e78, 0x15ef0, 0x15f0c, 0x15f18, 0x15f30, 0x15f60, 0x15f7c, 0x15f8e, 0x15f9c, 0x15fb8, 0x1604e,
        0x1605c, 0x1608e, 0x1609c, 0x160b8, 0x160c2, 0x160c4, 0x160c8, 0x160de, 0x1610e, 0x1611c, 0x16138, 0x16170,
        0x1617e, 0x16184, 0x16188, 0x16190, 0x1619e, 0x161a0, 0x161bc, 0x161c6, 0x161cc, 0x161d8, 0x161f2, 0x161f4,
        0x1620e, 0x1621c, 0x16238, 0x16270, 0x1627e, 0x162e0, 0x162fc, 0x16304, 0x16308, 0x16310, 0x1631e, 0x16320,
        0x1633c, 0x16340, 0x16378, 0x16386, 0x1638c, 0x16398, 0x163b0, 0x163be, 0x163ce, 0x163dc, 0x163e2, 0x163e4,
        0x163e8, 0x163f6, 0x1640e, 0x1641c, 0x16438, 0x16470, 0x1647e, 0x164e0, 0x164fc, 0x165c0, 0x165f8, 0x16610,
        0x1661e, 0x16620, 0x1663c, 0x16640, 0x16678, 0x166f0, 0x16718, 0x16730, 0x1673e, 0x16760, 0x1677c, 0x1678e,
        0x1679c, 0x167b8, 0x167c2, 0x167c4, 0x167c8, 0x167d0, 0x167de, 0x167e6, 0x167ec, 0x1681c, 0x16838, 0x16870,
        0x168e0, 0x168fc, 0x169c0, 0x169f8, 0x16bf0, 0x16c10, 0x16c1e, 0x16c20, 0x16c3c, 0x16c40, 0x16c78, 0x16cf0,
        0x16de0, 0x16e18, 0x16e30, 0x16e3e, 0x16e60, 0x16e7c, 0x16ec0, 0x16ef8, 0x16f1c, 0x16f38, 0x16f70, 0x16f7e,
        0x16f84, 0x16f88, 0x16f90, 0x16f9e, 0x16fa0, 0x16fbc, 0x16fc6, 0x16fcc, 0x16fd8, 0x17026, 0x1702c, 0x17046,
        0x1704c, 0x17058, 0x1706e, 0x17086, 0x1708c, 0x17098, 0x170b0, 0x170be, 0x170ce, 0x170dc, 0x170e8, 0x17106,
        0x1710c, 0x17118, 0x17130, 0x1713e, 0x17160, 0x1717c, 0x1718e, 0x1719c, 0x171b8, 0x171c2, 0x171c4, 0x171c8,
        0x171d0, 0x171de, 0x171e6, 0x171ec, 0x171fa, 0x17206, 0x1720c, 0x17218, 0x17230, 0x1723e, 0x17260, 0x1727c,
        0x172c0, 0x172f8, 0x1730e, 0x1731c, 0x17338, 0x17370, 0x1737e, 0x17388, 0x17390, 0x1739e, 0x173a0, 0x173bc,
        0x173cc, 0x173d8, 0x173ee, 0x173f2, 0x173f4, 0x1740c, 0x17418, 0x17430, 0x1743e, 0x17460, 0x1747c, 0x174c0,
        0x174f8, 0x175f0, 0x1760e, 0x1761c, 0x17638, 0x17670, 0x1767e, 0x176e0, 0x176fc, 0x17708, 0x17710, 0x1771e,
        0x17720, 0x1773c, 0x17740, 0x17778, 0x17798, 0x177b0, 0x177be, 0x177dc, 0x177e2, 0x177e4, 0x177e8, 0x17822,
        0x17824, 0x17828, 0x17836, 0x17842, 0x17844, 0x17848, 0x17850, 0x1785e, 0x17866, 0x1786c, 0x17882, 0x17884,
        0x17888, 0x17890, 0x1789e, 0x178a0, 0x178bc, 0x178c6, 0x178cc, 0x178d8, 0x178ee, 0x178f2, 0x178f4, 0x17902,
        0x17904, 0x17908, 0x17910, 0x1791e, 0x17920, 0x1793c, 0x17940, 0x17978, 0x17986, 0x1798c, 0x17998, 0x179b0,
        0x179be, 0x179ce, 0x179dc, 0x179e2, 0x179e4, 0x179e8, 0x179f6, 0x17a04, 0x17a08, 0x17a10, 0x17a1e, 0x17a20,
        0x17a3c, 0x17a40, 0x17a78, 0x17af0, 0x17b06, 0x17b0c, 0x17b18, 0x17b30, 0x17b3e, 0x17b60, 0x17b7c, 0x17b8e,
        0x17b9c, 0x17bb8, 0x17bc4, 0x17bc8, 0x17bd0, 0x17bde, 0x17be6, 0x17bec, 0x17c2e, 0x17c32, 0x17c34, 0x17c4e,
        0x17c5c, 0x17c62, 0x17c64, 0x17c68, 0x17c76, 0x17c8e, 0x17c9c, 0x17cb8, 0x17cc2, 0x17cc4, 0x17cc8, 0x17cd0,
        0x17cde, 0x17ce6, 0x17cec, 0x17d0e, 0x17d1c, 0x17d38, 0x17d70, 0x17d82, 0x17d84, 0x17d88, 0x17d90, 0x17d9e,
        0x17da0, 0x17dbc, 0x17dc6, 0x17dcc, 0x17dd8, 0x17dee, 0x17e26, 0x17e2c, 0x17e3a, 0x17e46, 0x17e4c, 0x17e58,
        0x17e6e, 0x17e72, 0x17e74, 0x17e86, 0x17e8c, 0x17e98, 0x17eb0, 0x17ece, 0x17edc, 0x17ee2, 0x17ee4, 0x17ee8,
        0x17ef6, 0x1813a, 0x18172, 0x18174, 0x18216, 0x18226, 0x1823a, 0x1824c, 0x18258, 0x1826e, 0x18272, 0x18274,
        0x18298, 0x182be, 0x182e2, 0x182e4, 0x182e8, 0x182f6, 0x1835e, 0x1837a, 0x183ae, 0x183d6, 0x18416, 0x18426,
        0x1842c, 0x1843a, 0x18446, 0x18458, 0x1846e, 0x18472, 0x18474, 0x18486, 0x184b0, 0x184be, 0x184ce, 0x184dc,
        0x184e2, 0x184e4, 0x184e8, 0x184f6, 0x18506, 0x1850c, 0x18518, 0x18530, 0x1853e, 0x18560, 0x1857c, 0x1858e,
        0x1859c, 0x185b8, 0x185c2, 0x185c4, 0x185c8, 0x185d0, 0x185de, 0x185e6, 0x185ec, 0x185fa, 0x18612, 0x18614,
        0x18622, 0x18628, 0x18636, 0x18642, 0x18650, 0x1865e, 0x1867a, 0x18682, 0x18684, 0x18688, 0x18690, 0x1869e,
        0x186a0, 0x186bc, 0x186c6, 0x186cc, 0x186d8, 0x186ee, 0x186f2, 0x186f4, 0x1872e, 0x1874e, 0x1875c, 0x18796,
        0x187a6, 0x187ac, 0x187d2, 0x187d4, 0x18826, 0x1882c, 0x1883a, 0x18846, 0x1884c, 0x18858, 0x1886e, 0x18872,
        0x18874, 0x18886, 0x18898, 0x188b0, 0x188be, 0x188ce, 0x188dc, 0x188e2, 0x188e4, 0x188e8, 0x188f6, 0x1890c,
        0x18930, 0x1893e, 0x18960, 0x1897c, 0x1898e, 0x189b8, 0x189c2, 0x189c8, 0x189d0, 0x189de, 0x189e6, 0x189ec,
        0x189fa, 0x18a18, 0x18a30, 0x18a3e, 0x18a60, 0x18a7c, 0x18ac0, 0x18af8, 0x18b1c, 0x18b38, 0x18b70, 0x18b7e,
        0x18b82, 0x18b84, 0x18b88, 0x18b90, 0x18b9e, 0x18ba0, 0x18bbc, 0x18bc6, 0x18bcc, 0x18bd8, 0x18bee, 0x18bf2,
        0x18bf4, 0x18c22, 0x18c24, 0x18c28, 0x18c36, 0x18c42, 0x18c48, 0x18c50, 0x18c5e, 0x18c66, 0x18c7a, 0x18c82,
        0x18c84, 0x18c90, 0x18c9e, 0x18ca0, 0x18cbc, 0x18ccc, 0x18cf2, 0x18cf4, 0x18d04, 0x18d08, 0x18d10, 0x18d1e,
        0x18d20, 0x18d3c, 0x18d40, 0x18d78, 0x18d86, 0x18d98, 0x18dce, 0x18de2, 0x18de4, 0x18de8, 0x18e2e, 0x18e32,
        0x18e34, 0x18e4e, 0x18e5c, 0x18e62, 0x18e64, 0x18e68, 0x18e8e, 0x18e9c, 0x18eb8, 0x18ec2, 0x18ec4, 0x18ec8,
        0x18ed0, 0x18efa, 0x18f16, 0x18f26, 0x18f2c, 0x18f46, 0x18f4c, 0x18f58, 0x18f6e, 0x18f8a, 0x18f92, 0x18f94,
        0x18fa2, 0x18fa4, 0x18fa8, 0x18fb6, 0x1902c, 0x1903a, 0x19046, 0x1904c, 0x19058, 0x19072, 0x19074, 0x19086,
        0x19098, 0x190b0, 0x190be, 0x190ce, 0x190dc, 0x190e2, 0x190e8, 0x190f6, 0x19106, 0x1910c, 0x19130, 0x1913e,
        0x19160, 0x1917c, 0x1918e, 0x1919c, 0x191b8, 0x191c2, 0x191c8, 0x191d0, 0x191de, 0x191e6, 0x191ec, 0x191fa,
        0x19218, 0x1923e, 0x19260, 0x1927c, 0x192c0, 0x192f8, 0x19338, 0x19370, 0x1937e, 0x19382, 0x19384, 0x19390,
        0x1939e, 0x193a0, 0x193bc, 0x193c6, 0x193cc, 0x193d8, 0x193ee, 0x193f2, 0x193f4, 0x19430, 0x1943e, 0x19460,
        0x1947c, 0x194c0, 0x194f8, 0x195f0, 0x19638, 0x19670, 0x1967e, 0x196e0, 0x196fc, 0x19702, 0x19704, 0x19708,
        0x19710, 0x19720, 0x1973c, 0x19740, 0x19778, 0x19786, 0x1978c, 0x19798, 0x197b0, 0x197be, 0x197ce, 0x197dc,
        0x197e2, 0x197e4, 0x197e8, 0x19822, 0x19824, 0x19842, 0x19848, 0x19850, 0x1985e, 0x19866, 0x1987a, 0x19882,
        0x19884, 0x19890, 0x1989e, 0x198a0, 0x198bc, 0x198cc, 0x198f2, 0x198f4, 0x19902, 0x19908, 0x1991e, 0x19920,
        0x1993c, 0x19940, 0x19978, 0x19986, 0x19998, 0x199ce, 0x199e2, 0x199e4, 0x199e8, 0x19a08, 0x19a10, 0x19a1e,
        0x19a20, 0x19a3c, 0x19a40, 0x19a78, 0x19af0, 0x19b18, 0x19b3e, 0x19b60, 0x19b9c, 0x19bc2, 0x19bc4, 0x19bc8,
        0x19bd0, 0x19be6, 0x19c2e, 0x19c34, 0x19c4e, 0x19c5c, 0x19c62, 0x19c64, 0x19c68, 0x19c8e, 0x19c9c, 0x19cb8,
        0x19cc2, 0x19cc8, 0x19cd0, 0x19ce6, 0x19cfa, 0x19d0e, 0x19d1c, 0x19d38, 0x19d70, 0x19d7e, 0x19d82, 0x19d84,
        0x19d88, 0x19d90, 0x19da0, 0x19dcc, 0x19df2, 0x19df4, 0x19e16, 0x19e26, 0x19e2c, 0x19e46, 0x19e4c, 0x19e58,
        0x19e74, 0x19e86, 0x19e8c, 0x19e98, 0x19eb0, 0x19ebe, 0x19ece, 0x19ee2, 0x19ee4, 0x19ee8, 0x19f0a, 0x19f12,
        0x19f14, 0x19f22, 0x19f24, 0x19f28, 0x19f42, 0x19f44, 0x19f48, 0x19f50, 0x19f5e, 0x19f6c, 0x19f9a, 0x19fae,
        0x19fb2, 0x19fb4, 0x1a046, 0x1a04c, 0x1a072, 0x1a074, 0x1a086, 0x1a08c, 0x1a098, 0x1a0b0, 0x1a0be, 0x1a0e2,
        0x1a0e4, 0x1a0e8, 0x1a0f6, 0x1a106, 0x1a10c, 0x1a118, 0x1a130, 0x1a13e, 0x1a160, 0x1a17c, 0x1a18e, 0x1a19c,
        0x1a1b8, 0x1a1c2, 0x1a1c4, 0x1a1c8, 0x1a1d0, 0x1a1de, 0x1a1e6, 0x1a1ec, 0x1a218, 0x1a230, 0x1a23e, 0x1a260,
        0x1a27c, 0x1a2c0, 0x1a2f8, 0x1a31c, 0x1a338, 0x1a370, 0x1a37e, 0x1a382, 0x1a384, 0x1a388, 0x1a390, 0x1a39e,
        0x1a3a0, 0x1a3bc, 0x1a3c6, 0x1a3cc, 0x1a3d8, 0x1a3ee, 0x1a3f2, 0x1a3f4, 0x1a418, 0x1a430, 0x1a43e, 0x1a460,
        0x1a47c, 0x1a4c0, 0x1a4f8, 0x1a5f0, 0x1a61c, 0x1a638, 0x1a670, 0x1a67e, 0x1a6e0, 0x1a6fc, 0x1a702, 0x1a704,
        0x1a708, 0x1a710, 0x1a71e, 0x1a720, 0x1a73c, 0x1a740, 0x1a778, 0x1a786, 0x1a78c, 0x1a798, 0x1a7b0, 0x1a7be,
        0x1a7ce, 0x1a7dc, 0x1a7e2, 0x1a7e4, 0x1a7e8, 0x1a830, 0x1a860, 0x1a87c, 0x1a8c0, 0x1a8f8, 0x1a9f0, 0x1abe0,
        0x1ac70, 0x1ac7e, 0x1ace0, 0x1acfc, 0x1adc0, 0x1adf8, 0x1ae04, 0x1ae08, 0x1ae10, 0x1ae20, 0x1ae3c, 0x1ae40,
        0x1ae78, 0x1aef0, 0x1af06, 0x1af0c, 0x1af18, 0x1af30, 0x1af3e, 0x1af60, 0x1af7c, 0x1af8e, 0x1af9c, 0x1afb8,
        0x1afc4, 0x1afc8, 0x1afd0, 0x1afde, 0x1b042, 0x1b05e, 0x1b07a, 0x1b082, 0x1b084, 0x1b088, 0x1b090, 0x1b09e,
        0x1b0a0, 0x1b0bc, 0x1b0cc, 0x1b0f2, 0x1b0f4, 0x1b102, 0x1b104, 0x1b108, 0x1b110, 0x1b11e, 0x1b120, 0x1b13c,
        0x1b140, 0x1b178, 0x1b186, 0x1b198, 0x1b1ce, 0x1b1e2, 0x1b1e4, 0x1b1e8, 0x1b204, 0x1b208, 0x1b210, 0x1b21e,
        0x1b220, 0x1b23c, 0x1b240, 0x1b278, 0x1b2f0, 0x1b30c, 0x1b33e, 0x1b360, 0x1b39c, 0x1b3c2, 0x1b3c4, 0x1b3c8,
        0x1b3d0, 0x1b3e6, 0x1b410, 0x1b41e, 0x1b420, 0x1b43c, 0x1b440, 0x1b478, 0x1b4f0, 0x1b5e0, 0x1b618, 0x1b660,
        0x1b67c, 0x1b6c0, 0x1b738, 0x1b782, 0x1b784, 0x1b788, 0x1b790, 0x1b79e, 0x1b7a0, 0x1b7cc, 0x1b82e, 0x1b84e,
        0x1b85c, 0x1b88e, 0x1b89c, 0x1b8b8, 0x1b8c2, 0x1b8c4, 0x1b8c8, 0x1b8d0, 0x1b8e6, 0x1b8fa, 0x1b90e, 0x1b91c,
        0x1b938, 0x1b970, 0x1b97e, 0x1b982, 0x1b984, 0x1b988, 0x1b990, 0x1b99e, 0x1b9a0, 0x1b9cc, 0x1b9f2, 0x1b9f4,
        0x1ba0e, 0x1ba1c, 0x1ba38, 0x1ba70, 0x1ba7e, 0x1bae0, 0x1bafc, 0x1bb08, 0x1bb10, 0x1bb20, 0x1bb3c, 0x1bb40,
        0x1bb98, 0x1bbce, 0x1bbe2, 0x1bbe4, 0x1bbe8, 0x1bc16, 0x1bc26, 0x1bc2c, 0x1bc46, 0x1bc4c, 0x1bc58, 0x1bc72,
        0x1bc74, 0x1bc86, 0x1bc8c, 0x1bc98, 0x1bcb0, 0x1bcbe, 0x1bcce, 0x1bce2, 0x1bce4, 0x1bce8, 0x1bd06, 0x1bd0c,
        0x1bd18, 0x1bd30, 0x1bd3e, 0x1bd60, 0x1bd7c, 0x1bd9c, 0x1bdc2, 0x1bdc4, 0x1bdc8, 0x1bdd0, 0x1bde6, 0x1bdfa,
        0x1be12, 0x1be14, 0x1be22, 0x1be24, 0x1be28, 0x1be42, 0x1be44, 0x1be48, 0x1be50, 0x1be5e, 0x1be66, 0x1be82,
        0x1be84, 0x1be88, 0x1be90, 0x1be9e, 0x1bea0, 0x1bebc, 0x1becc, 0x1bef4, 0x1bf1a, 0x1bf2e, 0x1bf32, 0x1bf34,
        0x1bf4e, 0x1bf5c, 0x1bf62, 0x1bf64, 0x1bf68, 0x1c09a, 0x1c0b2, 0x1c0b4, 0x1c11a, 0x1c132, 0x1c134, 0x1c162,
        0x1c164, 0x1c168, 0x1c176, 0x1c1ba, 0x1c21a, 0x1c232, 0x1c234, 0x1c24e, 0x1c25c, 0x1c262, 0x1c264, 0x1c268,
        0x1c276, 0x1c28e, 0x1c2c2, 0x1c2c4, 0x1c2c8, 0x1c2d0, 0x1c2de, 0x1c2e6, 0x1c2ec, 0x1c2fa, 0x1c316, 0x1c326,
        0x1c33a, 0x1c346, 0x1c34c, 0x1c372, 0x1c374, 0x1c41a, 0x1c42e, 0x1c432, 0x1c434, 0x1c44e, 0x1c45c, 0x1c462,
        0x1c464, 0x1c468, 0x1c476, 0x1c48e, 0x1c49c, 0x1c4b8, 0x1c4c2, 0x1c4c8, 0x1c4d0, 0x1c4de, 0x1c4e6, 0x1c4ec,
        0x1c4fa, 0x1c51c, 0x1c538, 0x1c570, 0x1c57e, 0x1c582, 0x1c584, 0x1c588, 0x1c590, 0x1c59e, 0x1c5a0, 0x1c5bc,
        0x1c5c6, 0x1c5cc, 0x1c5d8, 0x1c5ee, 0x1c5f2, 0x1c5f4, 0x1c616, 0x1c626, 0x1c62c, 0x1c63a, 0x1c646, 0x1c64c,
        0x1c658, 0x1c66e, 0x1c672, 0x1c674, 0x1c686, 0x1c68c, 0x1c698, 0x1c6b0, 0x1c6be, 0x1c6ce, 0x1c6dc, 0x1c6e2,
        0x1c6e4, 0x1c6e8, 0x1c712, 0x1c714, 0x1c722, 0x1c728, 0x1c736, 0x1c742, 0x1c744, 0x1c748, 0x1c750, 0x1c75e,
        0x1c766, 0x1c76c, 0x1c77a, 0x1c7ae, 0x1c7d6, 0x1c7ea, 0x1c81a, 0x1c82e, 0x1c832, 0x1c834, 0x1c84e, 0x1c85c,
        0x1c862, 0x1c864, 0x1c868, 0x1c876, 0x1c88e, 0x1c89c, 0x1c8b8, 0x1c8c2, 0x1c8c8, 0x1c8d0, 0x1c8de, 0x1c8e6,
        0x1c8ec, 0x1c8fa, 0x1c90e, 0x1c938, 0x1c970, 0x1c97e, 0x1c982, 0x1c984, 0x1c990, 0x1c99e, 0x1c9a0, 0x1c9bc,
        0x1c9c6, 0x1c9cc, 0x1c9d8, 0x1c9ee, 0x1c9f2, 0x1c9f4, 0x1ca38, 0x1ca70, 0x1ca7e, 0x1cae0, 0x1cafc, 0x1cb02,
        0x1cb04, 0x1cb08, 0x1cb10, 0x1cb20, 0x1cb3c, 0x1cb40, 0x1cb78, 0x1cb86, 0x1cb8c, 0x1cb98, 0x1cbb0, 0x1cbbe,
        0x1cbce, 0x1cbdc, 0x1cbe2, 0x1cbe4, 0x1cbe8, 0x1cbf6, 0x1cc16, 0x1cc26, 0x1cc2c, 0x1cc3a, 0x1cc46, 0x1cc58,
        0x1cc72, 0x1cc74, 0x1cc86, 0x1ccb0, 0x1ccbe, 0x1ccce, 0x1cce2, 0x1cce4, 0x1cce8, 0x1cd06, 0x1cd0c, 0x1cd18,
        0x1cd30, 0x1cd3e, 0x1cd60, 0x1cd7c, 0x1cd9c, 0x1cdc2, 0x1cdc4, 0x1cdc8, 0x1cdd0, 0x1cdde, 0x1cde6, 0x1cdfa,
        0x1ce22, 0x1ce28, 0x1ce42, 0x1ce50, 0x1ce5e, 0x1ce66, 0x1ce7a, 0x1ce82, 0x1ce84, 0x1ce88, 0x1ce90, 0x1ce9e,
        0x1cea0, 0x1cebc, 0x1cecc, 0x1cef2, 0x1cef4, 0x1cf2e, 0x1cf32, 0x1cf34, 0x1cf4e, 0x1cf5c, 0x1cf62, 0x1cf64,
        0x1cf68, 0x1cf96, 0x1cfa6, 0x1cfac, 0x1cfca, 0x1cfd2, 0x1cfd4, 0x1d02e, 0x1d032, 0x1d034, 0x1d04e, 0x1d05c,
        0x1d062, 0x1d064, 0x1d068, 0x1d076, 0x1d08e, 0x1d09c, 0x1d0b8, 0x1d0c2, 0x1d0c4, 0x1d0c8, 0x1d0d0, 0x1d0de,
        0x1d0e6, 0x1d0ec, 0x1d0fa, 0x1d11c, 0x1d138, 0x1d170, 0x1d17e, 0x1d182, 0x1d184, 0x1d188, 0x1d190, 0x1d19e,
        0x1d1a0, 0x1d1bc, 0x1d1c6, 0x1d1cc, 0x1d1d8, 0x1d1ee, 0x1d1f2, 0x1d1f4, 0x1d21c, 0x1d238, 0x1d270, 0x1d27e,
        0x1d2e0, 0x1d2fc, 0x1d302, 0x1d304, 0x1d308, 0x1d310, 0x1d31e, 0x1d320, 0x1d33c, 0x1d340, 0x1d378, 0x1d386,
        0x1d38c, 0x1d398, 0x1d3b0, 0x1d3be, 0x1d3ce, 0x1d3dc, 0x1d3e2, 0x1d3e4, 0x1d3e8, 0x1d3f6, 0x1d470, 0x1d47e,
        0x1d4e0, 0x1d4fc, 0x1d5c0, 0x1d5f8, 0x1d604, 0x1d608, 0x1d610, 0x1d620, 0x1d640, 0x1d678, 0x1d6f0, 0x1d706,
        0x1d70c, 0x1d718, 0x1d730, 0x1d73e, 0x1d760, 0x1d77c, 0x1d78e, 0x1d79c, 0x1d7b8, 0x1d7c2, 0x1d7c4, 0x1d7c8,
        0x1d7d0, 0x1d7de, 0x1d7e6, 0x1d7ec, 0x1d826, 0x1d82c, 0x1d83a, 0x1d846, 0x1d84c, 0x1d858, 0x1d872, 0x1d874,
        0x1d886, 0x1d88c, 0x1d898, 0x1d8b0, 0x1d8be, 0x1d8ce, 0x1d8e2, 0x1d8e4, 0x1d8e8, 0x1d8f6, 0x1d90c, 0x1d918,
        0x1d930, 0x1d93e, 0x1d960, 0x1d97c, 0x1d99c, 0x1d9c2, 0x1d9c4, 0x1d9c8, 0x1d9d0, 0x1d9e6, 0x1d9fa, 0x1da0c,
        0x1da18, 0x1da30, 0x1da3e, 0x1da60, 0x1da7c, 0x1dac0, 0x1daf8, 0x1db38, 0x1db82, 0x1db84, 0x1db88, 0x1db90,
        0x1db9e, 0x1dba0, 0x1dbcc, 0x1dbf2, 0x1dbf4, 0x1dc22, 0x1dc42, 0x1dc44, 0x1dc48, 0x1dc50, 0x1dc5e, 0x1dc66,
        0x1dc7a, 0x1dc82, 0x1dc84, 0x1dc88, 0x1dc90, 0x1dc9e, 0x1dca0, 0x1dcbc, 0x1dccc, 0x1dcf2, 0x1dcf4, 0x1dd04,
        0x1dd08, 0x1dd10, 0x1dd1e, 0x1dd20, 0x1dd3c, 0x1dd40, 0x1dd78, 0x1dd86, 0x1dd98, 0x1ddce, 0x1dde2, 0x1dde4,
        0x1dde8, 0x1de2e, 0x1de32, 0x1de34, 0x1de4e, 0x1de5c, 0x1de62, 0x1de64, 0x1de68, 0x1de8e, 0x1de9c, 0x1deb8,
        0x1dec2, 0x1dec4, 0x1dec8, 0x1ded0, 0x1dee6, 0x1defa, 0x1df16, 0x1df26, 0x1df2c, 0x1df46, 0x1df4c, 0x1df58,
        0x1df72, 0x1df74, 0x1df8a, 0x1df92, 0x1df94, 0x1dfa2, 0x1dfa4, 0x1dfa8, 0x1e08a, 0x1e092, 0x1e094, 0x1e0a2,
        0x1e0a4, 0x1e0a8, 0x1e0b6, 0x1e0da, 0x1e10a, 0x1e112, 0x1e114, 0x1e122, 0x1e124, 0x1e128, 0x1e136, 0x1e142,
        0x1e144, 0x1e148, 0x1e150, 0x1e166, 0x1e16c, 0x1e17a, 0x1e19a, 0x1e1b2, 0x1e1b4, 0x1e20a, 0x1e212, 0x1e214,
        0x1e222, 0x1e224, 0x1e228, 0x1e236, 0x1e242, 0x1e248, 0x1e250, 0x1e25e, 0x1e266, 0x1e26c, 0x1e27a, 0x1e282,
        0x1e284, 0x1e288, 0x1e290, 0x1e2a0, 0x1e2bc, 0x1e2c6, 0x1e2cc, 0x1e2d8, 0x1e2ee, 0x1e2f2, 0x1e2f4, 0x1e31a,
        0x1e332, 0x1e334, 0x1e35c, 0x1e362, 0x1e364, 0x1e368, 0x1e3ba, 0x1e40a, 0x1e412, 0x1e414, 0x1e422, 0x1e428,
        0x1e436, 0x1e442, 0x1e448, 0x1e450, 0x1e45e, 0x1e466, 0x1e46c, 0x1e47a, 0x1e482, 0x1e484, 0x1e490, 0x1e49e,
        0x1e4a0, 0x1e4bc, 0x1e4c6, 0x1e4cc, 0x1e4d8, 0x1e4ee, 0x1e4f2, 0x1e4f4, 0x1e502, 0x1e504, 0x1e508, 0x1e510,
        0x1e51e, 0x1e520, 0x1e53c, 0x1e540, 0x1e578, 0x1e586, 0x1e58c, 0x1e598, 0x1e5b0, 0x1e5be, 0x1e5ce, 0x1e5dc,
        0x1e5e2, 0x1e5e4, 0x1e5e8, 0x1e5f6, 0x1e61a, 0x1e62e, 0x1e632, 0x1e634, 0x1e64e, 0x1e65c, 0x1e662, 0x1e668,
        0x1e68e, 0x1e69c, 0x1e6b8, 0x1e6c2, 0x1e6c4, 0x1e6c8, 0x1e6d0, 0x1e6e6, 0x1e6fa, 0x1e716, 0x1e726, 0x1e72c,
        0x1e73a, 0x1e746, 0x1e74c, 0x1e758, 0x1e772, 0x1e774, 0x1e792, 0x1e794, 0x1e7a2, 0x1e7a4, 0x1e7a8, 0x1e7b6,
        0x1e812, 0x1e814, 0x1e822, 0x1e824, 0x1e828, 0x1e836, 0x1e842, 0x1e844, 0x1e848, 0x1e850, 0x1e85e, 0x1e866,
        0x1e86c, 0x1e87a, 0x1e882, 0x1e884, 0x1e888, 0x1e890, 0x1e89e, 0x1e8a0, 0x1e8bc, 0x1e8c6, 0x1e8cc, 0x1e8d8,
        0x1e8ee, 0x1e8f2, 0x1e8f4, 0x1e902, 0x1e904, 0x1e908, 0x1e910, 0x1e920, 0x1e93c, 0x1e940, 0x1e978, 0x1e986,
        0x1e98c, 0x1e998, 0x1e9b0, 0x1e9be, 0x1e9ce, 0x1e9dc, 0x1e9e2, 0x1e9e4, 0x1e9e8, 0x1e9f6, 0x1ea04, 0x1ea08,
        0x1ea10, 0x1ea20, 0x1ea40, 0x1ea78, 0x1eaf0, 0x1eb06, 0x1eb0c, 0x1eb18, 0x1eb30, 0x1eb3e, 0x1eb60, 0x1eb7c,
        0x1eb8e, 0x1eb9c, 0x1ebb8, 0x1ebc2, 0x1ebc4, 0x1ebc8, 0x1ebd0, 0x1ebde, 0x1ebe6, 0x1ebec, 0x1ec1a, 0x1ec2e,
        0x1ec32, 0x1ec34, 0x1ec4e, 0x1ec5c, 0x1ec62, 0x1ec64, 0x1ec68, 0x1ec8e, 0x1ec9c, 0x1ecb8, 0x1ecc2, 0x1ecc4,
        0x1ecc8, 0x1ecd0, 0x1ece6, 0x1ecfa, 0x1ed0e, 0x1ed1c, 0x1ed38, 0x1ed70, 0x1ed7e, 0x1ed82, 0x1ed84, 0x1ed88,
        0x1ed90, 0x1ed9e, 0x1eda0, 0x1edcc, 0x1edf2, 0x1edf4, 0x1ee16, 0x1ee26, 0x1ee2c, 0x1ee3a, 0x1ee46, 0x1ee4c,
        0x1ee58, 0x1ee6e, 0x1ee72, 0x1ee74, 0x1ee86, 0x1ee8c, 0x1ee98, 0x1eeb0, 0x1eebe, 0x1eece, 0x1eedc, 0x1eee2,
        0x1eee4, 0x1eee8, 0x1ef12, 0x1ef22, 0x1ef24, 0x1ef28, 0x1ef36, 0x1ef42, 0x1ef44, 0x1ef48, 0x1ef50, 0x1ef5e,
        0x1ef66, 0x1ef6c, 0x1ef7a, 0x1efae, 0x1efb2, 0x1efb4, 0x1efd6, 0x1f096, 0x1f0a6, 0x1f0ac, 0x1f0ba, 0x1f0ca,
        0x1f0d2, 0x1f0d4, 0x1f116, 0x1f126, 0x1f12c, 0x1f13a, 0x1f146, 0x1f14c, 0x1f158, 0x1f16e, 0x1f172, 0x1f174,
        0x1f18a, 0x1f192, 0x1f194, 0x1f1a2, 0x1f1a4, 0x1f1a8, 0x1f1da, 0x1f216, 0x1f226, 0x1f22c, 0x1f23a, 0x1f246,
        0x1f258, 0x1f26e, 0x1f272, 0x1f274, 0x1f286, 0x1f28c, 0x1f298, 0x1f2b0, 0x1f2be, 0x1f2ce, 0x1f2dc, 0x1f2e2,
        0x1f2e4, 0x1f2e8, 0x1f2f6, 0x1f30a, 0x1f312, 0x1f314, 0x1f322, 0x1f328, 0x1f342, 0x1f344, 0x1f348, 0x1f350,
        0x1f35e, 0x1f366, 0x1f37a, 0x1f39a, 0x1f3ae, 0x1f3b2, 0x1f3b4, 0x1f416, 0x1f426, 0x1f42c, 0x1f43a, 0x1f446,
        0x1f44c, 0x1f458, 0x1f46e, 0x1f472, 0x1f474, 0x1f486, 0x1f48c, 0x1f498, 0x1f4b0, 0x1f4be, 0x1f4ce, 0x1f4dc,
        0x1f4e2, 0x1f4e4, 0x1f4e8, 0x1f4f6, 0x1f506, 0x1f50c, 0x1f518, 0x1f530, 0x1f53e, 0x1f560, 0x1f57c, 0x1f58e,
        0x1f59c, 0x1f5b8, 0x1f5c2, 0x1f5c4, 0x1f5c8, 0x1f5d0, 0x1f5de, 0x1f5e6, 0x1f5ec, 0x1f5fa, 0x1f60a, 0x1f612,
        0x1f614, 0x1f622, 0x1f624, 0x1f628, 0x1f636, 0x1f642, 0x1f644, 0x1f648, 0x1f650, 0x1f65e, 0x1f666, 0x1f67a,
        0x1f682, 0x1f684, 0x1f688, 0x1f690, 0x1f69e, 0x1f6a0, 0x1f6bc, 0x1f6cc, 0x1f6f2, 0x1f6f4, 0x1f71a, 0x1f72e,
        0x1f732, 0x1f734, 0x1f74e, 0x1f75c, 0x1f762, 0x1f764, 0x1f768, 0x1f776, 0x1f796, 0x1f7a6, 0x1f7ac, 0x1f7ba,
        0x1f7d2, 0x1f7d4, 0x1f89a, 0x1f8ae, 0x1f8b2, 0x1f8b4, 0x1f8d6, 0x1f8ea, 0x1f91a, 0x1f92e, 0x1f932, 0x1f934,
        0x1f94e, 0x1f95c, 0x1f962, 0x1f964, 0x1f968, 0x1f976, 0x1f996, 0x1f9a6, 0x1f9ac, 0x1f9ba, 0x1f9ca, 0x1f9d2,
        0x1f9d4, 0x1fa1a, 0x1fa2e, 0x1fa32, 0x1fa34, 0x1fa4e, 0x1fa5c, 0x1fa62, 0x1fa64, 0x1fa68, 0x1fa76, 0x1fa8e,
        0x1fa9c, 0x1fab8, 0x1fac2, 0x1fac4, 0x1fac8, 0x1fad0, 0x1fade, 0x1fae6, 0x1faec, 0x1fb16, 0x1fb26, 0x1fb2c,
        0x1fb3a, 0x1fb46, 0x1fb4c, 0x1fb58, 0x1fb6e, 0x1fb72, 0x1fb74, 0x1fb8a, 0x1fb92, 0x1fb94, 0x1fba2, 0x1fba4,
        0x1fba8, 0x1fbb6, 0x1fbda
    ]);
    /**
     * This table contains to codewords for all symbols.
     */
    PDF417Common.CODEWORD_TABLE = Int32Array.from([
        2627, 1819, 2622, 2621, 1813, 1812, 2729, 2724, 2723, 2779, 2774, 2773, 902, 896, 908, 868, 865, 861, 859, 2511,
        873, 871, 1780, 835, 2493, 825, 2491, 842, 837, 844, 1764, 1762, 811, 810, 809, 2483, 807, 2482, 806, 2480, 815,
        814, 813, 812, 2484, 817, 816, 1745, 1744, 1742, 1746, 2655, 2637, 2635, 2626, 2625, 2623, 2628, 1820, 2752,
        2739, 2737, 2728, 2727, 2725, 2730, 2785, 2783, 2778, 2777, 2775, 2780, 787, 781, 747, 739, 736, 2413, 754, 752,
        1719, 692, 689, 681, 2371, 678, 2369, 700, 697, 694, 703, 1688, 1686, 642, 638, 2343, 631, 2341, 627, 2338, 651,
        646, 643, 2345, 654, 652, 1652, 1650, 1647, 1654, 601, 599, 2322, 596, 2321, 594, 2319, 2317, 611, 610, 608, 606,
        2324, 603, 2323, 615, 614, 612, 1617, 1616, 1614, 1612, 616, 1619, 1618, 2575, 2538, 2536, 905, 901, 898, 909,
        2509, 2507, 2504, 870, 867, 864, 860, 2512, 875, 872, 1781, 2490, 2489, 2487, 2485, 1748, 836, 834, 832, 830,
        2494, 827, 2492, 843, 841, 839, 845, 1765, 1763, 2701, 2676, 2674, 2653, 2648, 2656, 2634, 2633, 2631, 2629,
        1821, 2638, 2636, 2770, 2763, 2761, 2750, 2745, 2753, 2736, 2735, 2733, 2731, 1848, 2740, 2738, 2786, 2784, 591,
        588, 576, 569, 566, 2296, 1590, 537, 534, 526, 2276, 522, 2274, 545, 542, 539, 548, 1572, 1570, 481, 2245, 466,
        2242, 462, 2239, 492, 485, 482, 2249, 496, 494, 1534, 1531, 1528, 1538, 413, 2196, 406, 2191, 2188, 425, 419,
        2202, 415, 2199, 432, 430, 427, 1472, 1467, 1464, 433, 1476, 1474, 368, 367, 2160, 365, 2159, 362, 2157, 2155,
        2152, 378, 377, 375, 2166, 372, 2165, 369, 2162, 383, 381, 379, 2168, 1419, 1418, 1416, 1414, 385, 1411, 384,
        1423, 1422, 1420, 1424, 2461, 802, 2441, 2439, 790, 786, 783, 794, 2409, 2406, 2403, 750, 742, 738, 2414, 756,
        753, 1720, 2367, 2365, 2362, 2359, 1663, 693, 691, 684, 2373, 680, 2370, 702, 699, 696, 704, 1690, 1687, 2337,
        2336, 2334, 2332, 1624, 2329, 1622, 640, 637, 2344, 634, 2342, 630, 2340, 650, 648, 645, 2346, 655, 653, 1653,
        1651, 1649, 1655, 2612, 2597, 2595, 2571, 2568, 2565, 2576, 2534, 2529, 2526, 1787, 2540, 2537, 907, 904, 900,
        910, 2503, 2502, 2500, 2498, 1768, 2495, 1767, 2510, 2508, 2506, 869, 866, 863, 2513, 876, 874, 1782, 2720, 2713,
        2711, 2697, 2694, 2691, 2702, 2672, 2670, 2664, 1828, 2678, 2675, 2647, 2646, 2644, 2642, 1823, 2639, 1822, 2654,
        2652, 2650, 2657, 2771, 1855, 2765, 2762, 1850, 1849, 2751, 2749, 2747, 2754, 353, 2148, 344, 342, 336, 2142,
        332, 2140, 345, 1375, 1373, 306, 2130, 299, 2128, 295, 2125, 319, 314, 311, 2132, 1354, 1352, 1349, 1356, 262,
        257, 2101, 253, 2096, 2093, 274, 273, 267, 2107, 263, 2104, 280, 278, 275, 1316, 1311, 1308, 1320, 1318, 2052,
        202, 2050, 2044, 2040, 219, 2063, 212, 2060, 208, 2055, 224, 221, 2066, 1260, 1258, 1252, 231, 1248, 229, 1266,
        1264, 1261, 1268, 155, 1998, 153, 1996, 1994, 1991, 1988, 165, 164, 2007, 162, 2006, 159, 2003, 2000, 172, 171,
        169, 2012, 166, 2010, 1186, 1184, 1182, 1179, 175, 1176, 173, 1192, 1191, 1189, 1187, 176, 1194, 1193, 2313,
        2307, 2305, 592, 589, 2294, 2292, 2289, 578, 572, 568, 2297, 580, 1591, 2272, 2267, 2264, 1547, 538, 536, 529,
        2278, 525, 2275, 547, 544, 541, 1574, 1571, 2237, 2235, 2229, 1493, 2225, 1489, 478, 2247, 470, 2244, 465, 2241,
        493, 488, 484, 2250, 498, 495, 1536, 1533, 1530, 1539, 2187, 2186, 2184, 2182, 1432, 2179, 1430, 2176, 1427, 414,
        412, 2197, 409, 2195, 405, 2193, 2190, 426, 424, 421, 2203, 418, 2201, 431, 429, 1473, 1471, 1469, 1466, 434,
        1477, 1475, 2478, 2472, 2470, 2459, 2457, 2454, 2462, 803, 2437, 2432, 2429, 1726, 2443, 2440, 792, 789, 785,
        2401, 2399, 2393, 1702, 2389, 1699, 2411, 2408, 2405, 745, 741, 2415, 758, 755, 1721, 2358, 2357, 2355, 2353,
        1661, 2350, 1660, 2347, 1657, 2368, 2366, 2364, 2361, 1666, 690, 687, 2374, 683, 2372, 701, 698, 705, 1691, 1689,
        2619, 2617, 2610, 2608, 2605, 2613, 2593, 2588, 2585, 1803, 2599, 2596, 2563, 2561, 2555, 1797, 2551, 1795, 2573,
        2570, 2567, 2577, 2525, 2524, 2522, 2520, 1786, 2517, 1785, 2514, 1783, 2535, 2533, 2531, 2528, 1788, 2541, 2539,
        906, 903, 911, 2721, 1844, 2715, 2712, 1838, 1836, 2699, 2696, 2693, 2703, 1827, 1826, 1824, 2673, 2671, 2669,
        2666, 1829, 2679, 2677, 1858, 1857, 2772, 1854, 1853, 1851, 1856, 2766, 2764, 143, 1987, 139, 1986, 135, 133,
        131, 1984, 128, 1983, 125, 1981, 138, 137, 136, 1985, 1133, 1132, 1130, 112, 110, 1974, 107, 1973, 104, 1971,
        1969, 122, 121, 119, 117, 1977, 114, 1976, 124, 1115, 1114, 1112, 1110, 1117, 1116, 84, 83, 1953, 81, 1952, 78,
        1950, 1948, 1945, 94, 93, 91, 1959, 88, 1958, 85, 1955, 99, 97, 95, 1961, 1086, 1085, 1083, 1081, 1078, 100,
        1090, 1089, 1087, 1091, 49, 47, 1917, 44, 1915, 1913, 1910, 1907, 59, 1926, 56, 1925, 53, 1922, 1919, 66, 64,
        1931, 61, 1929, 1042, 1040, 1038, 71, 1035, 70, 1032, 68, 1048, 1047, 1045, 1043, 1050, 1049, 12, 10, 1869, 1867,
        1864, 1861, 21, 1880, 19, 1877, 1874, 1871, 28, 1888, 25, 1886, 22, 1883, 982, 980, 977, 974, 32, 30, 991, 989,
        987, 984, 34, 995, 994, 992, 2151, 2150, 2147, 2146, 2144, 356, 355, 354, 2149, 2139, 2138, 2136, 2134, 1359,
        343, 341, 338, 2143, 335, 2141, 348, 347, 346, 1376, 1374, 2124, 2123, 2121, 2119, 1326, 2116, 1324, 310, 308,
        305, 2131, 302, 2129, 298, 2127, 320, 318, 316, 313, 2133, 322, 321, 1355, 1353, 1351, 1357, 2092, 2091, 2089,
        2087, 1276, 2084, 1274, 2081, 1271, 259, 2102, 256, 2100, 252, 2098, 2095, 272, 269, 2108, 266, 2106, 281, 279,
        277, 1317, 1315, 1313, 1310, 282, 1321, 1319, 2039, 2037, 2035, 2032, 1203, 2029, 1200, 1197, 207, 2053, 205,
        2051, 201, 2049, 2046, 2043, 220, 218, 2064, 215, 2062, 211, 2059, 228, 226, 223, 2069, 1259, 1257, 1254, 232,
        1251, 230, 1267, 1265, 1263, 2316, 2315, 2312, 2311, 2309, 2314, 2304, 2303, 2301, 2299, 1593, 2308, 2306, 590,
        2288, 2287, 2285, 2283, 1578, 2280, 1577, 2295, 2293, 2291, 579, 577, 574, 571, 2298, 582, 581, 1592, 2263, 2262,
        2260, 2258, 1545, 2255, 1544, 2252, 1541, 2273, 2271, 2269, 2266, 1550, 535, 532, 2279, 528, 2277, 546, 543, 549,
        1575, 1573, 2224, 2222, 2220, 1486, 2217, 1485, 2214, 1482, 1479, 2238, 2236, 2234, 2231, 1496, 2228, 1492, 480,
        477, 2248, 473, 2246, 469, 2243, 490, 487, 2251, 497, 1537, 1535, 1532, 2477, 2476, 2474, 2479, 2469, 2468, 2466,
        2464, 1730, 2473, 2471, 2453, 2452, 2450, 2448, 1729, 2445, 1728, 2460, 2458, 2456, 2463, 805, 804, 2428, 2427,
        2425, 2423, 1725, 2420, 1724, 2417, 1722, 2438, 2436, 2434, 2431, 1727, 2444, 2442, 793, 791, 788, 795, 2388,
        2386, 2384, 1697, 2381, 1696, 2378, 1694, 1692, 2402, 2400, 2398, 2395, 1703, 2392, 1701, 2412, 2410, 2407, 751,
        748, 744, 2416, 759, 757, 1807, 2620, 2618, 1806, 1805, 2611, 2609, 2607, 2614, 1802, 1801, 1799, 2594, 2592,
        2590, 2587, 1804, 2600, 2598, 1794, 1793, 1791, 1789, 2564, 2562, 2560, 2557, 1798, 2554, 1796, 2574, 2572, 2569,
        2578, 1847, 1846, 2722, 1843, 1842, 1840, 1845, 2716, 2714, 1835, 1834, 1832, 1830, 1839, 1837, 2700, 2698, 2695,
        2704, 1817, 1811, 1810, 897, 862, 1777, 829, 826, 838, 1760, 1758, 808, 2481, 1741, 1740, 1738, 1743, 2624, 1818,
        2726, 2776, 782, 740, 737, 1715, 686, 679, 695, 1682, 1680, 639, 628, 2339, 647, 644, 1645, 1643, 1640, 1648,
        602, 600, 597, 595, 2320, 593, 2318, 609, 607, 604, 1611, 1610, 1608, 1606, 613, 1615, 1613, 2328, 926, 924, 892,
        886, 899, 857, 850, 2505, 1778, 824, 823, 821, 819, 2488, 818, 2486, 833, 831, 828, 840, 1761, 1759, 2649, 2632,
        2630, 2746, 2734, 2732, 2782, 2781, 570, 567, 1587, 531, 527, 523, 540, 1566, 1564, 476, 467, 463, 2240, 486,
        483, 1524, 1521, 1518, 1529, 411, 403, 2192, 399, 2189, 423, 416, 1462, 1457, 1454, 428, 1468, 1465, 2210, 366,
        363, 2158, 360, 2156, 357, 2153, 376, 373, 370, 2163, 1410, 1409, 1407, 1405, 382, 1402, 380, 1417, 1415, 1412,
        1421, 2175, 2174, 777, 774, 771, 784, 732, 725, 722, 2404, 743, 1716, 676, 674, 668, 2363, 665, 2360, 685, 1684,
        1681, 626, 624, 622, 2335, 620, 2333, 617, 2330, 641, 635, 649, 1646, 1644, 1642, 2566, 928, 925, 2530, 2527,
        894, 891, 888, 2501, 2499, 2496, 858, 856, 854, 851, 1779, 2692, 2668, 2665, 2645, 2643, 2640, 2651, 2768, 2759,
        2757, 2744, 2743, 2741, 2748, 352, 1382, 340, 337, 333, 1371, 1369, 307, 300, 296, 2126, 315, 312, 1347, 1342,
        1350, 261, 258, 250, 2097, 246, 2094, 271, 268, 264, 1306, 1301, 1298, 276, 1312, 1309, 2115, 203, 2048, 195,
        2045, 191, 2041, 213, 209, 2056, 1246, 1244, 1238, 225, 1234, 222, 1256, 1253, 1249, 1262, 2080, 2079, 154, 1997,
        150, 1995, 147, 1992, 1989, 163, 160, 2004, 156, 2001, 1175, 1174, 1172, 1170, 1167, 170, 1164, 167, 1185, 1183,
        1180, 1177, 174, 1190, 1188, 2025, 2024, 2022, 587, 586, 564, 559, 556, 2290, 573, 1588, 520, 518, 512, 2268,
        508, 2265, 530, 1568, 1565, 461, 457, 2233, 450, 2230, 446, 2226, 479, 471, 489, 1526, 1523, 1520, 397, 395,
        2185, 392, 2183, 389, 2180, 2177, 410, 2194, 402, 422, 1463, 1461, 1459, 1456, 1470, 2455, 799, 2433, 2430, 779,
        776, 773, 2397, 2394, 2390, 734, 728, 724, 746, 1717, 2356, 2354, 2351, 2348, 1658, 677, 675, 673, 670, 667, 688,
        1685, 1683, 2606, 2589, 2586, 2559, 2556, 2552, 927, 2523, 2521, 2518, 2515, 1784, 2532, 895, 893, 890, 2718,
        2709, 2707, 2689, 2687, 2684, 2663, 2662, 2660, 2658, 1825, 2667, 2769, 1852, 2760, 2758, 142, 141, 1139, 1138,
        134, 132, 129, 126, 1982, 1129, 1128, 1126, 1131, 113, 111, 108, 105, 1972, 101, 1970, 120, 118, 115, 1109, 1108,
        1106, 1104, 123, 1113, 1111, 82, 79, 1951, 75, 1949, 72, 1946, 92, 89, 86, 1956, 1077, 1076, 1074, 1072, 98,
        1069, 96, 1084, 1082, 1079, 1088, 1968, 1967, 48, 45, 1916, 42, 1914, 39, 1911, 1908, 60, 57, 54, 1923, 50, 1920,
        1031, 1030, 1028, 1026, 67, 1023, 65, 1020, 62, 1041, 1039, 1036, 1033, 69, 1046, 1044, 1944, 1943, 1941, 11, 9,
        1868, 7, 1865, 1862, 1859, 20, 1878, 16, 1875, 13, 1872, 970, 968, 966, 963, 29, 960, 26, 23, 983, 981, 978, 975,
        33, 971, 31, 990, 988, 985, 1906, 1904, 1902, 993, 351, 2145, 1383, 331, 330, 328, 326, 2137, 323, 2135, 339,
        1372, 1370, 294, 293, 291, 289, 2122, 286, 2120, 283, 2117, 309, 303, 317, 1348, 1346, 1344, 245, 244, 242, 2090,
        239, 2088, 236, 2085, 2082, 260, 2099, 249, 270, 1307, 1305, 1303, 1300, 1314, 189, 2038, 186, 2036, 183, 2033,
        2030, 2026, 206, 198, 2047, 194, 216, 1247, 1245, 1243, 1240, 227, 1237, 1255, 2310, 2302, 2300, 2286, 2284,
        2281, 565, 563, 561, 558, 575, 1589, 2261, 2259, 2256, 2253, 1542, 521, 519, 517, 514, 2270, 511, 533, 1569,
        1567, 2223, 2221, 2218, 2215, 1483, 2211, 1480, 459, 456, 453, 2232, 449, 474, 491, 1527, 1525, 1522, 2475, 2467,
        2465, 2451, 2449, 2446, 801, 800, 2426, 2424, 2421, 2418, 1723, 2435, 780, 778, 775, 2387, 2385, 2382, 2379,
        1695, 2375, 1693, 2396, 735, 733, 730, 727, 749, 1718, 2616, 2615, 2604, 2603, 2601, 2584, 2583, 2581, 2579,
        1800, 2591, 2550, 2549, 2547, 2545, 1792, 2542, 1790, 2558, 929, 2719, 1841, 2710, 2708, 1833, 1831, 2690, 2688,
        2686, 1815, 1809, 1808, 1774, 1756, 1754, 1737, 1736, 1734, 1739, 1816, 1711, 1676, 1674, 633, 629, 1638, 1636,
        1633, 1641, 598, 1605, 1604, 1602, 1600, 605, 1609, 1607, 2327, 887, 853, 1775, 822, 820, 1757, 1755, 1584, 524,
        1560, 1558, 468, 464, 1514, 1511, 1508, 1519, 408, 404, 400, 1452, 1447, 1444, 417, 1458, 1455, 2208, 364, 361,
        358, 2154, 1401, 1400, 1398, 1396, 374, 1393, 371, 1408, 1406, 1403, 1413, 2173, 2172, 772, 726, 723, 1712, 672,
        669, 666, 682, 1678, 1675, 625, 623, 621, 618, 2331, 636, 632, 1639, 1637, 1635, 920, 918, 884, 880, 889, 849,
        848, 847, 846, 2497, 855, 852, 1776, 2641, 2742, 2787, 1380, 334, 1367, 1365, 301, 297, 1340, 1338, 1335, 1343,
        255, 251, 247, 1296, 1291, 1288, 265, 1302, 1299, 2113, 204, 196, 192, 2042, 1232, 1230, 1224, 214, 1220, 210,
        1242, 1239, 1235, 1250, 2077, 2075, 151, 148, 1993, 144, 1990, 1163, 1162, 1160, 1158, 1155, 161, 1152, 157,
        1173, 1171, 1168, 1165, 168, 1181, 1178, 2021, 2020, 2018, 2023, 585, 560, 557, 1585, 516, 509, 1562, 1559, 458,
        447, 2227, 472, 1516, 1513, 1510, 398, 396, 393, 390, 2181, 386, 2178, 407, 1453, 1451, 1449, 1446, 420, 1460,
        2209, 769, 764, 720, 712, 2391, 729, 1713, 664, 663, 661, 659, 2352, 656, 2349, 671, 1679, 1677, 2553, 922, 919,
        2519, 2516, 885, 883, 881, 2685, 2661, 2659, 2767, 2756, 2755, 140, 1137, 1136, 130, 127, 1125, 1124, 1122, 1127,
        109, 106, 102, 1103, 1102, 1100, 1098, 116, 1107, 1105, 1980, 80, 76, 73, 1947, 1068, 1067, 1065, 1063, 90, 1060,
        87, 1075, 1073, 1070, 1080, 1966, 1965, 46, 43, 40, 1912, 36, 1909, 1019, 1018, 1016, 1014, 58, 1011, 55, 1008,
        51, 1029, 1027, 1024, 1021, 63, 1037, 1034, 1940, 1939, 1937, 1942, 8, 1866, 4, 1863, 1, 1860, 956, 954, 952,
        949, 946, 17, 14, 969, 967, 964, 961, 27, 957, 24, 979, 976, 972, 1901, 1900, 1898, 1896, 986, 1905, 1903, 350,
        349, 1381, 329, 327, 324, 1368, 1366, 292, 290, 287, 284, 2118, 304, 1341, 1339, 1337, 1345, 243, 240, 237, 2086,
        233, 2083, 254, 1297, 1295, 1293, 1290, 1304, 2114, 190, 187, 184, 2034, 180, 2031, 177, 2027, 199, 1233, 1231,
        1229, 1226, 217, 1223, 1241, 2078, 2076, 584, 555, 554, 552, 550, 2282, 562, 1586, 507, 506, 504, 502, 2257, 499,
        2254, 515, 1563, 1561, 445, 443, 441, 2219, 438, 2216, 435, 2212, 460, 454, 475, 1517, 1515, 1512, 2447, 798,
        797, 2422, 2419, 770, 768, 766, 2383, 2380, 2376, 721, 719, 717, 714, 731, 1714, 2602, 2582, 2580, 2548, 2546,
        2543, 923, 921, 2717, 2706, 2705, 2683, 2682, 2680, 1771, 1752, 1750, 1733, 1732, 1731, 1735, 1814, 1707, 1670,
        1668, 1631, 1629, 1626, 1634, 1599, 1598, 1596, 1594, 1603, 1601, 2326, 1772, 1753, 1751, 1581, 1554, 1552, 1504,
        1501, 1498, 1509, 1442, 1437, 1434, 401, 1448, 1445, 2206, 1392, 1391, 1389, 1387, 1384, 359, 1399, 1397, 1394,
        1404, 2171, 2170, 1708, 1672, 1669, 619, 1632, 1630, 1628, 1773, 1378, 1363, 1361, 1333, 1328, 1336, 1286, 1281,
        1278, 248, 1292, 1289, 2111, 1218, 1216, 1210, 197, 1206, 193, 1228, 1225, 1221, 1236, 2073, 2071, 1151, 1150,
        1148, 1146, 152, 1143, 149, 1140, 145, 1161, 1159, 1156, 1153, 158, 1169, 1166, 2017, 2016, 2014, 2019, 1582,
        510, 1556, 1553, 452, 448, 1506, 1500, 394, 391, 387, 1443, 1441, 1439, 1436, 1450, 2207, 765, 716, 713, 1709,
        662, 660, 657, 1673, 1671, 916, 914, 879, 878, 877, 882, 1135, 1134, 1121, 1120, 1118, 1123, 1097, 1096, 1094,
        1092, 103, 1101, 1099, 1979, 1059, 1058, 1056, 1054, 77, 1051, 74, 1066, 1064, 1061, 1071, 1964, 1963, 1007,
        1006, 1004, 1002, 999, 41, 996, 37, 1017, 1015, 1012, 1009, 52, 1025, 1022, 1936, 1935, 1933, 1938, 942, 940,
        938, 935, 932, 5, 2, 955, 953, 950, 947, 18, 943, 15, 965, 962, 958, 1895, 1894, 1892, 1890, 973, 1899, 1897,
        1379, 325, 1364, 1362, 288, 285, 1334, 1332, 1330, 241, 238, 234, 1287, 1285, 1283, 1280, 1294, 2112, 188, 185,
        181, 178, 2028, 1219, 1217, 1215, 1212, 200, 1209, 1227, 2074, 2072, 583, 553, 551, 1583, 505, 503, 500, 513,
        1557, 1555, 444, 442, 439, 436, 2213, 455, 451, 1507, 1505, 1502, 796, 763, 762, 760, 767, 711, 710, 708, 706,
        2377, 718, 715, 1710, 2544, 917, 915, 2681, 1627, 1597, 1595, 2325, 1769, 1749, 1747, 1499, 1438, 1435, 2204,
        1390, 1388, 1385, 1395, 2169, 2167, 1704, 1665, 1662, 1625, 1623, 1620, 1770, 1329, 1282, 1279, 2109, 1214, 1207,
        1222, 2068, 2065, 1149, 1147, 1144, 1141, 146, 1157, 1154, 2013, 2011, 2008, 2015, 1579, 1549, 1546, 1495, 1487,
        1433, 1431, 1428, 1425, 388, 1440, 2205, 1705, 658, 1667, 1664, 1119, 1095, 1093, 1978, 1057, 1055, 1052, 1062,
        1962, 1960, 1005, 1003, 1000, 997, 38, 1013, 1010, 1932, 1930, 1927, 1934, 941, 939, 936, 933, 6, 930, 3, 951,
        948, 944, 1889, 1887, 1884, 1881, 959, 1893, 1891, 35, 1377, 1360, 1358, 1327, 1325, 1322, 1331, 1277, 1275,
        1272, 1269, 235, 1284, 2110, 1205, 1204, 1201, 1198, 182, 1195, 179, 1213, 2070, 2067, 1580, 501, 1551, 1548,
        440, 437, 1497, 1494, 1490, 1503, 761, 709, 707, 1706, 913, 912, 2198, 1386, 2164, 2161, 1621, 1766, 2103, 1208,
        2058, 2054, 1145, 1142, 2005, 2002, 1999, 2009, 1488, 1429, 1426, 2200, 1698, 1659, 1656, 1975, 1053, 1957, 1954,
        1001, 998, 1924, 1921, 1918, 1928, 937, 934, 931, 1879, 1876, 1873, 1870, 945, 1885, 1882, 1323, 1273, 1270,
        2105, 1202, 1199, 1196, 1211, 2061, 2057, 1576, 1543, 1540, 1484, 1481, 1478, 1491, 1700
    ]);
    return PDF417Common;
}());
exports.default = PDF417Common;
//# sourceMappingURL=PDF417Common.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417Reader.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/PDF417Reader.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417;
// import com.google.zxing.BarcodeFormat;
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
// import com.google.zxing.ChecksumException;
var ChecksumException_1 = __webpack_require__(/*! ../ChecksumException */ "./node_modules/@zxing/library/esm5/core/ChecksumException.js");
// import com.google.zxing.FormatException;
var FormatException_1 = __webpack_require__(/*! ../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
// import com.google.zxing.NotFoundException;
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
// import com.google.zxing.Result;
var Result_1 = __webpack_require__(/*! ../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
// import com.google.zxing.common.DecoderResult;
// import com.google.zxing.multi.MultipleBarcodeReader;
// import com.google.zxing.pdf417.decoder.PDF417ScanningDecoder;
// import com.google.zxing.pdf417.detector.Detector;
// import com.google.zxing.pdf417.detector.PDF417DetectorResult;
var PDF417Common_1 = __webpack_require__(/*! ./PDF417Common */ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417Common.js");
var Integer_1 = __webpack_require__(/*! ../util/Integer */ "./node_modules/@zxing/library/esm5/core/util/Integer.js");
var ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ "./node_modules/@zxing/library/esm5/core/ResultMetadataType.js");
var Detector_1 = __webpack_require__(/*! ./detector/Detector */ "./node_modules/@zxing/library/esm5/core/pdf417/detector/Detector.js");
var PDF417ScanningDecoder_1 = __webpack_require__(/*! ./decoder/PDF417ScanningDecoder */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/PDF417ScanningDecoder.js");
// import java.util.ArrayList;
// import java.util.List;
// import java.util.Map;
/**
 * This implementation can detect and decode PDF417 codes in an image.
 *
 * @author Guenther Grau
 */
var PDF417Reader = /** @class */ (function () {
    function PDF417Reader() {
    }
    // private static /*final Result[]*/ EMPTY_RESULT_ARRAY: Result[] = new Result([0]);
    /**
     * Locates and decodes a PDF417 code in an image.
     *
     * @return a String representing the content encoded by the PDF417 code
     * @throws NotFoundException if a PDF417 code cannot be found,
     * @throws FormatException if a PDF417 cannot be decoded
     * @throws ChecksumException
     */
    // @Override
    PDF417Reader.prototype.decode = function (image, hints) {
        if (hints === void 0) { hints = null; }
        var result = PDF417Reader.decode(image, hints, false);
        if (result == null || result.length === 0 || result[0] == null) {
            throw NotFoundException_1.default.getNotFoundInstance();
        }
        return result[0];
    };
    /**
     *
     * @param BinaryBitmap
     * @param image
     * @throws NotFoundException
     */
    //   @Override
    PDF417Reader.prototype.decodeMultiple = function (image, hints) {
        if (hints === void 0) { hints = null; }
        try {
            return PDF417Reader.decode(image, hints, true);
        }
        catch (ignored) {
            if (ignored instanceof FormatException_1.default || ignored instanceof ChecksumException_1.default) {
                throw NotFoundException_1.default.getNotFoundInstance();
            }
            throw ignored;
        }
    };
    /**
     *
     * @param image
     * @param hints
     * @param multiple
     *
     * @throws NotFoundException
     * @throws FormatExceptionÃŸ
     * @throws ChecksumException
     */
    PDF417Reader.decode = function (image, hints, multiple) {
        var e_1, _a;
        var results = new Array();
        var detectorResult = Detector_1.default.detectMultiple(image, hints, multiple);
        try {
            for (var _b = __values(detectorResult.getPoints()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var points = _c.value;
                var decoderResult = PDF417ScanningDecoder_1.default.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));
                var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.PDF_417);
                result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());
                var pdf417ResultMetadata = decoderResult.getOther();
                if (pdf417ResultMetadata != null) {
                    result.putMetadata(ResultMetadataType_1.default.PDF417_EXTRA_METADATA, pdf417ResultMetadata);
                }
                results.push(result);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return results.map(function (x) { return x; });
    };
    PDF417Reader.getMaxWidth = function (p1, p2) {
        if (p1 == null || p2 == null) {
            return 0;
        }
        return Math.trunc(Math.abs(p1.getX() - p2.getX()));
    };
    PDF417Reader.getMinWidth = function (p1, p2) {
        if (p1 == null || p2 == null) {
            return Integer_1.default.MAX_VALUE;
        }
        return Math.trunc(Math.abs(p1.getX() - p2.getX()));
    };
    PDF417Reader.getMaxCodewordWidth = function (p) {
        return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p[0], p[4]), PDF417Reader.getMaxWidth(p[6], p[2]) * PDF417Common_1.default.MODULES_IN_CODEWORD /
            PDF417Common_1.default.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p[1], p[5]), PDF417Reader.getMaxWidth(p[7], p[3]) * PDF417Common_1.default.MODULES_IN_CODEWORD /
            PDF417Common_1.default.MODULES_IN_STOP_PATTERN)));
    };
    PDF417Reader.getMinCodewordWidth = function (p) {
        return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p[0], p[4]), PDF417Reader.getMinWidth(p[6], p[2]) * PDF417Common_1.default.MODULES_IN_CODEWORD /
            PDF417Common_1.default.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p[1], p[5]), PDF417Reader.getMinWidth(p[7], p[3]) * PDF417Common_1.default.MODULES_IN_CODEWORD /
            PDF417Common_1.default.MODULES_IN_STOP_PATTERN)));
    };
    // @Override
    PDF417Reader.prototype.reset = function () {
        // nothing needs to be reset
    };
    return PDF417Reader;
}());
exports.default = PDF417Reader;
//# sourceMappingURL=PDF417Reader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417ResultMetadata.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/PDF417ResultMetadata.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2013 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417;
/**
 * @author Guenther Grau
 */
var PDF417ResultMetadata = /** @class */ (function () {
    function PDF417ResultMetadata() {
        this.segmentCount = -1;
        this.fileSize = -1;
        this.timestamp = -1;
        this.checksum = -1;
    }
    /**
     * The Segment ID represents the segment of the whole file distributed over different symbols.
     *
     * @return File segment index
     */
    PDF417ResultMetadata.prototype.getSegmentIndex = function () {
        return this.segmentIndex;
    };
    PDF417ResultMetadata.prototype.setSegmentIndex = function (segmentIndex) {
        this.segmentIndex = segmentIndex;
    };
    /**
     * Is the same for each related PDF417 symbol
     *
     * @return File ID
     */
    PDF417ResultMetadata.prototype.getFileId = function () {
        return this.fileId;
    };
    PDF417ResultMetadata.prototype.setFileId = function (fileId) {
        this.fileId = fileId;
    };
    /**
     * @return always null
     * @deprecated use dedicated already parsed fields
     */
    //   @Deprecated
    PDF417ResultMetadata.prototype.getOptionalData = function () {
        return this.optionalData;
    };
    /**
     * @param optionalData old optional data format as int array
     * @deprecated parse and use new fields
     */
    //   @Deprecated
    PDF417ResultMetadata.prototype.setOptionalData = function (optionalData) {
        this.optionalData = optionalData;
    };
    /**
     * @return true if it is the last segment
     */
    PDF417ResultMetadata.prototype.isLastSegment = function () {
        return this.lastSegment;
    };
    PDF417ResultMetadata.prototype.setLastSegment = function (lastSegment) {
        this.lastSegment = lastSegment;
    };
    /**
     * @return count of segments, -1 if not set
     */
    PDF417ResultMetadata.prototype.getSegmentCount = function () {
        return this.segmentCount;
    };
    PDF417ResultMetadata.prototype.setSegmentCount = function (segmentCount /*int*/) {
        this.segmentCount = segmentCount;
    };
    PDF417ResultMetadata.prototype.getSender = function () {
        return this.sender || null;
    };
    PDF417ResultMetadata.prototype.setSender = function (sender) {
        this.sender = sender;
    };
    PDF417ResultMetadata.prototype.getAddressee = function () {
        return this.addressee || null;
    };
    PDF417ResultMetadata.prototype.setAddressee = function (addressee) {
        this.addressee = addressee;
    };
    /**
     * Filename of the encoded file
     *
     * @return filename
     */
    PDF417ResultMetadata.prototype.getFileName = function () {
        return this.fileName;
    };
    PDF417ResultMetadata.prototype.setFileName = function (fileName) {
        this.fileName = fileName;
    };
    /**
     * filesize in bytes of the encoded file
     *
     * @return filesize in bytes, -1 if not set
     */
    PDF417ResultMetadata.prototype.getFileSize = function () {
        return this.fileSize;
    };
    PDF417ResultMetadata.prototype.setFileSize = function (fileSize /*long*/) {
        this.fileSize = fileSize;
    };
    /**
     * 16-bit CRC checksum using CCITT-16
     *
     * @return crc checksum, -1 if not set
     */
    PDF417ResultMetadata.prototype.getChecksum = function () {
        return this.checksum;
    };
    PDF417ResultMetadata.prototype.setChecksum = function (checksum /*int*/) {
        this.checksum = checksum;
    };
    /**
     * unix epock timestamp, elapsed seconds since 1970-01-01
     *
     * @return elapsed seconds, -1 if not set
     */
    PDF417ResultMetadata.prototype.getTimestamp = function () {
        return this.timestamp;
    };
    PDF417ResultMetadata.prototype.setTimestamp = function (timestamp /*long*/) {
        this.timestamp = timestamp;
    };
    return PDF417ResultMetadata;
}());
exports.default = PDF417ResultMetadata;
//# sourceMappingURL=PDF417ResultMetadata.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/BarcodeMetadata.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/BarcodeMetadata.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2013 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder;
/**
 * @author Guenther Grau
 */
var BarcodeMetadata = /** @class */ (function () {
    function BarcodeMetadata(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {
        this.columnCount = columnCount;
        this.errorCorrectionLevel = errorCorrectionLevel;
        this.rowCountUpperPart = rowCountUpperPart;
        this.rowCountLowerPart = rowCountLowerPart;
        this.rowCount = rowCountUpperPart + rowCountLowerPart;
    }
    BarcodeMetadata.prototype.getColumnCount = function () {
        return this.columnCount;
    };
    BarcodeMetadata.prototype.getErrorCorrectionLevel = function () {
        return this.errorCorrectionLevel;
    };
    BarcodeMetadata.prototype.getRowCount = function () {
        return this.rowCount;
    };
    BarcodeMetadata.prototype.getRowCountUpperPart = function () {
        return this.rowCountUpperPart;
    };
    BarcodeMetadata.prototype.getRowCountLowerPart = function () {
        return this.rowCountLowerPart;
    };
    return BarcodeMetadata;
}());
exports.default = BarcodeMetadata;
//# sourceMappingURL=BarcodeMetadata.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/BarcodeValue.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/BarcodeValue.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2013 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder;
// import com.google.zxing.pdf417.PDF417Common;
var PDF417Common_1 = __webpack_require__(/*! ../PDF417Common */ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417Common.js");
// import java.util.ArrayList;
// import java.util.Collection;
// import java.util.HashMap;
// import java.util.Map;
// import java.util.Map.Entry;
/**
 * @author Guenther Grau
 */
var BarcodeValue = /** @class */ (function () {
    function BarcodeValue() {
        this.values = new Map();
    }
    /**
     * Add an occurrence of a value
     */
    BarcodeValue.prototype.setValue = function (value) {
        value = Math.trunc(value);
        var confidence = this.values.get(value);
        if (confidence == null) {
            confidence = 0;
        }
        confidence++;
        this.values.set(value, confidence);
    };
    /**
     * Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.
     * @return an array of int, containing the values with the highest occurrence, or null, if no value was set
     */
    BarcodeValue.prototype.getValue = function () {
        var e_1, _a;
        var maxConfidence = -1;
        var result = new Array();
        var _loop_1 = function (key, value) {
            var entry = {
                getKey: function () { return key; },
                getValue: function () { return value; },
            };
            if (entry.getValue() > maxConfidence) {
                maxConfidence = entry.getValue();
                result = [];
                result.push(entry.getKey());
            }
            else if (entry.getValue() === maxConfidence) {
                result.push(entry.getKey());
            }
        };
        try {
            for (var _b = __values(this.values.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                _loop_1(key, value);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return PDF417Common_1.default.toIntArray(result);
    };
    BarcodeValue.prototype.getConfidence = function (value) {
        return this.values.get(value);
    };
    return BarcodeValue;
}());
exports.default = BarcodeValue;
//# sourceMappingURL=BarcodeValue.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/BoundingBox.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/BoundingBox.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
* Copyright 2013 ZXing authors
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder;
// import com.google.zxing.NotFoundException;
var NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
// import com.google.zxing.ResultPoint;
var ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
/**
 * @author Guenther Grau
 */
var BoundingBox = /** @class */ (function () {
    function BoundingBox(image, topLeft, bottomLeft, topRight, bottomRight) {
        if (image instanceof BoundingBox) {
            this.constructor_2(image);
        }
        else {
            this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);
        }
    }
    /**
     *
     * @param image
     * @param topLeft
     * @param bottomLeft
     * @param topRight
     * @param bottomRight
     *
     * @throws NotFoundException
     */
    BoundingBox.prototype.constructor_1 = function (image, topLeft, bottomLeft, topRight, bottomRight) {
        var leftUnspecified = topLeft == null || bottomLeft == null;
        var rightUnspecified = topRight == null || bottomRight == null;
        if (leftUnspecified && rightUnspecified) {
            throw new NotFoundException_1.default();
        }
        if (leftUnspecified) {
            topLeft = new ResultPoint_1.default(0, topRight.getY());
            bottomLeft = new ResultPoint_1.default(0, bottomRight.getY());
        }
        else if (rightUnspecified) {
            topRight = new ResultPoint_1.default(image.getWidth() - 1, topLeft.getY());
            bottomRight = new ResultPoint_1.default(image.getWidth() - 1, bottomLeft.getY());
        }
        this.image = image;
        this.topLeft = topLeft;
        this.bottomLeft = bottomLeft;
        this.topRight = topRight;
        this.bottomRight = bottomRight;
        this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));
        this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));
        this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));
        this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));
    };
    BoundingBox.prototype.constructor_2 = function (boundingBox) {
        this.image = boundingBox.image;
        this.topLeft = boundingBox.getTopLeft();
        this.bottomLeft = boundingBox.getBottomLeft();
        this.topRight = boundingBox.getTopRight();
        this.bottomRight = boundingBox.getBottomRight();
        this.minX = boundingBox.getMinX();
        this.maxX = boundingBox.getMaxX();
        this.minY = boundingBox.getMinY();
        this.maxY = boundingBox.getMaxY();
    };
    /**
     * @throws NotFoundException
     */
    BoundingBox.merge = function (leftBox, rightBox) {
        if (leftBox == null) {
            return rightBox;
        }
        if (rightBox == null) {
            return leftBox;
        }
        return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);
    };
    /**
     * @throws NotFoundException
     */
    BoundingBox.prototype.addMissingRows = function (missingStartRows, missingEndRows, isLeft) {
        var newTopLeft = this.topLeft;
        var newBottomLeft = this.bottomLeft;
        var newTopRight = this.topRight;
        var newBottomRight = this.bottomRight;
        if (missingStartRows > 0) {
            var top_1 = isLeft ? this.topLeft : this.topRight;
            var newMinY = Math.trunc(top_1.getY() - missingStartRows);
            if (newMinY < 0) {
                newMinY = 0;
            }
            var newTop = new ResultPoint_1.default(top_1.getX(), newMinY);
            if (isLeft) {
                newTopLeft = newTop;
            }
            else {
                newTopRight = newTop;
            }
        }
        if (missingEndRows > 0) {
            var bottom = isLeft ? this.bottomLeft : this.bottomRight;
            var newMaxY = Math.trunc(bottom.getY() + missingEndRows);
            if (newMaxY >= this.image.getHeight()) {
                newMaxY = this.image.getHeight() - 1;
            }
            var newBottom = new ResultPoint_1.default(bottom.getX(), newMaxY);
            if (isLeft) {
                newBottomLeft = newBottom;
            }
            else {
                newBottomRight = newBottom;
            }
        }
        return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);
    };
    BoundingBox.prototype.getMinX = function () {
        return this.minX;
    };
    BoundingBox.prototype.getMaxX = function () {
        return this.maxX;
    };
    BoundingBox.prototype.getMinY = function () {
        return this.minY;
    };
    BoundingBox.prototype.getMaxY = function () {
        return this.maxY;
    };
    BoundingBox.prototype.getTopLeft = function () {
        return this.topLeft;
    };
    BoundingBox.prototype.getTopRight = function () {
        return this.topRight;
    };
    BoundingBox.prototype.getBottomLeft = function () {
        return this.bottomLeft;
    };
    BoundingBox.prototype.getBottomRight = function () {
        return this.bottomRight;
    };
    return BoundingBox;
}());
exports.default = BoundingBox;
//# sourceMappingURL=BoundingBox.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/Codeword.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/Codeword.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2013 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder;
/**
 * @author Guenther Grau
 */
var Codeword = /** @class */ (function () {
    function Codeword(startX, endX, bucket, value) {
        this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;
        this.startX = Math.trunc(startX);
        this.endX = Math.trunc(endX);
        this.bucket = Math.trunc(bucket);
        this.value = Math.trunc(value);
    }
    Codeword.prototype.hasValidRowNumber = function () {
        return this.isValidRowNumber(this.rowNumber);
    };
    Codeword.prototype.isValidRowNumber = function (rowNumber) {
        return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === (rowNumber % 3) * 3;
    };
    Codeword.prototype.setRowNumberAsRowIndicatorColumn = function () {
        this.rowNumber = Math.trunc((Math.trunc(this.value / 30)) * 3 + Math.trunc(this.bucket / 3));
    };
    Codeword.prototype.getWidth = function () {
        return this.endX - this.startX;
    };
    Codeword.prototype.getStartX = function () {
        return this.startX;
    };
    Codeword.prototype.getEndX = function () {
        return this.endX;
    };
    Codeword.prototype.getBucket = function () {
        return this.bucket;
    };
    Codeword.prototype.getValue = function () {
        return this.value;
    };
    Codeword.prototype.getRowNumber = function () {
        return this.rowNumber;
    };
    Codeword.prototype.setRowNumber = function (rowNumber) {
        this.rowNumber = rowNumber;
    };
    //   @Override
    Codeword.prototype.toString = function () {
        return this.rowNumber + '|' + this.value;
    };
    Codeword.BARCODE_ROW_UNKNOWN = -1;
    return Codeword;
}());
exports.default = Codeword;
//# sourceMappingURL=Codeword.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/DecodedBitStreamParser.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/DecodedBitStreamParser.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
/*
 * Copyright 2009 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder;
// import com.google.zxing.FormatException;
var FormatException_1 = __webpack_require__(/*! ../../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
// import com.google.zxing.common.CharacterSetECI;
var CharacterSetECI_1 = __webpack_require__(/*! ../../common/CharacterSetECI */ "./node_modules/@zxing/library/esm5/core/common/CharacterSetECI.js");
// import com.google.zxing.common.DecoderResult;
var DecoderResult_1 = __webpack_require__(/*! ../../common/DecoderResult */ "./node_modules/@zxing/library/esm5/core/common/DecoderResult.js");
// import com.google.zxing.pdf417.PDF417ResultMetadata;
var PDF417ResultMetadata_1 = __webpack_require__(/*! ../PDF417ResultMetadata */ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417ResultMetadata.js");
// import java.io.ByteArrayOutputStream;
// import java.math.BigInteger;
// import java.nio.charset.Charset;
// import java.nio.charset.StandardCharsets;
// import java.util.Arrays;
var Arrays_1 = __webpack_require__(/*! ../../util/Arrays */ "./node_modules/@zxing/library/esm5/core/util/Arrays.js");
var StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var Integer_1 = __webpack_require__(/*! ../../util/Integer */ "./node_modules/@zxing/library/esm5/core/util/Integer.js");
var Long_1 = __webpack_require__(/*! ../../util/Long */ "./node_modules/@zxing/library/esm5/core/util/Long.js");
var ByteArrayOutputStream_1 = __webpack_require__(/*! ../../util/ByteArrayOutputStream */ "./node_modules/@zxing/library/esm5/core/util/ByteArrayOutputStream.js");
var StringEncoding_1 = __webpack_require__(/*! ../../util/StringEncoding */ "./node_modules/@zxing/library/esm5/core/util/StringEncoding.js");
/*private*/ var Mode;
(function (Mode) {
    Mode[Mode["ALPHA"] = 0] = "ALPHA";
    Mode[Mode["LOWER"] = 1] = "LOWER";
    Mode[Mode["MIXED"] = 2] = "MIXED";
    Mode[Mode["PUNCT"] = 3] = "PUNCT";
    Mode[Mode["ALPHA_SHIFT"] = 4] = "ALPHA_SHIFT";
    Mode[Mode["PUNCT_SHIFT"] = 5] = "PUNCT_SHIFT";
})(Mode || (Mode = {}));
/**
 * Indirectly access the global BigInt constructor, it
 * allows browsers that doesn't support BigInt to run
 * the library without breaking due to "undefined BigInt"
 * errors.
 */
function getBigIntConstructor() {
    if (typeof window !== 'undefined') {
        return window['BigInt'] || null;
    }
    if (typeof global !== 'undefined') {
        return global['BigInt'] || null;
    }
    throw new Error('Can\'t search globals for BigInt!');
}
/**
 * Used to store the BigInt constructor.
 */
var BigInteger;
/**
 * This function creates a bigint value. It allows browsers
 * that doesn't support BigInt to run the rest of the library
 * by not directly accessing the BigInt constructor.
 */
function createBigInt(num) {
    if (typeof BigInteger === 'undefined') {
        BigInteger = getBigIntConstructor();
    }
    if (BigInteger === null) {
        throw new Error('BigInt is not supported!');
    }
    return BigInteger(num);
}
function getEXP900() {
    // in Java - array with length = 16
    var EXP900 = [];
    EXP900[0] = createBigInt(1);
    var nineHundred = createBigInt(900);
    EXP900[1] = nineHundred;
    // in Java - array with length = 16
    for (var i /*int*/ = 2; i < 16; i++) {
        EXP900[i] = EXP900[i - 1] * nineHundred;
    }
    return EXP900;
}
/**
 * <p>This class contains the methods for decoding the PDF417 codewords.</p>
 *
 * @author SITA Lab (kevin.osullivan@sita.aero)
 * @author Guenther Grau
 */
var DecodedBitStreamParser = /** @class */ (function () {
    function DecodedBitStreamParser() {
    }
    //   private DecodedBitStreamParser() {
    // }
    /**
     *
     * @param codewords
     * @param ecLevel
     *
     * @throws FormatException
     */
    DecodedBitStreamParser.decode = function (codewords, ecLevel) {
        // pass encoding to result (will be used for decode symbols in byte mode)
        var result = new StringBuilder_1.default('');
        // let encoding: Charset = StandardCharsets.ISO_8859_1;
        var encoding = CharacterSetECI_1.default.ISO8859_1;
        /**
         * @note the next command is specific from this TypeScript library
         * because TS can't properly cast some values to char and
         * convert it to string later correctly due to encoding
         * differences from Java version. As reported here:
         * https://github.com/zxing-js/library/pull/264/files#r382831593
         */
        result.enableDecoding(encoding);
        // Get compaction mode
        var codeIndex = 1;
        var code = codewords[codeIndex++];
        var resultMetadata = new PDF417ResultMetadata_1.default();
        while (codeIndex < codewords[0]) {
            switch (code) {
                case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                    codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);
                    break;
                case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                    codeIndex = DecodedBitStreamParser.byteCompaction(code, codewords, encoding, codeIndex, result);
                    break;
                case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(/*(char)*/ codewords[codeIndex++]);
                    break;
                case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:
                    codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex, result);
                    break;
                case DecodedBitStreamParser.ECI_CHARSET:
                    var charsetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(codewords[codeIndex++]);
                    // encoding = Charset.forName(charsetECI.getName());
                    break;
                case DecodedBitStreamParser.ECI_GENERAL_PURPOSE:
                    // Can't do anything with generic ECI; skip its 2 characters
                    codeIndex += 2;
                    break;
                case DecodedBitStreamParser.ECI_USER_DEFINED:
                    // Can't do anything with user ECI; skip its 1 character
                    codeIndex++;
                    break;
                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                    codeIndex = DecodedBitStreamParser.decodeMacroBlock(codewords, codeIndex, resultMetadata);
                    break;
                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                    // Should not see these outside a macro block
                    throw new FormatException_1.default();
                default:
                    // Default to text compaction. During testing numerous barcodes
                    // appeared to be missing the starting mode. In these cases defaulting
                    // to text compaction seems to work.
                    codeIndex--;
                    codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, result);
                    break;
            }
            if (codeIndex < codewords.length) {
                code = codewords[codeIndex++];
            }
            else {
                throw FormatException_1.default.getFormatInstance();
            }
        }
        if (result.length() === 0) {
            throw FormatException_1.default.getFormatInstance();
        }
        var decoderResult = new DecoderResult_1.default(null, result.toString(), null, ecLevel);
        decoderResult.setOther(resultMetadata);
        return decoderResult;
    };
    /**
     *
     * @param int
     * @param param1
     * @param codewords
     * @param int
     * @param codeIndex
     * @param PDF417ResultMetadata
     * @param resultMetadata
     *
     * @throws FormatException
     */
    // @SuppressWarnings("deprecation")
    DecodedBitStreamParser.decodeMacroBlock = function (codewords, codeIndex, resultMetadata) {
        if (codeIndex + DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {
            // we must have at least two bytes left for the segment index
            throw FormatException_1.default.getFormatInstance();
        }
        var segmentIndexArray = new Int32Array(DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS);
        for (var i /*int*/ = 0; i < DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS; i++, codeIndex++) {
            segmentIndexArray[i] = codewords[codeIndex];
        }
        resultMetadata.setSegmentIndex(Integer_1.default.parseInt(DecodedBitStreamParser.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS)));
        var fileId = new StringBuilder_1.default();
        codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex, fileId);
        resultMetadata.setFileId(fileId.toString());
        var optionalFieldsStart = -1;
        if (codewords[codeIndex] === DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
            optionalFieldsStart = codeIndex + 1;
        }
        while (codeIndex < codewords[0]) {
            switch (codewords[codeIndex]) {
                case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                    codeIndex++;
                    switch (codewords[codeIndex]) {
                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                            var fileName = new StringBuilder_1.default();
                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, fileName);
                            resultMetadata.setFileName(fileName.toString());
                            break;
                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                            var sender = new StringBuilder_1.default();
                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, sender);
                            resultMetadata.setSender(sender.toString());
                            break;
                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                            var addressee = new StringBuilder_1.default();
                            codeIndex = DecodedBitStreamParser.textCompaction(codewords, codeIndex + 1, addressee);
                            resultMetadata.setAddressee(addressee.toString());
                            break;
                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                            var segmentCount = new StringBuilder_1.default();
                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, segmentCount);
                            resultMetadata.setSegmentCount(Integer_1.default.parseInt(segmentCount.toString()));
                            break;
                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                            var timestamp = new StringBuilder_1.default();
                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, timestamp);
                            resultMetadata.setTimestamp(Long_1.default.parseLong(timestamp.toString()));
                            break;
                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                            var checksum = new StringBuilder_1.default();
                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, checksum);
                            resultMetadata.setChecksum(Integer_1.default.parseInt(checksum.toString()));
                            break;
                        case DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                            var fileSize = new StringBuilder_1.default();
                            codeIndex = DecodedBitStreamParser.numericCompaction(codewords, codeIndex + 1, fileSize);
                            resultMetadata.setFileSize(Long_1.default.parseLong(fileSize.toString()));
                            break;
                        default:
                            throw FormatException_1.default.getFormatInstance();
                    }
                    break;
                case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                    codeIndex++;
                    resultMetadata.setLastSegment(true);
                    break;
                default:
                    throw FormatException_1.default.getFormatInstance();
            }
        }
        // copy optional fields to additional options
        if (optionalFieldsStart !== -1) {
            var optionalFieldsLength = codeIndex - optionalFieldsStart;
            if (resultMetadata.isLastSegment()) {
                // do not include terminator
                optionalFieldsLength--;
            }
            resultMetadata.setOptionalData(Arrays_1.default.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));
        }
        return codeIndex;
    };
    /**
     * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be
     * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as
     * well as selected control characters.
     *
     * @param codewords The array of codewords (data + error)
     * @param codeIndex The current index into the codeword array.
     * @param result    The decoded data is appended to the result.
     * @return The next index into the codeword array.
     */
    DecodedBitStreamParser.textCompaction = function (codewords, codeIndex, result) {
        // 2 character per codeword
        var textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
        // Used to hold the byte compaction value if there is a mode shift
        var byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
        var index = 0;
        var end = false;
        while ((codeIndex < codewords[0]) && !end) {
            var code = codewords[codeIndex++];
            if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {
                textCompactionData[index] = code / 30;
                textCompactionData[index + 1] = code % 30;
                index += 2;
            }
            else {
                switch (code) {
                    case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                        // reinitialize text compaction mode to alpha sub mode
                        textCompactionData[index++] = DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH;
                        break;
                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                    case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:
                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                    case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                        codeIndex--;
                        end = true;
                        break;
                    case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                        // The Mode Shift codeword 913 shall cause a temporary
                        // switch from Text Compaction mode to Byte Compaction mode.
                        // This switch shall be in effect for only the next codeword,
                        // after which the mode shall revert to the prevailing sub-mode
                        // of the Text Compaction mode. Codeword 913 is only available
                        // in Text Compaction mode; its use is described in 5.4.2.4.
                        textCompactionData[index] = DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
                        code = codewords[codeIndex++];
                        byteCompactionData[index] = code;
                        index++;
                        break;
                }
            }
        }
        DecodedBitStreamParser.decodeTextCompaction(textCompactionData, byteCompactionData, index, result);
        return codeIndex;
    };
    /**
     * The Text Compaction mode includes all the printable ASCII characters
     * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab
     * (9: e), LF or line feed (10: e), and CR or carriage
     * return (13: e). The Text Compaction mode also includes various latch
     * and shift characters which are used exclusively within the mode. The Text
     * Compaction mode encodes up to 2 characters per codeword. The compaction rules
     * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode
     * switches are defined in 5.4.2.3.
     *
     * @param textCompactionData The text compaction data.
     * @param byteCompactionData The byte compaction data if there
     *                           was a mode shift.
     * @param length             The size of the text compaction and byte compaction data.
     * @param result             The decoded data is appended to the result.
     */
    DecodedBitStreamParser.decodeTextCompaction = function (textCompactionData, byteCompactionData, length, result) {
        // Beginning from an initial state of the Alpha sub-mode
        // The default compaction mode for PDF417 in effect at the start of each symbol shall always be Text
        // Compaction mode Alpha sub-mode (alphabetic: uppercase). A latch codeword from another mode to the Text
        // Compaction mode shall always switch to the Text Compaction Alpha sub-mode.
        var subMode = Mode.ALPHA;
        var priorToShiftMode = Mode.ALPHA;
        var i = 0;
        while (i < length) {
            var subModeCh = textCompactionData[i];
            var ch = /*char*/ '';
            switch (subMode) {
                case Mode.ALPHA:
                    // Alpha (alphabetic: uppercase)
                    if (subModeCh < 26) {
                        // Upper case Alpha Character
                        // Note: 65 = 'A' ASCII -> there is byte code of symbol
                        ch = /*(char)('A' + subModeCh) */ String.fromCharCode(65 + subModeCh);
                    }
                    else {
                        switch (subModeCh) {
                            case 26:
                                ch = ' ';
                                break;
                            case DecodedBitStreamParser.LL:
                                subMode = Mode.LOWER;
                                break;
                            case DecodedBitStreamParser.ML:
                                subMode = Mode.MIXED;
                                break;
                            case DecodedBitStreamParser.PS:
                                // Shift to punctuation
                                priorToShiftMode = subMode;
                                subMode = Mode.PUNCT_SHIFT;
                                break;
                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                result.append(/*(char)*/ byteCompactionData[i]);
                                break;
                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                break;
                        }
                    }
                    break;
                case Mode.LOWER:
                    // Lower (alphabetic: lowercase)
                    if (subModeCh < 26) {
                        ch = /*(char)('a' + subModeCh)*/ String.fromCharCode(97 + subModeCh);
                    }
                    else {
                        switch (subModeCh) {
                            case 26:
                                ch = ' ';
                                break;
                            case DecodedBitStreamParser.AS:
                                // Shift to alpha
                                priorToShiftMode = subMode;
                                subMode = Mode.ALPHA_SHIFT;
                                break;
                            case DecodedBitStreamParser.ML:
                                subMode = Mode.MIXED;
                                break;
                            case DecodedBitStreamParser.PS:
                                // Shift to punctuation
                                priorToShiftMode = subMode;
                                subMode = Mode.PUNCT_SHIFT;
                                break;
                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                // TODO Does this need to use the current character encoding? See other occurrences below
                                result.append(/*(char)*/ byteCompactionData[i]);
                                break;
                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                break;
                        }
                    }
                    break;
                case Mode.MIXED:
                    // Mixed (punctuation: e)
                    if (subModeCh < DecodedBitStreamParser.PL) {
                        ch = DecodedBitStreamParser.MIXED_CHARS[subModeCh];
                    }
                    else {
                        switch (subModeCh) {
                            case DecodedBitStreamParser.PL:
                                subMode = Mode.PUNCT;
                                break;
                            case 26:
                                ch = ' ';
                                break;
                            case DecodedBitStreamParser.LL:
                                subMode = Mode.LOWER;
                                break;
                            case DecodedBitStreamParser.AL:
                                subMode = Mode.ALPHA;
                                break;
                            case DecodedBitStreamParser.PS:
                                // Shift to punctuation
                                priorToShiftMode = subMode;
                                subMode = Mode.PUNCT_SHIFT;
                                break;
                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                result.append(/*(char)*/ byteCompactionData[i]);
                                break;
                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                break;
                        }
                    }
                    break;
                case Mode.PUNCT:
                    // Punctuation
                    if (subModeCh < DecodedBitStreamParser.PAL) {
                        ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];
                    }
                    else {
                        switch (subModeCh) {
                            case DecodedBitStreamParser.PAL:
                                subMode = Mode.ALPHA;
                                break;
                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                result.append(/*(char)*/ byteCompactionData[i]);
                                break;
                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                break;
                        }
                    }
                    break;
                case Mode.ALPHA_SHIFT:
                    // Restore sub-mode
                    subMode = priorToShiftMode;
                    if (subModeCh < 26) {
                        ch = /*(char)('A' + subModeCh)*/ String.fromCharCode(65 + subModeCh);
                    }
                    else {
                        switch (subModeCh) {
                            case 26:
                                ch = ' ';
                                break;
                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                break;
                        }
                    }
                    break;
                case Mode.PUNCT_SHIFT:
                    // Restore sub-mode
                    subMode = priorToShiftMode;
                    if (subModeCh < DecodedBitStreamParser.PAL) {
                        ch = DecodedBitStreamParser.PUNCT_CHARS[subModeCh];
                    }
                    else {
                        switch (subModeCh) {
                            case DecodedBitStreamParser.PAL:
                                subMode = Mode.ALPHA;
                                break;
                            case DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                                // PS before Shift-to-Byte is used as a padding character,
                                // see 5.4.2.4 of the specification
                                result.append(/*(char)*/ byteCompactionData[i]);
                                break;
                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                                subMode = Mode.ALPHA;
                                break;
                        }
                    }
                    break;
            }
            // if (ch !== 0) {
            if (ch !== '') {
                // Append decoded character to result
                result.append(ch);
            }
            i++;
        }
    };
    /**
     * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.
     * This includes all ASCII characters value 0 to 127 inclusive and provides for international
     * character set support.
     *
     * @param mode      The byte compaction mode i.e. 901 or 924
     * @param codewords The array of codewords (data + error)
     * @param encoding  Currently active character encoding
     * @param codeIndex The current index into the codeword array.
     * @param result    The decoded data is appended to the result.
     * @return The next index into the codeword array.
     */
    DecodedBitStreamParser.byteCompaction = function (mode, codewords, encoding, codeIndex, result) {
        var decodedBytes = new ByteArrayOutputStream_1.default();
        var count = 0;
        var value = /*long*/ 0;
        var end = false;
        switch (mode) {
            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                // Total number of Byte Compaction characters to be encoded
                // is not a multiple of 6
                var byteCompactedCodewords = new Int32Array(6);
                var nextCode = codewords[codeIndex++];
                while ((codeIndex < codewords[0]) && !end) {
                    byteCompactedCodewords[count++] = nextCode;
                    // Base 900
                    value = 900 * value + nextCode;
                    nextCode = codewords[codeIndex++];
                    // perhaps it should be ok to check only nextCode >= TEXT_COMPACTION_MODE_LATCH
                    switch (nextCode) {
                        case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                        case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:
                        case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                        case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                        case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                            codeIndex--;
                            end = true;
                            break;
                        default:
                            if ((count % 5 === 0) && (count > 0)) {
                                // Decode every 5 codewords
                                // Convert to Base 256
                                for (var j /*int*/ = 0; j < 6; ++j) {
                                    /* @note
                                     * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.
                                     * So the next bitwise operation could not be done with simple numbers
                                     */
                                    decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
                                }
                                value = 0;
                                count = 0;
                            }
                            break;
                    }
                }
                // if the end of all codewords is reached the last codeword needs to be added
                if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {
                    byteCompactedCodewords[count++] = nextCode;
                }
                // If Byte Compaction mode is invoked with codeword 901,
                // the last group of codewords is interpreted directly
                // as one byte per codeword, without compaction.
                for (var i /*int*/ = 0; i < count; i++) {
                    decodedBytes.write(/*(byte)*/ byteCompactedCodewords[i]);
                }
                break;
            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                // Total number of Byte Compaction characters to be encoded
                // is an integer multiple of 6
                while (codeIndex < codewords[0] && !end) {
                    var code = codewords[codeIndex++];
                    if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {
                        count++;
                        // Base 900
                        value = 900 * value + code;
                    }
                    else {
                        switch (code) {
                            case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                            case DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH:
                            case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                            case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                            case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                                codeIndex--;
                                end = true;
                                break;
                        }
                    }
                    if ((count % 5 === 0) && (count > 0)) {
                        // Decode every 5 codewords
                        // Convert to Base 256
                        /* @note
                         * JavaScript stores numbers as 64 bits floating point numbers, but all bitwise operations are performed on 32 bits binary numbers.
                         * So the next bitwise operation could not be done with simple numbers
                        */
                        for (var j /*int*/ = 0; j < 6; ++j) {
                            decodedBytes.write(/*(byte)*/ Number(createBigInt(value) >> createBigInt(8 * (5 - j))));
                        }
                        value = 0;
                        count = 0;
                    }
                }
                break;
        }
        result.append(StringEncoding_1.default.decode(decodedBytes.toByteArray(), encoding));
        return codeIndex;
    };
    /**
     * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.
     *
     * @param codewords The array of codewords (data + error)
     * @param codeIndex The current index into the codeword array.
     * @param result    The decoded data is appended to the result.
     * @return The next index into the codeword array.
     *
     * @throws FormatException
     */
    DecodedBitStreamParser.numericCompaction = function (codewords, codeIndex /*int*/, result) {
        var count = 0;
        var end = false;
        var numericCodewords = new Int32Array(DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS);
        while (codeIndex < codewords[0] && !end) {
            var code = codewords[codeIndex++];
            if (codeIndex === codewords[0]) {
                end = true;
            }
            if (code < DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH) {
                numericCodewords[count] = code;
                count++;
            }
            else {
                switch (code) {
                    case DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH:
                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH:
                    case DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6:
                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                    case DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                    case DecodedBitStreamParser.MACRO_PDF417_TERMINATOR:
                        codeIndex--;
                        end = true;
                        break;
                }
            }
            if ((count % DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH || end) && count > 0) {
                // Re-invoking Numeric Compaction mode (by using codeword 902
                // while in Numeric Compaction mode) serves  to terminate the
                // current Numeric Compaction mode grouping as described in 5.4.4.2,
                // and then to start a new one grouping.
                result.append(DecodedBitStreamParser.decodeBase900toBase10(numericCodewords, count));
                count = 0;
            }
        }
        return codeIndex;
    };
    /**
     * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.
     *
     * @param codewords The array of codewords
     * @param count     The number of codewords
     * @return The decoded string representing the Numeric data.
     *
     * EXAMPLE
     * Encode the fifteen digit numeric string 000213298174000
     * Prefix the numeric string with a 1 and set the initial value of
     * t = 1 000 213 298 174 000
     * Calculate codeword 0
     * d0 = 1 000 213 298 174 000 mod 900 = 200
     *
     * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082
     * Calculate codeword 1
     * d1 = 1 111 348 109 082 mod 900 = 282
     *
     * t = 1 111 348 109 082 div 900 = 1 234 831 232
     * Calculate codeword 2
     * d2 = 1 234 831 232 mod 900 = 632
     *
     * t = 1 234 831 232 div 900 = 1 372 034
     * Calculate codeword 3
     * d3 = 1 372 034 mod 900 = 434
     *
     * t = 1 372 034 div 900 = 1 524
     * Calculate codeword 4
     * d4 = 1 524 mod 900 = 624
     *
     * t = 1 524 div 900 = 1
     * Calculate codeword 5
     * d5 = 1 mod 900 = 1
     * t = 1 div 900 = 0
     * Codeword sequence is: 1, 624, 434, 632, 282, 200
     *
     * Decode the above codewords involves
     *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +
     * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000
     *
     * Remove leading 1 =>  Result is 000213298174000
     *
     * @throws FormatException
     */
    DecodedBitStreamParser.decodeBase900toBase10 = function (codewords, count) {
        var result = createBigInt(0);
        for (var i /*int*/ = 0; i < count; i++) {
            result += DecodedBitStreamParser.EXP900[count - i - 1] * createBigInt(codewords[i]);
        }
        var resultString = result.toString();
        if (resultString.charAt(0) !== '1') {
            throw new FormatException_1.default();
        }
        return resultString.substring(1);
    };
    DecodedBitStreamParser.TEXT_COMPACTION_MODE_LATCH = 900;
    DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH = 901;
    DecodedBitStreamParser.NUMERIC_COMPACTION_MODE_LATCH = 902;
    DecodedBitStreamParser.BYTE_COMPACTION_MODE_LATCH_6 = 924;
    DecodedBitStreamParser.ECI_USER_DEFINED = 925;
    DecodedBitStreamParser.ECI_GENERAL_PURPOSE = 926;
    DecodedBitStreamParser.ECI_CHARSET = 927;
    DecodedBitStreamParser.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;
    DecodedBitStreamParser.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;
    DecodedBitStreamParser.MACRO_PDF417_TERMINATOR = 922;
    DecodedBitStreamParser.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;
    DecodedBitStreamParser.MAX_NUMERIC_CODEWORDS = 15;
    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;
    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;
    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;
    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;
    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;
    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;
    DecodedBitStreamParser.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;
    DecodedBitStreamParser.PL = 25;
    DecodedBitStreamParser.LL = 27;
    DecodedBitStreamParser.AS = 27;
    DecodedBitStreamParser.ML = 28;
    DecodedBitStreamParser.AL = 28;
    DecodedBitStreamParser.PS = 29;
    DecodedBitStreamParser.PAL = 29;
    DecodedBitStreamParser.PUNCT_CHARS = ';<>@[\\]_`~!\r\t,:\n-.$/"|*()?{}\'';
    DecodedBitStreamParser.MIXED_CHARS = '0123456789&\r\t,:#-.$/+%*=^';
    /**
     * Table containing values for the exponent of 900.
     * This is used in the numeric compaction decode algorithm.
     */
    DecodedBitStreamParser.EXP900 = getBigIntConstructor() ? getEXP900() : [];
    DecodedBitStreamParser.NUMBER_OF_SEQUENCE_CODEWORDS = 2;
    return DecodedBitStreamParser;
}());
exports.default = DecodedBitStreamParser;
//# sourceMappingURL=DecodedBitStreamParser.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../next/dist/compiled/webpack/global.js */ "./node_modules/next/dist/compiled/webpack/global.js")))

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/DetectionResult.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/DetectionResult.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2013 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder;
// import com.google.zxing.pdf417.PDF417Common;
var PDF417Common_1 = __webpack_require__(/*! ../PDF417Common */ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417Common.js");
var Formatter_1 = __webpack_require__(/*! ../../util/Formatter */ "./node_modules/@zxing/library/esm5/core/util/Formatter.js");
/**
 * @author Guenther Grau
 */
var DetectionResult = /** @class */ (function () {
    function DetectionResult(barcodeMetadata, boundingBox) {
        /*final*/ this.ADJUST_ROW_NUMBER_SKIP = 2;
        this.barcodeMetadata = barcodeMetadata;
        this.barcodeColumnCount = barcodeMetadata.getColumnCount();
        this.boundingBox = boundingBox;
        // this.detectionResultColumns = new DetectionResultColumn[this.barcodeColumnCount + 2];
        this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);
    }
    DetectionResult.prototype.getDetectionResultColumns = function () {
        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);
        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);
        var unadjustedCodewordCount = PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE;
        var previousUnadjustedCount;
        do {
            previousUnadjustedCount = unadjustedCodewordCount;
            unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();
        } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);
        return this.detectionResultColumns;
    };
    DetectionResult.prototype.adjustIndicatorColumnRowNumbers = function (detectionResultColumn) {
        if (detectionResultColumn != null) {
            detectionResultColumn
                .adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);
        }
    };
    // TODO ensure that no detected codewords with unknown row number are left
    // we should be able to estimate the row height and use it as a hint for the row number
    // we should also fill the rows top to bottom and bottom to top
    /**
     * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords
     * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers
     */
    DetectionResult.prototype.adjustRowNumbersAndGetCount = function () {
        var unadjustedCount = this.adjustRowNumbersByRow();
        if (unadjustedCount === 0) {
            return 0;
        }
        for (var barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {
            var codewords = this.detectionResultColumns[barcodeColumn].getCodewords();
            for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {
                if (codewords[codewordsRow] == null) {
                    continue;
                }
                if (!codewords[codewordsRow].hasValidRowNumber()) {
                    this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);
                }
            }
        }
        return unadjustedCount;
    };
    DetectionResult.prototype.adjustRowNumbersByRow = function () {
        this.adjustRowNumbersFromBothRI();
        // TODO we should only do full row adjustments if row numbers of left and right row indicator column match.
        // Maybe it's even better to calculated the height (rows: d) and divide it by the number of barcode
        // rows. This, together with the LRI and RRI row numbers should allow us to get a good estimate where a row
        // number starts and ends.
        var unadjustedCount = this.adjustRowNumbersFromLRI();
        return unadjustedCount + this.adjustRowNumbersFromRRI();
    };
    DetectionResult.prototype.adjustRowNumbersFromBothRI = function () {
        if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
            return;
        }
        var LRIcodewords = this.detectionResultColumns[0].getCodewords();
        var RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
        for (var codewordsRow /*int*/ = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {
            if (LRIcodewords[codewordsRow] != null &&
                RRIcodewords[codewordsRow] != null &&
                LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {
                for (var barcodeColumn /*int*/ = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {
                    var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                    if (codeword == null) {
                        continue;
                    }
                    codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());
                    if (!codeword.hasValidRowNumber()) {
                        this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;
                    }
                }
            }
        }
    };
    DetectionResult.prototype.adjustRowNumbersFromRRI = function () {
        if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
            return 0;
        }
        var unadjustedCount = 0;
        var codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
        for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
                continue;
            }
            var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
            var invalidRowCounts = 0;
            for (var barcodeColumn /*int*/ = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {
                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                if (codeword != null) {
                    invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
                    if (!codeword.hasValidRowNumber()) {
                        unadjustedCount++;
                    }
                }
            }
        }
        return unadjustedCount;
    };
    DetectionResult.prototype.adjustRowNumbersFromLRI = function () {
        if (this.detectionResultColumns[0] == null) {
            return 0;
        }
        var unadjustedCount = 0;
        var codewords = this.detectionResultColumns[0].getCodewords();
        for (var codewordsRow /*int*/ = 0; codewordsRow < codewords.length; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
                continue;
            }
            var rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
            var invalidRowCounts = 0;
            for (var barcodeColumn /*int*/ = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {
                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                if (codeword != null) {
                    invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
                    if (!codeword.hasValidRowNumber()) {
                        unadjustedCount++;
                    }
                }
            }
        }
        return unadjustedCount;
    };
    DetectionResult.adjustRowNumberIfValid = function (rowIndicatorRowNumber, invalidRowCounts, codeword) {
        if (codeword == null) {
            return invalidRowCounts;
        }
        if (!codeword.hasValidRowNumber()) {
            if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {
                codeword.setRowNumber(rowIndicatorRowNumber);
                invalidRowCounts = 0;
            }
            else {
                ++invalidRowCounts;
            }
        }
        return invalidRowCounts;
    };
    DetectionResult.prototype.adjustRowNumbers = function (barcodeColumn, codewordsRow, codewords) {
        var e_1, _a;
        var codeword = codewords[codewordsRow];
        var previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();
        var nextColumnCodewords = previousColumnCodewords;
        if (this.detectionResultColumns[barcodeColumn + 1] != null) {
            nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();
        }
        // let otherCodewords: Codeword[] = new Codeword[14];
        var otherCodewords = new Array(14);
        otherCodewords[2] = previousColumnCodewords[codewordsRow];
        otherCodewords[3] = nextColumnCodewords[codewordsRow];
        if (codewordsRow > 0) {
            otherCodewords[0] = codewords[codewordsRow - 1];
            otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];
            otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];
        }
        if (codewordsRow > 1) {
            otherCodewords[8] = codewords[codewordsRow - 2];
            otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];
            otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];
        }
        if (codewordsRow < codewords.length - 1) {
            otherCodewords[1] = codewords[codewordsRow + 1];
            otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];
            otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];
        }
        if (codewordsRow < codewords.length - 2) {
            otherCodewords[9] = codewords[codewordsRow + 2];
            otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];
            otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];
        }
        try {
            for (var otherCodewords_1 = __values(otherCodewords), otherCodewords_1_1 = otherCodewords_1.next(); !otherCodewords_1_1.done; otherCodewords_1_1 = otherCodewords_1.next()) {
                var otherCodeword = otherCodewords_1_1.value;
                if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {
                    return;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (otherCodewords_1_1 && !otherCodewords_1_1.done && (_a = otherCodewords_1.return)) _a.call(otherCodewords_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @return true, if row number was adjusted, false otherwise
     */
    DetectionResult.adjustRowNumber = function (codeword, otherCodeword) {
        if (otherCodeword == null) {
            return false;
        }
        if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {
            codeword.setRowNumber(otherCodeword.getRowNumber());
            return true;
        }
        return false;
    };
    DetectionResult.prototype.getBarcodeColumnCount = function () {
        return this.barcodeColumnCount;
    };
    DetectionResult.prototype.getBarcodeRowCount = function () {
        return this.barcodeMetadata.getRowCount();
    };
    DetectionResult.prototype.getBarcodeECLevel = function () {
        return this.barcodeMetadata.getErrorCorrectionLevel();
    };
    DetectionResult.prototype.setBoundingBox = function (boundingBox) {
        this.boundingBox = boundingBox;
    };
    DetectionResult.prototype.getBoundingBox = function () {
        return this.boundingBox;
    };
    DetectionResult.prototype.setDetectionResultColumn = function (barcodeColumn, detectionResultColumn) {
        this.detectionResultColumns[barcodeColumn] = detectionResultColumn;
    };
    DetectionResult.prototype.getDetectionResultColumn = function (barcodeColumn) {
        return this.detectionResultColumns[barcodeColumn];
    };
    // @Override
    DetectionResult.prototype.toString = function () {
        var rowIndicatorColumn = this.detectionResultColumns[0];
        if (rowIndicatorColumn == null) {
            rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];
        }
        // try (
        var formatter = new Formatter_1.default();
        // ) {
        for (var codewordsRow /*int*/ = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {
            formatter.format('CW %3d:', codewordsRow);
            for (var barcodeColumn /*int*/ = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {
                if (this.detectionResultColumns[barcodeColumn] == null) {
                    formatter.format('    |   ');
                    continue;
                }
                var codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
                if (codeword == null) {
                    formatter.format('    |   ');
                    continue;
                }
                formatter.format(' %3d|%3d', codeword.getRowNumber(), codeword.getValue());
            }
            formatter.format('%n');
        }
        return formatter.toString();
        // }
    };
    return DetectionResult;
}());
exports.default = DetectionResult;
//# sourceMappingURL=DetectionResult.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/DetectionResultColumn.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/DetectionResultColumn.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2013 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder;
// import java.util.Formatter;
var Formatter_1 = __webpack_require__(/*! ../../util/Formatter */ "./node_modules/@zxing/library/esm5/core/util/Formatter.js");
var BoundingBox_1 = __webpack_require__(/*! ./BoundingBox */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/BoundingBox.js");
/**
 * @author Guenther Grau
 */
var DetectionResultColumn = /** @class */ (function () {
    function DetectionResultColumn(boundingBox) {
        this.boundingBox = new BoundingBox_1.default(boundingBox);
        // this.codewords = new Codeword[boundingBox.getMaxY() - boundingBox.getMinY() + 1];
        this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);
    }
    /*final*/ DetectionResultColumn.prototype.getCodewordNearby = function (imageRow) {
        var codeword = this.getCodeword(imageRow);
        if (codeword != null) {
            return codeword;
        }
        for (var i = 1; i < DetectionResultColumn.MAX_NEARBY_DISTANCE; i++) {
            var nearImageRow = this.imageRowToCodewordIndex(imageRow) - i;
            if (nearImageRow >= 0) {
                codeword = this.codewords[nearImageRow];
                if (codeword != null) {
                    return codeword;
                }
            }
            nearImageRow = this.imageRowToCodewordIndex(imageRow) + i;
            if (nearImageRow < this.codewords.length) {
                codeword = this.codewords[nearImageRow];
                if (codeword != null) {
                    return codeword;
                }
            }
        }
        return null;
    };
    /*final int*/ DetectionResultColumn.prototype.imageRowToCodewordIndex = function (imageRow) {
        return imageRow - this.boundingBox.getMinY();
    };
    /*final void*/ DetectionResultColumn.prototype.setCodeword = function (imageRow, codeword) {
        this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;
    };
    /*final*/ DetectionResultColumn.prototype.getCodeword = function (imageRow) {
        return this.codewords[this.imageRowToCodewordIndex(imageRow)];
    };
    /*final*/ DetectionResultColumn.prototype.getBoundingBox = function () {
        return this.boundingBox;
    };
    /*final*/ DetectionResultColumn.prototype.getCodewords = function () {
        return this.codewords;
    };
    // @Override
    DetectionResultColumn.prototype.toString = function () {
        var e_1, _a;
        var formatter = new Formatter_1.default();
        var row = 0;
        try {
            for (var _b = __values(this.codewords), _c = _b.next(); !_c.done; _c = _b.next()) {
                var codeword = _c.value;
                if (codeword == null) {
                    formatter.format('%3d:    |   %n', row++);
                    continue;
                }
                formatter.format('%3d: %3d|%3d%n', row++, codeword.getRowNumber(), codeword.getValue());
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return formatter.toString();
    };
    DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;
    return DetectionResultColumn;
}());
exports.default = DetectionResultColumn;
//# sourceMappingURL=DetectionResultColumn.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2013 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// import com.google.zxing.pdf417.PDF417Common;
var PDF417Common_1 = __webpack_require__(/*! ../PDF417Common */ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417Common.js");
var BarcodeMetadata_1 = __webpack_require__(/*! ./BarcodeMetadata */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/BarcodeMetadata.js");
var DetectionResultColumn_1 = __webpack_require__(/*! ./DetectionResultColumn */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/DetectionResultColumn.js");
var BarcodeValue_1 = __webpack_require__(/*! ./BarcodeValue */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/BarcodeValue.js");
/**
 * @author Guenther Grau
 */
var DetectionResultRowIndicatorColumn = /** @class */ (function (_super) {
    __extends(DetectionResultRowIndicatorColumn, _super);
    function DetectionResultRowIndicatorColumn(boundingBox, isLeft) {
        var _this = _super.call(this, boundingBox) || this;
        _this._isLeft = isLeft;
        return _this;
    }
    DetectionResultRowIndicatorColumn.prototype.setRowNumbers = function () {
        var e_1, _a;
        try {
            for (var _b = __values(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var codeword = _c.value /*Codeword*/;
                if (codeword != null) {
                    codeword.setRowNumberAsRowIndicatorColumn();
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    // TODO implement properly
    // TODO maybe we should add missing codewords to store the correct row number to make
    // finding row numbers for other columns easier
    // use row height count to make detection of invalid row numbers more reliable
    DetectionResultRowIndicatorColumn.prototype.adjustCompleteIndicatorColumnRowNumbers = function (barcodeMetadata) {
        var codewords = this.getCodewords();
        this.setRowNumbers();
        this.removeIncorrectCodewords(codewords, barcodeMetadata);
        var boundingBox = this.getBoundingBox();
        var top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
        var bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
        var firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
        var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
        // We need to be careful using the average row height. Barcode could be skewed so that we have smaller and
        // taller rows
        // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();
        var barcodeRow = -1;
        var maxRowHeight = 1;
        var currentRowHeight = 0;
        for (var codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
                continue;
            }
            var codeword = codewords[codewordsRow];
            //      float expectedRowNumber = (codewordsRow - firstRow) / averageRowHeight;
            //      if (Math.abs(codeword.getRowNumber() - expectedRowNumber) > 2) {
            //        SimpleLog.log(LEVEL.WARNING,
            //            "Removing codeword, rowNumberSkew too high, codeword[" + codewordsRow + "]: Expected Row: " +
            //                expectedRowNumber + ", RealRow: " + codeword.getRowNumber() + ", value: " + codeword.getValue());
            //        codewords[codewordsRow] = null;
            //      }
            var rowDifference = codeword.getRowNumber() - barcodeRow;
            // TODO improve handling with case where first row indicator doesn't start with 0
            if (rowDifference === 0) {
                currentRowHeight++;
            }
            else if (rowDifference === 1) {
                maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
                currentRowHeight = 1;
                barcodeRow = codeword.getRowNumber();
            }
            else if (rowDifference < 0 ||
                codeword.getRowNumber() >= barcodeMetadata.getRowCount() ||
                rowDifference > codewordsRow) {
                codewords[codewordsRow] = null;
            }
            else {
                var checkedRows = void 0;
                if (maxRowHeight > 2) {
                    checkedRows = (maxRowHeight - 2) * rowDifference;
                }
                else {
                    checkedRows = rowDifference;
                }
                var closePreviousCodewordFound = checkedRows >= codewordsRow;
                for (var i /*int*/ = 1; i <= checkedRows && !closePreviousCodewordFound; i++) {
                    // there must be (height * rowDifference) number of codewords missing. For now we assume height = 1.
                    // This should hopefully get rid of most problems already.
                    closePreviousCodewordFound = codewords[codewordsRow - i] != null;
                }
                if (closePreviousCodewordFound) {
                    codewords[codewordsRow] = null;
                }
                else {
                    barcodeRow = codeword.getRowNumber();
                    currentRowHeight = 1;
                }
            }
        }
        // return (int) (averageRowHeight + 0.5);
    };
    DetectionResultRowIndicatorColumn.prototype.getRowHeights = function () {
        var e_2, _a;
        var barcodeMetadata = this.getBarcodeMetadata();
        if (barcodeMetadata == null) {
            return null;
        }
        this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);
        var result = new Int32Array(barcodeMetadata.getRowCount());
        try {
            for (var _b = __values(this.getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var codeword = _c.value /*Codeword*/;
                if (codeword != null) {
                    var rowNumber = codeword.getRowNumber();
                    if (rowNumber >= result.length) {
                        // We have more rows than the barcode metadata allows for, ignore them.
                        continue;
                    }
                    result[rowNumber]++;
                } // else throw exception?
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return result;
    };
    // TODO maybe we should add missing codewords to store the correct row number to make
    // finding row numbers for other columns easier
    // use row height count to make detection of invalid row numbers more reliable
    DetectionResultRowIndicatorColumn.prototype.adjustIncompleteIndicatorColumnRowNumbers = function (barcodeMetadata) {
        var boundingBox = this.getBoundingBox();
        var top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
        var bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
        var firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
        var lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
        // float averageRowHeight = (lastRow - firstRow) / /*(float)*/ barcodeMetadata.getRowCount();
        var codewords = this.getCodewords();
        var barcodeRow = -1;
        var maxRowHeight = 1;
        var currentRowHeight = 0;
        for (var codewordsRow /*int*/ = firstRow; codewordsRow < lastRow; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
                continue;
            }
            var codeword = codewords[codewordsRow];
            codeword.setRowNumberAsRowIndicatorColumn();
            var rowDifference = codeword.getRowNumber() - barcodeRow;
            // TODO improve handling with case where first row indicator doesn't start with 0
            if (rowDifference === 0) {
                currentRowHeight++;
            }
            else if (rowDifference === 1) {
                maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
                currentRowHeight = 1;
                barcodeRow = codeword.getRowNumber();
            }
            else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {
                codewords[codewordsRow] = null;
            }
            else {
                barcodeRow = codeword.getRowNumber();
                currentRowHeight = 1;
            }
        }
        // return (int) (averageRowHeight + 0.5);
    };
    DetectionResultRowIndicatorColumn.prototype.getBarcodeMetadata = function () {
        var e_3, _a;
        var codewords = this.getCodewords();
        var barcodeColumnCount = new BarcodeValue_1.default();
        var barcodeRowCountUpperPart = new BarcodeValue_1.default();
        var barcodeRowCountLowerPart = new BarcodeValue_1.default();
        var barcodeECLevel = new BarcodeValue_1.default();
        try {
            for (var codewords_1 = __values(codewords), codewords_1_1 = codewords_1.next(); !codewords_1_1.done; codewords_1_1 = codewords_1.next()) {
                var codeword = codewords_1_1.value /*Codeword*/;
                if (codeword == null) {
                    continue;
                }
                codeword.setRowNumberAsRowIndicatorColumn();
                var rowIndicatorValue = codeword.getValue() % 30;
                var codewordRowNumber = codeword.getRowNumber();
                if (!this._isLeft) {
                    codewordRowNumber += 2;
                }
                switch (codewordRowNumber % 3) {
                    case 0:
                        barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);
                        break;
                    case 1:
                        barcodeECLevel.setValue(rowIndicatorValue / 3);
                        barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);
                        break;
                    case 2:
                        barcodeColumnCount.setValue(rowIndicatorValue + 1);
                        break;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (codewords_1_1 && !codewords_1_1.done && (_a = codewords_1.return)) _a.call(codewords_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        // Maybe we should check if we have ambiguous values?
        if ((barcodeColumnCount.getValue().length === 0) ||
            (barcodeRowCountUpperPart.getValue().length === 0) ||
            (barcodeRowCountLowerPart.getValue().length === 0) ||
            (barcodeECLevel.getValue().length === 0) ||
            barcodeColumnCount.getValue()[0] < 1 ||
            barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common_1.default.MIN_ROWS_IN_BARCODE ||
            barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common_1.default.MAX_ROWS_IN_BARCODE) {
            return null;
        }
        var barcodeMetadata = new BarcodeMetadata_1.default(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);
        this.removeIncorrectCodewords(codewords, barcodeMetadata);
        return barcodeMetadata;
    };
    DetectionResultRowIndicatorColumn.prototype.removeIncorrectCodewords = function (codewords, barcodeMetadata) {
        // Remove codewords which do not match the metadata
        // TODO Maybe we should keep the incorrect codewords for the start and end positions?
        for (var codewordRow /*int*/ = 0; codewordRow < codewords.length; codewordRow++) {
            var codeword = codewords[codewordRow];
            if (codewords[codewordRow] == null) {
                continue;
            }
            var rowIndicatorValue = codeword.getValue() % 30;
            var codewordRowNumber = codeword.getRowNumber();
            if (codewordRowNumber > barcodeMetadata.getRowCount()) {
                codewords[codewordRow] = null;
                continue;
            }
            if (!this._isLeft) {
                codewordRowNumber += 2;
            }
            switch (codewordRowNumber % 3) {
                case 0:
                    if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {
                        codewords[codewordRow] = null;
                    }
                    break;
                case 1:
                    if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() ||
                        rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {
                        codewords[codewordRow] = null;
                    }
                    break;
                case 2:
                    if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {
                        codewords[codewordRow] = null;
                    }
                    break;
            }
        }
    };
    DetectionResultRowIndicatorColumn.prototype.isLeft = function () {
        return this._isLeft;
    };
    // @Override
    DetectionResultRowIndicatorColumn.prototype.toString = function () {
        return 'IsLeft: ' + this._isLeft + '\n' + _super.prototype.toString.call(this);
    };
    return DetectionResultRowIndicatorColumn;
}(DetectionResultColumn_1.default));
exports.default = DetectionResultRowIndicatorColumn;
//# sourceMappingURL=DetectionResultRowIndicatorColumn.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/PDF417CodewordDecoder.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/PDF417CodewordDecoder.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
* Copyright 2013 ZXing authors
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder;
// import com.google.zxing.common.detector.MathUtils;
var MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js");
// import com.google.zxing.pdf417.PDF417Common;
var PDF417Common_1 = __webpack_require__(/*! ../PDF417Common */ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417Common.js");
var Float_1 = __webpack_require__(/*! ../../util/Float */ "./node_modules/@zxing/library/esm5/core/util/Float.js");
/**
 * @author Guenther Grau
 * @author creatale GmbH (christoph.schulz@creatale.de)
 */
var PDF417CodewordDecoder = /** @class */ (function () {
    function PDF417CodewordDecoder() {
    }
    /* @note
     * this action have to be performed before first use of class
     * - static constructor
     * working with 32bit float (based from Java logic)
    */
    PDF417CodewordDecoder.initialize = function () {
        // Pre-computes the symbol ratio table.
        for ( /*int*/var i = 0; i < PDF417Common_1.default.SYMBOL_TABLE.length; i++) {
            var currentSymbol = PDF417Common_1.default.SYMBOL_TABLE[i];
            var currentBit = currentSymbol & 0x1;
            for ( /*int*/var j = 0; j < PDF417Common_1.default.BARS_IN_MODULE; j++) {
                var size = 0.0;
                while ((currentSymbol & 0x1) === currentBit) {
                    size += 1.0;
                    currentSymbol >>= 1;
                }
                currentBit = currentSymbol & 0x1;
                if (!PDF417CodewordDecoder.RATIOS_TABLE[i]) {
                    PDF417CodewordDecoder.RATIOS_TABLE[i] = new Array(PDF417Common_1.default.BARS_IN_MODULE);
                }
                PDF417CodewordDecoder.RATIOS_TABLE[i][PDF417Common_1.default.BARS_IN_MODULE - j - 1] = Math.fround(size / PDF417Common_1.default.MODULES_IN_CODEWORD);
            }
        }
        this.bSymbolTableReady = true;
    };
    PDF417CodewordDecoder.getDecodedValue = function (moduleBitCount) {
        var decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));
        if (decodedValue !== -1) {
            return decodedValue;
        }
        return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);
    };
    PDF417CodewordDecoder.sampleBitCounts = function (moduleBitCount) {
        var bitCountSum = MathUtils_1.default.sum(moduleBitCount);
        var result = new Int32Array(PDF417Common_1.default.BARS_IN_MODULE);
        var bitCountIndex = 0;
        var sumPreviousBits = 0;
        for ( /*int*/var i = 0; i < PDF417Common_1.default.MODULES_IN_CODEWORD; i++) {
            var sampleIndex = bitCountSum / (2 * PDF417Common_1.default.MODULES_IN_CODEWORD) +
                (i * bitCountSum) / PDF417Common_1.default.MODULES_IN_CODEWORD;
            if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {
                sumPreviousBits += moduleBitCount[bitCountIndex];
                bitCountIndex++;
            }
            result[bitCountIndex]++;
        }
        return result;
    };
    PDF417CodewordDecoder.getDecodedCodewordValue = function (moduleBitCount) {
        var decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);
        return PDF417Common_1.default.getCodeword(decodedValue) === -1 ? -1 : decodedValue;
    };
    PDF417CodewordDecoder.getBitValue = function (moduleBitCount) {
        var result = /*long*/ 0;
        for (var /*int*/ i = 0; i < moduleBitCount.length; i++) {
            for ( /*int*/var bit = 0; bit < moduleBitCount[i]; bit++) {
                result = (result << 1) | (i % 2 === 0 ? 1 : 0);
            }
        }
        return Math.trunc(result);
    };
    // working with 32bit float (as in Java)
    PDF417CodewordDecoder.getClosestDecodedValue = function (moduleBitCount) {
        var bitCountSum = MathUtils_1.default.sum(moduleBitCount);
        var bitCountRatios = new Array(PDF417Common_1.default.BARS_IN_MODULE);
        if (bitCountSum > 1) {
            for (var /*int*/ i = 0; i < bitCountRatios.length; i++) {
                bitCountRatios[i] = Math.fround(moduleBitCount[i] / bitCountSum);
            }
        }
        var bestMatchError = Float_1.default.MAX_VALUE;
        var bestMatch = -1;
        if (!this.bSymbolTableReady) {
            PDF417CodewordDecoder.initialize();
        }
        for ( /*int*/var j = 0; j < PDF417CodewordDecoder.RATIOS_TABLE.length; j++) {
            var error = 0.0;
            var ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j];
            for ( /*int*/var k = 0; k < PDF417Common_1.default.BARS_IN_MODULE; k++) {
                var diff = Math.fround(ratioTableRow[k] - bitCountRatios[k]);
                error += Math.fround(diff * diff);
                if (error >= bestMatchError) {
                    break;
                }
            }
            if (error < bestMatchError) {
                bestMatchError = error;
                bestMatch = PDF417Common_1.default.SYMBOL_TABLE[j];
            }
        }
        return bestMatch;
    };
    // flag that the table is ready for use
    PDF417CodewordDecoder.bSymbolTableReady = false;
    PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common_1.default.SYMBOL_TABLE.length).map(function (x) { return x = new Array(PDF417Common_1.default.BARS_IN_MODULE); });
    return PDF417CodewordDecoder;
}());
exports.default = PDF417CodewordDecoder;
//# sourceMappingURL=PDF417CodewordDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/PDF417ScanningDecoder.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/PDF417ScanningDecoder.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
* Copyright 2013 ZXing authors
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder;
// import com.google.zxing.ChecksumException;
var ChecksumException_1 = __webpack_require__(/*! ../../ChecksumException */ "./node_modules/@zxing/library/esm5/core/ChecksumException.js");
// import com.google.zxing.FormatException;
var FormatException_1 = __webpack_require__(/*! ../../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
// import com.google.zxing.NotFoundException;
var NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
// import com.google.zxing.common.detector.MathUtils;
var MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js");
// import com.google.zxing.pdf417.PDF417Common;
var PDF417Common_1 = __webpack_require__(/*! ../PDF417Common */ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417Common.js");
// import com.google.zxing.pdf417.decoder.ec.ErrorCorrection;
var ErrorCorrection_1 = __webpack_require__(/*! ./ec/ErrorCorrection */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ErrorCorrection.js");
// local
var BoundingBox_1 = __webpack_require__(/*! ./BoundingBox */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/BoundingBox.js");
var DetectionResultRowIndicatorColumn_1 = __webpack_require__(/*! ./DetectionResultRowIndicatorColumn */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/DetectionResultRowIndicatorColumn.js");
var DetectionResult_1 = __webpack_require__(/*! ./DetectionResult */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/DetectionResult.js");
var DetectionResultColumn_1 = __webpack_require__(/*! ./DetectionResultColumn */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/DetectionResultColumn.js");
var Codeword_1 = __webpack_require__(/*! ./Codeword */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/Codeword.js");
var BarcodeValue_1 = __webpack_require__(/*! ./BarcodeValue */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/BarcodeValue.js");
var PDF417CodewordDecoder_1 = __webpack_require__(/*! ./PDF417CodewordDecoder */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/PDF417CodewordDecoder.js");
var DecodedBitStreamParser_1 = __webpack_require__(/*! ./DecodedBitStreamParser */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/DecodedBitStreamParser.js");
// utils
var Formatter_1 = __webpack_require__(/*! ../../util/Formatter */ "./node_modules/@zxing/library/esm5/core/util/Formatter.js");
// import java.util.ArrayList;
// import java.util.Collection;
// import java.util.Formatter;
// import java.util.List;
/**
 * @author Guenther Grau
 */
var PDF417ScanningDecoder = /** @class */ (function () {
    function PDF417ScanningDecoder() {
    }
    /**
     * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern
     *
     * columns. That way width can be deducted from the pattern column.
     * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider
     * than it should be. This can happen if the scanner used a bad blackpoint.
     *
     * @param BitMatrix
     * @param image
     * @param ResultPoint
     * @param imageTopLeft
     * @param ResultPoint
     * @param imageBottomLeft
     * @param ResultPoint
     * @param imageTopRight
     * @param ResultPoint
     * @param imageBottomRight
     * @param int
     * @param minCodewordWidth
     * @param int
     * @param maxCodewordWidth
     *
     * @throws NotFoundException
     * @throws FormatException
     * @throws ChecksumException
     */
    PDF417ScanningDecoder.decode = function (image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {
        var boundingBox = new BoundingBox_1.default(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);
        var leftRowIndicatorColumn = null;
        var rightRowIndicatorColumn = null;
        var detectionResult;
        for (var firstPass /*boolean*/ = true;; firstPass = false) {
            if (imageTopLeft != null) {
                leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);
            }
            if (imageTopRight != null) {
                rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);
            }
            detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);
            if (detectionResult == null) {
                throw NotFoundException_1.default.getNotFoundInstance();
            }
            var resultBox = detectionResult.getBoundingBox();
            if (firstPass && resultBox != null &&
                (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {
                boundingBox = resultBox;
            }
            else {
                break;
            }
        }
        detectionResult.setBoundingBox(boundingBox);
        var maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;
        detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);
        detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);
        var leftToRight = leftRowIndicatorColumn != null;
        for (var barcodeColumnCount /*int*/ = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {
            var barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;
            if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */ undefined) {
                // This will be the case for the opposite row indicator column, which doesn't need to be decoded again.
                continue;
            }
            var detectionResultColumn = void 0;
            if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {
                detectionResultColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, barcodeColumn === 0);
            }
            else {
                detectionResultColumn = new DetectionResultColumn_1.default(boundingBox);
            }
            detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);
            var startColumn = -1;
            var previousStartColumn = startColumn;
            // TODO start at a row for which we know the start position, then detect upwards and downwards from there.
            for (var imageRow /*int*/ = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {
                startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);
                if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {
                    if (previousStartColumn === -1) {
                        continue;
                    }
                    startColumn = previousStartColumn;
                }
                var codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
                if (codeword != null) {
                    detectionResultColumn.setCodeword(imageRow, codeword);
                    previousStartColumn = startColumn;
                    minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());
                    maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());
                }
            }
        }
        return PDF417ScanningDecoder.createDecoderResult(detectionResult);
    };
    /**
     *
     * @param leftRowIndicatorColumn
     * @param rightRowIndicatorColumn
     *
     * @throws NotFoundException
     */
    PDF417ScanningDecoder.merge = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {
        if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {
            return null;
        }
        var barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);
        if (barcodeMetadata == null) {
            return null;
        }
        var boundingBox = BoundingBox_1.default.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));
        return new DetectionResult_1.default(barcodeMetadata, boundingBox);
    };
    /**
     *
     * @param rowIndicatorColumn
     *
     * @throws NotFoundException
     */
    PDF417ScanningDecoder.adjustBoundingBox = function (rowIndicatorColumn) {
        var e_1, _a;
        if (rowIndicatorColumn == null) {
            return null;
        }
        var rowHeights = rowIndicatorColumn.getRowHeights();
        if (rowHeights == null) {
            return null;
        }
        var maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);
        var missingStartRows = 0;
        try {
            for (var rowHeights_1 = __values(rowHeights), rowHeights_1_1 = rowHeights_1.next(); !rowHeights_1_1.done; rowHeights_1_1 = rowHeights_1.next()) {
                var rowHeight = rowHeights_1_1.value /*int*/;
                missingStartRows += maxRowHeight - rowHeight;
                if (rowHeight > 0) {
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (rowHeights_1_1 && !rowHeights_1_1.done && (_a = rowHeights_1.return)) _a.call(rowHeights_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var codewords = rowIndicatorColumn.getCodewords();
        for (var row /*int*/ = 0; missingStartRows > 0 && codewords[row] == null; row++) {
            missingStartRows--;
        }
        var missingEndRows = 0;
        for (var row /*int*/ = rowHeights.length - 1; row >= 0; row--) {
            missingEndRows += maxRowHeight - rowHeights[row];
            if (rowHeights[row] > 0) {
                break;
            }
        }
        for (var row /*int*/ = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {
            missingEndRows--;
        }
        return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());
    };
    PDF417ScanningDecoder.getMax = function (values) {
        var e_2, _a;
        var maxValue = -1;
        try {
            for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
                var value = values_1_1.value /*int*/;
                maxValue = Math.max(maxValue, value);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return maxValue;
    };
    PDF417ScanningDecoder.getBarcodeMetadata = function (leftRowIndicatorColumn, rightRowIndicatorColumn) {
        var leftBarcodeMetadata;
        if (leftRowIndicatorColumn == null ||
            (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {
            return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();
        }
        var rightBarcodeMetadata;
        if (rightRowIndicatorColumn == null ||
            (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {
            return leftBarcodeMetadata;
        }
        if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() &&
            leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() &&
            leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {
            return null;
        }
        return leftBarcodeMetadata;
    };
    PDF417ScanningDecoder.getRowIndicatorColumn = function (image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {
        var rowIndicatorColumn = new DetectionResultRowIndicatorColumn_1.default(boundingBox, leftToRight);
        for (var i /*int*/ = 0; i < 2; i++) {
            var increment = i === 0 ? 1 : -1;
            var startColumn = Math.trunc(Math.trunc(startPoint.getX()));
            for (var imageRow /*int*/ = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() &&
                imageRow >= boundingBox.getMinY(); imageRow += increment) {
                var codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
                if (codeword != null) {
                    rowIndicatorColumn.setCodeword(imageRow, codeword);
                    if (leftToRight) {
                        startColumn = codeword.getStartX();
                    }
                    else {
                        startColumn = codeword.getEndX();
                    }
                }
            }
        }
        return rowIndicatorColumn;
    };
    /**
     *
     * @param detectionResult
     * @param BarcodeValue
     * @param param2
     * @param param3
     * @param barcodeMatrix
     *
     * @throws NotFoundException
     */
    PDF417ScanningDecoder.adjustCodewordCount = function (detectionResult, barcodeMatrix) {
        var barcodeMatrix01 = barcodeMatrix[0][1];
        var numberOfCodewords = barcodeMatrix01.getValue();
        var calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() *
            detectionResult.getBarcodeRowCount() -
            PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());
        if (numberOfCodewords.length === 0) {
            if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common_1.default.MAX_CODEWORDS_IN_BARCODE) {
                throw NotFoundException_1.default.getNotFoundInstance();
            }
            barcodeMatrix01.setValue(calculatedNumberOfCodewords);
        }
        else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {
            // The calculated one is more reliable as it is derived from the row indicator columns
            barcodeMatrix01.setValue(calculatedNumberOfCodewords);
        }
    };
    /**
     *
     * @param detectionResult
     *
     * @throws FormatException
     * @throws ChecksumException
     * @throws NotFoundException
     */
    PDF417ScanningDecoder.createDecoderResult = function (detectionResult) {
        var barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);
        PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);
        var erasures /*Collection<Integer>*/ = new Array();
        var codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());
        var ambiguousIndexValuesList = /*List<int[]>*/ [];
        var ambiguousIndexesList = /*Collection<Integer>*/ new Array();
        for (var row /*int*/ = 0; row < detectionResult.getBarcodeRowCount(); row++) {
            for (var column /*int*/ = 0; column < detectionResult.getBarcodeColumnCount(); column++) {
                var values = barcodeMatrix[row][column + 1].getValue();
                var codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;
                if (values.length === 0) {
                    erasures.push(codewordIndex);
                }
                else if (values.length === 1) {
                    codewords[codewordIndex] = values[0];
                }
                else {
                    ambiguousIndexesList.push(codewordIndex);
                    ambiguousIndexValuesList.push(values);
                }
            }
        }
        var ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);
        for (var i /*int*/ = 0; i < ambiguousIndexValues.length; i++) {
            ambiguousIndexValues[i] = ambiguousIndexValuesList[i];
        }
        return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common_1.default.toIntArray(erasures), PDF417Common_1.default.toIntArray(ambiguousIndexesList), ambiguousIndexValues);
    };
    /**
     * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The
     * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value
     * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of
     * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the
     * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,
     * so decoding the normal barcodes is not affected by this.
     *
     * @param erasureArray contains the indexes of erasures
     * @param ambiguousIndexes array with the indexes that have more than one most likely value
     * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must
     * be the same length as the ambiguousIndexes array
     *
     * @throws FormatException
     * @throws ChecksumException
     */
    PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues = function (ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {
        var ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);
        var tries = 100;
        while (tries-- > 0) {
            for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {
                codewords[ambiguousIndexes[i]] = ambiguousIndexValues[i][ambiguousIndexCount[i]];
            }
            try {
                return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);
            }
            catch (err) {
                var ignored = err instanceof ChecksumException_1.default;
                if (!ignored) {
                    throw err;
                }
            }
            if (ambiguousIndexCount.length === 0) {
                throw ChecksumException_1.default.getChecksumInstance();
            }
            for (var i /*int*/ = 0; i < ambiguousIndexCount.length; i++) {
                if (ambiguousIndexCount[i] < ambiguousIndexValues[i].length - 1) {
                    ambiguousIndexCount[i]++;
                    break;
                }
                else {
                    ambiguousIndexCount[i] = 0;
                    if (i === ambiguousIndexCount.length - 1) {
                        throw ChecksumException_1.default.getChecksumInstance();
                    }
                }
            }
        }
        throw ChecksumException_1.default.getChecksumInstance();
    };
    PDF417ScanningDecoder.createBarcodeMatrix = function (detectionResult) {
        var e_3, _a, e_4, _b;
        // let barcodeMatrix: BarcodeValue[][] =
        // new BarcodeValue[detectionResult.getBarcodeRowCount()][detectionResult.getBarcodeColumnCount() + 2];
        var barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, function () { return new Array(detectionResult.getBarcodeColumnCount() + 2); });
        for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {
            for (var column_1 /*int*/ = 0; column_1 < barcodeMatrix[row].length; column_1++) {
                barcodeMatrix[row][column_1] = new BarcodeValue_1.default();
            }
        }
        var column = 0;
        try {
            for (var _c = __values(detectionResult.getDetectionResultColumns()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var detectionResultColumn = _d.value /*DetectionResultColumn*/;
                if (detectionResultColumn != null) {
                    try {
                        for (var _e = __values(detectionResultColumn.getCodewords()), _f = _e.next(); !_f.done; _f = _e.next()) {
                            var codeword = _f.value /*Codeword*/;
                            if (codeword != null) {
                                var rowNumber = codeword.getRowNumber();
                                if (rowNumber >= 0) {
                                    if (rowNumber >= barcodeMatrix.length) {
                                        // We have more rows than the barcode metadata allows for, ignore them.
                                        continue;
                                    }
                                    barcodeMatrix[rowNumber][column].setValue(codeword.getValue());
                                }
                            }
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
                column++;
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return barcodeMatrix;
    };
    PDF417ScanningDecoder.isValidBarcodeColumn = function (detectionResult, barcodeColumn) {
        return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;
    };
    PDF417ScanningDecoder.getStartColumn = function (detectionResult, barcodeColumn, imageRow, leftToRight) {
        var e_5, _a;
        var offset = leftToRight ? 1 : -1;
        var codeword = null;
        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodeword(imageRow);
        }
        if (codeword != null) {
            return leftToRight ? codeword.getEndX() : codeword.getStartX();
        }
        codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);
        if (codeword != null) {
            return leftToRight ? codeword.getStartX() : codeword.getEndX();
        }
        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
            codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset).getCodewordNearby(imageRow);
        }
        if (codeword != null) {
            return leftToRight ? codeword.getEndX() : codeword.getStartX();
        }
        var skippedColumns = 0;
        while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset)) {
            barcodeColumn -= offset;
            try {
                for (var _b = __values(detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var previousRowCodeword = _c.value /*Codeword*/;
                    if (previousRowCodeword != null) {
                        return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) +
                            offset *
                                skippedColumns *
                                (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_5) throw e_5.error; }
            }
            skippedColumns++;
        }
        return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();
    };
    PDF417ScanningDecoder.detectCodeword = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {
        startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
        // we usually know fairly exact now how long a codeword is. We should provide minimum and maximum expected length
        // and try to adjust the read pixels, e.g. remove single pixel errors or try to cut off exceeding pixels.
        // min and maxCodewordWidth should not be used as they are calculated for the whole barcode an can be inaccurate
        // for the current position
        var moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
        if (moduleBitCount == null) {
            return null;
        }
        var endColumn;
        var codewordBitCount = MathUtils_1.default.sum(moduleBitCount);
        if (leftToRight) {
            endColumn = startColumn + codewordBitCount;
        }
        else {
            for (var i /*int*/ = 0; i < moduleBitCount.length / 2; i++) {
                var tmpCount = moduleBitCount[i];
                moduleBitCount[i] = moduleBitCount[moduleBitCount.length - 1 - i];
                moduleBitCount[moduleBitCount.length - 1 - i] = tmpCount;
            }
            endColumn = startColumn;
            startColumn = endColumn - codewordBitCount;
        }
        // TODO implement check for width and correction of black and white bars
        // use start (and maybe stop pattern) to determine if black bars are wider than white bars. If so, adjust.
        // should probably done only for codewords with a lot more than 17 bits.
        // The following fixes 10-1.png, which has wide black bars and small white bars
        //    for (let i /*int*/ = 0; i < moduleBitCount.length; i++) {
        //      if (i % 2 === 0) {
        //        moduleBitCount[i]--;
        //      } else {
        //        moduleBitCount[i]++;
        //      }
        //    }
        // We could also use the width of surrounding codewords for more accurate results, but this seems
        // sufficient for now
        if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {
            // We could try to use the startX and endX position of the codeword in the same column in the previous row,
            // create the bit count from it and normalize it to 8. This would help with single pixel errors.
            return null;
        }
        var decodedValue = PDF417CodewordDecoder_1.default.getDecodedValue(moduleBitCount);
        var codeword = PDF417Common_1.default.getCodeword(decodedValue);
        if (codeword === -1) {
            return null;
        }
        return new Codeword_1.default(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);
    };
    PDF417ScanningDecoder.getModuleBitCount = function (image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {
        var imageColumn = startColumn;
        var moduleBitCount = new Int32Array(8);
        var moduleNumber = 0;
        var increment = leftToRight ? 1 : -1;
        var previousPixelValue = leftToRight;
        while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) &&
            moduleNumber < moduleBitCount.length) {
            if (image.get(imageColumn, imageRow) === previousPixelValue) {
                moduleBitCount[moduleNumber]++;
                imageColumn += increment;
            }
            else {
                moduleNumber++;
                previousPixelValue = !previousPixelValue;
            }
        }
        if (moduleNumber === moduleBitCount.length ||
            ((imageColumn === (leftToRight ? maxColumn : minColumn)) &&
                moduleNumber === moduleBitCount.length - 1)) {
            return moduleBitCount;
        }
        return null;
    };
    PDF417ScanningDecoder.getNumberOfECCodeWords = function (barcodeECLevel) {
        return 2 << barcodeECLevel;
    };
    PDF417ScanningDecoder.adjustCodewordStartColumn = function (image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {
        var correctedStartColumn = codewordStartColumn;
        var increment = leftToRight ? -1 : 1;
        // there should be no black pixels before the start column. If there are, then we need to start earlier.
        for (var i /*int*/ = 0; i < 2; i++) {
            while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) &&
                leftToRight === image.get(correctedStartColumn, imageRow)) {
                if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {
                    return codewordStartColumn;
                }
                correctedStartColumn += increment;
            }
            increment = -increment;
            leftToRight = !leftToRight;
        }
        return correctedStartColumn;
    };
    PDF417ScanningDecoder.checkCodewordSkew = function (codewordSize, minCodewordWidth, maxCodewordWidth) {
        return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize &&
            codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;
    };
    /**
     * @throws FormatException,
     * @throws ChecksumException
     */
    PDF417ScanningDecoder.decodeCodewords = function (codewords, ecLevel, erasures) {
        if (codewords.length === 0) {
            throw FormatException_1.default.getFormatInstance();
        }
        var numECCodewords = 1 << (ecLevel + 1);
        var correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);
        PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);
        // Decode the codewords
        var decoderResult = DecodedBitStreamParser_1.default.decode(codewords, '' + ecLevel);
        decoderResult.setErrorsCorrected(correctedErrorsCount);
        decoderResult.setErasures(erasures.length);
        return decoderResult;
    };
    /**
     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
     * correct the errors in-place.</p>
     *
     * @param codewords   data and error correction codewords
     * @param erasures positions of any known erasures
     * @param numECCodewords number of error correction codewords that are available in codewords
     * @throws ChecksumException if error correction fails
     */
    PDF417ScanningDecoder.correctErrors = function (codewords, erasures, numECCodewords) {
        if (erasures != null &&
            erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS ||
            numECCodewords < 0 ||
            numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {
            // Too many errors or EC Codewords is corrupted
            throw ChecksumException_1.default.getChecksumInstance();
        }
        return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);
    };
    /**
     * Verify that all is OK with the codeword array.
     * @throws FormatException
     */
    PDF417ScanningDecoder.verifyCodewordCount = function (codewords, numECCodewords) {
        if (codewords.length < 4) {
            // Codeword array size should be at least 4 allowing for
            // Count CW, At least one Data CW, Error Correction CW, Error Correction CW
            throw FormatException_1.default.getFormatInstance();
        }
        // The first codeword, the Symbol Length Descriptor, shall always encode the total number of data
        // codewords in the symbol, including the Symbol Length Descriptor itself, data codewords and pad
        // codewords, but excluding the number of error correction codewords.
        var numberOfCodewords = codewords[0];
        if (numberOfCodewords > codewords.length) {
            throw FormatException_1.default.getFormatInstance();
        }
        if (numberOfCodewords === 0) {
            // Reset to the length of the array - 8 (Allow for at least level 3 Error Correction (8 Error Codewords)
            if (numECCodewords < codewords.length) {
                codewords[0] = codewords.length - numECCodewords;
            }
            else {
                throw FormatException_1.default.getFormatInstance();
            }
        }
    };
    PDF417ScanningDecoder.getBitCountForCodeword = function (codeword) {
        var result = new Int32Array(8);
        var previousValue = 0;
        var i = result.length - 1;
        while (true) {
            if ((codeword & 0x1) !== previousValue) {
                previousValue = codeword & 0x1;
                i--;
                if (i < 0) {
                    break;
                }
            }
            result[i]++;
            codeword >>= 1;
        }
        return result;
    };
    PDF417ScanningDecoder.getCodewordBucketNumber = function (codeword) {
        if (codeword instanceof Int32Array) {
            return this.getCodewordBucketNumber_Int32Array(codeword);
        }
        return this.getCodewordBucketNumber_number(codeword);
    };
    PDF417ScanningDecoder.getCodewordBucketNumber_number = function (codeword) {
        return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));
    };
    PDF417ScanningDecoder.getCodewordBucketNumber_Int32Array = function (moduleBitCount) {
        return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;
    };
    PDF417ScanningDecoder.toString = function (barcodeMatrix) {
        var formatter = new Formatter_1.default();
        // try (let formatter = new Formatter()) {
        for (var row /*int*/ = 0; row < barcodeMatrix.length; row++) {
            formatter.format('Row %2d: ', row);
            for (var column /*int*/ = 0; column < barcodeMatrix[row].length; column++) {
                var barcodeValue = barcodeMatrix[row][column];
                if (barcodeValue.getValue().length === 0) {
                    formatter.format('        ', null);
                }
                else {
                    formatter.format('%4d(%2d)', barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));
                }
            }
            formatter.format('%n');
        }
        return formatter.toString();
        // }
    };
    /*final*/ PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;
    /*final*/ PDF417ScanningDecoder.MAX_ERRORS = 3;
    /*final*/ PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;
    /*final*/ PDF417ScanningDecoder.errorCorrection = new ErrorCorrection_1.default();
    return PDF417ScanningDecoder;
}());
exports.default = PDF417ScanningDecoder;
//# sourceMappingURL=PDF417ScanningDecoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ErrorCorrection.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ErrorCorrection.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
* Copyright 2012 ZXing authors
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder.ec;
// import com.google.zxing.ChecksumException;
var ChecksumException_1 = __webpack_require__(/*! ../../../ChecksumException */ "./node_modules/@zxing/library/esm5/core/ChecksumException.js");
var ModulusPoly_1 = __webpack_require__(/*! ./ModulusPoly */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ModulusPoly.js");
var ModulusGF_1 = __webpack_require__(/*! ./ModulusGF */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ModulusGF.js");
/**
 * <p>PDF417 error correction implementation.</p>
 *
 * <p>This <a href="http://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction#Example">example</a>
 * is quite useful in understanding the algorithm.</p>
 *
 * @author Sean Owen
 * @see com.google.zxing.common.reedsolomon.ReedSolomonDecoder
 */
var ErrorCorrection = /** @class */ (function () {
    function ErrorCorrection() {
        this.field = ModulusGF_1.default.PDF417_GF;
    }
    /**
     * @param received received codewords
     * @param numECCodewords number of those codewords used for EC
     * @param erasures location of erasures
     * @return number of errors
     * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors
     */
    ErrorCorrection.prototype.decode = function (received, numECCodewords, erasures) {
        var e_1, _a;
        var poly = new ModulusPoly_1.default(this.field, received);
        var S = new Int32Array(numECCodewords);
        var error = false;
        for (var i /*int*/ = numECCodewords; i > 0; i--) {
            var evaluation = poly.evaluateAt(this.field.exp(i));
            S[numECCodewords - i] = evaluation;
            if (evaluation !== 0) {
                error = true;
            }
        }
        if (!error) {
            return 0;
        }
        var knownErrors = this.field.getOne();
        if (erasures != null) {
            try {
                for (var erasures_1 = __values(erasures), erasures_1_1 = erasures_1.next(); !erasures_1_1.done; erasures_1_1 = erasures_1.next()) {
                    var erasure = erasures_1_1.value;
                    var b = this.field.exp(received.length - 1 - erasure);
                    // Add (1 - bx) term:
                    var term = new ModulusPoly_1.default(this.field, new Int32Array([this.field.subtract(0, b), 1]));
                    knownErrors = knownErrors.multiply(term);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (erasures_1_1 && !erasures_1_1.done && (_a = erasures_1.return)) _a.call(erasures_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        var syndrome = new ModulusPoly_1.default(this.field, S);
        // syndrome = syndrome.multiply(knownErrors);
        var sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);
        var sigma = sigmaOmega[0];
        var omega = sigmaOmega[1];
        // sigma = sigma.multiply(knownErrors);
        var errorLocations = this.findErrorLocations(sigma);
        var errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);
        for (var i /*int*/ = 0; i < errorLocations.length; i++) {
            var position = received.length - 1 - this.field.log(errorLocations[i]);
            if (position < 0) {
                throw ChecksumException_1.default.getChecksumInstance();
            }
            received[position] = this.field.subtract(received[position], errorMagnitudes[i]);
        }
        return errorLocations.length;
    };
    /**
     *
     * @param ModulusPoly
     * @param a
     * @param ModulusPoly
     * @param b
     * @param int
     * @param R
     * @throws ChecksumException
     */
    ErrorCorrection.prototype.runEuclideanAlgorithm = function (a, b, R) {
        // Assume a's degree is >= b's
        if (a.getDegree() < b.getDegree()) {
            var temp = a;
            a = b;
            b = temp;
        }
        var rLast = a;
        var r = b;
        var tLast = this.field.getZero();
        var t = this.field.getOne();
        // Run Euclidean algorithm until r's degree is less than R/2
        while (r.getDegree() >= Math.round(R / 2)) {
            var rLastLast = rLast;
            var tLastLast = tLast;
            rLast = r;
            tLast = t;
            // Divide rLastLast by rLast, with quotient in q and remainder in r
            if (rLast.isZero()) {
                // Oops, Euclidean algorithm already terminated?
                throw ChecksumException_1.default.getChecksumInstance();
            }
            r = rLastLast;
            var q = this.field.getZero();
            var denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
            var dltInverse = this.field.inverse(denominatorLeadingTerm);
            while (r.getDegree() >= rLast.getDegree() && !r.isZero()) {
                var degreeDiff = r.getDegree() - rLast.getDegree();
                var scale = this.field.multiply(r.getCoefficient(r.getDegree()), dltInverse);
                q = q.add(this.field.buildMonomial(degreeDiff, scale));
                r = r.subtract(rLast.multiplyByMonomial(degreeDiff, scale));
            }
            t = q.multiply(tLast).subtract(tLastLast).negative();
        }
        var sigmaTildeAtZero = t.getCoefficient(0);
        if (sigmaTildeAtZero === 0) {
            throw ChecksumException_1.default.getChecksumInstance();
        }
        var inverse = this.field.inverse(sigmaTildeAtZero);
        var sigma = t.multiply(inverse);
        var omega = r.multiply(inverse);
        return [sigma, omega];
    };
    /**
     *
     * @param errorLocator
     * @throws ChecksumException
     */
    ErrorCorrection.prototype.findErrorLocations = function (errorLocator) {
        // This is a direct application of Chien's search
        var numErrors = errorLocator.getDegree();
        var result = new Int32Array(numErrors);
        var e = 0;
        for (var i /*int*/ = 1; i < this.field.getSize() && e < numErrors; i++) {
            if (errorLocator.evaluateAt(i) === 0) {
                result[e] = this.field.inverse(i);
                e++;
            }
        }
        if (e !== numErrors) {
            throw ChecksumException_1.default.getChecksumInstance();
        }
        return result;
    };
    ErrorCorrection.prototype.findErrorMagnitudes = function (errorEvaluator, errorLocator, errorLocations) {
        var errorLocatorDegree = errorLocator.getDegree();
        var formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);
        for (var i /*int*/ = 1; i <= errorLocatorDegree; i++) {
            formalDerivativeCoefficients[errorLocatorDegree - i] =
                this.field.multiply(i, errorLocator.getCoefficient(i));
        }
        var formalDerivative = new ModulusPoly_1.default(this.field, formalDerivativeCoefficients);
        // This is directly applying Forney's Formula
        var s = errorLocations.length;
        var result = new Int32Array(s);
        for (var i /*int*/ = 0; i < s; i++) {
            var xiInverse = this.field.inverse(errorLocations[i]);
            var numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));
            var denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));
            result[i] = this.field.multiply(numerator, denominator);
        }
        return result;
    };
    return ErrorCorrection;
}());
exports.default = ErrorCorrection;
//# sourceMappingURL=ErrorCorrection.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ModulusBase.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ModulusBase.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var IllegalArgumentException_1 = __webpack_require__(/*! ../../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
var ArithmeticException_1 = __webpack_require__(/*! ../../../ArithmeticException */ "./node_modules/@zxing/library/esm5/core/ArithmeticException.js");
var ModulusBase = /** @class */ (function () {
    function ModulusBase() {
    }
    ModulusBase.prototype.add = function (a, b) {
        return (a + b) % this.modulus;
    };
    ModulusBase.prototype.subtract = function (a, b) {
        return (this.modulus + a - b) % this.modulus;
    };
    ModulusBase.prototype.exp = function (a) {
        return this.expTable[a];
    };
    ModulusBase.prototype.log = function (a) {
        if (a === 0) {
            throw new IllegalArgumentException_1.default();
        }
        return this.logTable[a];
    };
    ModulusBase.prototype.inverse = function (a) {
        if (a === 0) {
            throw new ArithmeticException_1.default();
        }
        return this.expTable[this.modulus - this.logTable[a] - 1];
    };
    ModulusBase.prototype.multiply = function (a, b) {
        if (a === 0 || b === 0) {
            return 0;
        }
        return this.expTable[(this.logTable[a] + this.logTable[b]) % (this.modulus - 1)];
    };
    ModulusBase.prototype.getSize = function () {
        return this.modulus;
    };
    ModulusBase.prototype.equals = function (o) {
        return o === this;
    };
    return ModulusBase;
}());
exports.default = ModulusBase;
//# sourceMappingURL=ModulusBase.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ModulusGF.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ModulusGF.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2012 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder.ec;
// import com.google.zxing.pdf417.PDF417Common;
var PDF417Common_1 = __webpack_require__(/*! ../../PDF417Common */ "./node_modules/@zxing/library/esm5/core/pdf417/PDF417Common.js");
var ModulusPoly_1 = __webpack_require__(/*! ./ModulusPoly */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ModulusPoly.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
var ModulusBase_1 = __webpack_require__(/*! ./ModulusBase */ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ModulusBase.js");
/**
 * <p>A field based on powers of a generator integer, modulo some modulus.</p>
 *
 * @author Sean Owen
 * @see com.google.zxing.common.reedsolomon.GenericGF
 */
var ModulusGF = /** @class */ (function (_super) {
    __extends(ModulusGF, _super);
    // private /*final*/ modulus: /*int*/ number;
    function ModulusGF(modulus, generator) {
        var _this = _super.call(this) || this;
        _this.modulus = modulus;
        _this.expTable = new Int32Array(modulus);
        _this.logTable = new Int32Array(modulus);
        var x = /*int*/ 1;
        for (var i /*int*/ = 0; i < modulus; i++) {
            _this.expTable[i] = x;
            x = (x * generator) % modulus;
        }
        for (var i /*int*/ = 0; i < modulus - 1; i++) {
            _this.logTable[_this.expTable[i]] = i;
        }
        // logTable[0] == 0 but this should never be used
        _this.zero = new ModulusPoly_1.default(_this, new Int32Array([0]));
        _this.one = new ModulusPoly_1.default(_this, new Int32Array([1]));
        return _this;
    }
    ModulusGF.prototype.getZero = function () {
        return this.zero;
    };
    ModulusGF.prototype.getOne = function () {
        return this.one;
    };
    ModulusGF.prototype.buildMonomial = function (degree, coefficient) {
        if (degree < 0) {
            throw new IllegalArgumentException_1.default();
        }
        if (coefficient === 0) {
            return this.zero;
        }
        var coefficients = new Int32Array(degree + 1);
        coefficients[0] = coefficient;
        return new ModulusPoly_1.default(this, coefficients);
    };
    ModulusGF.PDF417_GF = new ModulusGF(PDF417Common_1.default.NUMBER_OF_CODEWORDS, 3);
    return ModulusGF;
}(ModulusBase_1.default));
exports.default = ModulusGF;
//# sourceMappingURL=ModulusGF.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ModulusPoly.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/decoder/ec/ModulusPoly.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
* Copyright 2012 ZXing authors
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// package com.google.zxing.pdf417.decoder.ec;
var IllegalArgumentException_1 = __webpack_require__(/*! ../../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
var System_1 = __webpack_require__(/*! ../../../util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var StringBuilder_1 = __webpack_require__(/*! ../../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
/**
 * @author Sean Owen
 * @see com.google.zxing.common.reedsolomon.GenericGFPoly
 */
var ModulusPoly = /** @class */ (function () {
    function ModulusPoly(field, coefficients) {
        if (coefficients.length === 0) {
            throw new IllegalArgumentException_1.default();
        }
        this.field = field;
        var coefficientsLength = /*int*/ coefficients.length;
        if (coefficientsLength > 1 && coefficients[0] === 0) {
            // Leading term must be non-zero for anything except the constant polynomial "0"
            var firstNonZero = /*int*/ 1;
            while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
                firstNonZero++;
            }
            if (firstNonZero === coefficientsLength) {
                this.coefficients = new Int32Array([0]);
            }
            else {
                this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
                System_1.default.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
            }
        }
        else {
            this.coefficients = coefficients;
        }
    }
    ModulusPoly.prototype.getCoefficients = function () {
        return this.coefficients;
    };
    /**
     * @return degree of this polynomial
     */
    ModulusPoly.prototype.getDegree = function () {
        return this.coefficients.length - 1;
    };
    /**
     * @return true iff this polynomial is the monomial "0"
     */
    ModulusPoly.prototype.isZero = function () {
        return this.coefficients[0] === 0;
    };
    /**
     * @return coefficient of x^degree term in this polynomial
     */
    ModulusPoly.prototype.getCoefficient = function (degree) {
        return this.coefficients[this.coefficients.length - 1 - degree];
    };
    /**
     * @return evaluation of this polynomial at a given point
     */
    ModulusPoly.prototype.evaluateAt = function (a) {
        var e_1, _a;
        if (a === 0) {
            // Just return the x^0 coefficient
            return this.getCoefficient(0);
        }
        if (a === 1) {
            // Just the sum of the coefficients
            var sum = /*int*/ 0;
            try {
                for (var _b = __values(this.coefficients), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var coefficient = _c.value /*int*/;
                    sum = this.field.add(sum, coefficient);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return sum;
        }
        var result = /*int*/ this.coefficients[0];
        var size = /*int*/ this.coefficients.length;
        for (var i /*int*/ = 1; i < size; i++) {
            result = this.field.add(this.field.multiply(a, result), this.coefficients[i]);
        }
        return result;
    };
    ModulusPoly.prototype.add = function (other) {
        if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException_1.default('ModulusPolys do not have same ModulusGF field');
        }
        if (this.isZero()) {
            return other;
        }
        if (other.isZero()) {
            return this;
        }
        var smallerCoefficients = this.coefficients;
        var largerCoefficients = other.coefficients;
        if (smallerCoefficients.length > largerCoefficients.length) {
            var temp = smallerCoefficients;
            smallerCoefficients = largerCoefficients;
            largerCoefficients = temp;
        }
        var sumDiff = new Int32Array(largerCoefficients.length);
        var lengthDiff = /*int*/ largerCoefficients.length - smallerCoefficients.length;
        // Copy high-order terms only found in higher-degree polynomial's coefficients
        System_1.default.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
        for (var i /*int*/ = lengthDiff; i < largerCoefficients.length; i++) {
            sumDiff[i] = this.field.add(smallerCoefficients[i - lengthDiff], largerCoefficients[i]);
        }
        return new ModulusPoly(this.field, sumDiff);
    };
    ModulusPoly.prototype.subtract = function (other) {
        if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException_1.default('ModulusPolys do not have same ModulusGF field');
        }
        if (other.isZero()) {
            return this;
        }
        return this.add(other.negative());
    };
    ModulusPoly.prototype.multiply = function (other) {
        if (other instanceof ModulusPoly) {
            return this.multiplyOther(other);
        }
        return this.multiplyScalar(other);
    };
    ModulusPoly.prototype.multiplyOther = function (other) {
        if (!this.field.equals(other.field)) {
            throw new IllegalArgumentException_1.default('ModulusPolys do not have same ModulusGF field');
        }
        if (this.isZero() || other.isZero()) {
            // return this.field.getZero();
            return new ModulusPoly(this.field, new Int32Array([0]));
        }
        var aCoefficients = this.coefficients;
        var aLength = /*int*/ aCoefficients.length;
        var bCoefficients = other.coefficients;
        var bLength = /*int*/ bCoefficients.length;
        var product = new Int32Array(aLength + bLength - 1);
        for (var i /*int*/ = 0; i < aLength; i++) {
            var aCoeff = /*int*/ aCoefficients[i];
            for (var j /*int*/ = 0; j < bLength; j++) {
                product[i + j] = this.field.add(product[i + j], this.field.multiply(aCoeff, bCoefficients[j]));
            }
        }
        return new ModulusPoly(this.field, product);
    };
    ModulusPoly.prototype.negative = function () {
        var size = /*int*/ this.coefficients.length;
        var negativeCoefficients = new Int32Array(size);
        for (var i /*int*/ = 0; i < size; i++) {
            negativeCoefficients[i] = this.field.subtract(0, this.coefficients[i]);
        }
        return new ModulusPoly(this.field, negativeCoefficients);
    };
    ModulusPoly.prototype.multiplyScalar = function (scalar) {
        if (scalar === 0) {
            return new ModulusPoly(this.field, new Int32Array([0]));
        }
        if (scalar === 1) {
            return this;
        }
        var size = /*int*/ this.coefficients.length;
        var product = new Int32Array(size);
        for (var i /*int*/ = 0; i < size; i++) {
            product[i] = this.field.multiply(this.coefficients[i], scalar);
        }
        return new ModulusPoly(this.field, product);
    };
    ModulusPoly.prototype.multiplyByMonomial = function (degree, coefficient) {
        if (degree < 0) {
            throw new IllegalArgumentException_1.default();
        }
        if (coefficient === 0) {
            return new ModulusPoly(this.field, new Int32Array([0]));
        }
        var size = /*int*/ this.coefficients.length;
        var product = new Int32Array(size + degree);
        for (var i /*int*/ = 0; i < size; i++) {
            product[i] = this.field.multiply(this.coefficients[i], coefficient);
        }
        return new ModulusPoly(this.field, product);
    };
    /*
    ModulusPoly[] divide(other: ModulusPoly) {
      if (!field.equals(other.field)) {
        throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
      }
      if (other.isZero()) {
        throw new IllegalArgumentException("Divide by 0");
      }
  
      let quotient: ModulusPoly = field.getZero();
      let remainder: ModulusPoly = this;
  
      let denominatorLeadingTerm: /*int/ number = other.getCoefficient(other.getDegree());
      let inverseDenominatorLeadingTerm: /*int/ number = field.inverse(denominatorLeadingTerm);
  
      while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
        let degreeDifference: /*int/ number = remainder.getDegree() - other.getDegree();
        let scale: /*int/ number = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
        let term: ModulusPoly = other.multiplyByMonomial(degreeDifference, scale);
        let iterationQuotient: ModulusPoly = field.buildMonomial(degreeDifference, scale);
        quotient = quotient.add(iterationQuotient);
        remainder = remainder.subtract(term);
      }
  
      return new ModulusPoly[] { quotient, remainder };
    }
    */
    // @Override
    ModulusPoly.prototype.toString = function () {
        var result = new StringBuilder_1.default( /*8 * this.getDegree()*/); // dynamic string size in JS
        for (var degree /*int*/ = this.getDegree(); degree >= 0; degree--) {
            var coefficient = /*int*/ this.getCoefficient(degree);
            if (coefficient !== 0) {
                if (coefficient < 0) {
                    result.append(' - ');
                    coefficient = -coefficient;
                }
                else {
                    if (result.length() > 0) {
                        result.append(' + ');
                    }
                }
                if (degree === 0 || coefficient !== 1) {
                    result.append(coefficient);
                }
                if (degree !== 0) {
                    if (degree === 1) {
                        result.append('x');
                    }
                    else {
                        result.append('x^');
                        result.append(degree);
                    }
                }
            }
        }
        return result.toString();
    };
    return ModulusPoly;
}());
exports.default = ModulusPoly;
//# sourceMappingURL=ModulusPoly.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/detector/Detector.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/detector/Detector.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
* Copyright 2009 ZXing authors
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
// import com.google.zxing.NotFoundException;
// import com.google.zxing.ResultPoint;
var ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var System_1 = __webpack_require__(/*! ../../util/System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var Arrays_1 = __webpack_require__(/*! ../../util/Arrays */ "./node_modules/@zxing/library/esm5/core/util/Arrays.js");
var PDF417DetectorResult_1 = __webpack_require__(/*! ./PDF417DetectorResult */ "./node_modules/@zxing/library/esm5/core/pdf417/detector/PDF417DetectorResult.js");
// import java.util.ArrayList;
// import java.util.Arrays;
// import java.util.List;
// import java.util.Map;
/**
 * <p>Encapsulates logic that can detect a PDF417 Code in an image, even if the
 * PDF417 Code is rotated or skewed, or partially obscured.</p>
 *
 * @author SITA Lab (kevin.osullivan@sita.aero)
 * @author dswitkin@google.com (Daniel Switkin)
 * @author Guenther Grau
 */
var Detector = /** @class */ (function () {
    function Detector() {
    }
    /**
     * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>
     *
     * @param image barcode image to decode
     * @param hints optional hints to detector
     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will
     * be found and returned
     * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code
     * @throws NotFoundException if no PDF417 Code can be found
     */
    Detector.detectMultiple = function (image, hints, multiple) {
        // TODO detection improvement, tryHarder could try several different luminance thresholds/blackpoints or even
        // different binarizers
        // boolean tryHarder = hints != null && hints.containsKey(DecodeHintType.TRY_HARDER);
        var bitMatrix = image.getBlackMatrix();
        var barcodeCoordinates = Detector.detect(multiple, bitMatrix);
        if (!barcodeCoordinates.length) {
            bitMatrix = bitMatrix.clone();
            bitMatrix.rotate180();
            barcodeCoordinates = Detector.detect(multiple, bitMatrix);
        }
        return new PDF417DetectorResult_1.default(bitMatrix, barcodeCoordinates);
    };
    /**
     * Detects PDF417 codes in an image. Only checks 0 degree rotation
     * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will
     * be found and returned
     * @param bitMatrix bit matrix to detect barcodes in
     * @return List of ResultPoint arrays containing the coordinates of found barcodes
     */
    Detector.detect = function (multiple, bitMatrix) {
        var e_1, _a;
        var barcodeCoordinates = new Array();
        var row = 0;
        var column = 0;
        var foundBarcodeInRow = false;
        while (row < bitMatrix.getHeight()) {
            var vertices = Detector.findVertices(bitMatrix, row, column);
            if (vertices[0] == null && vertices[3] == null) {
                if (!foundBarcodeInRow) {
                    // we didn't find any barcode so that's the end of searching
                    break;
                }
                // we didn't find a barcode starting at the given column and row. Try again from the first column and slightly
                // below the lowest barcode we found so far.
                foundBarcodeInRow = false;
                column = 0;
                try {
                    for (var barcodeCoordinates_1 = __values(barcodeCoordinates), barcodeCoordinates_1_1 = barcodeCoordinates_1.next(); !barcodeCoordinates_1_1.done; barcodeCoordinates_1_1 = barcodeCoordinates_1.next()) {
                        var barcodeCoordinate = barcodeCoordinates_1_1.value;
                        if (barcodeCoordinate[1] != null) {
                            row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));
                        }
                        if (barcodeCoordinate[3] != null) {
                            row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (barcodeCoordinates_1_1 && !barcodeCoordinates_1_1.done && (_a = barcodeCoordinates_1.return)) _a.call(barcodeCoordinates_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                row += Detector.ROW_STEP;
                continue;
            }
            foundBarcodeInRow = true;
            barcodeCoordinates.push(vertices);
            if (!multiple) {
                break;
            }
            // if we didn't find a right row indicator column, then continue the search for the next barcode after the
            // start pattern of the barcode just found.
            if (vertices[2] != null) {
                column = Math.trunc(vertices[2].getX());
                row = Math.trunc(vertices[2].getY());
            }
            else {
                column = Math.trunc(vertices[4].getX());
                row = Math.trunc(vertices[4].getY());
            }
        }
        return barcodeCoordinates;
    };
    /**
     * Locate the vertices and the codewords area of a black blob using the Start
     * and Stop patterns as locators.
     *
     * @param matrix the scanned barcode image.
     * @return an array containing the vertices:
     *           vertices[0] x, y top left barcode
     *           vertices[1] x, y bottom left barcode
     *           vertices[2] x, y top right barcode
     *           vertices[3] x, y bottom right barcode
     *           vertices[4] x, y top left codeword area
     *           vertices[5] x, y bottom left codeword area
     *           vertices[6] x, y top right codeword area
     *           vertices[7] x, y bottom right codeword area
     */
    Detector.findVertices = function (matrix, startRow, startColumn) {
        var height = matrix.getHeight();
        var width = matrix.getWidth();
        // const result = new ResultPoint[8];
        var result = new Array(8);
        Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.START_PATTERN), Detector.INDEXES_START_PATTERN);
        if (result[4] != null) {
            startColumn = Math.trunc(result[4].getX());
            startRow = Math.trunc(result[4].getY());
        }
        Detector.copyToResult(result, Detector.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector.STOP_PATTERN), Detector.INDEXES_STOP_PATTERN);
        return result;
    };
    Detector.copyToResult = function (result, tmpResult, destinationIndexes) {
        for (var i = 0; i < destinationIndexes.length; i++) {
            result[destinationIndexes[i]] = tmpResult[i];
        }
    };
    Detector.findRowsWithPattern = function (matrix, height, width, startRow, startColumn, pattern) {
        // const result = new ResultPoint[4];
        var result = new Array(4);
        var found = false;
        var counters = new Int32Array(pattern.length);
        for (; startRow < height; startRow += Detector.ROW_STEP) {
            var loc = Detector.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);
            if (loc != null) {
                while (startRow > 0) {
                    var previousRowLoc = Detector.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);
                    if (previousRowLoc != null) {
                        loc = previousRowLoc;
                    }
                    else {
                        startRow++;
                        break;
                    }
                }
                result[0] = new ResultPoint_1.default(loc[0], startRow);
                result[1] = new ResultPoint_1.default(loc[1], startRow);
                found = true;
                break;
            }
        }
        var stopRow = startRow + 1;
        // Last row of the current symbol that contains pattern
        if (found) {
            var skippedRowCount = 0;
            var previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);
            for (; stopRow < height; stopRow++) {
                var loc = Detector.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);
                // a found pattern is only considered to belong to the same barcode if the start and end positions
                // don't differ too much. Pattern drift should be not bigger than two for consecutive rows. With
                // a higher number of skipped rows drift could be larger. To keep it simple for now, we allow a slightly
                // larger drift and don't check for skipped rows.
                if (loc != null &&
                    Math.abs(previousRowLoc[0] - loc[0]) < Detector.MAX_PATTERN_DRIFT &&
                    Math.abs(previousRowLoc[1] - loc[1]) < Detector.MAX_PATTERN_DRIFT) {
                    previousRowLoc = loc;
                    skippedRowCount = 0;
                }
                else {
                    if (skippedRowCount > Detector.SKIPPED_ROW_COUNT_MAX) {
                        break;
                    }
                    else {
                        skippedRowCount++;
                    }
                }
            }
            stopRow -= skippedRowCount + 1;
            result[2] = new ResultPoint_1.default(previousRowLoc[0], stopRow);
            result[3] = new ResultPoint_1.default(previousRowLoc[1], stopRow);
        }
        if (stopRow - startRow < Detector.BARCODE_MIN_HEIGHT) {
            Arrays_1.default.fill(result, null);
        }
        return result;
    };
    /**
     * @param matrix row of black/white values to search
     * @param column x position to start search
     * @param row y position to start search
     * @param width the number of pixels to search on this row
     * @param pattern pattern of counts of number of black and white pixels that are
     *                 being searched for as a pattern
     * @param counters array of counters, as long as pattern, to re-use
     * @return start/end horizontal offset of guard pattern, as an array of two ints.
     */
    Detector.findGuardPattern = function (matrix, column, row, width, whiteFirst, pattern, counters) {
        Arrays_1.default.fillWithin(counters, 0, counters.length, 0);
        var patternStart = column;
        var pixelDrift = 0;
        // if there are black pixels left of the current pixel shift to the left, but only for MAX_PIXEL_DRIFT pixels
        while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector.MAX_PIXEL_DRIFT) {
            patternStart--;
        }
        var x = patternStart;
        var counterPosition = 0;
        var patternLength = pattern.length;
        for (var isWhite = whiteFirst; x < width; x++) {
            var pixel = matrix.get(x, row);
            if (pixel !== isWhite) {
                counters[counterPosition]++;
            }
            else {
                if (counterPosition === patternLength - 1) {
                    if (Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {
                        return new Int32Array([patternStart, x]);
                    }
                    patternStart += counters[0] + counters[1];
                    System_1.default.arraycopy(counters, 2, counters, 0, counterPosition - 1);
                    counters[counterPosition - 1] = 0;
                    counters[counterPosition] = 0;
                    counterPosition--;
                }
                else {
                    counterPosition++;
                }
                counters[counterPosition] = 1;
                isWhite = !isWhite;
            }
        }
        if (counterPosition === patternLength - 1 &&
            Detector.patternMatchVariance(counters, pattern, Detector.MAX_INDIVIDUAL_VARIANCE) < Detector.MAX_AVG_VARIANCE) {
            return new Int32Array([patternStart, x - 1]);
        }
        return null;
    };
    /**
     * Determines how closely a set of observed counts of runs of black/white
     * values matches a given target pattern. This is reported as the ratio of
     * the total variance from the expected pattern proportions across all
     * pattern elements, to the length of the pattern.
     *
     * @param counters observed counters
     * @param pattern expected pattern
     * @param maxIndividualVariance The most any counter can differ before we give up
     * @return ratio of total variance between counters and pattern compared to total pattern size
     */
    Detector.patternMatchVariance = function (counters, pattern, maxIndividualVariance) {
        var numCounters = counters.length;
        var total = 0;
        var patternLength = 0;
        for (var i = 0; i < numCounters; i++) {
            total += counters[i];
            patternLength += pattern[i];
        }
        if (total < patternLength) {
            // If we don't even have one pixel per unit of bar width, assume this
            // is too small to reliably match, so fail:
            return /*Float.POSITIVE_INFINITY*/ Infinity;
        }
        // We're going to fake floating-point math in integers. We just need to use more bits.
        // Scale up patternLength so that intermediate values below like scaledCounter will have
        // more "significant digits".
        var unitBarWidth = total / patternLength;
        maxIndividualVariance *= unitBarWidth;
        var totalVariance = 0.0;
        for (var x = 0; x < numCounters; x++) {
            var counter = counters[x];
            var scaledPattern = pattern[x] * unitBarWidth;
            var variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
            if (variance > maxIndividualVariance) {
                return /*Float.POSITIVE_INFINITY*/ Infinity;
            }
            totalVariance += variance;
        }
        return totalVariance / total;
    };
    Detector.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);
    Detector.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);
    Detector.MAX_AVG_VARIANCE = 0.42;
    Detector.MAX_INDIVIDUAL_VARIANCE = 0.8;
    // B S B S B S B S Bar/Space pattern
    // 11111111 0 1 0 1 0 1 000
    Detector.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);
    // 1111111 0 1 000 1 0 1 00 1
    Detector.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);
    Detector.MAX_PIXEL_DRIFT = 3;
    Detector.MAX_PATTERN_DRIFT = 5;
    // if we set the value too low, then we don't detect the correct height of the bar if the start patterns are damaged.
    // if we set the value too high, then we might detect the start pattern from a neighbor barcode.
    Detector.SKIPPED_ROW_COUNT_MAX = 25;
    // A PDF471 barcode should have at least 3 rows, with each row being >= 3 times the module width. Therefore it should be at least
    // 9 pixels tall. To be conservative, we use about half the size to ensure we don't miss it.
    Detector.ROW_STEP = 5;
    Detector.BARCODE_MIN_HEIGHT = 10;
    return Detector;
}());
exports.default = Detector;
//# sourceMappingURL=Detector.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/pdf417/detector/PDF417DetectorResult.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/pdf417/detector/PDF417DetectorResult.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
* Copyright 2007 ZXing authors
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*      http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
Object.defineProperty(exports, "__esModule", { value: true });
// import java.util.List;
/**
 * @author Guenther Grau
 */
var PDF417DetectorResult = /** @class */ (function () {
    function PDF417DetectorResult(bits, points) {
        this.bits = bits;
        this.points = points;
    }
    PDF417DetectorResult.prototype.getBits = function () {
        return this.bits;
    };
    PDF417DetectorResult.prototype.getPoints = function () {
        return this.points;
    };
    return PDF417DetectorResult;
}());
exports.default = PDF417DetectorResult;
//# sourceMappingURL=PDF417DetectorResult.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/QRCodeReader.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/QRCodeReader.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode {*/
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var DecodeHintType_1 = __webpack_require__(/*! ../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var Result_1 = __webpack_require__(/*! ../Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
var ResultMetadataType_1 = __webpack_require__(/*! ../ResultMetadataType */ "./node_modules/@zxing/library/esm5/core/ResultMetadataType.js");
var BitMatrix_1 = __webpack_require__(/*! ../common/BitMatrix */ "./node_modules/@zxing/library/esm5/core/common/BitMatrix.js");
var Decoder_1 = __webpack_require__(/*! ./decoder/Decoder */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/Decoder.js");
var QRCodeDecoderMetaData_1 = __webpack_require__(/*! ./decoder/QRCodeDecoderMetaData */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/QRCodeDecoderMetaData.js");
var Detector_1 = __webpack_require__(/*! ./detector/Detector */ "./node_modules/@zxing/library/esm5/core/qrcode/detector/Detector.js");
var NotFoundException_1 = __webpack_require__(/*! ../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/*import java.util.List;*/
/*import java.util.Map;*/
/**
 * This implementation can detect and decode QR Codes in an image.
 *
 * @author Sean Owen
 */
var QRCodeReader = /** @class */ (function () {
    function QRCodeReader() {
        this.decoder = new Decoder_1.default();
    }
    QRCodeReader.prototype.getDecoder = function () {
        return this.decoder;
    };
    /**
     * Locates and decodes a QR code in an image.
     *
     * @return a representing: string the content encoded by the QR code
     * @throws NotFoundException if a QR code cannot be found
     * @throws FormatException if a QR code cannot be decoded
     * @throws ChecksumException if error correction fails
     */
    /*@Override*/
    // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {
    //   return this.decode(image, null)
    // }
    /*@Override*/
    QRCodeReader.prototype.decode = function (image, hints) {
        var decoderResult;
        var points;
        if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE)) {
            var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());
            decoderResult = this.decoder.decodeBitMatrix(bits, hints);
            points = QRCodeReader.NO_POINTS;
        }
        else {
            var detectorResult = new Detector_1.default(image.getBlackMatrix()).detect(hints);
            decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);
            points = detectorResult.getPoints();
        }
        // If the code was mirrored: swap the bottom-left and the top-right points.
        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData_1.default) {
            decoderResult.getOther().applyMirroredCorrection(points);
        }
        var result = new Result_1.default(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat_1.default.QR_CODE, undefined);
        var byteSegments = decoderResult.getByteSegments();
        if (byteSegments !== null) {
            result.putMetadata(ResultMetadataType_1.default.BYTE_SEGMENTS, byteSegments);
        }
        var ecLevel = decoderResult.getECLevel();
        if (ecLevel !== null) {
            result.putMetadata(ResultMetadataType_1.default.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        if (decoderResult.hasStructuredAppend()) {
            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());
            result.putMetadata(ResultMetadataType_1.default.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());
        }
        return result;
    };
    /*@Override*/
    QRCodeReader.prototype.reset = function () {
        // do nothing
    };
    /**
     * This method detects a code in a "pure" image -- that is, pure monochrome image
     * which contains only an unrotated, unskewed, image of a code, with some white border
     * around it. This is a specialized method that works exceptionally fast in this special
     * case.
     *
     * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)
     */
    QRCodeReader.extractPureBits = function (image) {
        var leftTopBlack = image.getTopLeftOnBit();
        var rightBottomBlack = image.getBottomRightOnBit();
        if (leftTopBlack === null || rightBottomBlack === null) {
            throw new NotFoundException_1.default();
        }
        var moduleSize = this.moduleSize(leftTopBlack, image);
        var top = leftTopBlack[1];
        var bottom = rightBottomBlack[1];
        var left = leftTopBlack[0];
        var right = rightBottomBlack[0];
        // Sanity check!
        if (left >= right || top >= bottom) {
            throw new NotFoundException_1.default();
        }
        if (bottom - top !== right - left) {
            // Special case, where bottom-right module wasn't black so we found something else in the last row
            // Assume it's a square, so use height as the width
            right = left + (bottom - top);
            if (right >= image.getWidth()) {
                // Abort if that would not make sense -- off image
                throw new NotFoundException_1.default();
            }
        }
        var matrixWidth = Math.round((right - left + 1) / moduleSize);
        var matrixHeight = Math.round((bottom - top + 1) / moduleSize);
        if (matrixWidth <= 0 || matrixHeight <= 0) {
            throw new NotFoundException_1.default();
        }
        if (matrixHeight !== matrixWidth) {
            // Only possibly decode square regions
            throw new NotFoundException_1.default();
        }
        // Push in the "border" by half the module width so that we start
        // sampling in the middle of the module. Just in case the image is a
        // little off, this will help recover.
        var nudge = /*(int) */ Math.floor(moduleSize / 2.0);
        top += nudge;
        left += nudge;
        // But careful that this does not sample off the edge
        // "right" is the farthest-right valid pixel location -- right+1 is not necessarily
        // This is positive by how much the inner x loop below would be too large
        var nudgedTooFarRight = left + /*(int) */ Math.floor((matrixWidth - 1) * moduleSize) - right;
        if (nudgedTooFarRight > 0) {
            if (nudgedTooFarRight > nudge) {
                // Neither way fits; abort
                throw new NotFoundException_1.default();
            }
            left -= nudgedTooFarRight;
        }
        // See logic above
        var nudgedTooFarDown = top + /*(int) */ Math.floor((matrixHeight - 1) * moduleSize) - bottom;
        if (nudgedTooFarDown > 0) {
            if (nudgedTooFarDown > nudge) {
                // Neither way fits; abort
                throw new NotFoundException_1.default();
            }
            top -= nudgedTooFarDown;
        }
        // Now just read off the bits
        var bits = new BitMatrix_1.default(matrixWidth, matrixHeight);
        for (var y = 0; y < matrixHeight; y++) {
            var iOffset = top + /*(int) */ Math.floor(y * moduleSize);
            for (var x = 0; x < matrixWidth; x++) {
                if (image.get(left + /*(int) */ Math.floor(x * moduleSize), iOffset)) {
                    bits.set(x, y);
                }
            }
        }
        return bits;
    };
    QRCodeReader.moduleSize = function (leftTopBlack, image) {
        var height = image.getHeight();
        var width = image.getWidth();
        var x = leftTopBlack[0];
        var y = leftTopBlack[1];
        var inBlack = true;
        var transitions = 0;
        while (x < width && y < height) {
            if (inBlack !== image.get(x, y)) {
                if (++transitions === 5) {
                    break;
                }
                inBlack = !inBlack;
            }
            x++;
            y++;
        }
        if (x === width || y === height) {
            throw new NotFoundException_1.default();
        }
        return (x - leftTopBlack[0]) / 7.0;
    };
    QRCodeReader.NO_POINTS = new Array();
    return QRCodeReader;
}());
exports.default = QRCodeReader;
//# sourceMappingURL=QRCodeReader.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/QRCodeWriter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/QRCodeWriter.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode {*/
var BarcodeFormat_1 = __webpack_require__(/*! ../BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
var EncodeHintType_1 = __webpack_require__(/*! ../EncodeHintType */ "./node_modules/@zxing/library/esm5/core/EncodeHintType.js");
var BitMatrix_1 = __webpack_require__(/*! ../common/BitMatrix */ "./node_modules/@zxing/library/esm5/core/common/BitMatrix.js");
var ErrorCorrectionLevel_1 = __webpack_require__(/*! ./decoder/ErrorCorrectionLevel */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/ErrorCorrectionLevel.js");
var Encoder_1 = __webpack_require__(/*! ./encoder/Encoder */ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/Encoder.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
var IllegalStateException_1 = __webpack_require__(/*! ../IllegalStateException */ "./node_modules/@zxing/library/esm5/core/IllegalStateException.js");
/*import java.util.Map;*/
/**
 * This object renders a QR Code as a BitMatrix 2D array of greyscale values.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 */
var QRCodeWriter = /** @class */ (function () {
    function QRCodeWriter() {
    }
    /*@Override*/
    // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix
    //     /*throws WriterException */ {
    //   return encode(contents, format, width, height, null)
    // }
    /*@Override*/
    QRCodeWriter.prototype.encode = function (contents, format, width /*int*/, height /*int*/, hints) {
        if (contents.length === 0) {
            throw new IllegalArgumentException_1.default('Found empty contents');
        }
        if (format !== BarcodeFormat_1.default.QR_CODE) {
            throw new IllegalArgumentException_1.default('Can only encode QR_CODE, but got ' + format);
        }
        if (width < 0 || height < 0) {
            throw new IllegalArgumentException_1.default("Requested dimensions are too small: " + width + "x" + height);
        }
        var errorCorrectionLevel = ErrorCorrectionLevel_1.default.L;
        var quietZone = QRCodeWriter.QUIET_ZONE_SIZE;
        if (hints !== null) {
            if (undefined !== hints.get(EncodeHintType_1.default.ERROR_CORRECTION)) {
                errorCorrectionLevel = ErrorCorrectionLevel_1.default.fromString(hints.get(EncodeHintType_1.default.ERROR_CORRECTION).toString());
            }
            if (undefined !== hints.get(EncodeHintType_1.default.MARGIN)) {
                quietZone = Number.parseInt(hints.get(EncodeHintType_1.default.MARGIN).toString(), 10);
            }
        }
        var code = Encoder_1.default.encode(contents, errorCorrectionLevel, hints);
        return QRCodeWriter.renderResult(code, width, height, quietZone);
    };
    // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses
    // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
    QRCodeWriter.renderResult = function (code, width /*int*/, height /*int*/, quietZone /*int*/) {
        var input = code.getMatrix();
        if (input === null) {
            throw new IllegalStateException_1.default();
        }
        var inputWidth = input.getWidth();
        var inputHeight = input.getHeight();
        var qrWidth = inputWidth + (quietZone * 2);
        var qrHeight = inputHeight + (quietZone * 2);
        var outputWidth = Math.max(width, qrWidth);
        var outputHeight = Math.max(height, qrHeight);
        var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        // Padding includes both the quiet zone and the extra white pixels to accommodate the requested
        // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.
        // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will
        // handle all the padding from 100x100 (the actual QR) up to 200x160.
        var leftPadding = Math.floor((outputWidth - (inputWidth * multiple)) / 2);
        var topPadding = Math.floor((outputHeight - (inputHeight * multiple)) / 2);
        var output = new BitMatrix_1.default(outputWidth, outputHeight);
        for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
            // Write the contents of this row of the barcode
            for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
                if (input.get(inputX, inputY) === 1) {
                    output.setRegion(outputX, outputY, multiple, multiple);
                }
            }
        }
        return output;
    };
    QRCodeWriter.QUIET_ZONE_SIZE = 4;
    return QRCodeWriter;
}());
exports.default = QRCodeWriter;
//# sourceMappingURL=QRCodeWriter.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/BitMatrixParser.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/BitMatrixParser.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var Version_1 = __webpack_require__(/*! ./Version */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/Version.js");
var FormatInformation_1 = __webpack_require__(/*! ./FormatInformation */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/FormatInformation.js");
var DataMask_1 = __webpack_require__(/*! ./DataMask */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/DataMask.js");
var FormatException_1 = __webpack_require__(/*! ../../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
/**
 * @author Sean Owen
 */
var BitMatrixParser = /** @class */ (function () {
    /**
     * @param bitMatrix {@link BitMatrix} to parse
     * @throws FormatException if dimension is not >= 21 and 1 mod 4
     */
    function BitMatrixParser(bitMatrix) {
        var dimension = bitMatrix.getHeight();
        if (dimension < 21 || (dimension & 0x03) !== 1) {
            throw new FormatException_1.default();
        }
        this.bitMatrix = bitMatrix;
    }
    /**
     * <p>Reads format information from one of its two locations within the QR Code.</p>
     *
     * @return {@link FormatInformation} encapsulating the QR Code's format info
     * @throws FormatException if both format information locations cannot be parsed as
     * the valid encoding of format information
     */
    BitMatrixParser.prototype.readFormatInformation = function () {
        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== undefined) {
            return this.parsedFormatInfo;
        }
        // Read top-left format info bits
        var formatInfoBits1 = 0;
        for (var i = 0; i < 6; i++) {
            formatInfoBits1 = this.copyBit(i, 8, formatInfoBits1);
        }
        // .. and skip a bit in the timing pattern ...
        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);
        // .. and skip a bit in the timing pattern ...
        for (var j = 5; j >= 0; j--) {
            formatInfoBits1 = this.copyBit(8, j, formatInfoBits1);
        }
        // Read the top-right/bottom-left pattern too
        var dimension = this.bitMatrix.getHeight();
        var formatInfoBits2 = 0;
        var jMin = dimension - 7;
        for (var j = dimension - 1; j >= jMin; j--) {
            formatInfoBits2 = this.copyBit(8, j, formatInfoBits2);
        }
        for (var i = dimension - 8; i < dimension; i++) {
            formatInfoBits2 = this.copyBit(i, 8, formatInfoBits2);
        }
        this.parsedFormatInfo = FormatInformation_1.default.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
        if (this.parsedFormatInfo !== null) {
            return this.parsedFormatInfo;
        }
        throw new FormatException_1.default();
    };
    /**
     * <p>Reads version information from one of its two locations within the QR Code.</p>
     *
     * @return {@link Version} encapsulating the QR Code's version
     * @throws FormatException if both version information locations cannot be parsed as
     * the valid encoding of version information
     */
    BitMatrixParser.prototype.readVersion = function () {
        if (this.parsedVersion !== null && this.parsedVersion !== undefined) {
            return this.parsedVersion;
        }
        var dimension = this.bitMatrix.getHeight();
        var provisionalVersion = Math.floor((dimension - 17) / 4);
        if (provisionalVersion <= 6) {
            return Version_1.default.getVersionForNumber(provisionalVersion);
        }
        // Read top-right version info: 3 wide by 6 tall
        var versionBits = 0;
        var ijMin = dimension - 11;
        for (var j = 5; j >= 0; j--) {
            for (var i = dimension - 9; i >= ijMin; i--) {
                versionBits = this.copyBit(i, j, versionBits);
            }
        }
        var theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
            this.parsedVersion = theParsedVersion;
            return theParsedVersion;
        }
        // Hmm, failed. Try bottom left: 6 wide by 3 tall
        versionBits = 0;
        for (var i = 5; i >= 0; i--) {
            for (var j = dimension - 9; j >= ijMin; j--) {
                versionBits = this.copyBit(i, j, versionBits);
            }
        }
        theParsedVersion = Version_1.default.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
            this.parsedVersion = theParsedVersion;
            return theParsedVersion;
        }
        throw new FormatException_1.default();
    };
    BitMatrixParser.prototype.copyBit = function (i /*int*/, j /*int*/, versionBits /*int*/) {
        var bit = this.isMirror ? this.bitMatrix.get(j, i) : this.bitMatrix.get(i, j);
        return bit ? (versionBits << 1) | 0x1 : versionBits << 1;
    };
    /**
     * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the
     * correct order in order to reconstruct the codewords bytes contained within the
     * QR Code.</p>
     *
     * @return bytes encoded within the QR Code
     * @throws FormatException if the exact number of bytes expected is not read
     */
    BitMatrixParser.prototype.readCodewords = function () {
        var formatInfo = this.readFormatInformation();
        var version = this.readVersion();
        // Get the data mask for the format used in this QR Code. This will exclude
        // some bits from reading as we wind through the bit matrix.
        var dataMask = DataMask_1.default.values.get(formatInfo.getDataMask());
        var dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
        var functionPattern = version.buildFunctionPattern();
        var readingUp = true;
        var result = new Uint8Array(version.getTotalCodewords());
        var resultOffset = 0;
        var currentByte = 0;
        var bitsRead = 0;
        // Read columns in pairs, from right to left
        for (var j = dimension - 1; j > 0; j -= 2) {
            if (j === 6) {
                // Skip whole column with vertical alignment pattern
                // saves time and makes the other code proceed more cleanly
                j--;
            }
            // Read alternatingly from bottom to top then top to bottom
            for (var count = 0; count < dimension; count++) {
                var i = readingUp ? dimension - 1 - count : count;
                for (var col = 0; col < 2; col++) {
                    // Ignore bits covered by the function pattern
                    if (!functionPattern.get(j - col, i)) {
                        // Read a bit
                        bitsRead++;
                        currentByte <<= 1;
                        if (this.bitMatrix.get(j - col, i)) {
                            currentByte |= 1;
                        }
                        // If we've made a whole byte, save it off
                        if (bitsRead === 8) {
                            result[resultOffset++] = /*(byte) */ currentByte;
                            bitsRead = 0;
                            currentByte = 0;
                        }
                    }
                }
            }
            readingUp = !readingUp; // readingUp ^= true; // readingUp = !readingUp; // switch directions
        }
        if (resultOffset !== version.getTotalCodewords()) {
            throw new FormatException_1.default();
        }
        return result;
    };
    /**
     * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.
     */
    BitMatrixParser.prototype.remask = function () {
        if (this.parsedFormatInfo === null) {
            return; // We have no format information, and have no data mask
        }
        var dataMask = DataMask_1.default.values[this.parsedFormatInfo.getDataMask()];
        var dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
    };
    /**
     * Prepare the parser for a mirrored operation.
     * This flag has effect only on the {@link #readFormatInformation()} and the
     * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the
     * {@link #mirror()} method should be called.
     *
     * @param mirror Whether to read version and format information mirrored.
     */
    BitMatrixParser.prototype.setMirror = function (isMirror) {
        this.parsedVersion = null;
        this.parsedFormatInfo = null;
        this.isMirror = isMirror;
    };
    /** Mirror the bit matrix in order to attempt a second reading. */
    BitMatrixParser.prototype.mirror = function () {
        var bitMatrix = this.bitMatrix;
        for (var x = 0, width = bitMatrix.getWidth(); x < width; x++) {
            for (var y = x + 1, height = bitMatrix.getHeight(); y < height; y++) {
                if (bitMatrix.get(x, y) !== bitMatrix.get(y, x)) {
                    bitMatrix.flip(y, x);
                    bitMatrix.flip(x, y);
                }
            }
        }
    };
    return BitMatrixParser;
}());
exports.default = BitMatrixParser;
//# sourceMappingURL=BitMatrixParser.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/DataBlock.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/DataBlock.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into
 * multiple blocks, each of which is a unit of data and error-correction codewords. Each
 * is represented by an instance of this class.</p>
 *
 * @author Sean Owen
 */
var DataBlock = /** @class */ (function () {
    function DataBlock(numDataCodewords /*int*/, codewords) {
        this.numDataCodewords = numDataCodewords;
        this.codewords = codewords;
    }
    /**
     * <p>When QR Codes use multiple data blocks, they are actually interleaved.
     * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
     * method will separate the data into original blocks.</p>
     *
     * @param rawCodewords bytes as read directly from the QR Code
     * @param version version of the QR Code
     * @param ecLevel error-correction level of the QR Code
     * @return DataBlocks containing original bytes, "de-interleaved" from representation in the
     *         QR Code
     */
    DataBlock.getDataBlocks = function (rawCodewords, version, ecLevel) {
        var e_1, _a, e_2, _b;
        if (rawCodewords.length !== version.getTotalCodewords()) {
            throw new IllegalArgumentException_1.default();
        }
        // Figure out the number and size of data blocks used by this version and
        // error correction level
        var ecBlocks = version.getECBlocksForLevel(ecLevel);
        // First count the total number of data blocks
        var totalBlocks = 0;
        var ecBlockArray = ecBlocks.getECBlocks();
        try {
            for (var ecBlockArray_1 = __values(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {
                var ecBlock = ecBlockArray_1_1.value;
                totalBlocks += ecBlock.getCount();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return)) _a.call(ecBlockArray_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Now establish DataBlocks of the appropriate size and number of data codewords
        var result = new Array(totalBlocks);
        var numResultBlocks = 0;
        try {
            for (var ecBlockArray_2 = __values(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {
                var ecBlock = ecBlockArray_2_1.value;
                for (var i = 0; i < ecBlock.getCount(); i++) {
                    var numDataCodewords = ecBlock.getDataCodewords();
                    var numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;
                    result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // All blocks have the same amount of data, except that the last n
        // (where n may be 0) have 1 more byte. Figure out where these start.
        var shorterBlocksTotalCodewords = result[0].codewords.length;
        var longerBlocksStartAt = result.length - 1;
        // TYPESCRIPTPORT: check length is correct here
        while (longerBlocksStartAt >= 0) {
            var numCodewords = result[longerBlocksStartAt].codewords.length;
            if (numCodewords === shorterBlocksTotalCodewords) {
                break;
            }
            longerBlocksStartAt--;
        }
        longerBlocksStartAt++;
        var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();
        // The last elements of result may be 1 element longer
        // first fill out as many elements as all of them have
        var rawCodewordsOffset = 0;
        for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {
            for (var j = 0; j < numResultBlocks; j++) {
                result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];
            }
        }
        // Fill out the last data block in the longer ones
        for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {
            result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
        }
        // Now add in error correction blocks
        var max = result[0].codewords.length;
        for (var i = shorterBlocksNumDataCodewords; i < max; i++) {
            for (var j = 0; j < numResultBlocks; j++) {
                var iOffset = j < longerBlocksStartAt ? i : i + 1;
                result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
            }
        }
        return result;
    };
    DataBlock.prototype.getNumDataCodewords = function () {
        return this.numDataCodewords;
    };
    DataBlock.prototype.getCodewords = function () {
        return this.codewords;
    };
    return DataBlock;
}());
exports.default = DataBlock;
//# sourceMappingURL=DataBlock.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/DataMask.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/DataMask.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var DataMaskValues;
(function (DataMaskValues) {
    DataMaskValues[DataMaskValues["DATA_MASK_000"] = 0] = "DATA_MASK_000";
    DataMaskValues[DataMaskValues["DATA_MASK_001"] = 1] = "DATA_MASK_001";
    DataMaskValues[DataMaskValues["DATA_MASK_010"] = 2] = "DATA_MASK_010";
    DataMaskValues[DataMaskValues["DATA_MASK_011"] = 3] = "DATA_MASK_011";
    DataMaskValues[DataMaskValues["DATA_MASK_100"] = 4] = "DATA_MASK_100";
    DataMaskValues[DataMaskValues["DATA_MASK_101"] = 5] = "DATA_MASK_101";
    DataMaskValues[DataMaskValues["DATA_MASK_110"] = 6] = "DATA_MASK_110";
    DataMaskValues[DataMaskValues["DATA_MASK_111"] = 7] = "DATA_MASK_111";
})(DataMaskValues = exports.DataMaskValues || (exports.DataMaskValues = {}));
/**
 * <p>Encapsulates data masks for the data bits in a QR code, per ISO 18004:2006 6.8. Implementations
 * of this class can un-mask a raw BitMatrix. For simplicity, they will unmask the entire BitMatrix,
 * including areas used for finder patterns, timing patterns, etc. These areas should be unused
 * after the point they are unmasked anyway.</p>
 *
 * <p>Note that the diagram in section 6.8.1 is misleading since it indicates that i is column position
 * and j is row position. In fact, as the text says, i is row position and j is column position.</p>
 *
 * @author Sean Owen
 */
var DataMask = /** @class */ (function () {
    // See ISO 18004:2006 6.8.1
    function DataMask(value, isMasked) {
        this.value = value;
        this.isMasked = isMasked;
    }
    // End of enum constants.
    /**
     * <p>Implementations of this method reverse the data masking process applied to a QR Code and
     * make its bits ready to read.</p>
     *
     * @param bits representation of QR Code bits
     * @param dimension dimension of QR Code, represented by bits, being unmasked
     */
    DataMask.prototype.unmaskBitMatrix = function (bits, dimension /*int*/) {
        for (var i = 0; i < dimension; i++) {
            for (var j = 0; j < dimension; j++) {
                if (this.isMasked(i, j)) {
                    bits.flip(j, i);
                }
            }
        }
    };
    DataMask.values = new Map([
        /**
         * 000: mask bits for which (x + y) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, function (i /*int*/, j /*int*/) { return ((i + j) & 0x01) === 0; })],
        /**
         * 001: mask bits for which x mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, function (i /*int*/, j /*int*/) { return (i & 0x01) === 0; })],
        /**
         * 010: mask bits for which y mod 3 == 0
         */
        [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, function (i /*int*/, j /*int*/) { return j % 3 === 0; })],
        /**
         * 011: mask bits for which (x + y) mod 3 == 0
         */
        [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, function (i /*int*/, j /*int*/) { return (i + j) % 3 === 0; })],
        /**
         * 100: mask bits for which (x/2 + y/3) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, function (i /*int*/, j /*int*/) { return ((Math.floor(i / 2) + Math.floor(j / 3)) & 0x01) === 0; })],
        /**
         * 101: mask bits for which xy mod 2 + xy mod 3 == 0
         * equivalently, such that xy mod 6 == 0
         */
        [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, function (i /*int*/, j /*int*/) { return (i * j) % 6 === 0; })],
        /**
         * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0
         * equivalently, such that xy mod 6 < 3
         */
        [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, function (i /*int*/, j /*int*/) { return ((i * j) % 6) < 3; })],
        /**
         * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0
         * equivalently, such that (x + y + xy mod 3) mod 2 == 0
         */
        [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, function (i /*int*/, j /*int*/) { return ((i + j + ((i * j) % 3)) & 0x01) === 0; })],
    ]);
    return DataMask;
}());
exports.default = DataMask;
//# sourceMappingURL=DataMask.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/DecodedBitStreamParser.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/DecodedBitStreamParser.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var BitSource_1 = __webpack_require__(/*! ../../common/BitSource */ "./node_modules/@zxing/library/esm5/core/common/BitSource.js");
var CharacterSetECI_1 = __webpack_require__(/*! ../../common/CharacterSetECI */ "./node_modules/@zxing/library/esm5/core/common/CharacterSetECI.js");
var DecoderResult_1 = __webpack_require__(/*! ../../common/DecoderResult */ "./node_modules/@zxing/library/esm5/core/common/DecoderResult.js");
var StringUtils_1 = __webpack_require__(/*! ../../common/StringUtils */ "./node_modules/@zxing/library/esm5/core/common/StringUtils.js");
var Mode_1 = __webpack_require__(/*! ./Mode */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/Mode.js");
var StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
var StringEncoding_1 = __webpack_require__(/*! ../../util/StringEncoding */ "./node_modules/@zxing/library/esm5/core/util/StringEncoding.js");
var FormatException_1 = __webpack_require__(/*! ../../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
/*import java.io.UnsupportedEncodingException;*/
/*import java.util.ArrayList;*/
/*import java.util.Collection;*/
/*import java.util.List;*/
/*import java.util.Map;*/
/**
 * <p>QR Codes can encode text as bits in one of several modes, and can use multiple modes
 * in one QR Code. This class decodes the bits back into text.</p>
 *
 * <p>See ISO 18004:2006, 6.4.3 - 6.4.7</p>
 *
 * @author Sean Owen
 */
var DecodedBitStreamParser = /** @class */ (function () {
    function DecodedBitStreamParser() {
    }
    DecodedBitStreamParser.decode = function (bytes, version, ecLevel, hints) {
        var bits = new BitSource_1.default(bytes);
        var result = new StringBuilder_1.default();
        var byteSegments = new Array(); // 1
        // TYPESCRIPTPORT: I do not use constructor with size 1 as in original Java means capacity and the array length is checked below
        var symbolSequence = -1;
        var parityData = -1;
        try {
            var currentCharacterSetECI = null;
            var fc1InEffect = false;
            var mode = void 0;
            do {
                // While still another segment to read...
                if (bits.available() < 4) {
                    // OK, assume we're done. Really, a TERMINATOR mode should have been recorded here
                    mode = Mode_1.default.TERMINATOR;
                }
                else {
                    var modeBits = bits.readBits(4);
                    mode = Mode_1.default.forBits(modeBits); // mode is encoded by 4 bits
                }
                switch (mode) {
                    case Mode_1.default.TERMINATOR:
                        break;
                    case Mode_1.default.FNC1_FIRST_POSITION:
                    case Mode_1.default.FNC1_SECOND_POSITION:
                        // We do little with FNC1 except alter the parsed result a bit according to the spec
                        fc1InEffect = true;
                        break;
                    case Mode_1.default.STRUCTURED_APPEND:
                        if (bits.available() < 16) {
                            throw new FormatException_1.default();
                        }
                        // sequence number and parity is added later to the result metadata
                        // Read next 8 bits (symbol sequence #) and 8 bits (data: parity), then continue
                        symbolSequence = bits.readBits(8);
                        parityData = bits.readBits(8);
                        break;
                    case Mode_1.default.ECI:
                        // Count doesn't apply to ECI
                        var value = DecodedBitStreamParser.parseECIValue(bits);
                        currentCharacterSetECI = CharacterSetECI_1.default.getCharacterSetECIByValue(value);
                        if (currentCharacterSetECI === null) {
                            throw new FormatException_1.default();
                        }
                        break;
                    case Mode_1.default.HANZI:
                        // First handle Hanzi mode which does not start with character count
                        // Chinese mode contains a sub set indicator right after mode indicator
                        var subset = bits.readBits(4);
                        var countHanzi = bits.readBits(mode.getCharacterCountBits(version));
                        if (subset === DecodedBitStreamParser.GB2312_SUBSET) {
                            DecodedBitStreamParser.decodeHanziSegment(bits, result, countHanzi);
                        }
                        break;
                    default:
                        // "Normal" QR code modes:
                        // How many characters will follow, encoded in this mode?
                        var count = bits.readBits(mode.getCharacterCountBits(version));
                        switch (mode) {
                            case Mode_1.default.NUMERIC:
                                DecodedBitStreamParser.decodeNumericSegment(bits, result, count);
                                break;
                            case Mode_1.default.ALPHANUMERIC:
                                DecodedBitStreamParser.decodeAlphanumericSegment(bits, result, count, fc1InEffect);
                                break;
                            case Mode_1.default.BYTE:
                                DecodedBitStreamParser.decodeByteSegment(bits, result, count, currentCharacterSetECI, byteSegments, hints);
                                break;
                            case Mode_1.default.KANJI:
                                DecodedBitStreamParser.decodeKanjiSegment(bits, result, count);
                                break;
                            default:
                                throw new FormatException_1.default();
                        }
                        break;
                }
            } while (mode !== Mode_1.default.TERMINATOR);
        }
        catch (iae /*: IllegalArgumentException*/) {
            // from readBits() calls
            throw new FormatException_1.default();
        }
        return new DecoderResult_1.default(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);
    };
    /**
     * See specification GBT 18284-2000
     */
    DecodedBitStreamParser.decodeHanziSegment = function (bits, result, count /*int*/) {
        // Don't crash trying to read more bits than we have available.
        if (count * 13 > bits.available()) {
            throw new FormatException_1.default();
        }
        // Each character will require 2 bytes. Read the characters as 2-byte pairs
        // and decode as GB2312 afterwards
        var buffer = new Uint8Array(2 * count);
        var offset = 0;
        while (count > 0) {
            // Each 13 bits encodes a 2-byte character
            var twoBytes = bits.readBits(13);
            var assembledTwoBytes = (((twoBytes / 0x060) << 8) & 0xFFFFFFFF) | (twoBytes % 0x060);
            if (assembledTwoBytes < 0x003BF) {
                // In the 0xA1A1 to 0xAAFE range
                assembledTwoBytes += 0x0A1A1;
            }
            else {
                // In the 0xB0A1 to 0xFAFE range
                assembledTwoBytes += 0x0A6A1;
            }
            buffer[offset] = /*(byte) */ ((assembledTwoBytes >> 8) & 0xFF);
            buffer[offset + 1] = /*(byte) */ (assembledTwoBytes & 0xFF);
            offset += 2;
            count--;
        }
        try {
            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.GB2312));
            // TYPESCRIPTPORT: TODO: implement GB2312 decode. StringView from MDN could be a starting point
        }
        catch (ignored /*: UnsupportedEncodingException*/) {
            throw new FormatException_1.default(ignored);
        }
    };
    DecodedBitStreamParser.decodeKanjiSegment = function (bits, result, count /*int*/) {
        // Don't crash trying to read more bits than we have available.
        if (count * 13 > bits.available()) {
            throw new FormatException_1.default();
        }
        // Each character will require 2 bytes. Read the characters as 2-byte pairs
        // and decode as Shift_JIS afterwards
        var buffer = new Uint8Array(2 * count);
        var offset = 0;
        while (count > 0) {
            // Each 13 bits encodes a 2-byte character
            var twoBytes = bits.readBits(13);
            var assembledTwoBytes = (((twoBytes / 0x0C0) << 8) & 0xFFFFFFFF) | (twoBytes % 0x0C0);
            if (assembledTwoBytes < 0x01F00) {
                // In the 0x8140 to 0x9FFC range
                assembledTwoBytes += 0x08140;
            }
            else {
                // In the 0xE040 to 0xEBBF range
                assembledTwoBytes += 0x0C140;
            }
            buffer[offset] = /*(byte) */ (assembledTwoBytes >> 8);
            buffer[offset + 1] = /*(byte) */ assembledTwoBytes;
            offset += 2;
            count--;
        }
        // Shift_JIS may not be supported in some environments:
        try {
            result.append(StringEncoding_1.default.decode(buffer, StringUtils_1.default.SHIFT_JIS));
            // TYPESCRIPTPORT: TODO: implement SHIFT_JIS decode. StringView from MDN could be a starting point
        }
        catch (ignored /*: UnsupportedEncodingException*/) {
            throw new FormatException_1.default(ignored);
        }
    };
    DecodedBitStreamParser.decodeByteSegment = function (bits, result, count /*int*/, currentCharacterSetECI, byteSegments, hints) {
        // Don't crash trying to read more bits than we have available.
        if (8 * count > bits.available()) {
            throw new FormatException_1.default();
        }
        var readBytes = new Uint8Array(count);
        for (var i = 0; i < count; i++) {
            readBytes[i] = /*(byte) */ bits.readBits(8);
        }
        var encoding;
        if (currentCharacterSetECI === null) {
            // The spec isn't clear on this mode; see
            // section 6.4.5: t does not say which encoding to assuming
            // upon decoding. I have seen ISO-8859-1 used as well as
            // Shift_JIS -- without anything like an ECI designator to
            // give a hint.
            encoding = StringUtils_1.default.guessEncoding(readBytes, hints);
        }
        else {
            encoding = currentCharacterSetECI.getName();
        }
        try {
            result.append(StringEncoding_1.default.decode(readBytes, encoding));
        }
        catch (ignored /*: UnsupportedEncodingException*/) {
            throw new FormatException_1.default(ignored);
        }
        byteSegments.push(readBytes);
    };
    DecodedBitStreamParser.toAlphaNumericChar = function (value /*int*/) {
        if (value >= DecodedBitStreamParser.ALPHANUMERIC_CHARS.length) {
            throw new FormatException_1.default();
        }
        return DecodedBitStreamParser.ALPHANUMERIC_CHARS[value];
    };
    DecodedBitStreamParser.decodeAlphanumericSegment = function (bits, result, count /*int*/, fc1InEffect) {
        // Read two characters at a time
        var start = result.length();
        while (count > 1) {
            if (bits.available() < 11) {
                throw new FormatException_1.default();
            }
            var nextTwoCharsBits = bits.readBits(11);
            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));
            result.append(DecodedBitStreamParser.toAlphaNumericChar(nextTwoCharsBits % 45));
            count -= 2;
        }
        if (count === 1) {
            // special case: one character left
            if (bits.available() < 6) {
                throw new FormatException_1.default();
            }
            result.append(DecodedBitStreamParser.toAlphaNumericChar(bits.readBits(6)));
        }
        // See section 6.4.8.1, 6.4.8.2
        if (fc1InEffect) {
            // We need to massage the result a bit if in an FNC1 mode:
            for (var i = start; i < result.length(); i++) {
                if (result.charAt(i) === '%') {
                    if (i < result.length() - 1 && result.charAt(i + 1) === '%') {
                        // %% is rendered as %
                        result.deleteCharAt(i + 1);
                    }
                    else {
                        // In alpha mode, % should be converted to FNC1 separator 0x1D
                        result.setCharAt(i, String.fromCharCode(0x1D));
                    }
                }
            }
        }
    };
    DecodedBitStreamParser.decodeNumericSegment = function (bits, result, count /*int*/) {
        // Read three digits at a time
        while (count >= 3) {
            // Each 10 bits encodes three digits
            if (bits.available() < 10) {
                throw new FormatException_1.default();
            }
            var threeDigitsBits = bits.readBits(10);
            if (threeDigitsBits >= 1000) {
                throw new FormatException_1.default();
            }
            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));
            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));
            result.append(DecodedBitStreamParser.toAlphaNumericChar(threeDigitsBits % 10));
            count -= 3;
        }
        if (count === 2) {
            // Two digits left over to read, encoded in 7 bits
            if (bits.available() < 7) {
                throw new FormatException_1.default();
            }
            var twoDigitsBits = bits.readBits(7);
            if (twoDigitsBits >= 100) {
                throw new FormatException_1.default();
            }
            result.append(DecodedBitStreamParser.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));
            result.append(DecodedBitStreamParser.toAlphaNumericChar(twoDigitsBits % 10));
        }
        else if (count === 1) {
            // One digit left over to read
            if (bits.available() < 4) {
                throw new FormatException_1.default();
            }
            var digitBits = bits.readBits(4);
            if (digitBits >= 10) {
                throw new FormatException_1.default();
            }
            result.append(DecodedBitStreamParser.toAlphaNumericChar(digitBits));
        }
    };
    DecodedBitStreamParser.parseECIValue = function (bits) {
        var firstByte = bits.readBits(8);
        if ((firstByte & 0x80) === 0) {
            // just one byte
            return firstByte & 0x7F;
        }
        if ((firstByte & 0xC0) === 0x80) {
            // two bytes
            var secondByte = bits.readBits(8);
            return (((firstByte & 0x3F) << 8) & 0xFFFFFFFF) | secondByte;
        }
        if ((firstByte & 0xE0) === 0xC0) {
            // three bytes
            var secondThirdBytes = bits.readBits(16);
            return (((firstByte & 0x1F) << 16) & 0xFFFFFFFF) | secondThirdBytes;
        }
        throw new FormatException_1.default();
    };
    /**
     * See ISO 18004:2006, 6.4.4 Table 5
     */
    DecodedBitStreamParser.ALPHANUMERIC_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';
    DecodedBitStreamParser.GB2312_SUBSET = 1;
    return DecodedBitStreamParser;
}());
exports.default = DecodedBitStreamParser;
function Uint8ArrayToString(a) {
    var CHUNK_SZ = 0x8000;
    var c = new StringBuilder_1.default();
    for (var i = 0, length_1 = a.length; i < length_1; i += CHUNK_SZ) {
        c.append(String.fromCharCode.apply(null, a.subarray(i, i + CHUNK_SZ)));
    }
    return c.toString();
}
//# sourceMappingURL=DecodedBitStreamParser.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/Decoder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/Decoder.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var BitMatrix_1 = __webpack_require__(/*! ../../common/BitMatrix */ "./node_modules/@zxing/library/esm5/core/common/BitMatrix.js");
var GenericGF_1 = __webpack_require__(/*! ../../common/reedsolomon/GenericGF */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGF.js");
var ReedSolomonDecoder_1 = __webpack_require__(/*! ../../common/reedsolomon/ReedSolomonDecoder */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/ReedSolomonDecoder.js");
var BitMatrixParser_1 = __webpack_require__(/*! ./BitMatrixParser */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/BitMatrixParser.js");
var QRCodeDecoderMetaData_1 = __webpack_require__(/*! ./QRCodeDecoderMetaData */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/QRCodeDecoderMetaData.js");
var DataBlock_1 = __webpack_require__(/*! ./DataBlock */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/DataBlock.js");
var DecodedBitStreamParser_1 = __webpack_require__(/*! ./DecodedBitStreamParser */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/DecodedBitStreamParser.js");
var ChecksumException_1 = __webpack_require__(/*! ../../ChecksumException */ "./node_modules/@zxing/library/esm5/core/ChecksumException.js");
/*import java.util.Map;*/
/**
 * <p>The main class which implements QR Code decoding -- as opposed to locating and extracting
 * the QR Code from an image.</p>
 *
 * @author Sean Owen
 */
var Decoder = /** @class */ (function () {
    function Decoder() {
        this.rsDecoder = new ReedSolomonDecoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256);
    }
    // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {
    //   return decode(image, null)
    // }
    /**
     * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.
     * "true" is taken to mean a black module.</p>
     *
     * @param image booleans representing white/black QR Code modules
     * @param hints decoding hints that should be used to influence decoding
     * @return text and bytes encoded within the QR Code
     * @throws FormatException if the QR Code cannot be decoded
     * @throws ChecksumException if error correction fails
     */
    Decoder.prototype.decodeBooleanArray = function (image, hints) {
        return this.decodeBitMatrix(BitMatrix_1.default.parseFromBooleanArray(image), hints);
    };
    // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {
    //   return decode(bits, null)
    // }
    /**
     * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or "true" is taken to mean a black module.</p>
     *
     * @param bits booleans representing white/black QR Code modules
     * @param hints decoding hints that should be used to influence decoding
     * @return text and bytes encoded within the QR Code
     * @throws FormatException if the QR Code cannot be decoded
     * @throws ChecksumException if error correction fails
     */
    Decoder.prototype.decodeBitMatrix = function (bits, hints) {
        // Construct a parser and read version, error-correction level
        var parser = new BitMatrixParser_1.default(bits);
        var ex = null;
        try {
            return this.decodeBitMatrixParser(parser, hints);
        }
        catch (e /*: FormatException, ChecksumException*/) {
            ex = e;
        }
        try {
            // Revert the bit matrix
            parser.remask();
            // Will be attempting a mirrored reading of the version and format info.
            parser.setMirror(true);
            // Preemptively read the version.
            parser.readVersion();
            // Preemptively read the format information.
            parser.readFormatInformation();
            /*
             * Since we're here, this means we have successfully detected some kind
             * of version and format information when mirrored. This is a good sign,
             * that the QR code may be mirrored, and we should try once more with a
             * mirrored content.
             */
            // Prepare for a mirrored reading.
            parser.mirror();
            var result = this.decodeBitMatrixParser(parser, hints);
            // Success! Notify the caller that the code was mirrored.
            result.setOther(new QRCodeDecoderMetaData_1.default(true));
            return result;
        }
        catch (e /*FormatException | ChecksumException*/) {
            // Throw the exception from the original reading
            if (ex !== null) {
                throw ex;
            }
            throw e;
        }
    };
    Decoder.prototype.decodeBitMatrixParser = function (parser, hints) {
        var e_1, _a, e_2, _b;
        var version = parser.readVersion();
        var ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();
        // Read codewords
        var codewords = parser.readCodewords();
        // Separate into data blocks
        var dataBlocks = DataBlock_1.default.getDataBlocks(codewords, version, ecLevel);
        // Count total number of data bytes
        var totalBytes = 0;
        try {
            for (var dataBlocks_1 = __values(dataBlocks), dataBlocks_1_1 = dataBlocks_1.next(); !dataBlocks_1_1.done; dataBlocks_1_1 = dataBlocks_1.next()) {
                var dataBlock = dataBlocks_1_1.value;
                totalBytes += dataBlock.getNumDataCodewords();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (dataBlocks_1_1 && !dataBlocks_1_1.done && (_a = dataBlocks_1.return)) _a.call(dataBlocks_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var resultBytes = new Uint8Array(totalBytes);
        var resultOffset = 0;
        try {
            // Error-correct and copy data blocks together into a stream of bytes
            for (var dataBlocks_2 = __values(dataBlocks), dataBlocks_2_1 = dataBlocks_2.next(); !dataBlocks_2_1.done; dataBlocks_2_1 = dataBlocks_2.next()) {
                var dataBlock = dataBlocks_2_1.value;
                var codewordBytes = dataBlock.getCodewords();
                var numDataCodewords = dataBlock.getNumDataCodewords();
                this.correctErrors(codewordBytes, numDataCodewords);
                for (var i = 0; i < numDataCodewords; i++) {
                    resultBytes[resultOffset++] = codewordBytes[i];
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (dataBlocks_2_1 && !dataBlocks_2_1.done && (_b = dataBlocks_2.return)) _b.call(dataBlocks_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // Decode the contents of that stream of bytes
        return DecodedBitStreamParser_1.default.decode(resultBytes, version, ecLevel, hints);
    };
    /**
     * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
     * correct the errors in-place using Reed-Solomon error correction.</p>
     *
     * @param codewordBytes data and error correction codewords
     * @param numDataCodewords number of codewords that are data bytes
     * @throws ChecksumException if error correction fails
     */
    Decoder.prototype.correctErrors = function (codewordBytes, numDataCodewords /*int*/) {
        var numCodewords = codewordBytes.length;
        // First read into an array of ints
        var codewordsInts = new Int32Array(codewordBytes);
        // TYPESCRIPTPORT: not realy necessary to transform to ints? could redesign everything to work with unsigned bytes?
        // const codewordsInts = new Int32Array(numCodewords)
        // for (let i = 0; i < numCodewords; i++) {
        //   codewordsInts[i] = codewordBytes[i] & 0xFF
        // }
        try {
            this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
        }
        catch (ignored /*: ReedSolomonException*/) {
            throw new ChecksumException_1.default();
        }
        // Copy back into array of bytes -- only need to worry about the bytes that were data
        // We don't care about errors in the error-correction codewords
        for (var i = 0; i < numDataCodewords; i++) {
            codewordBytes[i] = /*(byte) */ codewordsInts[i];
        }
    };
    return Decoder;
}());
exports.default = Decoder;
//# sourceMappingURL=Decoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/ECB.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/ECB.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * <p>Encapsulates the parameters for one error-correction block in one symbol version.
 * This includes the number of data codewords, and the number of times a block with these
 * parameters is used consecutively in the QR code version's format.</p>
 */
var ECB = /** @class */ (function () {
    function ECB(count /*int*/, dataCodewords /*int*/) {
        this.count = count;
        this.dataCodewords = dataCodewords;
    }
    ECB.prototype.getCount = function () {
        return this.count;
    };
    ECB.prototype.getDataCodewords = function () {
        return this.dataCodewords;
    };
    return ECB;
}());
exports.default = ECB;
//# sourceMappingURL=ECB.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/ECBlocks.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/ECBlocks.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * <p>Encapsulates a set of error-correction blocks in one symbol version. Most versions will
 * use blocks of differing sizes within one version, so, this encapsulates the parameters for
 * each set of blocks. It also holds the number of error-correction codewords per block since it
 * will be the same across all blocks within one version.</p>
 */
var ECBlocks = /** @class */ (function () {
    function ECBlocks(ecCodewordsPerBlock /*int*/) {
        var ecBlocks = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            ecBlocks[_i - 1] = arguments[_i];
        }
        this.ecCodewordsPerBlock = ecCodewordsPerBlock;
        this.ecBlocks = ecBlocks;
    }
    ECBlocks.prototype.getECCodewordsPerBlock = function () {
        return this.ecCodewordsPerBlock;
    };
    ECBlocks.prototype.getNumBlocks = function () {
        var e_1, _a;
        var total = 0;
        var ecBlocks = this.ecBlocks;
        try {
            for (var ecBlocks_1 = __values(ecBlocks), ecBlocks_1_1 = ecBlocks_1.next(); !ecBlocks_1_1.done; ecBlocks_1_1 = ecBlocks_1.next()) {
                var ecBlock = ecBlocks_1_1.value;
                total += ecBlock.getCount();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ecBlocks_1_1 && !ecBlocks_1_1.done && (_a = ecBlocks_1.return)) _a.call(ecBlocks_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return total;
    };
    ECBlocks.prototype.getTotalECCodewords = function () {
        return this.ecCodewordsPerBlock * this.getNumBlocks();
    };
    ECBlocks.prototype.getECBlocks = function () {
        return this.ecBlocks;
    };
    return ECBlocks;
}());
exports.default = ECBlocks;
//# sourceMappingURL=ECBlocks.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/ErrorCorrectionLevel.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/ErrorCorrectionLevel.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode.decoder {*/
var ArgumentException_1 = __webpack_require__(/*! ../../ArgumentException */ "./node_modules/@zxing/library/esm5/core/ArgumentException.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
var ErrorCorrectionLevelValues;
(function (ErrorCorrectionLevelValues) {
    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["L"] = 0] = "L";
    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["M"] = 1] = "M";
    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["Q"] = 2] = "Q";
    ErrorCorrectionLevelValues[ErrorCorrectionLevelValues["H"] = 3] = "H";
})(ErrorCorrectionLevelValues = exports.ErrorCorrectionLevelValues || (exports.ErrorCorrectionLevelValues = {}));
/**
 * <p>See ISO 18004:2006, 6.5.1. This enum encapsulates the four error correction levels
 * defined by the QR code standard.</p>
 *
 * @author Sean Owen
 */
var ErrorCorrectionLevel = /** @class */ (function () {
    function ErrorCorrectionLevel(value, stringValue, bits /*int*/) {
        this.value = value;
        this.stringValue = stringValue;
        this.bits = bits;
        ErrorCorrectionLevel.FOR_BITS.set(bits, this);
        ErrorCorrectionLevel.FOR_VALUE.set(value, this);
    }
    ErrorCorrectionLevel.prototype.getValue = function () {
        return this.value;
    };
    ErrorCorrectionLevel.prototype.getBits = function () {
        return this.bits;
    };
    ErrorCorrectionLevel.fromString = function (s) {
        switch (s) {
            case 'L': return ErrorCorrectionLevel.L;
            case 'M': return ErrorCorrectionLevel.M;
            case 'Q': return ErrorCorrectionLevel.Q;
            case 'H': return ErrorCorrectionLevel.H;
            default: throw new ArgumentException_1.default(s + 'not available');
        }
    };
    ErrorCorrectionLevel.prototype.toString = function () {
        return this.stringValue;
    };
    ErrorCorrectionLevel.prototype.equals = function (o) {
        if (!(o instanceof ErrorCorrectionLevel)) {
            return false;
        }
        var other = o;
        return this.value === other.value;
    };
    /**
     * @param bits int containing the two bits encoding a QR Code's error correction level
     * @return ErrorCorrectionLevel representing the encoded error correction level
     */
    ErrorCorrectionLevel.forBits = function (bits /*int*/) {
        if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {
            throw new IllegalArgumentException_1.default();
        }
        return ErrorCorrectionLevel.FOR_BITS.get(bits);
    };
    ErrorCorrectionLevel.FOR_BITS = new Map();
    ErrorCorrectionLevel.FOR_VALUE = new Map();
    /** L = ~7% correction */
    ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, 'L', 0x01);
    /** M = ~15% correction */
    ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, 'M', 0x00);
    /** Q = ~25% correction */
    ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, 'Q', 0x03);
    /** H = ~30% correction */
    ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, 'H', 0x02);
    return ErrorCorrectionLevel;
}());
exports.default = ErrorCorrectionLevel;
//# sourceMappingURL=ErrorCorrectionLevel.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/FormatInformation.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/FormatInformation.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode.decoder {*/
var ErrorCorrectionLevel_1 = __webpack_require__(/*! ./ErrorCorrectionLevel */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/ErrorCorrectionLevel.js");
var Integer_1 = __webpack_require__(/*! ../../util/Integer */ "./node_modules/@zxing/library/esm5/core/util/Integer.js");
/**
 * <p>Encapsulates a QR Code's format information, including the data mask used and
 * error correction level.</p>
 *
 * @author Sean Owen
 * @see DataMask
 * @see ErrorCorrectionLevel
 */
var FormatInformation = /** @class */ (function () {
    function FormatInformation(formatInfo /*int*/) {
        // Bits 3,4
        this.errorCorrectionLevel = ErrorCorrectionLevel_1.default.forBits((formatInfo >> 3) & 0x03);
        // Bottom 3 bits
        this.dataMask = /*(byte) */ (formatInfo & 0x07);
    }
    FormatInformation.numBitsDiffering = function (a /*int*/, b /*int*/) {
        return Integer_1.default.bitCount(a ^ b);
    };
    /**
     * @param maskedFormatInfo1 format info indicator, with mask still applied
     * @param maskedFormatInfo2 second copy of same info; both are checked at the same time
     *  to establish best match
     * @return information about the format it specifies, or {@code null}
     *  if doesn't seem to match any known pattern
     */
    FormatInformation.decodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {
        var formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
        if (formatInfo !== null) {
            return formatInfo;
        }
        // Should return null, but, some QR codes apparently
        // do not mask this info. Try again by actually masking the pattern
        // first
        return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);
    };
    FormatInformation.doDecodeFormatInformation = function (maskedFormatInfo1 /*int*/, maskedFormatInfo2 /*int*/) {
        var e_1, _a;
        // Find the int in FORMAT_INFO_DECODE_LOOKUP with fewest bits differing
        var bestDifference = Number.MAX_SAFE_INTEGER;
        var bestFormatInfo = 0;
        try {
            for (var _b = __values(FormatInformation.FORMAT_INFO_DECODE_LOOKUP), _c = _b.next(); !_c.done; _c = _b.next()) {
                var decodeInfo = _c.value;
                var targetInfo = decodeInfo[0];
                if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {
                    // Found an exact match
                    return new FormatInformation(decodeInfo[1]);
                }
                var bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);
                if (bitsDifference < bestDifference) {
                    bestFormatInfo = decodeInfo[1];
                    bestDifference = bitsDifference;
                }
                if (maskedFormatInfo1 !== maskedFormatInfo2) {
                    // also try the other option
                    bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);
                    if (bitsDifference < bestDifference) {
                        bestFormatInfo = decodeInfo[1];
                        bestDifference = bitsDifference;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // Hamming distance of the 32 masked codes is 7, by construction, so <= 3 bits
        // differing means we found a match
        if (bestDifference <= 3) {
            return new FormatInformation(bestFormatInfo);
        }
        return null;
    };
    FormatInformation.prototype.getErrorCorrectionLevel = function () {
        return this.errorCorrectionLevel;
    };
    FormatInformation.prototype.getDataMask = function () {
        return this.dataMask;
    };
    /*@Override*/
    FormatInformation.prototype.hashCode = function () {
        return (this.errorCorrectionLevel.getBits() << 3) | this.dataMask;
    };
    /*@Override*/
    FormatInformation.prototype.equals = function (o) {
        if (!(o instanceof FormatInformation)) {
            return false;
        }
        var other = o;
        return this.errorCorrectionLevel === other.errorCorrectionLevel &&
            this.dataMask === other.dataMask;
    };
    FormatInformation.FORMAT_INFO_MASK_QR = 0x5412;
    /**
     * See ISO 18004:2006, Annex C, Table C.1
     */
    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [
        Int32Array.from([0x5412, 0x00]),
        Int32Array.from([0x5125, 0x01]),
        Int32Array.from([0x5E7C, 0x02]),
        Int32Array.from([0x5B4B, 0x03]),
        Int32Array.from([0x45F9, 0x04]),
        Int32Array.from([0x40CE, 0x05]),
        Int32Array.from([0x4F97, 0x06]),
        Int32Array.from([0x4AA0, 0x07]),
        Int32Array.from([0x77C4, 0x08]),
        Int32Array.from([0x72F3, 0x09]),
        Int32Array.from([0x7DAA, 0x0A]),
        Int32Array.from([0x789D, 0x0B]),
        Int32Array.from([0x662F, 0x0C]),
        Int32Array.from([0x6318, 0x0D]),
        Int32Array.from([0x6C41, 0x0E]),
        Int32Array.from([0x6976, 0x0F]),
        Int32Array.from([0x1689, 0x10]),
        Int32Array.from([0x13BE, 0x11]),
        Int32Array.from([0x1CE7, 0x12]),
        Int32Array.from([0x19D0, 0x13]),
        Int32Array.from([0x0762, 0x14]),
        Int32Array.from([0x0255, 0x15]),
        Int32Array.from([0x0D0C, 0x16]),
        Int32Array.from([0x083B, 0x17]),
        Int32Array.from([0x355F, 0x18]),
        Int32Array.from([0x3068, 0x19]),
        Int32Array.from([0x3F31, 0x1A]),
        Int32Array.from([0x3A06, 0x1B]),
        Int32Array.from([0x24B4, 0x1C]),
        Int32Array.from([0x2183, 0x1D]),
        Int32Array.from([0x2EDA, 0x1E]),
        Int32Array.from([0x2BED, 0x1F]),
    ];
    return FormatInformation;
}());
exports.default = FormatInformation;
//# sourceMappingURL=FormatInformation.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/Mode.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/Mode.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
var ModeValues;
(function (ModeValues) {
    ModeValues[ModeValues["TERMINATOR"] = 0] = "TERMINATOR";
    ModeValues[ModeValues["NUMERIC"] = 1] = "NUMERIC";
    ModeValues[ModeValues["ALPHANUMERIC"] = 2] = "ALPHANUMERIC";
    ModeValues[ModeValues["STRUCTURED_APPEND"] = 3] = "STRUCTURED_APPEND";
    ModeValues[ModeValues["BYTE"] = 4] = "BYTE";
    ModeValues[ModeValues["ECI"] = 5] = "ECI";
    ModeValues[ModeValues["KANJI"] = 6] = "KANJI";
    ModeValues[ModeValues["FNC1_FIRST_POSITION"] = 7] = "FNC1_FIRST_POSITION";
    ModeValues[ModeValues["FNC1_SECOND_POSITION"] = 8] = "FNC1_SECOND_POSITION";
    /** See GBT 18284-2000; "Hanzi" is a transliteration of this mode name. */
    ModeValues[ModeValues["HANZI"] = 9] = "HANZI";
})(ModeValues = exports.ModeValues || (exports.ModeValues = {}));
/**
 * <p>See ISO 18004:2006, 6.4.1, Tables 2 and 3. This enum encapsulates the various modes in which
 * data can be encoded to bits in the QR code standard.</p>
 *
 * @author Sean Owen
 */
var Mode = /** @class */ (function () {
    function Mode(value, stringValue, characterCountBitsForVersions, bits /*int*/) {
        this.value = value;
        this.stringValue = stringValue;
        this.characterCountBitsForVersions = characterCountBitsForVersions;
        this.bits = bits;
        Mode.FOR_BITS.set(bits, this);
        Mode.FOR_VALUE.set(value, this);
    }
    /**
     * @param bits four bits encoding a QR Code data mode
     * @return Mode encoded by these bits
     * @throws IllegalArgumentException if bits do not correspond to a known mode
     */
    Mode.forBits = function (bits /*int*/) {
        var mode = Mode.FOR_BITS.get(bits);
        if (undefined === mode) {
            throw new IllegalArgumentException_1.default();
        }
        return mode;
    };
    /**
     * @param version version in question
     * @return number of bits used, in this QR Code symbol {@link Version}, to encode the
     *         count of characters that will follow encoded in this Mode
     */
    Mode.prototype.getCharacterCountBits = function (version) {
        var versionNumber = version.getVersionNumber();
        var offset;
        if (versionNumber <= 9) {
            offset = 0;
        }
        else if (versionNumber <= 26) {
            offset = 1;
        }
        else {
            offset = 2;
        }
        return this.characterCountBitsForVersions[offset];
    };
    Mode.prototype.getValue = function () {
        return this.value;
    };
    Mode.prototype.getBits = function () {
        return this.bits;
    };
    Mode.prototype.equals = function (o) {
        if (!(o instanceof Mode)) {
            return false;
        }
        var other = o;
        return this.value === other.value;
    };
    Mode.prototype.toString = function () {
        return this.stringValue;
    };
    Mode.FOR_BITS = new Map();
    Mode.FOR_VALUE = new Map();
    Mode.TERMINATOR = new Mode(ModeValues.TERMINATOR, 'TERMINATOR', Int32Array.from([0, 0, 0]), 0x00); // Not really a mode...
    Mode.NUMERIC = new Mode(ModeValues.NUMERIC, 'NUMERIC', Int32Array.from([10, 12, 14]), 0x01);
    Mode.ALPHANUMERIC = new Mode(ModeValues.ALPHANUMERIC, 'ALPHANUMERIC', Int32Array.from([9, 11, 13]), 0x02);
    Mode.STRUCTURED_APPEND = new Mode(ModeValues.STRUCTURED_APPEND, 'STRUCTURED_APPEND', Int32Array.from([0, 0, 0]), 0x03); // Not supported
    Mode.BYTE = new Mode(ModeValues.BYTE, 'BYTE', Int32Array.from([8, 16, 16]), 0x04);
    Mode.ECI = new Mode(ModeValues.ECI, 'ECI', Int32Array.from([0, 0, 0]), 0x07); // character counts don't apply
    Mode.KANJI = new Mode(ModeValues.KANJI, 'KANJI', Int32Array.from([8, 10, 12]), 0x08);
    Mode.FNC1_FIRST_POSITION = new Mode(ModeValues.FNC1_FIRST_POSITION, 'FNC1_FIRST_POSITION', Int32Array.from([0, 0, 0]), 0x05);
    Mode.FNC1_SECOND_POSITION = new Mode(ModeValues.FNC1_SECOND_POSITION, 'FNC1_SECOND_POSITION', Int32Array.from([0, 0, 0]), 0x09);
    /** See GBT 18284-2000; "Hanzi" is a transliteration of this mode name. */
    Mode.HANZI = new Mode(ModeValues.HANZI, 'HANZI', Int32Array.from([8, 10, 12]), 0x0D);
    return Mode;
}());
exports.default = Mode;
//# sourceMappingURL=Mode.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/QRCodeDecoderMetaData.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/QRCodeDecoderMetaData.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2013 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Meta-data container for QR Code decoding. Instances of this class may be used to convey information back to the
 * decoding caller. Callers are expected to process this.
 *
 * @see com.google.zxing.common.DecoderResult#getOther()
 */
var QRCodeDecoderMetaData = /** @class */ (function () {
    function QRCodeDecoderMetaData(mirrored) {
        this.mirrored = mirrored;
    }
    /**
     * @return true if the QR Code was mirrored.
     */
    QRCodeDecoderMetaData.prototype.isMirrored = function () {
        return this.mirrored;
    };
    /**
     * Apply the result points' order correction due to mirroring.
     *
     * @param points Array of points to apply mirror correction to.
     */
    QRCodeDecoderMetaData.prototype.applyMirroredCorrection = function (points) {
        if (!this.mirrored || points === null || points.length < 3) {
            return;
        }
        var bottomLeft = points[0];
        points[0] = points[2];
        points[2] = bottomLeft;
        // No need to 'fix' top-left and alignment pattern.
    };
    return QRCodeDecoderMetaData;
}());
exports.default = QRCodeDecoderMetaData;
//# sourceMappingURL=QRCodeDecoderMetaData.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/Version.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/decoder/Version.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode.decoder {*/
var BitMatrix_1 = __webpack_require__(/*! ../../common/BitMatrix */ "./node_modules/@zxing/library/esm5/core/common/BitMatrix.js");
var FormatInformation_1 = __webpack_require__(/*! ./FormatInformation */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/FormatInformation.js");
var ECBlocks_1 = __webpack_require__(/*! ./ECBlocks */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/ECBlocks.js");
var ECB_1 = __webpack_require__(/*! ./ECB */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/ECB.js");
var FormatException_1 = __webpack_require__(/*! ../../FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * See ISO 18004:2006 Annex D
 *
 * @author Sean Owen
 */
var Version = /** @class */ (function () {
    function Version(versionNumber /*int*/, alignmentPatternCenters) {
        var e_1, _a;
        var ecBlocks = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            ecBlocks[_i - 2] = arguments[_i];
        }
        this.versionNumber = versionNumber;
        this.alignmentPatternCenters = alignmentPatternCenters;
        this.ecBlocks = ecBlocks;
        var total = 0;
        var ecCodewords = ecBlocks[0].getECCodewordsPerBlock();
        var ecbArray = ecBlocks[0].getECBlocks();
        try {
            for (var ecbArray_1 = __values(ecbArray), ecbArray_1_1 = ecbArray_1.next(); !ecbArray_1_1.done; ecbArray_1_1 = ecbArray_1.next()) {
                var ecBlock = ecbArray_1_1.value;
                total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (ecbArray_1_1 && !ecbArray_1_1.done && (_a = ecbArray_1.return)) _a.call(ecbArray_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.totalCodewords = total;
    }
    Version.prototype.getVersionNumber = function () {
        return this.versionNumber;
    };
    Version.prototype.getAlignmentPatternCenters = function () {
        return this.alignmentPatternCenters;
    };
    Version.prototype.getTotalCodewords = function () {
        return this.totalCodewords;
    };
    Version.prototype.getDimensionForVersion = function () {
        return 17 + 4 * this.versionNumber;
    };
    Version.prototype.getECBlocksForLevel = function (ecLevel) {
        return this.ecBlocks[ecLevel.getValue()];
        // TYPESCRIPTPORT: original was using ordinal, and using the order of levels as defined in ErrorCorrectionLevel enum (LMQH)
        // I will use the direct value from ErrorCorrectionLevelValues enum which in typescript goes to a number
    };
    /**
     * <p>Deduces version information purely from QR Code dimensions.</p>
     *
     * @param dimension dimension in modules
     * @return Version for a QR Code of that dimension
     * @throws FormatException if dimension is not 1 mod 4
     */
    Version.getProvisionalVersionForDimension = function (dimension /*int*/) {
        if (dimension % 4 !== 1) {
            throw new FormatException_1.default();
        }
        try {
            return this.getVersionForNumber((dimension - 17) / 4);
        }
        catch (ignored /*: IllegalArgumentException*/) {
            throw new FormatException_1.default();
        }
    };
    Version.getVersionForNumber = function (versionNumber /*int*/) {
        if (versionNumber < 1 || versionNumber > 40) {
            throw new IllegalArgumentException_1.default();
        }
        return Version.VERSIONS[versionNumber - 1];
    };
    Version.decodeVersionInformation = function (versionBits /*int*/) {
        var bestDifference = Number.MAX_SAFE_INTEGER;
        var bestVersion = 0;
        for (var i = 0; i < Version.VERSION_DECODE_INFO.length; i++) {
            var targetVersion = Version.VERSION_DECODE_INFO[i];
            // Do the version info bits match exactly? done.
            if (targetVersion === versionBits) {
                return Version.getVersionForNumber(i + 7);
            }
            // Otherwise see if this is the closest to a real version info bit string
            // we have seen so far
            var bitsDifference = FormatInformation_1.default.numBitsDiffering(versionBits, targetVersion);
            if (bitsDifference < bestDifference) {
                bestVersion = i + 7;
                bestDifference = bitsDifference;
            }
        }
        // We can tolerate up to 3 bits of error since no two version info codewords will
        // differ in less than 8 bits.
        if (bestDifference <= 3) {
            return Version.getVersionForNumber(bestVersion);
        }
        // If we didn't find a close enough match, fail
        return null;
    };
    /**
     * See ISO 18004:2006 Annex E
     */
    Version.prototype.buildFunctionPattern = function () {
        var dimension = this.getDimensionForVersion();
        var bitMatrix = new BitMatrix_1.default(dimension);
        // Top left finder pattern + separator + format
        bitMatrix.setRegion(0, 0, 9, 9);
        // Top right finder pattern + separator + format
        bitMatrix.setRegion(dimension - 8, 0, 8, 9);
        // Bottom left finder pattern + separator + format
        bitMatrix.setRegion(0, dimension - 8, 9, 8);
        // Alignment patterns
        var max = this.alignmentPatternCenters.length;
        for (var x = 0; x < max; x++) {
            var i = this.alignmentPatternCenters[x] - 2;
            for (var y = 0; y < max; y++) {
                if ((x === 0 && (y === 0 || y === max - 1)) || (x === max - 1 && y === 0)) {
                    // No alignment patterns near the three finder patterns
                    continue;
                }
                bitMatrix.setRegion(this.alignmentPatternCenters[y] - 2, i, 5, 5);
            }
        }
        // Vertical timing pattern
        bitMatrix.setRegion(6, 9, 1, dimension - 17);
        // Horizontal timing pattern
        bitMatrix.setRegion(9, 6, dimension - 17, 1);
        if (this.versionNumber > 6) {
            // Version info, top right
            bitMatrix.setRegion(dimension - 11, 0, 3, 6);
            // Version info, bottom left
            bitMatrix.setRegion(0, dimension - 11, 6, 3);
        }
        return bitMatrix;
    };
    /*@Override*/
    Version.prototype.toString = function () {
        return '' + this.versionNumber;
    };
    /**
       * See ISO 18004:2006 Annex D.
       * Element i represents the raw version bits that specify version i + 7
       */
    Version.VERSION_DECODE_INFO = Int32Array.from([
        0x07C94, 0x085BC, 0x09A99, 0x0A4D3, 0x0BBF6,
        0x0C762, 0x0D847, 0x0E60D, 0x0F928, 0x10B78,
        0x1145D, 0x12A17, 0x13532, 0x149A6, 0x15683,
        0x168C9, 0x177EC, 0x18EC4, 0x191E1, 0x1AFAB,
        0x1B08E, 0x1CC1A, 0x1D33F, 0x1ED75, 0x1F250,
        0x209D5, 0x216F0, 0x228BA, 0x2379F, 0x24B0B,
        0x2542E, 0x26A64, 0x27541, 0x28C69
    ]);
    /**
       * See ISO 18004:2006 6.5.1 Table 9
       */
    Version.VERSIONS = [
        new Version(1, new Int32Array(0), new ECBlocks_1.default(7, new ECB_1.default(1, 19)), new ECBlocks_1.default(10, new ECB_1.default(1, 16)), new ECBlocks_1.default(13, new ECB_1.default(1, 13)), new ECBlocks_1.default(17, new ECB_1.default(1, 9))),
        new Version(2, Int32Array.from([6, 18]), new ECBlocks_1.default(10, new ECB_1.default(1, 34)), new ECBlocks_1.default(16, new ECB_1.default(1, 28)), new ECBlocks_1.default(22, new ECB_1.default(1, 22)), new ECBlocks_1.default(28, new ECB_1.default(1, 16))),
        new Version(3, Int32Array.from([6, 22]), new ECBlocks_1.default(15, new ECB_1.default(1, 55)), new ECBlocks_1.default(26, new ECB_1.default(1, 44)), new ECBlocks_1.default(18, new ECB_1.default(2, 17)), new ECBlocks_1.default(22, new ECB_1.default(2, 13))),
        new Version(4, Int32Array.from([6, 26]), new ECBlocks_1.default(20, new ECB_1.default(1, 80)), new ECBlocks_1.default(18, new ECB_1.default(2, 32)), new ECBlocks_1.default(26, new ECB_1.default(2, 24)), new ECBlocks_1.default(16, new ECB_1.default(4, 9))),
        new Version(5, Int32Array.from([6, 30]), new ECBlocks_1.default(26, new ECB_1.default(1, 108)), new ECBlocks_1.default(24, new ECB_1.default(2, 43)), new ECBlocks_1.default(18, new ECB_1.default(2, 15), new ECB_1.default(2, 16)), new ECBlocks_1.default(22, new ECB_1.default(2, 11), new ECB_1.default(2, 12))),
        new Version(6, Int32Array.from([6, 34]), new ECBlocks_1.default(18, new ECB_1.default(2, 68)), new ECBlocks_1.default(16, new ECB_1.default(4, 27)), new ECBlocks_1.default(24, new ECB_1.default(4, 19)), new ECBlocks_1.default(28, new ECB_1.default(4, 15))),
        new Version(7, Int32Array.from([6, 22, 38]), new ECBlocks_1.default(20, new ECB_1.default(2, 78)), new ECBlocks_1.default(18, new ECB_1.default(4, 31)), new ECBlocks_1.default(18, new ECB_1.default(2, 14), new ECB_1.default(4, 15)), new ECBlocks_1.default(26, new ECB_1.default(4, 13), new ECB_1.default(1, 14))),
        new Version(8, Int32Array.from([6, 24, 42]), new ECBlocks_1.default(24, new ECB_1.default(2, 97)), new ECBlocks_1.default(22, new ECB_1.default(2, 38), new ECB_1.default(2, 39)), new ECBlocks_1.default(22, new ECB_1.default(4, 18), new ECB_1.default(2, 19)), new ECBlocks_1.default(26, new ECB_1.default(4, 14), new ECB_1.default(2, 15))),
        new Version(9, Int32Array.from([6, 26, 46]), new ECBlocks_1.default(30, new ECB_1.default(2, 116)), new ECBlocks_1.default(22, new ECB_1.default(3, 36), new ECB_1.default(2, 37)), new ECBlocks_1.default(20, new ECB_1.default(4, 16), new ECB_1.default(4, 17)), new ECBlocks_1.default(24, new ECB_1.default(4, 12), new ECB_1.default(4, 13))),
        new Version(10, Int32Array.from([6, 28, 50]), new ECBlocks_1.default(18, new ECB_1.default(2, 68), new ECB_1.default(2, 69)), new ECBlocks_1.default(26, new ECB_1.default(4, 43), new ECB_1.default(1, 44)), new ECBlocks_1.default(24, new ECB_1.default(6, 19), new ECB_1.default(2, 20)), new ECBlocks_1.default(28, new ECB_1.default(6, 15), new ECB_1.default(2, 16))),
        new Version(11, Int32Array.from([6, 30, 54]), new ECBlocks_1.default(20, new ECB_1.default(4, 81)), new ECBlocks_1.default(30, new ECB_1.default(1, 50), new ECB_1.default(4, 51)), new ECBlocks_1.default(28, new ECB_1.default(4, 22), new ECB_1.default(4, 23)), new ECBlocks_1.default(24, new ECB_1.default(3, 12), new ECB_1.default(8, 13))),
        new Version(12, Int32Array.from([6, 32, 58]), new ECBlocks_1.default(24, new ECB_1.default(2, 92), new ECB_1.default(2, 93)), new ECBlocks_1.default(22, new ECB_1.default(6, 36), new ECB_1.default(2, 37)), new ECBlocks_1.default(26, new ECB_1.default(4, 20), new ECB_1.default(6, 21)), new ECBlocks_1.default(28, new ECB_1.default(7, 14), new ECB_1.default(4, 15))),
        new Version(13, Int32Array.from([6, 34, 62]), new ECBlocks_1.default(26, new ECB_1.default(4, 107)), new ECBlocks_1.default(22, new ECB_1.default(8, 37), new ECB_1.default(1, 38)), new ECBlocks_1.default(24, new ECB_1.default(8, 20), new ECB_1.default(4, 21)), new ECBlocks_1.default(22, new ECB_1.default(12, 11), new ECB_1.default(4, 12))),
        new Version(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks_1.default(30, new ECB_1.default(3, 115), new ECB_1.default(1, 116)), new ECBlocks_1.default(24, new ECB_1.default(4, 40), new ECB_1.default(5, 41)), new ECBlocks_1.default(20, new ECB_1.default(11, 16), new ECB_1.default(5, 17)), new ECBlocks_1.default(24, new ECB_1.default(11, 12), new ECB_1.default(5, 13))),
        new Version(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks_1.default(22, new ECB_1.default(5, 87), new ECB_1.default(1, 88)), new ECBlocks_1.default(24, new ECB_1.default(5, 41), new ECB_1.default(5, 42)), new ECBlocks_1.default(30, new ECB_1.default(5, 24), new ECB_1.default(7, 25)), new ECBlocks_1.default(24, new ECB_1.default(11, 12), new ECB_1.default(7, 13))),
        new Version(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks_1.default(24, new ECB_1.default(5, 98), new ECB_1.default(1, 99)), new ECBlocks_1.default(28, new ECB_1.default(7, 45), new ECB_1.default(3, 46)), new ECBlocks_1.default(24, new ECB_1.default(15, 19), new ECB_1.default(2, 20)), new ECBlocks_1.default(30, new ECB_1.default(3, 15), new ECB_1.default(13, 16))),
        new Version(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks_1.default(28, new ECB_1.default(1, 107), new ECB_1.default(5, 108)), new ECBlocks_1.default(28, new ECB_1.default(10, 46), new ECB_1.default(1, 47)), new ECBlocks_1.default(28, new ECB_1.default(1, 22), new ECB_1.default(15, 23)), new ECBlocks_1.default(28, new ECB_1.default(2, 14), new ECB_1.default(17, 15))),
        new Version(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks_1.default(30, new ECB_1.default(5, 120), new ECB_1.default(1, 121)), new ECBlocks_1.default(26, new ECB_1.default(9, 43), new ECB_1.default(4, 44)), new ECBlocks_1.default(28, new ECB_1.default(17, 22), new ECB_1.default(1, 23)), new ECBlocks_1.default(28, new ECB_1.default(2, 14), new ECB_1.default(19, 15))),
        new Version(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks_1.default(28, new ECB_1.default(3, 113), new ECB_1.default(4, 114)), new ECBlocks_1.default(26, new ECB_1.default(3, 44), new ECB_1.default(11, 45)), new ECBlocks_1.default(26, new ECB_1.default(17, 21), new ECB_1.default(4, 22)), new ECBlocks_1.default(26, new ECB_1.default(9, 13), new ECB_1.default(16, 14))),
        new Version(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks_1.default(28, new ECB_1.default(3, 107), new ECB_1.default(5, 108)), new ECBlocks_1.default(26, new ECB_1.default(3, 41), new ECB_1.default(13, 42)), new ECBlocks_1.default(30, new ECB_1.default(15, 24), new ECB_1.default(5, 25)), new ECBlocks_1.default(28, new ECB_1.default(15, 15), new ECB_1.default(10, 16))),
        new Version(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks_1.default(28, new ECB_1.default(4, 116), new ECB_1.default(4, 117)), new ECBlocks_1.default(26, new ECB_1.default(17, 42)), new ECBlocks_1.default(28, new ECB_1.default(17, 22), new ECB_1.default(6, 23)), new ECBlocks_1.default(30, new ECB_1.default(19, 16), new ECB_1.default(6, 17))),
        new Version(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks_1.default(28, new ECB_1.default(2, 111), new ECB_1.default(7, 112)), new ECBlocks_1.default(28, new ECB_1.default(17, 46)), new ECBlocks_1.default(30, new ECB_1.default(7, 24), new ECB_1.default(16, 25)), new ECBlocks_1.default(24, new ECB_1.default(34, 13))),
        new Version(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks_1.default(30, new ECB_1.default(4, 121), new ECB_1.default(5, 122)), new ECBlocks_1.default(28, new ECB_1.default(4, 47), new ECB_1.default(14, 48)), new ECBlocks_1.default(30, new ECB_1.default(11, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(16, 15), new ECB_1.default(14, 16))),
        new Version(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks_1.default(30, new ECB_1.default(6, 117), new ECB_1.default(4, 118)), new ECBlocks_1.default(28, new ECB_1.default(6, 45), new ECB_1.default(14, 46)), new ECBlocks_1.default(30, new ECB_1.default(11, 24), new ECB_1.default(16, 25)), new ECBlocks_1.default(30, new ECB_1.default(30, 16), new ECB_1.default(2, 17))),
        new Version(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks_1.default(26, new ECB_1.default(8, 106), new ECB_1.default(4, 107)), new ECBlocks_1.default(28, new ECB_1.default(8, 47), new ECB_1.default(13, 48)), new ECBlocks_1.default(30, new ECB_1.default(7, 24), new ECB_1.default(22, 25)), new ECBlocks_1.default(30, new ECB_1.default(22, 15), new ECB_1.default(13, 16))),
        new Version(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks_1.default(28, new ECB_1.default(10, 114), new ECB_1.default(2, 115)), new ECBlocks_1.default(28, new ECB_1.default(19, 46), new ECB_1.default(4, 47)), new ECBlocks_1.default(28, new ECB_1.default(28, 22), new ECB_1.default(6, 23)), new ECBlocks_1.default(30, new ECB_1.default(33, 16), new ECB_1.default(4, 17))),
        new Version(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks_1.default(30, new ECB_1.default(8, 122), new ECB_1.default(4, 123)), new ECBlocks_1.default(28, new ECB_1.default(22, 45), new ECB_1.default(3, 46)), new ECBlocks_1.default(30, new ECB_1.default(8, 23), new ECB_1.default(26, 24)), new ECBlocks_1.default(30, new ECB_1.default(12, 15), new ECB_1.default(28, 16))),
        new Version(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks_1.default(30, new ECB_1.default(3, 117), new ECB_1.default(10, 118)), new ECBlocks_1.default(28, new ECB_1.default(3, 45), new ECB_1.default(23, 46)), new ECBlocks_1.default(30, new ECB_1.default(4, 24), new ECB_1.default(31, 25)), new ECBlocks_1.default(30, new ECB_1.default(11, 15), new ECB_1.default(31, 16))),
        new Version(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks_1.default(30, new ECB_1.default(7, 116), new ECB_1.default(7, 117)), new ECBlocks_1.default(28, new ECB_1.default(21, 45), new ECB_1.default(7, 46)), new ECBlocks_1.default(30, new ECB_1.default(1, 23), new ECB_1.default(37, 24)), new ECBlocks_1.default(30, new ECB_1.default(19, 15), new ECB_1.default(26, 16))),
        new Version(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks_1.default(30, new ECB_1.default(5, 115), new ECB_1.default(10, 116)), new ECBlocks_1.default(28, new ECB_1.default(19, 47), new ECB_1.default(10, 48)), new ECBlocks_1.default(30, new ECB_1.default(15, 24), new ECB_1.default(25, 25)), new ECBlocks_1.default(30, new ECB_1.default(23, 15), new ECB_1.default(25, 16))),
        new Version(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks_1.default(30, new ECB_1.default(13, 115), new ECB_1.default(3, 116)), new ECBlocks_1.default(28, new ECB_1.default(2, 46), new ECB_1.default(29, 47)), new ECBlocks_1.default(30, new ECB_1.default(42, 24), new ECB_1.default(1, 25)), new ECBlocks_1.default(30, new ECB_1.default(23, 15), new ECB_1.default(28, 16))),
        new Version(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks_1.default(30, new ECB_1.default(17, 115)), new ECBlocks_1.default(28, new ECB_1.default(10, 46), new ECB_1.default(23, 47)), new ECBlocks_1.default(30, new ECB_1.default(10, 24), new ECB_1.default(35, 25)), new ECBlocks_1.default(30, new ECB_1.default(19, 15), new ECB_1.default(35, 16))),
        new Version(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks_1.default(30, new ECB_1.default(17, 115), new ECB_1.default(1, 116)), new ECBlocks_1.default(28, new ECB_1.default(14, 46), new ECB_1.default(21, 47)), new ECBlocks_1.default(30, new ECB_1.default(29, 24), new ECB_1.default(19, 25)), new ECBlocks_1.default(30, new ECB_1.default(11, 15), new ECB_1.default(46, 16))),
        new Version(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks_1.default(30, new ECB_1.default(13, 115), new ECB_1.default(6, 116)), new ECBlocks_1.default(28, new ECB_1.default(14, 46), new ECB_1.default(23, 47)), new ECBlocks_1.default(30, new ECB_1.default(44, 24), new ECB_1.default(7, 25)), new ECBlocks_1.default(30, new ECB_1.default(59, 16), new ECB_1.default(1, 17))),
        new Version(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks_1.default(30, new ECB_1.default(12, 121), new ECB_1.default(7, 122)), new ECBlocks_1.default(28, new ECB_1.default(12, 47), new ECB_1.default(26, 48)), new ECBlocks_1.default(30, new ECB_1.default(39, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(22, 15), new ECB_1.default(41, 16))),
        new Version(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks_1.default(30, new ECB_1.default(6, 121), new ECB_1.default(14, 122)), new ECBlocks_1.default(28, new ECB_1.default(6, 47), new ECB_1.default(34, 48)), new ECBlocks_1.default(30, new ECB_1.default(46, 24), new ECB_1.default(10, 25)), new ECBlocks_1.default(30, new ECB_1.default(2, 15), new ECB_1.default(64, 16))),
        new Version(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks_1.default(30, new ECB_1.default(17, 122), new ECB_1.default(4, 123)), new ECBlocks_1.default(28, new ECB_1.default(29, 46), new ECB_1.default(14, 47)), new ECBlocks_1.default(30, new ECB_1.default(49, 24), new ECB_1.default(10, 25)), new ECBlocks_1.default(30, new ECB_1.default(24, 15), new ECB_1.default(46, 16))),
        new Version(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks_1.default(30, new ECB_1.default(4, 122), new ECB_1.default(18, 123)), new ECBlocks_1.default(28, new ECB_1.default(13, 46), new ECB_1.default(32, 47)), new ECBlocks_1.default(30, new ECB_1.default(48, 24), new ECB_1.default(14, 25)), new ECBlocks_1.default(30, new ECB_1.default(42, 15), new ECB_1.default(32, 16))),
        new Version(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks_1.default(30, new ECB_1.default(20, 117), new ECB_1.default(4, 118)), new ECBlocks_1.default(28, new ECB_1.default(40, 47), new ECB_1.default(7, 48)), new ECBlocks_1.default(30, new ECB_1.default(43, 24), new ECB_1.default(22, 25)), new ECBlocks_1.default(30, new ECB_1.default(10, 15), new ECB_1.default(67, 16))),
        new Version(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks_1.default(30, new ECB_1.default(19, 118), new ECB_1.default(6, 119)), new ECBlocks_1.default(28, new ECB_1.default(18, 47), new ECB_1.default(31, 48)), new ECBlocks_1.default(30, new ECB_1.default(34, 24), new ECB_1.default(34, 25)), new ECBlocks_1.default(30, new ECB_1.default(20, 15), new ECB_1.default(61, 16)))
    ];
    return Version;
}());
exports.default = Version;
//# sourceMappingURL=Version.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/detector/AlignmentPattern.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/detector/AlignmentPattern.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode.detector {*/
var ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
/**
 * <p>Encapsulates an alignment pattern, which are the smaller square patterns found in
 * all but the simplest QR Codes.</p>
 *
 * @author Sean Owen
 */
var AlignmentPattern = /** @class */ (function (_super) {
    __extends(AlignmentPattern, _super);
    function AlignmentPattern(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/) {
        var _this = _super.call(this, posX, posY) || this;
        _this.estimatedModuleSize = estimatedModuleSize;
        return _this;
    }
    /**
     * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated
     * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
     */
    AlignmentPattern.prototype.aboutEquals = function (moduleSize /*float*/, i /*float*/, j /*float*/) {
        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
            var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
            return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
    };
    /**
     * Combines this object's current estimate of a finder pattern position and module size
     * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.
     */
    AlignmentPattern.prototype.combineEstimate = function (i /*float*/, j /*float*/, newModuleSize /*float*/) {
        var combinedX = (this.getX() + j) / 2.0;
        var combinedY = (this.getY() + i) / 2.0;
        var combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2.0;
        return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
    };
    return AlignmentPattern;
}(ResultPoint_1.default));
exports.default = AlignmentPattern;
//# sourceMappingURL=AlignmentPattern.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/detector/AlignmentPatternFinder.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/detector/AlignmentPatternFinder.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var AlignmentPattern_1 = __webpack_require__(/*! ./AlignmentPattern */ "./node_modules/@zxing/library/esm5/core/qrcode/detector/AlignmentPattern.js");
var NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/*import java.util.ArrayList;*/
/*import java.util.List;*/
/**
 * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder
 * patterns but are smaller and appear at regular intervals throughout the image.</p>
 *
 * <p>At the moment this only looks for the bottom-right alignment pattern.</p>
 *
 * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,
 * pasted and stripped down here for maximum performance but does unfortunately duplicate
 * some code.</p>
 *
 * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>
 *
 * @author Sean Owen
 */
var AlignmentPatternFinder = /** @class */ (function () {
    /**
     * <p>Creates a finder that will look in a portion of the whole image.</p>
     *
     * @param image image to search
     * @param startX left column from which to start searching
     * @param startY top row from which to start searching
     * @param width width of region to search
     * @param height height of region to search
     * @param moduleSize estimated module size so far
     */
    function AlignmentPatternFinder(image, startX /*int*/, startY /*int*/, width /*int*/, height /*int*/, moduleSize /*float*/, resultPointCallback) {
        this.image = image;
        this.startX = startX;
        this.startY = startY;
        this.width = width;
        this.height = height;
        this.moduleSize = moduleSize;
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = []; // new Array<any>(5))
        // TYPESCRIPTPORT: array initialization without size as the length is checked below
        this.crossCheckStateCount = new Int32Array(3);
    }
    /**
     * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since
     * it's pretty performance-critical and so is written to be fast foremost.</p>
     *
     * @return {@link AlignmentPattern} if found
     * @throws NotFoundException if not found
     */
    AlignmentPatternFinder.prototype.find = function () {
        var startX = this.startX;
        var height = this.height;
        var width = this.width;
        var maxJ = startX + width;
        var middleI = this.startY + (height / 2);
        // We are looking for black/white/black modules in 1:1:1 ratio
        // this tracks the number of black/white/black modules seen so far
        var stateCount = new Int32Array(3);
        var image = this.image;
        for (var iGen = 0; iGen < height; iGen++) {
            // Search from middle outwards
            var i = middleI + ((iGen & 0x01) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            var j = startX;
            // Burn off leading white pixels before anything else; if we start in the middle of
            // a white run, it doesn't make sense to count its length, since we don't know if the
            // white run continued to the left of the start point
            while (j < maxJ && !image.get(j, i)) {
                j++;
            }
            var currentState = 0;
            while (j < maxJ) {
                if (image.get(j, i)) {
                    // Black pixel
                    if (currentState === 1) { // Counting black pixels
                        stateCount[1]++;
                    }
                    else { // Counting white pixels
                        if (currentState === 2) { // A winner?
                            if (this.foundPatternCross(stateCount)) { // Yes
                                var confirmed = this.handlePossibleCenter(stateCount, i, j);
                                if (confirmed !== null) {
                                    return confirmed;
                                }
                            }
                            stateCount[0] = stateCount[2];
                            stateCount[1] = 1;
                            stateCount[2] = 0;
                            currentState = 1;
                        }
                        else {
                            stateCount[++currentState]++;
                        }
                    }
                }
                else { // White pixel
                    if (currentState === 1) { // Counting black pixels
                        currentState++;
                    }
                    stateCount[currentState]++;
                }
                j++;
            }
            if (this.foundPatternCross(stateCount)) {
                var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);
                if (confirmed !== null) {
                    return confirmed;
                }
            }
        }
        // Hmm, nothing we saw was observed and confirmed twice. If we had
        // any guess at all, return it.
        if (this.possibleCenters.length !== 0) {
            return this.possibleCenters[0];
        }
        throw new NotFoundException_1.default();
    };
    /**
     * Given a count of black/white/black pixels just seen and an end position,
     * figures the location of the center of this black/white/black run.
     */
    AlignmentPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {
        return (end - stateCount[2]) - stateCount[1] / 2.0;
    };
    /**
     * @param stateCount count of black/white/black pixels just read
     * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios
     *         used by alignment patterns to be considered a match
     */
    AlignmentPatternFinder.prototype.foundPatternCross = function (stateCount) {
        var moduleSize = this.moduleSize;
        var maxVariance = moduleSize / 2.0;
        for (var i = 0; i < 3; i++) {
            if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {
                return false;
            }
        }
        return true;
    };
    /**
     * <p>After a horizontal scan finds a potential alignment pattern, this method
     * "cross-checks" by scanning down vertically through the center of the possible
     * alignment pattern to see if the same proportion is detected.</p>
     *
     * @param startI row where an alignment pattern was detected
     * @param centerJ center of the section that appears to cross an alignment pattern
     * @param maxCount maximum reasonable number of modules that should be
     * observed in any reading state, based on the results of the horizontal scan
     * @return vertical center of alignment pattern, or {@link Float#NaN} if not found
     */
    AlignmentPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
        var image = this.image;
        var maxI = image.getHeight();
        var stateCount = this.crossCheckStateCount;
        stateCount[0] = 0;
        stateCount[1] = 0;
        stateCount[2] = 0;
        // Start counting up from center
        var i = startI;
        while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i--;
        }
        // If already too many modules in this state or ran off the edge:
        if (i < 0 || stateCount[1] > maxCount) {
            return NaN;
        }
        while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {
            stateCount[0]++;
            i--;
        }
        if (stateCount[0] > maxCount) {
            return NaN;
        }
        // Now also count down from center
        i = startI + 1;
        while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i++;
        }
        if (i === maxI || stateCount[1] > maxCount) {
            return NaN;
        }
        while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {
            stateCount[2]++;
            i++;
        }
        if (stateCount[2] > maxCount) {
            return NaN;
        }
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
            return NaN;
        }
        return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;
    };
    /**
     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
     * cross check with a vertical scan, and if successful, will see if this pattern had been
     * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have
     * found the alignment pattern.</p>
     *
     * @param stateCount reading state module counts from horizontal scan
     * @param i row where alignment pattern may be found
     * @param j end of possible alignment pattern in row
     * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not
     */
    AlignmentPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/) {
        var e_1, _a;
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        var centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);
        var centerI = this.crossCheckVertical(i, /*(int) */ centerJ, 2 * stateCount[1], stateCountTotal);
        if (!isNaN(centerI)) {
            var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;
            try {
                for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var center = _c.value;
                    // Look for about the same center and module size:
                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                        return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // Hadn't found this before; save it
            var point = new AlignmentPattern_1.default(centerJ, centerI, estimatedModuleSize);
            this.possibleCenters.push(point);
            if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {
                this.resultPointCallback.foundPossibleResultPoint(point);
            }
        }
        return null;
    };
    return AlignmentPatternFinder;
}());
exports.default = AlignmentPatternFinder;
//# sourceMappingURL=AlignmentPatternFinder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/detector/Detector.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/detector/Detector.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode.detector {*/
var DecodeHintType_1 = __webpack_require__(/*! ../../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var DetectorResult_1 = __webpack_require__(/*! ../../common/DetectorResult */ "./node_modules/@zxing/library/esm5/core/common/DetectorResult.js");
var GridSamplerInstance_1 = __webpack_require__(/*! ../../common/GridSamplerInstance */ "./node_modules/@zxing/library/esm5/core/common/GridSamplerInstance.js");
var PerspectiveTransform_1 = __webpack_require__(/*! ../../common/PerspectiveTransform */ "./node_modules/@zxing/library/esm5/core/common/PerspectiveTransform.js");
var MathUtils_1 = __webpack_require__(/*! ../../common/detector/MathUtils */ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js");
var Version_1 = __webpack_require__(/*! ../decoder/Version */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/Version.js");
var FinderPatternFinder_1 = __webpack_require__(/*! ./FinderPatternFinder */ "./node_modules/@zxing/library/esm5/core/qrcode/detector/FinderPatternFinder.js");
var AlignmentPatternFinder_1 = __webpack_require__(/*! ./AlignmentPatternFinder */ "./node_modules/@zxing/library/esm5/core/qrcode/detector/AlignmentPatternFinder.js");
var NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/*import java.util.Map;*/
/**
 * <p>Encapsulates logic that can detect a QR Code in an image, even if the QR Code
 * is rotated or skewed, or partially obscured.</p>
 *
 * @author Sean Owen
 */
var Detector = /** @class */ (function () {
    function Detector(image) {
        this.image = image;
    }
    Detector.prototype.getImage = function () {
        return this.image;
    };
    Detector.prototype.getResultPointCallback = function () {
        return this.resultPointCallback;
    };
    /**
     * <p>Detects a QR Code in an image.</p>
     *
     * @return {@link DetectorResult} encapsulating results of detecting a QR Code
     * @throws NotFoundException if QR Code cannot be found
     * @throws FormatException if a QR Code cannot be decoded
     */
    // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {
    //   return detect(null)
    // }
    /**
     * <p>Detects a QR Code in an image.</p>
     *
     * @param hints optional hints to detector
     * @return {@link DetectorResult} encapsulating results of detecting a QR Code
     * @throws NotFoundException if QR Code cannot be found
     * @throws FormatException if a QR Code cannot be decoded
     */
    Detector.prototype.detect = function (hints) {
        this.resultPointCallback = (hints === null || hints === undefined) ? null :
            /*(ResultPointCallback) */ hints.get(DecodeHintType_1.default.NEED_RESULT_POINT_CALLBACK);
        var finder = new FinderPatternFinder_1.default(this.image, this.resultPointCallback);
        var info = finder.find(hints);
        return this.processFinderPatternInfo(info);
    };
    Detector.prototype.processFinderPatternInfo = function (info) {
        var topLeft = info.getTopLeft();
        var topRight = info.getTopRight();
        var bottomLeft = info.getBottomLeft();
        var moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
        if (moduleSize < 1.0) {
            throw new NotFoundException_1.default('No pattern found in proccess finder.');
        }
        var dimension = Detector.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
        var provisionalVersion = Version_1.default.getProvisionalVersionForDimension(dimension);
        var modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;
        var alignmentPattern = null;
        // Anything above version 1 has an alignment pattern
        if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
            // Guess where a "bottom right" finder pattern would have been
            var bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
            var bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
            // Estimate that alignment pattern is closer by 3 modules
            // from "bottom right" to known top left location
            var correctionToTopLeft = 1.0 - 3.0 / modulesBetweenFPCenters;
            var estAlignmentX = /*(int) */ Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()));
            var estAlignmentY = /*(int) */ Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()));
            // Kind of arbitrary -- expand search radius before giving up
            for (var i = 4; i <= 16; i <<= 1) {
                try {
                    alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i);
                    break;
                }
                catch (re /*NotFoundException*/) {
                    if (!(re instanceof NotFoundException_1.default)) {
                        throw re;
                    }
                    // try next round
                }
            }
            // If we didn't find alignment pattern... well try anyway without it
        }
        var transform = Detector.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
        var bits = Detector.sampleGrid(this.image, transform, dimension);
        var points;
        if (alignmentPattern === null) {
            points = [bottomLeft, topLeft, topRight];
        }
        else {
            points = [bottomLeft, topLeft, topRight, alignmentPattern];
        }
        return new DetectorResult_1.default(bits, points);
    };
    Detector.createTransform = function (topLeft, topRight, bottomLeft, alignmentPattern, dimension /*int*/) {
        var dimMinusThree = dimension - 3.5;
        var bottomRightX; /*float*/
        var bottomRightY; /*float*/
        var sourceBottomRightX; /*float*/
        var sourceBottomRightY; /*float*/
        if (alignmentPattern !== null) {
            bottomRightX = alignmentPattern.getX();
            bottomRightY = alignmentPattern.getY();
            sourceBottomRightX = dimMinusThree - 3.0;
            sourceBottomRightY = sourceBottomRightX;
        }
        else {
            // Don't have an alignment pattern, just make up the bottom-right point
            bottomRightX = (topRight.getX() - topLeft.getX()) + bottomLeft.getX();
            bottomRightY = (topRight.getY() - topLeft.getY()) + bottomLeft.getY();
            sourceBottomRightX = dimMinusThree;
            sourceBottomRightY = dimMinusThree;
        }
        return PerspectiveTransform_1.default.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());
    };
    Detector.sampleGrid = function (image, transform, dimension /*int*/) {
        var sampler = GridSamplerInstance_1.default.getInstance();
        return sampler.sampleGridWithTransform(image, dimension, dimension, transform);
    };
    /**
     * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position
     * of the finder patterns and estimated module size.</p>
     */
    Detector.computeDimension = function (topLeft, topRight, bottomLeft, moduleSize /*float*/) {
        var tltrCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, topRight) / moduleSize);
        var tlblCentersDimension = MathUtils_1.default.round(ResultPoint_1.default.distance(topLeft, bottomLeft) / moduleSize);
        var dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;
        switch (dimension & 0x03) { // mod 4
            case 0:
                dimension++;
                break;
            // 1? do nothing
            case 2:
                dimension--;
                break;
            case 3:
                throw new NotFoundException_1.default('Dimensions could be not found.');
        }
        return dimension;
    };
    /**
     * <p>Computes an average estimated module size based on estimated derived from the positions
     * of the three finder patterns.</p>
     *
     * @param topLeft detected top-left finder pattern center
     * @param topRight detected top-right finder pattern center
     * @param bottomLeft detected bottom-left finder pattern center
     * @return estimated module size
     */
    Detector.prototype.calculateModuleSize = function (topLeft, topRight, bottomLeft) {
        // Take the average
        return (this.calculateModuleSizeOneWay(topLeft, topRight) +
            this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2.0;
    };
    /**
     * <p>Estimates module size based on two finder patterns -- it uses
     * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the
     * width of each, measuring along the axis between their centers.</p>
     */
    Detector.prototype.calculateModuleSizeOneWay = function (pattern, otherPattern) {
        var moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(pattern.getX()), 
        /*(int) */ Math.floor(pattern.getY()), 
        /*(int) */ Math.floor(otherPattern.getX()), 
        /*(int) */ Math.floor(otherPattern.getY()));
        var moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(/*(int) */ Math.floor(otherPattern.getX()), 
        /*(int) */ Math.floor(otherPattern.getY()), 
        /*(int) */ Math.floor(pattern.getX()), 
        /*(int) */ Math.floor(pattern.getY()));
        if (isNaN(moduleSizeEst1)) {
            return moduleSizeEst2 / 7.0;
        }
        if (isNaN(moduleSizeEst2)) {
            return moduleSizeEst1 / 7.0;
        }
        // Average them, and divide by 7 since we've counted the width of 3 black modules,
        // and 1 white and 1 black module on either side. Ergo, divide sum by 14.
        return (moduleSizeEst1 + moduleSizeEst2) / 14.0;
    };
    /**
     * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of
     * a finder pattern by looking for a black-white-black run from the center in the direction
     * of another point (another finder pattern center), and in the opposite direction too.
     */
    Detector.prototype.sizeOfBlackWhiteBlackRunBothWays = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {
        var result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
        // Now count other way -- don't run off image though of course
        var scale = 1.0;
        var otherToX = fromX - (toX - fromX);
        if (otherToX < 0) {
            scale = fromX / /*(float) */ (fromX - otherToX);
            otherToX = 0;
        }
        else if (otherToX >= this.image.getWidth()) {
            scale = (this.image.getWidth() - 1 - fromX) / /*(float) */ (otherToX - fromX);
            otherToX = this.image.getWidth() - 1;
        }
        var otherToY = /*(int) */ Math.floor(fromY - (toY - fromY) * scale);
        scale = 1.0;
        if (otherToY < 0) {
            scale = fromY / /*(float) */ (fromY - otherToY);
            otherToY = 0;
        }
        else if (otherToY >= this.image.getHeight()) {
            scale = (this.image.getHeight() - 1 - fromY) / /*(float) */ (otherToY - fromY);
            otherToY = this.image.getHeight() - 1;
        }
        otherToX = /*(int) */ Math.floor(fromX + (otherToX - fromX) * scale);
        result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
        // Middle pixel is double-counted this way; subtract 1
        return result - 1.0;
    };
    /**
     * <p>This method traces a line from a point in the image, in the direction towards another point.
     * It begins in a black region, and keeps going until it finds white, then black, then white again.
     * It reports the distance from the start to this point.</p>
     *
     * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern
     * may be skewed or rotated.</p>
     */
    Detector.prototype.sizeOfBlackWhiteBlackRun = function (fromX /*int*/, fromY /*int*/, toX /*int*/, toY /*int*/) {
        // Mild variant of Bresenham's algorithm
        // see http://en.wikipedia.org/wiki/Bresenham's_line_algorithm
        var steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
        if (steep) {
            var temp = fromX;
            fromX = fromY;
            fromY = temp;
            temp = toX;
            toX = toY;
            toY = temp;
        }
        var dx = Math.abs(toX - fromX);
        var dy = Math.abs(toY - fromY);
        var error = -dx / 2;
        var xstep = fromX < toX ? 1 : -1;
        var ystep = fromY < toY ? 1 : -1;
        // In black pixels, looking for white, first or second time.
        var state = 0;
        // Loop up until x == toX, but not beyond
        var xLimit = toX + xstep;
        for (var x = fromX, y = fromY; x !== xLimit; x += xstep) {
            var realX = steep ? y : x;
            var realY = steep ? x : y;
            // Does current pixel mean we have moved white to black or vice versa?
            // Scanning black in state 0,2 and white in state 1, so if we find the wrong
            // color, advance to next state or end if we are in state 2 already
            if ((state === 1) === this.image.get(realX, realY)) {
                if (state === 2) {
                    return MathUtils_1.default.distance(x, y, fromX, fromY);
                }
                state++;
            }
            error += dy;
            if (error > 0) {
                if (y === toY) {
                    break;
                }
                y += ystep;
                error -= dx;
            }
        }
        // Found black-white-black; give the benefit of the doubt that the next pixel outside the image
        // is "white" so this last point at (toX+xStep,toY) is the right ending. This is really a
        // small approximation; (toX+xStep,toY+yStep) might be really correct. Ignore this.
        if (state === 2) {
            return MathUtils_1.default.distance(toX + xstep, toY, fromX, fromY);
        }
        // else we didn't find even black-white-black; no estimate is really possible
        return NaN;
    };
    /**
     * <p>Attempts to locate an alignment pattern in a limited region of the image, which is
     * guessed to contain it. This method uses {@link AlignmentPattern}.</p>
     *
     * @param overallEstModuleSize estimated module size so far
     * @param estAlignmentX x coordinate of center of area probably containing alignment pattern
     * @param estAlignmentY y coordinate of above
     * @param allowanceFactor number of pixels in all directions to search from the center
     * @return {@link AlignmentPattern} if found, or null otherwise
     * @throws NotFoundException if an unexpected error occurs during detection
     */
    Detector.prototype.findAlignmentInRegion = function (overallEstModuleSize /*float*/, estAlignmentX /*int*/, estAlignmentY /*int*/, allowanceFactor /*float*/) {
        // Look for an alignment pattern (3 modules in size) around where it
        // should be
        var allowance = /*(int) */ Math.floor(allowanceFactor * overallEstModuleSize);
        var alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
        var alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);
        if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
            throw new NotFoundException_1.default('Alignment top exceeds estimated module size.');
        }
        var alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
        var alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);
        if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {
            throw new NotFoundException_1.default('Alignment bottom exceeds estimated module size.');
        }
        var alignmentFinder = new AlignmentPatternFinder_1.default(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
        return alignmentFinder.find();
    };
    return Detector;
}());
exports.default = Detector;
//# sourceMappingURL=Detector.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/detector/FinderPattern.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/detector/FinderPattern.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode.detector {*/
var ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
/**
 * <p>Encapsulates a finder pattern, which are the three square patterns found in
 * the corners of QR Codes. It also encapsulates a count of similar finder patterns,
 * as a convenience to the finder's bookkeeping.</p>
 *
 * @author Sean Owen
 */
var FinderPattern = /** @class */ (function (_super) {
    __extends(FinderPattern, _super);
    // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {
    //   this(posX, posY, estimatedModuleSize, 1)
    // }
    function FinderPattern(posX /*float*/, posY /*float*/, estimatedModuleSize /*float*/, count /*int*/) {
        var _this = _super.call(this, posX, posY) || this;
        _this.estimatedModuleSize = estimatedModuleSize;
        _this.count = count;
        if (undefined === count) {
            _this.count = 1;
        }
        return _this;
    }
    FinderPattern.prototype.getEstimatedModuleSize = function () {
        return this.estimatedModuleSize;
    };
    FinderPattern.prototype.getCount = function () {
        return this.count;
    };
    /*
    void incrementCount() {
      this.count++
    }
     */
    /**
     * <p>Determines if this finder pattern "about equals" a finder pattern at the stated
     * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
     */
    FinderPattern.prototype.aboutEquals = function (moduleSize /*float*/, i /*float*/, j /*float*/) {
        if (Math.abs(i - this.getY()) <= moduleSize && Math.abs(j - this.getX()) <= moduleSize) {
            var moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
            return moduleSizeDiff <= 1.0 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
    };
    /**
     * Combines this object's current estimate of a finder pattern position and module size
     * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average
     * based on count.
     */
    FinderPattern.prototype.combineEstimate = function (i /*float*/, j /*float*/, newModuleSize /*float*/) {
        var combinedCount = this.count + 1;
        var combinedX = (this.count * this.getX() + j) / combinedCount;
        var combinedY = (this.count * this.getY() + i) / combinedCount;
        var combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;
        return new FinderPattern(combinedX, combinedY, combinedModuleSize, combinedCount);
    };
    return FinderPattern;
}(ResultPoint_1.default));
exports.default = FinderPattern;
//# sourceMappingURL=FinderPattern.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/detector/FinderPatternFinder.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/detector/FinderPatternFinder.js ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode.detector {*/
var DecodeHintType_1 = __webpack_require__(/*! ../../DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
var ResultPoint_1 = __webpack_require__(/*! ../../ResultPoint */ "./node_modules/@zxing/library/esm5/core/ResultPoint.js");
var FinderPattern_1 = __webpack_require__(/*! ./FinderPattern */ "./node_modules/@zxing/library/esm5/core/qrcode/detector/FinderPattern.js");
var FinderPatternInfo_1 = __webpack_require__(/*! ./FinderPatternInfo */ "./node_modules/@zxing/library/esm5/core/qrcode/detector/FinderPatternInfo.js");
var NotFoundException_1 = __webpack_require__(/*! ../../NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
/*import java.io.Serializable;*/
/*import java.util.ArrayList;*/
/*import java.util.Collections;*/
/*import java.util.Comparator;*/
/*import java.util.List;*/
/*import java.util.Map;*/
/**
 * <p>This class attempts to find finder patterns in a QR Code. Finder patterns are the square
 * markers at three corners of a QR Code.</p>
 *
 * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.
 *
 * @author Sean Owen
 */
var FinderPatternFinder = /** @class */ (function () {
    /**
     * <p>Creates a finder that will search the image for three finder patterns.</p>
     *
     * @param image image to search
     */
    // public constructor(image: BitMatrix) {
    //   this(image, null)
    // }
    function FinderPatternFinder(image, resultPointCallback) {
        this.image = image;
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = [];
        this.crossCheckStateCount = new Int32Array(5);
        this.resultPointCallback = resultPointCallback;
    }
    FinderPatternFinder.prototype.getImage = function () {
        return this.image;
    };
    FinderPatternFinder.prototype.getPossibleCenters = function () {
        return this.possibleCenters;
    };
    FinderPatternFinder.prototype.find = function (hints) {
        var tryHarder = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType_1.default.TRY_HARDER);
        var pureBarcode = (hints !== null && hints !== undefined) && undefined !== hints.get(DecodeHintType_1.default.PURE_BARCODE);
        var image = this.image;
        var maxI = image.getHeight();
        var maxJ = image.getWidth();
        // We are looking for black/white/black/white/black modules in
        // 1:1:3:1:1 ratio; this tracks the number of such modules seen so far
        // Let's assume that the maximum version QR Code we support takes up 1/4 the height of the
        // image, and then account for the center being 3 modules in size. This gives the smallest
        // number of pixels the center could be, so skip this often. When trying harder, look for all
        // QR versions regardless of how dense they are.
        var iSkip = Math.floor((3 * maxI) / (4 * FinderPatternFinder.MAX_MODULES));
        if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {
            iSkip = FinderPatternFinder.MIN_SKIP;
        }
        var done = false;
        var stateCount = new Int32Array(5);
        for (var i = iSkip - 1; i < maxI && !done; i += iSkip) {
            // Get a row of black/white values
            stateCount[0] = 0;
            stateCount[1] = 0;
            stateCount[2] = 0;
            stateCount[3] = 0;
            stateCount[4] = 0;
            var currentState = 0;
            for (var j = 0; j < maxJ; j++) {
                if (image.get(j, i)) {
                    // Black pixel
                    if ((currentState & 1) === 1) { // Counting white pixels
                        currentState++;
                    }
                    stateCount[currentState]++;
                }
                else { // White pixel
                    if ((currentState & 1) === 0) { // Counting black pixels
                        if (currentState === 4) { // A winner?
                            if (FinderPatternFinder.foundPatternCross(stateCount)) { // Yes
                                var confirmed = this.handlePossibleCenter(stateCount, i, j, pureBarcode);
                                if (confirmed === true) {
                                    // Start examining every other line. Checking each line turned out to be too
                                    // expensive and didn't improve performance.
                                    iSkip = 2;
                                    if (this.hasSkipped === true) {
                                        done = this.haveMultiplyConfirmedCenters();
                                    }
                                    else {
                                        var rowSkip = this.findRowSkip();
                                        if (rowSkip > stateCount[2]) {
                                            // Skip rows between row of lower confirmed center
                                            // and top of presumed third confirmed center
                                            // but back up a bit to get a full chance of detecting
                                            // it, entire width of center of finder pattern
                                            // Skip by rowSkip, but back off by stateCount[2] (size of last center
                                            // of pattern we saw) to be conservative, and also back off by iSkip which
                                            // is about to be re-added
                                            i += rowSkip - stateCount[2] - iSkip;
                                            j = maxJ - 1;
                                        }
                                    }
                                }
                                else {
                                    stateCount[0] = stateCount[2];
                                    stateCount[1] = stateCount[3];
                                    stateCount[2] = stateCount[4];
                                    stateCount[3] = 1;
                                    stateCount[4] = 0;
                                    currentState = 3;
                                    continue;
                                }
                                // Clear state to start looking again
                                currentState = 0;
                                stateCount[0] = 0;
                                stateCount[1] = 0;
                                stateCount[2] = 0;
                                stateCount[3] = 0;
                                stateCount[4] = 0;
                            }
                            else { // No, shift counts back by two
                                stateCount[0] = stateCount[2];
                                stateCount[1] = stateCount[3];
                                stateCount[2] = stateCount[4];
                                stateCount[3] = 1;
                                stateCount[4] = 0;
                                currentState = 3;
                            }
                        }
                        else {
                            stateCount[++currentState]++;
                        }
                    }
                    else { // Counting white pixels
                        stateCount[currentState]++;
                    }
                }
            }
            if (FinderPatternFinder.foundPatternCross(stateCount)) {
                var confirmed = this.handlePossibleCenter(stateCount, i, maxJ, pureBarcode);
                if (confirmed === true) {
                    iSkip = stateCount[0];
                    if (this.hasSkipped) {
                        // Found a third one
                        done = this.haveMultiplyConfirmedCenters();
                    }
                }
            }
        }
        var patternInfo = this.selectBestPatterns();
        ResultPoint_1.default.orderBestPatterns(patternInfo);
        return new FinderPatternInfo_1.default(patternInfo);
    };
    /**
     * Given a count of black/white/black/white/black pixels just seen and an end position,
     * figures the location of the center of this run.
     */
    FinderPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {
        return (end - stateCount[4] - stateCount[3]) - stateCount[2] / 2.0;
    };
    /**
     * @param stateCount count of black/white/black/white/black pixels just read
     * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios
     *         used by finder patterns to be considered a match
     */
    FinderPatternFinder.foundPatternCross = function (stateCount) {
        var totalModuleSize = 0;
        for (var i = 0; i < 5; i++) {
            var count = stateCount[i];
            if (count === 0) {
                return false;
            }
            totalModuleSize += count;
        }
        if (totalModuleSize < 7) {
            return false;
        }
        var moduleSize = totalModuleSize / 7.0;
        var maxVariance = moduleSize / 2.0;
        // Allow less than 50% variance from 1-1-3-1-1 proportions
        return Math.abs(moduleSize - stateCount[0]) < maxVariance &&
            Math.abs(moduleSize - stateCount[1]) < maxVariance &&
            Math.abs(3.0 * moduleSize - stateCount[2]) < 3 * maxVariance &&
            Math.abs(moduleSize - stateCount[3]) < maxVariance &&
            Math.abs(moduleSize - stateCount[4]) < maxVariance;
    };
    FinderPatternFinder.prototype.getCrossCheckStateCount = function () {
        var crossCheckStateCount = this.crossCheckStateCount;
        crossCheckStateCount[0] = 0;
        crossCheckStateCount[1] = 0;
        crossCheckStateCount[2] = 0;
        crossCheckStateCount[3] = 0;
        crossCheckStateCount[4] = 0;
        return crossCheckStateCount;
    };
    /**
     * After a vertical and horizontal scan finds a potential finder pattern, this method
     * "cross-cross-cross-checks" by scanning down diagonally through the center of the possible
     * finder pattern to see if the same proportion is detected.
     *
     * @param startI row where a finder pattern was detected
     * @param centerJ center of the section that appears to cross a finder pattern
     * @param maxCount maximum reasonable number of modules that should be
     *  observed in any reading state, based on the results of the horizontal scan
     * @param originalStateCountTotal The original state count total.
     * @return true if proportions are withing expected limits
     */
    FinderPatternFinder.prototype.crossCheckDiagonal = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
        var stateCount = this.getCrossCheckStateCount();
        // Start counting up, left from center finding black center mass
        var i = 0;
        var image = this.image;
        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i)) {
            stateCount[2]++;
            i++;
        }
        if (startI < i || centerJ < i) {
            return false;
        }
        // Continue up, left finding white space
        while (startI >= i && centerJ >= i && !image.get(centerJ - i, startI - i) &&
            stateCount[1] <= maxCount) {
            stateCount[1]++;
            i++;
        }
        // If already too many modules in this state or ran off the edge:
        if (startI < i || centerJ < i || stateCount[1] > maxCount) {
            return false;
        }
        // Continue up, left finding black border
        while (startI >= i && centerJ >= i && image.get(centerJ - i, startI - i) &&
            stateCount[0] <= maxCount) {
            stateCount[0]++;
            i++;
        }
        if (stateCount[0] > maxCount) {
            return false;
        }
        var maxI = image.getHeight();
        var maxJ = image.getWidth();
        // Now also count down, right from center
        i = 1;
        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i)) {
            stateCount[2]++;
            i++;
        }
        // Ran off the edge?
        if (startI + i >= maxI || centerJ + i >= maxJ) {
            return false;
        }
        while (startI + i < maxI && centerJ + i < maxJ && !image.get(centerJ + i, startI + i) &&
            stateCount[3] < maxCount) {
            stateCount[3]++;
            i++;
        }
        if (startI + i >= maxI || centerJ + i >= maxJ || stateCount[3] >= maxCount) {
            return false;
        }
        while (startI + i < maxI && centerJ + i < maxJ && image.get(centerJ + i, startI + i) &&
            stateCount[4] < maxCount) {
            stateCount[4]++;
            i++;
        }
        if (stateCount[4] >= maxCount) {
            return false;
        }
        // If we found a finder-pattern-like section, but its size is more than 100% different than
        // the original, assume it's a false positive
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal &&
            FinderPatternFinder.foundPatternCross(stateCount);
    };
    /**
     * <p>After a horizontal scan finds a potential finder pattern, this method
     * "cross-checks" by scanning down vertically through the center of the possible
     * finder pattern to see if the same proportion is detected.</p>
     *
     * @param startI row where a finder pattern was detected
     * @param centerJ center of the section that appears to cross a finder pattern
     * @param maxCount maximum reasonable number of modules that should be
     * observed in any reading state, based on the results of the horizontal scan
     * @return vertical center of finder pattern, or {@link Float#NaN} if not found
     */
    FinderPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
        var image = this.image;
        var maxI = image.getHeight();
        var stateCount = this.getCrossCheckStateCount();
        // Start counting up from center
        var i = startI;
        while (i >= 0 && image.get(centerJ, i)) {
            stateCount[2]++;
            i--;
        }
        if (i < 0) {
            return NaN;
        }
        while (i >= 0 && !image.get(centerJ, i) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            i--;
        }
        // If already too many modules in this state or ran off the edge:
        if (i < 0 || stateCount[1] > maxCount) {
            return NaN;
        }
        while (i >= 0 && image.get(centerJ, i) && stateCount[0] <= maxCount) {
            stateCount[0]++;
            i--;
        }
        if (stateCount[0] > maxCount) {
            return NaN;
        }
        // Now also count down from center
        i = startI + 1;
        while (i < maxI && image.get(centerJ, i)) {
            stateCount[2]++;
            i++;
        }
        if (i === maxI) {
            return NaN;
        }
        while (i < maxI && !image.get(centerJ, i) && stateCount[3] < maxCount) {
            stateCount[3]++;
            i++;
        }
        if (i === maxI || stateCount[3] >= maxCount) {
            return NaN;
        }
        while (i < maxI && image.get(centerJ, i) && stateCount[4] < maxCount) {
            stateCount[4]++;
            i++;
        }
        if (stateCount[4] >= maxCount) {
            return NaN;
        }
        // If we found a finder-pattern-like section, but its size is more than 40% different than
        // the original, assume it's a false positive
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
            stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
            return NaN;
        }
        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i) : NaN;
    };
    /**
     * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,
     * except it reads horizontally instead of vertically. This is used to cross-cross
     * check a vertical cross check and locate the real center of the alignment pattern.</p>
     */
    FinderPatternFinder.prototype.crossCheckHorizontal = function (startJ /*int*/, centerI /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {
        var image = this.image;
        var maxJ = image.getWidth();
        var stateCount = this.getCrossCheckStateCount();
        var j = startJ;
        while (j >= 0 && image.get(j, centerI)) {
            stateCount[2]++;
            j--;
        }
        if (j < 0) {
            return NaN;
        }
        while (j >= 0 && !image.get(j, centerI) && stateCount[1] <= maxCount) {
            stateCount[1]++;
            j--;
        }
        if (j < 0 || stateCount[1] > maxCount) {
            return NaN;
        }
        while (j >= 0 && image.get(j, centerI) && stateCount[0] <= maxCount) {
            stateCount[0]++;
            j--;
        }
        if (stateCount[0] > maxCount) {
            return NaN;
        }
        j = startJ + 1;
        while (j < maxJ && image.get(j, centerI)) {
            stateCount[2]++;
            j++;
        }
        if (j === maxJ) {
            return NaN;
        }
        while (j < maxJ && !image.get(j, centerI) && stateCount[3] < maxCount) {
            stateCount[3]++;
            j++;
        }
        if (j === maxJ || stateCount[3] >= maxCount) {
            return NaN;
        }
        while (j < maxJ && image.get(j, centerI) && stateCount[4] < maxCount) {
            stateCount[4]++;
            j++;
        }
        if (stateCount[4] >= maxCount) {
            return NaN;
        }
        // If we found a finder-pattern-like section, but its size is significantly different than
        // the original, assume it's a false positive
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
            stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
            return NaN;
        }
        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j) : NaN;
    };
    /**
     * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
     * cross check with a vertical scan, and if successful, will, ah, cross-cross-check
     * with another horizontal scan. This is needed primarily to locate the real horizontal
     * center of the pattern in cases of extreme skew.
     * And then we cross-cross-cross check with another diagonal scan.</p>
     *
     * <p>If that succeeds the finder pattern location is added to a list that tracks
     * the number of times each location has been nearly-matched as a finder pattern.
     * Each additional find is more evidence that the location is in fact a finder
     * pattern center
     *
     * @param stateCount reading state module counts from horizontal scan
     * @param i row where finder pattern may be found
     * @param j end of possible finder pattern in row
     * @param pureBarcode true if in "pure barcode" mode
     * @return true if a finder pattern candidate was found this time
     */
    FinderPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/, pureBarcode) {
        var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] +
            stateCount[4];
        var centerJ = FinderPatternFinder.centerFromEnd(stateCount, j);
        var centerI = this.crossCheckVertical(i, /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal);
        if (!isNaN(centerI)) {
            // Re-cross check
            centerJ = this.crossCheckHorizontal(/*(int) */ Math.floor(centerJ), /*(int) */ Math.floor(centerI), stateCount[2], stateCountTotal);
            if (!isNaN(centerJ) &&
                (!pureBarcode || this.crossCheckDiagonal(/*(int) */ Math.floor(centerI), /*(int) */ Math.floor(centerJ), stateCount[2], stateCountTotal))) {
                var estimatedModuleSize = stateCountTotal / 7.0;
                var found = false;
                var possibleCenters = this.possibleCenters;
                for (var index = 0, length_1 = possibleCenters.length; index < length_1; index++) {
                    var center = possibleCenters[index];
                    // Look for about the same center and module size:
                    if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                        possibleCenters[index] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    var point = new FinderPattern_1.default(centerJ, centerI, estimatedModuleSize);
                    possibleCenters.push(point);
                    if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {
                        this.resultPointCallback.foundPossibleResultPoint(point);
                    }
                }
                return true;
            }
        }
        return false;
    };
    /**
     * @return number of rows we could safely skip during scanning, based on the first
     *         two finder patterns that have been located. In some cases their position will
     *         allow us to infer that the third pattern must lie below a certain point farther
     *         down in the image.
     */
    FinderPatternFinder.prototype.findRowSkip = function () {
        var e_1, _a;
        var max = this.possibleCenters.length;
        if (max <= 1) {
            return 0;
        }
        var firstConfirmedCenter = null;
        try {
            for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {
                var center = _c.value;
                if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
                    if (firstConfirmedCenter == null) {
                        firstConfirmedCenter = center;
                    }
                    else {
                        // We have two confirmed centers
                        // How far down can we skip before resuming looking for the next
                        // pattern? In the worst case, only the difference between the
                        // difference in the x / y coordinates of the two centers.
                        // This is the case where you find top left last.
                        this.hasSkipped = true;
                        return /*(int) */ Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) -
                            Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2);
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return 0;
    };
    /**
     * @return true iff we have found at least 3 finder patterns that have been detected
     *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the
     *         candidates is "pretty similar"
     */
    FinderPatternFinder.prototype.haveMultiplyConfirmedCenters = function () {
        var e_2, _a, e_3, _b;
        var confirmedCount = 0;
        var totalModuleSize = 0.0;
        var max = this.possibleCenters.length;
        try {
            for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {
                var pattern = _d.value;
                if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
                    confirmedCount++;
                    totalModuleSize += pattern.getEstimatedModuleSize();
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (confirmedCount < 3) {
            return false;
        }
        // OK, we have at least 3 confirmed centers, but, it's possible that one is a "false positive"
        // and that we need to keep looking. We detect this by asking if the estimated module sizes
        // vary too much. We arbitrarily say that when the total deviation from average exceeds
        // 5% of the total module size estimates, it's too much.
        var average = totalModuleSize / max;
        var totalDeviation = 0.0;
        try {
            for (var _e = __values(this.possibleCenters), _f = _e.next(); !_f.done; _f = _e.next()) {
                var pattern = _f.value;
                totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return totalDeviation <= 0.05 * totalModuleSize;
    };
    /**
     * @return the 3 best {@link FinderPattern}s from our list of candidates. The "best" are
     *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module
     *         size differs from the average among those patterns the least
     * @throws NotFoundException if 3 such finder patterns do not exist
     */
    FinderPatternFinder.prototype.selectBestPatterns = function () {
        var e_4, _a, e_5, _b;
        var startSize = this.possibleCenters.length;
        if (startSize < 3) {
            // Couldn't find enough finder patterns
            throw new NotFoundException_1.default();
        }
        var possibleCenters = this.possibleCenters;
        var average;
        // Filter outlier possibilities whose module size is too different
        if (startSize > 3) {
            // But we can only afford to do so if we have at least 4 possibilities to choose from
            var totalModuleSize = 0.0;
            var square = 0.0;
            try {
                for (var _c = __values(this.possibleCenters), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var center = _d.value;
                    var size = center.getEstimatedModuleSize();
                    totalModuleSize += size;
                    square += size * size;
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_4) throw e_4.error; }
            }
            average = totalModuleSize / startSize;
            var stdDev = Math.sqrt(square / startSize - average * average);
            possibleCenters.sort(
            /**
             * <p>Orders by furthest from average</p>
             */
            // FurthestFromAverageComparator implements Comparator<FinderPattern>
            function (center1, center2) {
                var dA = Math.abs(center2.getEstimatedModuleSize() - average);
                var dB = Math.abs(center1.getEstimatedModuleSize() - average);
                return dA < dB ? -1 : dA > dB ? 1 : 0;
            });
            var limit = Math.max(0.2 * average, stdDev);
            for (var i = 0; i < possibleCenters.length && possibleCenters.length > 3; i++) {
                var pattern = possibleCenters[i];
                if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
                    possibleCenters.splice(i, 1);
                    i--;
                }
            }
        }
        if (possibleCenters.length > 3) {
            // Throw away all but those first size candidate points we found.
            var totalModuleSize = 0.0;
            try {
                for (var possibleCenters_1 = __values(possibleCenters), possibleCenters_1_1 = possibleCenters_1.next(); !possibleCenters_1_1.done; possibleCenters_1_1 = possibleCenters_1.next()) {
                    var possibleCenter = possibleCenters_1_1.value;
                    totalModuleSize += possibleCenter.getEstimatedModuleSize();
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (possibleCenters_1_1 && !possibleCenters_1_1.done && (_b = possibleCenters_1.return)) _b.call(possibleCenters_1);
                }
                finally { if (e_5) throw e_5.error; }
            }
            average = totalModuleSize / possibleCenters.length;
            possibleCenters.sort(
            /**
             * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>
             */
            // CenterComparator implements Comparator<FinderPattern>
            function (center1, center2) {
                if (center2.getCount() === center1.getCount()) {
                    var dA = Math.abs(center2.getEstimatedModuleSize() - average);
                    var dB = Math.abs(center1.getEstimatedModuleSize() - average);
                    return dA < dB ? 1 : dA > dB ? -1 : 0;
                }
                else {
                    return center2.getCount() - center1.getCount();
                }
            });
            possibleCenters.splice(3); // this is not realy necessary as we only return first 3 anyway
        }
        return [
            possibleCenters[0],
            possibleCenters[1],
            possibleCenters[2]
        ];
    };
    FinderPatternFinder.CENTER_QUORUM = 2;
    FinderPatternFinder.MIN_SKIP = 3; // 1 pixel/module times 3 modules/center
    FinderPatternFinder.MAX_MODULES = 57; // support up to version 10 for mobile clients
    return FinderPatternFinder;
}());
exports.default = FinderPatternFinder;
//# sourceMappingURL=FinderPatternFinder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/detector/FinderPatternInfo.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/detector/FinderPatternInfo.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2007 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * <p>Encapsulates information about finder patterns in an image, including the location of
 * the three finder patterns, and their estimated module size.</p>
 *
 * @author Sean Owen
 */
var FinderPatternInfo = /** @class */ (function () {
    function FinderPatternInfo(patternCenters) {
        this.bottomLeft = patternCenters[0];
        this.topLeft = patternCenters[1];
        this.topRight = patternCenters[2];
    }
    FinderPatternInfo.prototype.getBottomLeft = function () {
        return this.bottomLeft;
    };
    FinderPatternInfo.prototype.getTopLeft = function () {
        return this.topLeft;
    };
    FinderPatternInfo.prototype.getTopRight = function () {
        return this.topRight;
    };
    return FinderPatternInfo;
}());
exports.default = FinderPatternInfo;
//# sourceMappingURL=FinderPatternInfo.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/BlockPair.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/encoder/BlockPair.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode.encoder {*/
var BlockPair = /** @class */ (function () {
    function BlockPair(dataBytes, errorCorrectionBytes) {
        this.dataBytes = dataBytes;
        this.errorCorrectionBytes = errorCorrectionBytes;
    }
    BlockPair.prototype.getDataBytes = function () {
        return this.dataBytes;
    };
    BlockPair.prototype.getErrorCorrectionBytes = function () {
        return this.errorCorrectionBytes;
    };
    return BlockPair;
}());
exports.default = BlockPair;
//# sourceMappingURL=BlockPair.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/ByteMatrix.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/encoder/ByteMatrix.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode.encoder {*/
/*import java.util.Arrays;*/
var Arrays_1 = __webpack_require__(/*! ../../util/Arrays */ "./node_modules/@zxing/library/esm5/core/util/Arrays.js");
var StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
/**
 * JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned
 * -1, 0, and 1, I'm going to use less memory and go with bytes.
 *
 * @author dswitkin@google.com (Daniel Switkin)
 */
var ByteMatrix = /** @class */ (function () {
    function ByteMatrix(width /*int*/, height /*int*/) {
        this.width = width;
        this.height = height;
        var bytes = new Array(height); // [height][width]
        for (var i = 0; i !== height; i++) {
            bytes[i] = new Uint8Array(width);
        }
        this.bytes = bytes;
    }
    ByteMatrix.prototype.getHeight = function () {
        return this.height;
    };
    ByteMatrix.prototype.getWidth = function () {
        return this.width;
    };
    ByteMatrix.prototype.get = function (x /*int*/, y /*int*/) {
        return this.bytes[y][x];
    };
    /**
     * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)
     */
    ByteMatrix.prototype.getArray = function () {
        return this.bytes;
    };
    // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside
    ByteMatrix.prototype.setNumber = function (x /*int*/, y /*int*/, value /*byte|int*/) {
        this.bytes[y][x] = value;
    };
    // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {
    //   bytes[y][x] = (byte) value
    // }
    ByteMatrix.prototype.setBoolean = function (x /*int*/, y /*int*/, value) {
        this.bytes[y][x] = /*(byte) */ (value ? 1 : 0);
    };
    ByteMatrix.prototype.clear = function (value /*byte*/) {
        var e_1, _a;
        try {
            for (var _b = __values(this.bytes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var aByte = _c.value;
                Arrays_1.default.fill(aByte, value);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    ByteMatrix.prototype.equals = function (o) {
        if (!(o instanceof ByteMatrix)) {
            return false;
        }
        var other = o;
        if (this.width !== other.width) {
            return false;
        }
        if (this.height !== other.height) {
            return false;
        }
        for (var y = 0, height = this.height; y < height; ++y) {
            var bytesY = this.bytes[y];
            var otherBytesY = other.bytes[y];
            for (var x = 0, width = this.width; x < width; ++x) {
                if (bytesY[x] !== otherBytesY[x]) {
                    return false;
                }
            }
        }
        return true;
    };
    /*@Override*/
    ByteMatrix.prototype.toString = function () {
        var result = new StringBuilder_1.default(); // (2 * width * height + 2)
        for (var y = 0, height = this.height; y < height; ++y) {
            var bytesY = this.bytes[y];
            for (var x = 0, width = this.width; x < width; ++x) {
                switch (bytesY[x]) {
                    case 0:
                        result.append(' 0');
                        break;
                    case 1:
                        result.append(' 1');
                        break;
                    default:
                        result.append('  ');
                        break;
                }
            }
            result.append('\n');
        }
        return result.toString();
    };
    return ByteMatrix;
}());
exports.default = ByteMatrix;
//# sourceMappingURL=ByteMatrix.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/Encoder.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/encoder/Encoder.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode.encoder {*/
var EncodeHintType_1 = __webpack_require__(/*! ../../EncodeHintType */ "./node_modules/@zxing/library/esm5/core/EncodeHintType.js");
var BitArray_1 = __webpack_require__(/*! ../../common/BitArray */ "./node_modules/@zxing/library/esm5/core/common/BitArray.js");
var CharacterSetECI_1 = __webpack_require__(/*! ../../common/CharacterSetECI */ "./node_modules/@zxing/library/esm5/core/common/CharacterSetECI.js");
var GenericGF_1 = __webpack_require__(/*! ../../common/reedsolomon/GenericGF */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGF.js");
var ReedSolomonEncoder_1 = __webpack_require__(/*! ../../common/reedsolomon/ReedSolomonEncoder */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/ReedSolomonEncoder.js");
var Mode_1 = __webpack_require__(/*! ../decoder/Mode */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/Mode.js");
var Version_1 = __webpack_require__(/*! ../decoder/Version */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/Version.js");
var MaskUtil_1 = __webpack_require__(/*! ./MaskUtil */ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/MaskUtil.js");
var ByteMatrix_1 = __webpack_require__(/*! ./ByteMatrix */ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/ByteMatrix.js");
var QRCode_1 = __webpack_require__(/*! ./QRCode */ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/QRCode.js");
var MatrixUtil_1 = __webpack_require__(/*! ./MatrixUtil */ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/MatrixUtil.js");
var StringEncoding_1 = __webpack_require__(/*! ../../util/StringEncoding */ "./node_modules/@zxing/library/esm5/core/util/StringEncoding.js");
var BlockPair_1 = __webpack_require__(/*! ./BlockPair */ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/BlockPair.js");
var WriterException_1 = __webpack_require__(/*! ../../WriterException */ "./node_modules/@zxing/library/esm5/core/WriterException.js");
/*import java.io.UnsupportedEncodingException;*/
/*import java.util.ArrayList;*/
/*import java.util.Collection;*/
/*import java.util.Map;*/
/**
 * @author satorux@google.com (Satoru Takabayashi) - creator
 * @author dswitkin@google.com (Daniel Switkin) - ported from C++
 */
var Encoder = /** @class */ (function () {
    // TYPESCRIPTPORT: changed to UTF8, the default for js
    function Encoder() {
    }
    // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.
    // Basically it applies four rules and summate all penalties.
    Encoder.calculateMaskPenalty = function (matrix) {
        return MaskUtil_1.default.applyMaskPenaltyRule1(matrix)
            + MaskUtil_1.default.applyMaskPenaltyRule2(matrix)
            + MaskUtil_1.default.applyMaskPenaltyRule3(matrix)
            + MaskUtil_1.default.applyMaskPenaltyRule4(matrix);
    };
    /**
     * @param content text to encode
     * @param ecLevel error correction level to use
     * @return {@link QRCode} representing the encoded QR code
     * @throws WriterException if encoding can't succeed, because of for example invalid content
     *   or configuration
     */
    // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {
    //   return encode(content, ecLevel, null)
    // }
    Encoder.encode = function (content, ecLevel, hints) {
        if (hints === void 0) { hints = null; }
        // Determine what character encoding has been specified by the caller, if any
        var encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;
        var hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType_1.default.CHARACTER_SET);
        if (hasEncodingHint) {
            encoding = hints.get(EncodeHintType_1.default.CHARACTER_SET).toString();
        }
        // Pick an encoding mode appropriate for the content. Note that this will not attempt to use
        // multiple modes / segments even if that were more efficient. Twould be nice.
        var mode = this.chooseMode(content, encoding);
        // This will store the header information, like mode and
        // length, as well as "header" segments like an ECI segment.
        var headerBits = new BitArray_1.default();
        // Append ECI segment if applicable
        if (mode === Mode_1.default.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {
            var eci = CharacterSetECI_1.default.getCharacterSetECIByName(encoding);
            if (eci !== undefined) {
                this.appendECI(eci, headerBits);
            }
        }
        // (With ECI in place,) Write the mode marker
        this.appendModeInfo(mode, headerBits);
        // Collect data within the main segment, separately, to count its size if needed. Don't add it to
        // main payload yet.
        var dataBits = new BitArray_1.default();
        this.appendBytes(content, mode, dataBits, encoding);
        var version;
        if (hints !== null && undefined !== hints.get(EncodeHintType_1.default.QR_VERSION)) {
            var versionNumber = Number.parseInt(hints.get(EncodeHintType_1.default.QR_VERSION).toString(), 10);
            version = Version_1.default.getVersionForNumber(versionNumber);
            var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);
            if (!this.willFit(bitsNeeded, version, ecLevel)) {
                throw new WriterException_1.default('Data too big for requested version');
            }
        }
        else {
            version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);
        }
        var headerAndDataBits = new BitArray_1.default();
        headerAndDataBits.appendBitArray(headerBits);
        // Find "length" of main segment and write it
        var numLetters = mode === Mode_1.default.BYTE ? dataBits.getSizeInBytes() : content.length;
        this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);
        // Put data together into the overall payload
        headerAndDataBits.appendBitArray(dataBits);
        var ecBlocks = version.getECBlocksForLevel(ecLevel);
        var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();
        // Terminate the bits properly.
        this.terminateBits(numDataBytes, headerAndDataBits);
        // Interleave data bits with error correction code.
        var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());
        var qrCode = new QRCode_1.default();
        qrCode.setECLevel(ecLevel);
        qrCode.setMode(mode);
        qrCode.setVersion(version);
        //  Choose the mask pattern and set to "qrCode".
        var dimension = version.getDimensionForVersion();
        var matrix = new ByteMatrix_1.default(dimension, dimension);
        var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);
        qrCode.setMaskPattern(maskPattern);
        // Build the matrix and set it to "qrCode".
        MatrixUtil_1.default.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);
        qrCode.setMatrix(matrix);
        return qrCode;
    };
    /**
     * Decides the smallest version of QR code that will contain all of the provided data.
     *
     * @throws WriterException if the data cannot fit in any version
     */
    Encoder.recommendVersion = function (ecLevel, mode, headerBits, dataBits) {
        // Hard part: need to know version to know how many bits length takes. But need to know how many
        // bits it takes to know version. First we take a guess at version by assuming version will be
        // the minimum, 1:
        var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version_1.default.getVersionForNumber(1));
        var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);
        // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.
        var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);
        return this.chooseVersion(bitsNeeded, ecLevel);
    };
    Encoder.calculateBitsNeeded = function (mode, headerBits, dataBits, version) {
        return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();
    };
    /**
     * @return the code point of the table used in alphanumeric mode or
     *  -1 if there is no corresponding code in the table.
     */
    Encoder.getAlphanumericCode = function (code /*int*/) {
        if (code < Encoder.ALPHANUMERIC_TABLE.length) {
            return Encoder.ALPHANUMERIC_TABLE[code];
        }
        return -1;
    };
    // public static chooseMode(content: string): Mode {
    //   return chooseMode(content, null);
    // }
    /**
     * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;
     * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.
     */
    Encoder.chooseMode = function (content, encoding) {
        if (encoding === void 0) { encoding = null; }
        if (CharacterSetECI_1.default.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {
            // Choose Kanji mode if all input are double-byte characters
            return Mode_1.default.KANJI;
        }
        var hasNumeric = false;
        var hasAlphanumeric = false;
        for (var i = 0, length_1 = content.length; i < length_1; ++i) {
            var c = content.charAt(i);
            if (Encoder.isDigit(c)) {
                hasNumeric = true;
            }
            else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {
                hasAlphanumeric = true;
            }
            else {
                return Mode_1.default.BYTE;
            }
        }
        if (hasAlphanumeric) {
            return Mode_1.default.ALPHANUMERIC;
        }
        if (hasNumeric) {
            return Mode_1.default.NUMERIC;
        }
        return Mode_1.default.BYTE;
    };
    Encoder.isOnlyDoubleByteKanji = function (content) {
        var bytes;
        try {
            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS); // content.getBytes("Shift_JIS"))
        }
        catch (ignored /*: UnsupportedEncodingException*/) {
            return false;
        }
        var length = bytes.length;
        if (length % 2 !== 0) {
            return false;
        }
        for (var i = 0; i < length; i += 2) {
            var byte1 = bytes[i] & 0xFF;
            if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {
                return false;
            }
        }
        return true;
    };
    Encoder.chooseMaskPattern = function (bits, ecLevel, version, matrix) {
        var minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.
        var bestMaskPattern = -1;
        // We try all mask patterns to choose the best one.
        for (var maskPattern = 0; maskPattern < QRCode_1.default.NUM_MASK_PATTERNS; maskPattern++) {
            MatrixUtil_1.default.buildMatrix(bits, ecLevel, version, maskPattern, matrix);
            var penalty = this.calculateMaskPenalty(matrix);
            if (penalty < minPenalty) {
                minPenalty = penalty;
                bestMaskPattern = maskPattern;
            }
        }
        return bestMaskPattern;
    };
    Encoder.chooseVersion = function (numInputBits /*int*/, ecLevel) {
        for (var versionNum = 1; versionNum <= 40; versionNum++) {
            var version = Version_1.default.getVersionForNumber(versionNum);
            if (Encoder.willFit(numInputBits, version, ecLevel)) {
                return version;
            }
        }
        throw new WriterException_1.default('Data too big');
    };
    /**
     * @return true if the number of input bits will fit in a code with the specified version and
     * error correction level.
     */
    Encoder.willFit = function (numInputBits /*int*/, version, ecLevel) {
        // In the following comments, we use numbers of Version 7-H.
        // numBytes = 196
        var numBytes = version.getTotalCodewords();
        // getNumECBytes = 130
        var ecBlocks = version.getECBlocksForLevel(ecLevel);
        var numEcBytes = ecBlocks.getTotalECCodewords();
        // getNumDataBytes = 196 - 130 = 66
        var numDataBytes = numBytes - numEcBytes;
        var totalInputBytes = (numInputBits + 7) / 8;
        return numDataBytes >= totalInputBytes;
    };
    /**
     * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
     */
    Encoder.terminateBits = function (numDataBytes /*int*/, bits) {
        var capacity = numDataBytes * 8;
        if (bits.getSize() > capacity) {
            throw new WriterException_1.default('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' +
                capacity);
        }
        for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {
            bits.appendBit(false);
        }
        // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.
        // If the last byte isn't 8-bit aligned, we'll add padding bits.
        var numBitsInLastByte = bits.getSize() & 0x07;
        if (numBitsInLastByte > 0) {
            for (var i = numBitsInLastByte; i < 8; i++) {
                bits.appendBit(false);
            }
        }
        // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).
        var numPaddingBytes = numDataBytes - bits.getSizeInBytes();
        for (var i = 0; i < numPaddingBytes; ++i) {
            bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);
        }
        if (bits.getSize() !== capacity) {
            throw new WriterException_1.default('Bits size does not equal capacity');
        }
    };
    /**
     * Get number of data bytes and number of error correction bytes for block id "blockID". Store
     * the result in "numDataBytesInBlock", and "numECBytesInBlock". See table 12 in 8.5.1 of
     * JISX0510:2004 (p.30)
     */
    Encoder.getNumDataBytesAndNumECBytesForBlockID = function (numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/, blockID /*int*/, numDataBytesInBlock, numECBytesInBlock) {
        if (blockID >= numRSBlocks) {
            throw new WriterException_1.default('Block ID too large');
        }
        // numRsBlocksInGroup2 = 196 % 5 = 1
        var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
        // numRsBlocksInGroup1 = 5 - 1 = 4
        var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
        // numTotalBytesInGroup1 = 196 / 5 = 39
        var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);
        // numTotalBytesInGroup2 = 39 + 1 = 40
        var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
        // numDataBytesInGroup1 = 66 / 5 = 13
        var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);
        // numDataBytesInGroup2 = 13 + 1 = 14
        var numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
        // numEcBytesInGroup1 = 39 - 13 = 26
        var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
        // numEcBytesInGroup2 = 40 - 14 = 26
        var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
        // Sanity checks.
        // 26 = 26
        if (numEcBytesInGroup1 !== numEcBytesInGroup2) {
            throw new WriterException_1.default('EC bytes mismatch');
        }
        // 5 = 4 + 1.
        if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {
            throw new WriterException_1.default('RS blocks mismatch');
        }
        // 196 = (13 + 26) * 4 + (14 + 26) * 1
        if (numTotalBytes !==
            ((numDataBytesInGroup1 + numEcBytesInGroup1) *
                numRsBlocksInGroup1) +
                ((numDataBytesInGroup2 + numEcBytesInGroup2) *
                    numRsBlocksInGroup2)) {
            throw new WriterException_1.default('Total bytes mismatch');
        }
        if (blockID < numRsBlocksInGroup1) {
            numDataBytesInBlock[0] = numDataBytesInGroup1;
            numECBytesInBlock[0] = numEcBytesInGroup1;
        }
        else {
            numDataBytesInBlock[0] = numDataBytesInGroup2;
            numECBytesInBlock[0] = numEcBytesInGroup2;
        }
    };
    /**
     * Interleave "bits" with corresponding error correction bytes. On success, store the result in
     * "result". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.
     */
    Encoder.interleaveWithECBytes = function (bits, numTotalBytes /*int*/, numDataBytes /*int*/, numRSBlocks /*int*/) {
        var e_1, _a, e_2, _b;
        // "bits" must have "getNumDataBytes" bytes of data.
        if (bits.getSizeInBytes() !== numDataBytes) {
            throw new WriterException_1.default('Number of bits and data bytes does not match');
        }
        // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll
        // store the divided data bytes blocks and error correction bytes blocks into "blocks".
        var dataBytesOffset = 0;
        var maxNumDataBytes = 0;
        var maxNumEcBytes = 0;
        // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.
        var blocks = new Array(); // new Array<BlockPair>(numRSBlocks)
        for (var i = 0; i < numRSBlocks; ++i) {
            var numDataBytesInBlock = new Int32Array(1);
            var numEcBytesInBlock = new Int32Array(1);
            Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);
            var size = numDataBytesInBlock[0];
            var dataBytes = new Uint8Array(size);
            bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);
            var ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);
            blocks.push(new BlockPair_1.default(dataBytes, ecBytes));
            maxNumDataBytes = Math.max(maxNumDataBytes, size);
            maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);
            dataBytesOffset += numDataBytesInBlock[0];
        }
        if (numDataBytes !== dataBytesOffset) {
            throw new WriterException_1.default('Data bytes does not match offset');
        }
        var result = new BitArray_1.default();
        // First, place data blocks.
        for (var i = 0; i < maxNumDataBytes; ++i) {
            try {
                for (var blocks_1 = __values(blocks), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {
                    var block = blocks_1_1.value;
                    var dataBytes = block.getDataBytes();
                    if (i < dataBytes.length) {
                        result.appendBits(dataBytes[i], 8);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        // Then, place error correction blocks.
        for (var i = 0; i < maxNumEcBytes; ++i) {
            try {
                for (var blocks_2 = __values(blocks), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {
                    var block = blocks_2_1.value;
                    var ecBytes = block.getErrorCorrectionBytes();
                    if (i < ecBytes.length) {
                        result.appendBits(ecBytes[i], 8);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return)) _b.call(blocks_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        if (numTotalBytes !== result.getSizeInBytes()) { // Should be same.
            throw new WriterException_1.default('Interleaving error: ' + numTotalBytes + ' and ' +
                result.getSizeInBytes() + ' differ.');
        }
        return result;
    };
    Encoder.generateECBytes = function (dataBytes, numEcBytesInBlock /*int*/) {
        var numDataBytes = dataBytes.length;
        var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]
        for (var i = 0; i < numDataBytes; i++) {
            toEncode[i] = dataBytes[i] & 0xFF;
        }
        new ReedSolomonEncoder_1.default(GenericGF_1.default.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);
        var ecBytes = new Uint8Array(numEcBytesInBlock);
        for (var i = 0; i < numEcBytesInBlock; i++) {
            ecBytes[i] = /*(byte) */ toEncode[numDataBytes + i];
        }
        return ecBytes;
    };
    /**
     * Append mode info. On success, store the result in "bits".
     */
    Encoder.appendModeInfo = function (mode, bits) {
        bits.appendBits(mode.getBits(), 4);
    };
    /**
     * Append length info. On success, store the result in "bits".
     */
    Encoder.appendLengthInfo = function (numLetters /*int*/, version, mode, bits) {
        var numBits = mode.getCharacterCountBits(version);
        if (numLetters >= (1 << numBits)) {
            throw new WriterException_1.default(numLetters + ' is bigger than ' + ((1 << numBits) - 1));
        }
        bits.appendBits(numLetters, numBits);
    };
    /**
     * Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".
     */
    Encoder.appendBytes = function (content, mode, bits, encoding) {
        switch (mode) {
            case Mode_1.default.NUMERIC:
                Encoder.appendNumericBytes(content, bits);
                break;
            case Mode_1.default.ALPHANUMERIC:
                Encoder.appendAlphanumericBytes(content, bits);
                break;
            case Mode_1.default.BYTE:
                Encoder.append8BitBytes(content, bits, encoding);
                break;
            case Mode_1.default.KANJI:
                Encoder.appendKanjiBytes(content, bits);
                break;
            default:
                throw new WriterException_1.default('Invalid mode: ' + mode);
        }
    };
    Encoder.getDigit = function (singleCharacter) {
        return singleCharacter.charCodeAt(0) - 48;
    };
    Encoder.isDigit = function (singleCharacter) {
        var cn = Encoder.getDigit(singleCharacter);
        return cn >= 0 && cn <= 9;
    };
    Encoder.appendNumericBytes = function (content, bits) {
        var length = content.length;
        var i = 0;
        while (i < length) {
            var num1 = Encoder.getDigit(content.charAt(i));
            if (i + 2 < length) {
                // Encode three numeric letters in ten bits.
                var num2 = Encoder.getDigit(content.charAt(i + 1));
                var num3 = Encoder.getDigit(content.charAt(i + 2));
                bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);
                i += 3;
            }
            else if (i + 1 < length) {
                // Encode two numeric letters in seven bits.
                var num2 = Encoder.getDigit(content.charAt(i + 1));
                bits.appendBits(num1 * 10 + num2, 7);
                i += 2;
            }
            else {
                // Encode one numeric letter in four bits.
                bits.appendBits(num1, 4);
                i++;
            }
        }
    };
    Encoder.appendAlphanumericBytes = function (content, bits) {
        var length = content.length;
        var i = 0;
        while (i < length) {
            var code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));
            if (code1 === -1) {
                throw new WriterException_1.default();
            }
            if (i + 1 < length) {
                var code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));
                if (code2 === -1) {
                    throw new WriterException_1.default();
                }
                // Encode two alphanumeric letters in 11 bits.
                bits.appendBits(code1 * 45 + code2, 11);
                i += 2;
            }
            else {
                // Encode one alphanumeric letter in six bits.
                bits.appendBits(code1, 6);
                i++;
            }
        }
    };
    Encoder.append8BitBytes = function (content, bits, encoding) {
        var bytes;
        try {
            bytes = StringEncoding_1.default.encode(content, encoding);
        }
        catch (uee /*: UnsupportedEncodingException*/) {
            throw new WriterException_1.default(uee);
        }
        for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {
            var b = bytes[i];
            bits.appendBits(b, 8);
        }
    };
    /**
     * @throws WriterException
     */
    Encoder.appendKanjiBytes = function (content, bits) {
        var bytes;
        try {
            bytes = StringEncoding_1.default.encode(content, CharacterSetECI_1.default.SJIS);
        }
        catch (uee /*: UnsupportedEncodingException*/) {
            throw new WriterException_1.default(uee);
        }
        var length = bytes.length;
        for (var i = 0; i < length; i += 2) {
            var byte1 = bytes[i] & 0xFF;
            var byte2 = bytes[i + 1] & 0xFF;
            var code = ((byte1 << 8) & 0xFFFFFFFF) | byte2;
            var subtracted = -1;
            if (code >= 0x8140 && code <= 0x9ffc) {
                subtracted = code - 0x8140;
            }
            else if (code >= 0xe040 && code <= 0xebbf) {
                subtracted = code - 0xc140;
            }
            if (subtracted === -1) {
                throw new WriterException_1.default('Invalid byte sequence');
            }
            var encoded = ((subtracted >> 8) * 0xc0) + (subtracted & 0xff);
            bits.appendBits(encoded, 13);
        }
    };
    Encoder.appendECI = function (eci, bits) {
        bits.appendBits(Mode_1.default.ECI.getBits(), 4);
        // This is correct for values up to 127, which is all we need now.
        bits.appendBits(eci.getValue(), 8);
    };
    // The original table is defined in the table 5 of JISX0510:2004 (p.19).
    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
        36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1,
        -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1,
    ]);
    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI_1.default.UTF8.getName(); // "ISO-8859-1"
    return Encoder;
}());
exports.default = Encoder;
//# sourceMappingURL=Encoder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/MaskUtil.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/encoder/MaskUtil.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * @author Satoru Takabayashi
 * @author Daniel Switkin
 * @author Sean Owen
 */
var MaskUtil = /** @class */ (function () {
    function MaskUtil() {
        // do nothing
    }
    /**
     * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and
     * give penalty to them. Example: 00000 or 11111.
     */
    MaskUtil.applyMaskPenaltyRule1 = function (matrix) {
        return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);
    };
    /**
     * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give
     * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a
     * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.
     */
    MaskUtil.applyMaskPenaltyRule2 = function (matrix) {
        var penalty = 0;
        var array = matrix.getArray();
        var width = matrix.getWidth();
        var height = matrix.getHeight();
        for (var y = 0; y < height - 1; y++) {
            var arrayY = array[y];
            for (var x = 0; x < width - 1; x++) {
                var value = arrayY[x];
                if (value === arrayY[x + 1] && value === array[y + 1][x] && value === array[y + 1][x + 1]) {
                    penalty++;
                }
            }
        }
        return MaskUtil.N2 * penalty;
    };
    /**
     * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4
     * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we
     * find patterns like 000010111010000, we give penalty once.
     */
    MaskUtil.applyMaskPenaltyRule3 = function (matrix) {
        var numPenalties = 0;
        var array = matrix.getArray();
        var width = matrix.getWidth();
        var height = matrix.getHeight();
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var arrayY = array[y]; // We can at least optimize this access
                if (x + 6 < width &&
                    arrayY[x] === 1 &&
                    arrayY[x + 1] === 0 &&
                    arrayY[x + 2] === 1 &&
                    arrayY[x + 3] === 1 &&
                    arrayY[x + 4] === 1 &&
                    arrayY[x + 5] === 0 &&
                    arrayY[x + 6] === 1 &&
                    (MaskUtil.isWhiteHorizontal(arrayY, x - 4, x) || MaskUtil.isWhiteHorizontal(arrayY, x + 7, x + 11))) {
                    numPenalties++;
                }
                if (y + 6 < height &&
                    array[y][x] === 1 &&
                    array[y + 1][x] === 0 &&
                    array[y + 2][x] === 1 &&
                    array[y + 3][x] === 1 &&
                    array[y + 4][x] === 1 &&
                    array[y + 5][x] === 0 &&
                    array[y + 6][x] === 1 &&
                    (MaskUtil.isWhiteVertical(array, x, y - 4, y) || MaskUtil.isWhiteVertical(array, x, y + 7, y + 11))) {
                    numPenalties++;
                }
            }
        }
        return numPenalties * MaskUtil.N3;
    };
    MaskUtil.isWhiteHorizontal = function (rowArray, from /*int*/, to /*int*/) {
        from = Math.max(from, 0);
        to = Math.min(to, rowArray.length);
        for (var i = from; i < to; i++) {
            if (rowArray[i] === 1) {
                return false;
            }
        }
        return true;
    };
    MaskUtil.isWhiteVertical = function (array, col /*int*/, from /*int*/, to /*int*/) {
        from = Math.max(from, 0);
        to = Math.min(to, array.length);
        for (var i = from; i < to; i++) {
            if (array[i][col] === 1) {
                return false;
            }
        }
        return true;
    };
    /**
     * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give
     * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.
     */
    MaskUtil.applyMaskPenaltyRule4 = function (matrix) {
        var numDarkCells = 0;
        var array = matrix.getArray();
        var width = matrix.getWidth();
        var height = matrix.getHeight();
        for (var y = 0; y < height; y++) {
            var arrayY = array[y];
            for (var x = 0; x < width; x++) {
                if (arrayY[x] === 1) {
                    numDarkCells++;
                }
            }
        }
        var numTotalCells = matrix.getHeight() * matrix.getWidth();
        var fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);
        return fivePercentVariances * MaskUtil.N4;
    };
    /**
     * Return the mask bit for "getMaskPattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask
     * pattern conditions.
     */
    MaskUtil.getDataMaskBit = function (maskPattern /*int*/, x /*int*/, y /*int*/) {
        var intermediate; /*int*/
        var temp; /*int*/
        switch (maskPattern) {
            case 0:
                intermediate = (y + x) & 0x1;
                break;
            case 1:
                intermediate = y & 0x1;
                break;
            case 2:
                intermediate = x % 3;
                break;
            case 3:
                intermediate = (y + x) % 3;
                break;
            case 4:
                intermediate = (Math.floor(y / 2) + Math.floor(x / 3)) & 0x1;
                break;
            case 5:
                temp = y * x;
                intermediate = (temp & 0x1) + (temp % 3);
                break;
            case 6:
                temp = y * x;
                intermediate = ((temp & 0x1) + (temp % 3)) & 0x1;
                break;
            case 7:
                temp = y * x;
                intermediate = ((temp % 3) + ((y + x) & 0x1)) & 0x1;
                break;
            default:
                throw new IllegalArgumentException_1.default('Invalid mask pattern: ' + maskPattern);
        }
        return intermediate === 0;
    };
    /**
     * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both
     * vertical and horizontal orders respectively.
     */
    MaskUtil.applyMaskPenaltyRule1Internal = function (matrix, isHorizontal) {
        var penalty = 0;
        var iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
        var jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();
        var array = matrix.getArray();
        for (var i = 0; i < iLimit; i++) {
            var numSameBitCells = 0;
            var prevBit = -1;
            for (var j = 0; j < jLimit; j++) {
                var bit = isHorizontal ? array[i][j] : array[j][i];
                if (bit === prevBit) {
                    numSameBitCells++;
                }
                else {
                    if (numSameBitCells >= 5) {
                        penalty += MaskUtil.N1 + (numSameBitCells - 5);
                    }
                    numSameBitCells = 1; // Include the cell itself.
                    prevBit = bit;
                }
            }
            if (numSameBitCells >= 5) {
                penalty += MaskUtil.N1 + (numSameBitCells - 5);
            }
        }
        return penalty;
    };
    // Penalty weights from section 6.8.2.1
    MaskUtil.N1 = 3;
    MaskUtil.N2 = 3;
    MaskUtil.N3 = 40;
    MaskUtil.N4 = 10;
    return MaskUtil;
}());
exports.default = MaskUtil;
//# sourceMappingURL=MaskUtil.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/MatrixUtil.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/encoder/MatrixUtil.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/*namespace com.google.zxing.qrcode.encoder {*/
var BitArray_1 = __webpack_require__(/*! ../../common/BitArray */ "./node_modules/@zxing/library/esm5/core/common/BitArray.js");
var Integer_1 = __webpack_require__(/*! ../../util/Integer */ "./node_modules/@zxing/library/esm5/core/util/Integer.js");
var QRCode_1 = __webpack_require__(/*! ./QRCode */ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/QRCode.js");
var MaskUtil_1 = __webpack_require__(/*! ./MaskUtil */ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/MaskUtil.js");
var WriterException_1 = __webpack_require__(/*! ../../WriterException */ "./node_modules/@zxing/library/esm5/core/WriterException.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
/**
 * @author satorux@google.com (Satoru Takabayashi) - creator
 * @author dswitkin@google.com (Daniel Switkin) - ported from C++
 */
var MatrixUtil = /** @class */ (function () {
    function MatrixUtil() {
        // do nothing
    }
    // Set all cells to -1 (TYPESCRIPTPORT: 255).  -1 (TYPESCRIPTPORT: 255) means that the cell is empty (not set yet).
    //
    // JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding
    // with the ByteMatrix initialized all to zero.
    MatrixUtil.clearMatrix = function (matrix) {
        // TYPESCRIPTPORT: we use UintArray se changed here from -1 to 255
        matrix.clear(/*(byte) */ /*-1*/ 255);
    };
    // Build 2D matrix of QR Code from "dataBits" with "ecLevel", "version" and "getMaskPattern". On
    // success, store the result in "matrix" and return true.
    MatrixUtil.buildMatrix = function (dataBits, ecLevel, version, maskPattern /*int*/, matrix) {
        MatrixUtil.clearMatrix(matrix);
        MatrixUtil.embedBasicPatterns(version, matrix);
        // Type information appear with any version.
        MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);
        // Version info appear if version >= 7.
        MatrixUtil.maybeEmbedVersionInfo(version, matrix);
        // Data should be embedded at end.
        MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);
    };
    // Embed basic patterns. On success, modify the matrix and return true.
    // The basic patterns are:
    // - Position detection patterns
    // - Timing patterns
    // - Dark dot at the left bottom corner
    // - Position adjustment patterns, if need be
    MatrixUtil.embedBasicPatterns = function (version, matrix) {
        // Let's get started with embedding big squares at corners.
        MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);
        // Then, embed the dark dot at the left bottom corner.
        MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);
        // Position adjustment patterns appear if version >= 2.
        MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version, matrix);
        // Timing patterns should be embedded after position adj. patterns.
        MatrixUtil.embedTimingPatterns(matrix);
    };
    // Embed type information. On success, modify the matrix.
    MatrixUtil.embedTypeInfo = function (ecLevel, maskPattern /*int*/, matrix) {
        var typeInfoBits = new BitArray_1.default();
        MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
        for (var i = 0, size = typeInfoBits.getSize(); i < size; ++i) {
            // Place bits in LSB to MSB order.  LSB (least significant bit) is the last value in
            // "typeInfoBits".
            var bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i);
            // Type info bits at the left top corner. See 8.9 of JISX0510:2004 (p.46).
            var coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i];
            var x1 = coordinates[0];
            var y1 = coordinates[1];
            matrix.setBoolean(x1, y1, bit);
            if (i < 8) {
                // Right top corner.
                var x2 = matrix.getWidth() - i - 1;
                var y2 = 8;
                matrix.setBoolean(x2, y2, bit);
            }
            else {
                // Left bottom corner.
                var x2 = 8;
                var y2 = matrix.getHeight() - 7 + (i - 8);
                matrix.setBoolean(x2, y2, bit);
            }
        }
    };
    // Embed version information if need be. On success, modify the matrix and return true.
    // See 8.10 of JISX0510:2004 (p.47) for how to embed version information.
    MatrixUtil.maybeEmbedVersionInfo = function (version, matrix) {
        if (version.getVersionNumber() < 7) { // Version info is necessary if version >= 7.
            return; // Don't need version info.
        }
        var versionInfoBits = new BitArray_1.default();
        MatrixUtil.makeVersionInfoBits(version, versionInfoBits);
        var bitIndex = 6 * 3 - 1; // It will decrease from 17 to 0.
        for (var i = 0; i < 6; ++i) {
            for (var j = 0; j < 3; ++j) {
                // Place bits in LSB (least significant bit) to MSB order.
                var bit = versionInfoBits.get(bitIndex);
                bitIndex--;
                // Left bottom corner.
                matrix.setBoolean(i, matrix.getHeight() - 11 + j, bit);
                // Right bottom corner.
                matrix.setBoolean(matrix.getHeight() - 11 + j, i, bit);
            }
        }
    };
    // Embed "dataBits" using "getMaskPattern". On success, modify the matrix and return true.
    // For debugging purposes, it skips masking process if "getMaskPattern" is -1(TYPESCRIPTPORT: 255).
    // See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.
    MatrixUtil.embedDataBits = function (dataBits, maskPattern /*int*/, matrix) {
        var bitIndex = 0;
        var direction = -1;
        // Start from the right bottom cell.
        var x = matrix.getWidth() - 1;
        var y = matrix.getHeight() - 1;
        while (x > 0) {
            // Skip the vertical timing pattern.
            if (x === 6) {
                x -= 1;
            }
            while (y >= 0 && y < matrix.getHeight()) {
                for (var i = 0; i < 2; ++i) {
                    var xx = x - i;
                    // Skip the cell if it's not empty.
                    if (!MatrixUtil.isEmpty(matrix.get(xx, y))) {
                        continue;
                    }
                    var bit = void 0;
                    if (bitIndex < dataBits.getSize()) {
                        bit = dataBits.get(bitIndex);
                        ++bitIndex;
                    }
                    else {
                        // Padding bit. If there is no bit left, we'll fill the left cells with 0, as described
                        // in 8.4.9 of JISX0510:2004 (p. 24).
                        bit = false;
                    }
                    // Skip masking if mask_pattern is -1 (TYPESCRIPTPORT: 255).
                    if (maskPattern !== 255 && MaskUtil_1.default.getDataMaskBit(maskPattern, xx, y)) {
                        bit = !bit;
                    }
                    matrix.setBoolean(xx, y, bit);
                }
                y += direction;
            }
            direction = -direction; // Reverse the direction.
            y += direction;
            x -= 2; // Move to the left.
        }
        // All bits should be consumed.
        if (bitIndex !== dataBits.getSize()) {
            throw new WriterException_1.default('Not all bits consumed: ' + bitIndex + '/' + dataBits.getSize());
        }
    };
    // Return the position of the most significant bit set (one: to) in the "value". The most
    // significant bit is position 32. If there is no bit set, return 0. Examples:
    // - findMSBSet(0) => 0
    // - findMSBSet(1) => 1
    // - findMSBSet(255) => 8
    MatrixUtil.findMSBSet = function (value /*int*/) {
        return 32 - Integer_1.default.numberOfLeadingZeros(value);
    };
    // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for "value" using polynomial "poly". The BCH
    // code is used for encoding type information and version information.
    // Example: Calculation of version information of 7.
    // f(x) is created from 7.
    //   - 7 = 000111 in 6 bits
    //   - f(x) = x^2 + x^1 + x^0
    // g(x) is given by the standard (p. 67)
    //   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1
    // Multiply f(x) by x^(18 - 6)
    //   - f'(x) = f(x) * x^(18 - 6)
    //   - f'(x) = x^14 + x^13 + x^12
    // Calculate the remainder of f'(x) / g(x)
    //         x^2
    //         __________________________________________________
    //   g(x) )x^14 + x^13 + x^12
    //         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2
    //         --------------------------------------------------
    //                              x^11 + x^10 + x^7 + x^4 + x^2
    //
    // The remainder is x^11 + x^10 + x^7 + x^4 + x^2
    // Encode it in binary: 110010010100
    // The return value is 0xc94 (1100 1001 0100)
    //
    // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit
    // operations. We don't care if coefficients are positive or negative.
    MatrixUtil.calculateBCHCode = function (value /*int*/, poly /*int*/) {
        if (poly === 0) {
            throw new IllegalArgumentException_1.default('0 polynomial');
        }
        // If poly is "1 1111 0010 0101" (version info poly), msbSetInPoly is 13. We'll subtract 1
        // from 13 to make it 12.
        var msbSetInPoly = MatrixUtil.findMSBSet(poly);
        value <<= msbSetInPoly - 1;
        // Do the division business using exclusive-or operations.
        while (MatrixUtil.findMSBSet(value) >= msbSetInPoly) {
            value ^= poly << (MatrixUtil.findMSBSet(value) - msbSetInPoly);
        }
        // Now the "value" is the remainder (i.e. the BCH code)
        return value;
    };
    // Make bit vector of type information. On success, store the result in "bits" and return true.
    // Encode error correction level and mask pattern. See 8.9 of
    // JISX0510:2004 (p.45) for details.
    MatrixUtil.makeTypeInfoBits = function (ecLevel, maskPattern /*int*/, bits) {
        if (!QRCode_1.default.isValidMaskPattern(maskPattern)) {
            throw new WriterException_1.default('Invalid mask pattern');
        }
        var typeInfo = (ecLevel.getBits() << 3) | maskPattern;
        bits.appendBits(typeInfo, 5);
        var bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);
        bits.appendBits(bchCode, 10);
        var maskBits = new BitArray_1.default();
        maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);
        bits.xor(maskBits);
        if (bits.getSize() !== 15) { // Just in case.
            throw new WriterException_1.default('should not happen but we got: ' + bits.getSize());
        }
    };
    // Make bit vector of version information. On success, store the result in "bits" and return true.
    // See 8.10 of JISX0510:2004 (p.45) for details.
    MatrixUtil.makeVersionInfoBits = function (version, bits) {
        bits.appendBits(version.getVersionNumber(), 6);
        var bchCode = MatrixUtil.calculateBCHCode(version.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);
        bits.appendBits(bchCode, 12);
        if (bits.getSize() !== 18) { // Just in case.
            throw new WriterException_1.default('should not happen but we got: ' + bits.getSize());
        }
    };
    // Check if "value" is empty.
    MatrixUtil.isEmpty = function (value /*int*/) {
        return value === 255; // -1
    };
    MatrixUtil.embedTimingPatterns = function (matrix) {
        // -8 is for skipping position detection patterns (7: size), and two horizontal/vertical
        // separation patterns (1: size). Thus, 8 = 7 + 1.
        for (var i = 8; i < matrix.getWidth() - 8; ++i) {
            var bit = (i + 1) % 2;
            // Horizontal line.
            if (MatrixUtil.isEmpty(matrix.get(i, 6))) {
                matrix.setNumber(i, 6, bit);
            }
            // Vertical line.
            if (MatrixUtil.isEmpty(matrix.get(6, i))) {
                matrix.setNumber(6, i, bit);
            }
        }
    };
    // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)
    MatrixUtil.embedDarkDotAtLeftBottomCorner = function (matrix) {
        if (matrix.get(8, matrix.getHeight() - 8) === 0) {
            throw new WriterException_1.default();
        }
        matrix.setNumber(8, matrix.getHeight() - 8, 1);
    };
    MatrixUtil.embedHorizontalSeparationPattern = function (xStart /*int*/, yStart /*int*/, matrix) {
        for (var x = 0; x < 8; ++x) {
            if (!MatrixUtil.isEmpty(matrix.get(xStart + x, yStart))) {
                throw new WriterException_1.default();
            }
            matrix.setNumber(xStart + x, yStart, 0);
        }
    };
    MatrixUtil.embedVerticalSeparationPattern = function (xStart /*int*/, yStart /*int*/, matrix) {
        for (var y = 0; y < 7; ++y) {
            if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y))) {
                throw new WriterException_1.default();
            }
            matrix.setNumber(xStart, yStart + y, 0);
        }
    };
    MatrixUtil.embedPositionAdjustmentPattern = function (xStart /*int*/, yStart /*int*/, matrix) {
        for (var y = 0; y < 5; ++y) {
            var patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y];
            for (var x = 0; x < 5; ++x) {
                matrix.setNumber(xStart + x, yStart + y, patternY[x]);
            }
        }
    };
    MatrixUtil.embedPositionDetectionPattern = function (xStart /*int*/, yStart /*int*/, matrix) {
        for (var y = 0; y < 7; ++y) {
            var patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y];
            for (var x = 0; x < 7; ++x) {
                matrix.setNumber(xStart + x, yStart + y, patternY[x]);
            }
        }
    };
    // Embed position detection patterns and surrounding vertical/horizontal separators.
    MatrixUtil.embedPositionDetectionPatternsAndSeparators = function (matrix) {
        // Embed three big squares at corners.
        var pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;
        // Left top corner.
        MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);
        // Right top corner.
        MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);
        // Left bottom corner.
        MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);
        // Embed horizontal separation patterns around the squares.
        var hspWidth = 8;
        // Left top corner.
        MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
        // Right top corner.
        MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);
        // Left bottom corner.
        MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);
        // Embed vertical separation patterns around the squares.
        var vspSize = 7;
        // Left top corner.
        MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);
        // Right top corner.
        MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);
        // Left bottom corner.
        MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);
    };
    // Embed position adjustment patterns if need be.
    MatrixUtil.maybeEmbedPositionAdjustmentPatterns = function (version, matrix) {
        if (version.getVersionNumber() < 2) { // The patterns appear if version >= 2
            return;
        }
        var index = version.getVersionNumber() - 1;
        var coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index];
        for (var i = 0, length_1 = coordinates.length; i !== length_1; i++) {
            var y = coordinates[i];
            if (y >= 0) {
                for (var j = 0; j !== length_1; j++) {
                    var x = coordinates[j];
                    if (x >= 0 && MatrixUtil.isEmpty(matrix.get(x, y))) {
                        // If the cell is unset, we embed the position adjustment pattern here.
                        // -2 is necessary since the x/y coordinates point to the center of the pattern, not the
                        // left top corner.
                        MatrixUtil.embedPositionAdjustmentPattern(x - 2, y - 2, matrix);
                    }
                }
            }
        }
    };
    MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([
        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
        Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
        Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
    ]);
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([
        Int32Array.from([1, 1, 1, 1, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 0, 1, 0, 1]),
        Int32Array.from([1, 0, 0, 0, 1]),
        Int32Array.from([1, 1, 1, 1, 1]),
    ]);
    // From Appendix E. Table 1, JIS0510X:2004 (71: p). The table was double-checked by komatsu.
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
        Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
        Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
        Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
        Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
        Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
        Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
        Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
        Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
        Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
        Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
        Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
        Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
        Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
        Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
        Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
        Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
        Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
        Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
        Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
        Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
        Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
        Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
        Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
        Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
        Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
        Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
        Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
        Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
        Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
        Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
        Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
        Int32Array.from([6, 30, 58, 86, 114, 142, 170]),
    ]);
    // Type info cells at the left top corner.
    MatrixUtil.TYPE_INFO_COORDINATES = Array.from([
        Int32Array.from([8, 0]),
        Int32Array.from([8, 1]),
        Int32Array.from([8, 2]),
        Int32Array.from([8, 3]),
        Int32Array.from([8, 4]),
        Int32Array.from([8, 5]),
        Int32Array.from([8, 7]),
        Int32Array.from([8, 8]),
        Int32Array.from([7, 8]),
        Int32Array.from([5, 8]),
        Int32Array.from([4, 8]),
        Int32Array.from([3, 8]),
        Int32Array.from([2, 8]),
        Int32Array.from([1, 8]),
        Int32Array.from([0, 8]),
    ]);
    // From Appendix D in JISX0510:2004 (p. 67)
    MatrixUtil.VERSION_INFO_POLY = 0x1f25; // 1 1111 0010 0101
    // From Appendix C in JISX0510:2004 (p.65).
    MatrixUtil.TYPE_INFO_POLY = 0x537;
    MatrixUtil.TYPE_INFO_MASK_PATTERN = 0x5412;
    return MatrixUtil;
}());
exports.default = MatrixUtil;
//# sourceMappingURL=MatrixUtil.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/QRCode.js":
/*!************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/qrcode/encoder/QRCode.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright 2008 ZXing authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var StringBuilder_1 = __webpack_require__(/*! ../../util/StringBuilder */ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js");
/**
 * @author satorux@google.com (Satoru Takabayashi) - creator
 * @author dswitkin@google.com (Daniel Switkin) - ported from C++
 */
var QRCode = /** @class */ (function () {
    function QRCode() {
        this.maskPattern = -1;
    }
    QRCode.prototype.getMode = function () {
        return this.mode;
    };
    QRCode.prototype.getECLevel = function () {
        return this.ecLevel;
    };
    QRCode.prototype.getVersion = function () {
        return this.version;
    };
    QRCode.prototype.getMaskPattern = function () {
        return this.maskPattern;
    };
    QRCode.prototype.getMatrix = function () {
        return this.matrix;
    };
    /*@Override*/
    QRCode.prototype.toString = function () {
        var result = new StringBuilder_1.default(); // (200)
        result.append('<<\n');
        result.append(' mode: ');
        result.append(this.mode ? this.mode.toString() : 'null');
        result.append('\n ecLevel: ');
        result.append(this.ecLevel ? this.ecLevel.toString() : 'null');
        result.append('\n version: ');
        result.append(this.version ? this.version.toString() : 'null');
        result.append('\n maskPattern: ');
        result.append(this.maskPattern.toString());
        if (this.matrix) {
            result.append('\n matrix:\n');
            result.append(this.matrix.toString());
        }
        else {
            result.append('\n matrix: null\n');
        }
        result.append('>>\n');
        return result.toString();
    };
    QRCode.prototype.setMode = function (value) {
        this.mode = value;
    };
    QRCode.prototype.setECLevel = function (value) {
        this.ecLevel = value;
    };
    QRCode.prototype.setVersion = function (version) {
        this.version = version;
    };
    QRCode.prototype.setMaskPattern = function (value /*int*/) {
        this.maskPattern = value;
    };
    QRCode.prototype.setMatrix = function (value) {
        this.matrix = value;
    };
    // Check if "mask_pattern" is valid.
    QRCode.isValidMaskPattern = function (maskPattern /*int*/) {
        return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;
    };
    QRCode.NUM_MASK_PATTERNS = 8;
    return QRCode;
}());
exports.default = QRCode;
//# sourceMappingURL=QRCode.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/util/Arrays.js":
/*!**************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/util/Arrays.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var System_1 = __webpack_require__(/*! ./System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
var ArrayIndexOutOfBoundsException_1 = __webpack_require__(/*! ../ArrayIndexOutOfBoundsException */ "./node_modules/@zxing/library/esm5/core/ArrayIndexOutOfBoundsException.js");
var Arrays = /** @class */ (function () {
    function Arrays() {
    }
    /**
     * Assigns the specified int value to each element of the specified array
     * of ints.
     *
     * @param a the array to be filled
     * @param val the value to be stored in all elements of the array
     */
    Arrays.fill = function (a, val) {
        for (var i = 0, len = a.length; i < len; i++)
            a[i] = val;
    };
    /**
     * Assigns the specified int value to each element of the specified
     * range of the specified array of ints.  The range to be filled
     * extends from index {@code fromIndex}, inclusive, to index
     * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
     * range to be filled is empty.)
     *
     * @param a the array to be filled
     * @param fromIndex the index of the first element (inclusive) to be
     *        filled with the specified value
     * @param toIndex the index of the last element (exclusive) to be
     *        filled with the specified value
     * @param val the value to be stored in all elements of the array
     * @throws IllegalArgumentException if {@code fromIndex > toIndex}
     * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or
     *         {@code toIndex > a.length}
     */
    Arrays.fillWithin = function (a, fromIndex, toIndex, val) {
        Arrays.rangeCheck(a.length, fromIndex, toIndex);
        for (var i = fromIndex; i < toIndex; i++)
            a[i] = val;
    };
    /**
     * Checks that {@code fromIndex} and {@code toIndex} are in
     * the range and throws an exception if they aren't.
     */
    Arrays.rangeCheck = function (arrayLength, fromIndex, toIndex) {
        if (fromIndex > toIndex) {
            throw new IllegalArgumentException_1.default('fromIndex(' + fromIndex + ') > toIndex(' + toIndex + ')');
        }
        if (fromIndex < 0) {
            throw new ArrayIndexOutOfBoundsException_1.default(fromIndex);
        }
        if (toIndex > arrayLength) {
            throw new ArrayIndexOutOfBoundsException_1.default(toIndex);
        }
    };
    Arrays.asList = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return args;
    };
    Arrays.create = function (rows, cols, value) {
        var arr = Array.from({ length: rows });
        return arr.map(function (x) { return Array.from({ length: cols }).fill(value); });
    };
    Arrays.createInt32Array = function (rows, cols, value) {
        var arr = Array.from({ length: rows });
        return arr.map(function (x) { return Int32Array.from({ length: cols }).fill(value); });
    };
    Arrays.equals = function (first, second) {
        if (!first) {
            return false;
        }
        if (!second) {
            return false;
        }
        if (!first.length) {
            return false;
        }
        if (!second.length) {
            return false;
        }
        if (first.length !== second.length) {
            return false;
        }
        for (var i = 0, length_1 = first.length; i < length_1; i++) {
            if (first[i] !== second[i]) {
                return false;
            }
        }
        return true;
    };
    Arrays.hashCode = function (a) {
        var e_1, _a;
        if (a === null) {
            return 0;
        }
        var result = 1;
        try {
            for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {
                var element = a_1_1.value;
                result = 31 * result + element;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return result;
    };
    Arrays.fillUint8Array = function (a, value) {
        for (var i = 0; i !== a.length; i++) {
            a[i] = value;
        }
    };
    Arrays.copyOf = function (original, newLength) {
        return original.slice(0, newLength);
    };
    Arrays.copyOfUint8Array = function (original, newLength) {
        if (original.length <= newLength) {
            var newArray = new Uint8Array(newLength);
            newArray.set(original);
            return newArray;
        }
        return original.slice(0, newLength);
    };
    Arrays.copyOfRange = function (original, from, to) {
        var newLength = to - from;
        var copy = new Int32Array(newLength);
        System_1.default.arraycopy(original, from, copy, 0, newLength);
        return copy;
    };
    /*
    * Returns the index of of the element in a sorted array or (-n-1) where n is the insertion point
    * for the new element.
    * Parameters:
    *     ar - A sorted array
    *     el - An element to search for
    *     comparator - A comparator function. The function takes two arguments: (a, b) and returns:
    *        a negative number  if a is less than b;
    *        0 if a is equal to b;
    *        a positive number of a is greater than b.
    * The array may contain duplicate elements. If there are more than one equal elements in the array,
    * the returned value can be the index of any one of the equal elements.
    *
    * http://jsfiddle.net/aryzhov/pkfst550/
    */
    Arrays.binarySearch = function (ar, el, comparator) {
        if (undefined === comparator) {
            comparator = Arrays.numberComparator;
        }
        var m = 0;
        var n = ar.length - 1;
        while (m <= n) {
            var k = (n + m) >> 1;
            var cmp = comparator(el, ar[k]);
            if (cmp > 0) {
                m = k + 1;
            }
            else if (cmp < 0) {
                n = k - 1;
            }
            else {
                return k;
            }
        }
        return -m - 1;
    };
    Arrays.numberComparator = function (a, b) {
        return a - b;
    };
    return Arrays;
}());
exports.default = Arrays;
//# sourceMappingURL=Arrays.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/util/ByteArrayOutputStream.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/util/ByteArrayOutputStream.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * Copyright (c) 1994, 2010, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
// package java.io;
// import java.util.Arrays;
var Arrays_1 = __webpack_require__(/*! ./Arrays */ "./node_modules/@zxing/library/esm5/core/util/Arrays.js");
var OutputStream_1 = __webpack_require__(/*! ./OutputStream */ "./node_modules/@zxing/library/esm5/core/util/OutputStream.js");
var Integer_1 = __webpack_require__(/*! ./Integer */ "./node_modules/@zxing/library/esm5/core/util/Integer.js");
var IllegalArgumentException_1 = __webpack_require__(/*! ../IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
var OutOfMemoryError_1 = __webpack_require__(/*! ../OutOfMemoryError */ "./node_modules/@zxing/library/esm5/core/OutOfMemoryError.js");
var System_1 = __webpack_require__(/*! ./System */ "./node_modules/@zxing/library/esm5/core/util/System.js");
var IndexOutOfBoundsException_1 = __webpack_require__(/*! ../IndexOutOfBoundsException */ "./node_modules/@zxing/library/esm5/core/IndexOutOfBoundsException.js");
/**
 * This class implements an output stream in which the data is
 * written into a byte array. The buffer automatically grows as data
 * is written to it.
 * The data can be retrieved using <code>toByteArray()</code> and
 * <code>toString()</code>.
 * <p>
 * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
 * this class can be called after the stream has been closed without
 * generating an <tt>IOException</tt>.
 *
 * @author  Arthur van Hoff
 * @since   JDK1.0
 */
var ByteArrayOutputStream = /** @class */ (function (_super) {
    __extends(ByteArrayOutputStream, _super);
    /**
     * Creates a new byte array output stream. The buffer capacity is
     * initially 32 bytes, though its size increases if necessary.
     */
    // public constructor() {
    //     this(32);
    // }
    /**
     * Creates a new byte array output stream, with a buffer capacity of
     * the specified size, in bytes.
     *
     * @param   size   the initial size.
     * @exception  IllegalArgumentException if size is negative.
     */
    function ByteArrayOutputStream(size) {
        if (size === void 0) { size = 32; }
        var _this = _super.call(this) || this;
        /**
         * The number of valid bytes in the buffer.
         */
        _this.count = 0;
        if (size < 0) {
            throw new IllegalArgumentException_1.default('Negative initial size: '
                + size);
        }
        _this.buf = new Uint8Array(size);
        return _this;
    }
    /**
     * Increases the capacity if necessary to ensure that it can hold
     * at least the number of elements specified by the minimum
     * capacity argument.
     *
     * @param minCapacity the desired minimum capacity
     * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is
     * interpreted as a request for the unsatisfiably large capacity
     * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.
     */
    ByteArrayOutputStream.prototype.ensureCapacity = function (minCapacity) {
        // overflow-conscious code
        if (minCapacity - this.buf.length > 0)
            this.grow(minCapacity);
    };
    /**
     * Increases the capacity to ensure that it can hold at least the
     * number of elements specified by the minimum capacity argument.
     *
     * @param minCapacity the desired minimum capacity
     */
    ByteArrayOutputStream.prototype.grow = function (minCapacity) {
        // overflow-conscious code
        var oldCapacity = this.buf.length;
        var newCapacity = oldCapacity << 1;
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity < 0) {
            if (minCapacity < 0) // overflow
                throw new OutOfMemoryError_1.default();
            newCapacity = Integer_1.default.MAX_VALUE;
        }
        this.buf = Arrays_1.default.copyOfUint8Array(this.buf, newCapacity);
    };
    /**
     * Writes the specified byte to this byte array output stream.
     *
     * @param   b   the byte to be written.
     */
    ByteArrayOutputStream.prototype.write = function (b) {
        this.ensureCapacity(this.count + 1);
        this.buf[this.count] = /*(byte)*/ b;
        this.count += 1;
    };
    /**
     * Writes <code>len</code> bytes from the specified byte array
     * starting at offset <code>off</code> to this byte array output stream.
     *
     * @param   b     the data.
     * @param   off   the start offset in the data.
     * @param   len   the number of bytes to write.
     */
    ByteArrayOutputStream.prototype.writeBytesOffset = function (b, off, len) {
        if ((off < 0) || (off > b.length) || (len < 0) ||
            ((off + len) - b.length > 0)) {
            throw new IndexOutOfBoundsException_1.default();
        }
        this.ensureCapacity(this.count + len);
        System_1.default.arraycopy(b, off, this.buf, this.count, len);
        this.count += len;
    };
    /**
     * Writes the complete contents of this byte array output stream to
     * the specified output stream argument, as if by calling the output
     * stream's write method using <code>out.write(buf, 0, count)</code>.
     *
     * @param      out   the output stream to which to write the data.
     * @exception  IOException  if an I/O error occurs.
     */
    ByteArrayOutputStream.prototype.writeTo = function (out) {
        out.writeBytesOffset(this.buf, 0, this.count);
    };
    /**
     * Resets the <code>count</code> field of this byte array output
     * stream to zero, so that all currently accumulated output in the
     * output stream is discarded. The output stream can be used again,
     * reusing the already allocated buffer space.
     *
     * @see     java.io.ByteArrayInputStream#count
     */
    ByteArrayOutputStream.prototype.reset = function () {
        this.count = 0;
    };
    /**
     * Creates a newly allocated byte array. Its size is the current
     * size of this output stream and the valid contents of the buffer
     * have been copied into it.
     *
     * @return  the current contents of this output stream, as a byte array.
     * @see     java.io.ByteArrayOutputStream#size()
     */
    ByteArrayOutputStream.prototype.toByteArray = function () {
        return Arrays_1.default.copyOfUint8Array(this.buf, this.count);
    };
    /**
     * Returns the current size of the buffer.
     *
     * @return  the value of the <code>count</code> field, which is the number
     *          of valid bytes in this output stream.
     * @see     java.io.ByteArrayOutputStream#count
     */
    ByteArrayOutputStream.prototype.size = function () {
        return this.count;
    };
    ByteArrayOutputStream.prototype.toString = function (param) {
        if (!param) {
            return this.toString_void();
        }
        if (typeof param === 'string') {
            return this.toString_string(param);
        }
        return this.toString_number(param);
    };
    /**
     * Converts the buffer's contents into a string decoding bytes using the
     * platform's default character set. The length of the new <tt>String</tt>
     * is a function of the character set, and hence may not be equal to the
     * size of the buffer.
     *
     * <p> This method always replaces malformed-input and unmappable-character
     * sequences with the default replacement string for the platform's
     * default character set. The {@linkplain java.nio.charset.CharsetDecoder}
     * class should be used when more control over the decoding process is
     * required.
     *
     * @return String decoded from the buffer's contents.
     * @since  JDK1.1
     */
    ByteArrayOutputStream.prototype.toString_void = function () {
        return new String(this.buf /*, 0, this.count*/).toString();
    };
    /**
     * Converts the buffer's contents into a string by decoding the bytes using
     * the specified {@link java.nio.charset.Charset charsetName}. The length of
     * the new <tt>String</tt> is a function of the charset, and hence may not be
     * equal to the length of the byte array.
     *
     * <p> This method always replaces malformed-input and unmappable-character
     * sequences with this charset's default replacement string. The {@link
     * java.nio.charset.CharsetDecoder} class should be used when more control
     * over the decoding process is required.
     *
     * @param  charsetName  the name of a supported
     *              {@linkplain java.nio.charset.Charset </code>charset<code>}
     * @return String decoded from the buffer's contents.
     * @exception  UnsupportedEncodingException
     *             If the named charset is not supported
     * @since   JDK1.1
     */
    ByteArrayOutputStream.prototype.toString_string = function (charsetName) {
        return new String(this.buf /*, 0, this.count, charsetName*/).toString();
    };
    /**
     * Creates a newly allocated string. Its size is the current size of
     * the output stream and the valid contents of the buffer have been
     * copied into it. Each character <i>c</i> in the resulting string is
     * constructed from the corresponding element <i>b</i> in the byte
     * array such that:
     * <blockquote><pre>
     *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
     * </pre></blockquote>
     *
     * @deprecated This method does not properly convert bytes into characters.
     * As of JDK&nbsp;1.1, the preferred way to do this is via the
     * <code>toString(String enc)</code> method, which takes an encoding-name
     * argument, or the <code>toString()</code> method, which uses the
     * platform's default character encoding.
     *
     * @param      hibyte    the high byte of each resulting Unicode character.
     * @return     the current contents of the output stream, as a string.
     * @see        java.io.ByteArrayOutputStream#size()
     * @see        java.io.ByteArrayOutputStream#toString(String)
     * @see        java.io.ByteArrayOutputStream#toString()
     */
    // @Deprecated
    ByteArrayOutputStream.prototype.toString_number = function (hibyte) {
        return new String(this.buf /*, hibyte, 0, this.count*/).toString();
    };
    /**
     * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
     * this class can be called after the stream has been closed without
     * generating an <tt>IOException</tt>.
     * <p>
     *
     * @throws IOException
     */
    ByteArrayOutputStream.prototype.close = function () {
    };
    return ByteArrayOutputStream;
}(OutputStream_1.default));
exports.default = ByteArrayOutputStream;
//# sourceMappingURL=ByteArrayOutputStream.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/util/Float.js":
/*!*************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/util/Float.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Ponyfill for Java's Float class.
 */
var Float = /** @class */ (function () {
    function Float() {
    }
    /**
     * SincTS has no difference between int and float, there's all numbers,
     * this is used only to polyfill Java code.
     */
    Float.floatToIntBits = function (f) {
        return f;
    };
    /**
     * The float max value in JS is the number max value.
     */
    Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;
    return Float;
}());
exports.default = Float;
//# sourceMappingURL=Float.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/util/Formatter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/util/Formatter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Java Formatter class polyfill that works in the JS way.
 */
var Formatter = /** @class */ (function () {
    function Formatter() {
        this.buffer = '';
    }
    /**
     *
     * @see https://stackoverflow.com/a/13439711/4367683
     *
     * @param str
     * @param arr
     */
    Formatter.form = function (str, arr) {
        var i = -1;
        function callback(exp, p0, p1, p2, p3, p4) {
            if (exp === '%%')
                return '%';
            if (arr[++i] === undefined)
                return undefined;
            exp = p2 ? parseInt(p2.substr(1)) : undefined;
            var base = p3 ? parseInt(p3.substr(1)) : undefined;
            var val;
            switch (p4) {
                case 's':
                    val = arr[i];
                    break;
                case 'c':
                    val = arr[i][0];
                    break;
                case 'f':
                    val = parseFloat(arr[i]).toFixed(exp);
                    break;
                case 'p':
                    val = parseFloat(arr[i]).toPrecision(exp);
                    break;
                case 'e':
                    val = parseFloat(arr[i]).toExponential(exp);
                    break;
                case 'x':
                    val = parseInt(arr[i]).toString(base ? base : 16);
                    break;
                case 'd':
                    val = parseFloat(parseInt(arr[i], base ? base : 10).toPrecision(exp)).toFixed(0);
                    break;
            }
            val = typeof val === 'object' ? JSON.stringify(val) : (+val).toString(base);
            var size = parseInt(p1); /* padding size */
            var ch = p1 && (p1[0] + '') === '0' ? '0' : ' '; /* isnull? */
            while (val.length < size)
                val = p0 !== undefined ? val + ch : ch + val; /* isminus? */
            return val;
        }
        var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
        return str.replace(regex, callback);
    };
    /**
     *
     * @param append The new string to append.
     * @param args Argumets values to be formated.
     */
    Formatter.prototype.format = function (append) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.buffer += Formatter.form(append, args);
    };
    /**
     * Returns the Formatter string value.
     */
    Formatter.prototype.toString = function () {
        return this.buffer;
    };
    return Formatter;
}());
exports.default = Formatter;
//# sourceMappingURL=Formatter.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/util/Integer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/util/Integer.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Ponyfill for Java's Integer class.
 */
var Integer = /** @class */ (function () {
    function Integer() {
    }
    Integer.numberOfTrailingZeros = function (i) {
        var y;
        if (i === 0)
            return 32;
        var n = 31;
        y = i << 16;
        if (y !== 0) {
            n -= 16;
            i = y;
        }
        y = i << 8;
        if (y !== 0) {
            n -= 8;
            i = y;
        }
        y = i << 4;
        if (y !== 0) {
            n -= 4;
            i = y;
        }
        y = i << 2;
        if (y !== 0) {
            n -= 2;
            i = y;
        }
        return n - ((i << 1) >>> 31);
    };
    Integer.numberOfLeadingZeros = function (i) {
        // HD, Figure 5-6
        if (i === 0) {
            return 32;
        }
        var n = 1;
        if (i >>> 16 === 0) {
            n += 16;
            i <<= 16;
        }
        if (i >>> 24 === 0) {
            n += 8;
            i <<= 8;
        }
        if (i >>> 28 === 0) {
            n += 4;
            i <<= 4;
        }
        if (i >>> 30 === 0) {
            n += 2;
            i <<= 2;
        }
        n -= i >>> 31;
        return n;
    };
    Integer.toHexString = function (i) {
        return i.toString(16);
    };
    Integer.toBinaryString = function (intNumber) {
        return String(parseInt(String(intNumber), 2));
    };
    // Returns the number of one-bits in the two's complement binary representation of the specified int value. This function is sometimes referred to as the population count.
    // Returns:
    // the number of one-bits in the two's complement binary representation of the specified int value.
    Integer.bitCount = function (i) {
        // HD, Figure 5-2
        i = i - ((i >>> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
        i = (i + (i >>> 4)) & 0x0f0f0f0f;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 0x3f;
    };
    Integer.truncDivision = function (dividend, divisor) {
        return Math.trunc(dividend / divisor);
    };
    /**
     * Converts A string to an integer.
     * @param s A string to convert into a number.
     * @param radix A value between 2 and 36 that specifies the base of the number in numString. If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal. All other strings are considered decimal.
     */
    Integer.parseInt = function (num, radix) {
        if (radix === void 0) { radix = undefined; }
        return parseInt(num, radix);
    };
    Integer.MIN_VALUE_32_BITS = -2147483648;
    Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;
    return Integer;
}());
exports.default = Integer;
//# sourceMappingURL=Integer.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/util/Long.js":
/*!************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/util/Long.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Ponyfill for Java's Long class.
 */
var Long = /** @class */ (function () {
    function Long() {
    }
    /**
     * Parses a string to a number, since JS has no really Int64.
     *
     * @param num Numeric string.
     * @param radix Destination radix.
     */
    Long.parseLong = function (num, radix) {
        if (radix === void 0) { radix = undefined; }
        return parseInt(num, radix);
    };
    return Long;
}());
exports.default = Long;
//# sourceMappingURL=Long.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/util/OutputStream.js":
/*!********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/util/OutputStream.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var IndexOutOfBoundsException_1 = __webpack_require__(/*! ../IndexOutOfBoundsException */ "./node_modules/@zxing/library/esm5/core/IndexOutOfBoundsException.js");
var NullPointerException_1 = __webpack_require__(/*! ../NullPointerException */ "./node_modules/@zxing/library/esm5/core/NullPointerException.js");
/*
 * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
// package java.io;
/**
 * This abstract class is the superclass of all classes representing
 * an output stream of bytes. An output stream accepts output bytes
 * and sends them to some sink.
 * <p>
 * Applications that need to define a subclass of
 * <code>OutputStream</code> must always provide at least a method
 * that writes one byte of output.
 *
 * @author  Arthur van Hoff
 * @see     java.io.BufferedOutputStream
 * @see     java.io.ByteArrayOutputStream
 * @see     java.io.DataOutputStream
 * @see     java.io.FilterOutputStream
 * @see     java.io.InputStream
 * @see     java.io.OutputStream#write(int)
 * @since   JDK1.0
 */
var OutputStream /*implements Closeable, Flushable*/ = /** @class */ (function () {
    function OutputStream() {
    }
    /**
     * Writes <code>b.length</code> bytes from the specified byte array
     * to this output stream. The general contract for <code>write(b)</code>
     * is that it should have exactly the same effect as the call
     * <code>write(b, 0, b.length)</code>.
     *
     * @param      b   the data.
     * @exception  IOException  if an I/O error occurs.
     * @see        java.io.OutputStream#write(byte[], int, int)
     */
    OutputStream.prototype.writeBytes = function (b) {
        this.writeBytesOffset(b, 0, b.length);
    };
    /**
     * Writes <code>len</code> bytes from the specified byte array
     * starting at offset <code>off</code> to this output stream.
     * The general contract for <code>write(b, off, len)</code> is that
     * some of the bytes in the array <code>b</code> are written to the
     * output stream in order; element <code>b[off]</code> is the first
     * byte written and <code>b[off+len-1]</code> is the last byte written
     * by this operation.
     * <p>
     * The <code>write</code> method of <code>OutputStream</code> calls
     * the write method of one argument on each of the bytes to be
     * written out. Subclasses are encouraged to override this method and
     * provide a more efficient implementation.
     * <p>
     * If <code>b</code> is <code>null</code>, a
     * <code>NullPointerException</code> is thrown.
     * <p>
     * If <code>off</code> is negative, or <code>len</code> is negative, or
     * <code>off+len</code> is greater than the length of the array
     * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.
     *
     * @param      b     the data.
     * @param      off   the start offset in the data.
     * @param      len   the number of bytes to write.
     * @exception  IOException  if an I/O error occurs. In particular,
     *             an <code>IOException</code> is thrown if the output
     *             stream is closed.
     */
    OutputStream.prototype.writeBytesOffset = function (b, off, len) {
        if (b == null) {
            throw new NullPointerException_1.default();
        }
        else if ((off < 0) || (off > b.length) || (len < 0) ||
            ((off + len) > b.length) || ((off + len) < 0)) {
            throw new IndexOutOfBoundsException_1.default();
        }
        else if (len === 0) {
            return;
        }
        for (var i = 0; i < len; i++) {
            this.write(b[off + i]);
        }
    };
    /**
     * Flushes this output stream and forces any buffered output bytes
     * to be written out. The general contract of <code>flush</code> is
     * that calling it is an indication that, if any bytes previously
     * written have been buffered by the implementation of the output
     * stream, such bytes should immediately be written to their
     * intended destination.
     * <p>
     * If the intended destination of this stream is an abstraction provided by
     * the underlying operating system, for example a file, then flushing the
     * stream guarantees only that bytes previously written to the stream are
     * passed to the operating system for writing; it does not guarantee that
     * they are actually written to a physical device such as a disk drive.
     * <p>
     * The <code>flush</code> method of <code>OutputStream</code> does nothing.
     *
     * @exception  IOException  if an I/O error occurs.
     */
    OutputStream.prototype.flush = function () {
    };
    /**
     * Closes this output stream and releases any system resources
     * associated with this stream. The general contract of <code>close</code>
     * is that it closes the output stream. A closed stream cannot perform
     * output operations and cannot be reopened.
     * <p>
     * The <code>close</code> method of <code>OutputStream</code> does nothing.
     *
     * @exception  IOException  if an I/O error occurs.
     */
    OutputStream.prototype.close = function () {
    };
    return OutputStream;
}());
exports.default = OutputStream;
//# sourceMappingURL=OutputStream.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/util/StringBuilder.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/util/StringBuilder.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var StringUtils_1 = __webpack_require__(/*! ../common/StringUtils */ "./node_modules/@zxing/library/esm5/core/common/StringUtils.js");
var StringBuilder = /** @class */ (function () {
    function StringBuilder(value) {
        if (value === void 0) { value = ''; }
        this.value = value;
    }
    StringBuilder.prototype.enableDecoding = function (encoding) {
        this.encoding = encoding;
        return this;
    };
    StringBuilder.prototype.append = function (s) {
        if (typeof s === 'string') {
            this.value += s.toString();
        }
        else if (this.encoding) {
            // use passed format (fromCharCode will return UTF8 encoding)
            this.value += StringUtils_1.default.castAsNonUtf8Char(s, this.encoding);
        }
        else {
            // correctly converts from UTF-8, but not other encodings
            this.value += String.fromCharCode(s);
        }
        return this;
    };
    StringBuilder.prototype.length = function () {
        return this.value.length;
    };
    StringBuilder.prototype.charAt = function (n) {
        return this.value.charAt(n);
    };
    StringBuilder.prototype.deleteCharAt = function (n) {
        this.value = this.value.substr(0, n) + this.value.substring(n + 1);
    };
    StringBuilder.prototype.setCharAt = function (n, c) {
        this.value = this.value.substr(0, n) + c + this.value.substr(n + 1);
    };
    StringBuilder.prototype.substring = function (start, end) {
        return this.value.substring(start, end);
    };
    /**
     * @note helper method for RSS Expanded
     */
    StringBuilder.prototype.setLengthToZero = function () {
        this.value = "";
    };
    StringBuilder.prototype.toString = function () {
        return this.value;
    };
    StringBuilder.prototype.insert = function (n, c) {
        this.value = this.value.substr(0, n) + c + this.value.substr(n + c.length);
    };
    return StringBuilder;
}());
exports.default = StringBuilder;
//# sourceMappingURL=StringBuilder.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/util/StringEncoding.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/util/StringEncoding.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var UnsupportedOperationException_1 = __webpack_require__(/*! ../UnsupportedOperationException */ "./node_modules/@zxing/library/esm5/core/UnsupportedOperationException.js");
var CharacterSetECI_1 = __webpack_require__(/*! ../common/CharacterSetECI */ "./node_modules/@zxing/library/esm5/core/common/CharacterSetECI.js");
/**
 * Responsible for en/decoding strings.
 */
var StringEncoding = /** @class */ (function () {
    function StringEncoding() {
    }
    /**
     * Decodes some Uint8Array to a string format.
     */
    StringEncoding.decode = function (bytes, encoding) {
        var encodingName = this.encodingName(encoding);
        if (this.customDecoder) {
            return this.customDecoder(bytes, encodingName);
        }
        // Increases browser support.
        if (typeof TextDecoder === 'undefined' || this.shouldDecodeOnFallback(encodingName)) {
            return this.decodeFallback(bytes, encodingName);
        }
        return new TextDecoder(encodingName).decode(bytes);
    };
    /**
     * Checks if the decoding method should use the fallback for decoding
     * once Node TextDecoder doesn't support all encoding formats.
     *
     * @param encodingName
     */
    StringEncoding.shouldDecodeOnFallback = function (encodingName) {
        return !StringEncoding.isBrowser() && encodingName === 'ISO-8859-1';
    };
    /**
     * Encodes some string into a Uint8Array.
     */
    StringEncoding.encode = function (s, encoding) {
        var encodingName = this.encodingName(encoding);
        if (this.customEncoder) {
            return this.customEncoder(s, encodingName);
        }
        // Increases browser support.
        if (typeof TextEncoder === 'undefined') {
            return this.encodeFallback(s);
        }
        // TextEncoder only encodes to UTF8 by default as specified by encoding.spec.whatwg.org
        return new TextEncoder().encode(s);
    };
    StringEncoding.isBrowser = function () {
        return (typeof window !== 'undefined' && {}.toString.call(window) === '[object Window]');
    };
    /**
     * Returns the string value from some encoding character set.
     */
    StringEncoding.encodingName = function (encoding) {
        return typeof encoding === 'string'
            ? encoding
            : encoding.getName();
    };
    /**
     * Returns character set from some encoding character set.
     */
    StringEncoding.encodingCharacterSet = function (encoding) {
        if (encoding instanceof CharacterSetECI_1.default) {
            return encoding;
        }
        return CharacterSetECI_1.default.getCharacterSetECIByName(encoding);
    };
    /**
     * Runs a fallback for the native decoding funcion.
     */
    StringEncoding.decodeFallback = function (bytes, encoding) {
        var characterSet = this.encodingCharacterSet(encoding);
        if (StringEncoding.isDecodeFallbackSupported(characterSet)) {
            var s = '';
            for (var i = 0, length_1 = bytes.length; i < length_1; i++) {
                var h = bytes[i].toString(16);
                if (h.length < 2) {
                    h = '0' + h;
                }
                s += '%' + h;
            }
            return decodeURIComponent(s);
        }
        if (characterSet.equals(CharacterSetECI_1.default.UnicodeBigUnmarked)) {
            return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
        }
        throw new UnsupportedOperationException_1.default("Encoding " + this.encodingName(encoding) + " not supported by fallback.");
    };
    StringEncoding.isDecodeFallbackSupported = function (characterSet) {
        return characterSet.equals(CharacterSetECI_1.default.UTF8) ||
            characterSet.equals(CharacterSetECI_1.default.ISO8859_1) ||
            characterSet.equals(CharacterSetECI_1.default.ASCII);
    };
    /**
     * Runs a fallback for the native encoding funcion.
     *
     * @see https://stackoverflow.com/a/17192845/4367683
     */
    StringEncoding.encodeFallback = function (s) {
        var encodedURIstring = btoa(unescape(encodeURIComponent(s)));
        var charList = encodedURIstring.split('');
        var uintArray = [];
        for (var i = 0; i < charList.length; i++) {
            uintArray.push(charList[i].charCodeAt(0));
        }
        return new Uint8Array(uintArray);
    };
    return StringEncoding;
}());
exports.default = StringEncoding;
//# sourceMappingURL=StringEncoding.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/core/util/System.js":
/*!**************************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/core/util/System.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var System = /** @class */ (function () {
    function System() {
    }
    // public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
    /**
     * Makes a copy of a array.
     */
    System.arraycopy = function (src, srcPos, dest, destPos, length) {
        // TODO: better use split or set?
        while (length--) {
            dest[destPos++] = src[srcPos++];
        }
    };
    /**
     * Returns the current time in milliseconds.
     */
    System.currentTimeMillis = function () {
        return Date.now();
    };
    return System;
}());
exports.default = System;
//# sourceMappingURL=System.js.map

/***/ }),

/***/ "./node_modules/@zxing/library/esm5/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@zxing/library/esm5/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./browser */ "./node_modules/@zxing/library/esm5/browser.js"));
// Exceptions
var ArgumentException_1 = __webpack_require__(/*! ./core/ArgumentException */ "./node_modules/@zxing/library/esm5/core/ArgumentException.js");
exports.ArgumentException = ArgumentException_1.default;
var ArithmeticException_1 = __webpack_require__(/*! ./core/ArithmeticException */ "./node_modules/@zxing/library/esm5/core/ArithmeticException.js");
exports.ArithmeticException = ArithmeticException_1.default;
var ChecksumException_1 = __webpack_require__(/*! ./core/ChecksumException */ "./node_modules/@zxing/library/esm5/core/ChecksumException.js");
exports.ChecksumException = ChecksumException_1.default;
var Exception_1 = __webpack_require__(/*! ./core/Exception */ "./node_modules/@zxing/library/esm5/core/Exception.js");
exports.Exception = Exception_1.default;
var FormatException_1 = __webpack_require__(/*! ./core/FormatException */ "./node_modules/@zxing/library/esm5/core/FormatException.js");
exports.FormatException = FormatException_1.default;
var IllegalArgumentException_1 = __webpack_require__(/*! ./core/IllegalArgumentException */ "./node_modules/@zxing/library/esm5/core/IllegalArgumentException.js");
exports.IllegalArgumentException = IllegalArgumentException_1.default;
var IllegalStateException_1 = __webpack_require__(/*! ./core/IllegalStateException */ "./node_modules/@zxing/library/esm5/core/IllegalStateException.js");
exports.IllegalStateException = IllegalStateException_1.default;
var NotFoundException_1 = __webpack_require__(/*! ./core/NotFoundException */ "./node_modules/@zxing/library/esm5/core/NotFoundException.js");
exports.NotFoundException = NotFoundException_1.default;
var ReaderException_1 = __webpack_require__(/*! ./core/ReaderException */ "./node_modules/@zxing/library/esm5/core/ReaderException.js");
exports.ReaderException = ReaderException_1.default;
var ReedSolomonException_1 = __webpack_require__(/*! ./core/ReedSolomonException */ "./node_modules/@zxing/library/esm5/core/ReedSolomonException.js");
exports.ReedSolomonException = ReedSolomonException_1.default;
var UnsupportedOperationException_1 = __webpack_require__(/*! ./core/UnsupportedOperationException */ "./node_modules/@zxing/library/esm5/core/UnsupportedOperationException.js");
exports.UnsupportedOperationException = UnsupportedOperationException_1.default;
var WriterException_1 = __webpack_require__(/*! ./core/WriterException */ "./node_modules/@zxing/library/esm5/core/WriterException.js");
exports.WriterException = WriterException_1.default;
// core
var BarcodeFormat_1 = __webpack_require__(/*! ./core/BarcodeFormat */ "./node_modules/@zxing/library/esm5/core/BarcodeFormat.js");
exports.BarcodeFormat = BarcodeFormat_1.default;
var Binarizer_1 = __webpack_require__(/*! ./core/Binarizer */ "./node_modules/@zxing/library/esm5/core/Binarizer.js");
exports.Binarizer = Binarizer_1.default;
var BinaryBitmap_1 = __webpack_require__(/*! ./core/BinaryBitmap */ "./node_modules/@zxing/library/esm5/core/BinaryBitmap.js");
exports.BinaryBitmap = BinaryBitmap_1.default;
var DecodeHintType_1 = __webpack_require__(/*! ./core/DecodeHintType */ "./node_modules/@zxing/library/esm5/core/DecodeHintType.js");
exports.DecodeHintType = DecodeHintType_1.default;
var InvertedLuminanceSource_1 = __webpack_require__(/*! ./core/InvertedLuminanceSource */ "./node_modules/@zxing/library/esm5/core/InvertedLuminanceSource.js");
exports.InvertedLuminanceSource = InvertedLuminanceSource_1.default;
var LuminanceSource_1 = __webpack_require__(/*! ./core/LuminanceSource */ "./node_modules/@zxing/library/esm5/core/LuminanceSource.js");
exports.LuminanceSource = LuminanceSource_1.default;
var MultiFormatReader_1 = __webpack_require__(/*! ./core/MultiFormatReader */ "./node_modules/@zxing/library/esm5/core/MultiFormatReader.js");
exports.MultiFormatReader = MultiFormatReader_1.default;
var MultiFormatWriter_1 = __webpack_require__(/*! ./core/MultiFormatWriter */ "./node_modules/@zxing/library/esm5/core/MultiFormatWriter.js");
exports.MultiFormatWriter = MultiFormatWriter_1.default;
var PlanarYUVLuminanceSource_1 = __webpack_require__(/*! ./core/PlanarYUVLuminanceSource */ "./node_modules/@zxing/library/esm5/core/PlanarYUVLuminanceSource.js");
exports.PlanarYUVLuminanceSource = PlanarYUVLuminanceSource_1.default;
var Result_1 = __webpack_require__(/*! ./core/Result */ "./node_modules/@zxing/library/esm5/core/Result.js");
exports.Result = Result_1.default;
var ResultMetadataType_1 = __webpack_require__(/*! ./core/ResultMetadataType */ "./node_modules/@zxing/library/esm5/core/ResultMetadataType.js");
exports.ResultMetadataType = ResultMetadataType_1.default;
var RGBLuminanceSource_1 = __webpack_require__(/*! ./core/RGBLuminanceSource */ "./node_modules/@zxing/library/esm5/core/RGBLuminanceSource.js");
exports.RGBLuminanceSource = RGBLuminanceSource_1.default;
// core/common
var BitArray_1 = __webpack_require__(/*! ./core/common/BitArray */ "./node_modules/@zxing/library/esm5/core/common/BitArray.js");
exports.BitArray = BitArray_1.default;
var BitMatrix_1 = __webpack_require__(/*! ./core/common/BitMatrix */ "./node_modules/@zxing/library/esm5/core/common/BitMatrix.js");
exports.BitMatrix = BitMatrix_1.default;
var BitSource_1 = __webpack_require__(/*! ./core/common/BitSource */ "./node_modules/@zxing/library/esm5/core/common/BitSource.js");
exports.BitSource = BitSource_1.default;
var CharacterSetECI_1 = __webpack_require__(/*! ./core/common/CharacterSetECI */ "./node_modules/@zxing/library/esm5/core/common/CharacterSetECI.js");
exports.CharacterSetECI = CharacterSetECI_1.default;
var DecoderResult_1 = __webpack_require__(/*! ./core/common/DecoderResult */ "./node_modules/@zxing/library/esm5/core/common/DecoderResult.js");
exports.DecoderResult = DecoderResult_1.default;
var DefaultGridSampler_1 = __webpack_require__(/*! ./core/common/DefaultGridSampler */ "./node_modules/@zxing/library/esm5/core/common/DefaultGridSampler.js");
exports.DefaultGridSampler = DefaultGridSampler_1.default;
var DetectorResult_1 = __webpack_require__(/*! ./core/common/DetectorResult */ "./node_modules/@zxing/library/esm5/core/common/DetectorResult.js");
exports.DetectorResult = DetectorResult_1.default;
var EncodeHintType_1 = __webpack_require__(/*! ./core/EncodeHintType */ "./node_modules/@zxing/library/esm5/core/EncodeHintType.js");
exports.EncodeHintType = EncodeHintType_1.default;
var GlobalHistogramBinarizer_1 = __webpack_require__(/*! ./core/common/GlobalHistogramBinarizer */ "./node_modules/@zxing/library/esm5/core/common/GlobalHistogramBinarizer.js");
exports.GlobalHistogramBinarizer = GlobalHistogramBinarizer_1.default;
var GridSampler_1 = __webpack_require__(/*! ./core/common/GridSampler */ "./node_modules/@zxing/library/esm5/core/common/GridSampler.js");
exports.GridSampler = GridSampler_1.default;
var GridSamplerInstance_1 = __webpack_require__(/*! ./core/common/GridSamplerInstance */ "./node_modules/@zxing/library/esm5/core/common/GridSamplerInstance.js");
exports.GridSamplerInstance = GridSamplerInstance_1.default;
var HybridBinarizer_1 = __webpack_require__(/*! ./core/common/HybridBinarizer */ "./node_modules/@zxing/library/esm5/core/common/HybridBinarizer.js");
exports.HybridBinarizer = HybridBinarizer_1.default;
var PerspectiveTransform_1 = __webpack_require__(/*! ./core/common/PerspectiveTransform */ "./node_modules/@zxing/library/esm5/core/common/PerspectiveTransform.js");
exports.PerspectiveTransform = PerspectiveTransform_1.default;
var StringUtils_1 = __webpack_require__(/*! ./core/common/StringUtils */ "./node_modules/@zxing/library/esm5/core/common/StringUtils.js");
exports.StringUtils = StringUtils_1.default;
// core/common/detector
var MathUtils_1 = __webpack_require__(/*! ./core/common/detector/MathUtils */ "./node_modules/@zxing/library/esm5/core/common/detector/MathUtils.js");
exports.MathUtils = MathUtils_1.default;
// export { default as MonochromeRectangleDetector } from './core/common/detector/MonochromeRectangleDetector';
var WhiteRectangleDetector_1 = __webpack_require__(/*! ./core/common/detector/WhiteRectangleDetector */ "./node_modules/@zxing/library/esm5/core/common/detector/WhiteRectangleDetector.js");
exports.WhiteRectangleDetector = WhiteRectangleDetector_1.default;
// core/common/reedsolomon
var GenericGF_1 = __webpack_require__(/*! ./core/common/reedsolomon/GenericGF */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGF.js");
exports.GenericGF = GenericGF_1.default;
var GenericGFPoly_1 = __webpack_require__(/*! ./core/common/reedsolomon/GenericGFPoly */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/GenericGFPoly.js");
exports.GenericGFPoly = GenericGFPoly_1.default;
var ReedSolomonDecoder_1 = __webpack_require__(/*! ./core/common/reedsolomon/ReedSolomonDecoder */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/ReedSolomonDecoder.js");
exports.ReedSolomonDecoder = ReedSolomonDecoder_1.default;
var ReedSolomonEncoder_1 = __webpack_require__(/*! ./core/common/reedsolomon/ReedSolomonEncoder */ "./node_modules/@zxing/library/esm5/core/common/reedsolomon/ReedSolomonEncoder.js");
exports.ReedSolomonEncoder = ReedSolomonEncoder_1.default;
// core/datamatrix
var DataMatrixReader_1 = __webpack_require__(/*! ./core/datamatrix/DataMatrixReader */ "./node_modules/@zxing/library/esm5/core/datamatrix/DataMatrixReader.js");
exports.DataMatrixReader = DataMatrixReader_1.default;
// core/twod/qrcode
var QRCodeReader_1 = __webpack_require__(/*! ./core/qrcode/QRCodeReader */ "./node_modules/@zxing/library/esm5/core/qrcode/QRCodeReader.js");
exports.QRCodeReader = QRCodeReader_1.default;
var QRCodeWriter_1 = __webpack_require__(/*! ./core/qrcode/QRCodeWriter */ "./node_modules/@zxing/library/esm5/core/qrcode/QRCodeWriter.js");
exports.QRCodeWriter = QRCodeWriter_1.default;
var ErrorCorrectionLevel_1 = __webpack_require__(/*! ./core/qrcode/decoder/ErrorCorrectionLevel */ "./node_modules/@zxing/library/esm5/core/qrcode/decoder/ErrorCorrectionLevel.js");
exports.QRCodeDecoderErrorCorrectionLevel = ErrorCorrectionLevel_1.default;
var Encoder_1 = __webpack_require__(/*! ./core/qrcode/encoder/Encoder */ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/Encoder.js");
exports.QRCodeEncoder = Encoder_1.default;
var QRCode_1 = __webpack_require__(/*! ./core/qrcode/encoder/QRCode */ "./node_modules/@zxing/library/esm5/core/qrcode/encoder/QRCode.js");
exports.QRCodeEncoderQRCode = QRCode_1.default;
// core/twod/aztec
var AztecReader_1 = __webpack_require__(/*! ./core/aztec/AztecReader */ "./node_modules/@zxing/library/esm5/core/aztec/AztecReader.js");
exports.AztecCodeReader = AztecReader_1.default;
// core/oned
var OneDReader_1 = __webpack_require__(/*! ./core/oned/OneDReader */ "./node_modules/@zxing/library/esm5/core/oned/OneDReader.js");
exports.OneDReader = OneDReader_1.default;
var EAN13Reader_1 = __webpack_require__(/*! ./core/oned/EAN13Reader */ "./node_modules/@zxing/library/esm5/core/oned/EAN13Reader.js");
exports.EAN13Reader = EAN13Reader_1.default;
var Code128Reader_1 = __webpack_require__(/*! ./core/oned/Code128Reader */ "./node_modules/@zxing/library/esm5/core/oned/Code128Reader.js");
exports.Code128Reader = Code128Reader_1.default;
var ITFReader_1 = __webpack_require__(/*! ./core/oned/ITFReader */ "./node_modules/@zxing/library/esm5/core/oned/ITFReader.js");
exports.ITFReader = ITFReader_1.default;
var Code39Reader_1 = __webpack_require__(/*! ./core/oned/Code39Reader */ "./node_modules/@zxing/library/esm5/core/oned/Code39Reader.js");
exports.Code39Reader = Code39Reader_1.default;
var RSS14Reader_1 = __webpack_require__(/*! ./core/oned/rss/RSS14Reader */ "./node_modules/@zxing/library/esm5/core/oned/rss/RSS14Reader.js");
exports.RSS14Reader = RSS14Reader_1.default;
var RSSExpandedReader_1 = __webpack_require__(/*! ./core/oned/rss/expanded/RSSExpandedReader */ "./node_modules/@zxing/library/esm5/core/oned/rss/expanded/RSSExpandedReader.js");
exports.RSSExpandedReader = RSSExpandedReader_1.default;
var MultiFormatOneDReader_1 = __webpack_require__(/*! ./core/oned/MultiFormatOneDReader */ "./node_modules/@zxing/library/esm5/core/oned/MultiFormatOneDReader.js");
exports.MultiformatReader = MultiFormatOneDReader_1.default;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/react-qr-barcode-scanner/dist/BarcodeScannerComponent.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/react-qr-barcode-scanner/dist/BarcodeScannerComponent.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
const library_1 = __webpack_require__(/*! @zxing/library */ "./node_modules/@zxing/library/esm5/index.js");
const react_webcam_1 = __importDefault(__webpack_require__(/*! react-webcam */ "./node_modules/react-webcam/dist/react-webcam.js"));
const BarcodeScannerComponent = ({ onUpdate, onError, width = "100%", height = "100%", facingMode = "environment", torch, delay = 500, videoConstraints, stopStream, }) => {
    const webcamRef = react_1.default.useRef(null);
    const capture = react_1.default.useCallback(() => {
        var _a;
        const codeReader = new library_1.BrowserMultiFormatReader();
        const imageSrc = (_a = webcamRef === null || webcamRef === void 0 ? void 0 : webcamRef.current) === null || _a === void 0 ? void 0 : _a.getScreenshot();
        if (imageSrc) {
            codeReader
                .decodeFromImage(undefined, imageSrc)
                .then((result) => {
                onUpdate(null, result);
            })
                .catch((err) => {
                onUpdate(err);
            });
        }
    }, [onUpdate]);
    react_1.default.useEffect(() => {
        var _a, _b;
        // Turn on the flashlight if prop is defined and device has the capability
        if (typeof torch === "boolean" && ((_a = 
        // @ts-ignore
        navigator === null || 
        // @ts-ignore
        navigator === void 0 ? void 0 : 
        // @ts-ignore
        navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getSupportedConstraints().torch)) {
            const stream = (_b = webcamRef === null || webcamRef === void 0 ? void 0 : webcamRef.current) === null || _b === void 0 ? void 0 : _b.video.srcObject;
            const track = stream === null || stream === void 0 ? void 0 : stream.getVideoTracks()[0]; // get the active track of the stream
            if (track &&
                track.getCapabilities().torch &&
                !track.getConstraints().torch) {
                track
                    .applyConstraints({
                    advanced: [{ torch }],
                })
                    .catch((err) => onUpdate(err));
            }
        }
    }, [torch, onUpdate]);
    react_1.default.useEffect(() => {
        var _a;
        if (stopStream) {
            let stream = (_a = webcamRef === null || webcamRef === void 0 ? void 0 : webcamRef.current) === null || _a === void 0 ? void 0 : _a.video.srcObject;
            if (stream) {
                stream.getTracks().forEach((track) => {
                    stream.removeTrack(track);
                    track.stop();
                });
                stream = null;
            }
        }
    }, [stopStream]);
    react_1.default.useEffect(() => {
        const interval = setInterval(capture, delay);
        return () => {
            clearInterval(interval);
        };
    }, []);
    return (react_1.default.createElement(react_webcam_1.default, { width: width, height: height, ref: webcamRef, screenshotFormat: "image/jpeg", videoConstraints: videoConstraints || {
            facingMode,
        }, audio: false, onUserMediaError: onError }));
};
exports.default = BarcodeScannerComponent;


/***/ }),

/***/ "./node_modules/react-qr-barcode-scanner/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-qr-barcode-scanner/dist/index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BarcodeScannerComponent_1 = __importDefault(__webpack_require__(/*! ./BarcodeScannerComponent */ "./node_modules/react-qr-barcode-scanner/dist/BarcodeScannerComponent.js"));
exports.default = BarcodeScannerComponent_1.default;


/***/ }),

/***/ "./node_modules/react-webcam/dist/react-webcam.js":
/*!********************************************************!*\
  !*** ./node_modules/react-webcam/dist/react-webcam.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! react */ "./node_modules/react/index.js"));
	else {}
})(this, function(__WEBPACK_EXTERNAL_MODULE_react__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/react-webcam.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/react-webcam.tsx":
/*!******************************!*\
  !*** ./src/react-webcam.tsx ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};

// polyfill based on https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
(function polyfillGetUserMedia() {
    if (typeof window === 'undefined') {
        return;
    }
    // Older browsers might not implement mediaDevices at all, so we set an empty object first
    if (navigator.mediaDevices === undefined) {
        navigator.mediaDevices = {};
    }
    // Some browsers partially implement mediaDevices. We can't just assign an object
    // with getUserMedia as it would overwrite existing properties.
    // Here, we will just add the getUserMedia property if it's missing.
    if (navigator.mediaDevices.getUserMedia === undefined) {
        navigator.mediaDevices.getUserMedia = function (constraints) {
            // First get ahold of the legacy getUserMedia, if present
            var getUserMedia = navigator.getUserMedia ||
                navigator.webkitGetUserMedia ||
                navigator.mozGetUserMedia ||
                navigator.msGetUserMedia;
            // Some browsers just don't implement it - return a rejected promise with an error
            // to keep a consistent interface
            if (!getUserMedia) {
                return Promise.reject(new Error("getUserMedia is not implemented in this browser"));
            }
            // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise
            return new Promise(function (resolve, reject) {
                getUserMedia.call(navigator, constraints, resolve, reject);
            });
        };
    }
})();
function hasGetUserMedia() {
    return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
}
var Webcam = /** @class */ (function (_super) {
    __extends(Webcam, _super);
    function Webcam(props) {
        var _this = _super.call(this, props) || this;
        _this.canvas = null;
        _this.ctx = null;
        _this.unmounted = false;
        _this.state = {
            hasUserMedia: false
        };
        return _this;
    }
    Webcam.prototype.componentDidMount = function () {
        var _a = this, state = _a.state, props = _a.props;
        if (!hasGetUserMedia()) {
            props.onUserMediaError("getUserMedia not supported");
            return;
        }
        if (!state.hasUserMedia) {
            this.requestUserMedia();
        }
    };
    Webcam.prototype.componentDidUpdate = function (nextProps) {
        var props = this.props;
        if (!hasGetUserMedia()) {
            props.onUserMediaError("getUserMedia not supported");
            return;
        }
        var audioConstraintsChanged = JSON.stringify(nextProps.audioConstraints) !==
            JSON.stringify(props.audioConstraints);
        var videoConstraintsChanged = JSON.stringify(nextProps.videoConstraints) !==
            JSON.stringify(props.videoConstraints);
        var minScreenshotWidthChanged = nextProps.minScreenshotWidth !== props.minScreenshotWidth;
        var minScreenshotHeightChanged = nextProps.minScreenshotHeight !== props.minScreenshotHeight;
        if (videoConstraintsChanged ||
            minScreenshotWidthChanged ||
            minScreenshotHeightChanged) {
            this.canvas = null;
            this.ctx = null;
        }
        if (audioConstraintsChanged || videoConstraintsChanged) {
            this.stopAndCleanup();
            this.requestUserMedia();
        }
    };
    Webcam.prototype.componentWillUnmount = function () {
        this.unmounted = true;
        this.stopAndCleanup();
    };
    Webcam.stopMediaStream = function (stream) {
        if (stream) {
            if (stream.getVideoTracks && stream.getAudioTracks) {
                stream.getVideoTracks().map(function (track) {
                    stream.removeTrack(track);
                    track.stop();
                });
                stream.getAudioTracks().map(function (track) {
                    stream.removeTrack(track);
                    track.stop();
                });
            }
            else {
                stream.stop();
            }
        }
    };
    Webcam.prototype.stopAndCleanup = function () {
        var state = this.state;
        if (state.hasUserMedia) {
            Webcam.stopMediaStream(this.stream);
            if (state.src) {
                window.URL.revokeObjectURL(state.src);
            }
        }
    };
    Webcam.prototype.getScreenshot = function (screenshotDimensions) {
        var _a = this, state = _a.state, props = _a.props;
        if (!state.hasUserMedia)
            return null;
        var canvas = this.getCanvas(screenshotDimensions);
        return (canvas &&
            canvas.toDataURL(props.screenshotFormat, props.screenshotQuality));
    };
    Webcam.prototype.getCanvas = function (screenshotDimensions) {
        var _a = this, state = _a.state, props = _a.props;
        if (!this.video) {
            return null;
        }
        if (!state.hasUserMedia || !this.video.videoHeight)
            return null;
        if (!this.ctx) {
            var canvasWidth = this.video.videoWidth;
            var canvasHeight = this.video.videoHeight;
            if (!this.props.forceScreenshotSourceSize) {
                var aspectRatio = canvasWidth / canvasHeight;
                canvasWidth = props.minScreenshotWidth || this.video.clientWidth;
                canvasHeight = canvasWidth / aspectRatio;
                if (props.minScreenshotHeight &&
                    canvasHeight < props.minScreenshotHeight) {
                    canvasHeight = props.minScreenshotHeight;
                    canvasWidth = canvasHeight * aspectRatio;
                }
            }
            this.canvas = document.createElement("canvas");
            this.canvas.width = (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.width) || canvasWidth;
            this.canvas.height = (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.height) || canvasHeight;
            this.ctx = this.canvas.getContext("2d");
        }
        var _b = this, ctx = _b.ctx, canvas = _b.canvas;
        if (ctx && canvas) {
            // mirror the screenshot
            if (props.mirrored) {
                ctx.translate(canvas.width, 0);
                ctx.scale(-1, 1);
            }
            ctx.imageSmoothingEnabled = props.imageSmoothing;
            ctx.drawImage(this.video, 0, 0, (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.width) || canvas.width, (screenshotDimensions === null || screenshotDimensions === void 0 ? void 0 : screenshotDimensions.height) || canvas.height);
            // invert mirroring
            if (props.mirrored) {
                ctx.scale(-1, 1);
                ctx.translate(-canvas.width, 0);
            }
        }
        return canvas;
    };
    Webcam.prototype.requestUserMedia = function () {
        var _this = this;
        var props = this.props;
        var sourceSelected = function (audioConstraints, videoConstraints) {
            var constraints = {
                video: typeof videoConstraints !== "undefined" ? videoConstraints : true
            };
            if (props.audio) {
                constraints.audio =
                    typeof audioConstraints !== "undefined" ? audioConstraints : true;
            }
            navigator.mediaDevices
                .getUserMedia(constraints)
                .then(function (stream) {
                if (_this.unmounted) {
                    Webcam.stopMediaStream(stream);
                }
                else {
                    _this.handleUserMedia(null, stream);
                }
            })
                .catch(function (e) {
                _this.handleUserMedia(e);
            });
        };
        if ("mediaDevices" in navigator) {
            sourceSelected(props.audioConstraints, props.videoConstraints);
        }
        else {
            var optionalSource_1 = function (id) { return ({ optional: [{ sourceId: id }] }); };
            var constraintToSourceId_1 = function (constraint) {
                var deviceId = constraint.deviceId;
                if (typeof deviceId === "string") {
                    return deviceId;
                }
                if (Array.isArray(deviceId) && deviceId.length > 0) {
                    return deviceId[0];
                }
                if (typeof deviceId === "object" && deviceId.ideal) {
                    return deviceId.ideal;
                }
                return null;
            };
            // @ts-ignore: deprecated api
            MediaStreamTrack.getSources(function (sources) {
                var audioSource = null;
                var videoSource = null;
                sources.forEach(function (source) {
                    if (source.kind === "audio") {
                        audioSource = source.id;
                    }
                    else if (source.kind === "video") {
                        videoSource = source.id;
                    }
                });
                var audioSourceId = constraintToSourceId_1(props.audioConstraints);
                if (audioSourceId) {
                    audioSource = audioSourceId;
                }
                var videoSourceId = constraintToSourceId_1(props.videoConstraints);
                if (videoSourceId) {
                    videoSource = videoSourceId;
                }
                sourceSelected(optionalSource_1(audioSource), optionalSource_1(videoSource));
            });
        }
    };
    Webcam.prototype.handleUserMedia = function (err, stream) {
        var props = this.props;
        if (err || !stream) {
            this.setState({ hasUserMedia: false });
            props.onUserMediaError(err);
            return;
        }
        this.stream = stream;
        try {
            if (this.video) {
                this.video.srcObject = stream;
            }
            this.setState({ hasUserMedia: true });
        }
        catch (error) {
            this.setState({
                hasUserMedia: true,
                src: window.URL.createObjectURL(stream)
            });
        }
        props.onUserMedia(stream);
    };
    Webcam.prototype.render = function () {
        var _this = this;
        var _a = this, state = _a.state, props = _a.props;
        var audio = props.audio, forceScreenshotSourceSize = props.forceScreenshotSourceSize, onUserMedia = props.onUserMedia, onUserMediaError = props.onUserMediaError, screenshotFormat = props.screenshotFormat, screenshotQuality = props.screenshotQuality, minScreenshotWidth = props.minScreenshotWidth, minScreenshotHeight = props.minScreenshotHeight, audioConstraints = props.audioConstraints, videoConstraints = props.videoConstraints, imageSmoothing = props.imageSmoothing, mirrored = props.mirrored, _b = props.style, style = _b === void 0 ? {} : _b, rest = __rest(props, ["audio", "forceScreenshotSourceSize", "onUserMedia", "onUserMediaError", "screenshotFormat", "screenshotQuality", "minScreenshotWidth", "minScreenshotHeight", "audioConstraints", "videoConstraints", "imageSmoothing", "mirrored", "style"]);
        var videoStyle = mirrored ? __assign(__assign({}, style), { transform: (style.transform || "") + " scaleX(-1)" }) : style;
        return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("video", __assign({ autoPlay: true, src: state.src, muted: audio, playsInline: true, ref: function (ref) {
                _this.video = ref;
            }, style: videoStyle }, rest)));
    };
    Webcam.defaultProps = {
        audio: true,
        forceScreenshotSourceSize: false,
        imageSmoothing: true,
        mirrored: false,
        onUserMedia: function () { return undefined; },
        onUserMediaError: function () { return undefined; },
        screenshotFormat: "image/webp",
        screenshotQuality: 0.92,
    };
    return Webcam;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]));
/* harmony default export */ __webpack_exports__["default"] = (Webcam);


/***/ }),

/***/ "react":
/*!**************************************************************************************!*\
  !*** external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"} ***!
  \**************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_react__;

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=react-webcam.js.map

/***/ }),

/***/ "./node_modules/ts-custom-error/dist/custom-error.mjs":
/*!************************************************************!*\
  !*** ./node_modules/ts-custom-error/dist/custom-error.mjs ***!
  \************************************************************/
/*! exports provided: CustomError, customErrorFactory */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomError", function() { return CustomError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customErrorFactory", function() { return customErrorFactory; });
function fixProto(target, prototype) {
  var setPrototypeOf = Object.setPrototypeOf;
  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
}
function fixStack(target, fn) {
  if (fn === void 0) {
    fn = target.constructor;
  }

  var captureStackTrace = Error.captureStackTrace;
  captureStackTrace && captureStackTrace(target, fn);
}

var __extends = undefined && undefined.__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var CustomError = function (_super) {
  __extends(CustomError, _super);

  function CustomError(message, options) {
    var _newTarget = this.constructor;

    var _this = _super.call(this, message, options) || this;

    Object.defineProperty(_this, 'name', {
      value: _newTarget.name,
      enumerable: false,
      configurable: true
    });
    fixProto(_this, _newTarget.prototype);
    fixStack(_this);
    return _this;
  }

  return CustomError;
}(Error);

var __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function customErrorFactory(fn, parent) {
  if (parent === void 0) {
    parent = Error;
  }

  function CustomError() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    if (!(this instanceof CustomError)) return new (CustomError.bind.apply(CustomError, __spreadArray([void 0], args, false)))();
    parent.apply(this, args);
    Object.defineProperty(this, 'name', {
      value: fn.name || parent.name,
      enumerable: false,
      configurable: true
    });
    fn.apply(this, args);
    fixStack(this, CustomError);
  }

  return Object.defineProperties(CustomError, {
    prototype: {
      value: Object.create(parent.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          configurable: true
        }
      })
    }
  });
}


//# sourceMappingURL=custom-error.mjs.map


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvYnJvd3Nlci9Ccm93c2VyQXp0ZWNDb2RlUmVhZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9icm93c2VyL0Jyb3dzZXJCYXJjb2RlUmVhZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9icm93c2VyL0Jyb3dzZXJDb2RlUmVhZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9icm93c2VyL0Jyb3dzZXJEYXRhbWF0cml4Q29kZVJlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvYnJvd3Nlci9Ccm93c2VyTXVsdGlGb3JtYXRSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2Jyb3dzZXIvQnJvd3NlclBERjQxN1JlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvYnJvd3Nlci9Ccm93c2VyUVJDb2RlUmVhZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9icm93c2VyL0Jyb3dzZXJRUkNvZGVTdmdXcml0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2Jyb3dzZXIvSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2Jyb3dzZXIvVmlkZW9JbnB1dERldmljZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9Bcmd1bWVudEV4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9Bcml0aG1ldGljRXhjZXB0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL0FycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9CYXJjb2RlRm9ybWF0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL0JpbmFyaXplci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9CaW5hcnlCaXRtYXAuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvQ2hlY2tzdW1FeGNlcHRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvRGVjb2RlSGludFR5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvRW5jb2RlSGludFR5cGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvRXhjZXB0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL0Zvcm1hdEV4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvSWxsZWdhbFN0YXRlRXhjZXB0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL0luZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvTHVtaW5hbmNlU291cmNlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL011bHRpRm9ybWF0UmVhZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL011bHRpRm9ybWF0V3JpdGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL05vdEZvdW5kRXhjZXB0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL051bGxQb2ludGVyRXhjZXB0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL091dE9mTWVtb3J5RXJyb3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL1JHQkx1bWluYW5jZVNvdXJjZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9SZWFkZXJFeGNlcHRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvUmVlZFNvbG9tb25FeGNlcHRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvUmVzdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL1Jlc3VsdE1ldGFkYXRhVHlwZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9SZXN1bHRQb2ludC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9VbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9Xcml0ZXJFeGNlcHRpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvYXp0ZWMvQXp0ZWNEZXRlY3RvclJlc3VsdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9henRlYy9BenRlY1JlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9henRlYy9kZWNvZGVyL0RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvYXp0ZWMvZGV0ZWN0b3IvRGV0ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvY29tbW9uL0JpdEFycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2NvbW1vbi9CaXRNYXRyaXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvY29tbW9uL0JpdFNvdXJjZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9jb21tb24vQ2hhcmFjdGVyU2V0RUNJLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2NvbW1vbi9EZWNvZGVyUmVzdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2NvbW1vbi9EZWZhdWx0R3JpZFNhbXBsZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvY29tbW9uL0RldGVjdG9yUmVzdWx0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2NvbW1vbi9HbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvY29tbW9uL0dyaWRTYW1wbGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2NvbW1vbi9HcmlkU2FtcGxlckluc3RhbmNlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2NvbW1vbi9IeWJyaWRCaW5hcml6ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvY29tbW9uL1BlcnNwZWN0aXZlVHJhbnNmb3JtLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2NvbW1vbi9TdHJpbmdVdGlscy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9jb21tb24vZGV0ZWN0b3IvTWF0aFV0aWxzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2NvbW1vbi9kZXRlY3Rvci9XaGl0ZVJlY3RhbmdsZURldGVjdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2NvbW1vbi9yZWVkc29sb21vbi9BYnN0cmFjdEdlbmVyaWNHRi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9jb21tb24vcmVlZHNvbG9tb24vR2VuZXJpY0dGLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2NvbW1vbi9yZWVkc29sb21vbi9HZW5lcmljR0ZQb2x5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2NvbW1vbi9yZWVkc29sb21vbi9SZWVkU29sb21vbkRlY29kZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvY29tbW9uL3JlZWRzb2xvbW9uL1JlZWRTb2xvbW9uRW5jb2Rlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9kYXRhbWF0cml4L0RhdGFNYXRyaXhSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvZGF0YW1hdHJpeC9kZWNvZGVyL0JpdE1hdHJpeFBhcnNlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9kYXRhbWF0cml4L2RlY29kZXIvRGF0YUJsb2NrLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2RhdGFtYXRyaXgvZGVjb2Rlci9EZWNvZGVkQml0U3RyZWFtUGFyc2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2RhdGFtYXRyaXgvZGVjb2Rlci9EZWNvZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2RhdGFtYXRyaXgvZGVjb2Rlci9WZXJzaW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL2RhdGFtYXRyaXgvZGV0ZWN0b3IvRGV0ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9BYnN0cmFjdFVQQ0VBTlJlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL0NvZGUxMjhSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9Db2RlMzlSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9FQU4xM1JlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL0VBTjhSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9JVEZSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9NdWx0aUZvcm1hdE9uZURSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9NdWx0aUZvcm1hdFVQQ0VBTlJlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL09uZURSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9VUENFQU5FeHRlbnNpb24yU3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL1VQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvVVBDRUFORXh0ZW5zaW9uU3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL1VQQ0VBTlJlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL3Jzcy9BYnN0cmFjdFJTU1JlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL3Jzcy9EYXRhQ2hhcmFjdGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvcnNzL0ZpbmRlclBhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9yc3MvUGFpci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL3Jzcy9SU1MxNFJlYWRlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL3Jzcy9SU1NVdGlscy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9CaXRBcnJheUJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvRXhwYW5kZWRQYWlyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL0V4cGFuZGVkUm93LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL1JTU0V4cGFuZGVkUmVhZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0FJMDEzMTAzZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxMzIweERlY29kZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvQUkwMTM5MnhEZWNvZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0FJMDEzOTN4RGVjb2Rlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxM3gweDF4RGVjb2Rlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BSTAxM3gweERlY29kZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvQUkwMUFuZE90aGVyQUlzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0FJMDFkZWNvZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0FJMDF3ZWlnaHREZWNvZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0Fic3RyYWN0RXhwYW5kZWREZWNvZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0Fic3RyYWN0RXhwYW5kZWREZWNvZGVyQ29tcGxlbWVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9vbmVkL3Jzcy9leHBhbmRlZC9kZWNvZGVycy9BbnlBSURlY29kZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvQmxvY2tQYXJzZWRSZXN1bHQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvRGVjb2RlZENoYXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvRGVjb2RlZEluZm9ybWF0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0RlY29kZWROdW1lcmljLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL29uZWQvcnNzL2V4cGFuZGVkL2RlY29kZXJzL0RlY29kZWRPYmplY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvRmllbGRQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvZGVjb2RlcnMvR2VuZXJhbEFwcElkRGVjb2Rlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9wZGY0MTcvUERGNDE3Q29tbW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3BkZjQxNy9QREY0MTdSZWFkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcGRmNDE3L1BERjQxN1Jlc3VsdE1ldGFkYXRhLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3BkZjQxNy9kZWNvZGVyL0JhcmNvZGVNZXRhZGF0YS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9wZGY0MTcvZGVjb2Rlci9CYXJjb2RlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcGRmNDE3L2RlY29kZXIvQm91bmRpbmdCb3guanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcGRmNDE3L2RlY29kZXIvQ29kZXdvcmQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcGRmNDE3L2RlY29kZXIvRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9wZGY0MTcvZGVjb2Rlci9EZXRlY3Rpb25SZXN1bHQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcGRmNDE3L2RlY29kZXIvRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3BkZjQxNy9kZWNvZGVyL0RldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9wZGY0MTcvZGVjb2Rlci9QREY0MTdDb2Rld29yZERlY29kZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcGRmNDE3L2RlY29kZXIvUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3BkZjQxNy9kZWNvZGVyL2VjL0Vycm9yQ29ycmVjdGlvbi5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9wZGY0MTcvZGVjb2Rlci9lYy9Nb2R1bHVzQmFzZS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9wZGY0MTcvZGVjb2Rlci9lYy9Nb2R1bHVzR0YuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcGRmNDE3L2RlY29kZXIvZWMvTW9kdWx1c1BvbHkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcGRmNDE3L2RldGVjdG9yL0RldGVjdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3BkZjQxNy9kZXRlY3Rvci9QREY0MTdEZXRlY3RvclJlc3VsdC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9xcmNvZGUvUVJDb2RlUmVhZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9RUkNvZGVXcml0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcXJjb2RlL2RlY29kZXIvQml0TWF0cml4UGFyc2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9kZWNvZGVyL0RhdGFCbG9jay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9xcmNvZGUvZGVjb2Rlci9EYXRhTWFzay5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9xcmNvZGUvZGVjb2Rlci9EZWNvZGVkQml0U3RyZWFtUGFyc2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9kZWNvZGVyL0RlY29kZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcXJjb2RlL2RlY29kZXIvRUNCLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9kZWNvZGVyL0VDQmxvY2tzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9kZWNvZGVyL0Vycm9yQ29ycmVjdGlvbkxldmVsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9kZWNvZGVyL0Zvcm1hdEluZm9ybWF0aW9uLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9kZWNvZGVyL01vZGUuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcXJjb2RlL2RlY29kZXIvUVJDb2RlRGVjb2Rlck1ldGFEYXRhLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9kZWNvZGVyL1ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcXJjb2RlL2RldGVjdG9yL0FsaWdubWVudFBhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcXJjb2RlL2RldGVjdG9yL0FsaWdubWVudFBhdHRlcm5GaW5kZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcXJjb2RlL2RldGVjdG9yL0RldGVjdG9yLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9kZXRlY3Rvci9GaW5kZXJQYXR0ZXJuLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9kZXRlY3Rvci9GaW5kZXJQYXR0ZXJuRmluZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9kZXRlY3Rvci9GaW5kZXJQYXR0ZXJuSW5mby5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9xcmNvZGUvZW5jb2Rlci9CbG9ja1BhaXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcXJjb2RlL2VuY29kZXIvQnl0ZU1hdHJpeC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS9xcmNvZGUvZW5jb2Rlci9FbmNvZGVyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9lbmNvZGVyL01hc2tVdGlsLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3FyY29kZS9lbmNvZGVyL01hdHJpeFV0aWwuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvcXJjb2RlL2VuY29kZXIvUVJDb2RlLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3V0aWwvQXJyYXlzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3V0aWwvQnl0ZUFycmF5T3V0cHV0U3RyZWFtLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3V0aWwvRmxvYXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvdXRpbC9Gb3JtYXR0ZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvdXRpbC9JbnRlZ2VyLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHp4aW5nL2xpYnJhcnkvZXNtNS9jb3JlL3V0aWwvTG9uZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS91dGlsL091dHB1dFN0cmVhbS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS91dGlsL1N0cmluZ0J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AenhpbmcvbGlicmFyeS9lc201L2NvcmUvdXRpbC9TdHJpbmdFbmNvZGluZy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvY29yZS91dGlsL1N5c3RlbS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B6eGluZy9saWJyYXJ5L2VzbTUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1xci1iYXJjb2RlLXNjYW5uZXIvZGlzdC9CYXJjb2RlU2Nhbm5lckNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXFyLWJhcmNvZGUtc2Nhbm5lci9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcmVhY3Qtd2ViY2FtL2Rpc3QvcmVhY3Qtd2ViY2FtLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHMtY3VzdG9tLWVycm9yL2Rpc3QvY3VzdG9tLWVycm9yLm1qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLFNBQVMsbUJBQU8sQ0FBQyw4R0FBa0M7QUFDbkQsU0FBUyxtQkFBTyxDQUFDLDBHQUFnQztBQUNqRCxTQUFTLG1CQUFPLENBQUMsb0dBQTZCO0FBQzlDLFNBQVMsbUJBQU8sQ0FBQyx3SEFBdUM7QUFDeEQsU0FBUyxtQkFBTyxDQUFDLGtIQUFvQztBQUNyRCxTQUFTLG1CQUFPLENBQUMsd0dBQStCO0FBQ2hELFNBQVMsbUJBQU8sQ0FBQyx3R0FBK0I7QUFDaEQs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxxRUFBcUU7QUFDMUg7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsd0JBQXdCO0FBQ2pFLHNEQUFzRCxxQ0FBcUM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsOEJBQThCLEVBQUU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsaUJBQWlCLEVBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlCQUF5QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG9DOzs7Ozs7Ozs7Ozs7QUMzZWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZEQUE2RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsMkJBQTJCLEVBQUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1Qzs7Ozs7Ozs7Ozs7O0FDdmNhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBYSx3QkFBd0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQStDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsK0M7Ozs7Ozs7Ozs7OztBQ3JZYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLDhFQUFnQjtBQUN2QztBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsMEdBQThCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxnQkFBZ0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHdDOzs7Ozs7Ozs7Ozs7QUNuZWE7QUFDYjtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlEQUF5RDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQzs7Ozs7Ozs7Ozs7O0FDbFZhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3Q0FBd0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxtQzs7Ozs7Ozs7Ozs7O0FDMU9hO0FBQ2I7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQThDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGtCQUFrQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxVQUFVO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxVQUFVO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFVBQVU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxnQkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQyx1REFBdUQscUJBQXFCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxVQUFVO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMkJBQTJCLDBEQUEwRDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVILDJCQUEyQjtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMseUNBQXlDO0FBQ3pDO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsK0M7Ozs7Ozs7Ozs7OztBQ3RxQmE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZDOzs7Ozs7Ozs7Ozs7QUN6Q2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUM7Ozs7Ozs7Ozs7OztBQ2hDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCw2Q0FBNkM7QUFDN0MsMEJBQTBCO0FBQzFCLGVBQWUsbUJBQU8sQ0FBQyxpRkFBbUI7QUFDMUMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsVUFBVTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHNDOzs7Ozs7Ozs7Ozs7QUN2SWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsNkNBQTZDO0FBQzdDLHVCQUF1QixtQkFBTyxDQUFDLHVGQUFzQjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDaEQsd0JBQXdCLG1CQUFPLENBQUMsdUdBQThCO0FBQzlELGtCQUFrQixtQkFBTyxDQUFDLG1IQUFvQztBQUM5RCwyQkFBMkIsbUJBQU8sQ0FBQyxxSUFBNkM7QUFDaEYsYUFBYSxtQkFBTyxDQUFDLHVGQUFpQjtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyw2RkFBb0I7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsc0ZBQVk7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsMEZBQWM7QUFDekMsZUFBZSxtQkFBTyxDQUFDLGtGQUFVO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFjO0FBQ3pDLHVCQUF1QixtQkFBTyxDQUFDLGlHQUEyQjtBQUMxRCxrQkFBa0IsbUJBQU8sQ0FBQyx3RkFBYTtBQUN2Qyx3QkFBd0IsbUJBQU8sQ0FBQyx5RkFBdUI7QUFDdkQsOENBQThDO0FBQzlDLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixpQkFBaUI7QUFDckc7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLGlDQUFpQyxrREFBa0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0NBQW9DO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQSxtRkFBbUYsa0JBQWtCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFFBQVEsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0EsbUZBQW1GLGtCQUFrQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxtQzs7Ozs7Ozs7Ozs7O0FDemtCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELGlDQUFpQyxtQkFBTyxDQUFDLDJHQUFnQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DLDJCQUEyQixXQUFXO0FBQ3RDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQzs7Ozs7Ozs7Ozs7O0FDdE5hO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsNkNBQTZDO0FBQzdDLGlCQUFpQixtQkFBTyxDQUFDLHlGQUF1QjtBQUNoRCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBb0I7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLGtGQUFVO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFZO0FBQ3JDLHdCQUF3QixtQkFBTyxDQUFDLHlGQUF1QjtBQUN2RCxpQ0FBaUMsbUJBQU8sQ0FBQywyR0FBZ0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx1QkFBdUIsT0FBTztBQUM5QiwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwyQkFBMkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsT0FBTztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU87QUFDOUI7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZ0JBQWdCO0FBQ3RFO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxzQzs7Ozs7Ozs7Ozs7O0FDaGJhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0M7Ozs7Ozs7Ozs7OztBQ3RGYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCxlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsaUNBQWlDLG1CQUFPLENBQUMsd0dBQTZCO0FBQ3RFLHVDQUF1QyxtQkFBTyxDQUFDLG9IQUFtQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0MsUUFBUSxjQUFjLG1CQUFtQix5QkFBeUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxrREFBa0Qsb0JBQW9CO0FBQ3RFLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCLE1BQU0sY0FBYztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QyxxQ0FBcUMsb0JBQW9CLGVBQWUsY0FBYyxFQUFFO0FBQ3hGO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QyxxQ0FBcUMseUJBQXlCLGVBQWUsY0FBYyxFQUFFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0M7Ozs7Ozs7Ozs7OztBQzdMYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCLHNDQUFzQyxpQkFBaUIsRUFBRTtBQUN2Riw2QkFBNkIsdURBQXVEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0EsQ0FBQztBQUNELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLGlDQUFpQyxtQkFBTyxDQUFDLHdHQUE2QjtBQUN0RSx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBcUI7QUFDdEQsZUFBZSxtQkFBTyxDQUFDLHdFQUFVO0FBQ2pDLGtDQUFrQyxtQkFBTyxDQUFDLDBHQUE4QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxzQkFBc0I7QUFDMUQ7QUFDQSxRQUFRLG1FQUFtRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJDQUEyQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXLElBQUksY0FBYztBQUNsRTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxpRDs7Ozs7Ozs7Ozs7O0FDM1JhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsaUM7Ozs7Ozs7Ozs7OztBQ3RCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyw0REFBNEQ7QUFDNUQ7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUM7Ozs7Ozs7Ozs7OztBQ2hGYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsbUM7Ozs7Ozs7Ozs7OztBQy9GYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQzs7Ozs7Ozs7Ozs7O0FDckJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsa0NBQWtDLG1CQUFPLENBQUMsMEdBQThCO0FBQ3hFLDZCQUE2QixtQkFBTyxDQUFDLGdHQUF5QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHdDOzs7Ozs7Ozs7Ozs7QUM3SWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxvQkFBb0IsbUJBQU8sQ0FBQyw0RkFBdUI7QUFDbkQ7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHlDOzs7Ozs7Ozs7Ozs7QUN4RGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxzQ0FBc0MsbUJBQU8sQ0FBQyxrSEFBa0M7QUFDaEYsd0JBQXdCLG1CQUFPLENBQUMsb0dBQTJCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDOzs7Ozs7Ozs7Ozs7QUMvR2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0M7Ozs7Ozs7Ozs7OztBQ3hCYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELFNBQVMsbUJBQU8sQ0FBQyxnRUFBVztBQUM1QjtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLDhGQUEwQjtBQUM1RDtBQUNBLDRCQUE0QixtQkFBTyxDQUFDLGtHQUE0QjtBQUNoRTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLDhGQUEwQjtBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFrQjtBQUM1QztBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDBGQUF3QjtBQUN4RDtBQUNBLGlDQUFpQyxtQkFBTyxDQUFDLDRHQUFpQztBQUMxRTtBQUNBLDhCQUE4QixtQkFBTyxDQUFDLHNHQUE4QjtBQUNwRTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLDhGQUEwQjtBQUM1RDtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDBGQUF3QjtBQUN4RDtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLG9HQUE2QjtBQUNsRTtBQUNBLHNDQUFzQyxtQkFBTyxDQUFDLHNIQUFzQztBQUNwRjtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLDBGQUF3QjtBQUN4RDtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsc0ZBQXNCO0FBQ3BEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsOEVBQWtCO0FBQzVDO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ2xEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ3REO0FBQ0EsZ0NBQWdDLG1CQUFPLENBQUMsMEdBQWdDO0FBQ3hFO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsMEZBQXdCO0FBQ3hEO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsOEZBQTBCO0FBQzVEO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsOEZBQTBCO0FBQzVEO0FBQ0EsaUNBQWlDLG1CQUFPLENBQUMsNEdBQWlDO0FBQzFFO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHdFQUFlO0FBQ3RDO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsZ0dBQTJCO0FBQzlEO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsZ0dBQTJCO0FBQzlEO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywwRkFBd0I7QUFDakQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBeUI7QUFDbkQ7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyw0RkFBeUI7QUFDbkQ7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyx3R0FBK0I7QUFDL0Q7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxvR0FBNkI7QUFDM0Q7QUFDQSwyQkFBMkIsbUJBQU8sQ0FBQyw4R0FBa0M7QUFDckU7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxzR0FBOEI7QUFDN0Q7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDdEQ7QUFDQSxpQ0FBaUMsbUJBQU8sQ0FBQywwSEFBd0M7QUFDakY7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxnR0FBMkI7QUFDdkQ7QUFDQSw0QkFBNEIsbUJBQU8sQ0FBQyxnSEFBbUM7QUFDdkU7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyx3R0FBK0I7QUFDL0Q7QUFDQSw2QkFBNkIsbUJBQU8sQ0FBQyxrSEFBb0M7QUFDekU7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxnR0FBMkI7QUFDdkQ7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDhHQUFrQztBQUM1RDtBQUNBLFdBQVcseUNBQXlDO0FBQ3BELCtCQUErQixtQkFBTyxDQUFDLHdJQUErQztBQUN0RjtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsb0hBQXFDO0FBQy9EO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsNEhBQXlDO0FBQ3ZFO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsc0lBQThDO0FBQ2pGO0FBQ0EsMkJBQTJCLG1CQUFPLENBQUMsc0lBQThDO0FBQ2pGO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxrSEFBb0M7QUFDckU7QUFDQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGtHQUE0QjtBQUN6RDtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGtHQUE0QjtBQUN6RDtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLGtJQUE0QztBQUNqRjtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHdHQUErQjtBQUN2RDtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzR0FBOEI7QUFDckQ7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLDhGQUEwQjtBQUN0RDtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsMEZBQXdCO0FBQ25EO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsNEZBQXlCO0FBQ3JEO0FBQ0Esc0JBQXNCLG1CQUFPLENBQUMsZ0dBQTJCO0FBQ3pEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsd0ZBQXVCO0FBQ2pEO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsOEZBQTBCO0FBQ3ZEO0FBQ0Esb0JBQW9CLG1CQUFPLENBQUMsb0dBQTZCO0FBQ3pEO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsa0lBQTRDO0FBQzlFO0FBQ0EsOEJBQThCLG1CQUFPLENBQUMsZ0hBQW1DO0FBQ3pFO0FBQ0EsaUM7Ozs7Ozs7Ozs7OztBQ3RJYTtBQUNiO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsZ0NBQWdDLG1CQUFPLENBQUMsNENBQU87QUFDL0Msa0JBQWtCLG1CQUFPLENBQUMsbUVBQWdCO0FBQzFDLHVDQUF1QyxtQkFBTyxDQUFDLHNFQUFjO0FBQzdELGtDQUFrQyxvSUFBb0k7QUFDdEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUVBQW1FO0FBQ25FO0FBQ0EsU0FBUywyQ0FBMkM7QUFDcEQ7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZFYTtBQUNiO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsa0RBQWtELG1CQUFPLENBQUMsMEdBQTJCO0FBQ3JGOzs7Ozs7Ozs7Ozs7QUNOQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsNENBQU87QUFDMUMsTUFBTSxFQUtvQztBQUMxQyxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGLHdIQUF3SCxtQkFBbUIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDdkYsNkJBQTZCLHVEQUF1RDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsVUFBVSxhQUFhLGVBQWUsR0FBRyxFQUFFO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzaUJBQXNpQjtBQUN0aUIsd0RBQXdELFdBQVcscURBQXFEO0FBQ3hILHVGQUF1RjtBQUN2RjtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0IsRUFBRTtBQUN0RCx1Q0FBdUMsa0JBQWtCLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87O0FBRVA7QUFDQTtBQUNBLGlCQUFpQixvRUFBb0U7QUFDckY7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVAsVUFBVTtBQUNWLENBQUM7QUFDRCx3Qzs7Ozs7Ozs7Ozs7O0FDaGJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLDBFQUEwRSxPQUFPO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUUyQztBQUMzQyIsImZpbGUiOiJzdGF0aWMvY2h1bmtzLzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gYnJvd3NlclxyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9icm93c2VyL0Jyb3dzZXJBenRlY0NvZGVSZWFkZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9icm93c2VyL0Jyb3dzZXJCYXJjb2RlUmVhZGVyXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vYnJvd3Nlci9Ccm93c2VyQ29kZVJlYWRlclwiKSk7XHJcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2Jyb3dzZXIvQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vYnJvd3Nlci9Ccm93c2VyTXVsdGlGb3JtYXRSZWFkZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9icm93c2VyL0Jyb3dzZXJQREY0MTdSZWFkZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9icm93c2VyL0Jyb3dzZXJRUkNvZGVSZWFkZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9icm93c2VyL0Jyb3dzZXJRUkNvZGVTdmdXcml0ZXJcIikpO1xyXG5fX2V4cG9ydChyZXF1aXJlKFwiLi9icm93c2VyL0hUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlXCIpKTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vYnJvd3Nlci9WaWRlb0lucHV0RGV2aWNlXCIpKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEJyb3dzZXJDb2RlUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9Ccm93c2VyQ29kZVJlYWRlclwiKTtcclxudmFyIEF6dGVjUmVhZGVyXzEgPSByZXF1aXJlKFwiLi4vY29yZS9henRlYy9BenRlY1JlYWRlclwiKTtcclxuLyoqXHJcbiAqIEF6dGVjIENvZGUgcmVhZGVyIHRvIHVzZSBmcm9tIGJyb3dzZXIuXHJcbiAqXHJcbiAqIEBjbGFzcyBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyXHJcbiAqIEBleHRlbmRzIHtCcm93c2VyQ29kZVJlYWRlcn1cclxuICovXHJcbnZhciBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJyb3dzZXJBenRlY0NvZGVSZWFkZXIsIF9zdXBlcik7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQnJvd3NlckF6dGVjQ29kZVJlYWRlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBkZWNvZGUgdHJpZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckF6dGVjQ29kZVJlYWRlclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpIHtcclxuICAgICAgICBpZiAodGltZUJldHdlZW5TY2Fuc01pbGxpcyA9PT0gdm9pZCAwKSB7IHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDA7IH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmV3IEF6dGVjUmVhZGVyXzEuZGVmYXVsdCgpLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJyb3dzZXJBenRlY0NvZGVSZWFkZXI7XHJcbn0oQnJvd3NlckNvZGVSZWFkZXJfMS5Ccm93c2VyQ29kZVJlYWRlcikpO1xyXG5leHBvcnRzLkJyb3dzZXJBenRlY0NvZGVSZWFkZXIgPSBCcm93c2VyQXp0ZWNDb2RlUmVhZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2VyQXp0ZWNDb2RlUmVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQnJvd3NlckNvZGVSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0Jyb3dzZXJDb2RlUmVhZGVyXCIpO1xyXG52YXIgTXVsdGlGb3JtYXRPbmVEUmVhZGVyXzEgPSByZXF1aXJlKFwiLi4vY29yZS9vbmVkL011bHRpRm9ybWF0T25lRFJlYWRlclwiKTtcclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxyXG4gKlxyXG4gKiBCYXJjb2RlIHJlYWRlciByZWFkZXIgdG8gdXNlIGZyb20gYnJvd3Nlci5cclxuICovXHJcbnZhciBCcm93c2VyQmFyY29kZVJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhCcm93c2VyQmFyY29kZVJlYWRlciwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCcm93c2VyQmFyY29kZVJlYWRlci5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdGltZUJldHdlZW5TY2Fuc01pbGxpcz01MDBdIHRoZSB0aW1lIGRlbGF5IGJldHdlZW4gc3Vic2VxdWVudCBkZWNvZGUgdHJpZXNcclxuICAgICAqIEBwYXJhbSB7TWFwPERlY29kZUhpbnRUeXBlLCBhbnk+fSBoaW50c1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCcm93c2VyQmFyY29kZVJlYWRlcih0aW1lQmV0d2VlblNjYW5zTWlsbGlzLCBoaW50cykge1xyXG4gICAgICAgIGlmICh0aW1lQmV0d2VlblNjYW5zTWlsbGlzID09PSB2b2lkIDApIHsgdGltZUJldHdlZW5TY2Fuc01pbGxpcyA9IDUwMDsgfVxyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyXzEuZGVmYXVsdChoaW50cyksIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMsIGhpbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJyb3dzZXJCYXJjb2RlUmVhZGVyO1xyXG59KEJyb3dzZXJDb2RlUmVhZGVyXzEuQnJvd3NlckNvZGVSZWFkZXIpKTtcclxuZXhwb3J0cy5Ccm93c2VyQmFyY29kZVJlYWRlciA9IEJyb3dzZXJCYXJjb2RlUmVhZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2VyQmFyY29kZVJlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59O1xyXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL2NvcmUvQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbnZhciBCaW5hcnlCaXRtYXBfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL0JpbmFyeUJpdG1hcFwiKTtcclxudmFyIENoZWNrc3VtRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vY29yZS9DaGVja3N1bUV4Y2VwdGlvblwiKTtcclxudmFyIEh5YnJpZEJpbmFyaXplcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvY29tbW9uL0h5YnJpZEJpbmFyaXplclwiKTtcclxudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL2NvcmUvRm9ybWF0RXhjZXB0aW9uXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9jb3JlL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xyXG52YXIgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0hUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlXCIpO1xyXG52YXIgVmlkZW9JbnB1dERldmljZV8xID0gcmVxdWlyZShcIi4vVmlkZW9JbnB1dERldmljZVwiKTtcclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxyXG4gKlxyXG4gKiBCYXNlIGNsYXNzIGZvciBicm93c2VyIGNvZGUgcmVhZGVyLlxyXG4gKi9cclxudmFyIEJyb3dzZXJDb2RlUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJyb3dzZXJDb2RlUmVhZGVyLlxyXG4gICAgICogQHBhcmFtIHtSZWFkZXJ9IHJlYWRlciBUaGUgcmVhZGVyIGluc3RhbmNlIHRvIGRlY29kZSB0aGUgYmFyY29kZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IHN1Y2Nlc3NmdWwgZGVjb2RlIHRyaWVzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJyb3dzZXJDb2RlUmVhZGVyKHJlYWRlciwgdGltZUJldHdlZW5TY2Fuc01pbGxpcywgX2hpbnRzKSB7XHJcbiAgICAgICAgaWYgKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPT09IHZvaWQgMCkgeyB0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwOyB9XHJcbiAgICAgICAgdGhpcy5yZWFkZXIgPSByZWFkZXI7XHJcbiAgICAgICAgdGhpcy50aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gdGltZUJldHdlZW5TY2Fuc01pbGxpcztcclxuICAgICAgICB0aGlzLl9oaW50cyA9IF9oaW50cztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIHdpbGwgYnJlYWsgdGhlIGxvb3AuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fc3RvcENvbnRpbnVvdXNEZWNvZGUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIHdpbGwgYnJlYWsgdGhlIGxvb3AuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fc3RvcEFzeW5jRGVjb2RlID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVsYXkgdGltZSBiZXR3ZWVuIGRlY29kZSBhdHRlbXB0cyBtYWRlIGJ5IHRoZSBzY2FubmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3RpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cyA9IDA7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLCBcImhhc05hdmlnYXRvclwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgbmF2aWdhdG9yIGlzIHByZXNlbnQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUsIFwiaXNNZWRpYURldmljZXNTdXBvcnRlZFwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgbWVkaWFEZXZpY2VzIHVuZGVyIG5hdmlnYXRvciBpcyBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc05hdmlnYXRvciAmJiAhIW5hdmlnYXRvci5tZWRpYURldmljZXM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLCBcImNhbkVudW1lcmF0ZURldmljZXNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGVudW1lcmF0ZURldmljZXMgdW5kZXIgbmF2aWdhdG9yIGlzIHN1cHBvcnRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhKHRoaXMuaXNNZWRpYURldmljZXNTdXBvcnRlZCAmJiBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZSwgXCJ0aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHNcIiwge1xyXG4gICAgICAgIC8qKiBUaW1lIGJldHdlZW4gdHdvIGRlY29kaW5nIHRyaWVzIGluIG1pbGxpIHNlY29uZHMuICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGFuZ2UgdGhlIHRpbWUgc3BhbiB0aGUgZGVjb2RlciB3YWl0cyBiZXR3ZWVuIHR3byBkZWNvZGluZyB0cmllcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaWxsaXMgVGltZSBiZXR3ZWVuIHR3byBkZWNvZGluZyB0cmllcyBpbiBtaWxsaSBzZWNvbmRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG1pbGxpcykge1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lQmV0d2VlbkRlY29kaW5nQXR0ZW1wdHMgPSBtaWxsaXMgPCAwID8gMCA6IG1pbGxpcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUsIFwiaGludHNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGhpbnRzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faGludHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBoaW50cy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChoaW50cykge1xyXG4gICAgICAgICAgICB0aGlzLl9oaW50cyA9IGhpbnRzIHx8IG51bGw7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIExpc3RzIGFsbCB0aGUgYXZhaWxhYmxlIHZpZGVvIGlucHV0IGRldmljZXMuXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5saXN0VmlkZW9JbnB1dERldmljZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZV8xLCBfYSwgZGV2aWNlcywgdmlkZW9EZXZpY2VzLCBkZXZpY2VzXzEsIGRldmljZXNfMV8xLCBkZXZpY2UsIGtpbmQsIGRldmljZUlkLCBsYWJlbCwgZ3JvdXBJZCwgdmlkZW9EZXZpY2U7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNOYXZpZ2F0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBlbnVtZXJhdGUgZGV2aWNlcywgbmF2aWdhdG9yIGlzIG5vdCBwcmVzZW50LicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYW5FbnVtZXJhdGVEZXZpY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgZW51bWVyYXRlIGRldmljZXMsIG1ldGhvZCBub3Qgc3VwcG9ydGVkLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZXMgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvRGV2aWNlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChkZXZpY2VzXzEgPSBfX3ZhbHVlcyhkZXZpY2VzKSwgZGV2aWNlc18xXzEgPSBkZXZpY2VzXzEubmV4dCgpOyAhZGV2aWNlc18xXzEuZG9uZTsgZGV2aWNlc18xXzEgPSBkZXZpY2VzXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlID0gZGV2aWNlc18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2luZCA9IGRldmljZS5raW5kID09PSAndmlkZW8nID8gJ3ZpZGVvaW5wdXQnIDogZGV2aWNlLmtpbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09ICd2aWRlb2lucHV0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQgPSBkZXZpY2UuZGV2aWNlSWQgfHwgZGV2aWNlLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID0gZGV2aWNlLmxhYmVsIHx8IFwiVmlkZW8gZGV2aWNlIFwiICsgKHZpZGVvRGV2aWNlcy5sZW5ndGggKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cElkID0gZGV2aWNlLmdyb3VwSWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9EZXZpY2UgPSB7IGRldmljZUlkOiBkZXZpY2VJZCwgbGFiZWw6IGxhYmVsLCBraW5kOiBraW5kLCBncm91cElkOiBncm91cElkIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW9EZXZpY2VzLnB1c2godmlkZW9EZXZpY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGV2aWNlc18xXzEgJiYgIWRldmljZXNfMV8xLmRvbmUgJiYgKF9hID0gZGV2aWNlc18xLnJldHVybikpIF9hLmNhbGwoZGV2aWNlc18xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdmlkZW9EZXZpY2VzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBPYnRhaW4gdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIGRldmljZXMgd2l0aCB0eXBlICd2aWRlb2lucHV0Jy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWaWRlb0lucHV0RGV2aWNlW10+fSBhbiBhcnJheSBvZiBhdmFpbGFibGUgdmlkZW8gaW5wdXQgZGV2aWNlc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxyXG4gICAgICpcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgbGlzdFZpZGVvSW5wdXREZXZpY2VzYCBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZ2V0VmlkZW9JbnB1dERldmljZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGV2aWNlcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5saXN0VmlkZW9JbnB1dERldmljZXMoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VzID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGV2aWNlcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIG5ldyBWaWRlb0lucHV0RGV2aWNlXzEuVmlkZW9JbnB1dERldmljZShkLmRldmljZUlkLCBkLmxhYmVsKTsgfSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExldCdzIHlvdSBmaW5kIGEgZGV2aWNlIHVzaW5nIGl0J3MgSWQuXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5maW5kRGV2aWNlQnlJZCA9IGZ1bmN0aW9uIChkZXZpY2VJZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRldmljZXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMubGlzdFZpZGVvSW5wdXREZXZpY2VzKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlcyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXZpY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRldmljZXMuZmluZChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kZXZpY2VJZCA9PT0gZGV2aWNlSWQ7IH0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIHRoZSBiYXJjb2RlIGZyb20gdGhlIGRldmljZSBzcGVjaWZpZWQgYnkgZGV2aWNlSWQgd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkZXZpY2VJZCB0aGUgaWQgb2Ygb25lIG9mIHRoZSBkZXZpY2VzIG9idGFpbmVkIGFmdGVyIGNhbGxpbmcgZ2V0VmlkZW9JbnB1dERldmljZXMuIENhbiBiZSB1bmRlZmluZWQsIGluIHRoaXMgY2FzZSBpdCB3aWxsIGRlY29kZSBmcm9tIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGRldmljZXMsIHByZWZmZXJpbmcgdGhlIG1haW4gY2FtZXJhIChlbnZpcm9ubWVudCBmYWNpbmcpIGlmIGF2YWlsYWJsZS5cclxuICAgICAqIEBwYXJhbSB2aWRlbyB0aGUgdmlkZW8gZWxlbWVudCBpbiBwYWdlIHdoZXJlIHRvIHNob3cgdGhlIHZpZGVvIHdoaWxlIGRlY29kaW5nLiBDYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgZGlyZWN0bHkgYW4gSFRNTFZpZGVvRWxlbWVudC4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSBubyB2aWRlbyB3aWxsIGJlIHNob3duLlxyXG4gICAgICogQHJldHVybnMgVGhlIGRlY29kaW5nIHJlc3VsdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYGRlY29kZU9uY2VGcm9tVmlkZW9EZXZpY2VgIGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tSW5wdXRWaWRlb0RldmljZSA9IGZ1bmN0aW9uIChkZXZpY2VJZCwgdmlkZW9Tb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGVjb2RlT25jZUZyb21WaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluIG9uZSBhdHRlbXB0LCB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSB0aGUgZGV2aWNlIHNwZWNpZmllZCBieSBkZXZpY2VJZCB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRldmljZUlkIHRoZSBpZCBvZiBvbmUgb2YgdGhlIGRldmljZXMgb2J0YWluZWQgYWZ0ZXIgY2FsbGluZyBnZXRWaWRlb0lucHV0RGV2aWNlcy4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gdGhpcyBjYXNlIGl0IHdpbGwgZGVjb2RlIGZyb20gb25lIG9mIHRoZSBhdmFpbGFibGUgZGV2aWNlcywgcHJlZmZlcmluZyB0aGUgbWFpbiBjYW1lcmEgKGVudmlyb25tZW50IGZhY2luZykgaWYgYXZhaWxhYmxlLlxyXG4gICAgICogQHBhcmFtIHZpZGVvIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RpbmcgcmVzdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlT25jZUZyb21WaWRlb0RldmljZSA9IGZ1bmN0aW9uIChkZXZpY2VJZCwgdmlkZW9Tb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWRlb0NvbnN0cmFpbnRzLCBjb25zdHJhaW50cztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRldmljZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBkZXZpY2VJZDogeyBleGFjdDogZGV2aWNlSWQgfSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzID0geyB2aWRlbzogdmlkZW9Db25zdHJhaW50cyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRlY29kZU9uY2VGcm9tQ29uc3RyYWludHMoY29uc3RyYWludHMsIHZpZGVvU291cmNlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbiBvbmUgYXR0ZW1wdCwgdHJpZXMgdG8gZGVjb2RlIHRoZSBiYXJjb2RlIGZyb20gYSBzdHJlYW0gb2J0YWluZWQgZnJvbSB0aGUgZ2l2ZW4gY29uc3RyYWludHMgd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb25zdHJhaW50cyB0aGUgbWVkaWEgc3RyZWFtIGNvbnN0cmFpbnRzIHRvIGdldCBzIHZhbGlkIG1lZGlhIHN0cmVhbSB0byBkZWNvZGUgZnJvbVxyXG4gICAgICogQHBhcmFtIHZpZGVvIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGVjb2RpbmcgcmVzdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlT25jZUZyb21Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cywgdmlkZW9Tb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJlYW07XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0gPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGVjb2RlT25jZUZyb21TdHJlYW0oc3RyZWFtLCB2aWRlb1NvdXJjZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogSW4gb25lIGF0dGVtcHQsIHRyaWVzIHRvIGRlY29kZSB0aGUgYmFyY29kZSBmcm9tIGEgc3RyZWFtIG9idGFpbmVkIGZyb20gdGhlIGdpdmVuIGNvbnN0cmFpbnRzIHdoaWxlIHNob3dpbmcgdGhlIHZpZGVvIGluIHRoZSBzcGVjaWZpZWQgdmlkZW8gZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge01lZGlhU3RyZWFtfSBbY29uc3RyYWludHNdIHRoZSBtZWRpYSBzdHJlYW0gY29uc3RyYWludHMgdG8gZ2V0IHMgdmFsaWQgbWVkaWEgc3RyZWFtIHRvIGRlY29kZSBmcm9tXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fSBbdmlkZW9dIHRoZSB2aWRlbyBlbGVtZW50IGluIHBhZ2Ugd2hlcmUgdG8gc2hvdyB0aGUgdmlkZW8gd2hpbGUgZGVjb2RpbmcuIENhbiBiZSBlaXRoZXIgYW4gZWxlbWVudCBpZCBvciBkaXJlY3RseSBhbiBIVE1MVmlkZW9FbGVtZW50LiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB3aGljaCBjYXNlIG5vIHZpZGVvIHdpbGwgYmUgc2hvd24uXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlT25jZUZyb21TdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtLCB2aWRlb1NvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZGVvLCByZXN1bHQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5hdHRhY2hTdHJlYW1Ub1ZpZGVvKHN0cmVhbSwgdmlkZW9Tb3VyY2UpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRlY29kZU9uY2UodmlkZW8pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udGludW91c2x5IGRlY29kZXMgdGhlIGJhcmNvZGUgZnJvbSB0aGUgZGV2aWNlIHNwZWNpZmllZCBieSBkZXZpY2Ugd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IFtkZXZpY2VJZF0gdGhlIGlkIG9mIG9uZSBvZiB0aGUgZGV2aWNlcyBvYnRhaW5lZCBhZnRlciBjYWxsaW5nIGdldFZpZGVvSW5wdXREZXZpY2VzLiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB0aGlzIGNhc2UgaXQgd2lsbCBkZWNvZGUgZnJvbSBvbmUgb2YgdGhlIGF2YWlsYWJsZSBkZXZpY2VzLCBwcmVmZmVyaW5nIHRoZSBtYWluIGNhbWVyYSAoZW52aXJvbm1lbnQgZmFjaW5nKSBpZiBhdmFpbGFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fG51bGx9IFt2aWRlb10gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxyXG4gICAgICpcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgZGVjb2RlRnJvbVZpZGVvRGV2aWNlYCBpbnN0ZWFkLlxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlRnJvbUlucHV0VmlkZW9EZXZpY2VDb250aW51b3VzbHkgPSBmdW5jdGlvbiAoZGV2aWNlSWQsIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRlY29kZUZyb21WaWRlb0RldmljZShkZXZpY2VJZCwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnRpbnVvdXNseSB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSB0aGUgZGV2aWNlIHNwZWNpZmllZCBieSBkZXZpY2Ugd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IFtkZXZpY2VJZF0gdGhlIGlkIG9mIG9uZSBvZiB0aGUgZGV2aWNlcyBvYnRhaW5lZCBhZnRlciBjYWxsaW5nIGdldFZpZGVvSW5wdXREZXZpY2VzLiBDYW4gYmUgdW5kZWZpbmVkLCBpbiB0aGlzIGNhc2UgaXQgd2lsbCBkZWNvZGUgZnJvbSBvbmUgb2YgdGhlIGF2YWlsYWJsZSBkZXZpY2VzLCBwcmVmZmVyaW5nIHRoZSBtYWluIGNhbWVyYSAoZW52aXJvbm1lbnQgZmFjaW5nKSBpZiBhdmFpbGFibGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MVmlkZW9FbGVtZW50fG51bGx9IFt2aWRlb10gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlRnJvbVZpZGVvRGV2aWNlID0gZnVuY3Rpb24gKGRldmljZUlkLCB2aWRlb1NvdXJjZSwgY2FsbGJhY2tGbikge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZpZGVvQ29uc3RyYWludHMsIGNvbnN0cmFpbnRzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRldmljZUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBmYWNpbmdNb2RlOiAnZW52aXJvbm1lbnQnIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWRlb0NvbnN0cmFpbnRzID0geyBkZXZpY2VJZDogeyBleGFjdDogZGV2aWNlSWQgfSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzID0geyB2aWRlbzogdmlkZW9Db25zdHJhaW50cyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRlY29kZUZyb21Db25zdHJhaW50cyhjb25zdHJhaW50cywgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnRpbnVvdXNseSB0cmllcyB0byBkZWNvZGUgdGhlIGJhcmNvZGUgZnJvbSBhIHN0cmVhbSBvYnRhaW5lZCBmcm9tIHRoZSBnaXZlbiBjb25zdHJhaW50cyB3aGlsZSBzaG93aW5nIHRoZSB2aWRlbyBpbiB0aGUgc3BlY2lmaWVkIHZpZGVvIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtNZWRpYVN0cmVhbX0gW2NvbnN0cmFpbnRzXSB0aGUgbWVkaWEgc3RyZWFtIGNvbnN0cmFpbnRzIHRvIGdldCBzIHZhbGlkIG1lZGlhIHN0cmVhbSB0byBkZWNvZGUgZnJvbVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8SFRNTFZpZGVvRWxlbWVudH0gW3ZpZGVvXSB0aGUgdmlkZW8gZWxlbWVudCBpbiBwYWdlIHdoZXJlIHRvIHNob3cgdGhlIHZpZGVvIHdoaWxlIGRlY29kaW5nLiBDYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgZGlyZWN0bHkgYW4gSFRNTFZpZGVvRWxlbWVudC4gQ2FuIGJlIHVuZGVmaW5lZCwgaW4gd2hpY2ggY2FzZSBubyB2aWRlbyB3aWxsIGJlIHNob3duLlxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVzdWx0Pn0gVGhlIGRlY29kaW5nIHJlc3VsdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyT2YgQnJvd3NlckNvZGVSZWFkZXJcclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZUZyb21Db25zdHJhaW50cyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cywgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdHJlYW07XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0gPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGVjb2RlRnJvbVN0cmVhbShzdHJlYW0sIHZpZGVvU291cmNlLCBjYWxsYmFja0ZuKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbiBvbmUgYXR0ZW1wdCwgdHJpZXMgdG8gZGVjb2RlIHRoZSBiYXJjb2RlIGZyb20gYSBzdHJlYW0gb2J0YWluZWQgZnJvbSB0aGUgZ2l2ZW4gY29uc3RyYWludHMgd2hpbGUgc2hvd2luZyB0aGUgdmlkZW8gaW4gdGhlIHNwZWNpZmllZCB2aWRlbyBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TWVkaWFTdHJlYW19IFtjb25zdHJhaW50c10gdGhlIG1lZGlhIHN0cmVhbSBjb25zdHJhaW50cyB0byBnZXQgcyB2YWxpZCBtZWRpYSBzdHJlYW0gdG8gZGVjb2RlIGZyb21cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxWaWRlb0VsZW1lbnR9IFt2aWRlb10gdGhlIHZpZGVvIGVsZW1lbnQgaW4gcGFnZSB3aGVyZSB0byBzaG93IHRoZSB2aWRlbyB3aGlsZSBkZWNvZGluZy4gQ2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIGRpcmVjdGx5IGFuIEhUTUxWaWRlb0VsZW1lbnQuIENhbiBiZSB1bmRlZmluZWQsIGluIHdoaWNoIGNhc2Ugbm8gdmlkZW8gd2lsbCBiZSBzaG93bi5cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3VsdD59IFRoZSBkZWNvZGluZyByZXN1bHQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tU3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSwgdmlkZW9Tb3VyY2UsIGNhbGxiYWNrRm4pIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWRlbztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmF0dGFjaFN0cmVhbVRvVmlkZW8oc3RyZWFtLCB2aWRlb1NvdXJjZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlkZW8gPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGVjb2RlQ29udGludW91c2x5KHZpZGVvLCBjYWxsYmFja0ZuKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBCcmVha3MgdGhlIGRlY29kaW5nIGxvb3AuXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5zdG9wQXN5bmNEZWNvZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcEFzeW5jRGVjb2RlID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEJyZWFrcyB0aGUgZGVjb2RpbmcgbG9vcC5cclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLnN0b3BDb250aW51b3VzRGVjb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID0gdHJ1ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG5ldyBzdHJlYW0gYW5kIHJlcXVlc3QgYSBuZXcgZGVjb2Rpbmctd2l0aC1kZWxheS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RyZWFtIFRoZSBzdHJlYW0gdG8gYmUgc2hvd24gaW4gdGhlIHZpZGVvIGVsZW1lbnQuXHJcbiAgICAgKiBAcGFyYW0gZGVjb2RlRm4gQSBjYWxsYmFjayBmb3IgdGhlIGRlY29kZSBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5hdHRhY2hTdHJlYW1Ub1ZpZGVvID0gZnVuY3Rpb24gKHN0cmVhbSwgdmlkZW9Tb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWRlb0VsZW1lbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudCA9IHRoaXMucHJlcGFyZVZpZGVvRWxlbWVudCh2aWRlb1NvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVmlkZW9Tb3VyY2UodmlkZW9FbGVtZW50LCBzdHJlYW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZGVvRWxlbWVudCA9IHZpZGVvRWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGxheVZpZGVvT25Mb2FkQXN5bmModmlkZW9FbGVtZW50KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB2aWRlb0VsZW1lbnRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50XHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5wbGF5VmlkZW9PbkxvYWRBc3luYyA9IGZ1bmN0aW9uICh2aWRlb0VsZW1lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHJldHVybiBfdGhpcy5wbGF5VmlkZW9PbkxvYWQodmlkZW9FbGVtZW50LCBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlKCk7IH0pOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGxpc3RlbmVycyBhbmQgY2FsbGJhY2tzIHRvIHRoZSB2aWRlb0VsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSBjYWxsYmFja0ZuXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5wbGF5VmlkZW9PbkxvYWQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2FsbGJhY2tGbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zdG9wU3RyZWFtcygpOyB9O1xyXG4gICAgICAgIHRoaXMudmlkZW9DYW5QbGF5TGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy50cnlQbGF5VmlkZW8oZWxlbWVudCk7IH07XHJcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMudmlkZW9FbmRlZExpc3RlbmVyKTtcclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCB0aGlzLnZpZGVvQ2FuUGxheUxpc3RlbmVyKTtcclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXlpbmcnLCBjYWxsYmFja0ZuKTtcclxuICAgICAgICAvLyBpZiBjYW5wbGF5IHdhcyBhbHJlYWR5IGZpcmVkLCB3ZSB3b24ndCBrbm93IHdoZW4gdG8gcGxheSwgc28ganVzdCBnaXZlIGl0IGEgdHJ5XHJcbiAgICAgICAgdGhpcy50cnlQbGF5VmlkZW8oZWxlbWVudCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZpZGVvIGVsZW1lbnQgaXMgY3VycmVudGx5IHBsYXlpbmcuXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5pc1ZpZGVvUGxheWluZyA9IGZ1bmN0aW9uICh2aWRlbykge1xyXG4gICAgICAgIHJldHVybiB2aWRlby5jdXJyZW50VGltZSA+IDAgJiYgIXZpZGVvLnBhdXNlZCAmJiAhdmlkZW8uZW5kZWQgJiYgdmlkZW8ucmVhZHlTdGF0ZSA+IDI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBKdXN0IHRyaWVzIHRvIHBsYXkgdGhlIHZpZGVvIGFuZCBsb2dzIGFueSBlcnJvcnMuXHJcbiAgICAgKiBUaGUgcGxheSBjYWxsIGlzIG9ubHkgbWFkZSBpcyB0aGUgdmlkZW8gaXMgbm90IGFscmVhZHkgcGxheWluZy5cclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLnRyeVBsYXlWaWRlbyA9IGZ1bmN0aW9uICh2aWRlb0VsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXlpbmcodmlkZW9FbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUcnlpbmcgdG8gcGxheSB2aWRlbyB0aGF0IGlzIGFscmVhZHkgcGxheWluZy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB2aWRlb0VsZW1lbnQucGxheSgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJdCB3YXMgbm90IHBvc3NpYmxlIHRvIHBsYXkgdGhlIHZpZGVvLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2hlcyBhbmQgdmFsaWRhdGVzIGEgbWVkaWEgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmdldE1lZGlhRWxlbWVudCA9IGZ1bmN0aW9uIChtZWRpYUVsZW1lbnRJZCwgdHlwZSkge1xyXG4gICAgICAgIHZhciBtZWRpYUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChtZWRpYUVsZW1lbnRJZCk7XHJcbiAgICAgICAgaWYgKCFtZWRpYUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdChcImVsZW1lbnQgd2l0aCBpZCAnXCIgKyBtZWRpYUVsZW1lbnRJZCArIFwiJyBub3QgZm91bmRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZWRpYUVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gdHlwZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoXCJlbGVtZW50IHdpdGggaWQgJ1wiICsgbWVkaWFFbGVtZW50SWQgKyBcIicgbXVzdCBiZSBhbiBcIiArIHR5cGUgKyBcIiBlbGVtZW50XCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWVkaWFFbGVtZW50O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyB0aGUgYmFyY29kZSBmcm9tIGFuIGltYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50KX0gW3NvdXJjZV0gVGhlIGltYWdlIGVsZW1lbnQgdGhhdCBjYW4gYmUgZWl0aGVyIGFuIGVsZW1lbnQgaWQgb3IgdGhlIGVsZW1lbnQgaXRzZWxmLiBDYW4gYmUgdW5kZWZpbmVkIGluIHdoaWNoIGNhc2UgdGhlIGRlY29kaW5nIHdpbGwgYmUgZG9uZSBmcm9tIHRoZSBpbWFnZVVybCBwYXJhbWV0ZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VybF1cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlc3VsdD59IFRoZSBkZWNvZGluZyByZXN1bHQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlck9mIEJyb3dzZXJDb2RlUmVhZGVyXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tSW1hZ2UgPSBmdW5jdGlvbiAoc291cmNlLCB1cmwpIHtcclxuICAgICAgICBpZiAoIXNvdXJjZSAmJiAhdXJsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ2VpdGhlciBpbWFnZUVsZW1lbnQgd2l0aCBhIHNyYyBzZXQgb3IgYW4gdXJsIG11c3QgYmUgcHJvdmlkZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVybCAmJiAhc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21JbWFnZVVybCh1cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGcm9tSW1hZ2VFbGVtZW50KHNvdXJjZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIHRoZSBiYXJjb2RlIGZyb20gYSB2aWRlby5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8SFRNTEltYWdlRWxlbWVudCl9IFtzb3VyY2VdIFRoZSBpbWFnZSBlbGVtZW50IHRoYXQgY2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIHRoZSBlbGVtZW50IGl0c2VsZi4gQ2FuIGJlIHVuZGVmaW5lZCBpbiB3aGljaCBjYXNlIHRoZSBkZWNvZGluZyB3aWxsIGJlIGRvbmUgZnJvbSB0aGUgaW1hZ2VVcmwgcGFyYW1ldGVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt1cmxdXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlRnJvbVZpZGVvID0gZnVuY3Rpb24gKHNvdXJjZSwgdXJsKSB7XHJcbiAgICAgICAgaWYgKCFzb3VyY2UgJiYgIXVybCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdFaXRoZXIgYW4gZWxlbWVudCB3aXRoIGEgc3JjIHNldCBvciBhbiBVUkwgbXVzdCBiZSBwcm92aWRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXJsICYmICFzb3VyY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRnJvbVZpZGVvVXJsKHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21WaWRlb0VsZW1lbnQoc291cmNlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgY29udGludW91c2x5IHRoZSBiYXJjb2RlIGZyb20gYSB2aWRlby5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8SFRNTEltYWdlRWxlbWVudCl9IFtzb3VyY2VdIFRoZSBpbWFnZSBlbGVtZW50IHRoYXQgY2FuIGJlIGVpdGhlciBhbiBlbGVtZW50IGlkIG9yIHRoZSBlbGVtZW50IGl0c2VsZi4gQ2FuIGJlIHVuZGVmaW5lZCBpbiB3aGljaCBjYXNlIHRoZSBkZWNvZGluZyB3aWxsIGJlIGRvbmUgZnJvbSB0aGUgaW1hZ2VVcmwgcGFyYW1ldGVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt1cmxdXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXN1bHQ+fSBUaGUgZGVjb2RpbmcgcmVzdWx0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxyXG4gICAgICpcclxuICAgICAqIEBleHBlcmltZW50YWxcclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZUZyb21WaWRlb0NvbnRpbnVvdXNseSA9IGZ1bmN0aW9uIChzb3VyY2UsIHVybCwgY2FsbGJhY2tGbikge1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHNvdXJjZSAmJiB1bmRlZmluZWQgPT09IHVybCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdFaXRoZXIgYW4gZWxlbWVudCB3aXRoIGEgc3JjIHNldCBvciBhbiBVUkwgbXVzdCBiZSBwcm92aWRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXJsICYmICFzb3VyY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlRnJvbVZpZGVvVXJsQ29udGludW91c2x5KHVybCwgY2FsbGJhY2tGbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZyb21WaWRlb0VsZW1lbnRDb250aW51b3VzbHkoc291cmNlLCBjYWxsYmFja0ZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgc29tZXRoaW5nIGZyb20gYW4gaW1hZ2UgSFRNTCBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlRnJvbUltYWdlRWxlbWVudCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICBpZiAoIXNvdXJjZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdBbiBpbWFnZSBlbGVtZW50IG11c3QgYmUgcHJvdmlkZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucHJlcGFyZUltYWdlRWxlbWVudChzb3VyY2UpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VFbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB2YXIgdGFzaztcclxuICAgICAgICBpZiAodGhpcy5pc0ltYWdlTG9hZGVkKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHRhc2sgPSB0aGlzLmRlY29kZU9uY2UoZWxlbWVudCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGFzayA9IHRoaXMuX2RlY29kZU9uTG9hZEltYWdlKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFzaztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgc29tZXRoaW5nIGZyb20gYW4gaW1hZ2UgSFRNTCBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlRnJvbVZpZGVvRWxlbWVudCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2RlY29kZUZyb21WaWRlb0VsZW1lbnRTZXR1cChzb3VyY2UpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVPbkxvYWRWaWRlbyhlbGVtZW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgc29tZXRoaW5nIGZyb20gYW4gaW1hZ2UgSFRNTCBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlRnJvbVZpZGVvRWxlbWVudENvbnRpbnVvdXNseSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrRm4pIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2RlY29kZUZyb21WaWRlb0VsZW1lbnRTZXR1cChzb3VyY2UpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVPbkxvYWRWaWRlb0NvbnRpbnVvdXNseShlbGVtZW50LCBjYWxsYmFja0ZuKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgdGhlIHZpZGVvIHNvdXJjZSBzbyBpdCBjYW4gYmUgZGVjb2RlZCB3aGVuIGxvYWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc291cmNlIFRoZSB2aWRlbyBzb3VyY2UgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLl9kZWNvZGVGcm9tVmlkZW9FbGVtZW50U2V0dXAgPSBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnQSB2aWRlbyBlbGVtZW50IG11c3QgYmUgcHJvdmlkZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucHJlcGFyZVZpZGVvRWxlbWVudChzb3VyY2UpO1xyXG4gICAgICAgIC8vIGRlZmluZXMgdGhlIHZpZGVvIGVsZW1lbnQgYmVmb3JlIHN0YXJ0cyBkZWNvZGluZ1xyXG4gICAgICAgIHRoaXMudmlkZW9FbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgYW4gaW1hZ2UgZnJvbSBhIFVSTC5cclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZUZyb21JbWFnZVVybCA9IGZ1bmN0aW9uICh1cmwpIHtcclxuICAgICAgICBpZiAoIXVybCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdBbiBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wcmVwYXJlSW1hZ2VFbGVtZW50KCk7XHJcbiAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICAgIHZhciBkZWNvZGVUYXNrID0gdGhpcy5fZGVjb2RlT25Mb2FkSW1hZ2UoZWxlbWVudCk7XHJcbiAgICAgICAgZWxlbWVudC5zcmMgPSB1cmw7XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZVRhc2s7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGVzIGFuIGltYWdlIGZyb20gYSBVUkwuXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVGcm9tVmlkZW9VcmwgPSBmdW5jdGlvbiAodXJsKSB7XHJcbiAgICAgICAgaWYgKCF1cmwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnQW4gVVJMIG11c3QgYmUgcHJvdmlkZWQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICAvLyBjcmVhdGVzIGEgbmV3IGVsZW1lbnRcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucHJlcGFyZVZpZGVvRWxlbWVudCgpO1xyXG4gICAgICAgIHZhciBkZWNvZGVUYXNrID0gdGhpcy5kZWNvZGVGcm9tVmlkZW9FbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICAgIGVsZW1lbnQuc3JjID0gdXJsO1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVUYXNrO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVjb2RlcyBhbiBpbWFnZSBmcm9tIGEgVVJMLlxyXG4gICAgICpcclxuICAgICAqIEBleHBlcmltZW50YWxcclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZUZyb21WaWRlb1VybENvbnRpbnVvdXNseSA9IGZ1bmN0aW9uICh1cmwsIGNhbGxiYWNrRm4pIHtcclxuICAgICAgICBpZiAoIXVybCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdBbiBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIC8vIGNyZWF0ZXMgYSBuZXcgZWxlbWVudFxyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wcmVwYXJlVmlkZW9FbGVtZW50KCk7XHJcbiAgICAgICAgdmFyIGRlY29kZVRhc2sgPSB0aGlzLmRlY29kZUZyb21WaWRlb0VsZW1lbnRDb250aW51b3VzbHkoZWxlbWVudCwgY2FsbGJhY2tGbik7XHJcbiAgICAgICAgZWxlbWVudC5zcmMgPSB1cmw7XHJcbiAgICAgICAgcmV0dXJuIGRlY29kZVRhc2s7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLl9kZWNvZGVPbkxvYWRJbWFnZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5pbWFnZUxvYWRlZExpc3RlbmVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZGVjb2RlT25jZShlbGVtZW50LCBmYWxzZSwgdHJ1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpOyB9O1xyXG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBfdGhpcy5pbWFnZUxvYWRlZExpc3RlbmVyKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuX2RlY29kZU9uTG9hZFZpZGVvID0gZnVuY3Rpb24gKHZpZGVvRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxheXMgdGhlIHZpZGVvXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wbGF5VmlkZW9PbkxvYWRBc3luYyh2aWRlb0VsZW1lbnQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYXlzIHRoZSB2aWRlb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGVjb2RlT25jZSh2aWRlb0VsZW1lbnQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0cyBkZWNvZGluZyBhZnRlciBwbGF5ZWQgdGhlIHZpZGVvXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5fZGVjb2RlT25Mb2FkVmlkZW9Db250aW51b3VzbHkgPSBmdW5jdGlvbiAodmlkZW9FbGVtZW50LCBjYWxsYmFja0ZuKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBcclxuICAgICAgICAgICAgICAgICAgICAvLyBwbGF5cyB0aGUgdmlkZW9cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBsYXlWaWRlb09uTG9hZEFzeW5jKHZpZGVvRWxlbWVudCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxheXMgdGhlIHZpZGVvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnRzIGRlY29kaW5nIGFmdGVyIHBsYXllZCB0aGUgdmlkZW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVDb250aW51b3VzbHkodmlkZW9FbGVtZW50LCBjYWxsYmFja0ZuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuaXNJbWFnZUxvYWRlZCA9IGZ1bmN0aW9uIChpbWcpIHtcclxuICAgICAgICAvLyBEdXJpbmcgdGhlIG9ubG9hZCBldmVudCwgSUUgY29ycmVjdGx5IGlkZW50aWZpZXMgYW55IGltYWdlcyB0aGF0XHJcbiAgICAgICAgLy8gd2VyZW7igJl0IGRvd25sb2FkZWQgYXMgbm90IGNvbXBsZXRlLiBPdGhlcnMgc2hvdWxkIHRvby4gR2Vja28tYmFzZWRcclxuICAgICAgICAvLyBicm93c2VycyBhY3QgbGlrZSBOUzQgaW4gdGhhdCB0aGV5IHJlcG9ydCB0aGlzIGluY29ycmVjdGx5LlxyXG4gICAgICAgIGlmICghaW1nLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSG93ZXZlciwgdGhleSBkbyBoYXZlIHR3byB2ZXJ5IHVzZWZ1bCBwcm9wZXJ0aWVzOiBuYXR1cmFsV2lkdGggYW5kXHJcbiAgICAgICAgLy8gbmF0dXJhbEhlaWdodC4gVGhlc2UgZ2l2ZSB0aGUgdHJ1ZSBzaXplIG9mIHRoZSBpbWFnZS4gSWYgaXQgZmFpbGVkXHJcbiAgICAgICAgLy8gdG8gbG9hZCwgZWl0aGVyIG9mIHRoZXNlIHNob3VsZCBiZSB6ZXJvLlxyXG4gICAgICAgIGlmIChpbWcubmF0dXJhbFdpZHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm8gb3RoZXIgd2F5IG9mIGNoZWNraW5nOiBhc3N1bWUgaXTigJlzIG9rLlxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5wcmVwYXJlSW1hZ2VFbGVtZW50ID0gZnVuY3Rpb24gKGltYWdlU291cmNlKSB7XHJcbiAgICAgICAgdmFyIGltYWdlRWxlbWVudDtcclxuICAgICAgICBpZiAodHlwZW9mIGltYWdlU291cmNlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcclxuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LndpZHRoID0gMjAwO1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuaGVpZ2h0ID0gMjAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGltYWdlU291cmNlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQgPSB0aGlzLmdldE1lZGlhRWxlbWVudChpbWFnZVNvdXJjZSwgJ2ltZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW1hZ2VTb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGltYWdlRWxlbWVudCA9IGltYWdlU291cmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW1hZ2VFbGVtZW50O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIEhUTUxWaWRlb0VsZW1lbnQgZm9yIHNjYW5uaW5nIG9yIGNyZWF0ZXMgYSBuZXcgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2aWRlb1NvdXJjZSBUaGUgSFRNTFZpZGVvRWxlbWVudCB0byBiZSBzZXQuXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5wcmVwYXJlVmlkZW9FbGVtZW50ID0gZnVuY3Rpb24gKHZpZGVvU291cmNlKSB7XHJcbiAgICAgICAgdmFyIHZpZGVvRWxlbWVudDtcclxuICAgICAgICBpZiAoIXZpZGVvU291cmNlICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcclxuICAgICAgICAgICAgdmlkZW9FbGVtZW50LndpZHRoID0gMjAwO1xyXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuaGVpZ2h0ID0gMjAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHZpZGVvU291cmNlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQgPSB0aGlzLmdldE1lZGlhRWxlbWVudCh2aWRlb1NvdXJjZSwgJ3ZpZGVvJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2aWRlb1NvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgdmlkZW9FbGVtZW50ID0gdmlkZW9Tb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5lZWRlZCBmb3IgaU9TIDExXHJcbiAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b3BsYXknLCAndHJ1ZScpO1xyXG4gICAgICAgIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ211dGVkJywgJ3RydWUnKTtcclxuICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICd0cnVlJyk7XHJcbiAgICAgICAgcmV0dXJuIHZpZGVvRWxlbWVudDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRyaWVzIHRvIGRlY29kZSBmcm9tIHRoZSB2aWRlbyBpbnB1dCB1bnRpbCBpdCBmaW5kcyBzb21lIHZhbHVlLlxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlT25jZSA9IGZ1bmN0aW9uIChlbGVtZW50LCByZXRyeUlmTm90Rm91bmQsIHJldHJ5SWZDaGVja3N1bU9yRm9ybWF0RXJyb3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChyZXRyeUlmTm90Rm91bmQgPT09IHZvaWQgMCkgeyByZXRyeUlmTm90Rm91bmQgPSB0cnVlOyB9XHJcbiAgICAgICAgaWYgKHJldHJ5SWZDaGVja3N1bU9yRm9ybWF0RXJyb3IgPT09IHZvaWQgMCkgeyByZXRyeUlmQ2hlY2tzdW1PckZvcm1hdEVycm9yID0gdHJ1ZTsgfVxyXG4gICAgICAgIHRoaXMuX3N0b3BBc3luY0RlY29kZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuX3N0b3BBc3luY0RlY29kZSkge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ1ZpZGVvIHN0cmVhbSBoYXMgZW5kZWQgYmVmb3JlIGFueSBjb2RlIGNvdWxkIGJlIGRldGVjdGVkLicpKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLl9zdG9wQXN5bmNEZWNvZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBfdGhpcy5kZWNvZGUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpZk5vdEZvdW5kID0gcmV0cnlJZk5vdEZvdW5kICYmIGUgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNDaGVja3N1bU9yRm9ybWF0RXJyb3IgPSBlIGluc3RhbmNlb2YgQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0IHx8IGUgaW5zdGFuY2VvZiBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGlmQ2hlY2tzdW1PckZvcm1hdCA9IGlzQ2hlY2tzdW1PckZvcm1hdEVycm9yICYmIHJldHJ5SWZDaGVja3N1bU9yRm9ybWF0RXJyb3I7XHJcbiAgICAgICAgICAgICAgICBpZiAoaWZOb3RGb3VuZCB8fCBpZkNoZWNrc3VtT3JGb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0cnlpbmcgYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChsb29wLCBfdGhpcy5fdGltZUJldHdlZW5EZWNvZGluZ0F0dGVtcHRzLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyByZXR1cm4gbG9vcChyZXNvbHZlLCByZWplY3QpOyB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnRpbnVvdXNseSBkZWNvZGVzIGZyb20gdmlkZW8gaW5wdXQuXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVDb250aW51b3VzbHkgPSBmdW5jdGlvbiAoZWxlbWVudCwgY2FsbGJhY2tGbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fc3RvcENvbnRpbnVvdXNEZWNvZGUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLl9zdG9wQ29udGludW91c0RlY29kZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gX3RoaXMuZGVjb2RlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tGbihyZXN1bHQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChsb29wLCBfdGhpcy50aW1lQmV0d2VlblNjYW5zTWlsbGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tGbihudWxsLCBlKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc0NoZWNrc3VtT3JGb3JtYXRFcnJvciA9IGUgaW5zdGFuY2VvZiBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQgfHwgZSBpbnN0YW5jZW9mIEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgaXNOb3RGb3VuZCA9IGUgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGVja3N1bU9yRm9ybWF0RXJyb3IgfHwgaXNOb3RGb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeWluZyBhZ2FpblxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQobG9vcCwgX3RoaXMuX3RpbWVCZXR3ZWVuRGVjb2RpbmdBdHRlbXB0cyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGxvb3AoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIEJpbmFyeUJpdG1hcCBmb3IgeWEhIChhbmQgZGVjb2RlcyBpdClcclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgLy8gZ2V0IGJpbmFyeSBiaXRtYXAgZm9yIGRlY29kZSBmdW5jdGlvblxyXG4gICAgICAgIHZhciBiaW5hcnlCaXRtYXAgPSB0aGlzLmNyZWF0ZUJpbmFyeUJpdG1hcChlbGVtZW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVCaXRtYXAoYmluYXJ5Qml0bWFwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBiaW5hcnlCaXRtYXAgYmFzZWQgaW4gc29tZSBpbWFnZSBzb3VyY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG1lZGlhRWxlbWVudCBIVE1MIGVsZW1lbnQgY29udGFpbmluZyBkcmF3YWJsZSBpbWFnZSBzb3VyY2UuXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5jcmVhdGVCaW5hcnlCaXRtYXAgPSBmdW5jdGlvbiAobWVkaWFFbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0Q2FwdHVyZUNhbnZhc0NvbnRleHQobWVkaWFFbGVtZW50KTtcclxuICAgICAgICB0aGlzLmRyYXdJbWFnZU9uQ2FudmFzKGN0eCwgbWVkaWFFbGVtZW50KTtcclxuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5nZXRDYXB0dXJlQ2FudmFzKG1lZGlhRWxlbWVudCk7XHJcbiAgICAgICAgdmFyIGx1bWluYW5jZVNvdXJjZSA9IG5ldyBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZV8xLkhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlKGNhbnZhcyk7XHJcbiAgICAgICAgdmFyIGh5YnJpZEJpbmFyaXplciA9IG5ldyBIeWJyaWRCaW5hcml6ZXJfMS5kZWZhdWx0KGx1bWluYW5jZVNvdXJjZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlCaXRtYXBfMS5kZWZhdWx0KGh5YnJpZEJpbmFyaXplcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZ2V0Q2FwdHVyZUNhbnZhc0NvbnRleHQgPSBmdW5jdGlvbiAobWVkaWFFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmVDYW52YXNDb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5nZXRDYXB0dXJlQ2FudmFzKG1lZGlhRWxlbWVudCk7XHJcbiAgICAgICAgICAgIHZhciBjdHggPSBlbGVtLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FwdHVyZUNhbnZhc0NvbnRleHQgPSBjdHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNhcHR1cmVDYW52YXNDb250ZXh0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmdldENhcHR1cmVDYW52YXMgPSBmdW5jdGlvbiAobWVkaWFFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmVDYW52YXMpIHtcclxuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmNyZWF0ZUNhcHR1cmVDYW52YXMobWVkaWFFbGVtZW50KTtcclxuICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzID0gZWxlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FwdHVyZUNhbnZhcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE92ZXdyaXRpbmcgdGhpcyBhbGxvd3MgeW91IHRvIG1hbmlwdWxhdGUgdGhlIHNuYXBzaG90IGltYWdlIGluIGFueXdheSB5b3Ugd2FudCBiZWZvcmUgZGVjb2RlLlxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuZHJhd0ltYWdlT25DYW52YXMgPSBmdW5jdGlvbiAoY2FudmFzRWxlbWVudENvbnRleHQsIHNyY0VsZW1lbnQpIHtcclxuICAgICAgICBjYW52YXNFbGVtZW50Q29udGV4dC5kcmF3SW1hZ2Uoc3JjRWxlbWVudCwgMCwgMCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsIHRoZSBlbmNhcHN1bGF0ZWQgcmVhZGVycyBkZWNvZGVcclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmRlY29kZUJpdG1hcCA9IGZ1bmN0aW9uIChiaW5hcnlCaXRtYXApIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZWFkZXIuZGVjb2RlKGJpbmFyeUJpdG1hcCwgdGhpcy5faGludHMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICog8J+WjCBQcmVwYXJlcyB0aGUgY2FudmFzIGZvciBjYXB0dXJlIGFuZCBzY2FuIGZyYW1lcy5cclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmNyZWF0ZUNhcHR1cmVDYW52YXMgPSBmdW5jdGlvbiAobWVkaWFFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVzdHJveUNhcHR1cmVDYW52YXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgdmFyIHdpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBtZWRpYUVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlmIChtZWRpYUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aCA9IG1lZGlhRWxlbWVudC52aWRlb1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gbWVkaWFFbGVtZW50LnZpZGVvSGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG1lZGlhRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHdpZHRoID0gbWVkaWFFbGVtZW50Lm5hdHVyYWxXaWR0aCB8fCBtZWRpYUVsZW1lbnQud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBtZWRpYUVsZW1lbnQubmF0dXJhbEhlaWdodCB8fCBtZWRpYUVsZW1lbnQuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhbnZhc0VsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XHJcbiAgICAgICAgY2FudmFzRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xyXG4gICAgICAgIGNhbnZhc0VsZW1lbnQud2lkdGggPSB3aWR0aDtcclxuICAgICAgICBjYW52YXNFbGVtZW50LmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICByZXR1cm4gY2FudmFzRWxlbWVudDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRoZSBjb250aW51b3VzIHNjYW4gYW5kIGNsZWFucyB0aGUgc3RyZWFtLlxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuc3RvcFN0cmVhbXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5zdG9wKCk7IH0pO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmVhbSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0b3BBc3luY0RlY29kZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wQXN5bmNEZWNvZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0b3BDb250aW51b3VzRGVjb2RlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0b3BDb250aW51b3VzRGVjb2RlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBjb2RlIHJlYWRlciB0byB0aGUgaW5pdGlhbCBzdGF0ZS4gQ2FuY2VscyBhbnkgb25nb2luZyBiYXJjb2RlIHNjYW5uaW5nIGZyb20gdmlkZW8gb3IgY2FtZXJhLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJPZiBCcm93c2VyQ29kZVJlYWRlclxyXG4gICAgICovXHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3RvcHMgdGhlIGNhbWVyYSwgcHJldmlldyBhbmQgc2NhbiDwn5S0XHJcbiAgICAgICAgdGhpcy5zdG9wU3RyZWFtcygpO1xyXG4gICAgICAgIC8vIGNsZWFuIGFuZCBmb3JnZXQgYWJvdXQgSFRNTCBlbGVtZW50c1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lWaWRlb0VsZW1lbnQoKTtcclxuICAgICAgICB0aGlzLl9kZXN0cm95SW1hZ2VFbGVtZW50KCk7XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveUNhcHR1cmVDYW52YXMoKTtcclxuICAgIH07XHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuX2Rlc3Ryb3lWaWRlb0VsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnZpZGVvRWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpcnN0IGdpdmVzIGZyZWVkb24gdG8gdGhlIGVsZW1lbnQg8J+VilxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlkZW9FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy52aWRlb0VuZGVkTGlzdGVuZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMudmlkZW9QbGF5aW5nRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGxheWluZycsIHRoaXMudmlkZW9QbGF5aW5nRXZlbnRMaXN0ZW5lcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy52aWRlb0NhblBsYXlMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCB0aGlzLnZpZGVvQ2FuUGxheUxpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhlbiBmb3JnZXRzIGFib3V0IHRoYXQgZWxlbWVudCDwn5iiXHJcbiAgICAgICAgdGhpcy5jbGVhblZpZGVvU291cmNlKHRoaXMudmlkZW9FbGVtZW50KTtcclxuICAgICAgICB0aGlzLnZpZGVvRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICBCcm93c2VyQ29kZVJlYWRlci5wcm90b3R5cGUuX2Rlc3Ryb3lJbWFnZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmltYWdlRWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpcnN0IGdpdmVzIGZyZWVkb24gdG8gdGhlIGVsZW1lbnQg8J+VilxyXG4gICAgICAgIGlmICh1bmRlZmluZWQgIT09IHRoaXMuaW1hZ2VMb2FkZWRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5pbWFnZUxvYWRlZExpc3RlbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhlbiBmb3JnZXQgYWJvdXQgdGhhdCBlbGVtZW50IPCfmKJcclxuICAgICAgICB0aGlzLmltYWdlRWxlbWVudC5zcmMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5pbWFnZUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcclxuICAgICAgICB0aGlzLmltYWdlRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFucyBjYW52YXMgcmVmZXJlbmNlcyDwn5aMXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5fZGVzdHJveUNhcHR1cmVDYW52YXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdGhlbiBmb3JnZXQgYWJvdXQgdGhhdCBlbGVtZW50IPCfmKJcclxuICAgICAgICB0aGlzLmNhcHR1cmVDYW52YXNDb250ZXh0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuY2FwdHVyZUNhbnZhcyA9IHVuZGVmaW5lZDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlZmluZXMgd2hhdCB0aGUgdmlkZW9FbGVtZW50IHNyYyB3aWxsIGJlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2aWRlb0VsZW1lbnRcclxuICAgICAqIEBwYXJhbSBzdHJlYW1cclxuICAgICAqL1xyXG4gICAgQnJvd3NlckNvZGVSZWFkZXIucHJvdG90eXBlLmFkZFZpZGVvU291cmNlID0gZnVuY3Rpb24gKHZpZGVvRWxlbWVudCwgc3RyZWFtKSB7XHJcbiAgICAgICAgLy8gT2xkZXIgYnJvd3NlcnMgbWF5IG5vdCBoYXZlIGBzcmNPYmplY3RgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gQG5vdGUgVGhyb3dzIEV4Y2VwdGlvbiBpZiBpbnRlcnJ1cHRlZCBieSBhIG5ldyBsb2FkZWQgcmVxdWVzdFxyXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIC8vIEBub3RlIEF2b2lkIHVzaW5nIHRoaXMgaW4gbmV3IGJyb3dzZXJzLCBhcyBpdCBpcyBnb2luZyBhd2F5LlxyXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChzdHJlYW0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVuYmluZHMgYSBIVE1MIHZpZGVvIHNyYyBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmlkZW9FbGVtZW50XHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJDb2RlUmVhZGVyLnByb3RvdHlwZS5jbGVhblZpZGVvU291cmNlID0gZnVuY3Rpb24gKHZpZGVvRWxlbWVudCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zcmMgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWRlb0VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdzcmMnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQnJvd3NlckNvZGVSZWFkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQnJvd3NlckNvZGVSZWFkZXIgPSBCcm93c2VyQ29kZVJlYWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlckNvZGVSZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBCcm93c2VyQ29kZVJlYWRlcl8xID0gcmVxdWlyZShcIi4vQnJvd3NlckNvZGVSZWFkZXJcIik7XHJcbnZhciBEYXRhTWF0cml4UmVhZGVyXzEgPSByZXF1aXJlKFwiLi4vY29yZS9kYXRhbWF0cml4L0RhdGFNYXRyaXhSZWFkZXJcIik7XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcclxuICpcclxuICogUVIgQ29kZSByZWFkZXIgdG8gdXNlIGZyb20gYnJvd3Nlci5cclxuICovXHJcbnZhciBCcm93c2VyRGF0YW1hdHJpeENvZGVSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEJyb3dzZXJRUkNvZGVSZWFkZXIuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3RpbWVCZXR3ZWVuU2NhbnNNaWxsaXM9NTAwXSB0aGUgdGltZSBkZWxheSBiZXR3ZWVuIHN1YnNlcXVlbnQgZGVjb2RlIHRyaWVzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJyb3dzZXJEYXRhbWF0cml4Q29kZVJlYWRlcih0aW1lQmV0d2VlblNjYW5zTWlsbGlzKSB7XHJcbiAgICAgICAgaWYgKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPT09IHZvaWQgMCkgeyB0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwOyB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG5ldyBEYXRhTWF0cml4UmVhZGVyXzEuZGVmYXVsdCgpLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJyb3dzZXJEYXRhbWF0cml4Q29kZVJlYWRlcjtcclxufShCcm93c2VyQ29kZVJlYWRlcl8xLkJyb3dzZXJDb2RlUmVhZGVyKSk7XHJcbmV4cG9ydHMuQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyID0gQnJvd3NlckRhdGFtYXRyaXhDb2RlUmVhZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ccm93c2VyRGF0YW1hdHJpeENvZGVSZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBCcm93c2VyQ29kZVJlYWRlcl8xID0gcmVxdWlyZShcIi4vQnJvd3NlckNvZGVSZWFkZXJcIik7XHJcbnZhciBNdWx0aUZvcm1hdFJlYWRlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvTXVsdGlGb3JtYXRSZWFkZXJcIik7XHJcbnZhciBCcm93c2VyTXVsdGlGb3JtYXRSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyKGhpbnRzLCB0aW1lQmV0d2VlblNjYW5zTWlsbGlzKSB7XHJcbiAgICAgICAgaWYgKGhpbnRzID09PSB2b2lkIDApIHsgaGludHMgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPT09IHZvaWQgMCkgeyB0aW1lQmV0d2VlblNjYW5zTWlsbGlzID0gNTAwOyB9XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IE11bHRpRm9ybWF0UmVhZGVyXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIHJlYWRlci5zZXRIaW50cyhoaW50cyk7XHJcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByZWFkZXIsIHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVyd3JpdGUgZGVjb2RlQml0bWFwIHRvIGNhbGwgZGVjb2RlV2l0aFN0YXRlLCB3aGljaCB3aWxsIHBheVxyXG4gICAgICogYXR0ZW50aW9uIHRvIHRoZSBoaW50cyBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJNdWx0aUZvcm1hdFJlYWRlci5wcm90b3R5cGUuZGVjb2RlQml0bWFwID0gZnVuY3Rpb24gKGJpbmFyeUJpdG1hcCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRlci5kZWNvZGVXaXRoU3RhdGUoYmluYXJ5Qml0bWFwKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyO1xyXG59KEJyb3dzZXJDb2RlUmVhZGVyXzEuQnJvd3NlckNvZGVSZWFkZXIpKTtcclxuZXhwb3J0cy5Ccm93c2VyTXVsdGlGb3JtYXRSZWFkZXIgPSBCcm93c2VyTXVsdGlGb3JtYXRSZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJyb3dzZXJNdWx0aUZvcm1hdFJlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEJyb3dzZXJDb2RlUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9Ccm93c2VyQ29kZVJlYWRlclwiKTtcclxudmFyIFBERjQxN1JlYWRlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvcGRmNDE3L1BERjQxN1JlYWRlclwiKTtcclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxyXG4gKlxyXG4gKiBRUiBDb2RlIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxyXG4gKi9cclxudmFyIEJyb3dzZXJQREY0MTdSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQnJvd3NlclBERjQxN1JlYWRlciwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCcm93c2VyUERGNDE3UmVhZGVyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IGRlY29kZSB0cmllc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCcm93c2VyUERGNDE3UmVhZGVyKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpIHtcclxuICAgICAgICBpZiAodGltZUJldHdlZW5TY2Fuc01pbGxpcyA9PT0gdm9pZCAwKSB7IHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDA7IH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmV3IFBERjQxN1JlYWRlcl8xLmRlZmF1bHQoKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBCcm93c2VyUERGNDE3UmVhZGVyO1xyXG59KEJyb3dzZXJDb2RlUmVhZGVyXzEuQnJvd3NlckNvZGVSZWFkZXIpKTtcclxuZXhwb3J0cy5Ccm93c2VyUERGNDE3UmVhZGVyID0gQnJvd3NlclBERjQxN1JlYWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlclBERjQxN1JlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEJyb3dzZXJDb2RlUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9Ccm93c2VyQ29kZVJlYWRlclwiKTtcclxudmFyIFFSQ29kZVJlYWRlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvcXJjb2RlL1FSQ29kZVJlYWRlclwiKTtcclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkIE1vdmluZyB0byBAenhpbmcvYnJvd3NlclxyXG4gKlxyXG4gKiBRUiBDb2RlIHJlYWRlciB0byB1c2UgZnJvbSBicm93c2VyLlxyXG4gKi9cclxudmFyIEJyb3dzZXJRUkNvZGVSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQnJvd3NlclFSQ29kZVJlYWRlciwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBCcm93c2VyUVJDb2RlUmVhZGVyLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lQmV0d2VlblNjYW5zTWlsbGlzPTUwMF0gdGhlIHRpbWUgZGVsYXkgYmV0d2VlbiBzdWJzZXF1ZW50IGRlY29kZSB0cmllc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCcm93c2VyUVJDb2RlUmVhZGVyKHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMpIHtcclxuICAgICAgICBpZiAodGltZUJldHdlZW5TY2Fuc01pbGxpcyA9PT0gdm9pZCAwKSB7IHRpbWVCZXR3ZWVuU2NhbnNNaWxsaXMgPSA1MDA7IH1cclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbmV3IFFSQ29kZVJlYWRlcl8xLmRlZmF1bHQoKSwgdGltZUJldHdlZW5TY2Fuc01pbGxpcykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBCcm93c2VyUVJDb2RlUmVhZGVyO1xyXG59KEJyb3dzZXJDb2RlUmVhZGVyXzEuQnJvd3NlckNvZGVSZWFkZXIpKTtcclxuZXhwb3J0cy5Ccm93c2VyUVJDb2RlUmVhZGVyID0gQnJvd3NlclFSQ29kZVJlYWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlclFSQ29kZVJlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRW5jb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL0VuY29kZUhpbnRUeXBlXCIpO1xyXG52YXIgRW5jb2Rlcl8xID0gcmVxdWlyZShcIi4uL2NvcmUvcXJjb2RlL2VuY29kZXIvRW5jb2RlclwiKTtcclxudmFyIEVycm9yQ29ycmVjdGlvbkxldmVsXzEgPSByZXF1aXJlKFwiLi4vY29yZS9xcmNvZGUvZGVjb2Rlci9FcnJvckNvcnJlY3Rpb25MZXZlbFwiKTtcclxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL2NvcmUvSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xyXG52YXIgSWxsZWdhbFN0YXRlRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vY29yZS9JbGxlZ2FsU3RhdGVFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcclxuICovXHJcbnZhciBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQnJvd3NlclFSQ29kZVN2Z1dyaXRlcigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGFuZCByZW5kZXJzIGEgUVJDb2RlIFNWRyBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb250ZW50c1xyXG4gICAgICogQHBhcmFtIHdpZHRoXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0gaGludHNcclxuICAgICAqL1xyXG4gICAgQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY29udGVudHMsIHdpZHRoLCBoZWlnaHQsIGhpbnRzKSB7XHJcbiAgICAgICAgaWYgKGhpbnRzID09PSB2b2lkIDApIHsgaGludHMgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKGNvbnRlbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnRm91bmQgZW1wdHkgY29udGVudHMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgKGZvcm1hdCAhPSBCYXJjb2RlRm9ybWF0LlFSX0NPREUpIHtcclxuICAgICAgICAvLyAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oXCJDYW4gb25seSBlbmNvZGUgUVJfQ09ERSwgYnV0IGdvdCBcIiArIGZvcm1hdClcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgaWYgKHdpZHRoIDwgMCB8fCBoZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdSZXF1ZXN0ZWQgZGltZW5zaW9ucyBhcmUgdG9vIHNtYWxsOiAnICsgd2lkdGggKyAneCcgKyBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBFcnJvckNvcnJlY3Rpb25MZXZlbF8xLmRlZmF1bHQuTDtcclxuICAgICAgICB2YXIgcXVpZXRab25lID0gQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5RVUlFVF9aT05FX1NJWkU7XHJcbiAgICAgICAgaWYgKGhpbnRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQuRVJST1JfQ09SUkVDVElPTikpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yQ29ycmVjdGlvbkxldmVsID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWxfMS5kZWZhdWx0LmZyb21TdHJpbmcoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5FUlJPUl9DT1JSRUNUSU9OKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0Lk1BUkdJTikpIHtcclxuICAgICAgICAgICAgICAgIHF1aWV0Wm9uZSA9IE51bWJlci5wYXJzZUludChoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0Lk1BUkdJTikudG9TdHJpbmcoKSwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb2RlID0gRW5jb2Rlcl8xLmRlZmF1bHQuZW5jb2RlKGNvbnRlbnRzLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgaGludHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJlc3VsdChjb2RlLCB3aWR0aCwgaGVpZ2h0LCBxdWlldFpvbmUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgcmVzdWx0IGFuZCB0aGVuIGFwcGVuZHMgaXQgdG8gdGhlIERPTS5cclxuICAgICAqL1xyXG4gICAgQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5wcm90b3R5cGUud3JpdGVUb0RvbSA9IGZ1bmN0aW9uIChjb250YWluZXJFbGVtZW50LCBjb250ZW50cywgd2lkdGgsIGhlaWdodCwgaGludHMpIHtcclxuICAgICAgICBpZiAoaGludHMgPT09IHZvaWQgMCkgeyBoaW50cyA9IG51bGw7IH1cclxuICAgICAgICBpZiAodHlwZW9mIGNvbnRhaW5lckVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lckVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3ZnRWxlbWVudCA9IHRoaXMud3JpdGUoY29udGVudHMsIHdpZHRoLCBoZWlnaHQsIGhpbnRzKTtcclxuICAgICAgICBpZiAoY29udGFpbmVyRWxlbWVudClcclxuICAgICAgICAgICAgY29udGFpbmVyRWxlbWVudC5hcHBlbmRDaGlsZChzdmdFbGVtZW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIE5vdGUgdGhhdCB0aGUgaW5wdXQgbWF0cml4IHVzZXMgMCA9PSB3aGl0ZSwgMSA9PSBibGFjay5cclxuICAgICAqIFRoZSBvdXRwdXQgbWF0cml4IHVzZXMgMCA9PSBibGFjaywgMjU1ID09IHdoaXRlIChpLmUuIGFuIDggYml0IGdyZXlzY2FsZSBiaXRtYXApLlxyXG4gICAgICovXHJcbiAgICBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJSZXN1bHQgPSBmdW5jdGlvbiAoY29kZSwgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIHF1aWV0Wm9uZSAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gY29kZS5nZXRNYXRyaXgoKTtcclxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlucHV0V2lkdGggPSBpbnB1dC5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHZhciBpbnB1dEhlaWdodCA9IGlucHV0LmdldEhlaWdodCgpO1xyXG4gICAgICAgIHZhciBxcldpZHRoID0gaW5wdXRXaWR0aCArIChxdWlldFpvbmUgKiAyKTtcclxuICAgICAgICB2YXIgcXJIZWlnaHQgPSBpbnB1dEhlaWdodCArIChxdWlldFpvbmUgKiAyKTtcclxuICAgICAgICB2YXIgb3V0cHV0V2lkdGggPSBNYXRoLm1heCh3aWR0aCwgcXJXaWR0aCk7XHJcbiAgICAgICAgdmFyIG91dHB1dEhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgcXJIZWlnaHQpO1xyXG4gICAgICAgIHZhciBtdWx0aXBsZSA9IE1hdGgubWluKE1hdGguZmxvb3Iob3V0cHV0V2lkdGggLyBxcldpZHRoKSwgTWF0aC5mbG9vcihvdXRwdXRIZWlnaHQgLyBxckhlaWdodCkpO1xyXG4gICAgICAgIC8vIFBhZGRpbmcgaW5jbHVkZXMgYm90aCB0aGUgcXVpZXQgem9uZSBhbmQgdGhlIGV4dHJhIHdoaXRlIHBpeGVscyB0byBhY2NvbW1vZGF0ZSB0aGUgcmVxdWVzdGVkXHJcbiAgICAgICAgLy8gZGltZW5zaW9ucy4gRm9yIGV4YW1wbGUsIGlmIGlucHV0IGlzIDI1eDI1IHRoZSBRUiB3aWxsIGJlIDMzeDMzIGluY2x1ZGluZyB0aGUgcXVpZXQgem9uZS5cclxuICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdGVkIHNpemUgaXMgMjAweDE2MCwgdGhlIG11bHRpcGxlIHdpbGwgYmUgNCwgZm9yIGEgUVIgb2YgMTMyeDEzMi4gVGhlc2Ugd2lsbFxyXG4gICAgICAgIC8vIGhhbmRsZSBhbGwgdGhlIHBhZGRpbmcgZnJvbSAxMDB4MTAwICh0aGUgYWN0dWFsIFFSKSB1cCB0byAyMDB4MTYwLlxyXG4gICAgICAgIHZhciBsZWZ0UGFkZGluZyA9IE1hdGguZmxvb3IoKG91dHB1dFdpZHRoIC0gKGlucHV0V2lkdGggKiBtdWx0aXBsZSkpIC8gMik7XHJcbiAgICAgICAgdmFyIHRvcFBhZGRpbmcgPSBNYXRoLmZsb29yKChvdXRwdXRIZWlnaHQgLSAoaW5wdXRIZWlnaHQgKiBtdWx0aXBsZSkpIC8gMik7XHJcbiAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSB0aGlzLmNyZWF0ZVNWR0VsZW1lbnQob3V0cHV0V2lkdGgsIG91dHB1dEhlaWdodCk7XHJcbiAgICAgICAgZm9yICh2YXIgaW5wdXRZID0gMCwgb3V0cHV0WSA9IHRvcFBhZGRpbmc7IGlucHV0WSA8IGlucHV0SGVpZ2h0OyBpbnB1dFkrKywgb3V0cHV0WSArPSBtdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAvLyBXcml0ZSB0aGUgY29udGVudHMgb2YgdGhpcyByb3cgb2YgdGhlIGJhcmNvZGVcclxuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRYID0gMCwgb3V0cHV0WCA9IGxlZnRQYWRkaW5nOyBpbnB1dFggPCBpbnB1dFdpZHRoOyBpbnB1dFgrKywgb3V0cHV0WCArPSBtdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmdldChpbnB1dFgsIGlucHV0WSkgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3ZnUmVjdEVsZW1lbnQgPSB0aGlzLmNyZWF0ZVN2Z1JlY3RFbGVtZW50KG91dHB1dFgsIG91dHB1dFksIG11bHRpcGxlLCBtdWx0aXBsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3ZnRWxlbWVudC5hcHBlbmRDaGlsZChzdmdSZWN0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgU1ZHIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHcgU1ZHJ3Mgd2lkdGggYXR0cmlidXRlXHJcbiAgICAgKiBAcGFyYW0gaCBTVkcncyBoZWlnaHQgYXR0cmlidXRlXHJcbiAgICAgKi9cclxuICAgIEJyb3dzZXJRUkNvZGVTdmdXcml0ZXIucHJvdG90eXBlLmNyZWF0ZVNWR0VsZW1lbnQgPSBmdW5jdGlvbiAodywgaCkge1xyXG4gICAgICAgIHZhciBzdmdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKEJyb3dzZXJRUkNvZGVTdmdXcml0ZXIuU1ZHX05TLCAnc3ZnJyk7XHJcbiAgICAgICAgc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0Jywgdy50b1N0cmluZygpKTtcclxuICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgU1ZHIHJlY3QgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geCBFbGVtZW50J3MgeCBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0geSBFbGVtZW50J3MgeSBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gdyBFbGVtZW50J3Mgd2lkdGggYXR0cmlidXRlXHJcbiAgICAgKiBAcGFyYW0gaCBFbGVtZW50J3MgaGVpZ2h0IGF0dHJpYnV0ZVxyXG4gICAgICovXHJcbiAgICBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLnByb3RvdHlwZS5jcmVhdGVTdmdSZWN0RWxlbWVudCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5TVkdfTlMsICdyZWN0Jyk7XHJcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneCcsIHgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAneScsIHkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnaGVpZ2h0Jywgdy50b1N0cmluZygpKTtcclxuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsICd3aWR0aCcsIGgudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAnZmlsbCcsICcjMDAwMDAwJyk7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9O1xyXG4gICAgQnJvd3NlclFSQ29kZVN2Z1dyaXRlci5RVUlFVF9aT05FX1NJWkUgPSA0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTVkcgbWFya3VwIE5hbWVTcGFjZVxyXG4gICAgICovXHJcbiAgICBCcm93c2VyUVJDb2RlU3ZnV3JpdGVyLlNWR19OUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XHJcbiAgICByZXR1cm4gQnJvd3NlclFSQ29kZVN2Z1dyaXRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5Ccm93c2VyUVJDb2RlU3ZnV3JpdGVyID0gQnJvd3NlclFSQ29kZVN2Z1dyaXRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnJvd3NlclFSQ29kZVN2Z1dyaXRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEludmVydGVkTHVtaW5hbmNlU291cmNlXzEgPSByZXF1aXJlKFwiLi4vY29yZS9JbnZlcnRlZEx1bWluYW5jZVNvdXJjZVwiKTtcclxudmFyIEx1bWluYW5jZVNvdXJjZV8xID0gcmVxdWlyZShcIi4uL2NvcmUvTHVtaW5hbmNlU291cmNlXCIpO1xyXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vY29yZS9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcclxuICovXHJcbnZhciBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlKGNhbnZhcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jYW52YXMgPSBjYW52YXM7XHJcbiAgICAgICAgX3RoaXMudGVtcENhbnZhc0VsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIF90aGlzLmJ1ZmZlciA9IEhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLm1ha2VCdWZmZXJGcm9tQ2FudmFzSW1hZ2VEYXRhKGNhbnZhcyk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UubWFrZUJ1ZmZlckZyb21DYW52YXNJbWFnZURhdGEgPSBmdW5jdGlvbiAoY2FudmFzKSB7XHJcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS50b0dyYXlzY2FsZUJ1ZmZlcihpbWFnZURhdGEuZGF0YSwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS50b0dyYXlzY2FsZUJ1ZmZlciA9IGZ1bmN0aW9uIChpbWFnZUJ1ZmZlciwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHZhciBncmF5c2NhbGVCdWZmZXIgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGggKiBoZWlnaHQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMCwgbGVuZ3RoXzEgPSBpbWFnZUJ1ZmZlci5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgaSArPSA0LCBqKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyYXkgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGltYWdlQnVmZmVyW2kgKyAzXTtcclxuICAgICAgICAgICAgLy8gVGhlIGNvbG9yIG9mIGZ1bGx5LXRyYW5zcGFyZW50IHBpeGVscyBpcyBpcnJlbGV2YW50LiBUaGV5IGFyZSBvZnRlbiwgdGVjaG5pY2FsbHksIGZ1bGx5LXRyYW5zcGFyZW50XHJcbiAgICAgICAgICAgIC8vIGJsYWNrICgwIGFscGhhLCBhbmQgdGhlbiAwIFJHQikuIFRoZXkgYXJlIG9mdGVuIHVzZWQsIG9mIGNvdXJzZSBhcyB0aGUgXCJ3aGl0ZVwiIGFyZWEgaW4gYVxyXG4gICAgICAgICAgICAvLyBiYXJjb2RlIGltYWdlLiBGb3JjZSBhbnkgc3VjaCBwaXhlbCB0byBiZSB3aGl0ZTpcclxuICAgICAgICAgICAgaWYgKGFscGhhID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBncmF5ID0gMHhGRjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBwaXhlbFIgPSBpbWFnZUJ1ZmZlcltpXTtcclxuICAgICAgICAgICAgICAgIHZhciBwaXhlbEcgPSBpbWFnZUJ1ZmZlcltpICsgMV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcGl4ZWxCID0gaW1hZ2VCdWZmZXJbaSArIDJdO1xyXG4gICAgICAgICAgICAgICAgLy8gLjI5OVIgKyAwLjU4N0cgKyAwLjExNEIgKFlVVi9ZSVEgZm9yIFBBTCBhbmQgTlRTQyksXHJcbiAgICAgICAgICAgICAgICAvLyAoMzA2KlIpID4+IDEwIGlzIGFwcHJveGltYXRlbHkgZXF1YWwgdG8gUiowLjI5OSwgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgICAgICAgLy8gMHgyMDAgPj4gMTAgaXMgMC41LCBpdCBpbXBsZW1lbnRzIHJvdW5kaW5nLlxyXG4gICAgICAgICAgICAgICAgZ3JheSA9ICgzMDYgKiBwaXhlbFIgK1xyXG4gICAgICAgICAgICAgICAgICAgIDYwMSAqIHBpeGVsRyArXHJcbiAgICAgICAgICAgICAgICAgICAgMTE3ICogcGl4ZWxCICtcclxuICAgICAgICAgICAgICAgICAgICAweDIwMCkgPj4gMTA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3JheXNjYWxlQnVmZmVyW2pdID0gZ3JheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdyYXlzY2FsZUJ1ZmZlcjtcclxuICAgIH07XHJcbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gKHkgLyppbnQqLywgcm93KSB7XHJcbiAgICAgICAgaWYgKHkgPCAwIHx8IHkgPj0gdGhpcy5nZXRIZWlnaHQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnUmVxdWVzdGVkIHJvdyBpcyBvdXRzaWRlIHRoZSBpbWFnZTogJyArIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0geSAqIHdpZHRoO1xyXG4gICAgICAgIGlmIChyb3cgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgcm93ID0gdGhpcy5idWZmZXIuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgd2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHJvdy5sZW5ndGggPCB3aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgcm93ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUaGUgdW5kZXJseWluZyByYXN0ZXIgb2YgaW1hZ2UgY29uc2lzdHMgb2YgYnl0ZXMgd2l0aCB0aGUgbHVtaW5hbmNlIHZhbHVlc1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBjYW4gYXZvaWQgc2V0L3NsaWNlP1xyXG4gICAgICAgICAgICByb3cuc2V0KHRoaXMuYnVmZmVyLnNsaWNlKHN0YXJ0LCBzdGFydCArIHdpZHRoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb3c7XHJcbiAgICB9O1xyXG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XHJcbiAgICB9O1xyXG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmlzQ3JvcFN1cHBvcnRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuY3JvcCA9IGZ1bmN0aW9uIChsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuY3JvcC5jYWxsKHRoaXMsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGFsd2F5cyB0cnVlLCBzaW5jZSB0aGUgaW1hZ2UgaXMgYSBncmF5LXNjYWxlIGltYWdlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gdHJ1ZVxyXG4gICAgICovXHJcbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaXNSb3RhdGVTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yb3RhdGUoLTkwKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUucm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucm90YXRlKC00NSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldFRlbXBDYW52YXNFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChudWxsID09PSB0aGlzLnRlbXBDYW52YXNFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wQ2FudmFzRWxlbWVudCA9IHRoaXMuY2FudmFzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIHRlbXBDYW52YXNFbGVtZW50LndpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XHJcbiAgICAgICAgICAgIHRlbXBDYW52YXNFbGVtZW50LmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy50ZW1wQ2FudmFzRWxlbWVudCA9IHRlbXBDYW52YXNFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wQ2FudmFzRWxlbWVudDtcclxuICAgIH07XHJcbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24gKGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIHRlbXBDYW52YXNFbGVtZW50ID0gdGhpcy5nZXRUZW1wQ2FudmFzRWxlbWVudCgpO1xyXG4gICAgICAgIHZhciB0ZW1wQ29udGV4dCA9IHRlbXBDYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgdmFyIGFuZ2xlUmFkaWFucyA9IGFuZ2xlICogSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UuREVHUkVFX1RPX1JBRElBTlM7XHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGFuZCBzZXQgbmV3IGRpbWVuc2lvbnMgZm9yIHRlbXAgY2FudmFzXHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYW52YXMud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodDtcclxuICAgICAgICB2YXIgbmV3V2lkdGggPSBNYXRoLmNlaWwoTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGVSYWRpYW5zKSkgKiB3aWR0aCArIE1hdGguYWJzKE1hdGguc2luKGFuZ2xlUmFkaWFucykpICogaGVpZ2h0KTtcclxuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGguYWJzKE1hdGguc2luKGFuZ2xlUmFkaWFucykpICogd2lkdGggKyBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZVJhZGlhbnMpKSAqIGhlaWdodCk7XHJcbiAgICAgICAgdGVtcENhbnZhc0VsZW1lbnQud2lkdGggPSBuZXdXaWR0aDtcclxuICAgICAgICB0ZW1wQ2FudmFzRWxlbWVudC5oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcbiAgICAgICAgLy8gRHJhdyBhdCBjZW50ZXIgb2YgdGVtcCBjYW52YXMgdG8gcHJldmVudCBjbGlwcGluZyBvZiBpbWFnZSBkYXRhXHJcbiAgICAgICAgdGVtcENvbnRleHQudHJhbnNsYXRlKG5ld1dpZHRoIC8gMiwgbmV3SGVpZ2h0IC8gMik7XHJcbiAgICAgICAgdGVtcENvbnRleHQucm90YXRlKGFuZ2xlUmFkaWFucyk7XHJcbiAgICAgICAgdGVtcENvbnRleHQuZHJhd0ltYWdlKHRoaXMuY2FudmFzLCB3aWR0aCAvIC0yLCBoZWlnaHQgLyAtMik7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5tYWtlQnVmZmVyRnJvbUNhbnZhc0ltYWdlRGF0YSh0ZW1wQ2FudmFzRWxlbWVudCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBIVE1MQ2FudmFzRWxlbWVudEx1bWluYW5jZVNvdXJjZS5ERUdSRUVfVE9fUkFESUFOUyA9IE1hdGguUEkgLyAxODA7XHJcbiAgICByZXR1cm4gSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2U7XHJcbn0oTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLkhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlID0gSFRNTENhbnZhc0VsZW1lbnRMdW1pbmFuY2VTb3VyY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxDYW52YXNFbGVtZW50THVtaW5hbmNlU291cmNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCBNb3ZpbmcgdG8gQHp4aW5nL2Jyb3dzZXJcclxuICpcclxuICogVmlkZW8gaW5wdXQgZGV2aWNlIG1ldGFkYXRhIGNvbnRhaW5pbmcgdGhlIGlkIGFuZCBsYWJlbCBvZiB0aGUgZGV2aWNlIGlmIGF2YWlsYWJsZS5cclxuICovXHJcbnZhciBWaWRlb0lucHV0RGV2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFZpZGVvSW5wdXREZXZpY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRldmljZUlkIHRoZSB2aWRlbyBpbnB1dCBkZXZpY2UgaWRcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCB0aGUgbGFiZWwgb2YgdGhlIGRldmljZSBpZiBhdmFpbGFibGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gVmlkZW9JbnB1dERldmljZShkZXZpY2VJZCwgbGFiZWwsIGdyb3VwSWQpIHtcclxuICAgICAgICB0aGlzLmRldmljZUlkID0gZGV2aWNlSWQ7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xyXG4gICAgICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgICAgIHRoaXMua2luZCA9ICd2aWRlb2lucHV0JztcclxuICAgICAgICB0aGlzLmdyb3VwSWQgPSBncm91cElkIHx8IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xyXG4gICAgVmlkZW9JbnB1dERldmljZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGtpbmQ6IHRoaXMua2luZCxcclxuICAgICAgICAgICAgZ3JvdXBJZDogdGhpcy5ncm91cElkLFxyXG4gICAgICAgICAgICBkZXZpY2VJZDogdGhpcy5kZXZpY2VJZCxcclxuICAgICAgICAgICAgbGFiZWw6IHRoaXMubGFiZWwsXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmlkZW9JbnB1dERldmljZTtcclxufSgpKTtcclxuZXhwb3J0cy5WaWRlb0lucHV0RGV2aWNlID0gVmlkZW9JbnB1dERldmljZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmlkZW9JbnB1dERldmljZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxyXG4gKi9cclxudmFyIEFyZ3VtZW50RXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFyZ3VtZW50RXhjZXB0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXJndW1lbnRFeGNlcHRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFyZ3VtZW50RXhjZXB0aW9uO1xyXG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQXJndW1lbnRFeGNlcHRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFyZ3VtZW50RXhjZXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXHJcbiAqL1xyXG52YXIgQXJpdGhtZXRpY0V4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBcml0aG1ldGljRXhjZXB0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXJpdGhtZXRpY0V4Y2VwdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQXJpdGhtZXRpY0V4Y2VwdGlvbjtcclxufShFeGNlcHRpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFyaXRobWV0aWNFeGNlcHRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFyaXRobWV0aWNFeGNlcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9JbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxyXG4gKi9cclxudmFyIEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24oaW5kZXgsIG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkgeyBpbmRleCA9IHVuZGVmaW5lZDsgfVxyXG4gICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IHVuZGVmaW5lZDsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICBfdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uO1xyXG59KEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBEaXJlY3QgcG9ydCB0byBUeXBlU2NyaXB0IG9mIFpYaW5nIGJ5IEFkcmlhbiBUb8iZY8SDXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cclxuLyoqXHJcbiAqIEVudW1lcmF0ZXMgYmFyY29kZSBmb3JtYXRzIGtub3duIHRvIHRoaXMgcGFja2FnZS4gUGxlYXNlIGtlZXAgYWxwaGFiZXRpemVkLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIEJhcmNvZGVGb3JtYXQ7XHJcbihmdW5jdGlvbiAoQmFyY29kZUZvcm1hdCkge1xyXG4gICAgLyoqIEF6dGVjIDJEIGJhcmNvZGUgZm9ybWF0LiAqL1xyXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQVpURUNcIl0gPSAwXSA9IFwiQVpURUNcIjtcclxuICAgIC8qKiBDT0RBQkFSIDFEIGZvcm1hdC4gKi9cclxuICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIkNPREFCQVJcIl0gPSAxXSA9IFwiQ09EQUJBUlwiO1xyXG4gICAgLyoqIENvZGUgMzkgMUQgZm9ybWF0LiAqL1xyXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiQ09ERV8zOVwiXSA9IDJdID0gXCJDT0RFXzM5XCI7XHJcbiAgICAvKiogQ29kZSA5MyAxRCBmb3JtYXQuICovXHJcbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJDT0RFXzkzXCJdID0gM10gPSBcIkNPREVfOTNcIjtcclxuICAgIC8qKiBDb2RlIDEyOCAxRCBmb3JtYXQuICovXHJcbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJDT0RFXzEyOFwiXSA9IDRdID0gXCJDT0RFXzEyOFwiO1xyXG4gICAgLyoqIERhdGEgTWF0cml4IDJEIGJhcmNvZGUgZm9ybWF0LiAqL1xyXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiREFUQV9NQVRSSVhcIl0gPSA1XSA9IFwiREFUQV9NQVRSSVhcIjtcclxuICAgIC8qKiBFQU4tOCAxRCBmb3JtYXQuICovXHJcbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJFQU5fOFwiXSA9IDZdID0gXCJFQU5fOFwiO1xyXG4gICAgLyoqIEVBTi0xMyAxRCBmb3JtYXQuICovXHJcbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJFQU5fMTNcIl0gPSA3XSA9IFwiRUFOXzEzXCI7XHJcbiAgICAvKiogSVRGIChJbnRlcmxlYXZlZCBUd28gb2YgRml2ZSkgMUQgZm9ybWF0LiAqL1xyXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiSVRGXCJdID0gOF0gPSBcIklURlwiO1xyXG4gICAgLyoqIE1heGlDb2RlIDJEIGJhcmNvZGUgZm9ybWF0LiAqL1xyXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiTUFYSUNPREVcIl0gPSA5XSA9IFwiTUFYSUNPREVcIjtcclxuICAgIC8qKiBQREY0MTcgZm9ybWF0LiAqL1xyXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiUERGXzQxN1wiXSA9IDEwXSA9IFwiUERGXzQxN1wiO1xyXG4gICAgLyoqIFFSIENvZGUgMkQgYmFyY29kZSBmb3JtYXQuICovXHJcbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJRUl9DT0RFXCJdID0gMTFdID0gXCJRUl9DT0RFXCI7XHJcbiAgICAvKiogUlNTIDE0ICovXHJcbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJSU1NfMTRcIl0gPSAxMl0gPSBcIlJTU18xNFwiO1xyXG4gICAgLyoqIFJTUyBFWFBBTkRFRCAqL1xyXG4gICAgQmFyY29kZUZvcm1hdFtCYXJjb2RlRm9ybWF0W1wiUlNTX0VYUEFOREVEXCJdID0gMTNdID0gXCJSU1NfRVhQQU5ERURcIjtcclxuICAgIC8qKiBVUEMtQSAxRCBmb3JtYXQuICovXHJcbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJVUENfQVwiXSA9IDE0XSA9IFwiVVBDX0FcIjtcclxuICAgIC8qKiBVUEMtRSAxRCBmb3JtYXQuICovXHJcbiAgICBCYXJjb2RlRm9ybWF0W0JhcmNvZGVGb3JtYXRbXCJVUENfRVwiXSA9IDE1XSA9IFwiVVBDX0VcIjtcclxuICAgIC8qKiBVUEMvRUFOIGV4dGVuc2lvbiBmb3JtYXQuIE5vdCBhIHN0YW5kLWFsb25lIGZvcm1hdC4gKi9cclxuICAgIEJhcmNvZGVGb3JtYXRbQmFyY29kZUZvcm1hdFtcIlVQQ19FQU5fRVhURU5TSU9OXCJdID0gMTZdID0gXCJVUENfRUFOX0VYVEVOU0lPTlwiO1xyXG59KShCYXJjb2RlRm9ybWF0IHx8IChCYXJjb2RlRm9ybWF0ID0ge30pKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQmFyY29kZUZvcm1hdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFyY29kZUZvcm1hdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGhpZXJhcmNoeSBwcm92aWRlcyBhIHNldCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgbHVtaW5hbmNlIGRhdGEgdG8gMSBiaXQgZGF0YS5cclxuICogSXQgYWxsb3dzIHRoZSBhbGdvcml0aG0gdG8gdmFyeSBwb2x5bW9ycGhpY2FsbHksIGZvciBleGFtcGxlIGFsbG93aW5nIGEgdmVyeSBleHBlbnNpdmVcclxuICogdGhyZXNob2xkaW5nIHRlY2huaXF1ZSBmb3Igc2VydmVycyBhbmQgYSBmYXN0IG9uZSBmb3IgbW9iaWxlLiBJdCBhbHNvIHBlcm1pdHMgdGhlIGltcGxlbWVudGF0aW9uXHJcbiAqIHRvIHZhcnksIGUuZy4gYSBKTkkgdmVyc2lvbiBmb3IgQW5kcm9pZCBhbmQgYSBKYXZhIGZhbGxiYWNrIHZlcnNpb24gZm9yIG90aGVyIHBsYXRmb3Jtcy5cclxuICpcclxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcclxuICovXHJcbnZhciBCaW5hcml6ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCaW5hcml6ZXIoc291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBCaW5hcml6ZXIucHJvdG90eXBlLmdldEx1bWluYW5jZVNvdXJjZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2U7XHJcbiAgICB9O1xyXG4gICAgQmluYXJpemVyLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0V2lkdGgoKTtcclxuICAgIH07XHJcbiAgICBCaW5hcml6ZXIucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0SGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJpbmFyaXplcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQmluYXJpemVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaW5hcml6ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbnZhciBCaW5hcnlCaXRtYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCaW5hcnlCaXRtYXAoYmluYXJpemVyKSB7XHJcbiAgICAgICAgdGhpcy5iaW5hcml6ZXIgPSBiaW5hcml6ZXI7XHJcbiAgICAgICAgaWYgKGJpbmFyaXplciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnQmluYXJpemVyIG11c3QgYmUgbm9uLW51bGwuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIFRoZSB3aWR0aCBvZiB0aGUgYml0bWFwLlxyXG4gICAgICovXHJcbiAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRXaWR0aCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBUaGUgaGVpZ2h0IG9mIHRoZSBiaXRtYXAuXHJcbiAgICAgKi9cclxuICAgIEJpbmFyeUJpdG1hcC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIG9uZSByb3cgb2YgbHVtaW5hbmNlIGRhdGEgdG8gMSBiaXQgZGF0YS4gTWF5IGFjdHVhbGx5IGRvIHRoZSBjb252ZXJzaW9uLCBvciByZXR1cm5cclxuICAgICAqIGNhY2hlZCBkYXRhLiBDYWxsZXJzIHNob3VsZCBhc3N1bWUgdGhpcyBtZXRob2QgaXMgZXhwZW5zaXZlIGFuZCBjYWxsIGl0IGFzIHNlbGRvbSBhcyBwb3NzaWJsZS5cclxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIGZvciBkZWNvZGluZyAxRCBiYXJjb2RlcyBhbmQgbWF5IGNob29zZSB0byBhcHBseSBzaGFycGVuaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB5IFRoZSByb3cgdG8gZmV0Y2gsIHdoaWNoIG11c3QgYmUgaW4gWzAsIGJpdG1hcCBoZWlnaHQpXHJcbiAgICAgKiBAcGFyYW0gcm93IEFuIG9wdGlvbmFsIHByZWFsbG9jYXRlZCBhcnJheS4gSWYgbnVsbCBvciB0b28gc21hbGwsIGl0IHdpbGwgYmUgaWdub3JlZC5cclxuICAgICAqICAgICAgICAgICAgSWYgdXNlZCwgdGhlIEJpbmFyaXplciB3aWxsIGNhbGwgQml0QXJyYXkuY2xlYXIoKS4gQWx3YXlzIHVzZSB0aGUgcmV0dXJuZWQgb2JqZWN0LlxyXG4gICAgICogQHJldHVybiBUaGUgYXJyYXkgb2YgYml0cyBmb3IgdGhpcyByb3cgKHRydWUgbWVhbnMgYmxhY2spLlxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiByb3cgY2FuJ3QgYmUgYmluYXJpemVkXHJcbiAgICAgKi9cclxuICAgIEJpbmFyeUJpdG1hcC5wcm90b3R5cGUuZ2V0QmxhY2tSb3cgPSBmdW5jdGlvbiAoeSAvKmludCovLCByb3cpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcml6ZXIuZ2V0QmxhY2tSb3coeSwgcm93KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgMkQgYXJyYXkgb2YgbHVtaW5hbmNlIGRhdGEgdG8gMSBiaXQuIEFzIGFib3ZlLCBhc3N1bWUgdGhpcyBtZXRob2QgaXMgZXhwZW5zaXZlXHJcbiAgICAgKiBhbmQgZG8gbm90IGNhbGwgaXQgcmVwZWF0ZWRseS4gVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgZm9yIGRlY29kaW5nIDJEIGJhcmNvZGVzIGFuZCBtYXkgb3JcclxuICAgICAqIG1heSBub3QgYXBwbHkgc2hhcnBlbmluZy4gVGhlcmVmb3JlLCBhIHJvdyBmcm9tIHRoaXMgbWF0cml4IG1heSBub3QgYmUgaWRlbnRpY2FsIHRvIG9uZVxyXG4gICAgICogZmV0Y2hlZCB1c2luZyBnZXRCbGFja1JvdygpLCBzbyBkb24ndCBtaXggYW5kIG1hdGNoIGJldHdlZW4gdGhlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIFRoZSAyRCBhcnJheSBvZiBiaXRzIGZvciB0aGUgaW1hZ2UgKHRydWUgbWVhbnMgYmxhY2spLlxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBpbWFnZSBjYW4ndCBiZSBiaW5hcml6ZWQgdG8gbWFrZSBhIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLmdldEJsYWNrTWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFRoZSBtYXRyaXggaXMgY3JlYXRlZCBvbiBkZW1hbmQgdGhlIGZpcnN0IHRpbWUgaXQgaXMgcmVxdWVzdGVkLCB0aGVuIGNhY2hlZC4gVGhlcmUgYXJlIHR3b1xyXG4gICAgICAgIC8vIHJlYXNvbnMgZm9yIHRoaXM6XHJcbiAgICAgICAgLy8gMS4gVGhpcyB3b3JrIHdpbGwgbmV2ZXIgYmUgZG9uZSBpZiB0aGUgY2FsbGVyIG9ubHkgaW5zdGFsbHMgMUQgUmVhZGVyIG9iamVjdHMsIG9yIGlmIGFcclxuICAgICAgICAvLyAgICAxRCBSZWFkZXIgZmluZHMgYSBiYXJjb2RlIGJlZm9yZSB0aGUgMkQgUmVhZGVycyBydW4uXHJcbiAgICAgICAgLy8gMi4gVGhpcyB3b3JrIHdpbGwgb25seSBiZSBkb25lIG9uY2UgZXZlbiBpZiB0aGUgY2FsbGVyIGluc3RhbGxzIG11bHRpcGxlIDJEIFJlYWRlcnMuXHJcbiAgICAgICAgaWYgKHRoaXMubWF0cml4ID09PSBudWxsIHx8IHRoaXMubWF0cml4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXRyaXggPSB0aGlzLmJpbmFyaXplci5nZXRCbGFja01hdHJpeCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBiaXRtYXAgY2FuIGJlIGNyb3BwZWQuXHJcbiAgICAgKi9cclxuICAgIEJpbmFyeUJpdG1hcC5wcm90b3R5cGUuaXNDcm9wU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJpbmFyaXplci5nZXRMdW1pbmFuY2VTb3VyY2UoKS5pc0Nyb3BTdXBwb3J0ZWQoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggY3JvcHBlZCBpbWFnZSBkYXRhLiBJbXBsZW1lbnRhdGlvbnMgbWF5IGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlXHJcbiAgICAgKiBvcmlnaW5hbCBkYXRhIHJhdGhlciB0aGFuIGEgY29weS4gT25seSBjYWxsYWJsZSBpZiBpc0Nyb3BTdXBwb3J0ZWQoKSBpcyB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsZWZ0IFRoZSBsZWZ0IGNvb3JkaW5hdGUsIHdoaWNoIG11c3QgYmUgaW4gWzAsZ2V0V2lkdGgoKSlcclxuICAgICAqIEBwYXJhbSB0b3AgVGhlIHRvcCBjb29yZGluYXRlLCB3aGljaCBtdXN0IGJlIGluIFswLGdldEhlaWdodCgpKVxyXG4gICAgICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZSB0byBjcm9wLlxyXG4gICAgICogQHJldHVybiBBIGNyb3BwZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgQmluYXJ5Qml0bWFwLnByb3RvdHlwZS5jcm9wID0gZnVuY3Rpb24gKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIG5ld1NvdXJjZSA9IHRoaXMuYmluYXJpemVyLmdldEx1bWluYW5jZVNvdXJjZSgpLmNyb3AobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUJpdG1hcCh0aGlzLmJpbmFyaXplci5jcmVhdGVCaW5hcml6ZXIobmV3U291cmNlKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBiaXRtYXAgc3VwcG9ydHMgY291bnRlci1jbG9ja3dpc2Ugcm90YXRpb24uXHJcbiAgICAgKi9cclxuICAgIEJpbmFyeUJpdG1hcC5wcm90b3R5cGUuaXNSb3RhdGVTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJpemVyLmdldEx1bWluYW5jZVNvdXJjZSgpLmlzUm90YXRlU3VwcG9ydGVkKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHJvdGF0ZWQgaW1hZ2UgZGF0YSBieSA5MCBkZWdyZWVzIGNvdW50ZXJjbG9ja3dpc2UuXHJcbiAgICAgKiBPbmx5IGNhbGxhYmxlIGlmIHtAbGluayAjaXNSb3RhdGVTdXBwb3J0ZWQoKX0gaXMgdHJ1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIEEgcm90YXRlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5ld1NvdXJjZSA9IHRoaXMuYmluYXJpemVyLmdldEx1bWluYW5jZVNvdXJjZSgpLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKTtcclxuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeUJpdG1hcCh0aGlzLmJpbmFyaXplci5jcmVhdGVCaW5hcml6ZXIobmV3U291cmNlKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHJvdGF0ZWQgaW1hZ2UgZGF0YSBieSA0NSBkZWdyZWVzIGNvdW50ZXJjbG9ja3dpc2UuXHJcbiAgICAgKiBPbmx5IGNhbGxhYmxlIGlmIHtAbGluayAjaXNSb3RhdGVTdXBwb3J0ZWQoKX0gaXMgdHJ1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIEEgcm90YXRlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBCaW5hcnlCaXRtYXAucHJvdG90eXBlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbmV3U291cmNlID0gdGhpcy5iaW5hcml6ZXIuZ2V0THVtaW5hbmNlU291cmNlKCkucm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnlCaXRtYXAodGhpcy5iaW5hcml6ZXIuY3JlYXRlQmluYXJpemVyKG5ld1NvdXJjZSkpO1xyXG4gICAgfTtcclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIEJpbmFyeUJpdG1hcC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmxhY2tNYXRyaXgoKS50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSAvKjogTm90Rm91bmRFeGNlcHRpb24qLykge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBCaW5hcnlCaXRtYXA7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJpbmFyeUJpdG1hcDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmluYXJ5Qml0bWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXHJcbiAqL1xyXG52YXIgQ2hlY2tzdW1FeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ2hlY2tzdW1FeGNlcHRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDaGVja3N1bUV4Y2VwdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBDaGVja3N1bUV4Y2VwdGlvbi5nZXRDaGVja3N1bUluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2hlY2tzdW1FeGNlcHRpb24oKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2hlY2tzdW1FeGNlcHRpb247XHJcbn0oRXhjZXB0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDaGVja3N1bUV4Y2VwdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hlY2tzdW1FeGNlcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xyXG4vKipcclxuICogRW5jYXBzdWxhdGVzIGEgdHlwZSBvZiBoaW50IHRoYXQgYSBjYWxsZXIgbWF5IHBhc3MgdG8gYSBiYXJjb2RlIHJlYWRlciB0byBoZWxwIGl0XHJcbiAqIG1vcmUgcXVpY2tseSBvciBhY2N1cmF0ZWx5IGRlY29kZSBpdC4gSXQgaXMgdXAgdG8gaW1wbGVtZW50YXRpb25zIHRvIGRlY2lkZSB3aGF0LFxyXG4gKiBpZiBhbnl0aGluZywgdG8gZG8gd2l0aCB0aGUgaW5mb3JtYXRpb24gdGhhdCBpcyBzdXBwbGllZC5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcclxuICogQHNlZSBSZWFkZXIjZGVjb2RlKEJpbmFyeUJpdG1hcCxqYXZhLnV0aWwuTWFwKVxyXG4gKi9cclxudmFyIERlY29kZUhpbnRUeXBlO1xyXG4oZnVuY3Rpb24gKERlY29kZUhpbnRUeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFVuc3BlY2lmaWVkLCBhcHBsaWNhdGlvbi1zcGVjaWZpYyBoaW50LiBNYXBzIHRvIGFuIHVuc3BlY2lmaWVkIHtAbGluayBPYmplY3R9LlxyXG4gICAgICovXHJcbiAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIk9USEVSXCJdID0gMF0gPSBcIk9USEVSXCI7IC8qKE9iamVjdC5jbGFzcykqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbWFnZSBpcyBhIHB1cmUgbW9ub2Nocm9tZSBpbWFnZSBvZiBhIGJhcmNvZGUuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bztcclxuICAgICAqIHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS5cclxuICAgICAqL1xyXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJQVVJFX0JBUkNPREVcIl0gPSAxXSA9IFwiUFVSRV9CQVJDT0RFXCI7IC8qKFZvaWQuY2xhc3MpKi9cclxuICAgIC8qKlxyXG4gICAgICogSW1hZ2UgaXMga25vd24gdG8gYmUgb2Ygb25lIG9mIGEgZmV3IHBvc3NpYmxlIGZvcm1hdHMuXHJcbiAgICAgKiBNYXBzIHRvIGEge0BsaW5rIExpc3R9IG9mIHtAbGluayBCYXJjb2RlRm9ybWF0fXMuXHJcbiAgICAgKi9cclxuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiUE9TU0lCTEVfRk9STUFUU1wiXSA9IDJdID0gXCJQT1NTSUJMRV9GT1JNQVRTXCI7IC8qKExpc3QuY2xhc3MpKi9cclxuICAgIC8qKlxyXG4gICAgICogU3BlbmQgbW9yZSB0aW1lIHRvIHRyeSB0byBmaW5kIGEgYmFyY29kZTsgb3B0aW1pemUgZm9yIGFjY3VyYWN5LCBub3Qgc3BlZWQuXHJcbiAgICAgKiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87IHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS5cclxuICAgICAqL1xyXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJUUllfSEFSREVSXCJdID0gM10gPSBcIlRSWV9IQVJERVJcIjsgLyooVm9pZC5jbGFzcykqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgd2hhdCBjaGFyYWN0ZXIgZW5jb2RpbmcgdG8gdXNlIHdoZW4gZGVjb2RpbmcsIHdoZXJlIGFwcGxpY2FibGUgKHR5cGUgU3RyaW5nKVxyXG4gICAgICovXHJcbiAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIkNIQVJBQ1RFUl9TRVRcIl0gPSA0XSA9IFwiQ0hBUkFDVEVSX1NFVFwiOyAvKihTdHJpbmcuY2xhc3MpKi9cclxuICAgIC8qKlxyXG4gICAgICogQWxsb3dlZCBsZW5ndGhzIG9mIGVuY29kZWQgZGF0YSAtLSByZWplY3QgYW55dGhpbmcgZWxzZS4gTWFwcyB0byBhbiB7QGNvZGUgSW50MzJBcnJheX0uXHJcbiAgICAgKi9cclxuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQUxMT1dFRF9MRU5HVEhTXCJdID0gNV0gPSBcIkFMTE9XRURfTEVOR1RIU1wiOyAvKihJbnQzMkFycmF5LmNsYXNzKSovXHJcbiAgICAvKipcclxuICAgICAqIEFzc3VtZSBDb2RlIDM5IGNvZGVzIGVtcGxveSBhIGNoZWNrIGRpZ2l0LiBEb2Vzbid0IG1hdHRlciB3aGF0IGl0IG1hcHMgdG87XHJcbiAgICAgKiB1c2Uge0BsaW5rIEJvb2xlYW4jVFJVRX0uXHJcbiAgICAgKi9cclxuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiQVNTVU1FX0NPREVfMzlfQ0hFQ0tfRElHSVRcIl0gPSA2XSA9IFwiQVNTVU1FX0NPREVfMzlfQ0hFQ0tfRElHSVRcIjsgLyooVm9pZC5jbGFzcykqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBBc3N1bWUgdGhlIGJhcmNvZGUgaXMgYmVpbmcgcHJvY2Vzc2VkIGFzIGEgR1MxIGJhcmNvZGUsIGFuZCBtb2RpZnkgYmVoYXZpb3IgYXMgbmVlZGVkLlxyXG4gICAgICogRm9yIGV4YW1wbGUgdGhpcyBhZmZlY3RzIEZOQzEgaGFuZGxpbmcgZm9yIENvZGUgMTI4IChha2EgR1MxLTEyOCkuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bztcclxuICAgICAqIHVzZSB7QGxpbmsgQm9vbGVhbiNUUlVFfS5cclxuICAgICAqL1xyXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJBU1NVTUVfR1MxXCJdID0gN10gPSBcIkFTU1VNRV9HUzFcIjsgLyooVm9pZC5jbGFzcykqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0cnVlLCByZXR1cm4gdGhlIHN0YXJ0IGFuZCBlbmQgZGlnaXRzIGluIGEgQ29kYWJhciBiYXJjb2RlIGluc3RlYWQgb2Ygc3RyaXBwaW5nIHRoZW0uIFRoZXlcclxuICAgICAqIGFyZSBhbHBoYSwgd2hlcmVhcyB0aGUgcmVzdCBhcmUgbnVtZXJpYy4gQnkgZGVmYXVsdCwgdGhleSBhcmUgc3RyaXBwZWQsIGJ1dCB0aGlzIGNhdXNlcyB0aGVtXHJcbiAgICAgKiB0byBub3QgYmUuIERvZXNuJ3QgbWF0dGVyIHdoYXQgaXQgbWFwcyB0bzsgdXNlIHtAbGluayBCb29sZWFuI1RSVUV9LlxyXG4gICAgICovXHJcbiAgICBEZWNvZGVIaW50VHlwZVtEZWNvZGVIaW50VHlwZVtcIlJFVFVSTl9DT0RBQkFSX1NUQVJUX0VORFwiXSA9IDhdID0gXCJSRVRVUk5fQ09EQUJBUl9TVEFSVF9FTkRcIjsgLyooVm9pZC5jbGFzcykqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2FsbGVyIG5lZWRzIHRvIGJlIG5vdGlmaWVkIHZpYSBjYWxsYmFjayB3aGVuIGEgcG9zc2libGUge0BsaW5rIFJlc3VsdFBvaW50fVxyXG4gICAgICogaXMgZm91bmQuIE1hcHMgdG8gYSB7QGxpbmsgUmVzdWx0UG9pbnRDYWxsYmFja30uXHJcbiAgICAgKi9cclxuICAgIERlY29kZUhpbnRUeXBlW0RlY29kZUhpbnRUeXBlW1wiTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0tcIl0gPSA5XSA9IFwiTkVFRF9SRVNVTFRfUE9JTlRfQ0FMTEJBQ0tcIjsgLyooUmVzdWx0UG9pbnRDYWxsYmFjay5jbGFzcykqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbGxvd2VkIGV4dGVuc2lvbiBsZW5ndGhzIGZvciBFQU4gb3IgVVBDIGJhcmNvZGVzLiBPdGhlciBmb3JtYXRzIHdpbGwgaWdub3JlIHRoaXMuXHJcbiAgICAgKiBNYXBzIHRvIGFuIHtAY29kZSBJbnQzMkFycmF5fSBvZiB0aGUgYWxsb3dlZCBleHRlbnNpb24gbGVuZ3RocywgZm9yIGV4YW1wbGUgWzJdLCBbNV0sIG9yIFsyLCA1XS5cclxuICAgICAqIElmIGl0IGlzIG9wdGlvbmFsIHRvIGhhdmUgYW4gZXh0ZW5zaW9uLCBkbyBub3Qgc2V0IHRoaXMgaGludC4gSWYgdGhpcyBpcyBzZXQsXHJcbiAgICAgKiBhbmQgYSBVUEMgb3IgRUFOIGJhcmNvZGUgaXMgZm91bmQgYnV0IGFuIGV4dGVuc2lvbiBpcyBub3QsIHRoZW4gbm8gcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWRcclxuICAgICAqIGF0IGFsbC5cclxuICAgICAqL1xyXG4gICAgRGVjb2RlSGludFR5cGVbRGVjb2RlSGludFR5cGVbXCJBTExPV0VEX0VBTl9FWFRFTlNJT05TXCJdID0gMTBdID0gXCJBTExPV0VEX0VBTl9FWFRFTlNJT05TXCI7IC8qKEludDMyQXJyYXkuY2xhc3MpKi9cclxuICAgIC8vIEVuZCBvZiBlbnVtZXJhdGlvbiB2YWx1ZXMuXHJcbiAgICAvKipcclxuICAgICAqIERhdGEgdHlwZSB0aGUgaGludCBpcyBleHBlY3RpbmcuXHJcbiAgICAgKiBBbW9uZyB0aGUgcG9zc2libGUgdmFsdWVzIHRoZSB7QGxpbmsgVm9pZH0gc3RhbmRzIG91dCBhcyBiZWluZyB1c2VkIGZvclxyXG4gICAgICogaGludHMgdGhhdCBkbyBub3QgZXhwZWN0IGEgdmFsdWUgdG8gYmUgc3VwcGxpZWQgKGZsYWcgaGludHMpLiBTdWNoIGhpbnRzXHJcbiAgICAgKiB3aWxsIHBvc3NpYmx5IGhhdmUgdGhlaXIgdmFsdWUgaWdub3JlZCwgb3IgcmVwbGFjZWQgYnkgYVxyXG4gICAgICoge0BsaW5rIEJvb2xlYW4jVFJVRX0uIEhpbnQgc3VwcGxpZXJzIHNob3VsZCBwcm9iYWJseSB1c2VcclxuICAgICAqIHtAbGluayBCb29sZWFuI1RSVUV9IGFzIGRpcmVjdGVkIGJ5IHRoZSBhY3R1YWwgaGludCBkb2N1bWVudGF0aW9uLlxyXG4gICAgICovXHJcbiAgICAvLyBwcml2YXRlIHZhbHVlVHlwZTogQ2xhc3M8Pz5cclxuICAgIC8vIERlY29kZUhpbnRUeXBlKHZhbHVlVHlwZTogQ2xhc3M8Pz4pIHtcclxuICAgIC8vICAgdGhpcy52YWx1ZVR5cGUgPSB2YWx1ZVR5cGVcclxuICAgIC8vIH1cclxuICAgIC8vIHB1YmxpYyBnZXRWYWx1ZVR5cGUoKTogQ2xhc3M8Pz4ge1xyXG4gICAgLy8gICByZXR1cm4gdmFsdWVUeXBlXHJcbiAgICAvLyB9XHJcbn0pKERlY29kZUhpbnRUeXBlIHx8IChEZWNvZGVIaW50VHlwZSA9IHt9KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERlY29kZUhpbnRUeXBlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWNvZGVIaW50VHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXHJcbi8qKlxyXG4gKiBUaGVzZSBhcmUgYSBzZXQgb2YgaGludHMgdGhhdCB5b3UgbWF5IHBhc3MgdG8gV3JpdGVycyB0byBzcGVjaWZ5IHRoZWlyIGJlaGF2aW9yLlxyXG4gKlxyXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxyXG4gKi9cclxudmFyIEVuY29kZUhpbnRUeXBlO1xyXG4oZnVuY3Rpb24gKEVuY29kZUhpbnRUeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyB3aGF0IGRlZ3JlZSBvZiBlcnJvciBjb3JyZWN0aW9uIHRvIHVzZSwgZm9yIGV4YW1wbGUgaW4gUVIgQ29kZXMuXHJcbiAgICAgKiBUeXBlIGRlcGVuZHMgb24gdGhlIGVuY29kZXIuIEZvciBleGFtcGxlIGZvciBRUiBjb2RlcyBpdCdzIHR5cGVcclxuICAgICAqIHtAbGluayBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZWNvZGVyLkVycm9yQ29ycmVjdGlvbkxldmVsIEVycm9yQ29ycmVjdGlvbkxldmVsfS5cclxuICAgICAqIEZvciBBenRlYyBpdCBpcyBvZiB0eXBlIHtAbGluayBJbnRlZ2VyfSwgcmVwcmVzZW50aW5nIHRoZSBtaW5pbWFsIHBlcmNlbnRhZ2Ugb2YgZXJyb3IgY29ycmVjdGlvbiB3b3Jkcy5cclxuICAgICAqIEZvciBQREY0MTcgaXQgaXMgb2YgdHlwZSB7QGxpbmsgSW50ZWdlcn0sIHZhbGlkIHZhbHVlcyBiZWluZyAwIHRvIDguXHJcbiAgICAgKiBJbiBhbGwgY2FzZXMsIGl0IGNhbiBhbHNvIGJlIGEge0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRlc2lyZWQgdmFsdWUgYXMgd2VsbC5cclxuICAgICAqIE5vdGU6IGFuIEF6dGVjIHN5bWJvbCBzaG91bGQgaGF2ZSBhIG1pbmltdW0gb2YgMjUlIEVDIHdvcmRzLlxyXG4gICAgICovXHJcbiAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIkVSUk9SX0NPUlJFQ1RJT05cIl0gPSAwXSA9IFwiRVJST1JfQ09SUkVDVElPTlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgd2hhdCBjaGFyYWN0ZXIgZW5jb2RpbmcgdG8gdXNlIHdoZXJlIGFwcGxpY2FibGUgKHR5cGUge0BsaW5rIFN0cmluZ30pXHJcbiAgICAgKi9cclxuICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiQ0hBUkFDVEVSX1NFVFwiXSA9IDFdID0gXCJDSEFSQUNURVJfU0VUXCI7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyB0aGUgbWF0cml4IHNoYXBlIGZvciBEYXRhIE1hdHJpeCAodHlwZSB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5kYXRhbWF0cml4LmVuY29kZXIuU3ltYm9sU2hhcGVIaW50fSlcclxuICAgICAqL1xyXG4gICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJEQVRBX01BVFJJWF9TSEFQRVwiXSA9IDJdID0gXCJEQVRBX01BVFJJWF9TSEFQRVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgYSBtaW5pbXVtIGJhcmNvZGUgc2l6ZSAodHlwZSB7QGxpbmsgRGltZW5zaW9ufSkuIE9ubHkgYXBwbGljYWJsZSB0byBEYXRhIE1hdHJpeCBub3cuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIHdpZHRoL2hlaWdodCBwYXJhbXMgaW5cclxuICAgICAqIHtAbGluayBjb20uZ29vZ2xlLnp4aW5nLmRhdGFtYXRyaXguRGF0YU1hdHJpeFdyaXRlciNlbmNvZGUoU3RyaW5nLCBCYXJjb2RlRm9ybWF0LCBpbnQsIGludCl9XHJcbiAgICAgKi9cclxuICAgIC8qQERlcHJlY2F0ZWQqL1xyXG4gICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJNSU5fU0laRVwiXSA9IDNdID0gXCJNSU5fU0laRVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgYSBtYXhpbXVtIGJhcmNvZGUgc2l6ZSAodHlwZSB7QGxpbmsgRGltZW5zaW9ufSkuIE9ubHkgYXBwbGljYWJsZSB0byBEYXRhIE1hdHJpeCBub3cuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgd2l0aG91dCByZXBsYWNlbWVudFxyXG4gICAgICovXHJcbiAgICAvKkBEZXByZWNhdGVkKi9cclxuICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiTUFYX1NJWkVcIl0gPSA0XSA9IFwiTUFYX1NJWkVcIjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIG1hcmdpbiwgaW4gcGl4ZWxzLCB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIHRoZSBiYXJjb2RlLiBUaGUgbWVhbmluZyBjYW4gdmFyeVxyXG4gICAgICogYnkgZm9ybWF0OyBmb3IgZXhhbXBsZSBpdCBjb250cm9scyBtYXJnaW4gYmVmb3JlIGFuZCBhZnRlciB0aGUgYmFyY29kZSBob3Jpem9udGFsbHkgZm9yXHJcbiAgICAgKiBtb3N0IDFEIGZvcm1hdHMuIChUeXBlIHtAbGluayBJbnRlZ2VyfSwgb3Ige0BsaW5rIFN0cmluZ30gcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVnZXIgdmFsdWUpLlxyXG4gICAgICovXHJcbiAgICBFbmNvZGVIaW50VHlwZVtFbmNvZGVIaW50VHlwZVtcIk1BUkdJTlwiXSA9IDVdID0gXCJNQVJHSU5cIjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgdG8gdXNlIGNvbXBhY3QgbW9kZSBmb3IgUERGNDE3ICh0eXBlIHtAbGluayBCb29sZWFufSwgb3IgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiXHJcbiAgICAgKiB7QGxpbmsgU3RyaW5nfSB2YWx1ZSkuXHJcbiAgICAgKi9cclxuICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiUERGNDE3X0NPTVBBQ1RcIl0gPSA2XSA9IFwiUERGNDE3X0NPTVBBQ1RcIjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHdoYXQgY29tcGFjdGlvbiBtb2RlIHRvIHVzZSBmb3IgUERGNDE3ICh0eXBlXHJcbiAgICAgKiB7QGxpbmsgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZW5jb2Rlci5Db21wYWN0aW9uIENvbXBhY3Rpb259IG9yIHtAbGluayBTdHJpbmd9IHZhbHVlIG9mIG9uZSBvZiBpdHNcclxuICAgICAqIGVudW0gdmFsdWVzKS5cclxuICAgICAqL1xyXG4gICAgRW5jb2RlSGludFR5cGVbRW5jb2RlSGludFR5cGVbXCJQREY0MTdfQ09NUEFDVElPTlwiXSA9IDddID0gXCJQREY0MTdfQ09NUEFDVElPTlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbnVtYmVyIG9mIHJvd3MgYW5kIGNvbHVtbnMgZm9yIFBERjQxNyAodHlwZVxyXG4gICAgICoge0BsaW5rIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmVuY29kZXIuRGltZW5zaW9ucyBEaW1lbnNpb25zfSkuXHJcbiAgICAgKi9cclxuICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiUERGNDE3X0RJTUVOU0lPTlNcIl0gPSA4XSA9IFwiUERGNDE3X0RJTUVOU0lPTlNcIjtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgbGF5ZXJzIGZvciBhbiBBenRlYyBjb2RlLlxyXG4gICAgICogQSBuZWdhdGl2ZSBudW1iZXIgKC0xLCAtMiwgLTMsIC00KSBzcGVjaWZpZXMgYSBjb21wYWN0IEF6dGVjIGNvZGUuXHJcbiAgICAgKiAwIGluZGljYXRlcyB0byB1c2UgdGhlIG1pbmltdW0gbnVtYmVyIG9mIGxheWVycyAodGhlIGRlZmF1bHQpLlxyXG4gICAgICogQSBwb3NpdGl2ZSBudW1iZXIgKDEsIDIsIC4uIDMyKSBzcGVjaWZpZXMgYSBub3JtYWwgKG5vbi1jb21wYWN0KSBBenRlYyBjb2RlLlxyXG4gICAgICogKFR5cGUge0BsaW5rIEludGVnZXJ9LCBvciB7QGxpbmsgU3RyaW5nfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW50ZWdlciB2YWx1ZSkuXHJcbiAgICAgKi9cclxuICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiQVpURUNfTEFZRVJTXCJdID0gOV0gPSBcIkFaVEVDX0xBWUVSU1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGV4YWN0IHZlcnNpb24gb2YgUVIgY29kZSB0byBiZSBlbmNvZGVkLlxyXG4gICAgICogKFR5cGUge0BsaW5rIEludGVnZXJ9LCBvciB7QGxpbmsgU3RyaW5nfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW50ZWdlciB2YWx1ZSkuXHJcbiAgICAgKi9cclxuICAgIEVuY29kZUhpbnRUeXBlW0VuY29kZUhpbnRUeXBlW1wiUVJfVkVSU0lPTlwiXSA9IDEwXSA9IFwiUVJfVkVSU0lPTlwiO1xyXG59KShFbmNvZGVIaW50VHlwZSB8fCAoRW5jb2RlSGludFR5cGUgPSB7fSkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFbmNvZGVIaW50VHlwZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW5jb2RlSGludFR5cGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c19jdXN0b21fZXJyb3JfMSA9IHJlcXVpcmUoXCJ0cy1jdXN0b20tZXJyb3JcIik7XHJcbi8qKlxyXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXHJcbiAqL1xyXG52YXIgRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEV4Y2VwdGlvbiwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQWxsb3dzIEV4Y2VwdGlvbiB0byBiZSBjb25zdHJ1Y3RlZCBkaXJlY3RseVxyXG4gICAgICogd2l0aCBzb21lIG1lc3NhZ2UgYW5kIHByb3RvdHlwZSBkZWZpbml0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBFeGNlcHRpb24obWVzc2FnZSkge1xyXG4gICAgICAgIGlmIChtZXNzYWdlID09PSB2b2lkIDApIHsgbWVzc2FnZSA9IHVuZGVmaW5lZDsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEV4Y2VwdGlvbjtcclxufSh0c19jdXN0b21fZXJyb3JfMS5DdXN0b21FcnJvcikpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFeGNlcHRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4Y2VwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxyXG4gKi9cclxudmFyIEZvcm1hdEV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhGb3JtYXRFeGNlcHRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGb3JtYXRFeGNlcHRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRm9ybWF0RXhjZXB0aW9uLmdldEZvcm1hdEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRm9ybWF0RXhjZXB0aW9uKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZvcm1hdEV4Y2VwdGlvbjtcclxufShFeGNlcHRpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZvcm1hdEV4Y2VwdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9ybWF0RXhjZXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXHJcbiAqL1xyXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uO1xyXG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cclxuICovXHJcbnZhciBJbGxlZ2FsU3RhdGVFeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSWxsZWdhbFN0YXRlRXhjZXB0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSWxsZWdhbFN0YXRlRXhjZXB0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBJbGxlZ2FsU3RhdGVFeGNlcHRpb247XHJcbn0oRXhjZXB0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBJbGxlZ2FsU3RhdGVFeGNlcHRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlsbGVnYWxTdGF0ZUV4Y2VwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxyXG4gKi9cclxudmFyIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb247XHJcbn0oRXhjZXB0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbmRleE91dE9mQm91bmRzRXhjZXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBMdW1pbmFuY2VTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0x1bWluYW5jZVNvdXJjZVwiKTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cclxuLyoqXHJcbiAqIEEgd3JhcHBlciBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgTHVtaW5hbmNlU291cmNlfSB3aGljaCBpbnZlcnRzIHRoZSBsdW1pbmFuY2VzIGl0IHJldHVybnMgLS0gYmxhY2sgYmVjb21lc1xyXG4gKiB3aGl0ZSBhbmQgdmljZSB2ZXJzYSwgYW5kIGVhY2ggdmFsdWUgYmVjb21lcyAoMjU1LXZhbHVlKS5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICovXHJcbnZhciBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEludmVydGVkTHVtaW5hbmNlU291cmNlKGRlbGVnYXRlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVsZWdhdGUuZ2V0V2lkdGgoKSwgZGVsZWdhdGUuZ2V0SGVpZ2h0KCkpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gKHkgLyppbnQqLywgcm93KSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZVJvdyA9IHRoaXMuZGVsZWdhdGUuZ2V0Um93KHksIHJvdyk7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xyXG4gICAgICAgICAgICBzb3VyY2VSb3dbaV0gPSAvKihieXRlKSovICgyNTUgLSAoc291cmNlUm93W2ldICYgMHhGRikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc291cmNlUm93O1xyXG4gICAgfTtcclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIEludmVydGVkTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5nZXRNYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuZGVsZWdhdGUuZ2V0TWF0cml4KCk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuZ2V0V2lkdGgoKSAqIHRoaXMuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgdmFyIGludmVydGVkTWF0cml4ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpbnZlcnRlZE1hdHJpeFtpXSA9IC8qKGJ5dGUpKi8gKDI1NSAtIChtYXRyaXhbaV0gJiAweEZGKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnZlcnRlZE1hdHJpeDtcclxuICAgIH07XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaXNDcm9wU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmlzQ3JvcFN1cHBvcnRlZCgpO1xyXG4gICAgfTtcclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIEludmVydGVkTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5jcm9wID0gZnVuY3Rpb24gKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSh0aGlzLmRlbGVnYXRlLmNyb3AobGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSk7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmlzUm90YXRlU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmlzUm90YXRlU3VwcG9ydGVkKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIG9yaWdpbmFsIGRlbGVnYXRlIHtAbGluayBMdW1pbmFuY2VTb3VyY2V9IHNpbmNlIGludmVydCB1bmRvZXMgaXRzZWxmXHJcbiAgICAgKi9cclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIEludmVydGVkTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZWdhdGU7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZSh0aGlzLmRlbGVnYXRlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2UoKSk7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnJvdGF0ZUNvdW50ZXJDbG9ja3dpc2U0NSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlKHRoaXMuZGVsZWdhdGUucm90YXRlQ291bnRlckNsb2Nrd2lzZTQ1KCkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZTtcclxufShMdW1pbmFuY2VTb3VyY2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEludmVydGVkTHVtaW5hbmNlU291cmNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnZlcnRlZEx1bWluYW5jZVNvdXJjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XHJcbnZhciBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25cIik7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXHJcbi8qKlxyXG4gKiBUaGUgcHVycG9zZSBvZiB0aGlzIGNsYXNzIGhpZXJhcmNoeSBpcyB0byBhYnN0cmFjdCBkaWZmZXJlbnQgYml0bWFwIGltcGxlbWVudGF0aW9ucyBhY3Jvc3NcclxuICogcGxhdGZvcm1zIGludG8gYSBzdGFuZGFyZCBpbnRlcmZhY2UgZm9yIHJlcXVlc3RpbmcgZ3JleXNjYWxlIGx1bWluYW5jZSB2YWx1ZXMuIFRoZSBpbnRlcmZhY2VcclxuICogb25seSBwcm92aWRlcyBpbW11dGFibGUgbWV0aG9kczsgdGhlcmVmb3JlIGNyb3AgYW5kIHJvdGF0aW9uIGNyZWF0ZSBjb3BpZXMuIFRoaXMgaXMgdG8gZW5zdXJlXHJcbiAqIHRoYXQgb25lIFJlYWRlciBkb2VzIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsIGx1bWluYW5jZSBzb3VyY2UgYW5kIGxlYXZlIGl0IGluIGFuIHVua25vd24gc3RhdGVcclxuICogZm9yIG90aGVyIFJlYWRlcnMgaW4gdGhlIGNoYWluLlxyXG4gKlxyXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxyXG4gKi9cclxudmFyIEx1bWluYW5jZVNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEx1bWluYW5jZVNvdXJjZSh3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBUaGUgd2lkdGggb2YgdGhlIGJpdG1hcC5cclxuICAgICAqL1xyXG4gICAgTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gVGhlIGhlaWdodCBvZiB0aGUgYml0bWFwLlxyXG4gICAgICovXHJcbiAgICBMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIFdoZXRoZXIgdGhpcyBzdWJjbGFzcyBzdXBwb3J0cyBjcm9wcGluZy5cclxuICAgICAqL1xyXG4gICAgTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5pc0Nyb3BTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCBjcm9wcGVkIGltYWdlIGRhdGEuIEltcGxlbWVudGF0aW9ucyBtYXkga2VlcCBhIHJlZmVyZW5jZSB0byB0aGVcclxuICAgICAqIG9yaWdpbmFsIGRhdGEgcmF0aGVyIHRoYW4gYSBjb3B5LiBPbmx5IGNhbGxhYmxlIGlmIGlzQ3JvcFN1cHBvcnRlZCgpIGlzIHRydWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGxlZnQgVGhlIGxlZnQgY29vcmRpbmF0ZSwgd2hpY2ggbXVzdCBiZSBpbiBbMCxnZXRXaWR0aCgpKVxyXG4gICAgICogQHBhcmFtIHRvcCBUaGUgdG9wIGNvb3JkaW5hdGUsIHdoaWNoIG11c3QgYmUgaW4gWzAsZ2V0SGVpZ2h0KCkpXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUgdG8gY3JvcC5cclxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlIHRvIGNyb3AuXHJcbiAgICAgKiBAcmV0dXJuIEEgY3JvcHBlZCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmNyb3AgPSBmdW5jdGlvbiAobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcclxuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25fMS5kZWZhdWx0KCdUaGlzIGx1bWluYW5jZSBzb3VyY2UgZG9lcyBub3Qgc3VwcG9ydCBjcm9wcGluZy4nKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gV2hldGhlciB0aGlzIHN1YmNsYXNzIHN1cHBvcnRzIGNvdW50ZXItY2xvY2t3aXNlIHJvdGF0aW9uLlxyXG4gICAgICovXHJcbiAgICBMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmlzUm90YXRlU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggcm90YXRlZCBpbWFnZSBkYXRhIGJ5IDkwIGRlZ3JlZXMgY291bnRlcmNsb2Nrd2lzZS5cclxuICAgICAqIE9ubHkgY2FsbGFibGUgaWYge0BsaW5rICNpc1JvdGF0ZVN1cHBvcnRlZCgpfSBpcyB0cnVlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gQSByb3RhdGVkIHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIEx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUucm90YXRlQ291bnRlckNsb2Nrd2lzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25fMS5kZWZhdWx0KCdUaGlzIGx1bWluYW5jZSBzb3VyY2UgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGlvbiBieSA5MCBkZWdyZWVzLicpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBvYmplY3Qgd2l0aCByb3RhdGVkIGltYWdlIGRhdGEgYnkgNDUgZGVncmVlcyBjb3VudGVyY2xvY2t3aXNlLlxyXG4gICAgICogT25seSBjYWxsYWJsZSBpZiB7QGxpbmsgI2lzUm90YXRlU3VwcG9ydGVkKCl9IGlzIHRydWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBBIHJvdGF0ZWQgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5yb3RhdGVDb3VudGVyQ2xvY2t3aXNlNDUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uXzEuZGVmYXVsdCgnVGhpcyBsdW1pbmFuY2Ugc291cmNlIGRvZXMgbm90IHN1cHBvcnQgcm90YXRpb24gYnkgNDUgZGVncmVlcy4nKTtcclxuICAgIH07XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByb3cgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkodGhpcy53aWR0aCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgc291cmNlUm93ID0gdGhpcy5nZXRSb3coeSwgcm93KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBsdW1pbmFuY2UgPSBzb3VyY2VSb3dbeF0gJiAweEZGO1xyXG4gICAgICAgICAgICAgICAgdmFyIGMgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBpZiAobHVtaW5hbmNlIDwgMHg0MCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSAnIyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsdW1pbmFuY2UgPCAweDgwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcrJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGx1bWluYW5jZSA8IDB4QzApIHtcclxuICAgICAgICAgICAgICAgICAgICBjID0gJy4nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9ICcgJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTHVtaW5hbmNlU291cmNlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMdW1pbmFuY2VTb3VyY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUx1bWluYW5jZVNvdXJjZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4vRGVjb2RlSGludFR5cGVcIik7XHJcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi9CYXJjb2RlRm9ybWF0XCIpO1xyXG52YXIgUVJDb2RlUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9xcmNvZGUvUVJDb2RlUmVhZGVyXCIpO1xyXG52YXIgQXp0ZWNSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2F6dGVjL0F6dGVjUmVhZGVyXCIpO1xyXG52YXIgTXVsdGlGb3JtYXRPbmVEUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9vbmVkL011bHRpRm9ybWF0T25lRFJlYWRlclwiKTtcclxudmFyIERhdGFNYXRyaXhSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2RhdGFtYXRyaXgvRGF0YU1hdHJpeFJlYWRlclwiKTtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxudmFyIFBERjQxN1JlYWRlcl8xID0gcmVxdWlyZShcIi4vcGRmNDE3L1BERjQxN1JlYWRlclwiKTtcclxudmFyIFJlYWRlckV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vUmVhZGVyRXhjZXB0aW9uXCIpO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nIHsqL1xyXG4vKipcclxuICogTXVsdGlGb3JtYXRSZWFkZXIgaXMgYSBjb252ZW5pZW5jZSBjbGFzcyBhbmQgdGhlIG1haW4gZW50cnkgcG9pbnQgaW50byB0aGUgbGlicmFyeSBmb3IgbW9zdCB1c2VzLlxyXG4gKiBCeSBkZWZhdWx0IGl0IGF0dGVtcHRzIHRvIGRlY29kZSBhbGwgYmFyY29kZSBmb3JtYXRzIHRoYXQgdGhlIGxpYnJhcnkgc3VwcG9ydHMuIE9wdGlvbmFsbHksIHlvdVxyXG4gKiBjYW4gcHJvdmlkZSBhIGhpbnRzIG9iamVjdCB0byByZXF1ZXN0IGRpZmZlcmVudCBiZWhhdmlvciwgZm9yIGV4YW1wbGUgb25seSBkZWNvZGluZyBRUiBjb2Rlcy5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcclxuICovXHJcbnZhciBNdWx0aUZvcm1hdFJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE11bHRpRm9ybWF0UmVhZGVyKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHZlcnNpb24gb2YgZGVjb2RlIGhvbm9ycyB0aGUgaW50ZW50IG9mIFJlYWRlci5kZWNvZGUoQmluYXJ5Qml0bWFwKSBpbiB0aGF0IGl0XHJcbiAgICAgKiBwYXNzZXMgbnVsbCBhcyBhIGhpbnQgdG8gdGhlIGRlY29kZXJzLiBIb3dldmVyLCB0aGF0IG1ha2VzIGl0IGluZWZmaWNpZW50IHRvIGNhbGwgcmVwZWF0ZWRseS5cclxuICAgICAqIFVzZSBzZXRIaW50cygpIGZvbGxvd2VkIGJ5IGRlY29kZVdpdGhTdGF0ZSgpIGZvciBjb250aW51b3VzIHNjYW4gYXBwbGljYXRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbWFnZSBUaGUgcGl4ZWwgZGF0YSB0byBkZWNvZGVcclxuICAgICAqIEByZXR1cm4gVGhlIGNvbnRlbnRzIG9mIHRoZSBpbWFnZVxyXG4gICAgICpcclxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gQW55IGVycm9ycyB3aGljaCBvY2N1cnJlZFxyXG4gICAgICovXHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICAvLyBwdWJsaWMgZGVjb2RlKGltYWdlOiBCaW5hcnlCaXRtYXApOiBSZXN1bHQge1xyXG4gICAgLy8gICBzZXRIaW50cyhudWxsKVxyXG4gICAgLy8gICByZXR1cm4gZGVjb2RlSW50ZXJuYWwoaW1hZ2UpXHJcbiAgICAvLyB9XHJcbiAgICAvKipcclxuICAgICAqIERlY29kZSBhbiBpbWFnZSB1c2luZyB0aGUgaGludHMgcHJvdmlkZWQuIERvZXMgbm90IGhvbm9yIGV4aXN0aW5nIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbWFnZSBUaGUgcGl4ZWwgZGF0YSB0byBkZWNvZGVcclxuICAgICAqIEBwYXJhbSBoaW50cyBUaGUgaGludHMgdG8gdXNlLCBjbGVhcmluZyB0aGUgcHJldmlvdXMgc3RhdGUuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50cyBvZiB0aGUgaW1hZ2VcclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIEFueSBlcnJvcnMgd2hpY2ggb2NjdXJyZWRcclxuICAgICAqL1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgTXVsdGlGb3JtYXRSZWFkZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChpbWFnZSwgaGludHMpIHtcclxuICAgICAgICB0aGlzLnNldEhpbnRzKGhpbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVJbnRlcm5hbChpbWFnZSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvZGUgYW4gaW1hZ2UgdXNpbmcgdGhlIHN0YXRlIHNldCB1cCBieSBjYWxsaW5nIHNldEhpbnRzKCkgcHJldmlvdXNseS4gQ29udGludW91cyBzY2FuXHJcbiAgICAgKiBjbGllbnRzIHdpbGwgZ2V0IGEgPGI+bGFyZ2U8L2I+IHNwZWVkIGluY3JlYXNlIGJ5IHVzaW5nIHRoaXMgaW5zdGVhZCBvZiBkZWNvZGUoKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW1hZ2UgVGhlIHBpeGVsIGRhdGEgdG8gZGVjb2RlXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50cyBvZiB0aGUgaW1hZ2VcclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIEFueSBlcnJvcnMgd2hpY2ggb2NjdXJyZWRcclxuICAgICAqL1xyXG4gICAgTXVsdGlGb3JtYXRSZWFkZXIucHJvdG90eXBlLmRlY29kZVdpdGhTdGF0ZSA9IGZ1bmN0aW9uIChpbWFnZSkge1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0byBzZXQgdXAgdGhlIGRlZmF1bHQgc3RhdGUgc28gd2UgZG9uJ3QgY3Jhc2hcclxuICAgICAgICBpZiAodGhpcy5yZWFkZXJzID09PSBudWxsIHx8IHRoaXMucmVhZGVycyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0SGludHMobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRlY29kZUludGVybmFsKGltYWdlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGFkZHMgc3RhdGUgdG8gdGhlIE11bHRpRm9ybWF0UmVhZGVyLiBCeSBzZXR0aW5nIHRoZSBoaW50cyBvbmNlLCBzdWJzZXF1ZW50IGNhbGxzXHJcbiAgICAgKiB0byBkZWNvZGVXaXRoU3RhdGUoaW1hZ2UpIGNhbiByZXVzZSB0aGUgc2FtZSBzZXQgb2YgcmVhZGVycyB3aXRob3V0IHJlYWxsb2NhdGluZyBtZW1vcnkuIFRoaXNcclxuICAgICAqIGlzIGltcG9ydGFudCBmb3IgcGVyZm9ybWFuY2UgaW4gY29udGludW91cyBzY2FuIGNsaWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGhpbnRzIFRoZSBzZXQgb2YgaGludHMgdG8gdXNlIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIGRlY29kZShpbWFnZSlcclxuICAgICAqL1xyXG4gICAgTXVsdGlGb3JtYXRSZWFkZXIucHJvdG90eXBlLnNldEhpbnRzID0gZnVuY3Rpb24gKGhpbnRzKSB7XHJcbiAgICAgICAgdGhpcy5oaW50cyA9IGhpbnRzO1xyXG4gICAgICAgIHZhciB0cnlIYXJkZXIgPSBoaW50cyAhPT0gbnVsbCAmJiBoaW50cyAhPT0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5UUllfSEFSREVSKTtcclxuICAgICAgICAvKkBTdXBwcmVzc1dhcm5pbmdzKFwidW5jaGVja2VkXCIpKi9cclxuICAgICAgICB2YXIgZm9ybWF0cyA9IGhpbnRzID09PSBudWxsIHx8IGhpbnRzID09PSB1bmRlZmluZWQgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5QT1NTSUJMRV9GT1JNQVRTKTtcclxuICAgICAgICB2YXIgcmVhZGVycyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIGlmIChmb3JtYXRzICE9PSBudWxsICYmIGZvcm1hdHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YXIgYWRkT25lRFJlYWRlciA9IGZvcm1hdHMuc29tZShmdW5jdGlvbiAoZikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGYgPT09IEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlVQQ19BIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuVVBDX0UgfHxcclxuICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5FQU5fMTMgfHxcclxuICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5FQU5fOCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkNPREFCQVIgfHxcclxuICAgICAgICAgICAgICAgICAgICBmID09PSBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5DT0RFXzM5IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuQ09ERV85MyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGYgPT09IEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkNPREVfMTI4IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuSVRGIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuUlNTXzE0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgZiA9PT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuUlNTX0VYUEFOREVEO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gUHV0IDFEIHJlYWRlcnMgdXBmcm9udCBpbiBcIm5vcm1hbFwiIG1vZGVcclxuICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IFRPRE86IHVuY29tbWVudCBiZWxvdyBhcyB0aGV5IGFyZSBwb3J0ZWRcclxuICAgICAgICAgICAgaWYgKGFkZE9uZURSZWFkZXIgJiYgIXRyeUhhcmRlcikge1xyXG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdE9uZURSZWFkZXJfMS5kZWZhdWx0KGhpbnRzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuUVJfQ09ERSkpIHtcclxuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgUVJDb2RlUmVhZGVyXzEuZGVmYXVsdCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5EQVRBX01BVFJJWCkpIHtcclxuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgRGF0YU1hdHJpeFJlYWRlcl8xLmRlZmF1bHQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuQVpURUMpKSB7XHJcbiAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IEF6dGVjUmVhZGVyXzEuZGVmYXVsdCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5QREZfNDE3KSkge1xyXG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBQREY0MTdSZWFkZXJfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIChmb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQuTUFYSUNPREUpKSB7XHJcbiAgICAgICAgICAgIC8vICAgIHJlYWRlcnMucHVzaChuZXcgTWF4aUNvZGVSZWFkZXIoKSlcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAvLyBBdCBlbmQgaW4gXCJ0cnkgaGFyZGVyXCIgbW9kZVxyXG4gICAgICAgICAgICBpZiAoYWRkT25lRFJlYWRlciAmJiB0cnlIYXJkZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyXzEuZGVmYXVsdChoaW50cykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWFkZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoIXRyeUhhcmRlcikge1xyXG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdE9uZURSZWFkZXJfMS5kZWZhdWx0KGhpbnRzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBRUkNvZGVSZWFkZXJfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IERhdGFNYXRyaXhSZWFkZXJfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IEF6dGVjUmVhZGVyXzEuZGVmYXVsdCgpKTtcclxuICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBQREY0MTdSZWFkZXJfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgICAgICAvLyByZWFkZXJzLnB1c2gobmV3IE1heGlDb2RlUmVhZGVyKCkpXHJcbiAgICAgICAgICAgIGlmICh0cnlIYXJkZXIpIHtcclxuICAgICAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgTXVsdGlGb3JtYXRPbmVEUmVhZGVyXzEuZGVmYXVsdChoaW50cykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVhZGVycyA9IHJlYWRlcnM7IC8vIC50b0FycmF5KG5ldyBSZWFkZXJbcmVhZGVycy5zaXplKCldKVxyXG4gICAgfTtcclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIE11bHRpRm9ybWF0UmVhZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZV8xLCBfYTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkZXJzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMucmVhZGVycyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gX2MudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgTXVsdGlGb3JtYXRSZWFkZXIucHJvdG90eXBlLmRlY29kZUludGVybmFsID0gZnVuY3Rpb24gKGltYWdlKSB7XHJcbiAgICAgICAgdmFyIGVfMiwgX2E7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZGVycyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVhZGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgnTm8gcmVhZGVycyB3aGVyZSBzZWxlY3RlZCwgbm90aGluZyBjYW4gYmUgcmVhZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLnJlYWRlcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gX2MudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAvLyBUcnlpbmcgdG8gZGVjb2RlIHdpdGggJHtyZWFkZXJ9IHJlYWRlci5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5kZWNvZGUoaW1hZ2UsIHRoaXMuaGludHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgUmVhZGVyRXhjZXB0aW9uXzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFkIEV4Y2VwdGlvbi5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgnTm8gTXVsdGlGb3JtYXQgUmVhZGVycyB3ZXJlIGFibGUgdG8gZGV0ZWN0IHRoZSBjb2RlLicpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNdWx0aUZvcm1hdFJlYWRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTXVsdGlGb3JtYXRSZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpRm9ybWF0UmVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gaW1wb3J0IERhdGFNYXRyaXhXcml0ZXIgZnJvbSAnLi9kYXRhbWF0cml4L0RhdGFNYXRyaXhXcml0ZXInXHJcbi8vIGltcG9ydCBDb2RhQmFyV3JpdGVyIGZyb20gJy4vb25lZC9Db2RhQmFyV3JpdGVyJ1xyXG4vLyBpbXBvcnQgQ29kZTEyOFdyaXRlciBmcm9tICcuL29uZWQvQ29kZTEyOFdyaXRlcidcclxuLy8gaW1wb3J0IENvZGUzOVdyaXRlciBmcm9tICcuL29uZWQvQ29kZTM5V3JpdGVyJ1xyXG4vLyBpbXBvcnQgQ29kZTkzV3JpdGVyIGZyb20gJy4vb25lZC9Db2RlOTNXcml0ZXInXHJcbi8vIGltcG9ydCBFQU4xM1dyaXRlciBmcm9tICcuL29uZWQvRUFOMTNXcml0ZXInXHJcbi8vIGltcG9ydCBFQU44V3JpdGVyIGZyb20gJy4vb25lZC9FQU44V3JpdGVyJ1xyXG4vLyBpbXBvcnQgSVRGV3JpdGVyIGZyb20gJy4vb25lZC9JVEZXcml0ZXInXHJcbi8vIGltcG9ydCBVUENBV3JpdGVyIGZyb20gJy4vb25lZC9VUENBV3JpdGVyJ1xyXG4vLyBpbXBvcnQgVVBDRVdyaXRlciBmcm9tICcuL29uZWQvVVBDRVdyaXRlcidcclxuLy8gaW1wb3J0IFBERjQxN1dyaXRlciBmcm9tICcuL3BkZjQxNy9QREY0MTdXcml0ZXInXHJcbnZhciBRUkNvZGVXcml0ZXJfMSA9IHJlcXVpcmUoXCIuL3FyY29kZS9RUkNvZGVXcml0ZXJcIik7XHJcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi9CYXJjb2RlRm9ybWF0XCIpO1xyXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbi8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cclxuLyoqXHJcbiAqIFRoaXMgaXMgYSBmYWN0b3J5IGNsYXNzIHdoaWNoIGZpbmRzIHRoZSBhcHByb3ByaWF0ZSBXcml0ZXIgc3ViY2xhc3MgZm9yIHRoZSBCYXJjb2RlRm9ybWF0XHJcbiAqIHJlcXVlc3RlZCBhbmQgZW5jb2RlcyB0aGUgYmFyY29kZSB3aXRoIHRoZSBzdXBwbGllZCBjb250ZW50cy5cclxuICpcclxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcclxuICovXHJcbnZhciBNdWx0aUZvcm1hdFdyaXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE11bHRpRm9ybWF0V3JpdGVyKCkge1xyXG4gICAgfVxyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgLy8gcHVibGljIGVuY29kZShjb250ZW50czogc3RyaW5nLFxyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBCYXJjb2RlRm9ybWF0LFxyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG51bWJlciAvKmludCovLFxyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBudW1iZXIgLyppbnQqLyk6IEJpdE1hdHJpeCAvKnRocm93cyBXcml0ZXJFeGNlcHRpb24gKi8ge1xyXG4gICAgLy8gICByZXR1cm4gZW5jb2RlKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIG51bGwpXHJcbiAgICAvLyB9XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBNdWx0aUZvcm1hdFdyaXRlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBoaW50cykge1xyXG4gICAgICAgIHZhciB3cml0ZXI7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkVBTl84OlxyXG4gICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBFQU44V3JpdGVyKClcclxuICAgICAgICAgICAgLy8gICBicmVha1xyXG4gICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuVVBDX0U6XHJcbiAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IFVQQ0VXcml0ZXIoKVxyXG4gICAgICAgICAgICAvLyAgIGJyZWFrXHJcbiAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5FQU5fMTM6XHJcbiAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IEVBTjEzV3JpdGVyKClcclxuICAgICAgICAgICAgLy8gICBicmVha1xyXG4gICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuVVBDX0E6XHJcbiAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IFVQQ0FXcml0ZXIoKVxyXG4gICAgICAgICAgICAvLyAgIGJyZWFrXHJcbiAgICAgICAgICAgIGNhc2UgQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuUVJfQ09ERTpcclxuICAgICAgICAgICAgICAgIHdyaXRlciA9IG5ldyBRUkNvZGVXcml0ZXJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfMzk6XHJcbiAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IENvZGUzOVdyaXRlcigpXHJcbiAgICAgICAgICAgIC8vICAgYnJlYWtcclxuICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfOTM6XHJcbiAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IENvZGU5M1dyaXRlcigpXHJcbiAgICAgICAgICAgIC8vICAgYnJlYWtcclxuICAgICAgICAgICAgLy8gY2FzZSBCYXJjb2RlRm9ybWF0LkNPREVfMTI4OlxyXG4gICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBDb2RlMTI4V3JpdGVyKClcclxuICAgICAgICAgICAgLy8gICBicmVha1xyXG4gICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuSVRGOlxyXG4gICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBJVEZXcml0ZXIoKVxyXG4gICAgICAgICAgICAvLyAgIGJyZWFrXHJcbiAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5QREZfNDE3OlxyXG4gICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBQREY0MTdXcml0ZXIoKVxyXG4gICAgICAgICAgICAvLyAgIGJyZWFrXHJcbiAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5DT0RBQkFSOlxyXG4gICAgICAgICAgICAvLyAgIHdyaXRlciA9IG5ldyBDb2RhQmFyV3JpdGVyKClcclxuICAgICAgICAgICAgLy8gICBicmVha1xyXG4gICAgICAgICAgICAvLyBjYXNlIEJhcmNvZGVGb3JtYXQuREFUQV9NQVRSSVg6XHJcbiAgICAgICAgICAgIC8vICAgd3JpdGVyID0gbmV3IERhdGFNYXRyaXhXcml0ZXIoKVxyXG4gICAgICAgICAgICAvLyAgIGJyZWFrXHJcbiAgICAgICAgICAgIC8vIGNhc2UgQmFyY29kZUZvcm1hdC5BWlRFQzpcclxuICAgICAgICAgICAgLy8gICB3cml0ZXIgPSBuZXcgQXp0ZWNXcml0ZXIoKVxyXG4gICAgICAgICAgICAvLyAgIGJyZWFrXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnTm8gZW5jb2RlciBhdmFpbGFibGUgZm9yIGZvcm1hdCAnICsgZm9ybWF0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdyaXRlci5lbmNvZGUoY29udGVudHMsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgaGludHMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNdWx0aUZvcm1hdFdyaXRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTXVsdGlGb3JtYXRXcml0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpRm9ybWF0V3JpdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXHJcbiAqL1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTm90Rm91bmRFeGNlcHRpb24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBOb3RGb3VuZEV4Y2VwdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBOb3RGb3VuZEV4Y2VwdGlvbi5nZXROb3RGb3VuZEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTm90Rm91bmRFeGNlcHRpb247XHJcbn0oRXhjZXB0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBOb3RGb3VuZEV4Y2VwdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90Rm91bmRFeGNlcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cclxuICovXHJcbnZhciBOdWxsUG9pbnRlckV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhOdWxsUG9pbnRlckV4Y2VwdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE51bGxQb2ludGVyRXhjZXB0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBOdWxsUG9pbnRlckV4Y2VwdGlvbjtcclxufShFeGNlcHRpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE51bGxQb2ludGVyRXhjZXB0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1OdWxsUG9pbnRlckV4Y2VwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxyXG4gKi9cclxudmFyIE91dE9mTWVtb3J5RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoT3V0T2ZNZW1vcnlFcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE91dE9mTWVtb3J5RXJyb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE91dE9mTWVtb3J5RXJyb3I7XHJcbn0oRXhjZXB0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBPdXRPZk1lbW9yeUVycm9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1PdXRPZk1lbW9yeUVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXHJcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL3V0aWwvU3lzdGVtXCIpO1xyXG52YXIgTHVtaW5hbmNlU291cmNlXzEgPSByZXF1aXJlKFwiLi9MdW1pbmFuY2VTb3VyY2VcIik7XHJcbnZhciBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZV8xID0gcmVxdWlyZShcIi4vSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2VcIik7XHJcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIFRoaXMgb2JqZWN0IGV4dGVuZHMgTHVtaW5hbmNlU291cmNlIGFyb3VuZCBhbiBhcnJheSBvZiBZVVYgZGF0YSByZXR1cm5lZCBmcm9tIHRoZSBjYW1lcmEgZHJpdmVyLFxyXG4gKiB3aXRoIHRoZSBvcHRpb24gdG8gY3JvcCB0byBhIHJlY3RhbmdsZSB3aXRoaW4gdGhlIGZ1bGwgZGF0YS4gVGhpcyBjYW4gYmUgdXNlZCB0byBleGNsdWRlXHJcbiAqIHN1cGVyZmx1b3VzIHBpeGVscyBhcm91bmQgdGhlIHBlcmltZXRlciBhbmQgc3BlZWQgdXAgZGVjb2RpbmcuXHJcbiAqXHJcbiAqIEl0IHdvcmtzIGZvciBhbnkgcGl4ZWwgZm9ybWF0IHdoZXJlIHRoZSBZIGNoYW5uZWwgaXMgcGxhbmFyIGFuZCBhcHBlYXJzIGZpcnN0LCBpbmNsdWRpbmdcclxuICogWUNiQ3JfNDIwX1NQIGFuZCBZQ2JDcl80MjJfU1AuXHJcbiAqXHJcbiAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXHJcbiAqL1xyXG52YXIgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZSh5dXZEYXRhLCBkYXRhV2lkdGggLyppbnQqLywgZGF0YUhlaWdodCAvKmludCovLCBsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgcmV2ZXJzZUhvcml6b250YWwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnl1dkRhdGEgPSB5dXZEYXRhO1xyXG4gICAgICAgIF90aGlzLmRhdGFXaWR0aCA9IGRhdGFXaWR0aDtcclxuICAgICAgICBfdGhpcy5kYXRhSGVpZ2h0ID0gZGF0YUhlaWdodDtcclxuICAgICAgICBfdGhpcy5sZWZ0ID0gbGVmdDtcclxuICAgICAgICBfdGhpcy50b3AgPSB0b3A7XHJcbiAgICAgICAgaWYgKGxlZnQgKyB3aWR0aCA+IGRhdGFXaWR0aCB8fCB0b3AgKyBoZWlnaHQgPiBkYXRhSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdDcm9wIHJlY3RhbmdsZSBkb2VzIG5vdCBmaXQgd2l0aGluIGltYWdlIGRhdGEuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXZlcnNlSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICBfdGhpcy5yZXZlcnNlSG9yaXpvbnRhbCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5nZXRSb3cgPSBmdW5jdGlvbiAoeSAvKmludCovLCByb3cpIHtcclxuICAgICAgICBpZiAoeSA8IDAgfHwgeSA+PSB0aGlzLmdldEhlaWdodCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdSZXF1ZXN0ZWQgcm93IGlzIG91dHNpZGUgdGhlIGltYWdlOiAnICsgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcclxuICAgICAgICBpZiAocm93ID09PSBudWxsIHx8IHJvdyA9PT0gdW5kZWZpbmVkIHx8IHJvdy5sZW5ndGggPCB3aWR0aCkge1xyXG4gICAgICAgICAgICByb3cgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gKHkgKyB0aGlzLnRvcCkgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDtcclxuICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weSh0aGlzLnl1dkRhdGEsIG9mZnNldCwgcm93LCAwLCB3aWR0aCk7XHJcbiAgICAgICAgcmV0dXJuIHJvdztcclxuICAgIH07XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgLy8gSWYgdGhlIGNhbGxlciBhc2tzIGZvciB0aGUgZW50aXJlIHVuZGVybHlpbmcgaW1hZ2UsIHNhdmUgdGhlIGNvcHkgYW5kIGdpdmUgdGhlbSB0aGVcclxuICAgICAgICAvLyBvcmlnaW5hbCBkYXRhLiBUaGUgZG9jcyBzcGVjaWZpY2FsbHkgd2FybiB0aGF0IHJlc3VsdC5sZW5ndGggbXVzdCBiZSBpZ25vcmVkLlxyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy5kYXRhV2lkdGggJiYgaGVpZ2h0ID09PSB0aGlzLmRhdGFIZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueXV2RGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFyZWEgPSB3aWR0aCAqIGhlaWdodDtcclxuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGFyZWEpO1xyXG4gICAgICAgIHZhciBpbnB1dE9mZnNldCA9IHRoaXMudG9wICogdGhpcy5kYXRhV2lkdGggKyB0aGlzLmxlZnQ7XHJcbiAgICAgICAgLy8gSWYgdGhlIHdpZHRoIG1hdGNoZXMgdGhlIGZ1bGwgd2lkdGggb2YgdGhlIHVuZGVybHlpbmcgZGF0YSwgcGVyZm9ybSBhIHNpbmdsZSBjb3B5LlxyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy5kYXRhV2lkdGgpIHtcclxuICAgICAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkodGhpcy55dXZEYXRhLCBpbnB1dE9mZnNldCwgbWF0cml4LCAwLCBhcmVhKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNvcHkgb25lIGNyb3BwZWQgcm93IGF0IGEgdGltZS5cclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXRPZmZzZXQgPSB5ICogd2lkdGg7XHJcbiAgICAgICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KHRoaXMueXV2RGF0YSwgaW5wdXRPZmZzZXQsIG1hdHJpeCwgb3V0cHV0T2Zmc2V0LCB3aWR0aCk7XHJcbiAgICAgICAgICAgIGlucHV0T2Zmc2V0ICs9IHRoaXMuZGF0YVdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfTtcclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuaXNDcm9wU3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuY3JvcCA9IGZ1bmN0aW9uIChsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlKHRoaXMueXV2RGF0YSwgdGhpcy5kYXRhV2lkdGgsIHRoaXMuZGF0YUhlaWdodCwgdGhpcy5sZWZ0ICsgbGVmdCwgdGhpcy50b3AgKyB0b3AsIHdpZHRoLCBoZWlnaHQsIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnJlbmRlclRodW1ibmFpbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCkgLyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUjtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKSAvIFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZS5USFVNQk5BSUxfU0NBTEVfRkFDVE9SO1xyXG4gICAgICAgIHZhciBwaXhlbHMgPSBuZXcgSW50MzJBcnJheSh3aWR0aCAqIGhlaWdodCk7XHJcbiAgICAgICAgdmFyIHl1diA9IHRoaXMueXV2RGF0YTtcclxuICAgICAgICB2YXIgaW5wdXRPZmZzZXQgPSB0aGlzLnRvcCAqIHRoaXMuZGF0YVdpZHRoICsgdGhpcy5sZWZ0O1xyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgdmFyIG91dHB1dE9mZnNldCA9IHkgKiB3aWR0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JleSA9IHl1dltpbnB1dE9mZnNldCArIHggKiBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUl0gJiAweGZmO1xyXG4gICAgICAgICAgICAgICAgcGl4ZWxzW291dHB1dE9mZnNldCArIHhdID0gMHhGRjAwMDAwMCB8IChncmV5ICogMHgwMDAxMDEwMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5wdXRPZmZzZXQgKz0gdGhpcy5kYXRhV2lkdGggKiBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBpeGVscztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gd2lkdGggb2YgaW1hZ2UgZnJvbSB7QGxpbmsgI3JlbmRlclRodW1ibmFpbCgpfVxyXG4gICAgICovXHJcbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldFRodW1ibmFpbFdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgLyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gaGVpZ2h0IG9mIGltYWdlIGZyb20ge0BsaW5rICNyZW5kZXJUaHVtYm5haWwoKX1cclxuICAgICAqL1xyXG4gICAgUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5nZXRUaHVtYm5haWxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVpZ2h0KCkgLyBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUjtcclxuICAgIH07XHJcbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLnJldmVyc2VIb3Jpem9udGFsID0gZnVuY3Rpb24gKHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIHl1dkRhdGEgPSB0aGlzLnl1dkRhdGE7XHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDAsIHJvd1N0YXJ0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDsgeSA8IGhlaWdodDsgeSsrLCByb3dTdGFydCArPSB0aGlzLmRhdGFXaWR0aCkge1xyXG4gICAgICAgICAgICB2YXIgbWlkZGxlID0gcm93U3RhcnQgKyB3aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHgxID0gcm93U3RhcnQsIHgyID0gcm93U3RhcnQgKyB3aWR0aCAtIDE7IHgxIDwgbWlkZGxlOyB4MSsrLCB4Mi0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IHl1dkRhdGFbeDFdO1xyXG4gICAgICAgICAgICAgICAgeXV2RGF0YVt4MV0gPSB5dXZEYXRhW3gyXTtcclxuICAgICAgICAgICAgICAgIHl1dkRhdGFbeDJdID0gdGVtcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEludmVydGVkTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuVEhVTUJOQUlMX1NDQUxFX0ZBQ1RPUiA9IDI7XHJcbiAgICByZXR1cm4gUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlO1xyXG59KEx1bWluYW5jZVNvdXJjZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cclxucmVxdWlyZShcIi4vSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2VcIik7IC8vIHJlcXVpcmVkIGJlY2F1c2Ugb2YgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGJldHdlZW4gTHVtaW5hbmNlU291cmNlIGFuZCBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZVxyXG52YXIgSW52ZXJ0ZWRMdW1pbmFuY2VTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0ludmVydGVkTHVtaW5hbmNlU291cmNlXCIpO1xyXG52YXIgTHVtaW5hbmNlU291cmNlXzEgPSByZXF1aXJlKFwiLi9MdW1pbmFuY2VTb3VyY2VcIik7XHJcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL3V0aWwvU3lzdGVtXCIpO1xyXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGlzIHVzZWQgdG8gaGVscCBkZWNvZGUgaW1hZ2VzIGZyb20gZmlsZXMgd2hpY2ggYXJyaXZlIGFzIFJHQiBkYXRhIGZyb21cclxuICogYW4gQVJHQiBwaXhlbCBhcnJheS4gSXQgZG9lcyBub3Qgc3VwcG9ydCByb3RhdGlvbi5cclxuICpcclxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcclxuICogQGF1dGhvciBCZXRhbWlub3NcclxuICovXHJcbnZhciBSR0JMdW1pbmFuY2VTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUkdCTHVtaW5hbmNlU291cmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUkdCTHVtaW5hbmNlU291cmNlKGx1bWluYW5jZXMsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBkYXRhV2lkdGggLyppbnQqLywgZGF0YUhlaWdodCAvKmludCovLCBsZWZ0IC8qaW50Ki8sIHRvcCAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kYXRhV2lkdGggPSBkYXRhV2lkdGg7XHJcbiAgICAgICAgX3RoaXMuZGF0YUhlaWdodCA9IGRhdGFIZWlnaHQ7XHJcbiAgICAgICAgX3RoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgX3RoaXMudG9wID0gdG9wO1xyXG4gICAgICAgIGlmIChsdW1pbmFuY2VzLkJZVEVTX1BFUl9FTEVNRU5UID09PSA0KSB7IC8vIEludDMyQXJyYXlcclxuICAgICAgICAgICAgdmFyIHNpemUgPSB3aWR0aCAqIGhlaWdodDtcclxuICAgICAgICAgICAgdmFyIGx1bWluYW5jZXNVaW50OEFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHNpemUpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBzaXplOyBvZmZzZXQrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gbHVtaW5hbmNlc1tvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHIgPSAocGl4ZWwgPj4gMTYpICYgMHhmZjsgLy8gcmVkXHJcbiAgICAgICAgICAgICAgICB2YXIgZzIgPSAocGl4ZWwgPj4gNykgJiAweDFmZTsgLy8gMiAqIGdyZWVuXHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9IHBpeGVsICYgMHhmZjsgLy8gYmx1ZVxyXG4gICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGdyZWVuLWZhdm91cmluZyBhdmVyYWdlIGNoZWFwbHlcclxuICAgICAgICAgICAgICAgIGx1bWluYW5jZXNVaW50OEFycmF5W29mZnNldF0gPSAvKihieXRlKSAqLyAoKHIgKyBnMiArIGIpIC8gNCkgJiAweEZGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF90aGlzLmx1bWluYW5jZXMgPSBsdW1pbmFuY2VzVWludDhBcnJheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF90aGlzLmx1bWluYW5jZXMgPSBsdW1pbmFuY2VzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBkYXRhV2lkdGgpIHtcclxuICAgICAgICAgICAgX3RoaXMuZGF0YVdpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRhdGFIZWlnaHQpIHtcclxuICAgICAgICAgICAgX3RoaXMuZGF0YUhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gbGVmdCkge1xyXG4gICAgICAgICAgICBfdGhpcy5sZWZ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdG9wKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRvcCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5sZWZ0ICsgd2lkdGggPiBfdGhpcy5kYXRhV2lkdGggfHwgX3RoaXMudG9wICsgaGVpZ2h0ID4gX3RoaXMuZGF0YUhlaWdodCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnQ3JvcCByZWN0YW5nbGUgZG9lcyBub3QgZml0IHdpdGhpbiBpbWFnZSBkYXRhLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBSR0JMdW1pbmFuY2VTb3VyY2UucHJvdG90eXBlLmdldFJvdyA9IGZ1bmN0aW9uICh5IC8qaW50Ki8sIHJvdykge1xyXG4gICAgICAgIGlmICh5IDwgMCB8fCB5ID49IHRoaXMuZ2V0SGVpZ2h0KCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ1JlcXVlc3RlZCByb3cgaXMgb3V0c2lkZSB0aGUgaW1hZ2U6ICcgKyB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xyXG4gICAgICAgIGlmIChyb3cgPT09IG51bGwgfHwgcm93ID09PSB1bmRlZmluZWQgfHwgcm93Lmxlbmd0aCA8IHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHJvdyA9IG5ldyBVaW50OENsYW1wZWRBcnJheSh3aWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvZmZzZXQgPSAoeSArIHRoaXMudG9wKSAqIHRoaXMuZGF0YVdpZHRoICsgdGhpcy5sZWZ0O1xyXG4gICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KHRoaXMubHVtaW5hbmNlcywgb2Zmc2V0LCByb3csIDAsIHdpZHRoKTtcclxuICAgICAgICByZXR1cm4gcm93O1xyXG4gICAgfTtcclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIFJHQkx1bWluYW5jZVNvdXJjZS5wcm90b3R5cGUuZ2V0TWF0cml4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcclxuICAgICAgICAvLyBJZiB0aGUgY2FsbGVyIGFza3MgZm9yIHRoZSBlbnRpcmUgdW5kZXJseWluZyBpbWFnZSwgc2F2ZSB0aGUgY29weSBhbmQgZ2l2ZSB0aGVtIHRoZVxyXG4gICAgICAgIC8vIG9yaWdpbmFsIGRhdGEuIFRoZSBkb2NzIHNwZWNpZmljYWxseSB3YXJuIHRoYXQgcmVzdWx0Lmxlbmd0aCBtdXN0IGJlIGlnbm9yZWQuXHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB0aGlzLmRhdGFXaWR0aCAmJiBoZWlnaHQgPT09IHRoaXMuZGF0YUhlaWdodCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sdW1pbmFuY2VzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYXJlYSA9IHdpZHRoICogaGVpZ2h0O1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgVWludDhDbGFtcGVkQXJyYXkoYXJlYSk7XHJcbiAgICAgICAgdmFyIGlucHV0T2Zmc2V0ID0gdGhpcy50b3AgKiB0aGlzLmRhdGFXaWR0aCArIHRoaXMubGVmdDtcclxuICAgICAgICAvLyBJZiB0aGUgd2lkdGggbWF0Y2hlcyB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgdW5kZXJseWluZyBkYXRhLCBwZXJmb3JtIGEgc2luZ2xlIGNvcHkuXHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB0aGlzLmRhdGFXaWR0aCkge1xyXG4gICAgICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weSh0aGlzLmx1bWluYW5jZXMsIGlucHV0T2Zmc2V0LCBtYXRyaXgsIDAsIGFyZWEpO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdGhlcndpc2UgY29weSBvbmUgY3JvcHBlZCByb3cgYXQgYSB0aW1lLlxyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgdmFyIG91dHB1dE9mZnNldCA9IHkgKiB3aWR0aDtcclxuICAgICAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkodGhpcy5sdW1pbmFuY2VzLCBpbnB1dE9mZnNldCwgbWF0cml4LCBvdXRwdXRPZmZzZXQsIHdpZHRoKTtcclxuICAgICAgICAgICAgaW5wdXRPZmZzZXQgKz0gdGhpcy5kYXRhV2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgUkdCTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5pc0Nyb3BTdXBwb3J0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgUkdCTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5jcm9wID0gZnVuY3Rpb24gKGxlZnQgLyppbnQqLywgdG9wIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSR0JMdW1pbmFuY2VTb3VyY2UodGhpcy5sdW1pbmFuY2VzLCB3aWR0aCwgaGVpZ2h0LCB0aGlzLmRhdGFXaWR0aCwgdGhpcy5kYXRhSGVpZ2h0LCB0aGlzLmxlZnQgKyBsZWZ0LCB0aGlzLnRvcCArIHRvcCk7XHJcbiAgICB9O1xyXG4gICAgUkdCTHVtaW5hbmNlU291cmNlLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZV8xLmRlZmF1bHQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJHQkx1bWluYW5jZVNvdXJjZTtcclxufShMdW1pbmFuY2VTb3VyY2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJHQkx1bWluYW5jZVNvdXJjZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UkdCTHVtaW5hbmNlU291cmNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXHJcbiAqL1xyXG52YXIgUmVhZGVyRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFJlYWRlckV4Y2VwdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJlYWRlckV4Y2VwdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUmVhZGVyRXhjZXB0aW9uO1xyXG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUmVhZGVyRXhjZXB0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFkZXJFeGNlcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL0V4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIEN1c3RvbSBFcnJvciBjbGFzcyBvZiB0eXBlIEV4Y2VwdGlvbi5cclxuICovXHJcbnZhciBSZWVkU29sb21vbkV4Y2VwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSZWVkU29sb21vbkV4Y2VwdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJlZWRTb2xvbW9uRXhjZXB0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBSZWVkU29sb21vbkV4Y2VwdGlvbjtcclxufShFeGNlcHRpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJlZWRTb2xvbW9uRXhjZXB0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWVkU29sb21vbkV4Y2VwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL3V0aWwvU3lzdGVtXCIpO1xyXG4vKipcclxuICogPHA+RW5jYXBzdWxhdGVzIHRoZSByZXN1bHQgb2YgZGVjb2RpbmcgYSBiYXJjb2RlIHdpdGhpbiBhbiBpbWFnZS48L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqL1xyXG52YXIgUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgdGV4dDogc3RyaW5nLFxyXG4gICAgLy8gICAgICAgICAgICAgICBVaW50OEFycmF5IHJhd0J5dGVzLFxyXG4gICAgLy8gICAgICAgICAgICAgICBSZXN1bHRQb2NvbnN0IHJlc3VsdFBvaW50czogSW50MzJBcnJheSxcclxuICAgIC8vICAgICAgICAgICAgICAgQmFyY29kZUZvcm1hdCBmb3JtYXQpIHtcclxuICAgIC8vICAgdGhpcyh0ZXh0LCByYXdCeXRlcywgcmVzdWx0UG9pbnRzLCBmb3JtYXQsIFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpKVxyXG4gICAgLy8gfVxyXG4gICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKHRleHQ6IHN0cmluZyxcclxuICAgIC8vICAgICAgICAgICAgICAgVWludDhBcnJheSByYXdCeXRlcyxcclxuICAgIC8vICAgICAgICAgICAgICAgUmVzdWx0UG9jb25zdCByZXN1bHRQb2ludHM6IEludDMyQXJyYXksXHJcbiAgICAvLyAgICAgICAgICAgICAgIEJhcmNvZGVGb3JtYXQgZm9ybWF0LFxyXG4gICAgLy8gICAgICAgICAgICAgICBsb25nIHRpbWVzdGFtcCkge1xyXG4gICAgLy8gICB0aGlzKHRleHQsIHJhd0J5dGVzLCByYXdCeXRlcyA9PSBudWxsID8gMCA6IDggKiByYXdCeXRlcy5sZW5ndGgsXHJcbiAgICAvLyAgICAgICAgcmVzdWx0UG9pbnRzLCBmb3JtYXQsIHRpbWVzdGFtcClcclxuICAgIC8vIH1cclxuICAgIGZ1bmN0aW9uIFJlc3VsdCh0ZXh0LCByYXdCeXRlcywgbnVtQml0cywgcmVzdWx0UG9pbnRzLCBmb3JtYXQsIHRpbWVzdGFtcCkge1xyXG4gICAgICAgIGlmIChudW1CaXRzID09PSB2b2lkIDApIHsgbnVtQml0cyA9IHJhd0J5dGVzID09IG51bGwgPyAwIDogOCAqIHJhd0J5dGVzLmxlbmd0aDsgfVxyXG4gICAgICAgIGlmICh0aW1lc3RhbXAgPT09IHZvaWQgMCkgeyB0aW1lc3RhbXAgPSBTeXN0ZW1fMS5kZWZhdWx0LmN1cnJlbnRUaW1lTWlsbGlzKCk7IH1cclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgICAgIHRoaXMucmF3Qnl0ZXMgPSByYXdCeXRlcztcclxuICAgICAgICB0aGlzLm51bUJpdHMgPSBudW1CaXRzO1xyXG4gICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gcmVzdWx0UG9pbnRzO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xyXG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZXN0YW1wO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICAgICAgdGhpcy5yYXdCeXRlcyA9IHJhd0J5dGVzO1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IG51bUJpdHMgfHwgbnVsbCA9PT0gbnVtQml0cykge1xyXG4gICAgICAgICAgICB0aGlzLm51bUJpdHMgPSAocmF3Qnl0ZXMgPT09IG51bGwgfHwgcmF3Qnl0ZXMgPT09IHVuZGVmaW5lZCkgPyAwIDogOCAqIHJhd0J5dGVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubnVtQml0cyA9IG51bUJpdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gcmVzdWx0UG9pbnRzO1xyXG4gICAgICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xyXG4gICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEgPSBudWxsO1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHRpbWVzdGFtcCB8fCBudWxsID09PSB0aW1lc3RhbXApIHtcclxuICAgICAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBTeXN0ZW1fMS5kZWZhdWx0LmN1cnJlbnRUaW1lTWlsbGlzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gcmF3IHRleHQgZW5jb2RlZCBieSB0aGUgYmFyY29kZVxyXG4gICAgICovXHJcbiAgICBSZXN1bHQucHJvdG90eXBlLmdldFRleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gcmF3IGJ5dGVzIGVuY29kZWQgYnkgdGhlIGJhcmNvZGUsIGlmIGFwcGxpY2FibGUsIG90aGVyd2lzZSB7QGNvZGUgbnVsbH1cclxuICAgICAqL1xyXG4gICAgUmVzdWx0LnByb3RvdHlwZS5nZXRSYXdCeXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yYXdCeXRlcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gaG93IG1hbnkgYml0cyBvZiB7QGxpbmsgI2dldFJhd0J5dGVzKCl9IGFyZSB2YWxpZDsgdHlwaWNhbGx5IDggdGltZXMgaXRzIGxlbmd0aFxyXG4gICAgICogQHNpbmNlIDMuMy4wXHJcbiAgICAgKi9cclxuICAgIFJlc3VsdC5wcm90b3R5cGUuZ2V0TnVtQml0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1CaXRzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBwb2ludHMgcmVsYXRlZCB0byB0aGUgYmFyY29kZSBpbiB0aGUgaW1hZ2UuIFRoZXNlIGFyZSB0eXBpY2FsbHkgcG9pbnRzXHJcbiAgICAgKiAgICAgICAgIGlkZW50aWZ5aW5nIGZpbmRlciBwYXR0ZXJucyBvciB0aGUgY29ybmVycyBvZiB0aGUgYmFyY29kZS4gVGhlIGV4YWN0IG1lYW5pbmcgaXNcclxuICAgICAqICAgICAgICAgc3BlY2lmaWMgdG8gdGhlIHR5cGUgb2YgYmFyY29kZSB0aGF0IHdhcyBkZWNvZGVkLlxyXG4gICAgICovXHJcbiAgICBSZXN1bHQucHJvdG90eXBlLmdldFJlc3VsdFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRQb2ludHM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtAbGluayBCYXJjb2RlRm9ybWF0fSByZXByZXNlbnRpbmcgdGhlIGZvcm1hdCBvZiB0aGUgYmFyY29kZSB0aGF0IHdhcyBkZWNvZGVkXHJcbiAgICAgKi9cclxuICAgIFJlc3VsdC5wcm90b3R5cGUuZ2V0QmFyY29kZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHtAbGluayBNYXB9IG1hcHBpbmcge0BsaW5rIFJlc3VsdE1ldGFkYXRhVHlwZX0ga2V5cyB0byB2YWx1ZXMuIE1heSBiZVxyXG4gICAgICogICB7QGNvZGUgbnVsbH0uIFRoaXMgY29udGFpbnMgb3B0aW9uYWwgbWV0YWRhdGEgYWJvdXQgd2hhdCB3YXMgZGV0ZWN0ZWQgYWJvdXQgdGhlIGJhcmNvZGUsXHJcbiAgICAgKiAgIGxpa2Ugb3JpZW50YXRpb24uXHJcbiAgICAgKi9cclxuICAgIFJlc3VsdC5wcm90b3R5cGUuZ2V0UmVzdWx0TWV0YWRhdGEgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0TWV0YWRhdGE7XHJcbiAgICB9O1xyXG4gICAgUmVzdWx0LnByb3RvdHlwZS5wdXRNZXRhZGF0YSA9IGZ1bmN0aW9uICh0eXBlLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlc3VsdE1ldGFkYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzdWx0TWV0YWRhdGEuc2V0KHR5cGUsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBSZXN1bHQucHJvdG90eXBlLnB1dEFsbE1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XHJcbiAgICAgICAgaWYgKG1ldGFkYXRhICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdE1ldGFkYXRhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhID0gbWV0YWRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdE1ldGFkYXRhID0gbmV3IE1hcChtZXRhZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUmVzdWx0LnByb3RvdHlwZS5hZGRSZXN1bHRQb2ludHMgPSBmdW5jdGlvbiAobmV3UG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIG9sZFBvaW50cyA9IHRoaXMucmVzdWx0UG9pbnRzO1xyXG4gICAgICAgIGlmIChvbGRQb2ludHMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMgPSBuZXdQb2ludHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5ld1BvaW50cyAhPT0gbnVsbCAmJiBuZXdQb2ludHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgYWxsUG9pbnRzID0gbmV3IEFycmF5KG9sZFBvaW50cy5sZW5ndGggKyBuZXdQb2ludHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkob2xkUG9pbnRzLCAwLCBhbGxQb2ludHMsIDAsIG9sZFBvaW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShuZXdQb2ludHMsIDAsIGFsbFBvaW50cywgb2xkUG9pbnRzLmxlbmd0aCwgbmV3UG9pbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRzID0gYWxsUG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZXN1bHQucHJvdG90eXBlLmdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXA7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgUmVzdWx0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXN1bHQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJlc3VsdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVzdWx0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZyB7Ki9cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgc29tZSB0eXBlIG9mIG1ldGFkYXRhIGFib3V0IHRoZSByZXN1bHQgb2YgdGhlIGRlY29kaW5nIHRoYXQgdGhlIGRlY29kZXJcclxuICogd2lzaGVzIHRvIGNvbW11bmljYXRlIGJhY2sgdG8gdGhlIGNhbGxlci5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICovXHJcbnZhciBSZXN1bHRNZXRhZGF0YVR5cGU7XHJcbihmdW5jdGlvbiAoUmVzdWx0TWV0YWRhdGFUeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFVuc3BlY2lmaWVkLCBhcHBsaWNhdGlvbi1zcGVjaWZpYyBtZXRhZGF0YS4gTWFwcyB0byBhbiB1bnNwZWNpZmllZCB7QGxpbmsgT2JqZWN0fS5cclxuICAgICAqL1xyXG4gICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIk9USEVSXCJdID0gMF0gPSBcIk9USEVSXCI7XHJcbiAgICAvKipcclxuICAgICAqIERlbm90ZXMgdGhlIGxpa2VseSBhcHByb3hpbWF0ZSBvcmllbnRhdGlvbiBvZiB0aGUgYmFyY29kZSBpbiB0aGUgaW1hZ2UuIFRoaXMgdmFsdWVcclxuICAgICAqIGlzIGdpdmVuIGFzIGRlZ3JlZXMgcm90YXRlZCBjbG9ja3dpc2UgZnJvbSB0aGUgbm9ybWFsLCB1cHJpZ2h0IG9yaWVudGF0aW9uLlxyXG4gICAgICogRm9yIGV4YW1wbGUgYSAxRCBiYXJjb2RlIHdoaWNoIHdhcyBmb3VuZCBieSByZWFkaW5nIHRvcC10by1ib3R0b20gd291bGQgYmVcclxuICAgICAqIHNhaWQgdG8gaGF2ZSBvcmllbnRhdGlvbiBcIjkwXCIuIFRoaXMga2V5IG1hcHMgdG8gYW4ge0BsaW5rIEludGVnZXJ9IHdob3NlXHJcbiAgICAgKiB2YWx1ZSBpcyBpbiB0aGUgcmFuZ2UgWzAsMzYwKS5cclxuICAgICAqL1xyXG4gICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIk9SSUVOVEFUSU9OXCJdID0gMV0gPSBcIk9SSUVOVEFUSU9OXCI7XHJcbiAgICAvKipcclxuICAgICAqIDxwPjJEIGJhcmNvZGUgZm9ybWF0cyB0eXBpY2FsbHkgZW5jb2RlIHRleHQsIGJ1dCBhbGxvdyBmb3IgYSBzb3J0IG9mICdieXRlIG1vZGUnXHJcbiAgICAgKiB3aGljaCBpcyBzb21ldGltZXMgdXNlZCB0byBlbmNvZGUgYmluYXJ5IGRhdGEuIFdoaWxlIHtAbGluayBSZXN1bHR9IG1ha2VzIGF2YWlsYWJsZVxyXG4gICAgICogdGhlIGNvbXBsZXRlIHJhdyBieXRlcyBpbiB0aGUgYmFyY29kZSBmb3IgdGhlc2UgZm9ybWF0cywgaXQgZG9lcyBub3Qgb2ZmZXIgdGhlIGJ5dGVzXHJcbiAgICAgKiBmcm9tIHRoZSBieXRlIHNlZ21lbnRzIGFsb25lLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiA8cD5UaGlzIG1hcHMgdG8gYSB7QGxpbmsgamF2YS51dGlsLkxpc3R9IG9mIGJ5dGUgYXJyYXlzIGNvcnJlc3BvbmRpbmcgdG8gdGhlXHJcbiAgICAgKiByYXcgYnl0ZXMgaW4gdGhlIGJ5dGUgc2VnbWVudHMgaW4gdGhlIGJhcmNvZGUsIGluIG9yZGVyLjwvcD5cclxuICAgICAqL1xyXG4gICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIkJZVEVfU0VHTUVOVFNcIl0gPSAyXSA9IFwiQllURV9TRUdNRU5UU1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFcnJvciBjb3JyZWN0aW9uIGxldmVsIHVzZWQsIGlmIGFwcGxpY2FibGUuIFRoZSB2YWx1ZSB0eXBlIGRlcGVuZHMgb24gdGhlXHJcbiAgICAgKiBmb3JtYXQsIGJ1dCBpcyB0eXBpY2FsbHkgYSBTdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJFUlJPUl9DT1JSRUNUSU9OX0xFVkVMXCJdID0gM10gPSBcIkVSUk9SX0NPUlJFQ1RJT05fTEVWRUxcIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIHNvbWUgcGVyaW9kaWNhbHMsIGluZGljYXRlcyB0aGUgaXNzdWUgbnVtYmVyIGFzIGFuIHtAbGluayBJbnRlZ2VyfS5cclxuICAgICAqL1xyXG4gICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIklTU1VFX05VTUJFUlwiXSA9IDRdID0gXCJJU1NVRV9OVU1CRVJcIjtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIHNvbWUgcHJvZHVjdHMsIGluZGljYXRlcyB0aGUgc3VnZ2VzdGVkIHJldGFpbCBwcmljZSBpbiB0aGUgYmFyY29kZSBhcyBhXHJcbiAgICAgKiBmb3JtYXR0ZWQge0BsaW5rIFN0cmluZ30uXHJcbiAgICAgKi9cclxuICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJTVUdHRVNURURfUFJJQ0VcIl0gPSA1XSA9IFwiU1VHR0VTVEVEX1BSSUNFXCI7XHJcbiAgICAvKipcclxuICAgICAqIEZvciBzb21lIHByb2R1Y3RzLCB0aGUgcG9zc2libGUgY291bnRyeSBvZiBtYW51ZmFjdHVyZSBhcyBhIHtAbGluayBTdHJpbmd9IGRlbm90aW5nIHRoZVxyXG4gICAgICogSVNPIGNvdW50cnkgY29kZS4gU29tZSBtYXAgdG8gbXVsdGlwbGUgcG9zc2libGUgY291bnRyaWVzLCBsaWtlIFwiVVMvQ0FcIi5cclxuICAgICAqL1xyXG4gICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlBPU1NJQkxFX0NPVU5UUllcIl0gPSA2XSA9IFwiUE9TU0lCTEVfQ09VTlRSWVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGb3Igc29tZSBwcm9kdWN0cywgdGhlIGV4dGVuc2lvbiB0ZXh0XHJcbiAgICAgKi9cclxuICAgIFJlc3VsdE1ldGFkYXRhVHlwZVtSZXN1bHRNZXRhZGF0YVR5cGVbXCJVUENfRUFOX0VYVEVOU0lPTlwiXSA9IDddID0gXCJVUENfRUFOX0VYVEVOU0lPTlwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQREY0MTctc3BlY2lmaWMgbWV0YWRhdGFcclxuICAgICAqL1xyXG4gICAgUmVzdWx0TWV0YWRhdGFUeXBlW1Jlc3VsdE1ldGFkYXRhVHlwZVtcIlBERjQxN19FWFRSQV9NRVRBREFUQVwiXSA9IDhdID0gXCJQREY0MTdfRVhUUkFfTUVUQURBVEFcIjtcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGNvZGUgZm9ybWF0IHN1cHBvcnRzIHN0cnVjdHVyZWQgYXBwZW5kIGFuZCB0aGUgY3VycmVudCBzY2FubmVkIGNvZGUgaXMgcGFydCBvZiBvbmUgdGhlbiB0aGVcclxuICAgICAqIHNlcXVlbmNlIG51bWJlciBpcyBnaXZlbiB3aXRoIGl0LlxyXG4gICAgICovXHJcbiAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiU1RSVUNUVVJFRF9BUFBFTkRfU0VRVUVOQ0VcIl0gPSA5XSA9IFwiU1RSVUNUVVJFRF9BUFBFTkRfU0VRVUVOQ0VcIjtcclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGNvZGUgZm9ybWF0IHN1cHBvcnRzIHN0cnVjdHVyZWQgYXBwZW5kIGFuZCB0aGUgY3VycmVudCBzY2FubmVkIGNvZGUgaXMgcGFydCBvZiBvbmUgdGhlbiB0aGVcclxuICAgICAqIHBhcml0eSBpcyBnaXZlbiB3aXRoIGl0LlxyXG4gICAgICovXHJcbiAgICBSZXN1bHRNZXRhZGF0YVR5cGVbUmVzdWx0TWV0YWRhdGFUeXBlW1wiU1RSVUNUVVJFRF9BUFBFTkRfUEFSSVRZXCJdID0gMTBdID0gXCJTVFJVQ1RVUkVEX0FQUEVORF9QQVJJVFlcIjtcclxufSkoUmVzdWx0TWV0YWRhdGFUeXBlIHx8IChSZXN1bHRNZXRhZGF0YVR5cGUgPSB7fSkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSZXN1bHRNZXRhZGF0YVR5cGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlc3VsdE1ldGFkYXRhVHlwZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcgeyovXHJcbnZhciBNYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9kZXRlY3Rvci9NYXRoVXRpbHNcIik7XHJcbnZhciBGbG9hdF8xID0gcmVxdWlyZShcIi4vdXRpbC9GbG9hdFwiKTtcclxuLyoqXHJcbiAqIDxwPkVuY2Fwc3VsYXRlcyBhIHBvaW50IG9mIGludGVyZXN0IGluIGFuIGltYWdlIGNvbnRhaW5pbmcgYSBiYXJjb2RlLiBUeXBpY2FsbHksIHRoaXNcclxuICogd291bGQgYmUgdGhlIGxvY2F0aW9uIG9mIGEgZmluZGVyIHBhdHRlcm4gb3IgdGhlIGNvcm5lciBvZiB0aGUgYmFyY29kZSwgZm9yIGV4YW1wbGUuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIFJlc3VsdFBvaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUmVzdWx0UG9pbnQoeCwgeSkge1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgIH1cclxuICAgIFJlc3VsdFBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLng7XHJcbiAgICB9O1xyXG4gICAgUmVzdWx0UG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueTtcclxuICAgIH07XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBSZXN1bHRQb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgUmVzdWx0UG9pbnQpIHtcclxuICAgICAgICAgICAgdmFyIG90aGVyUG9pbnQgPSBvdGhlcjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gb3RoZXJQb2ludC54ICYmIHRoaXMueSA9PT0gb3RoZXJQb2ludC55O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgUmVzdWx0UG9pbnQucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAzMSAqIEZsb2F0XzEuZGVmYXVsdC5mbG9hdFRvSW50Qml0cyh0aGlzLngpICsgRmxvYXRfMS5kZWZhdWx0LmZsb2F0VG9JbnRCaXRzKHRoaXMueSk7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgUmVzdWx0UG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnKCcgKyB0aGlzLnggKyAnLCcgKyB0aGlzLnkgKyAnKSc7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBPcmRlcnMgYW4gYXJyYXkgb2YgdGhyZWUgUmVzdWx0UG9pbnRzIGluIGFuIG9yZGVyIFtBLEIsQ10gc3VjaCB0aGF0IEFCIGlzIGxlc3MgdGhhbiBBQ1xyXG4gICAgICogYW5kIEJDIGlzIGxlc3MgdGhhbiBBQywgYW5kIHRoZSBhbmdsZSBiZXR3ZWVuIEJDIGFuZCBCQSBpcyBsZXNzIHRoYW4gMTgwIGRlZ3JlZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhdHRlcm5zIGFycmF5IG9mIHRocmVlIHtAY29kZSBSZXN1bHRQb2ludH0gdG8gb3JkZXJcclxuICAgICAqL1xyXG4gICAgUmVzdWx0UG9pbnQub3JkZXJCZXN0UGF0dGVybnMgPSBmdW5jdGlvbiAocGF0dGVybnMpIHtcclxuICAgICAgICAvLyBGaW5kIGRpc3RhbmNlcyBiZXR3ZWVuIHBhdHRlcm4gY2VudGVyc1xyXG4gICAgICAgIHZhciB6ZXJvT25lRGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHBhdHRlcm5zWzBdLCBwYXR0ZXJuc1sxXSk7XHJcbiAgICAgICAgdmFyIG9uZVR3b0Rpc3RhbmNlID0gdGhpcy5kaXN0YW5jZShwYXR0ZXJuc1sxXSwgcGF0dGVybnNbMl0pO1xyXG4gICAgICAgIHZhciB6ZXJvVHdvRGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKHBhdHRlcm5zWzBdLCBwYXR0ZXJuc1syXSk7XHJcbiAgICAgICAgdmFyIHBvaW50QTtcclxuICAgICAgICB2YXIgcG9pbnRCO1xyXG4gICAgICAgIHZhciBwb2ludEM7XHJcbiAgICAgICAgLy8gQXNzdW1lIG9uZSBjbG9zZXN0IHRvIG90aGVyIHR3byBpcyBCOyBBIGFuZCBDIHdpbGwganVzdCBiZSBndWVzc2VzIGF0IGZpcnN0XHJcbiAgICAgICAgaWYgKG9uZVR3b0Rpc3RhbmNlID49IHplcm9PbmVEaXN0YW5jZSAmJiBvbmVUd29EaXN0YW5jZSA+PSB6ZXJvVHdvRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgcG9pbnRCID0gcGF0dGVybnNbMF07XHJcbiAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzFdO1xyXG4gICAgICAgICAgICBwb2ludEMgPSBwYXR0ZXJuc1syXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoemVyb1R3b0Rpc3RhbmNlID49IG9uZVR3b0Rpc3RhbmNlICYmIHplcm9Ud29EaXN0YW5jZSA+PSB6ZXJvT25lRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgcG9pbnRCID0gcGF0dGVybnNbMV07XHJcbiAgICAgICAgICAgIHBvaW50QSA9IHBhdHRlcm5zWzBdO1xyXG4gICAgICAgICAgICBwb2ludEMgPSBwYXR0ZXJuc1syXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBvaW50QiA9IHBhdHRlcm5zWzJdO1xyXG4gICAgICAgICAgICBwb2ludEEgPSBwYXR0ZXJuc1swXTtcclxuICAgICAgICAgICAgcG9pbnRDID0gcGF0dGVybnNbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVzZSBjcm9zcyBwcm9kdWN0IHRvIGZpZ3VyZSBvdXQgd2hldGhlciBBIGFuZCBDIGFyZSBjb3JyZWN0IG9yIGZsaXBwZWQuXHJcbiAgICAgICAgLy8gVGhpcyBhc2tzIHdoZXRoZXIgQkMgeCBCQSBoYXMgYSBwb3NpdGl2ZSB6IGNvbXBvbmVudCwgd2hpY2ggaXMgdGhlIGFycmFuZ2VtZW50XHJcbiAgICAgICAgLy8gd2Ugd2FudCBmb3IgQSwgQiwgQy4gSWYgaXQncyBuZWdhdGl2ZSwgdGhlbiB3ZSd2ZSBnb3QgaXQgZmxpcHBlZCBhcm91bmQgYW5kXHJcbiAgICAgICAgLy8gc2hvdWxkIHN3YXAgQSBhbmQgQy5cclxuICAgICAgICBpZiAodGhpcy5jcm9zc1Byb2R1Y3RaKHBvaW50QSwgcG9pbnRCLCBwb2ludEMpIDwgMC4wKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gcG9pbnRBO1xyXG4gICAgICAgICAgICBwb2ludEEgPSBwb2ludEM7XHJcbiAgICAgICAgICAgIHBvaW50QyA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdHRlcm5zWzBdID0gcG9pbnRBO1xyXG4gICAgICAgIHBhdHRlcm5zWzFdID0gcG9pbnRCO1xyXG4gICAgICAgIHBhdHRlcm5zWzJdID0gcG9pbnRDO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHBhdHRlcm4xIGZpcnN0IHBhdHRlcm5cclxuICAgICAqIEBwYXJhbSBwYXR0ZXJuMiBzZWNvbmQgcGF0dGVyblxyXG4gICAgICogQHJldHVybiBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcclxuICAgICAqL1xyXG4gICAgUmVzdWx0UG9pbnQuZGlzdGFuY2UgPSBmdW5jdGlvbiAocGF0dGVybjEsIHBhdHRlcm4yKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsc18xLmRlZmF1bHQuZGlzdGFuY2UocGF0dGVybjEueCwgcGF0dGVybjEueSwgcGF0dGVybjIueCwgcGF0dGVybjIueSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB6IGNvbXBvbmVudCBvZiB0aGUgY3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIHZlY3RvcnMgQkMgYW5kIEJBLlxyXG4gICAgICovXHJcbiAgICBSZXN1bHRQb2ludC5jcm9zc1Byb2R1Y3RaID0gZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCLCBwb2ludEMpIHtcclxuICAgICAgICB2YXIgYlggPSBwb2ludEIueDtcclxuICAgICAgICB2YXIgYlkgPSBwb2ludEIueTtcclxuICAgICAgICByZXR1cm4gKChwb2ludEMueCAtIGJYKSAqIChwb2ludEEueSAtIGJZKSkgLSAoKHBvaW50Qy55IC0gYlkpICogKHBvaW50QS54IC0gYlgpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVzdWx0UG9pbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFJlc3VsdFBvaW50O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXN1bHRQb2ludC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vRXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogQ3VzdG9tIEVycm9yIGNsYXNzIG9mIHR5cGUgRXhjZXB0aW9uLlxyXG4gKi9cclxudmFyIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uO1xyXG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9FeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBDdXN0b20gRXJyb3IgY2xhc3Mgb2YgdHlwZSBFeGNlcHRpb24uXHJcbiAqL1xyXG52YXIgV3JpdGVyRXhjZXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKFdyaXRlckV4Y2VwdGlvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFdyaXRlckV4Y2VwdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gV3JpdGVyRXhjZXB0aW9uO1xyXG59KEV4Y2VwdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gV3JpdGVyRXhjZXB0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Xcml0ZXJFeGNlcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDEwIFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIERldGVjdG9yUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0RldGVjdG9yUmVzdWx0XCIpO1xyXG4vKipcclxuICogPHA+RXh0ZW5kcyB7QGxpbmsgRGV0ZWN0b3JSZXN1bHR9IHdpdGggbW9yZSBpbmZvcm1hdGlvbiBzcGVjaWZpYyB0byB0aGUgQXp0ZWMgZm9ybWF0LFxyXG4gKiBsaWtlIHRoZSBudW1iZXIgb2YgbGF5ZXJzIGFuZCB3aGV0aGVyIGl0J3MgY29tcGFjdC48L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqL1xyXG52YXIgQXp0ZWNEZXRlY3RvclJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBenRlY0RldGVjdG9yUmVzdWx0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXp0ZWNEZXRlY3RvclJlc3VsdChiaXRzLCBwb2ludHMsIGNvbXBhY3QsIG5iRGF0YWJsb2NrcywgbmJMYXllcnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBiaXRzLCBwb2ludHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY29tcGFjdCA9IGNvbXBhY3Q7XHJcbiAgICAgICAgX3RoaXMubmJEYXRhYmxvY2tzID0gbmJEYXRhYmxvY2tzO1xyXG4gICAgICAgIF90aGlzLm5iTGF5ZXJzID0gbmJMYXllcnM7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQXp0ZWNEZXRlY3RvclJlc3VsdC5wcm90b3R5cGUuZ2V0TmJMYXllcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmJMYXllcnM7XHJcbiAgICB9O1xyXG4gICAgQXp0ZWNEZXRlY3RvclJlc3VsdC5wcm90b3R5cGUuZ2V0TmJEYXRhYmxvY2tzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5iRGF0YWJsb2NrcztcclxuICAgIH07XHJcbiAgICBBenRlY0RldGVjdG9yUmVzdWx0LnByb3RvdHlwZS5pc0NvbXBhY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFjdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQXp0ZWNEZXRlY3RvclJlc3VsdDtcclxufShEZXRlY3RvclJlc3VsdF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQXp0ZWNEZXRlY3RvclJlc3VsdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXp0ZWNEZXRlY3RvclJlc3VsdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTAgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRcIik7XHJcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcclxudmFyIERlY29kZUhpbnRUeXBlXzEgPSByZXF1aXJlKFwiLi4vRGVjb2RlSGludFR5cGVcIik7XHJcbnZhciBSZXN1bHRNZXRhZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRNZXRhZGF0YVR5cGVcIik7XHJcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuLi91dGlsL1N5c3RlbVwiKTtcclxudmFyIERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL2RlY29kZXIvRGVjb2RlclwiKTtcclxudmFyIERldGVjdG9yXzEgPSByZXF1aXJlKFwiLi9kZXRlY3Rvci9EZXRlY3RvclwiKTtcclxuLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xyXG4vLyBpbXBvcnQgamF2YS51dGlsLk1hcDtcclxuLyoqXHJcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gY2FuIGRldGVjdCBhbmQgZGVjb2RlIEF6dGVjIGNvZGVzIGluIGFuIGltYWdlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcclxuICovXHJcbnZhciBBenRlY1JlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEF6dGVjUmVhZGVyKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NhdGVzIGFuZCBkZWNvZGVzIGEgRGF0YSBNYXRyaXggY29kZSBpbiBhbiBpbWFnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIGEgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY29udGVudCBlbmNvZGVkIGJ5IHRoZSBEYXRhIE1hdHJpeCBjb2RlXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZm91bmRcclxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZGVjb2RlZFxyXG4gICAgICovXHJcbiAgICBBenRlY1JlYWRlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGltYWdlLCBoaW50cykge1xyXG4gICAgICAgIGlmIChoaW50cyA9PT0gdm9pZCAwKSB7IGhpbnRzID0gbnVsbDsgfVxyXG4gICAgICAgIHZhciBleGNlcHRpb24gPSBudWxsO1xyXG4gICAgICAgIHZhciBkZXRlY3RvciA9IG5ldyBEZXRlY3Rvcl8xLmRlZmF1bHQoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSk7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IG51bGw7XHJcbiAgICAgICAgdmFyIGRlY29kZXJSZXN1bHQgPSBudWxsO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBkZXRlY3RvclJlc3VsdCA9IGRldGVjdG9yLmRldGVjdE1pcnJvcihmYWxzZSk7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IGRldGVjdG9yUmVzdWx0LmdldFBvaW50cygpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcG9ydEZvdW5kUmVzdWx0UG9pbnRzKGhpbnRzLCBwb2ludHMpO1xyXG4gICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gbmV3IERlY29kZXJfMS5kZWZhdWx0KCkuZGVjb2RlKGRldGVjdG9yUmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgZXhjZXB0aW9uID0gZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlY29kZXJSZXN1bHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRldGVjdG9yUmVzdWx0ID0gZGV0ZWN0b3IuZGV0ZWN0TWlycm9yKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzID0gZGV0ZWN0b3JSZXN1bHQuZ2V0UG9pbnRzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEZvdW5kUmVzdWx0UG9pbnRzKGhpbnRzLCBwb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgZGVjb2RlclJlc3VsdCA9IG5ldyBEZWNvZGVyXzEuZGVmYXVsdCgpLmRlY29kZShkZXRlY3RvclJlc3VsdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChleGNlcHRpb24gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV4Y2VwdGlvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBSZXN1bHRfMS5kZWZhdWx0KGRlY29kZXJSZXN1bHQuZ2V0VGV4dCgpLCBkZWNvZGVyUmVzdWx0LmdldFJhd0J5dGVzKCksIGRlY29kZXJSZXN1bHQuZ2V0TnVtQml0cygpLCBwb2ludHMsIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkFaVEVDLCBTeXN0ZW1fMS5kZWZhdWx0LmN1cnJlbnRUaW1lTWlsbGlzKCkpO1xyXG4gICAgICAgIHZhciBieXRlU2VnbWVudHMgPSBkZWNvZGVyUmVzdWx0LmdldEJ5dGVTZWdtZW50cygpO1xyXG4gICAgICAgIGlmIChieXRlU2VnbWVudHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5CWVRFX1NFR01FTlRTLCBieXRlU2VnbWVudHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZWNMZXZlbCA9IGRlY29kZXJSZXN1bHQuZ2V0RUNMZXZlbCgpO1xyXG4gICAgICAgIGlmIChlY0xldmVsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZWNMZXZlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgQXp0ZWNSZWFkZXIucHJvdG90eXBlLnJlcG9ydEZvdW5kUmVzdWx0UG9pbnRzID0gZnVuY3Rpb24gKGhpbnRzLCBwb2ludHMpIHtcclxuICAgICAgICBpZiAoaGludHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgcnBjYl8xID0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XHJcbiAgICAgICAgICAgIGlmIChycGNiXzEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLmZvckVhY2goZnVuY3Rpb24gKHBvaW50LCBpZHgsIGFycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJwY2JfMS5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQE92ZXJyaWRlXHJcbiAgICBBenRlY1JlYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBenRlY1JlYWRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQXp0ZWNSZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF6dGVjUmVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxMCBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIERlY29kZXJSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vRGVjb2RlclJlc3VsdFwiKTtcclxudmFyIEdlbmVyaWNHRl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9yZWVkc29sb21vbi9HZW5lcmljR0ZcIik7XHJcbnZhciBSZWVkU29sb21vbkRlY29kZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25EZWNvZGVyXCIpO1xyXG52YXIgSWxsZWdhbFN0YXRlRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vSWxsZWdhbFN0YXRlRXhjZXB0aW9uXCIpO1xyXG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xyXG52YXIgX18xID0gcmVxdWlyZShcIi4uLy4uLy4uXCIpO1xyXG52YXIgSW50ZWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvSW50ZWdlclwiKTtcclxuLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheXM7XHJcbnZhciBUYWJsZTtcclxuKGZ1bmN0aW9uIChUYWJsZSkge1xyXG4gICAgVGFibGVbVGFibGVbXCJVUFBFUlwiXSA9IDBdID0gXCJVUFBFUlwiO1xyXG4gICAgVGFibGVbVGFibGVbXCJMT1dFUlwiXSA9IDFdID0gXCJMT1dFUlwiO1xyXG4gICAgVGFibGVbVGFibGVbXCJNSVhFRFwiXSA9IDJdID0gXCJNSVhFRFwiO1xyXG4gICAgVGFibGVbVGFibGVbXCJESUdJVFwiXSA9IDNdID0gXCJESUdJVFwiO1xyXG4gICAgVGFibGVbVGFibGVbXCJQVU5DVFwiXSA9IDRdID0gXCJQVU5DVFwiO1xyXG4gICAgVGFibGVbVGFibGVbXCJCSU5BUllcIl0gPSA1XSA9IFwiQklOQVJZXCI7XHJcbn0pKFRhYmxlIHx8IChUYWJsZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiA8cD5UaGUgbWFpbiBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIEF6dGVjIENvZGUgZGVjb2RpbmcgLS0gYXMgb3Bwb3NlZCB0byBsb2NhdGluZyBhbmQgZXh0cmFjdGluZ1xyXG4gKiB0aGUgQXp0ZWMgQ29kZSBmcm9tIGFuIGltYWdlLjwvcD5cclxuICpcclxuICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXHJcbiAqL1xyXG52YXIgRGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlY29kZXIoKSB7XHJcbiAgICB9XHJcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoZGV0ZWN0b3JSZXN1bHQpIHtcclxuICAgICAgICB0aGlzLmRkYXRhID0gZGV0ZWN0b3JSZXN1bHQ7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IGRldGVjdG9yUmVzdWx0LmdldEJpdHMoKTtcclxuICAgICAgICB2YXIgcmF3Yml0cyA9IHRoaXMuZXh0cmFjdEJpdHMobWF0cml4KTtcclxuICAgICAgICB2YXIgY29ycmVjdGVkQml0cyA9IHRoaXMuY29ycmVjdEJpdHMocmF3Yml0cyk7XHJcbiAgICAgICAgdmFyIHJhd0J5dGVzID0gRGVjb2Rlci5jb252ZXJ0Qm9vbEFycmF5VG9CeXRlQXJyYXkoY29ycmVjdGVkQml0cyk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IERlY29kZXIuZ2V0RW5jb2RlZERhdGEoY29ycmVjdGVkQml0cyk7XHJcbiAgICAgICAgdmFyIGRlY29kZXJSZXN1bHQgPSBuZXcgRGVjb2RlclJlc3VsdF8xLmRlZmF1bHQocmF3Qnl0ZXMsIHJlc3VsdCwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgZGVjb2RlclJlc3VsdC5zZXROdW1CaXRzKGNvcnJlY3RlZEJpdHMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gZGVjb2RlclJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvLyBUaGlzIG1ldGhvZCBpcyB1c2VkIGZvciB0ZXN0aW5nIHRoZSBoaWdoLWxldmVsIGVuY29kZXJcclxuICAgIERlY29kZXIuaGlnaExldmVsRGVjb2RlID0gZnVuY3Rpb24gKGNvcnJlY3RlZEJpdHMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVkRGF0YShjb3JyZWN0ZWRCaXRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHN0cmluZyBlbmNvZGVkIGluIHRoZSBhenRlYyBjb2RlIGJpdHNcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHRoZSBkZWNvZGVkIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBEZWNvZGVyLmdldEVuY29kZWREYXRhID0gZnVuY3Rpb24gKGNvcnJlY3RlZEJpdHMpIHtcclxuICAgICAgICB2YXIgZW5kSW5kZXggPSBjb3JyZWN0ZWRCaXRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgbGF0Y2hUYWJsZSA9IFRhYmxlLlVQUEVSOyAvLyB0YWJsZSBtb3N0IHJlY2VudGx5IGxhdGNoZWQgdG9cclxuICAgICAgICB2YXIgc2hpZnRUYWJsZSA9IFRhYmxlLlVQUEVSOyAvLyB0YWJsZSB0byB1c2UgZm9yIHRoZSBuZXh0IHJlYWRcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoc2hpZnRUYWJsZSA9PT0gVGFibGUuQklOQVJZKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggLSBpbmRleCA8IDUpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IERlY29kZXIucmVhZENvZGUoY29ycmVjdGVkQml0cywgaW5kZXgsIDUpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gNTtcclxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhfMSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCAtIGluZGV4IDwgMTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aF8xID0gRGVjb2Rlci5yZWFkQ29kZShjb3JyZWN0ZWRCaXRzLCBpbmRleCwgMTEpICsgMzE7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gMTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaGFyQ291bnQgPSAwOyBjaGFyQ291bnQgPCBsZW5ndGhfMTsgY2hhckNvdW50KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggLSBpbmRleCA8IDgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBlbmRJbmRleDsgLy8gRm9yY2Ugb3V0ZXIgbG9vcCB0byBleGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IERlY29kZXIucmVhZENvZGUoY29ycmVjdGVkQml0cywgaW5kZXgsIDgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAvKihjaGFyKSovIF9fMS5TdHJpbmdVdGlscy5jYXN0QXNOb25VdGY4Q2hhcihjb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSA4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gR28gYmFjayB0byB3aGF0ZXZlciBtb2RlIHdlIGhhZCBiZWVuIGluXHJcbiAgICAgICAgICAgICAgICBzaGlmdFRhYmxlID0gbGF0Y2hUYWJsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gc2hpZnRUYWJsZSA9PT0gVGFibGUuRElHSVQgPyA0IDogNTtcclxuICAgICAgICAgICAgICAgIGlmIChlbmRJbmRleCAtIGluZGV4IDwgc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBEZWNvZGVyLnJlYWRDb2RlKGNvcnJlY3RlZEJpdHMsIGluZGV4LCBzaXplKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IHNpemU7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyID0gRGVjb2Rlci5nZXRDaGFyYWN0ZXIoc2hpZnRUYWJsZSwgY29kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyLnN0YXJ0c1dpdGgoJ0NUUkxfJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUYWJsZSBjaGFuZ2VzXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSVNPL0lFQyAyNDc3ODoyMDA4IHByZXNjcmliZXMgZW5kaW5nIGEgc2hpZnQgc2VxdWVuY2UgaW4gdGhlIG1vZGUgZnJvbSB3aGljaCBpdCB3YXMgaW52b2tlZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGF0J3MgaW5jbHVkaW5nIHdoZW4gdGhhdCBtb2RlIGlzIGEgc2hpZnQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT3VyIHRlc3QgY2FzZSBkbHVzYnMucG5nIGZvciBpc3N1ZSAjNjQyIGV4ZXJjaXNlcyB0aGF0LlxyXG4gICAgICAgICAgICAgICAgICAgIGxhdGNoVGFibGUgPSBzaGlmdFRhYmxlOyAvLyBMYXRjaCB0aGUgY3VycmVudCBtb2RlLCBzbyBhcyB0byByZXR1cm4gdG8gVXBwZXIgYWZ0ZXIgVS9TIEIvU1xyXG4gICAgICAgICAgICAgICAgICAgIHNoaWZ0VGFibGUgPSBEZWNvZGVyLmdldFRhYmxlKHN0ci5jaGFyQXQoNSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHIuY2hhckF0KDYpID09PSAnTCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF0Y2hUYWJsZSA9IHNoaWZ0VGFibGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cjtcclxuICAgICAgICAgICAgICAgICAgICAvLyBHbyBiYWNrIHRvIHdoYXRldmVyIG1vZGUgd2UgaGFkIGJlZW4gaW5cclxuICAgICAgICAgICAgICAgICAgICBzaGlmdFRhYmxlID0gbGF0Y2hUYWJsZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogZ2V0cyB0aGUgdGFibGUgY29ycmVzcG9uZGluZyB0byB0aGUgY2hhciBwYXNzZWRcclxuICAgICAqL1xyXG4gICAgRGVjb2Rlci5nZXRUYWJsZSA9IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgc3dpdGNoICh0KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ0wnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLkxPV0VSO1xyXG4gICAgICAgICAgICBjYXNlICdQJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZS5QVU5DVDtcclxuICAgICAgICAgICAgY2FzZSAnTSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gVGFibGUuTUlYRUQ7XHJcbiAgICAgICAgICAgIGNhc2UgJ0QnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLkRJR0lUO1xyXG4gICAgICAgICAgICBjYXNlICdCJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBUYWJsZS5CSU5BUlk7XHJcbiAgICAgICAgICAgIGNhc2UgJ1UnOlxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFRhYmxlLlVQUEVSO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNoYXJhY3RlciAob3Igc3RyaW5nKSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwYXNzZWQgY29kZSBpbiB0aGUgZ2l2ZW4gdGFibGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFibGUgdGhlIHRhYmxlIHVzZWRcclxuICAgICAqIEBwYXJhbSBjb2RlIHRoZSBjb2RlIG9mIHRoZSBjaGFyYWN0ZXJcclxuICAgICAqL1xyXG4gICAgRGVjb2Rlci5nZXRDaGFyYWN0ZXIgPSBmdW5jdGlvbiAodGFibGUsIGNvZGUpIHtcclxuICAgICAgICBzd2l0Y2ggKHRhYmxlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVGFibGUuVVBQRVI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5VUFBFUl9UQUJMRVtjb2RlXTtcclxuICAgICAgICAgICAgY2FzZSBUYWJsZS5MT1dFUjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvZGVyLkxPV0VSX1RBQkxFW2NvZGVdO1xyXG4gICAgICAgICAgICBjYXNlIFRhYmxlLk1JWEVEOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29kZXIuTUlYRURfVEFCTEVbY29kZV07XHJcbiAgICAgICAgICAgIGNhc2UgVGFibGUuUFVOQ1Q6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRGVjb2Rlci5QVU5DVF9UQUJMRVtjb2RlXTtcclxuICAgICAgICAgICAgY2FzZSBUYWJsZS5ESUdJVDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvZGVyLkRJR0lUX1RBQkxFW2NvZGVdO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCByZWFjaCBoZXJlLlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0JhZCB0YWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPlBlcmZvcm1zIFJTIGVycm9yIGNvcnJlY3Rpb24gb24gYW4gYXJyYXkgb2YgYml0cy48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB0aGUgY29ycmVjdGVkIGFycmF5XHJcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiB0aGUgaW5wdXQgY29udGFpbnMgdG9vIG1hbnkgZXJyb3JzXHJcbiAgICAgKi9cclxuICAgIERlY29kZXIucHJvdG90eXBlLmNvcnJlY3RCaXRzID0gZnVuY3Rpb24gKHJhd2JpdHMpIHtcclxuICAgICAgICB2YXIgZ2Y7XHJcbiAgICAgICAgdmFyIGNvZGV3b3JkU2l6ZTtcclxuICAgICAgICBpZiAodGhpcy5kZGF0YS5nZXROYkxheWVycygpIDw9IDIpIHtcclxuICAgICAgICAgICAgY29kZXdvcmRTaXplID0gNjtcclxuICAgICAgICAgICAgZ2YgPSBHZW5lcmljR0ZfMS5kZWZhdWx0LkFaVEVDX0RBVEFfNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZGF0YS5nZXROYkxheWVycygpIDw9IDgpIHtcclxuICAgICAgICAgICAgY29kZXdvcmRTaXplID0gODtcclxuICAgICAgICAgICAgZ2YgPSBHZW5lcmljR0ZfMS5kZWZhdWx0LkFaVEVDX0RBVEFfODtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kZGF0YS5nZXROYkxheWVycygpIDw9IDIyKSB7XHJcbiAgICAgICAgICAgIGNvZGV3b3JkU2l6ZSA9IDEwO1xyXG4gICAgICAgICAgICBnZiA9IEdlbmVyaWNHRl8xLmRlZmF1bHQuQVpURUNfREFUQV8xMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvZGV3b3JkU2l6ZSA9IDEyO1xyXG4gICAgICAgICAgICBnZiA9IEdlbmVyaWNHRl8xLmRlZmF1bHQuQVpURUNfREFUQV8xMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG51bURhdGFDb2Rld29yZHMgPSB0aGlzLmRkYXRhLmdldE5iRGF0YWJsb2NrcygpO1xyXG4gICAgICAgIHZhciBudW1Db2Rld29yZHMgPSByYXdiaXRzLmxlbmd0aCAvIGNvZGV3b3JkU2l6ZTtcclxuICAgICAgICBpZiAobnVtQ29kZXdvcmRzIDwgbnVtRGF0YUNvZGV3b3Jkcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gcmF3Yml0cy5sZW5ndGggJSBjb2Rld29yZFNpemU7XHJcbiAgICAgICAgdmFyIGRhdGFXb3JkcyA9IG5ldyBJbnQzMkFycmF5KG51bUNvZGV3b3Jkcyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Db2Rld29yZHM7IGkrKywgb2Zmc2V0ICs9IGNvZGV3b3JkU2l6ZSkge1xyXG4gICAgICAgICAgICBkYXRhV29yZHNbaV0gPSBEZWNvZGVyLnJlYWRDb2RlKHJhd2JpdHMsIG9mZnNldCwgY29kZXdvcmRTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIHJzRGVjb2RlciA9IG5ldyBSZWVkU29sb21vbkRlY29kZXJfMS5kZWZhdWx0KGdmKTtcclxuICAgICAgICAgICAgcnNEZWNvZGVyLmRlY29kZShkYXRhV29yZHMsIG51bUNvZGV3b3JkcyAtIG51bURhdGFDb2Rld29yZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3cgcGVyZm9ybSB0aGUgdW5zdHVmZmluZyBvcGVyYXRpb24uXHJcbiAgICAgICAgLy8gRmlyc3QsIGNvdW50IGhvdyBtYW55IGJpdHMgYXJlIGdvaW5nIHRvIGJlIHRocm93biBvdXQgYXMgc3R1ZmZpbmdcclxuICAgICAgICB2YXIgbWFzayA9ICgxIDw8IGNvZGV3b3JkU2l6ZSkgLSAxO1xyXG4gICAgICAgIHZhciBzdHVmZmVkQml0cyA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFXb3JkID0gZGF0YVdvcmRzW2ldO1xyXG4gICAgICAgICAgICBpZiAoZGF0YVdvcmQgPT09IDAgfHwgZGF0YVdvcmQgPT09IG1hc2spIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVdvcmQgPT09IDEgfHwgZGF0YVdvcmQgPT09IG1hc2sgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzdHVmZmVkQml0cysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdywgYWN0dWFsbHkgdW5wYWNrIHRoZSBiaXRzIGFuZCByZW1vdmUgdGhlIHN0dWZmaW5nXHJcbiAgICAgICAgdmFyIGNvcnJlY3RlZEJpdHMgPSBuZXcgQXJyYXkobnVtRGF0YUNvZGV3b3JkcyAqIGNvZGV3b3JkU2l6ZSAtIHN0dWZmZWRCaXRzKTtcclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhV29yZCA9IGRhdGFXb3Jkc1tpXTtcclxuICAgICAgICAgICAgaWYgKGRhdGFXb3JkID09PSAxIHx8IGRhdGFXb3JkID09PSBtYXNrIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gbmV4dCBjb2Rld29yZFNpemUtMSBiaXRzIGFyZSBhbGwgemVyb3Mgb3IgYWxsIG9uZXNcclxuICAgICAgICAgICAgICAgIGNvcnJlY3RlZEJpdHMuZmlsbChkYXRhV29yZCA+IDEsIGluZGV4LCBpbmRleCArIGNvZGV3b3JkU2l6ZSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8gQXJyYXlzLmZpbGwoY29ycmVjdGVkQml0cywgaW5kZXgsIGluZGV4ICsgY29kZXdvcmRTaXplIC0gMSwgZGF0YVdvcmQgPiAxKTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IGNvZGV3b3JkU2l6ZSAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBiaXQgPSBjb2Rld29yZFNpemUgLSAxOyBiaXQgPj0gMDsgLS1iaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3JyZWN0ZWRCaXRzW2luZGV4KytdID0gKGRhdGFXb3JkICYgKDEgPDwgYml0KSkgIT09IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvcnJlY3RlZEJpdHM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBhcnJheSBvZiBiaXRzIGZyb20gYW4gQXp0ZWMgQ29kZSBtYXRyaXhcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHRoZSBhcnJheSBvZiBiaXRzXHJcbiAgICAgKi9cclxuICAgIERlY29kZXIucHJvdG90eXBlLmV4dHJhY3RCaXRzID0gZnVuY3Rpb24gKG1hdHJpeCkge1xyXG4gICAgICAgIHZhciBjb21wYWN0ID0gdGhpcy5kZGF0YS5pc0NvbXBhY3QoKTtcclxuICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5kZGF0YS5nZXROYkxheWVycygpO1xyXG4gICAgICAgIHZhciBiYXNlTWF0cml4U2l6ZSA9IChjb21wYWN0ID8gMTEgOiAxNCkgKyBsYXllcnMgKiA0OyAvLyBub3QgaW5jbHVkaW5nIGFsaWdubWVudCBsaW5lc1xyXG4gICAgICAgIHZhciBhbGlnbm1lbnRNYXAgPSBuZXcgSW50MzJBcnJheShiYXNlTWF0cml4U2l6ZSk7XHJcbiAgICAgICAgdmFyIHJhd2JpdHMgPSBuZXcgQXJyYXkodGhpcy50b3RhbEJpdHNJbkxheWVyKGxheWVycywgY29tcGFjdCkpO1xyXG4gICAgICAgIGlmIChjb21wYWN0KSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxpZ25tZW50TWFwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnRNYXBbaV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbWF0cml4U2l6ZSA9IGJhc2VNYXRyaXhTaXplICsgMSArIDIgKiBJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKChJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKGJhc2VNYXRyaXhTaXplLCAyKSAtIDEpLCAxNSk7XHJcbiAgICAgICAgICAgIHZhciBvcmlnQ2VudGVyID0gYmFzZU1hdHJpeFNpemUgLyAyO1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gSW50ZWdlcl8xLmRlZmF1bHQudHJ1bmNEaXZpc2lvbihtYXRyaXhTaXplLCAyKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmlnQ2VudGVyOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXdPZmZzZXQgPSBpICsgSW50ZWdlcl8xLmRlZmF1bHQudHJ1bmNEaXZpc2lvbihpLCAxNSk7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnRNYXBbb3JpZ0NlbnRlciAtIGkgLSAxXSA9IGNlbnRlciAtIG5ld09mZnNldCAtIDE7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnRNYXBbb3JpZ0NlbnRlciArIGldID0gY2VudGVyICsgbmV3T2Zmc2V0ICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcm93T2Zmc2V0ID0gMDsgaSA8IGxheWVyczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByb3dTaXplID0gKGxheWVycyAtIGkpICogNCArIChjb21wYWN0ID8gOSA6IDEyKTtcclxuICAgICAgICAgICAgLy8gVGhlIHRvcC1sZWZ0IG1vc3QgcG9pbnQgb2YgdGhpcyBsYXllciBpcyA8bG93LCBsb3c+IChub3QgaW5jbHVkaW5nIGFsaWdubWVudCBsaW5lcylcclxuICAgICAgICAgICAgdmFyIGxvdyA9IGkgKiAyO1xyXG4gICAgICAgICAgICAvLyBUaGUgYm90dG9tLXJpZ2h0IG1vc3QgcG9pbnQgb2YgdGhpcyBsYXllciBpcyA8aGlnaCwgaGlnaD4gKG5vdCBpbmNsdWRpbmcgYWxpZ25tZW50IGxpbmVzKVxyXG4gICAgICAgICAgICB2YXIgaGlnaCA9IGJhc2VNYXRyaXhTaXplIC0gMSAtIGxvdztcclxuICAgICAgICAgICAgLy8gV2UgcHVsbCBiaXRzIGZyb20gdGhlIHR3byAyIHggcm93U2l6ZSBjb2x1bW5zIGFuZCB0d28gcm93U2l6ZSB4IDIgcm93c1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvd1NpemU7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbk9mZnNldCA9IGogKiAyO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAyOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBsZWZ0IGNvbHVtblxyXG4gICAgICAgICAgICAgICAgICAgIHJhd2JpdHNbcm93T2Zmc2V0ICsgY29sdW1uT2Zmc2V0ICsga10gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXguZ2V0KGFsaWdubWVudE1hcFtsb3cgKyBrXSwgYWxpZ25tZW50TWFwW2xvdyArIGpdKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBib3R0b20gcm93XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3Yml0c1tyb3dPZmZzZXQgKyAyICogcm93U2l6ZSArIGNvbHVtbk9mZnNldCArIGtdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4LmdldChhbGlnbm1lbnRNYXBbbG93ICsgal0sIGFsaWdubWVudE1hcFtoaWdoIC0ga10pO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGNvbHVtblxyXG4gICAgICAgICAgICAgICAgICAgIHJhd2JpdHNbcm93T2Zmc2V0ICsgNCAqIHJvd1NpemUgKyBjb2x1bW5PZmZzZXQgKyBrXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXQoYWxpZ25tZW50TWFwW2hpZ2ggLSBrXSwgYWxpZ25tZW50TWFwW2hpZ2ggLSBqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9wIHJvd1xyXG4gICAgICAgICAgICAgICAgICAgIHJhd2JpdHNbcm93T2Zmc2V0ICsgNiAqIHJvd1NpemUgKyBjb2x1bW5PZmZzZXQgKyBrXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeC5nZXQoYWxpZ25tZW50TWFwW2hpZ2ggLSBqXSwgYWxpZ25tZW50TWFwW2xvdyArIGtdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByb3dPZmZzZXQgKz0gcm93U2l6ZSAqIDg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByYXdiaXRzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYSBjb2RlIG9mIGdpdmVuIGxlbmd0aCBhbmQgYXQgZ2l2ZW4gaW5kZXggaW4gYW4gYXJyYXkgb2YgYml0c1xyXG4gICAgICovXHJcbiAgICBEZWNvZGVyLnJlYWRDb2RlID0gZnVuY3Rpb24gKHJhd2JpdHMsIHN0YXJ0SW5kZXgsIGxlbmd0aCkge1xyXG4gICAgICAgIHZhciByZXMgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgc3RhcnRJbmRleCArIGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlcyA8PD0gMTtcclxuICAgICAgICAgICAgaWYgKHJhd2JpdHNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJlcyB8PSAweDAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhIGNvZGUgb2YgbGVuZ3RoIDggaW4gYW4gYXJyYXkgb2YgYml0cywgcGFkZGluZyB3aXRoIHplcm9zXHJcbiAgICAgKi9cclxuICAgIERlY29kZXIucmVhZEJ5dGUgPSBmdW5jdGlvbiAocmF3Yml0cywgc3RhcnRJbmRleCkge1xyXG4gICAgICAgIHZhciBuID0gcmF3Yml0cy5sZW5ndGggLSBzdGFydEluZGV4O1xyXG4gICAgICAgIGlmIChuID49IDgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIERlY29kZXIucmVhZENvZGUocmF3Yml0cywgc3RhcnRJbmRleCwgOCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBEZWNvZGVyLnJlYWRDb2RlKHJhd2JpdHMsIHN0YXJ0SW5kZXgsIG4pIDw8ICg4IC0gbik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYWNrcyBhIGJpdCBhcnJheSBpbnRvIGJ5dGVzLCBtb3N0IHNpZ25pZmljYW50IGJpdCBmaXJzdFxyXG4gICAgICovXHJcbiAgICBEZWNvZGVyLmNvbnZlcnRCb29sQXJyYXlUb0J5dGVBcnJheSA9IGZ1bmN0aW9uIChib29sQXJyKSB7XHJcbiAgICAgICAgdmFyIGJ5dGVBcnIgPSBuZXcgVWludDhBcnJheSgoYm9vbEFyci5sZW5ndGggKyA3KSAvIDgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZUFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBieXRlQXJyW2ldID0gRGVjb2Rlci5yZWFkQnl0ZShib29sQXJyLCA4ICogaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBieXRlQXJyO1xyXG4gICAgfTtcclxuICAgIERlY29kZXIucHJvdG90eXBlLnRvdGFsQml0c0luTGF5ZXIgPSBmdW5jdGlvbiAobGF5ZXJzLCBjb21wYWN0KSB7XHJcbiAgICAgICAgcmV0dXJuICgoY29tcGFjdCA/IDg4IDogMTEyKSArIDE2ICogbGF5ZXJzKSAqIGxheWVycztcclxuICAgIH07XHJcbiAgICBEZWNvZGVyLlVQUEVSX1RBQkxFID0gW1xyXG4gICAgICAgICdDVFJMX1BTJywgJyAnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLCAnUCcsXHJcbiAgICAgICAgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnQ1RSTF9MTCcsICdDVFJMX01MJywgJ0NUUkxfREwnLCAnQ1RSTF9CUydcclxuICAgIF07XHJcbiAgICBEZWNvZGVyLkxPV0VSX1RBQkxFID0gW1xyXG4gICAgICAgICdDVFJMX1BTJywgJyAnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsXHJcbiAgICAgICAgJ3EnLCAncicsICdzJywgJ3QnLCAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnQ1RSTF9VUycsICdDVFJMX01MJywgJ0NUUkxfREwnLCAnQ1RSTF9CUydcclxuICAgIF07XHJcbiAgICBEZWNvZGVyLk1JWEVEX1RBQkxFID0gW1xyXG4gICAgICAgIC8vIE1vZHVsZSBwYXJzZSBmYWlsZWQ6IE9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGUgKDUwOjI5KVxyXG4gICAgICAgIC8vIHNvIG51bWJlciBzdHJpbmcgd2VyZSBzY2FwZWRcclxuICAgICAgICAnQ1RSTF9QUycsICcgJywgJ1xcXFwxJywgJ1xcXFwyJywgJ1xcXFwzJywgJ1xcXFw0JywgJ1xcXFw1JywgJ1xcXFw2JywgJ1xcXFw3JywgJ1xcYicsICdcXHQnLCAnXFxuJyxcclxuICAgICAgICAnXFxcXDEzJywgJ1xcZicsICdcXHInLCAnXFxcXDMzJywgJ1xcXFwzNCcsICdcXFxcMzUnLCAnXFxcXDM2JywgJ1xcXFwzNycsICdAJywgJ1xcXFwnLCAnXicsICdfJyxcclxuICAgICAgICAnYCcsICd8JywgJ34nLCAnXFxcXDE3NycsICdDVFJMX0xMJywgJ0NUUkxfVUwnLCAnQ1RSTF9QTCcsICdDVFJMX0JTJ1xyXG4gICAgXTtcclxuICAgIERlY29kZXIuUFVOQ1RfVEFCTEUgPSBbXHJcbiAgICAgICAgJycsICdcXHInLCAnXFxyXFxuJywgJy4gJywgJywgJywgJzogJywgJyEnLCAnXCInLCAnIycsICckJywgJyUnLCAnJicsICdcXCcnLCAnKCcsICcpJyxcclxuICAgICAgICAnKicsICcrJywgJywnLCAnLScsICcuJywgJy8nLCAnOicsICc7JywgJzwnLCAnPScsICc+JywgJz8nLCAnWycsICddJywgJ3snLCAnfScsICdDVFJMX1VMJ1xyXG4gICAgXTtcclxuICAgIERlY29kZXIuRElHSVRfVEFCTEUgPSBbXHJcbiAgICAgICAgJ0NUUkxfUFMnLCAnICcsICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JywgJywnLCAnLicsICdDVFJMX1VMJywgJ0NUUkxfVVMnXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIERlY29kZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERlY29kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlY29kZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDEwIFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgUmVzdWx0UG9pbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9SZXN1bHRQb2ludFwiKTtcclxudmFyIEF6dGVjRGV0ZWN0b3JSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9BenRlY0RldGVjdG9yUmVzdWx0XCIpO1xyXG52YXIgTWF0aFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL2RldGVjdG9yL01hdGhVdGlsc1wiKTtcclxudmFyIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vZGV0ZWN0b3IvV2hpdGVSZWN0YW5nbGVEZXRlY3RvclwiKTtcclxudmFyIEdlbmVyaWNHRl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9yZWVkc29sb21vbi9HZW5lcmljR0ZcIik7XHJcbnZhciBSZWVkU29sb21vbkRlY29kZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25EZWNvZGVyXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxudmFyIEdyaWRTYW1wbGVySW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vR3JpZFNhbXBsZXJJbnN0YW5jZVwiKTtcclxudmFyIEludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0ludGVnZXJcIik7XHJcbnZhciBQb2ludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBvaW50KHgsIHkpIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICB9XHJcbiAgICBQb2ludC5wcm90b3R5cGUudG9SZXN1bHRQb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdCh0aGlzLmdldFgoKSwgdGhpcy5nZXRZKCkpO1xyXG4gICAgfTtcclxuICAgIFBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLng7XHJcbiAgICB9O1xyXG4gICAgUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUG9pbnQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcclxuLyoqXHJcbiAqIEVuY2Fwc3VsYXRlcyBsb2dpYyB0aGF0IGNhbiBkZXRlY3QgYW4gQXp0ZWMgQ29kZSBpbiBhbiBpbWFnZSwgZXZlbiBpZiB0aGUgQXp0ZWMgQ29kZVxyXG4gKiBpcyByb3RhdGVkIG9yIHNrZXdlZCwgb3IgcGFydGlhbGx5IG9ic2N1cmVkLlxyXG4gKlxyXG4gKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcclxuICogQGF1dGhvciBGcmFuayBZZWxsaW5cclxuICovXHJcbnZhciBEZXRlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERldGVjdG9yKGltYWdlKSB7XHJcbiAgICAgICAgdGhpcy5FWFBFQ1RFRF9DT1JORVJfQklUUyA9IG5ldyBJbnQzMkFycmF5KFtcclxuICAgICAgICAgICAgMHhlZTAsXHJcbiAgICAgICAgICAgIDB4MWRjLFxyXG4gICAgICAgICAgICAweDgzYixcclxuICAgICAgICAgICAgMHg3MDcsXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xyXG4gICAgfVxyXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmRldGVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZXRlY3RNaXJyb3IoZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZWN0cyBhbiBBenRlYyBDb2RlIGluIGFuIGltYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpc01pcnJvciBpZiB0cnVlLCBpbWFnZSBpcyBhIG1pcnJvci1pbWFnZSBvZiBvcmlnaW5hbFxyXG4gICAgICogQHJldHVybiB7QGxpbmsgQXp0ZWNEZXRlY3RvclJlc3VsdH0gZW5jYXBzdWxhdGluZyByZXN1bHRzIG9mIGRldGVjdGluZyBhbiBBenRlYyBDb2RlXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vIEF6dGVjIENvZGUgY2FuIGJlIGZvdW5kXHJcbiAgICAgKi9cclxuICAgIERldGVjdG9yLnByb3RvdHlwZS5kZXRlY3RNaXJyb3IgPSBmdW5jdGlvbiAoaXNNaXJyb3IpIHtcclxuICAgICAgICAvLyAxLiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgYXp0ZWMgbWF0cml4XHJcbiAgICAgICAgdmFyIHBDZW50ZXIgPSB0aGlzLmdldE1hdHJpeENlbnRlcigpO1xyXG4gICAgICAgIC8vIDIuIEdldCB0aGUgY2VudGVyIHBvaW50cyBvZiB0aGUgZm91ciBkaWFnb25hbCBwb2ludHMganVzdCBvdXRzaWRlIHRoZSBidWxsJ3MgZXllXHJcbiAgICAgICAgLy8gIFt0b3BSaWdodCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnQsIHRvcExlZnRdXHJcbiAgICAgICAgdmFyIGJ1bGxzRXllQ29ybmVycyA9IHRoaXMuZ2V0QnVsbHNFeWVDb3JuZXJzKHBDZW50ZXIpO1xyXG4gICAgICAgIGlmIChpc01pcnJvcikge1xyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGJ1bGxzRXllQ29ybmVyc1swXTtcclxuICAgICAgICAgICAgYnVsbHNFeWVDb3JuZXJzWzBdID0gYnVsbHNFeWVDb3JuZXJzWzJdO1xyXG4gICAgICAgICAgICBidWxsc0V5ZUNvcm5lcnNbMl0gPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAzLiBHZXQgdGhlIHNpemUgb2YgdGhlIG1hdHJpeCBhbmQgb3RoZXIgcGFyYW1ldGVycyBmcm9tIHRoZSBidWxsJ3MgZXllXHJcbiAgICAgICAgdGhpcy5leHRyYWN0UGFyYW1ldGVycyhidWxsc0V5ZUNvcm5lcnMpO1xyXG4gICAgICAgIC8vIDQuIFNhbXBsZSB0aGUgZ3JpZFxyXG4gICAgICAgIHZhciBiaXRzID0gdGhpcy5zYW1wbGVHcmlkKHRoaXMuaW1hZ2UsIGJ1bGxzRXllQ29ybmVyc1t0aGlzLnNoaWZ0ICUgNF0sIGJ1bGxzRXllQ29ybmVyc1sodGhpcy5zaGlmdCArIDEpICUgNF0sIGJ1bGxzRXllQ29ybmVyc1sodGhpcy5zaGlmdCArIDIpICUgNF0sIGJ1bGxzRXllQ29ybmVyc1sodGhpcy5zaGlmdCArIDMpICUgNF0pO1xyXG4gICAgICAgIC8vIDUuIEdldCB0aGUgY29ybmVycyBvZiB0aGUgbWF0cml4LlxyXG4gICAgICAgIHZhciBjb3JuZXJzID0gdGhpcy5nZXRNYXRyaXhDb3JuZXJQb2ludHMoYnVsbHNFeWVDb3JuZXJzKTtcclxuICAgICAgICByZXR1cm4gbmV3IEF6dGVjRGV0ZWN0b3JSZXN1bHRfMS5kZWZhdWx0KGJpdHMsIGNvcm5lcnMsIHRoaXMuY29tcGFjdCwgdGhpcy5uYkRhdGFCbG9ja3MsIHRoaXMubmJMYXllcnMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdHMgdGhlIG51bWJlciBvZiBkYXRhIGxheWVycyBhbmQgZGF0YSBibG9ja3MgZnJvbSB0aGUgbGF5ZXIgYXJvdW5kIHRoZSBidWxsJ3MgZXllLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBidWxsc0V5ZUNvcm5lcnMgdGhlIGFycmF5IG9mIGJ1bGwncyBleWUgY29ybmVyc1xyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpbiBjYXNlIG9mIHRvbyBtYW55IGVycm9ycyBvciBpbnZhbGlkIHBhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmV4dHJhY3RQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKGJ1bGxzRXllQ29ybmVycykge1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkUG9pbnQoYnVsbHNFeWVDb3JuZXJzWzBdKSB8fCAhdGhpcy5pc1ZhbGlkUG9pbnQoYnVsbHNFeWVDb3JuZXJzWzFdKSB8fFxyXG4gICAgICAgICAgICAhdGhpcy5pc1ZhbGlkUG9pbnQoYnVsbHNFeWVDb3JuZXJzWzJdKSB8fCAhdGhpcy5pc1ZhbGlkUG9pbnQoYnVsbHNFeWVDb3JuZXJzWzNdKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsZW5ndGggPSAyICogdGhpcy5uYkNlbnRlckxheWVycztcclxuICAgICAgICAvLyBHZXQgdGhlIGJpdHMgYXJvdW5kIHRoZSBidWxsJ3MgZXllXHJcbiAgICAgICAgdmFyIHNpZGVzID0gbmV3IEludDMyQXJyYXkoW1xyXG4gICAgICAgICAgICB0aGlzLnNhbXBsZUxpbmUoYnVsbHNFeWVDb3JuZXJzWzBdLCBidWxsc0V5ZUNvcm5lcnNbMV0sIGxlbmd0aCksXHJcbiAgICAgICAgICAgIHRoaXMuc2FtcGxlTGluZShidWxsc0V5ZUNvcm5lcnNbMV0sIGJ1bGxzRXllQ29ybmVyc1syXSwgbGVuZ3RoKSxcclxuICAgICAgICAgICAgdGhpcy5zYW1wbGVMaW5lKGJ1bGxzRXllQ29ybmVyc1syXSwgYnVsbHNFeWVDb3JuZXJzWzNdLCBsZW5ndGgpLFxyXG4gICAgICAgICAgICB0aGlzLnNhbXBsZUxpbmUoYnVsbHNFeWVDb3JuZXJzWzNdLCBidWxsc0V5ZUNvcm5lcnNbMF0sIGxlbmd0aCkgLy8gVG9wXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgLy8gYnVsbHNFeWVDb3JuZXJzW3NoaWZ0XSBpcyB0aGUgY29ybmVyIG9mIHRoZSBidWxscydleWUgdGhhdCBoYXMgdGhyZWVcclxuICAgICAgICAvLyBvcmllbnRhdGlvbiBtYXJrcy5cclxuICAgICAgICAvLyBzaWRlc1tzaGlmdF0gaXMgdGhlIHJvdy9jb2x1bW4gdGhhdCBnb2VzIGZyb20gdGhlIGNvcm5lciB3aXRoIHRocmVlXHJcbiAgICAgICAgLy8gb3JpZW50YXRpb24gbWFya3MgdG8gdGhlIGNvcm5lciB3aXRoIHR3by5cclxuICAgICAgICB0aGlzLnNoaWZ0ID0gdGhpcy5nZXRSb3RhdGlvbihzaWRlcywgbGVuZ3RoKTtcclxuICAgICAgICAvLyBGbGF0dGVuIHRoZSBwYXJhbWV0ZXIgYml0cyBpbnRvIGEgc2luZ2xlIDI4LSBvciA0MC1iaXQgbG9uZ1xyXG4gICAgICAgIHZhciBwYXJhbWV0ZXJEYXRhID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2lkZSA9IHNpZGVzWyh0aGlzLnNoaWZ0ICsgaSkgJSA0XTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFjdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRWFjaCBzaWRlIG9mIHRoZSBmb3JtIC4uWFhYWFhYWC4gd2hlcmUgWHMgYXJlIHBhcmFtZXRlciBkYXRhXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJEYXRhIDw8PSA3O1xyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyRGF0YSArPSAoc2lkZSA+PiAxKSAmIDB4N0Y7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFYWNoIHNpZGUgb2YgdGhlIGZvcm0gLi5YWFhYWC5YWFhYWC4gd2hlcmUgWHMgYXJlIHBhcmFtZXRlciBkYXRhXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJEYXRhIDw8PSAxMDtcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlckRhdGEgKz0gKChzaWRlID4+IDIpICYgKDB4MWYgPDwgNSkpICsgKChzaWRlID4+IDEpICYgMHgxRik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29ycmVjdHMgcGFyYW1ldGVyIGRhdGEgdXNpbmcgUlMuICBSZXR1cm5zIGp1c3QgdGhlIGRhdGEgcG9ydGlvblxyXG4gICAgICAgIC8vIHdpdGhvdXQgdGhlIGVycm9yIGNvcnJlY3Rpb24uXHJcbiAgICAgICAgdmFyIGNvcnJlY3RlZERhdGEgPSB0aGlzLmdldENvcnJlY3RlZFBhcmFtZXRlckRhdGEocGFyYW1ldGVyRGF0YSwgdGhpcy5jb21wYWN0KTtcclxuICAgICAgICBpZiAodGhpcy5jb21wYWN0KSB7XHJcbiAgICAgICAgICAgIC8vIDggYml0czogIDIgYml0cyBsYXllcnMgYW5kIDYgYml0cyBkYXRhIGJsb2Nrc1xyXG4gICAgICAgICAgICB0aGlzLm5iTGF5ZXJzID0gKGNvcnJlY3RlZERhdGEgPj4gNikgKyAxO1xyXG4gICAgICAgICAgICB0aGlzLm5iRGF0YUJsb2NrcyA9IChjb3JyZWN0ZWREYXRhICYgMHgzRikgKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gMTYgYml0czogIDUgYml0cyBsYXllcnMgYW5kIDExIGJpdHMgZGF0YSBibG9ja3NcclxuICAgICAgICAgICAgdGhpcy5uYkxheWVycyA9IChjb3JyZWN0ZWREYXRhID4+IDExKSArIDE7XHJcbiAgICAgICAgICAgIHRoaXMubmJEYXRhQmxvY2tzID0gKGNvcnJlY3RlZERhdGEgJiAweDdGRikgKyAxO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiAoc2lkZXMsIGxlbmd0aCkge1xyXG4gICAgICAgIC8vIEluIGEgbm9ybWFsIHBhdHRlcm4sIHdlIGV4cGVjdCB0byBTZWVcclxuICAgICAgICAvLyAgICoqICAgIC4qICAgICAgICAgICAgIEQgICAgICAgQVxyXG4gICAgICAgIC8vICAgKiAgICAgICpcclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vICAgLiAgICAgICpcclxuICAgICAgICAvLyAgIC4uICAgIC4uICAgICAgICAgICAgIEMgICAgICAgQlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gR3JhYiB0aGUgMyBiaXRzIGZyb20gZWFjaCBvZiB0aGUgc2lkZXMgdGhlIGZvcm0gdGhlIGxvY2F0b3IgcGF0dGVybiBhbmQgY29uY2F0ZW5hdGVcclxuICAgICAgICAvLyBpbnRvIGEgMTItYml0IGludGVnZXIuICBTdGFydCB3aXRoIHRoZSBiaXQgYXQgQVxyXG4gICAgICAgIHZhciBjb3JuZXJCaXRzID0gMDtcclxuICAgICAgICBzaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlLCBpZHgsIGFycikge1xyXG4gICAgICAgICAgICAvLyBYWC4uLi4uLlggd2hlcmUgWCdzIGFyZSBvcmllbnRhdGlvbiBtYXJrc1xyXG4gICAgICAgICAgICB2YXIgdCA9ICgoc2lkZSA+PiAobGVuZ3RoIC0gMikpIDw8IDEpICsgKHNpZGUgJiAxKTtcclxuICAgICAgICAgICAgY29ybmVyQml0cyA9IChjb3JuZXJCaXRzIDw8IDMpICsgdDtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBmb3IgKHZhciBzaWRlIGluIHNpZGVzKSB7XHJcbiAgICAgICAgLy8gICAgIC8vIFhYLi4uLi4uWCB3aGVyZSBYJ3MgYXJlIG9yaWVudGF0aW9uIG1hcmtzXHJcbiAgICAgICAgLy8gICAgIHZhciB0ID0gKChzaWRlID4+IChsZW5ndGggLSAyKSkgPDwgMSkgKyAoc2lkZSAmIDEpO1xyXG4gICAgICAgIC8vICAgICBjb3JuZXJCaXRzID0gKGNvcm5lckJpdHMgPDwgMykgKyB0O1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBNb3YgdGhlIGJvdHRvbSBiaXQgdG8gdGhlIHRvcCwgc28gdGhhdCB0aGUgdGhyZWUgYml0cyBvZiB0aGUgbG9jYXRvciBwYXR0ZXJuIGF0IEEgYXJlXHJcbiAgICAgICAgLy8gdG9nZXRoZXIuICBjb3JuZXJCaXRzIGlzIG5vdzpcclxuICAgICAgICAvLyAgMyBvcmllbnRhdGlvbiBiaXRzIGF0IEEgfHwgMyBvcmllbnRhdGlvbiBiaXRzIGF0IEIgfHwgLi4uIHx8IDMgb3JpZW50YXRpb24gYml0cyBhdCBEXHJcbiAgICAgICAgY29ybmVyQml0cyA9ICgoY29ybmVyQml0cyAmIDEpIDw8IDExKSArIChjb3JuZXJCaXRzID4+IDEpO1xyXG4gICAgICAgIC8vIFRoZSByZXN1bHQgc2hpZnQgaW5kaWNhdGVzIHdoaWNoIGVsZW1lbnQgb2YgQnVsbHNFeWVDb3JuZXJzW10gZ29lcyBpbnRvIHRoZSB0b3AtbGVmdFxyXG4gICAgICAgIC8vIGNvcm5lci4gU2luY2UgdGhlIGZvdXIgcm90YXRpb24gdmFsdWVzIGhhdmUgYSBIYW1taW5nIGRpc3RhbmNlIG9mIDgsIHdlXHJcbiAgICAgICAgLy8gY2FuIGVhc2lseSB0b2xlcmF0ZSB0d28gZXJyb3JzLlxyXG4gICAgICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgc2hpZnQgPCA0OyBzaGlmdCsrKSB7XHJcbiAgICAgICAgICAgIGlmIChJbnRlZ2VyXzEuZGVmYXVsdC5iaXRDb3VudChjb3JuZXJCaXRzIF4gdGhpcy5FWFBFQ1RFRF9DT1JORVJfQklUU1tzaGlmdF0pIDw9IDIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaGlmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb3JyZWN0cyB0aGUgcGFyYW1ldGVyIGJpdHMgdXNpbmcgUmVlZC1Tb2xvbW9uIGFsZ29yaXRobS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVyRGF0YSBwYXJhbWV0ZXIgYml0c1xyXG4gICAgICogQHBhcmFtIGNvbXBhY3QgdHJ1ZSBpZiB0aGlzIGlzIGEgY29tcGFjdCBBenRlYyBjb2RlXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIHRoZSBhcnJheSBjb250YWlucyB0b28gbWFueSBlcnJvcnNcclxuICAgICAqL1xyXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmdldENvcnJlY3RlZFBhcmFtZXRlckRhdGEgPSBmdW5jdGlvbiAocGFyYW1ldGVyRGF0YSwgY29tcGFjdCkge1xyXG4gICAgICAgIHZhciBudW1Db2Rld29yZHM7XHJcbiAgICAgICAgdmFyIG51bURhdGFDb2Rld29yZHM7XHJcbiAgICAgICAgaWYgKGNvbXBhY3QpIHtcclxuICAgICAgICAgICAgbnVtQ29kZXdvcmRzID0gNztcclxuICAgICAgICAgICAgbnVtRGF0YUNvZGV3b3JkcyA9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBudW1Db2Rld29yZHMgPSAxMDtcclxuICAgICAgICAgICAgbnVtRGF0YUNvZGV3b3JkcyA9IDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBudW1FQ0NvZGV3b3JkcyA9IG51bUNvZGV3b3JkcyAtIG51bURhdGFDb2Rld29yZHM7XHJcbiAgICAgICAgdmFyIHBhcmFtZXRlcldvcmRzID0gbmV3IEludDMyQXJyYXkobnVtQ29kZXdvcmRzKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gbnVtQ29kZXdvcmRzIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgcGFyYW1ldGVyV29yZHNbaV0gPSBwYXJhbWV0ZXJEYXRhICYgMHhGO1xyXG4gICAgICAgICAgICBwYXJhbWV0ZXJEYXRhID4+PSA0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgcnNEZWNvZGVyID0gbmV3IFJlZWRTb2xvbW9uRGVjb2Rlcl8xLmRlZmF1bHQoR2VuZXJpY0dGXzEuZGVmYXVsdC5BWlRFQ19QQVJBTSk7XHJcbiAgICAgICAgICAgIHJzRGVjb2Rlci5kZWNvZGUocGFyYW1ldGVyV29yZHMsIG51bUVDQ29kZXdvcmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUb3NzIHRoZSBlcnJvciBjb3JyZWN0aW9uLiAgSnVzdCByZXR1cm4gdGhlIGRhdGEgYXMgYW4gaW50ZWdlclxyXG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgNCkgKyBwYXJhbWV0ZXJXb3Jkc1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIHRoZSBjb3JuZXJzIG9mIGEgYnVsbC1leWUgY2VudGVyZWQgb24gdGhlIHBhc3NlZCBwb2ludC5cclxuICAgICAqIFRoaXMgcmV0dXJucyB0aGUgY2VudGVycyBvZiB0aGUgZGlhZ29uYWwgcG9pbnRzIGp1c3Qgb3V0c2lkZSB0aGUgYnVsbCdzIGV5ZVxyXG4gICAgICogUmV0dXJucyBbdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0LCB0b3BMZWZ0XVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwQ2VudGVyIENlbnRlciBwb2ludFxyXG4gICAgICogQHJldHVybiBUaGUgY29ybmVycyBvZiB0aGUgYnVsbC1leWVcclxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gSWYgbm8gdmFsaWQgYnVsbC1leWUgY2FuIGJlIGZvdW5kXHJcbiAgICAgKi9cclxuICAgIERldGVjdG9yLnByb3RvdHlwZS5nZXRCdWxsc0V5ZUNvcm5lcnMgPSBmdW5jdGlvbiAocENlbnRlcikge1xyXG4gICAgICAgIHZhciBwaW5hID0gcENlbnRlcjtcclxuICAgICAgICB2YXIgcGluYiA9IHBDZW50ZXI7XHJcbiAgICAgICAgdmFyIHBpbmMgPSBwQ2VudGVyO1xyXG4gICAgICAgIHZhciBwaW5kID0gcENlbnRlcjtcclxuICAgICAgICB2YXIgY29sb3IgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodGhpcy5uYkNlbnRlckxheWVycyA9IDE7IHRoaXMubmJDZW50ZXJMYXllcnMgPCA5OyB0aGlzLm5iQ2VudGVyTGF5ZXJzKyspIHtcclxuICAgICAgICAgICAgdmFyIHBvdXRhID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChwaW5hLCBjb2xvciwgMSwgLTEpO1xyXG4gICAgICAgICAgICB2YXIgcG91dGIgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KHBpbmIsIGNvbG9yLCAxLCAxKTtcclxuICAgICAgICAgICAgdmFyIHBvdXRjID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChwaW5jLCBjb2xvciwgLTEsIDEpO1xyXG4gICAgICAgICAgICB2YXIgcG91dGQgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KHBpbmQsIGNvbG9yLCAtMSwgLTEpO1xyXG4gICAgICAgICAgICAvLyBkICAgICAgYVxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBjICAgICAgYlxyXG4gICAgICAgICAgICBpZiAodGhpcy5uYkNlbnRlckxheWVycyA+IDIpIHtcclxuICAgICAgICAgICAgICAgIHZhciBxID0gKHRoaXMuZGlzdGFuY2VQb2ludChwb3V0ZCwgcG91dGEpICogdGhpcy5uYkNlbnRlckxheWVycykgLyAodGhpcy5kaXN0YW5jZVBvaW50KHBpbmQsIHBpbmEpICogKHRoaXMubmJDZW50ZXJMYXllcnMgKyAyKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocSA8IDAuNzUgfHwgcSA+IDEuMjUgfHwgIXRoaXMuaXNXaGl0ZU9yQmxhY2tSZWN0YW5nbGUocG91dGEsIHBvdXRiLCBwb3V0YywgcG91dGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGluYSA9IHBvdXRhO1xyXG4gICAgICAgICAgICBwaW5iID0gcG91dGI7XHJcbiAgICAgICAgICAgIHBpbmMgPSBwb3V0YztcclxuICAgICAgICAgICAgcGluZCA9IHBvdXRkO1xyXG4gICAgICAgICAgICBjb2xvciA9ICFjb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubmJDZW50ZXJMYXllcnMgIT09IDUgJiYgdGhpcy5uYkNlbnRlckxheWVycyAhPT0gNykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcGFjdCA9IHRoaXMubmJDZW50ZXJMYXllcnMgPT09IDU7XHJcbiAgICAgICAgLy8gRXhwYW5kIHRoZSBzcXVhcmUgYnkgLjUgcGl4ZWwgaW4gZWFjaCBkaXJlY3Rpb24gc28gdGhhdCB3ZSdyZSBvbiB0aGUgYm9yZGVyXHJcbiAgICAgICAgLy8gYmV0d2VlbiB0aGUgd2hpdGUgc3F1YXJlIGFuZCB0aGUgYmxhY2sgc3F1YXJlXHJcbiAgICAgICAgdmFyIHBpbmF4ID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChwaW5hLmdldFgoKSArIDAuNSwgcGluYS5nZXRZKCkgLSAwLjUpO1xyXG4gICAgICAgIHZhciBwaW5ieCA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQocGluYi5nZXRYKCkgKyAwLjUsIHBpbmIuZ2V0WSgpICsgMC41KTtcclxuICAgICAgICB2YXIgcGluY3ggPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHBpbmMuZ2V0WCgpIC0gMC41LCBwaW5jLmdldFkoKSArIDAuNSk7XHJcbiAgICAgICAgdmFyIHBpbmR4ID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChwaW5kLmdldFgoKSAtIDAuNSwgcGluZC5nZXRZKCkgLSAwLjUpO1xyXG4gICAgICAgIC8vIEV4cGFuZCB0aGUgc3F1YXJlIHNvIHRoYXQgaXRzIGNvcm5lcnMgYXJlIHRoZSBjZW50ZXJzIG9mIHRoZSBwb2ludHNcclxuICAgICAgICAvLyBqdXN0IG91dHNpZGUgdGhlIGJ1bGwncyBleWUuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kU3F1YXJlKFtwaW5heCwgcGluYngsIHBpbmN4LCBwaW5keF0sIDIgKiB0aGlzLm5iQ2VudGVyTGF5ZXJzIC0gMywgMiAqIHRoaXMubmJDZW50ZXJMYXllcnMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgYSBjYW5kaWRhdGUgY2VudGVyIHBvaW50IG9mIGFuIEF6dGVjIGNvZGUgZnJvbSBhbiBpbWFnZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gdGhlIGNlbnRlciBwb2ludFxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZ2V0TWF0cml4Q2VudGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwb2ludEE7XHJcbiAgICAgICAgdmFyIHBvaW50QjtcclxuICAgICAgICB2YXIgcG9pbnRDO1xyXG4gICAgICAgIHZhciBwb2ludEQ7XHJcbiAgICAgICAgLy8gR2V0IGEgd2hpdGUgcmVjdGFuZ2xlIHRoYXQgY2FuIGJlIHRoZSBib3JkZXIgb2YgdGhlIG1hdHJpeCBpbiBjZW50ZXIgYnVsbCdzIGV5ZSBvclxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBjb3JuZXJQb2ludHMgPSBuZXcgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcl8xLmRlZmF1bHQodGhpcy5pbWFnZSkuZGV0ZWN0KCk7XHJcbiAgICAgICAgICAgIHBvaW50QSA9IGNvcm5lclBvaW50c1swXTtcclxuICAgICAgICAgICAgcG9pbnRCID0gY29ybmVyUG9pbnRzWzFdO1xyXG4gICAgICAgICAgICBwb2ludEMgPSBjb3JuZXJQb2ludHNbMl07XHJcbiAgICAgICAgICAgIHBvaW50RCA9IGNvcm5lclBvaW50c1szXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBleGNlcHRpb24gY2FuIGJlIGluIGNhc2UgdGhlIGluaXRpYWwgcmVjdGFuZ2xlIGlzIHdoaXRlXHJcbiAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSwgc3VyZWx5IGluIHRoZSBidWxsJ3MgZXllLCB3ZSB0cnkgdG8gZXhwYW5kIHRoZSByZWN0YW5nbGUuXHJcbiAgICAgICAgICAgIHZhciBjeF8xID0gdGhpcy5pbWFnZS5nZXRXaWR0aCgpIC8gMjtcclxuICAgICAgICAgICAgdmFyIGN5XzEgPSB0aGlzLmltYWdlLmdldEhlaWdodCgpIC8gMjtcclxuICAgICAgICAgICAgcG9pbnRBID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3hfMSArIDcsIGN5XzEgLSA3KSwgZmFsc2UsIDEsIC0xKS50b1Jlc3VsdFBvaW50KCk7XHJcbiAgICAgICAgICAgIHBvaW50QiA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4XzEgKyA3LCBjeV8xICsgNyksIGZhbHNlLCAxLCAxKS50b1Jlc3VsdFBvaW50KCk7XHJcbiAgICAgICAgICAgIHBvaW50QyA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4XzEgLSA3LCBjeV8xICsgNyksIGZhbHNlLCAtMSwgMSkudG9SZXN1bHRQb2ludCgpO1xyXG4gICAgICAgICAgICBwb2ludEQgPSB0aGlzLmdldEZpcnN0RGlmZmVyZW50KG5ldyBQb2ludChjeF8xIC0gNywgY3lfMSAtIDcpLCBmYWxzZSwgLTEsIC0xKS50b1Jlc3VsdFBvaW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNlbnRlciBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgICAgdmFyIGN4ID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZCgocG9pbnRBLmdldFgoKSArIHBvaW50RC5nZXRYKCkgKyBwb2ludEIuZ2V0WCgpICsgcG9pbnRDLmdldFgoKSkgLyA0LjApO1xyXG4gICAgICAgIHZhciBjeSA9IE1hdGhVdGlsc18xLmRlZmF1bHQucm91bmQoKHBvaW50QS5nZXRZKCkgKyBwb2ludEQuZ2V0WSgpICsgcG9pbnRCLmdldFkoKSArIHBvaW50Qy5nZXRZKCkpIC8gNC4wKTtcclxuICAgICAgICAvLyBSZWRldGVybWluZSB0aGUgd2hpdGUgcmVjdGFuZ2xlIHN0YXJ0aW5nIGZyb20gcHJldmlvdXNseSBjb21wdXRlZCBjZW50ZXIuXHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IHdlIGVuZCB1cCB3aXRoIGEgd2hpdGUgcmVjdGFuZ2xlIGluIGNlbnRlciBidWxsJ3MgZXllXHJcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gY29tcHV0ZSBhIG1vcmUgYWNjdXJhdGUgY2VudGVyLlxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBjb3JuZXJQb2ludHMgPSBuZXcgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvcl8xLmRlZmF1bHQodGhpcy5pbWFnZSwgMTUsIGN4LCBjeSkuZGV0ZWN0KCk7XHJcbiAgICAgICAgICAgIHBvaW50QSA9IGNvcm5lclBvaW50c1swXTtcclxuICAgICAgICAgICAgcG9pbnRCID0gY29ybmVyUG9pbnRzWzFdO1xyXG4gICAgICAgICAgICBwb2ludEMgPSBjb3JuZXJQb2ludHNbMl07XHJcbiAgICAgICAgICAgIHBvaW50RCA9IGNvcm5lclBvaW50c1szXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBleGNlcHRpb24gY2FuIGJlIGluIGNhc2UgdGhlIGluaXRpYWwgcmVjdGFuZ2xlIGlzIHdoaXRlXHJcbiAgICAgICAgICAgIC8vIEluIHRoYXQgY2FzZSB3ZSB0cnkgdG8gZXhwYW5kIHRoZSByZWN0YW5nbGUuXHJcbiAgICAgICAgICAgIHBvaW50QSA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4ICsgNywgY3kgLSA3KSwgZmFsc2UsIDEsIC0xKS50b1Jlc3VsdFBvaW50KCk7XHJcbiAgICAgICAgICAgIHBvaW50QiA9IHRoaXMuZ2V0Rmlyc3REaWZmZXJlbnQobmV3IFBvaW50KGN4ICsgNywgY3kgKyA3KSwgZmFsc2UsIDEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcclxuICAgICAgICAgICAgcG9pbnRDID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3ggLSA3LCBjeSArIDcpLCBmYWxzZSwgLTEsIDEpLnRvUmVzdWx0UG9pbnQoKTtcclxuICAgICAgICAgICAgcG9pbnREID0gdGhpcy5nZXRGaXJzdERpZmZlcmVudChuZXcgUG9pbnQoY3ggLSA3LCBjeSAtIDcpLCBmYWxzZSwgLTEsIC0xKS50b1Jlc3VsdFBvaW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlY29tcHV0ZSB0aGUgY2VudGVyIG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAgICBjeCA9IE1hdGhVdGlsc18xLmRlZmF1bHQucm91bmQoKHBvaW50QS5nZXRYKCkgKyBwb2ludEQuZ2V0WCgpICsgcG9pbnRCLmdldFgoKSArIHBvaW50Qy5nZXRYKCkpIC8gNC4wKTtcclxuICAgICAgICBjeSA9IE1hdGhVdGlsc18xLmRlZmF1bHQucm91bmQoKHBvaW50QS5nZXRZKCkgKyBwb2ludEQuZ2V0WSgpICsgcG9pbnRCLmdldFkoKSArIHBvaW50Qy5nZXRZKCkpIC8gNC4wKTtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KGN4LCBjeSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBBenRlYyBjb2RlIGNvcm5lcnMgZnJvbSB0aGUgYnVsbCdzIGV5ZSBjb3JuZXJzIGFuZCB0aGUgcGFyYW1ldGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYnVsbHNFeWVDb3JuZXJzIHRoZSBhcnJheSBvZiBidWxsJ3MgZXllIGNvcm5lcnNcclxuICAgICAqIEByZXR1cm4gdGhlIGFycmF5IG9mIGF6dGVjIGNvZGUgY29ybmVyc1xyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZ2V0TWF0cml4Q29ybmVyUG9pbnRzID0gZnVuY3Rpb24gKGJ1bGxzRXllQ29ybmVycykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuZFNxdWFyZShidWxsc0V5ZUNvcm5lcnMsIDIgKiB0aGlzLm5iQ2VudGVyTGF5ZXJzLCB0aGlzLmdldERpbWVuc2lvbigpKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBCaXRNYXRyaXggYnkgc2FtcGxpbmcgdGhlIHByb3ZpZGVkIGltYWdlLlxyXG4gICAgICogdG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBhbmQgYm90dG9tTGVmdCBhcmUgdGhlIGNlbnRlcnMgb2YgdGhlIHNxdWFyZXMgb24gdGhlXHJcbiAgICAgKiBkaWFnb25hbCBqdXN0IG91dHNpZGUgdGhlIGJ1bGwncyBleWUuXHJcbiAgICAgKi9cclxuICAgIERldGVjdG9yLnByb3RvdHlwZS5zYW1wbGVHcmlkID0gZnVuY3Rpb24gKGltYWdlLCB0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tUmlnaHQsIGJvdHRvbUxlZnQpIHtcclxuICAgICAgICB2YXIgc2FtcGxlciA9IEdyaWRTYW1wbGVySW5zdGFuY2VfMS5kZWZhdWx0LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuZ2V0RGltZW5zaW9uKCk7XHJcbiAgICAgICAgdmFyIGxvdyA9IGRpbWVuc2lvbiAvIDIgLSB0aGlzLm5iQ2VudGVyTGF5ZXJzO1xyXG4gICAgICAgIHZhciBoaWdoID0gZGltZW5zaW9uIC8gMiArIHRoaXMubmJDZW50ZXJMYXllcnM7XHJcbiAgICAgICAgcmV0dXJuIHNhbXBsZXIuc2FtcGxlR3JpZChpbWFnZSwgZGltZW5zaW9uLCBkaW1lbnNpb24sIGxvdywgbG93LCAvLyB0b3BsZWZ0XHJcbiAgICAgICAgaGlnaCwgbG93LCAvLyB0b3ByaWdodFxyXG4gICAgICAgIGhpZ2gsIGhpZ2gsIC8vIGJvdHRvbXJpZ2h0XHJcbiAgICAgICAgbG93LCBoaWdoLCAvLyBib3R0b21sZWZ0XHJcbiAgICAgICAgdG9wTGVmdC5nZXRYKCksIHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRYKCksIHRvcFJpZ2h0LmdldFkoKSwgYm90dG9tUmlnaHQuZ2V0WCgpLCBib3R0b21SaWdodC5nZXRZKCksIGJvdHRvbUxlZnQuZ2V0WCgpLCBib3R0b21MZWZ0LmdldFkoKSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTYW1wbGVzIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcDEgICBzdGFydCBwb2ludCAoaW5jbHVzaXZlKVxyXG4gICAgICogQHBhcmFtIHAyICAgZW5kIHBvaW50IChleGNsdXNpdmUpXHJcbiAgICAgKiBAcGFyYW0gc2l6ZSBudW1iZXIgb2YgYml0c1xyXG4gICAgICogQHJldHVybiB0aGUgYXJyYXkgb2YgYml0cyBhcyBhbiBpbnQgKGZpcnN0IGJpdCBpcyBoaWdoLW9yZGVyIGJpdCBvZiByZXN1bHQpXHJcbiAgICAgKi9cclxuICAgIERldGVjdG9yLnByb3RvdHlwZS5zYW1wbGVMaW5lID0gZnVuY3Rpb24gKHAxLCBwMiwgc2l6ZSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAwO1xyXG4gICAgICAgIHZhciBkID0gdGhpcy5kaXN0YW5jZVJlc3VsdFBvaW50KHAxLCBwMik7XHJcbiAgICAgICAgdmFyIG1vZHVsZVNpemUgPSBkIC8gc2l6ZTtcclxuICAgICAgICB2YXIgcHggPSBwMS5nZXRYKCk7XHJcbiAgICAgICAgdmFyIHB5ID0gcDEuZ2V0WSgpO1xyXG4gICAgICAgIHZhciBkeCA9IG1vZHVsZVNpemUgKiAocDIuZ2V0WCgpIC0gcDEuZ2V0WCgpKSAvIGQ7XHJcbiAgICAgICAgdmFyIGR5ID0gbW9kdWxlU2l6ZSAqIChwMi5nZXRZKCkgLSBwMS5nZXRZKCkpIC8gZDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbWFnZS5nZXQoTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZChweCArIGkgKiBkeCksIE1hdGhVdGlsc18xLmRlZmF1bHQucm91bmQocHkgKyBpICogZHkpKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0IHw9IDEgPDwgKHNpemUgLSBpIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgYm9yZGVyIG9mIHRoZSByZWN0YW5nbGUgcGFzc2VkIGluIHBhcmFtZXRlciBpcyBjb21wb3VuZCBvZiB3aGl0ZSBwb2ludHMgb25seVxyXG4gICAgICogICAgICAgICBvciBibGFjayBwb2ludHMgb25seVxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuaXNXaGl0ZU9yQmxhY2tSZWN0YW5nbGUgPSBmdW5jdGlvbiAocDEsIHAyLCBwMywgcDQpIHtcclxuICAgICAgICB2YXIgY29yciA9IDM7XHJcbiAgICAgICAgcDEgPSBuZXcgUG9pbnQocDEuZ2V0WCgpIC0gY29yciwgcDEuZ2V0WSgpICsgY29ycik7XHJcbiAgICAgICAgcDIgPSBuZXcgUG9pbnQocDIuZ2V0WCgpIC0gY29yciwgcDIuZ2V0WSgpIC0gY29ycik7XHJcbiAgICAgICAgcDMgPSBuZXcgUG9pbnQocDMuZ2V0WCgpICsgY29yciwgcDMuZ2V0WSgpIC0gY29ycik7XHJcbiAgICAgICAgcDQgPSBuZXcgUG9pbnQocDQuZ2V0WCgpICsgY29yciwgcDQuZ2V0WSgpICsgY29ycik7XHJcbiAgICAgICAgdmFyIGNJbml0ID0gdGhpcy5nZXRDb2xvcihwNCwgcDEpO1xyXG4gICAgICAgIGlmIChjSW5pdCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjID0gdGhpcy5nZXRDb2xvcihwMSwgcDIpO1xyXG4gICAgICAgIGlmIChjICE9PSBjSW5pdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGMgPSB0aGlzLmdldENvbG9yKHAyLCBwMyk7XHJcbiAgICAgICAgaWYgKGMgIT09IGNJbml0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYyA9IHRoaXMuZ2V0Q29sb3IocDMsIHA0KTtcclxuICAgICAgICByZXR1cm4gYyA9PT0gY0luaXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjb2xvciBvZiBhIHNlZ21lbnRcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIDEgaWYgc2VnbWVudCBtb3JlIHRoYW4gOTAlIGJsYWNrLCAtMSBpZiBzZWdtZW50IGlzIG1vcmUgdGhhbiA5MCUgd2hpdGUsIDAgZWxzZVxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbiAocDEsIHAyKSB7XHJcbiAgICAgICAgdmFyIGQgPSB0aGlzLmRpc3RhbmNlUG9pbnQocDEsIHAyKTtcclxuICAgICAgICB2YXIgZHggPSAocDIuZ2V0WCgpIC0gcDEuZ2V0WCgpKSAvIGQ7XHJcbiAgICAgICAgdmFyIGR5ID0gKHAyLmdldFkoKSAtIHAxLmdldFkoKSkgLyBkO1xyXG4gICAgICAgIHZhciBlcnJvciA9IDA7XHJcbiAgICAgICAgdmFyIHB4ID0gcDEuZ2V0WCgpO1xyXG4gICAgICAgIHZhciBweSA9IHAxLmdldFkoKTtcclxuICAgICAgICB2YXIgY29sb3JNb2RlbCA9IHRoaXMuaW1hZ2UuZ2V0KHAxLmdldFgoKSwgcDEuZ2V0WSgpKTtcclxuICAgICAgICB2YXIgaU1heCA9IE1hdGguY2VpbChkKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlNYXg7IGkrKykge1xyXG4gICAgICAgICAgICBweCArPSBkeDtcclxuICAgICAgICAgICAgcHkgKz0gZHk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmltYWdlLmdldChNYXRoVXRpbHNfMS5kZWZhdWx0LnJvdW5kKHB4KSwgTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZChweSkpICE9PSBjb2xvck1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlcnJSYXRpbyA9IGVycm9yIC8gZDtcclxuICAgICAgICBpZiAoZXJyUmF0aW8gPiAwLjEgJiYgZXJyUmF0aW8gPCAwLjkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoZXJyUmF0aW8gPD0gMC4xKSA9PT0gY29sb3JNb2RlbCA/IDEgOiAtMTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IHBvaW50IHdpdGggYSBkaWZmZXJlbnQgY29sb3IgaW4gdGhlIGdpdmVuIGRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZ2V0Rmlyc3REaWZmZXJlbnQgPSBmdW5jdGlvbiAoaW5pdCwgY29sb3IsIGR4LCBkeSkge1xyXG4gICAgICAgIHZhciB4ID0gaW5pdC5nZXRYKCkgKyBkeDtcclxuICAgICAgICB2YXIgeSA9IGluaXQuZ2V0WSgpICsgZHk7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNWYWxpZCh4LCB5KSAmJiB0aGlzLmltYWdlLmdldCh4LCB5KSA9PT0gY29sb3IpIHtcclxuICAgICAgICAgICAgeCArPSBkeDtcclxuICAgICAgICAgICAgeSArPSBkeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeCAtPSBkeDtcclxuICAgICAgICB5IC09IGR5O1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmlzVmFsaWQoeCwgeSkgJiYgdGhpcy5pbWFnZS5nZXQoeCwgeSkgPT09IGNvbG9yKSB7XHJcbiAgICAgICAgICAgIHggKz0gZHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHggLT0gZHg7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNWYWxpZCh4LCB5KSAmJiB0aGlzLmltYWdlLmdldCh4LCB5KSA9PT0gY29sb3IpIHtcclxuICAgICAgICAgICAgeSArPSBkeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeSAtPSBkeTtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRXhwYW5kIHRoZSBzcXVhcmUgcmVwcmVzZW50ZWQgYnkgdGhlIGNvcm5lciBwb2ludHMgYnkgcHVzaGluZyBvdXQgZXF1YWxseSBpbiBhbGwgZGlyZWN0aW9uc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb3JuZXJQb2ludHMgdGhlIGNvcm5lcnMgb2YgdGhlIHNxdWFyZSwgd2hpY2ggaGFzIHRoZSBidWxsJ3MgZXllIGF0IGl0cyBjZW50ZXJcclxuICAgICAqIEBwYXJhbSBvbGRTaWRlIHRoZSBvcmlnaW5hbCBsZW5ndGggb2YgdGhlIHNpZGUgb2YgdGhlIHNxdWFyZSBpbiB0aGUgdGFyZ2V0IGJpdCBtYXRyaXhcclxuICAgICAqIEBwYXJhbSBuZXdTaWRlIHRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBzaXplIG9mIHRoZSBzcXVhcmUgaW4gdGhlIHRhcmdldCBiaXQgbWF0cml4XHJcbiAgICAgKiBAcmV0dXJuIHRoZSBjb3JuZXJzIG9mIHRoZSBleHBhbmRlZCBzcXVhcmVcclxuICAgICAqL1xyXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmV4cGFuZFNxdWFyZSA9IGZ1bmN0aW9uIChjb3JuZXJQb2ludHMsIG9sZFNpZGUsIG5ld1NpZGUpIHtcclxuICAgICAgICB2YXIgcmF0aW8gPSBuZXdTaWRlIC8gKDIuMCAqIG9sZFNpZGUpO1xyXG4gICAgICAgIHZhciBkeCA9IGNvcm5lclBvaW50c1swXS5nZXRYKCkgLSBjb3JuZXJQb2ludHNbMl0uZ2V0WCgpO1xyXG4gICAgICAgIHZhciBkeSA9IGNvcm5lclBvaW50c1swXS5nZXRZKCkgLSBjb3JuZXJQb2ludHNbMl0uZ2V0WSgpO1xyXG4gICAgICAgIHZhciBjZW50ZXJ4ID0gKGNvcm5lclBvaW50c1swXS5nZXRYKCkgKyBjb3JuZXJQb2ludHNbMl0uZ2V0WCgpKSAvIDIuMDtcclxuICAgICAgICB2YXIgY2VudGVyeSA9IChjb3JuZXJQb2ludHNbMF0uZ2V0WSgpICsgY29ybmVyUG9pbnRzWzJdLmdldFkoKSkgLyAyLjA7XHJcbiAgICAgICAgdmFyIHJlc3VsdDAgPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGNlbnRlcnggKyByYXRpbyAqIGR4LCBjZW50ZXJ5ICsgcmF0aW8gKiBkeSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdDIgPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGNlbnRlcnggLSByYXRpbyAqIGR4LCBjZW50ZXJ5IC0gcmF0aW8gKiBkeSk7XHJcbiAgICAgICAgZHggPSBjb3JuZXJQb2ludHNbMV0uZ2V0WCgpIC0gY29ybmVyUG9pbnRzWzNdLmdldFgoKTtcclxuICAgICAgICBkeSA9IGNvcm5lclBvaW50c1sxXS5nZXRZKCkgLSBjb3JuZXJQb2ludHNbM10uZ2V0WSgpO1xyXG4gICAgICAgIGNlbnRlcnggPSAoY29ybmVyUG9pbnRzWzFdLmdldFgoKSArIGNvcm5lclBvaW50c1szXS5nZXRYKCkpIC8gMi4wO1xyXG4gICAgICAgIGNlbnRlcnkgPSAoY29ybmVyUG9pbnRzWzFdLmdldFkoKSArIGNvcm5lclBvaW50c1szXS5nZXRZKCkpIC8gMi4wO1xyXG4gICAgICAgIHZhciByZXN1bHQxID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChjZW50ZXJ4ICsgcmF0aW8gKiBkeCwgY2VudGVyeSArIHJhdGlvICogZHkpO1xyXG4gICAgICAgIHZhciByZXN1bHQzID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChjZW50ZXJ4IC0gcmF0aW8gKiBkeCwgY2VudGVyeSAtIHJhdGlvICogZHkpO1xyXG4gICAgICAgIHZhciByZXN1bHRzID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDNdO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfTtcclxuICAgIERldGVjdG9yLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKHgsIHkpIHtcclxuICAgICAgICByZXR1cm4geCA+PSAwICYmIHggPCB0aGlzLmltYWdlLmdldFdpZHRoKCkgJiYgeSA+IDAgJiYgeSA8IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmlzVmFsaWRQb2ludCA9IGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgIHZhciB4ID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZChwb2ludC5nZXRYKCkpO1xyXG4gICAgICAgIHZhciB5ID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZChwb2ludC5nZXRZKCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoeCwgeSk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmRpc3RhbmNlUG9pbnQgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBNYXRoVXRpbHNfMS5kZWZhdWx0LmRpc3RhbmNlKGEuZ2V0WCgpLCBhLmdldFkoKSwgYi5nZXRYKCksIGIuZ2V0WSgpKTtcclxuICAgIH07XHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZGlzdGFuY2VSZXN1bHRQb2ludCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsc18xLmRlZmF1bHQuZGlzdGFuY2UoYS5nZXRYKCksIGEuZ2V0WSgpLCBiLmdldFgoKSwgYi5nZXRZKCkpO1xyXG4gICAgfTtcclxuICAgIERldGVjdG9yLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcGFjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gNCAqIHRoaXMubmJMYXllcnMgKyAxMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubmJMYXllcnMgPD0gNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gNCAqIHRoaXMubmJMYXllcnMgKyAxNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDQgKiB0aGlzLm5iTGF5ZXJzICsgMiAqIChJbnRlZ2VyXzEuZGVmYXVsdC50cnVuY0RpdmlzaW9uKCh0aGlzLm5iTGF5ZXJzIC0gNCksIDgpICsgMSkgKyAxNTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGV0ZWN0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERldGVjdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZXRlY3Rvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqL1xyXG4vKmltcG9ydCBqYXZhLnV0aWwuQXJyYXlzOyovXHJcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuLi91dGlsL1N5c3RlbVwiKTtcclxudmFyIEludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi91dGlsL0ludGVnZXJcIik7XHJcbnZhciBBcnJheXNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL0FycmF5c1wiKTtcclxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIDxwPkEgc2ltcGxlLCBmYXN0IGFycmF5IG9mIGJpdHMsIHJlcHJlc2VudGVkIGNvbXBhY3RseSBieSBhbiBhcnJheSBvZiBpbnRzIGludGVybmFsbHkuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIEJpdEFycmF5IC8qaW1wbGVtZW50cyBDbG9uZWFibGUqLyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8vICAgdGhpcy5zaXplID0gMFxyXG4gICAgLy8gICB0aGlzLmJpdHMgPSBuZXcgSW50MzJBcnJheSgxKVxyXG4gICAgLy8gfVxyXG4gICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKHNpemU/OiBudW1iZXIgLyppbnQqLykge1xyXG4gICAgLy8gICBpZiAodW5kZWZpbmVkID09PSBzaXplKSB7XHJcbiAgICAvLyAgICAgdGhpcy5zaXplID0gMFxyXG4gICAgLy8gICB9IGVsc2Uge1xyXG4gICAgLy8gICAgIHRoaXMuc2l6ZSA9IHNpemVcclxuICAgIC8vICAgfVxyXG4gICAgLy8gICB0aGlzLmJpdHMgPSB0aGlzLm1ha2VBcnJheShzaXplKVxyXG4gICAgLy8gfVxyXG4gICAgLy8gRm9yIHRlc3Rpbmcgb25seVxyXG4gICAgZnVuY3Rpb24gQml0QXJyYXkoc2l6ZSAvKmludCovLCBiaXRzKSB7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmJpdHMgPSBuZXcgSW50MzJBcnJheSgxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGJpdHMgfHwgbnVsbCA9PT0gYml0cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gQml0QXJyYXkubWFrZUFycmF5KHNpemUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iaXRzID0gYml0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEJpdEFycmF5LnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XHJcbiAgICB9O1xyXG4gICAgQml0QXJyYXkucHJvdG90eXBlLmdldFNpemVJbkJ5dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCh0aGlzLnNpemUgKyA3KSAvIDgpO1xyXG4gICAgfTtcclxuICAgIEJpdEFycmF5LnByb3RvdHlwZS5lbnN1cmVDYXBhY2l0eSA9IGZ1bmN0aW9uIChzaXplIC8qaW50Ki8pIHtcclxuICAgICAgICBpZiAoc2l6ZSA+IHRoaXMuYml0cy5sZW5ndGggKiAzMikge1xyXG4gICAgICAgICAgICB2YXIgbmV3Qml0cyA9IEJpdEFycmF5Lm1ha2VBcnJheShzaXplKTtcclxuICAgICAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkodGhpcy5iaXRzLCAwLCBuZXdCaXRzLCAwLCB0aGlzLmJpdHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgdGhpcy5iaXRzID0gbmV3Qml0cztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaSBiaXQgdG8gZ2V0XHJcbiAgICAgKiBAcmV0dXJuIHRydWUgaWZmIGJpdCBpIGlzIHNldFxyXG4gICAgICovXHJcbiAgICBCaXRBcnJheS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGkgLyppbnQqLykge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5iaXRzW01hdGguZmxvb3IoaSAvIDMyKV0gJiAoMSA8PCAoaSAmIDB4MUYpKSkgIT09IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGJpdCBpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpIGJpdCB0byBzZXRcclxuICAgICAqL1xyXG4gICAgQml0QXJyYXkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpIC8qaW50Ki8pIHtcclxuICAgICAgICB0aGlzLmJpdHNbTWF0aC5mbG9vcihpIC8gMzIpXSB8PSAxIDw8IChpICYgMHgxRik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBGbGlwcyBiaXQgaS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaSBiaXQgdG8gc2V0XHJcbiAgICAgKi9cclxuICAgIEJpdEFycmF5LnByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24gKGkgLyppbnQqLykge1xyXG4gICAgICAgIHRoaXMuYml0c1tNYXRoLmZsb29yKGkgLyAzMildIF49IDEgPDwgKGkgJiAweDFGKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBmcm9tIGZpcnN0IGJpdCB0byBjaGVja1xyXG4gICAgICogQHJldHVybiBpbmRleCBvZiBmaXJzdCBiaXQgdGhhdCBpcyBzZXQsIHN0YXJ0aW5nIGZyb20gdGhlIGdpdmVuIGluZGV4LCBvciBzaXplIGlmIG5vbmUgYXJlIHNldFxyXG4gICAgICogIGF0IG9yIGJleW9uZCB0aGlzIGdpdmVuIGluZGV4XHJcbiAgICAgKiBAc2VlICNnZXROZXh0VW5zZXQoaW50KVxyXG4gICAgICovXHJcbiAgICBCaXRBcnJheS5wcm90b3R5cGUuZ2V0TmV4dFNldCA9IGZ1bmN0aW9uIChmcm9tIC8qaW50Ki8pIHtcclxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZTtcclxuICAgICAgICBpZiAoZnJvbSA+PSBzaXplKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcclxuICAgICAgICB2YXIgYml0c09mZnNldCA9IE1hdGguZmxvb3IoZnJvbSAvIDMyKTtcclxuICAgICAgICB2YXIgY3VycmVudEJpdHMgPSBiaXRzW2JpdHNPZmZzZXRdO1xyXG4gICAgICAgIC8vIG1hc2sgb2ZmIGxlc3NlciBiaXRzIGZpcnN0XHJcbiAgICAgICAgY3VycmVudEJpdHMgJj0gfigoMSA8PCAoZnJvbSAmIDB4MUYpKSAtIDEpO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBiaXRzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudEJpdHMgPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKCsrYml0c09mZnNldCA9PT0gbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50Qml0cyA9IGJpdHNbYml0c09mZnNldF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSAoYml0c09mZnNldCAqIDMyKSArIEludGVnZXJfMS5kZWZhdWx0Lm51bWJlck9mVHJhaWxpbmdaZXJvcyhjdXJyZW50Qml0cyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA+IHNpemUgPyBzaXplIDogcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGZyb20gaW5kZXggdG8gc3RhcnQgbG9va2luZyBmb3IgdW5zZXQgYml0XHJcbiAgICAgKiBAcmV0dXJuIGluZGV4IG9mIG5leHQgdW5zZXQgYml0LCBvciB7QGNvZGUgc2l6ZX0gaWYgbm9uZSBhcmUgdW5zZXQgdW50aWwgdGhlIGVuZFxyXG4gICAgICogQHNlZSAjZ2V0TmV4dFNldChpbnQpXHJcbiAgICAgKi9cclxuICAgIEJpdEFycmF5LnByb3RvdHlwZS5nZXROZXh0VW5zZXQgPSBmdW5jdGlvbiAoZnJvbSAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemU7XHJcbiAgICAgICAgaWYgKGZyb20gPj0gc2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7XHJcbiAgICAgICAgdmFyIGJpdHNPZmZzZXQgPSBNYXRoLmZsb29yKGZyb20gLyAzMik7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRCaXRzID0gfmJpdHNbYml0c09mZnNldF07XHJcbiAgICAgICAgLy8gbWFzayBvZmYgbGVzc2VyIGJpdHMgZmlyc3RcclxuICAgICAgICBjdXJyZW50Qml0cyAmPSB+KCgxIDw8IChmcm9tICYgMHgxRikpIC0gMSk7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGJpdHMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50Qml0cyA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoKytiaXRzT2Zmc2V0ID09PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRCaXRzID0gfmJpdHNbYml0c09mZnNldF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSAoYml0c09mZnNldCAqIDMyKSArIEludGVnZXJfMS5kZWZhdWx0Lm51bWJlck9mVHJhaWxpbmdaZXJvcyhjdXJyZW50Qml0cyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA+IHNpemUgPyBzaXplIDogcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBhIGJsb2NrIG9mIDMyIGJpdHMsIHN0YXJ0aW5nIGF0IGJpdCBpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpIGZpcnN0IGJpdCB0byBzZXRcclxuICAgICAqIEBwYXJhbSBuZXdCaXRzIHRoZSBuZXcgdmFsdWUgb2YgdGhlIG5leHQgMzIgYml0cy4gTm90ZSBhZ2FpbiB0aGF0IHRoZSBsZWFzdC1zaWduaWZpY2FudCBiaXRcclxuICAgICAqIGNvcnJlc3BvbmRzIHRvIGJpdCBpLCB0aGUgbmV4dC1sZWFzdC1zaWduaWZpY2FudCB0byBpKzEsIGFuZCBzbyBvbi5cclxuICAgICAqL1xyXG4gICAgQml0QXJyYXkucHJvdG90eXBlLnNldEJ1bGsgPSBmdW5jdGlvbiAoaSAvKmludCovLCBuZXdCaXRzIC8qaW50Ki8pIHtcclxuICAgICAgICB0aGlzLmJpdHNbTWF0aC5mbG9vcihpIC8gMzIpXSA9IG5ld0JpdHM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgcmFuZ2Ugb2YgYml0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhcnQgc3RhcnQgb2YgcmFuZ2UsIGluY2x1c2l2ZS5cclxuICAgICAqIEBwYXJhbSBlbmQgZW5kIG9mIHJhbmdlLCBleGNsdXNpdmVcclxuICAgICAqL1xyXG4gICAgQml0QXJyYXkucHJvdG90eXBlLnNldFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0IC8qaW50Ki8sIGVuZCAvKmludCovKSB7XHJcbiAgICAgICAgaWYgKGVuZCA8IHN0YXJ0IHx8IHN0YXJ0IDwgMCB8fCBlbmQgPiB0aGlzLnNpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZCA9PT0gc3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbmQtLTsgLy8gd2lsbCBiZSBlYXNpZXIgdG8gdHJlYXQgdGhpcyBhcyB0aGUgbGFzdCBhY3R1YWxseSBzZXQgYml0IC0tIGluY2x1c2l2ZVxyXG4gICAgICAgIHZhciBmaXJzdEludCA9IE1hdGguZmxvb3Ioc3RhcnQgLyAzMik7XHJcbiAgICAgICAgdmFyIGxhc3RJbnQgPSBNYXRoLmZsb29yKGVuZCAvIDMyKTtcclxuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcclxuICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RJbnQ7IGkgPD0gbGFzdEludDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdEJpdCA9IGkgPiBmaXJzdEludCA/IDAgOiBzdGFydCAmIDB4MUY7XHJcbiAgICAgICAgICAgIHZhciBsYXN0Qml0ID0gaSA8IGxhc3RJbnQgPyAzMSA6IGVuZCAmIDB4MUY7XHJcbiAgICAgICAgICAgIC8vIE9uZXMgZnJvbSBmaXJzdEJpdCB0byBsYXN0Qml0LCBpbmNsdXNpdmVcclxuICAgICAgICAgICAgdmFyIG1hc2sgPSAoMiA8PCBsYXN0Qml0KSAtICgxIDw8IGZpcnN0Qml0KTtcclxuICAgICAgICAgICAgYml0c1tpXSB8PSBtYXNrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbGwgYml0cyAoc2V0cyB0byBmYWxzZSkuXHJcbiAgICAgKi9cclxuICAgIEJpdEFycmF5LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbWF4ID0gdGhpcy5iaXRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGJpdHNbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVmZmljaWVudCBtZXRob2QgdG8gY2hlY2sgaWYgYSByYW5nZSBvZiBiaXRzIGlzIHNldCwgb3Igbm90IHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhcnQgc3RhcnQgb2YgcmFuZ2UsIGluY2x1c2l2ZS5cclxuICAgICAqIEBwYXJhbSBlbmQgZW5kIG9mIHJhbmdlLCBleGNsdXNpdmVcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBpZiB0cnVlLCBjaGVja3MgdGhhdCBiaXRzIGluIHJhbmdlIGFyZSBzZXQsIG90aGVyd2lzZSBjaGVja3MgdGhhdCB0aGV5IGFyZSBub3Qgc2V0XHJcbiAgICAgKiBAcmV0dXJuIHRydWUgaWZmIGFsbCBiaXRzIGFyZSBzZXQgb3Igbm90IHNldCBpbiByYW5nZSwgYWNjb3JkaW5nIHRvIHZhbHVlIGFyZ3VtZW50XHJcbiAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBlbmQgaXMgbGVzcyB0aGFuIHN0YXJ0IG9yIHRoZSByYW5nZSBpcyBub3QgY29udGFpbmVkIGluIHRoZSBhcnJheVxyXG4gICAgICovXHJcbiAgICBCaXRBcnJheS5wcm90b3R5cGUuaXNSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCAvKmludCovLCBlbmQgLyppbnQqLywgdmFsdWUpIHtcclxuICAgICAgICBpZiAoZW5kIDwgc3RhcnQgfHwgc3RhcnQgPCAwIHx8IGVuZCA+IHRoaXMuc2l6ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kID09PSBzdGFydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZW1wdHkgcmFuZ2UgbWF0Y2hlc1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbmQtLTsgLy8gd2lsbCBiZSBlYXNpZXIgdG8gdHJlYXQgdGhpcyBhcyB0aGUgbGFzdCBhY3R1YWxseSBzZXQgYml0IC0tIGluY2x1c2l2ZVxyXG4gICAgICAgIHZhciBmaXJzdEludCA9IE1hdGguZmxvb3Ioc3RhcnQgLyAzMik7XHJcbiAgICAgICAgdmFyIGxhc3RJbnQgPSBNYXRoLmZsb29yKGVuZCAvIDMyKTtcclxuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcclxuICAgICAgICBmb3IgKHZhciBpID0gZmlyc3RJbnQ7IGkgPD0gbGFzdEludDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBmaXJzdEJpdCA9IGkgPiBmaXJzdEludCA/IDAgOiBzdGFydCAmIDB4MUY7XHJcbiAgICAgICAgICAgIHZhciBsYXN0Qml0ID0gaSA8IGxhc3RJbnQgPyAzMSA6IGVuZCAmIDB4MUY7XHJcbiAgICAgICAgICAgIC8vIE9uZXMgZnJvbSBmaXJzdEJpdCB0byBsYXN0Qml0LCBpbmNsdXNpdmVcclxuICAgICAgICAgICAgdmFyIG1hc2sgPSAoMiA8PCBsYXN0Qml0KSAtICgxIDw8IGZpcnN0Qml0KSAmIDB4RkZGRkZGRkY7XHJcbiAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiAmIDB4RkZGRkZGRkYgYWRkZWQgdG8gZGlzY2FyZCBhbnl0aGluZyBhZnRlciAzMiBiaXRzLCBhcyBFUyBoYXMgNTMgYml0c1xyXG4gICAgICAgICAgICAvLyBSZXR1cm4gZmFsc2UgaWYgd2UncmUgbG9va2luZyBmb3IgMXMgYW5kIHRoZSBtYXNrZWQgYml0c1tpXSBpc24ndCBhbGwgMXMgKGlzOiB0aGF0LFxyXG4gICAgICAgICAgICAvLyBlcXVhbHMgdGhlIG1hc2ssIG9yIHdlJ3JlIGxvb2tpbmcgZm9yIDBzIGFuZCB0aGUgbWFza2VkIHBvcnRpb24gaXMgbm90IGFsbCAwc1xyXG4gICAgICAgICAgICBpZiAoKGJpdHNbaV0gJiBtYXNrKSAhPT0gKHZhbHVlID8gbWFzayA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgQml0QXJyYXkucHJvdG90eXBlLmFwcGVuZEJpdCA9IGZ1bmN0aW9uIChiaXQpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuc2l6ZSArIDEpO1xyXG4gICAgICAgIGlmIChiaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5iaXRzW01hdGguZmxvb3IodGhpcy5zaXplIC8gMzIpXSB8PSAxIDw8ICh0aGlzLnNpemUgJiAweDFGKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zaXplKys7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHRoZSBsZWFzdC1zaWduaWZpY2FudCBiaXRzLCBmcm9tIHZhbHVlLCBpbiBvcmRlciBmcm9tIG1vc3Qtc2lnbmlmaWNhbnQgdG9cclxuICAgICAqIGxlYXN0LXNpZ25pZmljYW50LiBGb3IgZXhhbXBsZSwgYXBwZW5kaW5nIDYgYml0cyBmcm9tIDB4MDAwMDAxRSB3aWxsIGFwcGVuZCB0aGUgYml0c1xyXG4gICAgICogMCwgMSwgMSwgMSwgMSwgMCBpbiB0aGF0IG9yZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB2YWx1ZSB7QGNvZGUgaW50fSBjb250YWluaW5nIGJpdHMgdG8gYXBwZW5kXHJcbiAgICAgKiBAcGFyYW0gbnVtQml0cyBiaXRzIGZyb20gdmFsdWUgdG8gYXBwZW5kXHJcbiAgICAgKi9cclxuICAgIEJpdEFycmF5LnByb3RvdHlwZS5hcHBlbmRCaXRzID0gZnVuY3Rpb24gKHZhbHVlIC8qaW50Ki8sIG51bUJpdHMgLyppbnQqLykge1xyXG4gICAgICAgIGlmIChudW1CaXRzIDwgMCB8fCBudW1CaXRzID4gMzIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ051bSBiaXRzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAzMicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KHRoaXMuc2l6ZSArIG51bUJpdHMpO1xyXG4gICAgICAgIHZhciBhcHBlbmRCaXQgPSB0aGlzLmFwcGVuZEJpdDtcclxuICAgICAgICBmb3IgKHZhciBudW1CaXRzTGVmdCA9IG51bUJpdHM7IG51bUJpdHNMZWZ0ID4gMDsgbnVtQml0c0xlZnQtLSkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGVuZEJpdCgoKHZhbHVlID4+IChudW1CaXRzTGVmdCAtIDEpKSAmIDB4MDEpID09PSAxKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQml0QXJyYXkucHJvdG90eXBlLmFwcGVuZEJpdEFycmF5ID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgdmFyIG90aGVyU2l6ZSA9IG90aGVyLnNpemU7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVDYXBhY2l0eSh0aGlzLnNpemUgKyBvdGhlclNpemUpO1xyXG4gICAgICAgIHZhciBhcHBlbmRCaXQgPSB0aGlzLmFwcGVuZEJpdDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQml0KG90aGVyLmdldChpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJpdEFycmF5LnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5zaXplICE9PSBvdGhlci5zaXplKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdTaXplcyBkb25cXCd0IG1hdGNoJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IGJpdHMubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBpbnQgY291bGQgYmUgaW5jb21wbGV0ZSAoaS5lLiBub3QgaGF2ZSAzMiBiaXRzIGluXHJcbiAgICAgICAgICAgIC8vIGl0KSBidXQgdGhlcmUgaXMgbm8gcHJvYmxlbSBzaW5jZSAwIFhPUiAwID09IDAuXHJcbiAgICAgICAgICAgIGJpdHNbaV0gXj0gb3RoZXIuYml0c1tpXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJpdE9mZnNldCBmaXJzdCBiaXQgdG8gc3RhcnQgd3JpdGluZ1xyXG4gICAgICogQHBhcmFtIGFycmF5IGFycmF5IHRvIHdyaXRlIGludG8uIEJ5dGVzIGFyZSB3cml0dGVuIG1vc3Qtc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdC4gVGhpcyBpcyB0aGUgb3Bwb3NpdGVcclxuICAgICAqICBvZiB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24sIHdoaWNoIGlzIGV4cG9zZWQgYnkge0BsaW5rICNnZXRCaXRBcnJheSgpfVxyXG4gICAgICogQHBhcmFtIG9mZnNldCBwb3NpdGlvbiBpbiBhcnJheSB0byBzdGFydCB3cml0aW5nXHJcbiAgICAgKiBAcGFyYW0gbnVtQnl0ZXMgaG93IG1hbnkgYnl0ZXMgdG8gd3JpdGVcclxuICAgICAqL1xyXG4gICAgQml0QXJyYXkucHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiAoYml0T2Zmc2V0IC8qaW50Ki8sIGFycmF5LCBvZmZzZXQgLyppbnQqLywgbnVtQnl0ZXMgLyppbnQqLykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQnl0ZXM7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdGhlQnl0ZSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXQoYml0T2Zmc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoZUJ5dGUgfD0gMSA8PCAoNyAtIGopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYml0T2Zmc2V0Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgaV0gPSAvKihieXRlKSovIHRoZUJ5dGU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB1bmRlcmx5aW5nIGFycmF5IG9mIGludHMuIFRoZSBmaXJzdCBlbGVtZW50IGhvbGRzIHRoZSBmaXJzdCAzMiBiaXRzLCBhbmQgdGhlIGxlYXN0XHJcbiAgICAgKiAgICAgICAgIHNpZ25pZmljYW50IGJpdCBpcyBiaXQgMC5cclxuICAgICAqL1xyXG4gICAgQml0QXJyYXkucHJvdG90eXBlLmdldEJpdEFycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJpdHM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXZlcnNlcyBhbGwgYml0cyBpbiB0aGUgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIEJpdEFycmF5LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBuZXdCaXRzID0gbmV3IEludDMyQXJyYXkodGhpcy5iaXRzLmxlbmd0aCk7XHJcbiAgICAgICAgLy8gcmV2ZXJzZSBhbGwgaW50J3MgZmlyc3RcclxuICAgICAgICB2YXIgbGVuID0gTWF0aC5mbG9vcigodGhpcy5zaXplIC0gMSkgLyAzMik7XHJcbiAgICAgICAgdmFyIG9sZEJpdHNMZW4gPSBsZW4gKyAxO1xyXG4gICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkQml0c0xlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gYml0c1tpXTtcclxuICAgICAgICAgICAgeCA9ICgoeCA+PiAxKSAmIDB4NTU1NTU1NTUpIHwgKCh4ICYgMHg1NTU1NTU1NSkgPDwgMSk7XHJcbiAgICAgICAgICAgIHggPSAoKHggPj4gMikgJiAweDMzMzMzMzMzKSB8ICgoeCAmIDB4MzMzMzMzMzMpIDw8IDIpO1xyXG4gICAgICAgICAgICB4ID0gKCh4ID4+IDQpICYgMHgwZjBmMGYwZikgfCAoKHggJiAweDBmMGYwZjBmKSA8PCA0KTtcclxuICAgICAgICAgICAgeCA9ICgoeCA+PiA4KSAmIDB4MDBmZjAwZmYpIHwgKCh4ICYgMHgwMGZmMDBmZikgPDwgOCk7XHJcbiAgICAgICAgICAgIHggPSAoKHggPj4gMTYpICYgMHgwMDAwZmZmZikgfCAoKHggJiAweDAwMDBmZmZmKSA8PCAxNik7XHJcbiAgICAgICAgICAgIG5ld0JpdHNbbGVuIC0gaV0gPSAvKihpbnQpKi8geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbm93IGNvcnJlY3QgdGhlIGludCdzIGlmIHRoZSBiaXQgc2l6ZSBpc24ndCBhIG11bHRpcGxlIG9mIDMyXHJcbiAgICAgICAgaWYgKHRoaXMuc2l6ZSAhPT0gb2xkQml0c0xlbiAqIDMyKSB7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0T2Zmc2V0ID0gb2xkQml0c0xlbiAqIDMyIC0gdGhpcy5zaXplO1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudEludCA9IG5ld0JpdHNbMF0gPj4+IGxlZnRPZmZzZXQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgb2xkQml0c0xlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEludCA9IG5ld0JpdHNbaV07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SW50IHw9IG5leHRJbnQgPDwgKDMyIC0gbGVmdE9mZnNldCk7XHJcbiAgICAgICAgICAgICAgICBuZXdCaXRzW2kgLSAxXSA9IGN1cnJlbnRJbnQ7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SW50ID0gbmV4dEludCA+Pj4gbGVmdE9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuZXdCaXRzW29sZEJpdHNMZW4gLSAxXSA9IGN1cnJlbnRJbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYml0cyA9IG5ld0JpdHM7XHJcbiAgICB9O1xyXG4gICAgQml0QXJyYXkubWFrZUFycmF5ID0gZnVuY3Rpb24gKHNpemUgLyppbnQqLykge1xyXG4gICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShNYXRoLmZsb29yKChzaXplICsgMzEpIC8gMzIpKTtcclxuICAgIH07XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBCaXRBcnJheS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQml0QXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG90aGVyID0gbztcclxuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSBvdGhlci5zaXplICYmIEFycmF5c18xLmRlZmF1bHQuZXF1YWxzKHRoaXMuYml0cywgb3RoZXIuYml0cyk7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgQml0QXJyYXkucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAzMSAqIHRoaXMuc2l6ZSArIEFycmF5c18xLmRlZmF1bHQuaGFzaENvZGUodGhpcy5iaXRzKTtcclxuICAgIH07XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBCaXRBcnJheS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBzaXplID0gdGhpcy5zaXplOyBpIDwgc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICgoaSAmIDB4MDcpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmdldChpKSA/ICdYJyA6ICcuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBCaXRBcnJheS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaXRBcnJheSh0aGlzLnNpemUsIHRoaXMuYml0cy5zbGljZSgpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQml0QXJyYXk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJpdEFycmF5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRBcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqL1xyXG4vKmltcG9ydCBqYXZhLnV0aWwuQXJyYXlzOyovXHJcbnZhciBCaXRBcnJheV8xID0gcmVxdWlyZShcIi4vQml0QXJyYXlcIik7XHJcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuLi91dGlsL1N5c3RlbVwiKTtcclxudmFyIEFycmF5c18xID0gcmVxdWlyZShcIi4uL3V0aWwvQXJyYXlzXCIpO1xyXG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcclxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIDxwPlJlcHJlc2VudHMgYSAyRCBtYXRyaXggb2YgYml0cy4gSW4gZnVuY3Rpb24gYXJndW1lbnRzIGJlbG93LCBhbmQgdGhyb3VnaG91dCB0aGUgY29tbW9uXHJcbiAqIG1vZHVsZSwgeCBpcyB0aGUgY29sdW1uIHBvc2l0aW9uLCBhbmQgeSBpcyB0aGUgcm93IHBvc2l0aW9uLiBUaGUgb3JkZXJpbmcgaXMgYWx3YXlzIHgsIHkuXHJcbiAqIFRoZSBvcmlnaW4gaXMgYXQgdGhlIHRvcC1sZWZ0LjwvcD5cclxuICpcclxuICogPHA+SW50ZXJuYWxseSB0aGUgYml0cyBhcmUgcmVwcmVzZW50ZWQgaW4gYSAxLUQgYXJyYXkgb2YgMzItYml0IGludHMuIEhvd2V2ZXIsIGVhY2ggcm93IGJlZ2luc1xyXG4gKiB3aXRoIGEgbmV3IGludC4gVGhpcyBpcyBkb25lIGludGVudGlvbmFsbHkgc28gdGhhdCB3ZSBjYW4gY29weSBvdXQgYSByb3cgaW50byBhIEJpdEFycmF5IHZlcnlcclxuICogZWZmaWNpZW50bHkuPC9wPlxyXG4gKlxyXG4gKiA8cD5UaGUgb3JkZXJpbmcgb2YgYml0cyBpcyByb3ctbWFqb3IuIFdpdGhpbiBlYWNoIGludCwgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgYXJlIHVzZWQgZmlyc3QsXHJcbiAqIG1lYW5pbmcgdGhleSByZXByZXNlbnQgbG93ZXIgeCB2YWx1ZXMuIFRoaXMgaXMgY29tcGF0aWJsZSB3aXRoIEJpdEFycmF5J3MgaW1wbGVtZW50YXRpb24uPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxyXG4gKi9cclxudmFyIEJpdE1hdHJpeCAvKmltcGxlbWVudHMgQ2xvbmVhYmxlKi8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gZW1wdHkgc3F1YXJlIHtAbGluayBCaXRNYXRyaXh9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkaW1lbnNpb24gaGVpZ2h0IGFuZCB3aWR0aFxyXG4gICAgICovXHJcbiAgICAvLyBwdWJsaWMgY29uc3RydWN0b3IoZGltZW5zaW9uOiBudW1iZXIgLyppbnQqLykge1xyXG4gICAgLy8gICB0aGlzKGRpbWVuc2lvbiwgZGltZW5zaW9uKVxyXG4gICAgLy8gfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IHtAbGluayBCaXRNYXRyaXh9LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3aWR0aCBiaXQgbWF0cml4IHdpZHRoXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IGJpdCBtYXRyaXggaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3Rvcih3aWR0aDogbnVtYmVyIC8qaW50Ki8sIGhlaWdodDogbnVtYmVyIC8qaW50Ki8pIHtcclxuICAgIC8vICAgaWYgKHdpZHRoIDwgMSB8fCBoZWlnaHQgPCAxKSB7XHJcbiAgICAvLyAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIkJvdGggZGltZW5zaW9ucyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpXHJcbiAgICAvLyAgIH1cclxuICAgIC8vICAgdGhpcy53aWR0aCA9IHdpZHRoXHJcbiAgICAvLyAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0XHJcbiAgICAvLyAgIHRoaXMucm93U2l6ZSA9ICh3aWR0aCArIDMxKSAvIDMyXHJcbiAgICAvLyAgIGJpdHMgPSBuZXcgaW50W3Jvd1NpemUgKiBoZWlnaHRdO1xyXG4gICAgLy8gfVxyXG4gICAgZnVuY3Rpb24gQml0TWF0cml4KHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCByb3dTaXplIC8qaW50Ki8sIGJpdHMpIHtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5yb3dTaXplID0gcm93U2l6ZTtcclxuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGhlaWdodCB8fCBudWxsID09PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIGlmICh3aWR0aCA8IDEgfHwgaGVpZ2h0IDwgMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnQm90aCBkaW1lbnNpb25zIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcm93U2l6ZSB8fCBudWxsID09PSByb3dTaXplKSB7XHJcbiAgICAgICAgICAgIHJvd1NpemUgPSBNYXRoLmZsb29yKCh3aWR0aCArIDMxKSAvIDMyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb3dTaXplID0gcm93U2l6ZTtcclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBiaXRzIHx8IG51bGwgPT09IGJpdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5iaXRzID0gbmV3IEludDMyQXJyYXkodGhpcy5yb3dTaXplICogdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJwcmV0cyBhIDJEIGFycmF5IG9mIGJvb2xlYW5zIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0sIHdoZXJlIFwidHJ1ZVwiIG1lYW5zIGFuIFwib25cIiBiaXQuXHJcbiAgICAgKlxyXG4gICAgICogQGZ1bmN0aW9uIHBhcnNlXHJcbiAgICAgKiBAcGFyYW0gaW1hZ2UgYml0cyBvZiB0aGUgaW1hZ2UsIGFzIGEgcm93LW1ham9yIDJEIGFycmF5LiBFbGVtZW50cyBhcmUgYXJyYXlzIHJlcHJlc2VudGluZyByb3dzXHJcbiAgICAgKiBAcmV0dXJuIHtAbGluayBCaXRNYXRyaXh9IHJlcHJlc2VudGF0aW9uIG9mIGltYWdlXHJcbiAgICAgKi9cclxuICAgIEJpdE1hdHJpeC5wYXJzZUZyb21Cb29sZWFuQXJyYXkgPSBmdW5jdGlvbiAoaW1hZ2UpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UubGVuZ3RoO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IGltYWdlWzBdLmxlbmd0aDtcclxuICAgICAgICB2YXIgYml0cyA9IG5ldyBCaXRNYXRyaXgod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VJID0gaW1hZ2VbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlSVtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpdHMuc2V0KGosIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBmdW5jdGlvbiBwYXJzZVxyXG4gICAgICogQHBhcmFtIHN0cmluZ1JlcHJlc2VudGF0aW9uXHJcbiAgICAgKiBAcGFyYW0gc2V0U3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gdW5zZXRTdHJpbmdcclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4LnBhcnNlRnJvbVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmdSZXByZXNlbnRhdGlvbiwgc2V0U3RyaW5nLCB1bnNldFN0cmluZykge1xyXG4gICAgICAgIGlmIChzdHJpbmdSZXByZXNlbnRhdGlvbiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnc3RyaW5nUmVwcmVzZW50YXRpb24gY2Fubm90IGJlIG51bGwnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJpdHMgPSBuZXcgQXJyYXkoc3RyaW5nUmVwcmVzZW50YXRpb24ubGVuZ3RoKTtcclxuICAgICAgICB2YXIgYml0c1BvcyA9IDA7XHJcbiAgICAgICAgdmFyIHJvd1N0YXJ0UG9zID0gMDtcclxuICAgICAgICB2YXIgcm93TGVuZ3RoID0gLTE7XHJcbiAgICAgICAgdmFyIG5Sb3dzID0gMDtcclxuICAgICAgICB2YXIgcG9zID0gMDtcclxuICAgICAgICB3aGlsZSAocG9zIDwgc3RyaW5nUmVwcmVzZW50YXRpb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChzdHJpbmdSZXByZXNlbnRhdGlvbi5jaGFyQXQocG9zKSA9PT0gJ1xcbicgfHxcclxuICAgICAgICAgICAgICAgIHN0cmluZ1JlcHJlc2VudGF0aW9uLmNoYXJBdChwb3MpID09PSAnXFxyJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJpdHNQb3MgPiByb3dTdGFydFBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3dMZW5ndGggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvd0xlbmd0aCA9IGJpdHNQb3MgLSByb3dTdGFydFBvcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYml0c1BvcyAtIHJvd1N0YXJ0UG9zICE9PSByb3dMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ3JvdyBsZW5ndGhzIGRvIG5vdCBtYXRjaCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByb3dTdGFydFBvcyA9IGJpdHNQb3M7XHJcbiAgICAgICAgICAgICAgICAgICAgblJvd3MrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmluZ1JlcHJlc2VudGF0aW9uLnN1YnN0cmluZyhwb3MsIHBvcyArIHNldFN0cmluZy5sZW5ndGgpID09PSBzZXRTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBvcyArPSBzZXRTdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgYml0c1tiaXRzUG9zXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBiaXRzUG9zKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyaW5nUmVwcmVzZW50YXRpb24uc3Vic3RyaW5nKHBvcywgcG9zICsgdW5zZXRTdHJpbmcubGVuZ3RoKSA9PT0gdW5zZXRTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHBvcyArPSB1bnNldFN0cmluZy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBiaXRzW2JpdHNQb3NdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBiaXRzUG9zKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnaWxsZWdhbCBjaGFyYWN0ZXIgZW5jb3VudGVyZWQ6ICcgKyBzdHJpbmdSZXByZXNlbnRhdGlvbi5zdWJzdHJpbmcocG9zKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbm8gRU9MIGF0IGVuZD9cclxuICAgICAgICBpZiAoYml0c1BvcyA+IHJvd1N0YXJ0UG9zKSB7XHJcbiAgICAgICAgICAgIGlmIChyb3dMZW5ndGggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByb3dMZW5ndGggPSBiaXRzUG9zIC0gcm93U3RhcnRQb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYml0c1BvcyAtIHJvd1N0YXJ0UG9zICE9PSByb3dMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdyb3cgbGVuZ3RocyBkbyBub3QgbWF0Y2gnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuUm93cysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IEJpdE1hdHJpeChyb3dMZW5ndGgsIG5Sb3dzKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpdHNQb3M7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYml0c1tpXSkge1xyXG4gICAgICAgICAgICAgICAgbWF0cml4LnNldChNYXRoLmZsb29yKGkgJSByb3dMZW5ndGgpLCBNYXRoLmZsb29yKGkgLyByb3dMZW5ndGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogPHA+R2V0cyB0aGUgcmVxdWVzdGVkIGJpdCwgd2hlcmUgdHJ1ZSBtZWFucyBibGFjay48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHggVGhlIGhvcml6b250YWwgY29tcG9uZW50IChpLmUuIHdoaWNoIGNvbHVtbilcclxuICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggcm93KVxyXG4gICAgICogQHJldHVybiB2YWx1ZSBvZiBnaXZlbiBiaXQgaW4gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHggLyppbnQqLywgeSAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHkgKiB0aGlzLnJvd1NpemUgKyBNYXRoLmZsb29yKHggLyAzMik7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5iaXRzW29mZnNldF0gPj4+ICh4ICYgMHgxZikpICYgMSkgIT09IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5TZXRzIHRoZSBnaXZlbiBiaXQgdG8gdHJ1ZS48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHggVGhlIGhvcml6b250YWwgY29tcG9uZW50IChpLmUuIHdoaWNoIGNvbHVtbilcclxuICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggcm93KVxyXG4gICAgICovXHJcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh4IC8qaW50Ki8sIHkgLyppbnQqLykge1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSB5ICogdGhpcy5yb3dTaXplICsgTWF0aC5mbG9vcih4IC8gMzIpO1xyXG4gICAgICAgIHRoaXMuYml0c1tvZmZzZXRdIHw9ICgxIDw8ICh4ICYgMHgxZikpICYgMHhGRkZGRkZGRjtcclxuICAgIH07XHJcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24gKHggLyppbnQqLywgeSAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHkgKiB0aGlzLnJvd1NpemUgKyBNYXRoLmZsb29yKHggLyAzMik7XHJcbiAgICAgICAgdGhpcy5iaXRzW29mZnNldF0gJj0gfigoMSA8PCAoeCAmIDB4MWYpKSAmIDB4RkZGRkZGRkYpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogPHA+RmxpcHMgdGhlIGdpdmVuIGJpdC48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHggVGhlIGhvcml6b250YWwgY29tcG9uZW50IChpLmUuIHdoaWNoIGNvbHVtbilcclxuICAgICAqIEBwYXJhbSB5IFRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgKGkuZS4gd2hpY2ggcm93KVxyXG4gICAgICovXHJcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmZsaXAgPSBmdW5jdGlvbiAoeCAvKmludCovLCB5IC8qaW50Ki8pIHtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0geSAqIHRoaXMucm93U2l6ZSArIE1hdGguZmxvb3IoeCAvIDMyKTtcclxuICAgICAgICB0aGlzLmJpdHNbb2Zmc2V0XSBePSAoKDEgPDwgKHggJiAweDFmKSkgJiAweEZGRkZGRkZGKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEV4Y2x1c2l2ZS1vciAoWE9SKTogRmxpcCB0aGUgYml0IGluIHRoaXMge0Bjb2RlIEJpdE1hdHJpeH0gaWYgdGhlIGNvcnJlc3BvbmRpbmdcclxuICAgICAqIG1hc2sgYml0IGlzIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWFzayBYT1IgbWFza1xyXG4gICAgICovXHJcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChtYXNrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT09IG1hc2suZ2V0V2lkdGgoKSB8fCB0aGlzLmhlaWdodCAhPT0gbWFzay5nZXRIZWlnaHQoKVxyXG4gICAgICAgICAgICB8fCB0aGlzLnJvd1NpemUgIT09IG1hc2suZ2V0Um93U2l6ZSgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdpbnB1dCBtYXRyaXggZGltZW5zaW9ucyBkbyBub3QgbWF0Y2gnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJvd0FycmF5ID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdChNYXRoLmZsb29yKHRoaXMud2lkdGggLyAzMikgKyAxKTtcclxuICAgICAgICB2YXIgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcclxuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcclxuICAgICAgICBmb3IgKHZhciB5ID0gMCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7IHkgPCBoZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0geSAqIHJvd1NpemU7XHJcbiAgICAgICAgICAgIHZhciByb3cgPSBtYXNrLmdldFJvdyh5LCByb3dBcnJheSkuZ2V0Qml0QXJyYXkoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCByb3dTaXplOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGJpdHNbb2Zmc2V0ICsgeF0gXj0gcm93W3hdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGFsbCBiaXRzIChzZXRzIHRvIGZhbHNlKS5cclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcclxuICAgICAgICB2YXIgbWF4ID0gYml0cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICBiaXRzW2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5TZXRzIGEgc3F1YXJlIHJlZ2lvbiBvZiB0aGUgYml0IG1hdHJpeCB0byB0cnVlLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgaG9yaXpvbnRhbCBwb3NpdGlvbiB0byBiZWdpbiBhdCAoaW5jbHVzaXZlKVxyXG4gICAgICogQHBhcmFtIHRvcCBUaGUgdmVydGljYWwgcG9zaXRpb24gdG8gYmVnaW4gYXQgKGluY2x1c2l2ZSlcclxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHJlZ2lvblxyXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSByZWdpb25cclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5zZXRSZWdpb24gPSBmdW5jdGlvbiAobGVmdCAvKmludCovLCB0b3AgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8pIHtcclxuICAgICAgICBpZiAodG9wIDwgMCB8fCBsZWZ0IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnTGVmdCBhbmQgdG9wIG11c3QgYmUgbm9ubmVnYXRpdmUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhlaWdodCA8IDEgfHwgd2lkdGggPCAxKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdIZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgYXQgbGVhc3QgMScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmlnaHQgPSBsZWZ0ICsgd2lkdGg7XHJcbiAgICAgICAgdmFyIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcclxuICAgICAgICBpZiAoYm90dG9tID4gdGhpcy5oZWlnaHQgfHwgcmlnaHQgPiB0aGlzLndpZHRoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdUaGUgcmVnaW9uIG11c3QgZml0IGluc2lkZSB0aGUgbWF0cml4Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByb3dTaXplID0gdGhpcy5yb3dTaXplO1xyXG4gICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzO1xyXG4gICAgICAgIGZvciAodmFyIHkgPSB0b3A7IHkgPCBib3R0b207IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0geSAqIHJvd1NpemU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSBsZWZ0OyB4IDwgcmlnaHQ7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgYml0c1tvZmZzZXQgKyBNYXRoLmZsb29yKHggLyAzMildIHw9ICgoMSA8PCAoeCAmIDB4MWYpKSAmIDB4RkZGRkZGRkYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQSBmYXN0IG1ldGhvZCB0byByZXRyaWV2ZSBvbmUgcm93IG9mIGRhdGEgZnJvbSB0aGUgbWF0cml4IGFzIGEgQml0QXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHkgVGhlIHJvdyB0byByZXRyaWV2ZVxyXG4gICAgICogQHBhcmFtIHJvdyBBbiBvcHRpb25hbCBjYWxsZXItYWxsb2NhdGVkIEJpdEFycmF5LCB3aWxsIGJlIGFsbG9jYXRlZCBpZiBudWxsIG9yIHRvbyBzbWFsbFxyXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIEJpdEFycmF5IC0gdGhpcyByZWZlcmVuY2Ugc2hvdWxkIGFsd2F5cyBiZSB1c2VkIGV2ZW4gd2hlbiBwYXNzaW5nXHJcbiAgICAgKiAgICAgICAgIHlvdXIgb3duIHJvd1xyXG4gICAgICovXHJcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmdldFJvdyA9IGZ1bmN0aW9uICh5IC8qaW50Ki8sIHJvdykge1xyXG4gICAgICAgIGlmIChyb3cgPT09IG51bGwgfHwgcm93ID09PSB1bmRlZmluZWQgfHwgcm93LmdldFNpemUoKSA8IHRoaXMud2lkdGgpIHtcclxuICAgICAgICAgICAgcm93ID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdCh0aGlzLndpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJvdy5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcclxuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcclxuICAgICAgICB2YXIgb2Zmc2V0ID0geSAqIHJvd1NpemU7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCByb3dTaXplOyB4KyspIHtcclxuICAgICAgICAgICAgcm93LnNldEJ1bGsoeCAqIDMyLCBiaXRzW29mZnNldCArIHhdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJvdztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB5IHJvdyB0byBzZXRcclxuICAgICAqIEBwYXJhbSByb3cge0BsaW5rIEJpdEFycmF5fSB0byBjb3B5IGZyb21cclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5zZXRSb3cgPSBmdW5jdGlvbiAoeSAvKmludCovLCByb3cpIHtcclxuICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShyb3cuZ2V0Qml0QXJyYXkoKSwgMCwgdGhpcy5iaXRzLCB5ICogdGhpcy5yb3dTaXplLCB0aGlzLnJvd1NpemUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTW9kaWZpZXMgdGhpcyB7QGNvZGUgQml0TWF0cml4fSB0byByZXByZXNlbnQgdGhlIHNhbWUgYnV0IHJvdGF0ZWQgMTgwIGRlZ3JlZXNcclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5yb3RhdGUxODAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xyXG4gICAgICAgIHZhciB0b3BSb3cgPSBuZXcgQml0QXJyYXlfMS5kZWZhdWx0KHdpZHRoKTtcclxuICAgICAgICB2YXIgYm90dG9tUm93ID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdCh3aWR0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gTWF0aC5mbG9vcigoaGVpZ2h0ICsgMSkgLyAyKTsgaSA8IGxlbmd0aF8xOyBpKyspIHtcclxuICAgICAgICAgICAgdG9wUm93ID0gdGhpcy5nZXRSb3coaSwgdG9wUm93KTtcclxuICAgICAgICAgICAgYm90dG9tUm93ID0gdGhpcy5nZXRSb3coaGVpZ2h0IC0gMSAtIGksIGJvdHRvbVJvdyk7XHJcbiAgICAgICAgICAgIHRvcFJvdy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIGJvdHRvbVJvdy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Um93KGksIGJvdHRvbVJvdyk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0Um93KGhlaWdodCAtIDEgLSBpLCB0b3BSb3cpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIGRldGVjdGluZyB0aGUgZW5jbG9zaW5nIHJlY3RhbmdsZSBvZiBhICdwdXJlJyBiYXJjb2RlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0Bjb2RlIGxlZnQsdG9wLHdpZHRoLGhlaWdodH0gZW5jbG9zaW5nIHJlY3RhbmdsZSBvZiBhbGwgMSBiaXRzLCBvciBudWxsIGlmIGl0IGlzIGFsbCB3aGl0ZVxyXG4gICAgICovXHJcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmdldEVuY2xvc2luZ1JlY3RhbmdsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICB2YXIgcm93U2l6ZSA9IHRoaXMucm93U2l6ZTtcclxuICAgICAgICB2YXIgYml0cyA9IHRoaXMuYml0cztcclxuICAgICAgICB2YXIgbGVmdCA9IHdpZHRoO1xyXG4gICAgICAgIHZhciB0b3AgPSBoZWlnaHQ7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gLTE7XHJcbiAgICAgICAgdmFyIGJvdHRvbSA9IC0xO1xyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeDMyID0gMDsgeDMyIDwgcm93U2l6ZTsgeDMyKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB0aGVCaXRzID0gYml0c1t5ICogcm93U2l6ZSArIHgzMl07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhlQml0cyAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5IDwgdG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID4gYm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdHRvbSA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4MzIgKiAzMiA8IGxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoKHRoZUJpdHMgPDwgKDMxIC0gYml0KSkgJiAweEZGRkZGRkZGKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh4MzIgKiAzMiArIGJpdCkgPCBsZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0geDMyICogMzIgKyBiaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHgzMiAqIDMyICsgMzEgPiByaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0ID0gMzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgodGhlQml0cyA+Pj4gYml0KSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh4MzIgKiAzMiArIGJpdCkgPiByaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSB4MzIgKiAzMiArIGJpdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmlnaHQgPCBsZWZ0IHx8IGJvdHRvbSA8IHRvcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbbGVmdCwgdG9wLCByaWdodCAtIGxlZnQgKyAxLCBib3R0b20gLSB0b3AgKyAxXSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBpbiBkZXRlY3RpbmcgYSBjb3JuZXIgb2YgYSAncHVyZScgYmFyY29kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtAY29kZSB4LHl9IGNvb3JkaW5hdGUgb2YgdG9wLWxlZnQtbW9zdCAxIGJpdCwgb3IgbnVsbCBpZiBpdCBpcyBhbGwgd2hpdGVcclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5nZXRUb3BMZWZ0T25CaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJvd1NpemUgPSB0aGlzLnJvd1NpemU7XHJcbiAgICAgICAgdmFyIGJpdHMgPSB0aGlzLmJpdHM7XHJcbiAgICAgICAgdmFyIGJpdHNPZmZzZXQgPSAwO1xyXG4gICAgICAgIHdoaWxlIChiaXRzT2Zmc2V0IDwgYml0cy5sZW5ndGggJiYgYml0c1tiaXRzT2Zmc2V0XSA9PT0gMCkge1xyXG4gICAgICAgICAgICBiaXRzT2Zmc2V0Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiaXRzT2Zmc2V0ID09PSBiaXRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHkgPSBiaXRzT2Zmc2V0IC8gcm93U2l6ZTtcclxuICAgICAgICB2YXIgeCA9IChiaXRzT2Zmc2V0ICUgcm93U2l6ZSkgKiAzMjtcclxuICAgICAgICB2YXIgdGhlQml0cyA9IGJpdHNbYml0c09mZnNldF07XHJcbiAgICAgICAgdmFyIGJpdCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKCgodGhlQml0cyA8PCAoMzEgLSBiaXQpKSAmIDB4RkZGRkZGRkYpID09PSAwKSB7XHJcbiAgICAgICAgICAgIGJpdCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB4ICs9IGJpdDtcclxuICAgICAgICByZXR1cm4gSW50MzJBcnJheS5mcm9tKFt4LCB5XSk7XHJcbiAgICB9O1xyXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5nZXRCb3R0b21SaWdodE9uQml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByb3dTaXplID0gdGhpcy5yb3dTaXplO1xyXG4gICAgICAgIHZhciBiaXRzID0gdGhpcy5iaXRzO1xyXG4gICAgICAgIHZhciBiaXRzT2Zmc2V0ID0gYml0cy5sZW5ndGggLSAxO1xyXG4gICAgICAgIHdoaWxlIChiaXRzT2Zmc2V0ID49IDAgJiYgYml0c1tiaXRzT2Zmc2V0XSA9PT0gMCkge1xyXG4gICAgICAgICAgICBiaXRzT2Zmc2V0LS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiaXRzT2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKGJpdHNPZmZzZXQgLyByb3dTaXplKTtcclxuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IoYml0c09mZnNldCAlIHJvd1NpemUpICogMzI7XHJcbiAgICAgICAgdmFyIHRoZUJpdHMgPSBiaXRzW2JpdHNPZmZzZXRdO1xyXG4gICAgICAgIHZhciBiaXQgPSAzMTtcclxuICAgICAgICB3aGlsZSAoKHRoZUJpdHMgPj4+IGJpdCkgPT09IDApIHtcclxuICAgICAgICAgICAgYml0LS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHggKz0gYml0O1xyXG4gICAgICAgIHJldHVybiBJbnQzMkFycmF5LmZyb20oW3gsIHldKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gVGhlIHdpZHRoIG9mIHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gVGhlIGhlaWdodCBvZiB0aGUgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIEJpdE1hdHJpeC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gVGhlIHJvdyBzaXplIG9mIHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5nZXRSb3dTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvd1NpemU7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgQml0TWF0cml4LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBCaXRNYXRyaXgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG90aGVyID0gbztcclxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gb3RoZXIud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IG90aGVyLmhlaWdodCAmJiB0aGlzLnJvd1NpemUgPT09IG90aGVyLnJvd1NpemUgJiZcclxuICAgICAgICAgICAgQXJyYXlzXzEuZGVmYXVsdC5lcXVhbHModGhpcy5iaXRzLCBvdGhlci5iaXRzKTtcclxuICAgIH07XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoYXNoID0gdGhpcy53aWR0aDtcclxuICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgdGhpcy53aWR0aDtcclxuICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgaGFzaCA9IDMxICogaGFzaCArIHRoaXMucm93U2l6ZTtcclxuICAgICAgICBoYXNoID0gMzEgKiBoYXNoICsgQXJyYXlzXzEuZGVmYXVsdC5oYXNoQ29kZSh0aGlzLmJpdHMpO1xyXG4gICAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gdXNpbmcgXCJYXCIgZm9yIHNldCBhbmQgXCIgXCIgZm9yIHVuc2V0IGJpdHNcclxuICAgICAqL1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgLy8gcHVibGljIHRvU3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAvLyAgIHJldHVybiB0b1N0cmluZyhcIjogXCJYLCBcIiAgXCIpXHJcbiAgICAvLyB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBzZXRTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBzZXQgYml0XHJcbiAgICAgKiBAcGFyYW0gdW5zZXRTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gdW5zZXQgYml0XHJcbiAgICAgKiBAcmV0dXJuIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBlbnRpcmUgbWF0cml4IHV0aWxpemluZyBnaXZlbiBzdHJpbmdzXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyB0b1N0cmluZyhzZXRTdHJpbmc6IHN0cmluZyA9IFwiWCBcIiwgdW5zZXRTdHJpbmc6IHN0cmluZyA9IFwiICBcIik6IHN0cmluZyB7XHJcbiAgICAvLyAgIHJldHVybiB0aGlzLmJ1aWxkVG9TdHJpbmcoc2V0U3RyaW5nLCB1bnNldFN0cmluZywgXCJcXG5cIilcclxuICAgIC8vIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHNldFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHNldCBiaXRcclxuICAgICAqIEBwYXJhbSB1bnNldFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiB1bnNldCBiaXRcclxuICAgICAqIEBwYXJhbSBsaW5lU2VwYXJhdG9yIG5ld2xpbmUgY2hhcmFjdGVyIGluIHN0cmluZyByZXByZXNlbnRhdGlvblxyXG4gICAgICogQHJldHVybiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgZW50aXJlIG1hdHJpeCB1dGlsaXppbmcgZ2l2ZW4gc3RyaW5ncyBhbmQgbGluZSBzZXBhcmF0b3JcclxuICAgICAqIEBkZXByZWNhdGVkIGNhbGwge0BsaW5rICN0b1N0cmluZyhTdHJpbmcsU3RyaW5nKX0gb25seSwgd2hpY2ggdXNlcyBcXG4gbGluZSBzZXBhcmF0b3IgYWx3YXlzXHJcbiAgICAgKi9cclxuICAgIC8vIEBEZXByZWNhdGVkXHJcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHNldFN0cmluZywgdW5zZXRTdHJpbmcsIGxpbmVTZXBhcmF0b3IpIHtcclxuICAgICAgICBpZiAoc2V0U3RyaW5nID09PSB2b2lkIDApIHsgc2V0U3RyaW5nID0gJ1ggJzsgfVxyXG4gICAgICAgIGlmICh1bnNldFN0cmluZyA9PT0gdm9pZCAwKSB7IHVuc2V0U3RyaW5nID0gJyAgJzsgfVxyXG4gICAgICAgIGlmIChsaW5lU2VwYXJhdG9yID09PSB2b2lkIDApIHsgbGluZVNlcGFyYXRvciA9ICdcXG4nOyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRUb1N0cmluZyhzZXRTdHJpbmcsIHVuc2V0U3RyaW5nLCBsaW5lU2VwYXJhdG9yKTtcclxuICAgIH07XHJcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmJ1aWxkVG9TdHJpbmcgPSBmdW5jdGlvbiAoc2V0U3RyaW5nLCB1bnNldFN0cmluZywgbGluZVNlcGFyYXRvcikge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAvLyByZXN1bHQuYXBwZW5kKGxpbmVTZXBhcmF0b3IpO1xyXG4gICAgICAgIGZvciAodmFyIHkgPSAwLCBoZWlnaHQgPSB0aGlzLmhlaWdodDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwLCB3aWR0aCA9IHRoaXMud2lkdGg7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMuZ2V0KHgsIHkpID8gc2V0U3RyaW5nIDogdW5zZXRTdHJpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQobGluZVNlcGFyYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBCaXRNYXRyaXgucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQml0TWF0cml4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLnJvd1NpemUsIHRoaXMuYml0cy5zbGljZSgpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQml0TWF0cml4O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCaXRNYXRyaXg7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdE1hdHJpeC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqL1xyXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogPHA+VGhpcyBwcm92aWRlcyBhbiBlYXN5IGFic3RyYWN0aW9uIHRvIHJlYWQgYml0cyBhdCBhIHRpbWUgZnJvbSBhIHNlcXVlbmNlIG9mIGJ5dGVzLCB3aGVyZSB0aGVcclxuICogbnVtYmVyIG9mIGJpdHMgcmVhZCBpcyBub3Qgb2Z0ZW4gYSBtdWx0aXBsZSBvZiA4LjwvcD5cclxuICpcclxuICogPHA+VGhpcyBjbGFzcyBpcyB0aHJlYWQtc2FmZSBidXQgbm90IHJlZW50cmFudCAtLSB1bmxlc3MgdGhlIGNhbGxlciBtb2RpZmllcyB0aGUgYnl0ZXMgYXJyYXlcclxuICogaXQgcGFzc2VkIGluLCBpbiB3aGljaCBjYXNlIGFsbCBiZXRzIGFyZSBvZmYuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIEJpdFNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGJ5dGVzIGJ5dGVzIGZyb20gd2hpY2ggdGhpcyB3aWxsIHJlYWQgYml0cy4gQml0cyB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgZmlyc3QgYnl0ZSBmaXJzdC5cclxuICAgICAqIEJpdHMgYXJlIHJlYWQgd2l0aGluIGEgYnl0ZSBmcm9tIG1vc3Qtc2lnbmlmaWNhbnQgdG8gbGVhc3Qtc2lnbmlmaWNhbnQgYml0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCaXRTb3VyY2UoYnl0ZXMpIHtcclxuICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XHJcbiAgICAgICAgdGhpcy5ieXRlT2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLmJpdE9mZnNldCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gaW5kZXggb2YgbmV4dCBiaXQgaW4gY3VycmVudCBieXRlIHdoaWNoIHdvdWxkIGJlIHJlYWQgYnkgdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgI3JlYWRCaXRzKGludCl9LlxyXG4gICAgICovXHJcbiAgICBCaXRTb3VyY2UucHJvdG90eXBlLmdldEJpdE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iaXRPZmZzZXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIGluZGV4IG9mIG5leHQgYnl0ZSBpbiBpbnB1dCBieXRlIGFycmF5IHdoaWNoIHdvdWxkIGJlIHJlYWQgYnkgdGhlIG5leHQgY2FsbCB0byB7QGxpbmsgI3JlYWRCaXRzKGludCl9LlxyXG4gICAgICovXHJcbiAgICBCaXRTb3VyY2UucHJvdG90eXBlLmdldEJ5dGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBudW1CaXRzIG51bWJlciBvZiBiaXRzIHRvIHJlYWRcclxuICAgICAqIEByZXR1cm4gaW50IHJlcHJlc2VudGluZyB0aGUgYml0cyByZWFkLiBUaGUgYml0cyB3aWxsIGFwcGVhciBhcyB0aGUgbGVhc3Qtc2lnbmlmaWNhbnRcclxuICAgICAqICAgICAgICAgYml0cyBvZiB0aGUgaW50XHJcbiAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiBudW1CaXRzIGlzbid0IGluIFsxLDMyXSBvciBtb3JlIHRoYW4gaXMgYXZhaWxhYmxlXHJcbiAgICAgKi9cclxuICAgIEJpdFNvdXJjZS5wcm90b3R5cGUucmVhZEJpdHMgPSBmdW5jdGlvbiAobnVtQml0cyAvKmludCovKSB7XHJcbiAgICAgICAgaWYgKG51bUJpdHMgPCAxIHx8IG51bUJpdHMgPiAzMiB8fCBudW1CaXRzID4gdGhpcy5hdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnJyArIG51bUJpdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gMDtcclxuICAgICAgICB2YXIgYml0T2Zmc2V0ID0gdGhpcy5iaXRPZmZzZXQ7XHJcbiAgICAgICAgdmFyIGJ5dGVPZmZzZXQgPSB0aGlzLmJ5dGVPZmZzZXQ7XHJcbiAgICAgICAgdmFyIGJ5dGVzID0gdGhpcy5ieXRlcztcclxuICAgICAgICAvLyBGaXJzdCwgcmVhZCByZW1haW5kZXIgZnJvbSBjdXJyZW50IGJ5dGVcclxuICAgICAgICBpZiAoYml0T2Zmc2V0ID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgYml0c0xlZnQgPSA4IC0gYml0T2Zmc2V0O1xyXG4gICAgICAgICAgICB2YXIgdG9SZWFkID0gbnVtQml0cyA8IGJpdHNMZWZ0ID8gbnVtQml0cyA6IGJpdHNMZWZ0O1xyXG4gICAgICAgICAgICB2YXIgYml0c1RvTm90UmVhZCA9IGJpdHNMZWZ0IC0gdG9SZWFkO1xyXG4gICAgICAgICAgICB2YXIgbWFzayA9ICgweEZGID4+ICg4IC0gdG9SZWFkKSkgPDwgYml0c1RvTm90UmVhZDtcclxuICAgICAgICAgICAgcmVzdWx0ID0gKGJ5dGVzW2J5dGVPZmZzZXRdICYgbWFzaykgPj4gYml0c1RvTm90UmVhZDtcclxuICAgICAgICAgICAgbnVtQml0cyAtPSB0b1JlYWQ7XHJcbiAgICAgICAgICAgIGJpdE9mZnNldCArPSB0b1JlYWQ7XHJcbiAgICAgICAgICAgIGlmIChiaXRPZmZzZXQgPT09IDgpIHtcclxuICAgICAgICAgICAgICAgIGJpdE9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICBieXRlT2Zmc2V0Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTmV4dCByZWFkIHdob2xlIGJ5dGVzXHJcbiAgICAgICAgaWYgKG51bUJpdHMgPiAwKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChudW1CaXRzID49IDgpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgOCkgfCAoYnl0ZXNbYnl0ZU9mZnNldF0gJiAweEZGKTtcclxuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQrKztcclxuICAgICAgICAgICAgICAgIG51bUJpdHMgLT0gODtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGaW5hbGx5IHJlYWQgYSBwYXJ0aWFsIGJ5dGVcclxuICAgICAgICAgICAgaWYgKG51bUJpdHMgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYml0c1RvTm90UmVhZCA9IDggLSBudW1CaXRzO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hc2sgPSAoMHhGRiA+PiBiaXRzVG9Ob3RSZWFkKSA8PCBiaXRzVG9Ob3RSZWFkO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCA8PCBudW1CaXRzKSB8ICgoYnl0ZXNbYnl0ZU9mZnNldF0gJiBtYXNrKSA+PiBiaXRzVG9Ob3RSZWFkKTtcclxuICAgICAgICAgICAgICAgIGJpdE9mZnNldCArPSBudW1CaXRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYml0T2Zmc2V0ID0gYml0T2Zmc2V0O1xyXG4gICAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IGJ5dGVPZmZzZXQ7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGJpdHMgdGhhdCBjYW4gYmUgcmVhZCBzdWNjZXNzZnVsbHlcclxuICAgICAqL1xyXG4gICAgQml0U291cmNlLnByb3RvdHlwZS5hdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDggKiAodGhpcy5ieXRlcy5sZW5ndGggLSB0aGlzLmJ5dGVPZmZzZXQpIC0gdGhpcy5iaXRPZmZzZXQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJpdFNvdXJjZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQml0U291cmNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CaXRTb3VyY2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbiB7Ki9cclxudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcclxuLyppbXBvcnQgamF2YS51dGlsLkhhc2hNYXA7Ki9cclxuLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xyXG52YXIgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycztcclxuKGZ1bmN0aW9uIChDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzKSB7XHJcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJDcDQzN1wiXSA9IDBdID0gXCJDcDQzN1wiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xXCJdID0gMV0gPSBcIklTTzg4NTlfMVwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8yXCJdID0gMl0gPSBcIklTTzg4NTlfMlwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8zXCJdID0gM10gPSBcIklTTzg4NTlfM1wiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV80XCJdID0gNF0gPSBcIklTTzg4NTlfNFwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV81XCJdID0gNV0gPSBcIklTTzg4NTlfNVwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV82XCJdID0gNl0gPSBcIklTTzg4NTlfNlwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV83XCJdID0gN10gPSBcIklTTzg4NTlfN1wiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV84XCJdID0gOF0gPSBcIklTTzg4NTlfOFwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV85XCJdID0gOV0gPSBcIklTTzg4NTlfOVwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xMFwiXSA9IDEwXSA9IFwiSVNPODg1OV8xMFwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xMVwiXSA9IDExXSA9IFwiSVNPODg1OV8xMVwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xM1wiXSA9IDEyXSA9IFwiSVNPODg1OV8xM1wiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xNFwiXSA9IDEzXSA9IFwiSVNPODg1OV8xNFwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xNVwiXSA9IDE0XSA9IFwiSVNPODg1OV8xNVwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiSVNPODg1OV8xNlwiXSA9IDE1XSA9IFwiSVNPODg1OV8xNlwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiU0pJU1wiXSA9IDE2XSA9IFwiU0pJU1wiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQ3AxMjUwXCJdID0gMTddID0gXCJDcDEyNTBcIjtcclxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkNwMTI1MVwiXSA9IDE4XSA9IFwiQ3AxMjUxXCI7XHJcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJDcDEyNTJcIl0gPSAxOV0gPSBcIkNwMTI1MlwiO1xyXG4gICAgQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW1wiQ3AxMjU2XCJdID0gMjBdID0gXCJDcDEyNTZcIjtcclxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIlVuaWNvZGVCaWdVbm1hcmtlZFwiXSA9IDIxXSA9IFwiVW5pY29kZUJpZ1VubWFya2VkXCI7XHJcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJVVEY4XCJdID0gMjJdID0gXCJVVEY4XCI7XHJcbiAgICBDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzW0NoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbXCJBU0NJSVwiXSA9IDIzXSA9IFwiQVNDSUlcIjtcclxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkJpZzVcIl0gPSAyNF0gPSBcIkJpZzVcIjtcclxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkdCMTgwMzBcIl0gPSAyNV0gPSBcIkdCMTgwMzBcIjtcclxuICAgIENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnNbQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVyc1tcIkVVQ19LUlwiXSA9IDI2XSA9IFwiRVVDX0tSXCI7XHJcbn0pKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMgPSBleHBvcnRzLkNoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMgfHwgKGV4cG9ydHMuQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbmNhcHN1bGF0ZXMgYSBDaGFyYWN0ZXIgU2V0IEVDSSwgYWNjb3JkaW5nIHRvIFwiRXh0ZW5kZWQgQ2hhbm5lbCBJbnRlcnByZXRhdGlvbnNcIiA1LjMuMS4xXHJcbiAqIG9mIElTTyAxODAwNC5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICovXHJcbnZhciBDaGFyYWN0ZXJTZXRFQ0kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDaGFyYWN0ZXJTZXRFQ0kodmFsdWVJZGVudGlmaWVyLCB2YWx1ZXNQYXJhbSwgbmFtZSkge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIHZhciBvdGhlckVuY29kaW5nTmFtZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBvdGhlckVuY29kaW5nTmFtZXNbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsdWVJZGVudGlmaWVyID0gdmFsdWVJZGVudGlmaWVyO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZXNQYXJhbSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBJbnQzMkFycmF5LmZyb20oW3ZhbHVlc1BhcmFtXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlc1BhcmFtO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm90aGVyRW5jb2RpbmdOYW1lcyA9IG90aGVyRW5jb2RpbmdOYW1lcztcclxuICAgICAgICBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVfSURFTlRJRklFUl9UT19FQ0kuc2V0KHZhbHVlSWRlbnRpZmllciwgdGhpcyk7XHJcbiAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLk5BTUVfVE9fRUNJLnNldChuYW1lLCB0aGlzKTtcclxuICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gdmFsdWVzLmxlbmd0aDsgaSAhPT0gbGVuZ3RoXzE7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcclxuICAgICAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLlZBTFVFU19UT19FQ0kuc2V0KHYsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBvdGhlckVuY29kaW5nTmFtZXNfMSA9IF9fdmFsdWVzKG90aGVyRW5jb2RpbmdOYW1lcyksIG90aGVyRW5jb2RpbmdOYW1lc18xXzEgPSBvdGhlckVuY29kaW5nTmFtZXNfMS5uZXh0KCk7ICFvdGhlckVuY29kaW5nTmFtZXNfMV8xLmRvbmU7IG90aGVyRW5jb2RpbmdOYW1lc18xXzEgPSBvdGhlckVuY29kaW5nTmFtZXNfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdGhlck5hbWUgPSBvdGhlckVuY29kaW5nTmFtZXNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgQ2hhcmFjdGVyU2V0RUNJLk5BTUVfVE9fRUNJLnNldChvdGhlck5hbWUsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJFbmNvZGluZ05hbWVzXzFfMSAmJiAhb3RoZXJFbmNvZGluZ05hbWVzXzFfMS5kb25lICYmIChfYSA9IG90aGVyRW5jb2RpbmdOYW1lc18xLnJldHVybikpIF9hLmNhbGwob3RoZXJFbmNvZGluZ05hbWVzXzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBDaGFyYWN0ZXJTZXRFQ0kodmFsdWU6IG51bWJlciAvKmludCovKSB7XHJcbiAgICAvLyAgIHRoaXMobmV3IEludDMyQXJyYXkge3ZhbHVlfSlcclxuICAgIC8vIH1cclxuICAgIC8vIENoYXJhY3RlclNldEVDSSh2YWx1ZTogbnVtYmVyIC8qaW50Ki8sIFN0cmluZy4uLiBvdGhlckVuY29kaW5nTmFtZXMpIHtcclxuICAgIC8vICAgdGhpcy52YWx1ZXMgPSBuZXcgSW50MzJBcnJheSB7dmFsdWV9XHJcbiAgICAvLyAgIHRoaXMub3RoZXJFbmNvZGluZ05hbWVzID0gb3RoZXJFbmNvZGluZ05hbWVzXHJcbiAgICAvLyB9XHJcbiAgICAvLyBDaGFyYWN0ZXJTZXRFQ0kodmFsdWVzOiBJbnQzMkFycmF5LCBTdHJpbmcuLi4gb3RoZXJFbmNvZGluZ05hbWVzKSB7XHJcbiAgICAvLyAgIHRoaXMudmFsdWVzID0gdmFsdWVzXHJcbiAgICAvLyAgIHRoaXMub3RoZXJFbmNvZGluZ05hbWVzID0gb3RoZXJFbmNvZGluZ05hbWVzXHJcbiAgICAvLyB9XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kucHJvdG90eXBlLmdldFZhbHVlSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUlkZW50aWZpZXI7XHJcbiAgICB9O1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLnByb3RvdHlwZS5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5hbWU7XHJcbiAgICB9O1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXNbMF07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgY2hhcmFjdGVyIHNldCBFQ0kgdmFsdWVcclxuICAgICAqIEByZXR1cm4ge0Bjb2RlIENoYXJhY3RlclNldEVDSX0gcmVwcmVzZW50aW5nIEVDSSBvZiBnaXZlbiB2YWx1ZSwgb3IgbnVsbCBpZiBpdCBpcyBsZWdhbCBidXRcclxuICAgICAqICAgdW5zdXBwb3J0ZWRcclxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIEVDSSB2YWx1ZSBpcyBpbnZhbGlkXHJcbiAgICAgKi9cclxuICAgIENoYXJhY3RlclNldEVDSS5nZXRDaGFyYWN0ZXJTZXRFQ0lCeVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlIC8qaW50Ki8pIHtcclxuICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDkwMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgnaW5jb3JlY3QgdmFsdWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNoYXJhY3RlclNldCA9IENoYXJhY3RlclNldEVDSS5WQUxVRVNfVE9fRUNJLmdldCh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY2hhcmFjdGVyU2V0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCdpbmNvcmVjdCB2YWx1ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hhcmFjdGVyU2V0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG5hbWUgY2hhcmFjdGVyIHNldCBFQ0kgZW5jb2RpbmcgbmFtZVxyXG4gICAgICogQHJldHVybiBDaGFyYWN0ZXJTZXRFQ0kgcmVwcmVzZW50aW5nIEVDSSBmb3IgY2hhcmFjdGVyIGVuY29kaW5nLCBvciBudWxsIGlmIGl0IGlzIGxlZ2FsXHJcbiAgICAgKiAgIGJ1dCB1bnN1cHBvcnRlZFxyXG4gICAgICovXHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgY2hhcmFjdGVyU2V0ID0gQ2hhcmFjdGVyU2V0RUNJLk5BTUVfVE9fRUNJLmdldChuYW1lKTtcclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjaGFyYWN0ZXJTZXQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ2luY29yZWN0IHZhbHVlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJTZXQ7XHJcbiAgICB9O1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBDaGFyYWN0ZXJTZXRFQ0kpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG90aGVyID0gbztcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXROYW1lKCkgPT09IG90aGVyLmdldE5hbWUoKTtcclxuICAgIH07XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVfSURFTlRJRklFUl9UT19FQ0kgPSBuZXcgTWFwKCk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuVkFMVUVTX1RPX0VDSSA9IG5ldyBNYXAoKTtcclxuICAgIENoYXJhY3RlclNldEVDSS5OQU1FX1RPX0VDSSA9IG5ldyBNYXAoKTtcclxuICAgIC8vIEVudW0gbmFtZSBpcyBhIEphdmEgZW5jb2RpbmcgdmFsaWQgZm9yIGphdmEubGFuZyBhbmQgamF2YS5pb1xyXG4gICAgLy8gVFlQRVNDUklQVFBPUlQ6IGNoYW5nZWQgdGhlIG1haW4gbGFiZWwgZm9yIElTTyBhcyB0aGUgVGV4dEVuY29kZXIgZGlkIG5vdCByZWNvZ25pemVkIHRoZW0gaW4gdGhlIGZvcm0gZnJvbSBqYXZhXHJcbiAgICAvLyAoZWcgSVNPODg1OV8xIG11c3QgYmUgSVNPODg1OTEgb3IgSVNPODg1OS0xIG9yIElTTy04ODU5LTEpXHJcbiAgICAvLyBsYXRlciBvbjogd2VsbCwgZXhjZXB0IDE2IHdpY2ggZG9lcyBub3Qgd29yayB3aXRoIElTTzg4NTkxNiBzbyB1c2VkIElTTy04ODU5LTEgZm9ybSBmb3IgZGVmYXVsdFxyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLkNwNDM3ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwNDM3LCBJbnQzMkFycmF5LmZyb20oWzAsIDJdKSwgJ0NwNDM3Jyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLklTTzg4NTlfMSwgSW50MzJBcnJheS5mcm9tKFsxLCAzXSksICdJU08tODg1OS0xJywgJ0lTTzg4NTkxJywgJ0lTTzg4NTlfMScpO1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzIsIDQsICdJU08tODg1OS0yJywgJ0lTTzg4NTkyJywgJ0lTTzg4NTlfMicpO1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfMyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzMsIDUsICdJU08tODg1OS0zJywgJ0lTTzg4NTkzJywgJ0lTTzg4NTlfMycpO1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzQsIDYsICdJU08tODg1OS00JywgJ0lTTzg4NTk0JywgJ0lTTzg4NTlfNCcpO1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzUsIDcsICdJU08tODg1OS01JywgJ0lTTzg4NTk1JywgJ0lTTzg4NTlfNScpO1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzYsIDgsICdJU08tODg1OS02JywgJ0lTTzg4NTk2JywgJ0lTTzg4NTlfNicpO1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfNyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzcsIDksICdJU08tODg1OS03JywgJ0lTTzg4NTk3JywgJ0lTTzg4NTlfNycpO1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLklTTzg4NTlfOCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzgsIDEwLCAnSVNPLTg4NTktOCcsICdJU084ODU5OCcsICdJU084ODU5XzgnKTtcclxuICAgIENoYXJhY3RlclNldEVDSS5JU084ODU5XzkgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuSVNPODg1OV85LCAxMSwgJ0lTTy04ODU5LTknLCAnSVNPODg1OTknLCAnSVNPODg1OV85Jyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xMCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEwLCAxMiwgJ0lTTy04ODU5LTEwJywgJ0lTTzg4NTkxMCcsICdJU084ODU5XzEwJyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xMSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzExLCAxMywgJ0lTTy04ODU5LTExJywgJ0lTTzg4NTkxMScsICdJU084ODU5XzExJyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xMyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzEzLCAxNSwgJ0lTTy04ODU5LTEzJywgJ0lTTzg4NTkxMycsICdJU084ODU5XzEzJyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xNCA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzE0LCAxNiwgJ0lTTy04ODU5LTE0JywgJ0lTTzg4NTkxNCcsICdJU084ODU5XzE0Jyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xNSA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzE1LCAxNywgJ0lTTy04ODU5LTE1JywgJ0lTTzg4NTkxNScsICdJU084ODU5XzE1Jyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuSVNPODg1OV8xNiA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5JU084ODU5XzE2LCAxOCwgJ0lTTy04ODU5LTE2JywgJ0lTTzg4NTkxNicsICdJU084ODU5XzE2Jyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuU0pJUyA9IG5ldyBDaGFyYWN0ZXJTZXRFQ0koQ2hhcmFjdGVyU2V0VmFsdWVJZGVudGlmaWVycy5TSklTLCAyMCwgJ1NKSVMnLCAnU2hpZnRfSklTJyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3AxMjUwID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwMTI1MCwgMjEsICdDcDEyNTAnLCAnd2luZG93cy0xMjUwJyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3AxMjUxID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwMTI1MSwgMjIsICdDcDEyNTEnLCAnd2luZG93cy0xMjUxJyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3AxMjUyID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwMTI1MiwgMjMsICdDcDEyNTInLCAnd2luZG93cy0xMjUyJyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQ3AxMjU2ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkNwMTI1NiwgMjQsICdDcDEyNTYnLCAnd2luZG93cy0xMjU2Jyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuVW5pY29kZUJpZ1VubWFya2VkID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLlVuaWNvZGVCaWdVbm1hcmtlZCwgMjUsICdVbmljb2RlQmlnVW5tYXJrZWQnLCAnVVRGLTE2QkUnLCAnVW5pY29kZUJpZycpO1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLlVURjggPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuVVRGOCwgMjYsICdVVEY4JywgJ1VURi04Jyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuQVNDSUkgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuQVNDSUksIEludDMyQXJyYXkuZnJvbShbMjcsIDE3MF0pLCAnQVNDSUknLCAnVVMtQVNDSUknKTtcclxuICAgIENoYXJhY3RlclNldEVDSS5CaWc1ID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkJpZzUsIDI4LCAnQmlnNScpO1xyXG4gICAgQ2hhcmFjdGVyU2V0RUNJLkdCMTgwMzAgPSBuZXcgQ2hhcmFjdGVyU2V0RUNJKENoYXJhY3RlclNldFZhbHVlSWRlbnRpZmllcnMuR0IxODAzMCwgMjksICdHQjE4MDMwJywgJ0dCMjMxMicsICdFVUNfQ04nLCAnR0JLJyk7XHJcbiAgICBDaGFyYWN0ZXJTZXRFQ0kuRVVDX0tSID0gbmV3IENoYXJhY3RlclNldEVDSShDaGFyYWN0ZXJTZXRWYWx1ZUlkZW50aWZpZXJzLkVVQ19LUiwgMzAsICdFVUNfS1InLCAnRVVDLUtSJyk7XHJcbiAgICByZXR1cm4gQ2hhcmFjdGVyU2V0RUNJO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDaGFyYWN0ZXJTZXRFQ0k7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNoYXJhY3RlclNldEVDSS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqL1xyXG4vKmltcG9ydCBqYXZhLnV0aWwuTGlzdDsqL1xyXG4vKipcclxuICogPHA+RW5jYXBzdWxhdGVzIHRoZSByZXN1bHQgb2YgZGVjb2RpbmcgYSBtYXRyaXggb2YgYml0cy4gVGhpcyB0eXBpY2FsbHlcclxuICogYXBwbGllcyB0byAyRCBiYXJjb2RlIGZvcm1hdHMuIEZvciBub3cgaXQgY29udGFpbnMgdGhlIHJhdyBieXRlcyBvYnRhaW5lZCxcclxuICogYXMgd2VsbCBhcyBhIFN0cmluZyBpbnRlcnByZXRhdGlvbiBvZiB0aG9zZSBieXRlcywgaWYgYXBwbGljYWJsZS48L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqL1xyXG52YXIgRGVjb2RlclJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcihyYXdCeXRlczogVWludDhBcnJheSxcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHN0cmluZyxcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIExpc3Q8VWludDhBcnJheT4gYnl0ZVNlZ21lbnRzLFxyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgU3RyaW5nIGVjTGV2ZWwpIHtcclxuICAgIC8vICAgdGhpcyhyYXdCeXRlcywgdGV4dCwgYnl0ZVNlZ21lbnRzLCBlY0xldmVsLCAtMSwgLTEpXHJcbiAgICAvLyB9XHJcbiAgICBmdW5jdGlvbiBEZWNvZGVyUmVzdWx0KHJhd0J5dGVzLCB0ZXh0LCBieXRlU2VnbWVudHMsIGVjTGV2ZWwsIHN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlciwgc3RydWN0dXJlZEFwcGVuZFBhcml0eSkge1xyXG4gICAgICAgIGlmIChzdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIgPT09IHZvaWQgMCkgeyBzdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIgPSAtMTsgfVxyXG4gICAgICAgIGlmIChzdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5ID09PSB2b2lkIDApIHsgc3RydWN0dXJlZEFwcGVuZFBhcml0eSA9IC0xOyB9XHJcbiAgICAgICAgdGhpcy5yYXdCeXRlcyA9IHJhd0J5dGVzO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICAgICAgdGhpcy5ieXRlU2VnbWVudHMgPSBieXRlU2VnbWVudHM7XHJcbiAgICAgICAgdGhpcy5lY0xldmVsID0gZWNMZXZlbDtcclxuICAgICAgICB0aGlzLnN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlciA9IHN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlcjtcclxuICAgICAgICB0aGlzLnN0cnVjdHVyZWRBcHBlbmRQYXJpdHkgPSBzdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5O1xyXG4gICAgICAgIHRoaXMubnVtQml0cyA9IChyYXdCeXRlcyA9PT0gdW5kZWZpbmVkIHx8IHJhd0J5dGVzID09PSBudWxsKSA/IDAgOiA4ICogcmF3Qnl0ZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHJhdyBieXRlcyByZXByZXNlbnRpbmcgdGhlIHJlc3VsdCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXHJcbiAgICAgKi9cclxuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmdldFJhd0J5dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJhd0J5dGVzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBob3cgbWFueSBiaXRzIG9mIHtAbGluayAjZ2V0UmF3Qnl0ZXMoKX0gYXJlIHZhbGlkOyB0eXBpY2FsbHkgOCB0aW1lcyBpdHMgbGVuZ3RoXHJcbiAgICAgKiBAc2luY2UgMy4zLjBcclxuICAgICAqL1xyXG4gICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuZ2V0TnVtQml0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1CaXRzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG51bUJpdHMgb3ZlcnJpZGVzIHRoZSBudW1iZXIgb2YgYml0cyB0aGF0IGFyZSB2YWxpZCBpbiB7QGxpbmsgI2dldFJhd0J5dGVzKCl9XHJcbiAgICAgKiBAc2luY2UgMy4zLjBcclxuICAgICAqL1xyXG4gICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuc2V0TnVtQml0cyA9IGZ1bmN0aW9uIChudW1CaXRzIC8qaW50Ki8pIHtcclxuICAgICAgICB0aGlzLm51bUJpdHMgPSBudW1CaXRzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB0ZXh0IHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXN1bHRcclxuICAgICAqL1xyXG4gICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuZ2V0VGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBsaXN0IG9mIGJ5dGUgc2VnbWVudHMgaW4gdGhlIHJlc3VsdCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXHJcbiAgICAgKi9cclxuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmdldEJ5dGVTZWdtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ieXRlU2VnbWVudHM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIG5hbWUgb2YgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCB1c2VkLCBvciB7QGNvZGUgbnVsbH0gaWYgbm90IGFwcGxpY2FibGVcclxuICAgICAqL1xyXG4gICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuZ2V0RUNMZXZlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lY0xldmVsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBudW1iZXIgb2YgZXJyb3JzIGNvcnJlY3RlZCwgb3Ige0Bjb2RlIG51bGx9IGlmIG5vdCBhcHBsaWNhYmxlXHJcbiAgICAgKi9cclxuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmdldEVycm9yc0NvcnJlY3RlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnNDb3JyZWN0ZWQ7XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuc2V0RXJyb3JzQ29ycmVjdGVkID0gZnVuY3Rpb24gKGVycm9yc0NvcnJlY3RlZCAvKkludGVnZXIqLykge1xyXG4gICAgICAgIHRoaXMuZXJyb3JzQ29ycmVjdGVkID0gZXJyb3JzQ29ycmVjdGVkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBudW1iZXIgb2YgZXJhc3VyZXMgY29ycmVjdGVkLCBvciB7QGNvZGUgbnVsbH0gaWYgbm90IGFwcGxpY2FibGVcclxuICAgICAqL1xyXG4gICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuZ2V0RXJhc3VyZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJhc3VyZXM7XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuc2V0RXJhc3VyZXMgPSBmdW5jdGlvbiAoZXJhc3VyZXMgLypJbnRlZ2VyKi8pIHtcclxuICAgICAgICB0aGlzLmVyYXN1cmVzID0gZXJhc3VyZXM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIGFyYml0cmFyeSBhZGRpdGlvbmFsIG1ldGFkYXRhXHJcbiAgICAgKi9cclxuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmdldE90aGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm90aGVyO1xyXG4gICAgfTtcclxuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLnNldE90aGVyID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgfTtcclxuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmhhc1N0cnVjdHVyZWRBcHBlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RydWN0dXJlZEFwcGVuZFBhcml0eSA+PSAwICYmIHRoaXMuc3RydWN0dXJlZEFwcGVuZFNlcXVlbmNlTnVtYmVyID49IDA7XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlclJlc3VsdC5wcm90b3R5cGUuZ2V0U3RydWN0dXJlZEFwcGVuZFBhcml0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5O1xyXG4gICAgfTtcclxuICAgIERlY29kZXJSZXN1bHQucHJvdG90eXBlLmdldFN0cnVjdHVyZWRBcHBlbmRTZXF1ZW5jZU51bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERlY29kZXJSZXN1bHQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERlY29kZXJSZXN1bHQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlY29kZXJSZXN1bHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXHJcbnZhciBHcmlkU2FtcGxlcl8xID0gcmVxdWlyZShcIi4vR3JpZFNhbXBsZXJcIik7XHJcbnZhciBCaXRNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL0JpdE1hdHJpeFwiKTtcclxudmFyIFBlcnNwZWN0aXZlVHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi9QZXJzcGVjdGl2ZVRyYW5zZm9ybVwiKTtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIERlZmF1bHRHcmlkU2FtcGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZWZhdWx0R3JpZFNhbXBsZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEZWZhdWx0R3JpZFNhbXBsZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgRGVmYXVsdEdyaWRTYW1wbGVyLnByb3RvdHlwZS5zYW1wbGVHcmlkID0gZnVuY3Rpb24gKGltYWdlLCBkaW1lbnNpb25YIC8qaW50Ki8sIGRpbWVuc2lvblkgLyppbnQqLywgcDFUb1ggLypmbG9hdCovLCBwMVRvWSAvKmZsb2F0Ki8sIHAyVG9YIC8qZmxvYXQqLywgcDJUb1kgLypmbG9hdCovLCBwM1RvWCAvKmZsb2F0Ki8sIHAzVG9ZIC8qZmxvYXQqLywgcDRUb1ggLypmbG9hdCovLCBwNFRvWSAvKmZsb2F0Ki8sIHAxRnJvbVggLypmbG9hdCovLCBwMUZyb21ZIC8qZmxvYXQqLywgcDJGcm9tWCAvKmZsb2F0Ki8sIHAyRnJvbVkgLypmbG9hdCovLCBwM0Zyb21YIC8qZmxvYXQqLywgcDNGcm9tWSAvKmZsb2F0Ki8sIHA0RnJvbVggLypmbG9hdCovLCBwNEZyb21ZIC8qZmxvYXQqLykge1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybV8xLmRlZmF1bHQucXVhZHJpbGF0ZXJhbFRvUXVhZHJpbGF0ZXJhbChwMVRvWCwgcDFUb1ksIHAyVG9YLCBwMlRvWSwgcDNUb1gsIHAzVG9ZLCBwNFRvWCwgcDRUb1ksIHAxRnJvbVgsIHAxRnJvbVksIHAyRnJvbVgsIHAyRnJvbVksIHAzRnJvbVgsIHAzRnJvbVksIHA0RnJvbVgsIHA0RnJvbVkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNhbXBsZUdyaWRXaXRoVHJhbnNmb3JtKGltYWdlLCBkaW1lbnNpb25YLCBkaW1lbnNpb25ZLCB0cmFuc2Zvcm0pO1xyXG4gICAgfTtcclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIERlZmF1bHRHcmlkU2FtcGxlci5wcm90b3R5cGUuc2FtcGxlR3JpZFdpdGhUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoaW1hZ2UsIGRpbWVuc2lvblggLyppbnQqLywgZGltZW5zaW9uWSAvKmludCovLCB0cmFuc2Zvcm0pIHtcclxuICAgICAgICBpZiAoZGltZW5zaW9uWCA8PSAwIHx8IGRpbWVuc2lvblkgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiaXRzID0gbmV3IEJpdE1hdHJpeF8xLmRlZmF1bHQoZGltZW5zaW9uWCwgZGltZW5zaW9uWSk7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoMiAqIGRpbWVuc2lvblgpO1xyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgZGltZW5zaW9uWTsgeSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXggPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaVZhbHVlID0geSArIDAuNTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBtYXg7IHggKz0gMikge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzW3hdID0gKHggLyAyKSArIDAuNTtcclxuICAgICAgICAgICAgICAgIHBvaW50c1t4ICsgMV0gPSBpVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJhbnNmb3JtLnRyYW5zZm9ybVBvaW50cyhwb2ludHMpO1xyXG4gICAgICAgICAgICAvLyBRdWljayBjaGVjayB0byBzZWUgaWYgcG9pbnRzIHRyYW5zZm9ybWVkIHRvIHNvbWV0aGluZyBpbnNpZGUgdGhlIGltYWdlXHJcbiAgICAgICAgICAgIC8vIHN1ZmZpY2llbnQgdG8gY2hlY2sgdGhlIGVuZHBvaW50c1xyXG4gICAgICAgICAgICBHcmlkU2FtcGxlcl8xLmRlZmF1bHQuY2hlY2tBbmROdWRnZVBvaW50cyhpbWFnZSwgcG9pbnRzKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbWF4OyB4ICs9IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KE1hdGguZmxvb3IocG9pbnRzW3hdKSwgTWF0aC5mbG9vcihwb2ludHNbeCArIDFdKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2soLWlzaCkgcGl4ZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYml0cy5zZXQoeCAvIDIsIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoYWlvb2JlIC8qOiBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24qLykge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmZWVscyB3cm9uZywgYnV0LCBzb21ldGltZXMgaWYgdGhlIGZpbmRlciBwYXR0ZXJucyBhcmUgbWlzaWRlbnRpZmllZCwgdGhlIHJlc3VsdGluZ1xyXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGdldHMgXCJ0d2lzdGVkXCIgc3VjaCB0aGF0IGl0IG1hcHMgYSBzdHJhaWdodCBsaW5lIG9mIHBvaW50cyB0byBhIHNldCBvZiBwb2ludHNcclxuICAgICAgICAgICAgICAgIC8vIHdob3NlIGVuZHBvaW50cyBhcmUgaW4gYm91bmRzLCBidXQgb3RoZXJzIGFyZSBub3QuIFRoZXJlIGlzIHByb2JhYmx5IHNvbWUgbWF0aGVtYXRpY2FsXHJcbiAgICAgICAgICAgICAgICAvLyB3YXkgdG8gZGV0ZWN0IHRoaXMgYWJvdXQgdGhlIHRyYW5zZm9ybWF0aW9uIHRoYXQgSSBkb24ndCBrbm93IHlldC5cclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVzdWx0cyBpbiBhbiB1Z2x5IHJ1bnRpbWUgZXhjZXB0aW9uIGRlc3BpdGUgb3VyIGNsZXZlciBjaGVja3MgYWJvdmUgLS0gY2FuJ3QgaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gdGhhdC4gV2UgY291bGQgY2hlY2sgZWFjaCBwb2ludCdzIGNvb3JkaW5hdGVzIGJ1dCB0aGF0IGZlZWxzIGR1cGxpY2F0aXZlLiBXZSBzZXR0bGUgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBjYXRjaGluZyBhbmQgd3JhcHBpbmcgQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uLlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiaXRzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEZWZhdWx0R3JpZFNhbXBsZXI7XHJcbn0oR3JpZFNhbXBsZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERlZmF1bHRHcmlkU2FtcGxlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmYXVsdEdyaWRTYW1wbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIDxwPkVuY2Fwc3VsYXRlcyB0aGUgcmVzdWx0IG9mIGRldGVjdGluZyBhIGJhcmNvZGUgaW4gYW4gaW1hZ2UuIFRoaXMgaW5jbHVkZXMgdGhlIHJhd1xyXG4gKiBtYXRyaXggb2YgYmxhY2svd2hpdGUgcGl4ZWxzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGJhcmNvZGUsIGFuZCBwb3NzaWJseSBwb2ludHMgb2YgaW50ZXJlc3RcclxuICogaW4gdGhlIGltYWdlLCBsaWtlIHRoZSBsb2NhdGlvbiBvZiBmaW5kZXIgcGF0dGVybnMgb3IgY29ybmVycyBvZiB0aGUgYmFyY29kZSBpbiB0aGUgaW1hZ2UuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIERldGVjdG9yUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGV0ZWN0b3JSZXN1bHQoYml0cywgcG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5iaXRzID0gYml0cztcclxuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcclxuICAgIH1cclxuICAgIERldGVjdG9yUmVzdWx0LnByb3RvdHlwZS5nZXRCaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJpdHM7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0b3JSZXN1bHQucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb2ludHM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERldGVjdG9yUmVzdWx0O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEZXRlY3RvclJlc3VsdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGV0ZWN0b3JSZXN1bHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXHJcbnZhciBCaW5hcml6ZXJfMSA9IHJlcXVpcmUoXCIuLi9CaW5hcml6ZXJcIik7XHJcbnZhciBCaXRBcnJheV8xID0gcmVxdWlyZShcIi4vQml0QXJyYXlcIik7XHJcbnZhciBCaXRNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL0JpdE1hdHJpeFwiKTtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBUaGlzIEJpbmFyaXplciBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSBvbGQgWlhpbmcgZ2xvYmFsIGhpc3RvZ3JhbSBhcHByb2FjaC4gSXQgaXMgc3VpdGFibGVcclxuICogZm9yIGxvdy1lbmQgbW9iaWxlIGRldmljZXMgd2hpY2ggZG9uJ3QgaGF2ZSBlbm91Z2ggQ1BVIG9yIG1lbW9yeSB0byB1c2UgYSBsb2NhbCB0aHJlc2hvbGRpbmdcclxuICogYWxnb3JpdGhtLiBIb3dldmVyLCBiZWNhdXNlIGl0IHBpY2tzIGEgZ2xvYmFsIGJsYWNrIHBvaW50LCBpdCBjYW5ub3QgaGFuZGxlIGRpZmZpY3VsdCBzaGFkb3dzXHJcbiAqIGFuZCBncmFkaWVudHMuXHJcbiAqXHJcbiAqIEZhc3RlciBtb2JpbGUgZGV2aWNlcyBhbmQgYWxsIGRlc2t0b3AgYXBwbGljYXRpb25zIHNob3VsZCBwcm9iYWJseSB1c2UgSHlicmlkQmluYXJpemVyIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqL1xyXG52YXIgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcihzb3VyY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzb3VyY2UpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubHVtaW5hbmNlcyA9IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5FTVBUWTtcclxuICAgICAgICBfdGhpcy5idWNrZXRzID0gbmV3IEludDMyQXJyYXkoR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CVUNLRVRTKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBBcHBsaWVzIHNpbXBsZSBzaGFycGVuaW5nIHRvIHRoZSByb3cgZGF0YSB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIG9mIHRoZSAxRCBSZWFkZXJzLlxyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLnByb3RvdHlwZS5nZXRCbGFja1JvdyA9IGZ1bmN0aW9uICh5IC8qaW50Ki8sIHJvdykge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLmdldEx1bWluYW5jZVNvdXJjZSgpO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHNvdXJjZS5nZXRXaWR0aCgpO1xyXG4gICAgICAgIGlmIChyb3cgPT09IHVuZGVmaW5lZCB8fCByb3cgPT09IG51bGwgfHwgcm93LmdldFNpemUoKSA8IHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHJvdyA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQod2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcm93LmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5pdEFycmF5cyh3aWR0aCk7XHJcbiAgICAgICAgdmFyIGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRSb3coeSwgdGhpcy5sdW1pbmFuY2VzKTtcclxuICAgICAgICB2YXIgbG9jYWxCdWNrZXRzID0gdGhpcy5idWNrZXRzO1xyXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICBsb2NhbEJ1Y2tldHNbKGxvY2FsTHVtaW5hbmNlc1t4XSAmIDB4ZmYpID4+IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfU0hJRlRdKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBibGFja1BvaW50ID0gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLmVzdGltYXRlQmxhY2tQb2ludChsb2NhbEJ1Y2tldHMpO1xyXG4gICAgICAgIGlmICh3aWR0aCA8IDMpIHtcclxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciB2ZXJ5IHNtYWxsIGltYWdlc1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGlmICgobG9jYWxMdW1pbmFuY2VzW3hdICYgMHhmZikgPCBibGFja1BvaW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93LnNldCh4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSBsb2NhbEx1bWluYW5jZXNbMF0gJiAweGZmO1xyXG4gICAgICAgICAgICB2YXIgY2VudGVyID0gbG9jYWxMdW1pbmFuY2VzWzFdICYgMHhmZjtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDE7IHggPCB3aWR0aCAtIDE7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gbG9jYWxMdW1pbmFuY2VzW3ggKyAxXSAmIDB4ZmY7XHJcbiAgICAgICAgICAgICAgICAvLyBBIHNpbXBsZSAtMSA0IC0xIGJveCBmaWx0ZXIgd2l0aCBhIHdlaWdodCBvZiAyLlxyXG4gICAgICAgICAgICAgICAgaWYgKCgoY2VudGVyICogNCkgLSBsZWZ0IC0gcmlnaHQpIC8gMiA8IGJsYWNrUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3cuc2V0KHgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGVmdCA9IGNlbnRlcjtcclxuICAgICAgICAgICAgICAgIGNlbnRlciA9IHJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb3c7XHJcbiAgICB9O1xyXG4gICAgLy8gRG9lcyBub3Qgc2hhcnBlbiB0aGUgZGF0YSwgYXMgdGhpcyBjYWxsIGlzIGludGVuZGVkIHRvIG9ubHkgYmUgdXNlZCBieSAyRCBSZWFkZXJzLlxyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLnByb3RvdHlwZS5nZXRCbGFja01hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRMdW1pbmFuY2VTb3VyY2UoKTtcclxuICAgICAgICB2YXIgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gc291cmNlLmdldEhlaWdodCgpO1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgQml0TWF0cml4XzEuZGVmYXVsdCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAvLyBRdWlja2x5IGNhbGN1bGF0ZXMgdGhlIGhpc3RvZ3JhbSBieSBzYW1wbGluZyBmb3VyIHJvd3MgZnJvbSB0aGUgaW1hZ2UuIFRoaXMgcHJvdmVkIHRvIGJlXHJcbiAgICAgICAgLy8gbW9yZSByb2J1c3Qgb24gdGhlIGJsYWNrYm94IHRlc3RzIHRoYW4gc2FtcGxpbmcgYSBkaWFnb25hbCBhcyB3ZSB1c2VkIHRvIGRvLlxyXG4gICAgICAgIHRoaXMuaW5pdEFycmF5cyh3aWR0aCk7XHJcbiAgICAgICAgdmFyIGxvY2FsQnVja2V0cyA9IHRoaXMuYnVja2V0cztcclxuICAgICAgICBmb3IgKHZhciB5ID0gMTsgeSA8IDU7IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgcm93ID0gTWF0aC5mbG9vcigoaGVpZ2h0ICogeSkgLyA1KTtcclxuICAgICAgICAgICAgdmFyIGxvY2FsTHVtaW5hbmNlc18xID0gc291cmNlLmdldFJvdyhyb3csIHRoaXMubHVtaW5hbmNlcyk7XHJcbiAgICAgICAgICAgIHZhciByaWdodCA9IE1hdGguZmxvb3IoKHdpZHRoICogNCkgLyA1KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IE1hdGguZmxvb3Iod2lkdGggLyA1KTsgeCA8IHJpZ2h0OyB4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGxvY2FsTHVtaW5hbmNlc18xW3hdICYgMHhmZjtcclxuICAgICAgICAgICAgICAgIGxvY2FsQnVja2V0c1twaXhlbCA+PiBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUXSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBibGFja1BvaW50ID0gR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLmVzdGltYXRlQmxhY2tQb2ludChsb2NhbEJ1Y2tldHMpO1xyXG4gICAgICAgIC8vIFdlIGRlbGF5IHJlYWRpbmcgdGhlIGVudGlyZSBpbWFnZSBsdW1pbmFuY2UgdW50aWwgdGhlIGJsYWNrIHBvaW50IGVzdGltYXRpb24gc3VjY2VlZHMuXHJcbiAgICAgICAgLy8gQWx0aG91Z2ggd2UgZW5kIHVwIHJlYWRpbmcgZm91ciByb3dzIHR3aWNlLCBpdCBpcyBjb25zaXN0ZW50IHdpdGggb3VyIG1vdHRvIG9mXHJcbiAgICAgICAgLy8gXCJmYWlsIHF1aWNrbHlcIiB3aGljaCBpcyBuZWNlc3NhcnkgZm9yIGNvbnRpbnVvdXMgc2Nhbm5pbmcuXHJcbiAgICAgICAgdmFyIGxvY2FsTHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRNYXRyaXgoKTtcclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB5ICogd2lkdGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gbG9jYWxMdW1pbmFuY2VzW29mZnNldCArIHhdICYgMHhmZjtcclxuICAgICAgICAgICAgICAgIGlmIChwaXhlbCA8IGJsYWNrUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0KHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRyaXg7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLnByb3RvdHlwZS5jcmVhdGVCaW5hcml6ZXIgPSBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIoc291cmNlKTtcclxuICAgIH07XHJcbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIucHJvdG90eXBlLmluaXRBcnJheXMgPSBmdW5jdGlvbiAobHVtaW5hbmNlU2l6ZSAvKmludCovKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubHVtaW5hbmNlcy5sZW5ndGggPCBsdW1pbmFuY2VTaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMubHVtaW5hbmNlcyA9IG5ldyBVaW50OENsYW1wZWRBcnJheShsdW1pbmFuY2VTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1Y2tldHMgPSB0aGlzLmJ1Y2tldHM7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX0JVQ0tFVFM7IHgrKykge1xyXG4gICAgICAgICAgICBidWNrZXRzW3hdID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLmVzdGltYXRlQmxhY2tQb2ludCA9IGZ1bmN0aW9uIChidWNrZXRzKSB7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgdGFsbGVzdCBwZWFrIGluIHRoZSBoaXN0b2dyYW0uXHJcbiAgICAgICAgdmFyIG51bUJ1Y2tldHMgPSBidWNrZXRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgbWF4QnVja2V0Q291bnQgPSAwO1xyXG4gICAgICAgIHZhciBmaXJzdFBlYWsgPSAwO1xyXG4gICAgICAgIHZhciBmaXJzdFBlYWtTaXplID0gMDtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG51bUJ1Y2tldHM7IHgrKykge1xyXG4gICAgICAgICAgICBpZiAoYnVja2V0c1t4XSA+IGZpcnN0UGVha1NpemUpIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0UGVhayA9IHg7XHJcbiAgICAgICAgICAgICAgICBmaXJzdFBlYWtTaXplID0gYnVja2V0c1t4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYnVja2V0c1t4XSA+IG1heEJ1Y2tldENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBtYXhCdWNrZXRDb3VudCA9IGJ1Y2tldHNbeF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRmluZCB0aGUgc2Vjb25kLXRhbGxlc3QgcGVhayB3aGljaCBpcyBzb21ld2hhdCBmYXIgZnJvbSB0aGUgdGFsbGVzdCBwZWFrLlxyXG4gICAgICAgIHZhciBzZWNvbmRQZWFrID0gMDtcclxuICAgICAgICB2YXIgc2Vjb25kUGVha1Njb3JlID0gMDtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG51bUJ1Y2tldHM7IHgrKykge1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2VUb0JpZ2dlc3QgPSB4IC0gZmlyc3RQZWFrO1xyXG4gICAgICAgICAgICAvLyBFbmNvdXJhZ2UgbW9yZSBkaXN0YW50IHNlY29uZCBwZWFrcyBieSBtdWx0aXBseWluZyBieSBzcXVhcmUgb2YgZGlzdGFuY2UuXHJcbiAgICAgICAgICAgIHZhciBzY29yZSA9IGJ1Y2tldHNbeF0gKiBkaXN0YW5jZVRvQmlnZ2VzdCAqIGRpc3RhbmNlVG9CaWdnZXN0O1xyXG4gICAgICAgICAgICBpZiAoc2NvcmUgPiBzZWNvbmRQZWFrU2NvcmUpIHtcclxuICAgICAgICAgICAgICAgIHNlY29uZFBlYWsgPSB4O1xyXG4gICAgICAgICAgICAgICAgc2Vjb25kUGVha1Njb3JlID0gc2NvcmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIGZpcnN0UGVhayBjb3JyZXNwb25kcyB0byB0aGUgYmxhY2sgcGVhay5cclxuICAgICAgICBpZiAoZmlyc3RQZWFrID4gc2Vjb25kUGVhaykge1xyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGZpcnN0UGVhaztcclxuICAgICAgICAgICAgZmlyc3RQZWFrID0gc2Vjb25kUGVhaztcclxuICAgICAgICAgICAgc2Vjb25kUGVhayA9IHRlbXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIHRvbyBsaXR0bGUgY29udHJhc3QgaW4gdGhlIGltYWdlIHRvIHBpY2sgYSBtZWFuaW5nZnVsIGJsYWNrIHBvaW50LCB0aHJvdyByYXRoZXJcclxuICAgICAgICAvLyB0aGFuIHdhc3RlIHRpbWUgdHJ5aW5nIHRvIGRlY29kZSB0aGUgaW1hZ2UsIGFuZCByaXNrIGZhbHNlIHBvc2l0aXZlcy5cclxuICAgICAgICBpZiAoc2Vjb25kUGVhayAtIGZpcnN0UGVhayA8PSBudW1CdWNrZXRzIC8gMTYpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGaW5kIGEgdmFsbGV5IGJldHdlZW4gdGhlbSB0aGF0IGlzIGxvdyBhbmQgY2xvc2VyIHRvIHRoZSB3aGl0ZSBwZWFrLlxyXG4gICAgICAgIHZhciBiZXN0VmFsbGV5ID0gc2Vjb25kUGVhayAtIDE7XHJcbiAgICAgICAgdmFyIGJlc3RWYWxsZXlTY29yZSA9IC0xO1xyXG4gICAgICAgIGZvciAodmFyIHggPSBzZWNvbmRQZWFrIC0gMTsgeCA+IGZpcnN0UGVhazsgeC0tKSB7XHJcbiAgICAgICAgICAgIHZhciBmcm9tRmlyc3QgPSB4IC0gZmlyc3RQZWFrO1xyXG4gICAgICAgICAgICB2YXIgc2NvcmUgPSBmcm9tRmlyc3QgKiBmcm9tRmlyc3QgKiAoc2Vjb25kUGVhayAtIHgpICogKG1heEJ1Y2tldENvdW50IC0gYnVja2V0c1t4XSk7XHJcbiAgICAgICAgICAgIGlmIChzY29yZSA+IGJlc3RWYWxsZXlTY29yZSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdFZhbGxleSA9IHg7XHJcbiAgICAgICAgICAgICAgICBiZXN0VmFsbGV5U2NvcmUgPSBzY29yZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmVzdFZhbGxleSA8PCBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQklUUyA9IDU7XHJcbiAgICBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIuTFVNSU5BTkNFX1NISUZUID0gOCAtIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQklUUztcclxuICAgIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplci5MVU1JTkFOQ0VfQlVDS0VUUyA9IDEgPDwgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkxVTUlOQU5DRV9CSVRTO1xyXG4gICAgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLkVNUFRZID0gVWludDhDbGFtcGVkQXJyYXkuZnJvbShbMF0pO1xyXG4gICAgcmV0dXJuIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcjtcclxufShCaW5hcml6ZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbnMgb2YgdGhpcyBjbGFzcyBjYW4sIGdpdmVuIGxvY2F0aW9ucyBvZiBmaW5kZXIgcGF0dGVybnMgZm9yIGEgUVIgY29kZSBpbiBhblxyXG4gKiBpbWFnZSwgc2FtcGxlIHRoZSByaWdodCBwb2ludHMgaW4gdGhlIGltYWdlIHRvIHJlY29uc3RydWN0IHRoZSBRUiBjb2RlLCBhY2NvdW50aW5nIGZvclxyXG4gKiBwZXJzcGVjdGl2ZSBkaXN0b3J0aW9uLiBJdCBpcyBhYnN0cmFjdGVkIHNpbmNlIGl0IGlzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGFuZCBzaG91bGQgYmUgYWxsb3dlZFxyXG4gKiB0byB0YWtlIGFkdmFudGFnZSBvZiBwbGF0Zm9ybS1zcGVjaWZpYyBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb25zLCBsaWtlIFN1bidzIEphdmEgQWR2YW5jZWRcclxuICogSW1hZ2luZyBsaWJyYXJ5LCBidXQgd2hpY2ggbWF5IG5vdCBiZSBhdmFpbGFibGUgaW4gb3RoZXIgZW52aXJvbm1lbnRzIHN1Y2ggYXMgSjJNRSwgYW5kIHZpY2VcclxuICogdmVyc2EuXHJcbiAqXHJcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VkIGNhbiBiZSBjb250cm9sbGVkIGJ5IGNhbGxpbmcge0BsaW5rICNzZXRHcmlkU2FtcGxlcihHcmlkU2FtcGxlcil9XHJcbiAqIHdpdGggYW4gaW5zdGFuY2Ugb2YgYSBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIHRoaXMgaW50ZXJmYWNlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIEdyaWRTYW1wbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR3JpZFNhbXBsZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIDxwPkNoZWNrcyBhIHNldCBvZiBwb2ludHMgdGhhdCBoYXZlIGJlZW4gdHJhbnNmb3JtZWQgdG8gc2FtcGxlIHBvaW50cyBvbiBhbiBpbWFnZSBhZ2FpbnN0XHJcbiAgICAgKiB0aGUgaW1hZ2UncyBkaW1lbnNpb25zIHRvIHNlZSBpZiB0aGUgcG9pbnQgYXJlIGV2ZW4gd2l0aGluIHRoZSBpbWFnZS48L3A+XHJcbiAgICAgKlxyXG4gICAgICogPHA+VGhpcyBtZXRob2Qgd2lsbCBhY3R1YWxseSBcIm51ZGdlXCIgdGhlIGVuZHBvaW50cyBiYWNrIG9udG8gdGhlIGltYWdlIGlmIHRoZXkgYXJlIGZvdW5kIHRvIGJlXHJcbiAgICAgKiBiYXJlbHkgKGxlc3MgdGhhbiAxIHBpeGVsKSBvZmYgdGhlIGltYWdlLiBUaGlzIGFjY291bnRzIGZvciBpbXBlcmZlY3QgZGV0ZWN0aW9uIG9mIGZpbmRlclxyXG4gICAgICogcGF0dGVybnMgaW4gYW4gaW1hZ2Ugd2hlcmUgdGhlIFFSIENvZGUgcnVucyBhbGwgdGhlIHdheSB0byB0aGUgaW1hZ2UgYm9yZGVyLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiA8cD5Gb3IgZWZmaWNpZW5jeSwgdGhlIG1ldGhvZCB3aWxsIGNoZWNrIHBvaW50cyBmcm9tIGVpdGhlciBlbmQgb2YgdGhlIGxpbmUgdW50aWwgb25lIGlzIGZvdW5kXHJcbiAgICAgKiB0byBiZSB3aXRoaW4gdGhlIGltYWdlLiBCZWNhdXNlIHRoZSBzZXQgb2YgcG9pbnRzIGFyZSBhc3N1bWVkIHRvIGJlIGxpbmVhciwgdGhpcyBpcyB2YWxpZC48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGltYWdlIGltYWdlIGludG8gd2hpY2ggdGhlIHBvaW50cyBzaG91bGQgbWFwXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRzIGFjdHVhbCBwb2ludHMgaW4geDEseTEsLi4uLHhuLHluIGZvcm1cclxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgYW4gZW5kcG9pbnQgaXMgbGllcyBvdXRzaWRlIHRoZSBpbWFnZSBib3VuZGFyaWVzXHJcbiAgICAgKi9cclxuICAgIEdyaWRTYW1wbGVyLmNoZWNrQW5kTnVkZ2VQb2ludHMgPSBmdW5jdGlvbiAoaW1hZ2UsIHBvaW50cykge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpO1xyXG4gICAgICAgIC8vIENoZWNrIGFuZCBudWRnZSBwb2ludHMgZnJvbSBzdGFydCB1bnRpbCB3ZSBzZWUgc29tZSB0aGF0IGFyZSBPSzpcclxuICAgICAgICB2YXIgbnVkZ2VkID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBwb2ludHMubGVuZ3RoICYmIG51ZGdlZDsgb2Zmc2V0ICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXRdKTtcclxuICAgICAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKHBvaW50c1tvZmZzZXQgKyAxXSk7XHJcbiAgICAgICAgICAgIGlmICh4IDwgLTEgfHwgeCA+IHdpZHRoIHx8IHkgPCAtMSB8fCB5ID4gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbnVkZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldF0gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHggPT09IHdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0XSA9IHdpZHRoIC0gMTtcclxuICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHNbb2Zmc2V0ICsgMV0gPSAwLjA7XHJcbiAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHkgPT09IGhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gaGVpZ2h0IC0gMTtcclxuICAgICAgICAgICAgICAgIG51ZGdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgYW5kIG51ZGdlIHBvaW50cyBmcm9tIGVuZDpcclxuICAgICAgICBudWRnZWQgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIG9mZnNldCA9IHBvaW50cy5sZW5ndGggLSAyOyBvZmZzZXQgPj0gMCAmJiBudWRnZWQ7IG9mZnNldCAtPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0XSk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcihwb2ludHNbb2Zmc2V0ICsgMV0pO1xyXG4gICAgICAgICAgICBpZiAoeCA8IC0xIHx8IHggPiB3aWR0aCB8fCB5IDwgLTEgfHwgeSA+IGhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG51ZGdlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoeCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXRdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh4ID09PSB3aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldF0gPSB3aWR0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh5ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzW29mZnNldCArIDFdID0gMC4wO1xyXG4gICAgICAgICAgICAgICAgbnVkZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh5ID09PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50c1tvZmZzZXQgKyAxXSA9IGhlaWdodCAtIDE7XHJcbiAgICAgICAgICAgICAgICBudWRnZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBHcmlkU2FtcGxlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gR3JpZFNhbXBsZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyaWRTYW1wbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBEZWZhdWx0R3JpZFNhbXBsZXJfMSA9IHJlcXVpcmUoXCIuL0RlZmF1bHRHcmlkU2FtcGxlclwiKTtcclxudmFyIEdyaWRTYW1wbGVySW5zdGFuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBHcmlkU2FtcGxlckluc3RhbmNlKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBHcmlkU2FtcGxlciB1c2VkIGJ5IHRoZSBsaWJyYXJ5LiBPbmUgZ2xvYmFsXHJcbiAgICAgKiBpbnN0YW5jZSBpcyBzdG9yZWQsIHdoaWNoIG1heSBzb3VuZCBwcm9ibGVtYXRpYy4gQnV0LCB0aGUgaW1wbGVtZW50YXRpb24gcHJvdmlkZWRcclxuICAgICAqIG91Z2h0IHRvIGJlIGFwcHJvcHJpYXRlIGZvciB0aGUgZW50aXJlIHBsYXRmb3JtLCBhbmQgYWxsIHVzZXMgb2YgdGhpcyBsaWJyYXJ5XHJcbiAgICAgKiBpbiB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlIEpWTS4gRm9yIGluc3RhbmNlLCBhbiBBbmRyb2lkIGFjdGl2aXR5IGNhbiBzd2FwIGluXHJcbiAgICAgKiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IHRha2VzIGFkdmFudGFnZSBvZiBuYXRpdmUgcGxhdGZvcm0gbGlicmFyaWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBuZXdHcmlkU2FtcGxlciBUaGUgcGxhdGZvcm0tc3BlY2lmaWMgb2JqZWN0IHRvIGluc3RhbGwuXHJcbiAgICAgKi9cclxuICAgIEdyaWRTYW1wbGVySW5zdGFuY2Uuc2V0R3JpZFNhbXBsZXIgPSBmdW5jdGlvbiAobmV3R3JpZFNhbXBsZXIpIHtcclxuICAgICAgICBHcmlkU2FtcGxlckluc3RhbmNlLmdyaWRTYW1wbGVyID0gbmV3R3JpZFNhbXBsZXI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIEdyaWRTYW1wbGVyXHJcbiAgICAgKi9cclxuICAgIEdyaWRTYW1wbGVySW5zdGFuY2UuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEdyaWRTYW1wbGVySW5zdGFuY2UuZ3JpZFNhbXBsZXI7XHJcbiAgICB9O1xyXG4gICAgR3JpZFNhbXBsZXJJbnN0YW5jZS5ncmlkU2FtcGxlciA9IG5ldyBEZWZhdWx0R3JpZFNhbXBsZXJfMS5kZWZhdWx0KCk7XHJcbiAgICByZXR1cm4gR3JpZFNhbXBsZXJJbnN0YW5jZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gR3JpZFNhbXBsZXJJbnN0YW5jZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JpZFNhbXBsZXJJbnN0YW5jZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyXzEgPSByZXF1aXJlKFwiLi9HbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXJcIik7XHJcbnZhciBCaXRNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL0JpdE1hdHJpeFwiKTtcclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBhIGxvY2FsIHRocmVzaG9sZGluZyBhbGdvcml0aG0sIHdoaWNoIHdoaWxlIHNsb3dlciB0aGFuIHRoZVxyXG4gKiBHbG9iYWxIaXN0b2dyYW1CaW5hcml6ZXIsIGlzIGZhaXJseSBlZmZpY2llbnQgZm9yIHdoYXQgaXQgZG9lcy4gSXQgaXMgZGVzaWduZWQgZm9yXHJcbiAqIGhpZ2ggZnJlcXVlbmN5IGltYWdlcyBvZiBiYXJjb2RlcyB3aXRoIGJsYWNrIGRhdGEgb24gd2hpdGUgYmFja2dyb3VuZHMuIEZvciB0aGlzIGFwcGxpY2F0aW9uLFxyXG4gKiBpdCBkb2VzIGEgbXVjaCBiZXR0ZXIgam9iIHRoYW4gYSBnbG9iYWwgYmxhY2twb2ludCB3aXRoIHNldmVyZSBzaGFkb3dzIGFuZCBncmFkaWVudHMuXHJcbiAqIEhvd2V2ZXIgaXQgdGVuZHMgdG8gcHJvZHVjZSBhcnRpZmFjdHMgb24gbG93ZXIgZnJlcXVlbmN5IGltYWdlcyBhbmQgaXMgdGhlcmVmb3JlIG5vdFxyXG4gKiBhIGdvb2QgZ2VuZXJhbCBwdXJwb3NlIGJpbmFyaXplciBmb3IgdXNlcyBvdXRzaWRlIFpYaW5nLlxyXG4gKlxyXG4gKiBUaGlzIGNsYXNzIGV4dGVuZHMgR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyLCB1c2luZyB0aGUgb2xkZXIgaGlzdG9ncmFtIGFwcHJvYWNoIGZvciAxRCByZWFkZXJzLFxyXG4gKiBhbmQgdGhlIG5ld2VyIGxvY2FsIGFwcHJvYWNoIGZvciAyRCByZWFkZXJzLiAxRCBkZWNvZGluZyB1c2luZyBhIHBlci1yb3cgaGlzdG9ncmFtIGlzIGFscmVhZHlcclxuICogaW5oZXJlbnRseSBsb2NhbCwgYW5kIG9ubHkgZmFpbHMgZm9yIGhvcml6b250YWwgZ3JhZGllbnRzLiBXZSBjYW4gcmV2aXNpdCB0aGF0IHByb2JsZW0gbGF0ZXIsXHJcbiAqIGJ1dCBmb3Igbm93IGl0IHdhcyBub3QgYSB3aW4gdG8gdXNlIGxvY2FsIGJsb2NrcyBmb3IgMUQuXHJcbiAqXHJcbiAqIFRoaXMgQmluYXJpemVyIGlzIHRoZSBkZWZhdWx0IGZvciB0aGUgdW5pdCB0ZXN0cyBhbmQgdGhlIHJlY29tbWVuZGVkIGNsYXNzIGZvciBsaWJyYXJ5IHVzZXJzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxyXG4gKi9cclxudmFyIEh5YnJpZEJpbmFyaXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhIeWJyaWRCaW5hcml6ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBIeWJyaWRCaW5hcml6ZXIoc291cmNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc291cmNlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm1hdHJpeCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBmaW5hbCBCaXRNYXRyaXggb25jZSBmb3IgYWxsIHJlcXVlc3RzLiBUaGlzIGNvdWxkIGJlIGNhbGxlZCBvbmNlIGZyb20gdGhlXHJcbiAgICAgKiBjb25zdHJ1Y3RvciBpbnN0ZWFkLCBidXQgdGhlcmUgYXJlIHNvbWUgYWR2YW50YWdlcyB0byBkb2luZyBpdCBsYXppbHksIHN1Y2ggYXMgbWFraW5nXHJcbiAgICAgKiBwcm9maWxpbmcgZWFzaWVyLCBhbmQgbm90IGRvaW5nIGhlYXZ5IGxpZnRpbmcgd2hlbiBjYWxsZXJzIGRvbid0IGV4cGVjdCBpdC5cclxuICAgICAqL1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgSHlicmlkQmluYXJpemVyLnByb3RvdHlwZS5nZXRCbGFja01hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5tYXRyaXggIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5nZXRMdW1pbmFuY2VTb3VyY2UoKTtcclxuICAgICAgICB2YXIgd2lkdGggPSBzb3VyY2UuZ2V0V2lkdGgoKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gc291cmNlLmdldEhlaWdodCgpO1xyXG4gICAgICAgIGlmICh3aWR0aCA+PSBIeWJyaWRCaW5hcml6ZXIuTUlOSU1VTV9ESU1FTlNJT04gJiYgaGVpZ2h0ID49IEh5YnJpZEJpbmFyaXplci5NSU5JTVVNX0RJTUVOU0lPTikge1xyXG4gICAgICAgICAgICB2YXIgbHVtaW5hbmNlcyA9IHNvdXJjZS5nZXRNYXRyaXgoKTtcclxuICAgICAgICAgICAgdmFyIHN1YldpZHRoID0gd2lkdGggPj4gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7XHJcbiAgICAgICAgICAgIGlmICgod2lkdGggJiBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9NQVNLKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc3ViV2lkdGgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc3ViSGVpZ2h0ID0gaGVpZ2h0ID4+IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSO1xyXG4gICAgICAgICAgICBpZiAoKGhlaWdodCAmIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX01BU0spICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJIZWlnaHQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYmxhY2tQb2ludHMgPSBIeWJyaWRCaW5hcml6ZXIuY2FsY3VsYXRlQmxhY2tQb2ludHMobHVtaW5hbmNlcywgc3ViV2lkdGgsIHN1YkhlaWdodCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHZhciBuZXdNYXRyaXggPSBuZXcgQml0TWF0cml4XzEuZGVmYXVsdCh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICAgICAgSHlicmlkQmluYXJpemVyLmNhbGN1bGF0ZVRocmVzaG9sZEZvckJsb2NrKGx1bWluYW5jZXMsIHN1YldpZHRoLCBzdWJIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIGJsYWNrUG9pbnRzLCBuZXdNYXRyaXgpO1xyXG4gICAgICAgICAgICB0aGlzLm1hdHJpeCA9IG5ld01hdHJpeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBpcyB0b28gc21hbGwsIGZhbGwgYmFjayB0byB0aGUgZ2xvYmFsIGhpc3RvZ3JhbSBhcHByb2FjaC5cclxuICAgICAgICAgICAgdGhpcy5tYXRyaXggPSBfc3VwZXIucHJvdG90eXBlLmdldEJsYWNrTWF0cml4LmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm1hdHJpeDtcclxuICAgIH07XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBIeWJyaWRCaW5hcml6ZXIucHJvdG90eXBlLmNyZWF0ZUJpbmFyaXplciA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEh5YnJpZEJpbmFyaXplcihzb3VyY2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggYmxvY2sgaW4gdGhlIGltYWdlLCBjYWxjdWxhdGUgdGhlIGF2ZXJhZ2UgYmxhY2sgcG9pbnQgdXNpbmcgYSA1eDUgZ3JpZFxyXG4gICAgICogb2YgdGhlIGJsb2NrcyBhcm91bmQgaXQuIEFsc28gaGFuZGxlcyB0aGUgY29ybmVyIGNhc2VzIChmcmFjdGlvbmFsIGJsb2NrcyBhcmUgY29tcHV0ZWQgYmFzZWRcclxuICAgICAqIG9uIHRoZSBsYXN0IHBpeGVscyBpbiB0aGUgcm93L2NvbHVtbiB3aGljaCBhcmUgYWxzbyB1c2VkIGluIHRoZSBwcmV2aW91cyBibG9jaykuXHJcbiAgICAgKi9cclxuICAgIEh5YnJpZEJpbmFyaXplci5jYWxjdWxhdGVUaHJlc2hvbGRGb3JCbG9jayA9IGZ1bmN0aW9uIChsdW1pbmFuY2VzLCBzdWJXaWR0aCAvKmludCovLCBzdWJIZWlnaHQgLyppbnQqLywgd2lkdGggLyppbnQqLywgaGVpZ2h0IC8qaW50Ki8sIGJsYWNrUG9pbnRzLCBtYXRyaXgpIHtcclxuICAgICAgICB2YXIgbWF4WU9mZnNldCA9IGhlaWdodCAtIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFO1xyXG4gICAgICAgIHZhciBtYXhYT2Zmc2V0ID0gd2lkdGggLSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTtcclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHN1YkhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB5b2Zmc2V0ID0geSA8PCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjtcclxuICAgICAgICAgICAgaWYgKHlvZmZzZXQgPiBtYXhZT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICB5b2Zmc2V0ID0gbWF4WU9mZnNldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdG9wXzEgPSBIeWJyaWRCaW5hcml6ZXIuY2FwKHksIDIsIHN1YkhlaWdodCAtIDMpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHN1YldpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB4b2Zmc2V0ID0geCA8PCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUjtcclxuICAgICAgICAgICAgICAgIGlmICh4b2Zmc2V0ID4gbWF4WE9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhvZmZzZXQgPSBtYXhYT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSBIeWJyaWRCaW5hcml6ZXIuY2FwKHgsIDIsIHN1YldpZHRoIC0gMyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHogPSAtMjsgeiA8PSAyOyB6KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmxhY2tSb3cgPSBibGFja1BvaW50c1t0b3BfMSArIHpdO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBibGFja1Jvd1tsZWZ0IC0gMl0gKyBibGFja1Jvd1tsZWZ0IC0gMV0gKyBibGFja1Jvd1tsZWZ0XSArIGJsYWNrUm93W2xlZnQgKyAxXSArIGJsYWNrUm93W2xlZnQgKyAyXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBhdmVyYWdlID0gc3VtIC8gMjU7XHJcbiAgICAgICAgICAgICAgICBIeWJyaWRCaW5hcml6ZXIudGhyZXNob2xkQmxvY2sobHVtaW5hbmNlcywgeG9mZnNldCwgeW9mZnNldCwgYXZlcmFnZSwgd2lkdGgsIG1hdHJpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSHlicmlkQmluYXJpemVyLmNhcCA9IGZ1bmN0aW9uICh2YWx1ZSAvKmludCovLCBtaW4gLyppbnQqLywgbWF4IC8qaW50Ki8pIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhIHNpbmdsZSB0aHJlc2hvbGQgdG8gYSBibG9jayBvZiBwaXhlbHMuXHJcbiAgICAgKi9cclxuICAgIEh5YnJpZEJpbmFyaXplci50aHJlc2hvbGRCbG9jayA9IGZ1bmN0aW9uIChsdW1pbmFuY2VzLCB4b2Zmc2V0IC8qaW50Ki8sIHlvZmZzZXQgLyppbnQqLywgdGhyZXNob2xkIC8qaW50Ki8sIHN0cmlkZSAvKmludCovLCBtYXRyaXgpIHtcclxuICAgICAgICBmb3IgKHZhciB5ID0gMCwgb2Zmc2V0ID0geW9mZnNldCAqIHN0cmlkZSArIHhvZmZzZXQ7IHkgPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeSsrLCBvZmZzZXQgKz0gc3RyaWRlKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyaXNvbiBuZWVkcyB0byBiZSA8PSBzbyB0aGF0IGJsYWNrID09IDAgcGl4ZWxzIGFyZSBibGFjayBldmVuIGlmIHRoZSB0aHJlc2hvbGQgaXMgMC5cclxuICAgICAgICAgICAgICAgIGlmICgobHVtaW5hbmNlc1tvZmZzZXQgKyB4XSAmIDB4RkYpIDw9IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeC5zZXQoeG9mZnNldCArIHgsIHlvZmZzZXQgKyB5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgYSBzaW5nbGUgYmxhY2sgcG9pbnQgZm9yIGVhY2ggYmxvY2sgb2YgcGl4ZWxzIGFuZCBzYXZlcyBpdCBhd2F5LlxyXG4gICAgICogU2VlIHRoZSBmb2xsb3dpbmcgdGhyZWFkIGZvciBhIGRpc2N1c3Npb24gb2YgdGhpcyBhbGdvcml0aG06XHJcbiAgICAgKiAgaHR0cDovL2dyb3Vwcy5nb29nbGUuY29tL2dyb3VwL3p4aW5nL2Jyb3dzZV90aHJlYWQvdGhyZWFkL2QwNmVmYTJjMzVhN2RkYzBcclxuICAgICAqL1xyXG4gICAgSHlicmlkQmluYXJpemVyLmNhbGN1bGF0ZUJsYWNrUG9pbnRzID0gZnVuY3Rpb24gKGx1bWluYW5jZXMsIHN1YldpZHRoIC8qaW50Ki8sIHN1YkhlaWdodCAvKmludCovLCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLykge1xyXG4gICAgICAgIHZhciBtYXhZT2Zmc2V0ID0gaGVpZ2h0IC0gSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7XHJcbiAgICAgICAgdmFyIG1heFhPZmZzZXQgPSB3aWR0aCAtIEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFO1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp3aGl0ZXNwYWNlXHJcbiAgICAgICAgdmFyIGJsYWNrUG9pbnRzID0gbmV3IEFycmF5KHN1YkhlaWdodCk7IC8vIHN1YldpZHRoXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBzdWJIZWlnaHQ7IHkrKykge1xyXG4gICAgICAgICAgICBibGFja1BvaW50c1t5XSA9IG5ldyBJbnQzMkFycmF5KHN1YldpZHRoKTtcclxuICAgICAgICAgICAgdmFyIHlvZmZzZXQgPSB5IDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSO1xyXG4gICAgICAgICAgICBpZiAoeW9mZnNldCA+IG1heFlPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgIHlvZmZzZXQgPSBtYXhZT2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgc3ViV2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHhvZmZzZXQgPSB4IDw8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFX1BPV0VSO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhvZmZzZXQgPiBtYXhYT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeG9mZnNldCA9IG1heFhPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBtaW4gPSAweEZGO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5eSA9IDAsIG9mZnNldCA9IHlvZmZzZXQgKiB3aWR0aCArIHhvZmZzZXQ7IHl5IDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkU7IHl5KyssIG9mZnNldCArPSB3aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHh4ID0gMDsgeHggPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBsdW1pbmFuY2VzW29mZnNldCArIHh4XSAmIDB4RkY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSBwaXhlbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgbG9va2luZyBmb3IgZ29vZCBjb250cmFzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWwgPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbiA9IHBpeGVsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaXhlbCA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gcGl4ZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBtaW4vbWF4IHRlc3RzIG9uY2UgZHluYW1pYyByYW5nZSBpcyBtZXRcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWF4IC0gbWluID4gSHlicmlkQmluYXJpemVyLk1JTl9EWU5BTUlDX1JBTkdFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmlzaCB0aGUgcmVzdCBvZiB0aGUgcm93cyBxdWlja2x5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoeXkrKywgb2Zmc2V0ICs9IHdpZHRoOyB5eSA8IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFOyB5eSsrLCBvZmZzZXQgKz0gd2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHh4ID0gMDsgeHggPCBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRTsgeHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bSArPSBsdW1pbmFuY2VzW29mZnNldCArIHh4XSAmIDB4RkY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBlc3RpbWF0ZSBpcyB0aGUgYXZlcmFnZSBvZiB0aGUgdmFsdWVzIGluIHRoZSBibG9jay5cclxuICAgICAgICAgICAgICAgIHZhciBhdmVyYWdlID0gc3VtID4+IChIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUiAqIDIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1heCAtIG1pbiA8PSBIeWJyaWRCaW5hcml6ZXIuTUlOX0RZTkFNSUNfUkFOR0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB2YXJpYXRpb24gd2l0aGluIHRoZSBibG9jayBpcyBsb3csIGFzc3VtZSB0aGlzIGlzIGEgYmxvY2sgd2l0aCBvbmx5IGxpZ2h0IG9yIG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAvLyBkYXJrIHBpeGVscy4gSW4gdGhhdCBjYXNlIHdlIGRvIG5vdCB3YW50IHRvIHVzZSB0aGUgYXZlcmFnZSwgYXMgaXQgd291bGQgZGl2aWRlIHRoaXNcclxuICAgICAgICAgICAgICAgICAgICAvLyBsb3cgY29udHJhc3QgYXJlYSBpbnRvIGJsYWNrIGFuZCB3aGl0ZSBwaXhlbHMsIGVzc2VudGlhbGx5IGNyZWF0aW5nIGRhdGEgb3V0IG9mIG5vaXNlLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgYXNzdW1wdGlvbiBpcyB0aGF0IHRoZSBibG9jayBpcyBsaWdodC9iYWNrZ3JvdW5kLiBTaW5jZSBubyBlc3RpbWF0ZSBmb3JcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbGV2ZWwgb2YgZGFyayBwaXhlbHMgZXhpc3RzIGxvY2FsbHksIHVzZSBoYWxmIHRoZSBtaW4gZm9yIHRoZSBibG9jay5cclxuICAgICAgICAgICAgICAgICAgICBhdmVyYWdlID0gbWluIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeSA+IDAgJiYgeCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29ycmVjdCB0aGUgXCJ3aGl0ZSBiYWNrZ3JvdW5kXCIgYXNzdW1wdGlvbiBmb3IgYmxvY2tzIHRoYXQgaGF2ZSBuZWlnaGJvcnMgYnkgY29tcGFyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBwaXhlbHMgaW4gdGhpcyBibG9jayB0byB0aGUgcHJldmlvdXNseSBjYWxjdWxhdGVkIGJsYWNrIHBvaW50cy4gVGhpcyBpcyBiYXNlZCBvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IGRhcmsgYmFyY29kZSBzeW1ib2xvZ3kgaXMgYWx3YXlzIHN1cnJvdW5kZWQgYnkgc29tZSBhbW91bnQgb2YgbGlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFja2dyb3VuZCBmb3Igd2hpY2ggcmVhc29uYWJsZSBibGFjayBwb2ludCBlc3RpbWF0ZXMgd2VyZSBtYWRlLiBUaGUgYnAgZXN0aW1hdGVkIGF0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBib3VuZGFyaWVzIGlzIHVzZWQgZm9yIHRoZSBpbnRlcmlvci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIChtaW4gPCBicCkgaXMgYXJiaXRyYXJ5IGJ1dCB3b3JrcyBiZXR0ZXIgdGhhbiBvdGhlciBoZXVyaXN0aWNzIHRoYXQgd2VyZSB0cmllZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF2ZXJhZ2VOZWlnaGJvckJsYWNrUG9pbnQgPSAoYmxhY2tQb2ludHNbeSAtIDFdW3hdICsgKDIgKiBibGFja1BvaW50c1t5XVt4IC0gMV0pICsgYmxhY2tQb2ludHNbeSAtIDFdW3ggLSAxXSkgLyA0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluIDwgYXZlcmFnZU5laWdoYm9yQmxhY2tQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZlcmFnZSA9IGF2ZXJhZ2VOZWlnaGJvckJsYWNrUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBibGFja1BvaW50c1t5XVt4XSA9IGF2ZXJhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJsYWNrUG9pbnRzO1xyXG4gICAgfTtcclxuICAgIC8vIFRoaXMgY2xhc3MgdXNlcyA1eDUgYmxvY2tzIHRvIGNvbXB1dGUgbG9jYWwgbHVtaW5hbmNlLCB3aGVyZSBlYWNoIGJsb2NrIGlzIDh4OCBwaXhlbHMuXHJcbiAgICAvLyBTbyB0aGlzIGlzIHRoZSBzbWFsbGVzdCBkaW1lbnNpb24gaW4gZWFjaCBheGlzIHdlIGNhbiBhY2NlcHQuXHJcbiAgICBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRV9QT1dFUiA9IDM7XHJcbiAgICBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRSA9IDEgPDwgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfUE9XRVI7IC8vIC4uLjAxMDAuLi4wMFxyXG4gICAgSHlicmlkQmluYXJpemVyLkJMT0NLX1NJWkVfTUFTSyA9IEh5YnJpZEJpbmFyaXplci5CTE9DS19TSVpFIC0gMTsgLy8gLi4uMDAxMS4uLjExXHJcbiAgICBIeWJyaWRCaW5hcml6ZXIuTUlOSU1VTV9ESU1FTlNJT04gPSBIeWJyaWRCaW5hcml6ZXIuQkxPQ0tfU0laRSAqIDU7XHJcbiAgICBIeWJyaWRCaW5hcml6ZXIuTUlOX0RZTkFNSUNfUkFOR0UgPSAyNDtcclxuICAgIHJldHVybiBIeWJyaWRCaW5hcml6ZXI7XHJcbn0oR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBIeWJyaWRCaW5hcml6ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUh5YnJpZEJpbmFyaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uIHsqL1xyXG4vKipcclxuICogPHA+VGhpcyBjbGFzcyBpbXBsZW1lbnRzIGEgcGVyc3BlY3RpdmUgdHJhbnNmb3JtIGluIHR3byBkaW1lbnNpb25zLiBHaXZlbiBmb3VyIHNvdXJjZSBhbmQgZm91clxyXG4gKiBkZXN0aW5hdGlvbiBwb2ludHMsIGl0IHdpbGwgY29tcHV0ZSB0aGUgdHJhbnNmb3JtYXRpb24gaW1wbGllZCBiZXR3ZWVuIHRoZW0uIFRoZSBjb2RlIGlzIGJhc2VkXHJcbiAqIGRpcmVjdGx5IHVwb24gc2VjdGlvbiAzLjQuMiBvZiBHZW9yZ2UgV29sYmVyZydzIFwiRGlnaXRhbCBJbWFnZSBXYXJwaW5nXCI7IHNlZSBwYWdlcyA1NC01Ni48L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqL1xyXG52YXIgUGVyc3BlY3RpdmVUcmFuc2Zvcm0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQZXJzcGVjdGl2ZVRyYW5zZm9ybShhMTEgLypmbG9hdCovLCBhMjEgLypmbG9hdCovLCBhMzEgLypmbG9hdCovLCBhMTIgLypmbG9hdCovLCBhMjIgLypmbG9hdCovLCBhMzIgLypmbG9hdCovLCBhMTMgLypmbG9hdCovLCBhMjMgLypmbG9hdCovLCBhMzMgLypmbG9hdCovKSB7XHJcbiAgICAgICAgdGhpcy5hMTEgPSBhMTE7XHJcbiAgICAgICAgdGhpcy5hMjEgPSBhMjE7XHJcbiAgICAgICAgdGhpcy5hMzEgPSBhMzE7XHJcbiAgICAgICAgdGhpcy5hMTIgPSBhMTI7XHJcbiAgICAgICAgdGhpcy5hMjIgPSBhMjI7XHJcbiAgICAgICAgdGhpcy5hMzIgPSBhMzI7XHJcbiAgICAgICAgdGhpcy5hMTMgPSBhMTM7XHJcbiAgICAgICAgdGhpcy5hMjMgPSBhMjM7XHJcbiAgICAgICAgdGhpcy5hMzMgPSBhMzM7XHJcbiAgICB9XHJcbiAgICBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9RdWFkcmlsYXRlcmFsID0gZnVuY3Rpb24gKHgwIC8qZmxvYXQqLywgeTAgLypmbG9hdCovLCB4MSAvKmZsb2F0Ki8sIHkxIC8qZmxvYXQqLywgeDIgLypmbG9hdCovLCB5MiAvKmZsb2F0Ki8sIHgzIC8qZmxvYXQqLywgeTMgLypmbG9hdCovLCB4MHAgLypmbG9hdCovLCB5MHAgLypmbG9hdCovLCB4MXAgLypmbG9hdCovLCB5MXAgLypmbG9hdCovLCB4MnAgLypmbG9hdCovLCB5MnAgLypmbG9hdCovLCB4M3AgLypmbG9hdCovLCB5M3AgLypmbG9hdCovKSB7XHJcbiAgICAgICAgdmFyIHFUb1MgPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybS5xdWFkcmlsYXRlcmFsVG9TcXVhcmUoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcclxuICAgICAgICB2YXIgc1RvUSA9IFBlcnNwZWN0aXZlVHJhbnNmb3JtLnNxdWFyZVRvUXVhZHJpbGF0ZXJhbCh4MHAsIHkwcCwgeDFwLCB5MXAsIHgycCwgeTJwLCB4M3AsIHkzcCk7XHJcbiAgICAgICAgcmV0dXJuIHNUb1EudGltZXMocVRvUyk7XHJcbiAgICB9O1xyXG4gICAgUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMpIHtcclxuICAgICAgICB2YXIgbWF4ID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgYTExID0gdGhpcy5hMTE7XHJcbiAgICAgICAgdmFyIGExMiA9IHRoaXMuYTEyO1xyXG4gICAgICAgIHZhciBhMTMgPSB0aGlzLmExMztcclxuICAgICAgICB2YXIgYTIxID0gdGhpcy5hMjE7XHJcbiAgICAgICAgdmFyIGEyMiA9IHRoaXMuYTIyO1xyXG4gICAgICAgIHZhciBhMjMgPSB0aGlzLmEyMztcclxuICAgICAgICB2YXIgYTMxID0gdGhpcy5hMzE7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuYTMyO1xyXG4gICAgICAgIHZhciBhMzMgPSB0aGlzLmEzMztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBvaW50c1tpICsgMV07XHJcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IGExMyAqIHggKyBhMjMgKiB5ICsgYTMzO1xyXG4gICAgICAgICAgICBwb2ludHNbaV0gPSAoYTExICogeCArIGEyMSAqIHkgKyBhMzEpIC8gZGVub21pbmF0b3I7XHJcbiAgICAgICAgICAgIHBvaW50c1tpICsgMV0gPSAoYTEyICogeCArIGEyMiAqIHkgKyBhMzIpIC8gZGVub21pbmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBlcnNwZWN0aXZlVHJhbnNmb3JtLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2ludHNXaXRoVmFsdWVzID0gZnVuY3Rpb24gKHhWYWx1ZXMsIHlWYWx1ZXMpIHtcclxuICAgICAgICB2YXIgYTExID0gdGhpcy5hMTE7XHJcbiAgICAgICAgdmFyIGExMiA9IHRoaXMuYTEyO1xyXG4gICAgICAgIHZhciBhMTMgPSB0aGlzLmExMztcclxuICAgICAgICB2YXIgYTIxID0gdGhpcy5hMjE7XHJcbiAgICAgICAgdmFyIGEyMiA9IHRoaXMuYTIyO1xyXG4gICAgICAgIHZhciBhMjMgPSB0aGlzLmEyMztcclxuICAgICAgICB2YXIgYTMxID0gdGhpcy5hMzE7XHJcbiAgICAgICAgdmFyIGEzMiA9IHRoaXMuYTMyO1xyXG4gICAgICAgIHZhciBhMzMgPSB0aGlzLmEzMztcclxuICAgICAgICB2YXIgbiA9IHhWYWx1ZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0geFZhbHVlc1tpXTtcclxuICAgICAgICAgICAgdmFyIHkgPSB5VmFsdWVzW2ldO1xyXG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBhMTMgKiB4ICsgYTIzICogeSArIGEzMztcclxuICAgICAgICAgICAgeFZhbHVlc1tpXSA9IChhMTEgKiB4ICsgYTIxICogeSArIGEzMSkgLyBkZW5vbWluYXRvcjtcclxuICAgICAgICAgICAgeVZhbHVlc1tpXSA9IChhMTIgKiB4ICsgYTIyICogeSArIGEzMikgLyBkZW5vbWluYXRvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUGVyc3BlY3RpdmVUcmFuc2Zvcm0uc3F1YXJlVG9RdWFkcmlsYXRlcmFsID0gZnVuY3Rpb24gKHgwIC8qZmxvYXQqLywgeTAgLypmbG9hdCovLCB4MSAvKmZsb2F0Ki8sIHkxIC8qZmxvYXQqLywgeDIgLypmbG9hdCovLCB5MiAvKmZsb2F0Ki8sIHgzIC8qZmxvYXQqLywgeTMgLypmbG9hdCovKSB7XHJcbiAgICAgICAgdmFyIGR4MyA9IHgwIC0geDEgKyB4MiAtIHgzO1xyXG4gICAgICAgIHZhciBkeTMgPSB5MCAtIHkxICsgeTIgLSB5MztcclxuICAgICAgICBpZiAoZHgzID09PSAwLjAgJiYgZHkzID09PSAwLjApIHtcclxuICAgICAgICAgICAgLy8gQWZmaW5lXHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0oeDEgLSB4MCwgeDIgLSB4MSwgeDAsIHkxIC0geTAsIHkyIC0geTEsIHkwLCAwLjAsIDAuMCwgMS4wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBkeDEgPSB4MSAtIHgyO1xyXG4gICAgICAgICAgICB2YXIgZHgyID0geDMgLSB4MjtcclxuICAgICAgICAgICAgdmFyIGR5MSA9IHkxIC0geTI7XHJcbiAgICAgICAgICAgIHZhciBkeTIgPSB5MyAtIHkyO1xyXG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBkeDEgKiBkeTIgLSBkeDIgKiBkeTE7XHJcbiAgICAgICAgICAgIHZhciBhMTMgPSAoZHgzICogZHkyIC0gZHgyICogZHkzKSAvIGRlbm9taW5hdG9yO1xyXG4gICAgICAgICAgICB2YXIgYTIzID0gKGR4MSAqIGR5MyAtIGR4MyAqIGR5MSkgLyBkZW5vbWluYXRvcjtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQZXJzcGVjdGl2ZVRyYW5zZm9ybSh4MSAtIHgwICsgYTEzICogeDEsIHgzIC0geDAgKyBhMjMgKiB4MywgeDAsIHkxIC0geTAgKyBhMTMgKiB5MSwgeTMgLSB5MCArIGEyMyAqIHkzLCB5MCwgYTEzLCBhMjMsIDEuMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBlcnNwZWN0aXZlVHJhbnNmb3JtLnF1YWRyaWxhdGVyYWxUb1NxdWFyZSA9IGZ1bmN0aW9uICh4MCAvKmZsb2F0Ki8sIHkwIC8qZmxvYXQqLywgeDEgLypmbG9hdCovLCB5MSAvKmZsb2F0Ki8sIHgyIC8qZmxvYXQqLywgeTIgLypmbG9hdCovLCB4MyAvKmZsb2F0Ki8sIHkzIC8qZmxvYXQqLykge1xyXG4gICAgICAgIC8vIEhlcmUsIHRoZSBhZGpvaW50IHNlcnZlcyBhcyB0aGUgaW52ZXJzZTpcclxuICAgICAgICByZXR1cm4gUGVyc3BlY3RpdmVUcmFuc2Zvcm0uc3F1YXJlVG9RdWFkcmlsYXRlcmFsKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykuYnVpbGRBZGpvaW50KCk7XHJcbiAgICB9O1xyXG4gICAgUGVyc3BlY3RpdmVUcmFuc2Zvcm0ucHJvdG90eXBlLmJ1aWxkQWRqb2ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBBZGpvaW50IGlzIHRoZSB0cmFuc3Bvc2Ugb2YgdGhlIGNvZmFjdG9yIG1hdHJpeDpcclxuICAgICAgICByZXR1cm4gbmV3IFBlcnNwZWN0aXZlVHJhbnNmb3JtKHRoaXMuYTIyICogdGhpcy5hMzMgLSB0aGlzLmEyMyAqIHRoaXMuYTMyLCB0aGlzLmEyMyAqIHRoaXMuYTMxIC0gdGhpcy5hMjEgKiB0aGlzLmEzMywgdGhpcy5hMjEgKiB0aGlzLmEzMiAtIHRoaXMuYTIyICogdGhpcy5hMzEsIHRoaXMuYTEzICogdGhpcy5hMzIgLSB0aGlzLmExMiAqIHRoaXMuYTMzLCB0aGlzLmExMSAqIHRoaXMuYTMzIC0gdGhpcy5hMTMgKiB0aGlzLmEzMSwgdGhpcy5hMTIgKiB0aGlzLmEzMSAtIHRoaXMuYTExICogdGhpcy5hMzIsIHRoaXMuYTEyICogdGhpcy5hMjMgLSB0aGlzLmExMyAqIHRoaXMuYTIyLCB0aGlzLmExMyAqIHRoaXMuYTIxIC0gdGhpcy5hMTEgKiB0aGlzLmEyMywgdGhpcy5hMTEgKiB0aGlzLmEyMiAtIHRoaXMuYTEyICogdGhpcy5hMjEpO1xyXG4gICAgfTtcclxuICAgIFBlcnNwZWN0aXZlVHJhbnNmb3JtLnByb3RvdHlwZS50aW1lcyA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgUGVyc3BlY3RpdmVUcmFuc2Zvcm0odGhpcy5hMTEgKiBvdGhlci5hMTEgKyB0aGlzLmEyMSAqIG90aGVyLmExMiArIHRoaXMuYTMxICogb3RoZXIuYTEzLCB0aGlzLmExMSAqIG90aGVyLmEyMSArIHRoaXMuYTIxICogb3RoZXIuYTIyICsgdGhpcy5hMzEgKiBvdGhlci5hMjMsIHRoaXMuYTExICogb3RoZXIuYTMxICsgdGhpcy5hMjEgKiBvdGhlci5hMzIgKyB0aGlzLmEzMSAqIG90aGVyLmEzMywgdGhpcy5hMTIgKiBvdGhlci5hMTEgKyB0aGlzLmEyMiAqIG90aGVyLmExMiArIHRoaXMuYTMyICogb3RoZXIuYTEzLCB0aGlzLmExMiAqIG90aGVyLmEyMSArIHRoaXMuYTIyICogb3RoZXIuYTIyICsgdGhpcy5hMzIgKiBvdGhlci5hMjMsIHRoaXMuYTEyICogb3RoZXIuYTMxICsgdGhpcy5hMjIgKiBvdGhlci5hMzIgKyB0aGlzLmEzMiAqIG90aGVyLmEzMywgdGhpcy5hMTMgKiBvdGhlci5hMTEgKyB0aGlzLmEyMyAqIG90aGVyLmExMiArIHRoaXMuYTMzICogb3RoZXIuYTEzLCB0aGlzLmExMyAqIG90aGVyLmEyMSArIHRoaXMuYTIzICogb3RoZXIuYTIyICsgdGhpcy5hMzMgKiBvdGhlci5hMjMsIHRoaXMuYTEzICogb3RoZXIuYTMxICsgdGhpcy5hMjMgKiBvdGhlci5hMzIgKyB0aGlzLmEzMyAqIG90aGVyLmEzMyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBlcnNwZWN0aXZlVHJhbnNmb3JtO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGVyc3BlY3RpdmVUcmFuc2Zvcm0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAoQykgMjAxMCBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24geyovXHJcbi8qaW1wb3J0IGphdmEubmlvLmNoYXJzZXQuQ2hhcnNldDsqL1xyXG4vKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXHJcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0RlY29kZUhpbnRUeXBlXCIpO1xyXG52YXIgQ2hhcmFjdGVyU2V0RUNJXzEgPSByZXF1aXJlKFwiLi9DaGFyYWN0ZXJTZXRFQ0lcIik7XHJcbnZhciBTdHJpbmdFbmNvZGluZ18xID0gcmVxdWlyZShcIi4uL3V0aWwvU3RyaW5nRW5jb2RpbmdcIik7XHJcbi8qKlxyXG4gKiBDb21tb24gc3RyaW5nLXJlbGF0ZWQgZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKiBAYXV0aG9yIEFsZXggRHVwcmVcclxuICovXHJcbnZhciBTdHJpbmdVdGlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFN0cmluZ1V0aWxzKCkge1xyXG4gICAgfVxyXG4gICAgLy8gU0hJRlRfSklTLmVxdWFsc0lnbm9yZUNhc2UoUExBVEZPUk1fREVGQVVMVF9FTkNPRElORykgfHxcclxuICAgIC8vIEVVQ19KUC5lcXVhbHNJZ25vcmVDYXNlKFBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkcpO1xyXG4gICAgU3RyaW5nVXRpbHMuY2FzdEFzTm9uVXRmOENoYXIgPSBmdW5jdGlvbiAoY29kZSwgZW5jb2RpbmcpIHtcclxuICAgICAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9IG51bGw7IH1cclxuICAgICAgICAvLyBJU08gODg1OS0xIGlzIHRoZSBKYXZhIGRlZmF1bHQgYXMgVVRGLTggaXMgSmF2YVNjcmlwdHNcclxuICAgICAgICAvLyB5b3UgY2FuIHNlZSB0aGlzIG1ldGhvZCBhcyBhIEphdmEgdmVyc2lvbiBvZiBTdHJpbmcuZnJvbUNoYXJDb2RlXHJcbiAgICAgICAgdmFyIGUgPSBlbmNvZGluZyA/IGVuY29kaW5nLmdldE5hbWUoKSA6IHRoaXMuSVNPODg1OTE7XHJcbiAgICAgICAgLy8gdXNlIHBhc3NlZCBmb3JtYXQgKGZyb21DaGFyQ29kZSB3aWxsIHJldHVybiBVVEY4IGVuY29kaW5nKVxyXG4gICAgICAgIHJldHVybiBTdHJpbmdFbmNvZGluZ18xLmRlZmF1bHQuZGVjb2RlKG5ldyBVaW50OEFycmF5KFtjb2RlXSksIGUpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGJ5dGVzIGJ5dGVzIGVuY29kaW5nIGEgc3RyaW5nLCB3aG9zZSBlbmNvZGluZyBzaG91bGQgYmUgZ3Vlc3NlZFxyXG4gICAgICogQHBhcmFtIGhpbnRzIGRlY29kZSBoaW50cyBpZiBhcHBsaWNhYmxlXHJcbiAgICAgKiBAcmV0dXJuIG5hbWUgb2YgZ3Vlc3NlZCBlbmNvZGluZzsgYXQgdGhlIG1vbWVudCB3aWxsIG9ubHkgZ3Vlc3Mgb25lIG9mOlxyXG4gICAgICogIHtAbGluayAjU0hJRlRfSklTfSwge0BsaW5rICNVVEY4fSwge0BsaW5rICNJU084ODU5MX0sIG9yIHRoZSBwbGF0Zm9ybVxyXG4gICAgICogIGRlZmF1bHQgZW5jb2RpbmcgaWYgbm9uZSBvZiB0aGVzZSBjYW4gcG9zc2libHkgYmUgY29ycmVjdFxyXG4gICAgICovXHJcbiAgICBTdHJpbmdVdGlscy5ndWVzc0VuY29kaW5nID0gZnVuY3Rpb24gKGJ5dGVzLCBoaW50cykge1xyXG4gICAgICAgIGlmIChoaW50cyAhPT0gbnVsbCAmJiBoaW50cyAhPT0gdW5kZWZpbmVkICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5DSEFSQUNURVJfU0VUKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5DSEFSQUNURVJfU0VUKS50b1N0cmluZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGb3Igbm93LCBtZXJlbHkgdHJpZXMgdG8gZGlzdGluZ3Vpc2ggSVNPLTg4NTktMSwgVVRGLTggYW5kIFNoaWZ0X0pJUyxcclxuICAgICAgICAvLyB3aGljaCBzaG91bGQgYmUgYnkgZmFyIHRoZSBtb3N0IGNvbW1vbiBlbmNvZGluZ3MuXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgICB2YXIgY2FuQmVJU084ODU5MSA9IHRydWU7XHJcbiAgICAgICAgdmFyIGNhbkJlU2hpZnRKSVMgPSB0cnVlO1xyXG4gICAgICAgIHZhciBjYW5CZVVURjggPSB0cnVlO1xyXG4gICAgICAgIHZhciB1dGY4Qnl0ZXNMZWZ0ID0gMDtcclxuICAgICAgICAvLyBpbnQgdXRmOExvd0NoYXJzID0gMFxyXG4gICAgICAgIHZhciB1dGYyQnl0ZXNDaGFycyA9IDA7XHJcbiAgICAgICAgdmFyIHV0ZjNCeXRlc0NoYXJzID0gMDtcclxuICAgICAgICB2YXIgdXRmNEJ5dGVzQ2hhcnMgPSAwO1xyXG4gICAgICAgIHZhciBzamlzQnl0ZXNMZWZ0ID0gMDtcclxuICAgICAgICAvLyBpbnQgc2ppc0xvd0NoYXJzID0gMFxyXG4gICAgICAgIHZhciBzamlzS2F0YWthbmFDaGFycyA9IDA7XHJcbiAgICAgICAgLy8gaW50IHNqaXNEb3VibGVCeXRlc0NoYXJzID0gMFxyXG4gICAgICAgIHZhciBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcclxuICAgICAgICB2YXIgc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCA9IDA7XHJcbiAgICAgICAgdmFyIHNqaXNNYXhLYXRha2FuYVdvcmRMZW5ndGggPSAwO1xyXG4gICAgICAgIHZhciBzamlzTWF4RG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcclxuICAgICAgICAvLyBpbnQgaXNvTG93Q2hhcnMgPSAwXHJcbiAgICAgICAgLy8gaW50IGlzb0hpZ2hDaGFycyA9IDBcclxuICAgICAgICB2YXIgaXNvSGlnaE90aGVyID0gMDtcclxuICAgICAgICB2YXIgdXRmOGJvbSA9IGJ5dGVzLmxlbmd0aCA+IDMgJiZcclxuICAgICAgICAgICAgYnl0ZXNbMF0gPT09IC8qKGJ5dGUpICovIDB4RUYgJiZcclxuICAgICAgICAgICAgYnl0ZXNbMV0gPT09IC8qKGJ5dGUpICovIDB4QkIgJiZcclxuICAgICAgICAgICAgYnl0ZXNbMl0gPT09IC8qKGJ5dGUpICovIDB4QkY7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggJiYgKGNhbkJlSVNPODg1OTEgfHwgY2FuQmVTaGlmdEpJUyB8fCBjYW5CZVVURjgpOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gYnl0ZXNbaV0gJiAweEZGO1xyXG4gICAgICAgICAgICAvLyBVVEYtOCBzdHVmZlxyXG4gICAgICAgICAgICBpZiAoY2FuQmVVVEY4KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodXRmOEJ5dGVzTGVmdCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHg4MCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVVVEY4ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1dGY4Qnl0ZXNMZWZ0LS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHZhbHVlICYgMHg4MCkgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHZhbHVlICYgMHg0MCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVVVEY4ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1dGY4Qnl0ZXNMZWZ0Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDIwKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRmMkJ5dGVzQ2hhcnMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjhCeXRlc0xlZnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodmFsdWUgJiAweDEwKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjNCeXRlc0NoYXJzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1dGY4Qnl0ZXNMZWZ0Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh2YWx1ZSAmIDB4MDgpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0ZjRCeXRlc0NoYXJzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVVURjggPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IC8vIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdXRmOExvd0NoYXJzKytcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJU08tODg1OS0xIHN0dWZmXHJcbiAgICAgICAgICAgIGlmIChjYW5CZUlTTzg4NTkxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAweDdGICYmIHZhbHVlIDwgMHhBMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbkJlSVNPODg1OTEgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID4gMHg5Rikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4QzAgfHwgdmFsdWUgPT09IDB4RDcgfHwgdmFsdWUgPT09IDB4RjcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNvSGlnaE90aGVyKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpc29IaWdoQ2hhcnMrK1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIH0gLy8gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpc29Mb3dDaGFycysrXHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2hpZnRfSklTIHN0dWZmXHJcbiAgICAgICAgICAgIGlmIChjYW5CZVNoaWZ0SklTKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2ppc0J5dGVzTGVmdCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAweDQwIHx8IHZhbHVlID09PSAweDdGIHx8IHZhbHVlID4gMHhGQykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5CZVNoaWZ0SklTID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzQnl0ZXNMZWZ0LS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IDB4ODAgfHwgdmFsdWUgPT09IDB4QTAgfHwgdmFsdWUgPiAweEVGKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuQmVTaGlmdEpJUyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPiAweEEwICYmIHZhbHVlIDwgMHhFMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNqaXNLYXRha2FuYUNoYXJzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID4gc2ppc01heEthdGFrYW5hV29yZExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID0gc2ppc0N1ckthdGFrYW5hV29yZExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA+IDB4N0YpIHtcclxuICAgICAgICAgICAgICAgICAgICBzamlzQnl0ZXNMZWZ0Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2ppc0RvdWJsZUJ5dGVzQ2hhcnMrK1xyXG4gICAgICAgICAgICAgICAgICAgIHNqaXNDdXJLYXRha2FuYVdvcmRMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGgrKztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2ppc0N1ckRvdWJsZUJ5dGVzV29yZExlbmd0aCA+IHNqaXNNYXhEb3VibGVCeXRlc1dvcmRMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2ppc01heERvdWJsZUJ5dGVzV29yZExlbmd0aCA9IHNqaXNDdXJEb3VibGVCeXRlc1dvcmRMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2ppc0xvd0NoYXJzKytcclxuICAgICAgICAgICAgICAgICAgICBzamlzQ3VyS2F0YWthbmFXb3JkTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBzamlzQ3VyRG91YmxlQnl0ZXNXb3JkTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FuQmVVVEY4ICYmIHV0ZjhCeXRlc0xlZnQgPiAwKSB7XHJcbiAgICAgICAgICAgIGNhbkJlVVRGOCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FuQmVTaGlmdEpJUyAmJiBzamlzQnl0ZXNMZWZ0ID4gMCkge1xyXG4gICAgICAgICAgICBjYW5CZVNoaWZ0SklTID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVhc3kgLS0gaWYgdGhlcmUgaXMgQk9NIG9yIGF0IGxlYXN0IDEgdmFsaWQgbm90LXNpbmdsZSBieXRlIGNoYXJhY3RlciAoYW5kIG5vIGV2aWRlbmNlIGl0IGNhbid0IGJlIFVURi04KSwgZG9uZVxyXG4gICAgICAgIGlmIChjYW5CZVVURjggJiYgKHV0Zjhib20gfHwgdXRmMkJ5dGVzQ2hhcnMgKyB1dGYzQnl0ZXNDaGFycyArIHV0ZjRCeXRlc0NoYXJzID4gMCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLlVURjg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVhc3kgLS0gaWYgYXNzdW1pbmcgU2hpZnRfSklTIG9yIGF0IGxlYXN0IDMgdmFsaWQgY29uc2VjdXRpdmUgbm90LWFzY2lpIGNoYXJhY3RlcnMgKGFuZCBubyBldmlkZW5jZSBpdCBjYW4ndCBiZSksIGRvbmVcclxuICAgICAgICBpZiAoY2FuQmVTaGlmdEpJUyAmJiAoU3RyaW5nVXRpbHMuQVNTVU1FX1NISUZUX0pJUyB8fCBzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID49IDMgfHwgc2ppc01heERvdWJsZUJ5dGVzV29yZExlbmd0aCA+PSAzKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuU0hJRlRfSklTO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBEaXN0aW5ndWlzaGluZyBTaGlmdF9KSVMgYW5kIElTTy04ODU5LTEgY2FuIGJlIGEgbGl0dGxlIHRvdWdoIGZvciBzaG9ydCB3b3Jkcy4gVGhlIGNydWRlIGhldXJpc3RpYyBpczpcclxuICAgICAgICAvLyAtIElmIHdlIHNhd1xyXG4gICAgICAgIC8vICAgLSBvbmx5IHR3byBjb25zZWN1dGl2ZSBrYXRha2FuYSBjaGFycyBpbiB0aGUgd2hvbGUgdGV4dCwgb3JcclxuICAgICAgICAvLyAgIC0gYXQgbGVhc3QgMTAlIG9mIGJ5dGVzIHRoYXQgY291bGQgYmUgXCJ1cHBlclwiIG5vdC1hbHBoYW51bWVyaWMgTGF0aW4xLFxyXG4gICAgICAgIC8vIC0gdGhlbiB3ZSBjb25jbHVkZSBTaGlmdF9KSVMsIGVsc2UgSVNPLTg4NTktMVxyXG4gICAgICAgIGlmIChjYW5CZUlTTzg4NTkxICYmIGNhbkJlU2hpZnRKSVMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChzamlzTWF4S2F0YWthbmFXb3JkTGVuZ3RoID09PSAyICYmIHNqaXNLYXRha2FuYUNoYXJzID09PSAyKSB8fCBpc29IaWdoT3RoZXIgKiAxMCA+PSBsZW5ndGhcclxuICAgICAgICAgICAgICAgID8gU3RyaW5nVXRpbHMuU0hJRlRfSklTIDogU3RyaW5nVXRpbHMuSVNPODg1OTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IGluIG9yZGVyIElTTy04ODU5LTEsIFNoaWZ0IEpJUywgVVRGLTggYW5kIGZhbGwgYmFjayB0byBkZWZhdWx0IHBsYXRmb3JtIGVuY29kaW5nXHJcbiAgICAgICAgaWYgKGNhbkJlSVNPODg1OTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZ1V0aWxzLklTTzg4NTkxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FuQmVTaGlmdEpJUykge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuU0hJRlRfSklTO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FuQmVVVEY4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdVdGlscy5VVEY4O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHRha2UgYSB3aWxkIGd1ZXNzIHdpdGggcGxhdGZvcm0gZW5jb2RpbmdcclxuICAgICAgICByZXR1cm4gU3RyaW5nVXRpbHMuUExBVEZPUk1fREVGQVVMVF9FTkNPRElORztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMzQzOTcxMS80MzY3NjgzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFwcGVuZCBUaGUgbmV3IHN0cmluZyB0byBhcHBlbmQuXHJcbiAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWV0cyB2YWx1ZXMgdG8gYmUgZm9ybWF0ZWQuXHJcbiAgICAgKi9cclxuICAgIFN0cmluZ1V0aWxzLmZvcm1hdCA9IGZ1bmN0aW9uIChhcHBlbmQpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpID0gLTE7XHJcbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXhwLCBwMCwgcDEsIHAyLCBwMywgcDQpIHtcclxuICAgICAgICAgICAgaWYgKGV4cCA9PT0gJyUlJylcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJSc7XHJcbiAgICAgICAgICAgIGlmIChhcmdzWysraV0gPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIGV4cCA9IHAyID8gcGFyc2VJbnQocDIuc3Vic3RyKDEpKSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdmFyIGJhc2UgPSBwMyA/IHBhcnNlSW50KHAzLnN1YnN0cigxKSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhciB2YWw7XHJcbiAgICAgICAgICAgIHN3aXRjaCAocDQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGFyZ3NbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjJzpcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcmdzW2ldWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcmdzW2ldKS50b0ZpeGVkKGV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdwJzpcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFyZ3NbaV0pLnRvUHJlY2lzaW9uKGV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlJzpcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFyZ3NbaV0pLnRvRXhwb25lbnRpYWwoZXhwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3gnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlSW50KGFyZ3NbaV0pLnRvU3RyaW5nKGJhc2UgPyBiYXNlIDogMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChwYXJzZUludChhcmdzW2ldLCBiYXNlID8gYmFzZSA6IDEwKS50b1ByZWNpc2lvbihleHApKS50b0ZpeGVkKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkodmFsKSA6ICgrdmFsKS50b1N0cmluZyhiYXNlKTtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSBwYXJzZUludChwMSk7IC8qIHBhZGRpbmcgc2l6ZSAqL1xyXG4gICAgICAgICAgICB2YXIgY2ggPSBwMSAmJiAocDFbMF0gKyAnJykgPT09ICcwJyA/ICcwJyA6ICcgJzsgLyogaXNudWxsPyAqL1xyXG4gICAgICAgICAgICB3aGlsZSAodmFsLmxlbmd0aCA8IHNpemUpXHJcbiAgICAgICAgICAgICAgICB2YWwgPSBwMCAhPT0gdW5kZWZpbmVkID8gdmFsICsgY2ggOiBjaCArIHZhbDsgLyogaXNtaW51cz8gKi9cclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlZ2V4ID0gLyUoLSk/KDA/WzAtOV0rKT8oWy5dWzAtOV0rKT8oWyNdWzAtOV0rKT8oW3NjZnBleGQlXSkvZztcclxuICAgICAgICByZXR1cm4gYXBwZW5kLnJlcGxhY2UocmVnZXgsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIFN0cmluZ1V0aWxzLmdldEJ5dGVzID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmVuY29kZShzdHIsIGVuY29kaW5nKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNoYXJjb2RlIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggb3IgYXQgaW5kZXggemVyby5cclxuICAgICAqL1xyXG4gICAgU3RyaW5nVXRpbHMuZ2V0Q2hhckNvZGUgPSBmdW5jdGlvbiAoc3RyLCBpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gMDsgfVxyXG4gICAgICAgIHJldHVybiBzdHIuY2hhckNvZGVBdChpbmRleCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGNoYXIgZm9yIGdpdmVuIGNoYXJjb2RlXHJcbiAgICAgKi9cclxuICAgIFN0cmluZ1V0aWxzLmdldENoYXJBdCA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcclxuICAgIH07XHJcbiAgICBTdHJpbmdVdGlscy5TSElGVF9KSVMgPSBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LlNKSVMuZ2V0TmFtZSgpOyAvLyBcIlNKSVNcIlxyXG4gICAgU3RyaW5nVXRpbHMuR0IyMzEyID0gJ0dCMjMxMic7XHJcbiAgICBTdHJpbmdVdGlscy5JU084ODU5MSA9IENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuSVNPODg1OV8xLmdldE5hbWUoKTsgLy8gXCJJU084ODU5XzFcIlxyXG4gICAgU3RyaW5nVXRpbHMuRVVDX0pQID0gJ0VVQ19KUCc7XHJcbiAgICBTdHJpbmdVdGlscy5VVEY4ID0gQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5VVEY4LmdldE5hbWUoKTsgLy8gXCJVVEY4XCJcclxuICAgIFN0cmluZ1V0aWxzLlBMQVRGT1JNX0RFRkFVTFRfRU5DT0RJTkcgPSBTdHJpbmdVdGlscy5VVEY4OyAvLyBcIlVURjhcIi8vQ2hhcnNldC5kZWZhdWx0Q2hhcnNldCgpLm5hbWUoKVxyXG4gICAgU3RyaW5nVXRpbHMuQVNTVU1FX1NISUZUX0pJUyA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIFN0cmluZ1V0aWxzO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTdHJpbmdVdGlscztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyaW5nVXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDEyIFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5kZXRlY3RvciB7Ki9cclxuLyoqXHJcbiAqIEdlbmVyYWwgbWF0aC1yZWxhdGVkIGFuZCBudW1lcmljIHV0aWxpdHkgZnVuY3Rpb25zLlxyXG4gKi9cclxudmFyIE1hdGhVdGlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1hdGhVdGlscygpIHtcclxuICAgIH1cclxuICAgIE1hdGhVdGlscy5wcm90b3R5cGUuTWF0aFV0aWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRW5kcyB1cCBiZWluZyBhIGJpdCBmYXN0ZXIgdGhhbiB7QGxpbmsgTWF0aCNyb3VuZChmbG9hdCl9LiBUaGlzIG1lcmVseSByb3VuZHMgaXRzXHJcbiAgICAgKiBhcmd1bWVudCB0byB0aGUgbmVhcmVzdCBpbnQsIHdoZXJlIHguNSByb3VuZHMgdXAgdG8geCsxLiBTZW1hbnRpY3Mgb2YgdGhpcyBzaG9ydGN1dFxyXG4gICAgICogZGlmZmVyIHNsaWdodGx5IGZyb20ge0BsaW5rIE1hdGgjcm91bmQoZmxvYXQpfSBpbiB0aGF0IGhhbGYgcm91bmRzIGRvd24gZm9yIG5lZ2F0aXZlXHJcbiAgICAgKiB2YWx1ZXMuIC0yLjUgcm91bmRzIHRvIC0zLCBub3QgLTIuIEZvciBwdXJwb3NlcyBoZXJlIGl0IG1ha2VzIG5vIGRpZmZlcmVuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGQgcmVhbCB2YWx1ZSB0byByb3VuZFxyXG4gICAgICogQHJldHVybiBuZWFyZXN0IHtAY29kZSBpbnR9XHJcbiAgICAgKi9cclxuICAgIE1hdGhVdGlscy5yb3VuZCA9IGZ1bmN0aW9uIChkIC8qZmxvYXQqLykge1xyXG4gICAgICAgIGlmIChOYU4gPT09IGQpXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIGlmIChkIDw9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKVxyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XHJcbiAgICAgICAgaWYgKGQgPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpXHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxuICAgICAgICByZXR1cm4gLyooaW50KSAqLyAoZCArIChkIDwgMC4wID8gLTAuNSA6IDAuNSkpIHwgMDtcclxuICAgIH07XHJcbiAgICAvLyBUWVBFU0NSSVBUUE9SVDogbWF5YmUgcmVtb3ZlIHJvdW5kIG1ldGhvZCBhbmQgY2FsbCBkaXJlY3RseSBNYXRoLnJvdW5kLCBpdCBsb29rcyBsaWtlIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSBmb3IganNcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGFYIHBvaW50IEEgeCBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gYVkgcG9pbnQgQSB5IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSBiWCBwb2ludCBCIHggY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIGJZIHBvaW50IEIgeSBjb29yZGluYXRlXHJcbiAgICAgKiBAcmV0dXJuIEV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyBBIGFuZCBCXHJcbiAgICAgKi9cclxuICAgIE1hdGhVdGlscy5kaXN0YW5jZSA9IGZ1bmN0aW9uIChhWCAvKmZsb2F0fGludCovLCBhWSAvKmZsb2F0fGludCovLCBiWCAvKmZsb2F0fGludCovLCBiWSAvKmZsb2F0fGludCovKSB7XHJcbiAgICAgICAgdmFyIHhEaWZmID0gYVggLSBiWDtcclxuICAgICAgICB2YXIgeURpZmYgPSBhWSAtIGJZO1xyXG4gICAgICAgIHJldHVybiAvKihmbG9hdCkgKi8gTWF0aC5zcXJ0KHhEaWZmICogeERpZmYgKyB5RGlmZiAqIHlEaWZmKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBhWCBwb2ludCBBIHggY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIGFZIHBvaW50IEEgeSBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gYlggcG9pbnQgQiB4IGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSBiWSBwb2ludCBCIHkgY29vcmRpbmF0ZVxyXG4gICAgICogQHJldHVybiBFdWNsaWRlYW4gZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgQSBhbmQgQlxyXG4gICAgICovXHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIGRpc3RhbmNlKGFYOiBudW1iZXIgLyppbnQqLywgYVk6IG51bWJlciAvKmludCovLCBiWDogbnVtYmVyIC8qaW50Ki8sIGJZOiBudW1iZXIgLyppbnQqLyk6IGZsb2F0IHtcclxuICAgIC8vICAgY29uc3QgeERpZmYgPSBhWCAtIGJYXHJcbiAgICAvLyAgIGNvbnN0IHlEaWZmID0gYVkgLSBiWVxyXG4gICAgLy8gICByZXR1cm4gKGZsb2F0KSBNYXRoLnNxcnQoeERpZmYgKiB4RGlmZiArIHlEaWZmICogeURpZmYpO1xyXG4gICAgLy8gfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYXJyYXkgdmFsdWVzIHRvIHN1bVxyXG4gICAgICogQHJldHVybiBzdW0gb2YgdmFsdWVzIGluIGFycmF5XHJcbiAgICAgKi9cclxuICAgIE1hdGhVdGlscy5zdW0gPSBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgICAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IGFycmF5Lmxlbmd0aDsgaSAhPT0gbGVuZ3RoXzE7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYSA9IGFycmF5W2ldO1xyXG4gICAgICAgICAgICBjb3VudCArPSBhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY291bnQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1hdGhVdGlscztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTWF0aFV0aWxzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRoVXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDEwIFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5kZXRlY3RvciB7Ki9cclxudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVzdWx0UG9pbnRcIik7XHJcbnZhciBNYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuL01hdGhVdGlsc1wiKTtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiA8cD5cclxuICogRGV0ZWN0cyBhIGNhbmRpZGF0ZSBiYXJjb2RlLWxpa2UgcmVjdGFuZ3VsYXIgcmVnaW9uIHdpdGhpbiBhbiBpbWFnZS4gSXRcclxuICogc3RhcnRzIGFyb3VuZCB0aGUgY2VudGVyIG9mIHRoZSBpbWFnZSwgaW5jcmVhc2VzIHRoZSBzaXplIG9mIHRoZSBjYW5kaWRhdGVcclxuICogcmVnaW9uIHVudGlsIGl0IGZpbmRzIGEgd2hpdGUgcmVjdGFuZ3VsYXIgcmVnaW9uLiBCeSBrZWVwaW5nIHRyYWNrIG9mIHRoZVxyXG4gKiBsYXN0IGJsYWNrIHBvaW50cyBpdCBlbmNvdW50ZXJlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY29ybmVycyBvZiB0aGUgYmFyY29kZS5cclxuICogPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcclxuICovXHJcbnZhciBXaGl0ZVJlY3RhbmdsZURldGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgaW1hZ2U6IEJpdE1hdHJpeCkgLyp0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24qLyB7XHJcbiAgICAvLyAgIHRoaXMoaW1hZ2UsIElOSVRfU0laRSwgaW1hZ2UuZ2V0V2lkdGgoKSAvIDIsIGltYWdlLmdldEhlaWdodCgpIC8gMilcclxuICAgIC8vIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGltYWdlIGJhcmNvZGUgaW1hZ2UgdG8gZmluZCBhIHJlY3RhbmdsZSBpblxyXG4gICAgICogQHBhcmFtIGluaXRTaXplIGluaXRpYWwgc2l6ZSBvZiBzZWFyY2ggYXJlYSBhcm91bmQgY2VudGVyXHJcbiAgICAgKiBAcGFyYW0geCB4IHBvc2l0aW9uIG9mIHNlYXJjaCBjZW50ZXJcclxuICAgICAqIEBwYXJhbSB5IHkgcG9zaXRpb24gb2Ygc2VhcmNoIGNlbnRlclxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBpbWFnZSBpcyB0b28gc21hbGwgdG8gYWNjb21tb2RhdGUge0Bjb2RlIGluaXRTaXplfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBXaGl0ZVJlY3RhbmdsZURldGVjdG9yKGltYWdlLCBpbml0U2l6ZSAvKmludCovLCB4IC8qaW50Ki8sIHkgLyppbnQqLykge1xyXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGltYWdlLmdldEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGluaXRTaXplIHx8IG51bGwgPT09IGluaXRTaXplKSB7XHJcbiAgICAgICAgICAgIGluaXRTaXplID0gV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5JTklUX1NJWkU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHggfHwgbnVsbCA9PT0geCkge1xyXG4gICAgICAgICAgICB4ID0gaW1hZ2UuZ2V0V2lkdGgoKSAvIDIgfCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB5IHx8IG51bGwgPT09IHkpIHtcclxuICAgICAgICAgICAgeSA9IGltYWdlLmdldEhlaWdodCgpIC8gMiB8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoYWxmc2l6ZSA9IGluaXRTaXplIC8gMiB8IDA7XHJcbiAgICAgICAgdGhpcy5sZWZ0SW5pdCA9IHggLSBoYWxmc2l6ZTtcclxuICAgICAgICB0aGlzLnJpZ2h0SW5pdCA9IHggKyBoYWxmc2l6ZTtcclxuICAgICAgICB0aGlzLnVwSW5pdCA9IHkgLSBoYWxmc2l6ZTtcclxuICAgICAgICB0aGlzLmRvd25Jbml0ID0geSArIGhhbGZzaXplO1xyXG4gICAgICAgIGlmICh0aGlzLnVwSW5pdCA8IDAgfHwgdGhpcy5sZWZ0SW5pdCA8IDAgfHwgdGhpcy5kb3duSW5pdCA+PSB0aGlzLmhlaWdodCB8fCB0aGlzLnJpZ2h0SW5pdCA+PSB0aGlzLndpZHRoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIDxwPlxyXG4gICAgICogRGV0ZWN0cyBhIGNhbmRpZGF0ZSBiYXJjb2RlLWxpa2UgcmVjdGFuZ3VsYXIgcmVnaW9uIHdpdGhpbiBhbiBpbWFnZS4gSXRcclxuICAgICAqIHN0YXJ0cyBhcm91bmQgdGhlIGNlbnRlciBvZiB0aGUgaW1hZ2UsIGluY3JlYXNlcyB0aGUgc2l6ZSBvZiB0aGUgY2FuZGlkYXRlXHJcbiAgICAgKiByZWdpb24gdW50aWwgaXQgZmluZHMgYSB3aGl0ZSByZWN0YW5ndWxhciByZWdpb24uXHJcbiAgICAgKiA8L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7QGxpbmsgUmVzdWx0UG9pbnR9W10gZGVzY3JpYmluZyB0aGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ3VsYXJcclxuICAgICAqICAgICAgICAgcmVnaW9uLiBUaGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBvcHBvc2VkIG9uIHRoZSBkaWFnb25hbCwgYXNcclxuICAgICAqICAgICAgICAgYXJlIHRoZSBzZWNvbmQgYW5kIHRoaXJkLiBUaGUgZmlyc3QgcG9pbnQgd2lsbCBiZSB0aGUgdG9wbW9zdFxyXG4gICAgICogICAgICAgICBwb2ludCBhbmQgdGhlIGxhc3QsIHRoZSBib3R0b21tb3N0LiBUaGUgc2Vjb25kIHBvaW50IHdpbGwgYmVcclxuICAgICAqICAgICAgICAgbGVmdG1vc3QgYW5kIHRoZSB0aGlyZCwgdGhlIHJpZ2h0bW9zdFxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBubyBEYXRhIE1hdHJpeCBDb2RlIGNhbiBiZSBmb3VuZFxyXG4gICAgICovXHJcbiAgICBXaGl0ZVJlY3RhbmdsZURldGVjdG9yLnByb3RvdHlwZS5kZXRlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnRJbml0O1xyXG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucmlnaHRJbml0O1xyXG4gICAgICAgIHZhciB1cCA9IHRoaXMudXBJbml0O1xyXG4gICAgICAgIHZhciBkb3duID0gdGhpcy5kb3duSW5pdDtcclxuICAgICAgICB2YXIgc2l6ZUV4Y2VlZGVkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XHJcbiAgICAgICAgdmFyIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25SaWdodCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3R0b20gPSBmYWxzZTtcclxuICAgICAgICB2YXIgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uTGVmdCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Ub3AgPSBmYWxzZTtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICB3aGlsZSAoYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyKSB7XHJcbiAgICAgICAgICAgIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyAuLi4uLlxyXG4gICAgICAgICAgICAvLyAuICAgfFxyXG4gICAgICAgICAgICAvLyAuLi4uLlxyXG4gICAgICAgICAgICB2YXIgcmlnaHRCb3JkZXJOb3RXaGl0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHdoaWxlICgocmlnaHRCb3JkZXJOb3RXaGl0ZSB8fCAhYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uUmlnaHQpICYmIHJpZ2h0IDwgd2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0Qm9yZGVyTm90V2hpdGUgPSB0aGlzLmNvbnRhaW5zQmxhY2tQb2ludCh1cCwgZG93biwgcmlnaHQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChyaWdodEJvcmRlck5vdFdoaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQrKztcclxuICAgICAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPblJpZ2h0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25SaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJpZ2h0ID49IHdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplRXhjZWVkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gLi4uLi5cclxuICAgICAgICAgICAgLy8gLiAgIC5cclxuICAgICAgICAgICAgLy8gLl9fXy5cclxuICAgICAgICAgICAgdmFyIGJvdHRvbUJvcmRlck5vdFdoaXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgd2hpbGUgKChib3R0b21Cb3JkZXJOb3RXaGl0ZSB8fCAhYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm90dG9tKSAmJiBkb3duIDwgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBib3R0b21Cb3JkZXJOb3RXaGl0ZSA9IHRoaXMuY29udGFpbnNCbGFja1BvaW50KGxlZnQsIHJpZ2h0LCBkb3duLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGlmIChib3R0b21Cb3JkZXJOb3RXaGl0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvd24rKztcclxuICAgICAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvdHRvbSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uQm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG93bisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkb3duID49IGhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIC4uLi4uXHJcbiAgICAgICAgICAgIC8vIHwgICAuXHJcbiAgICAgICAgICAgIC8vIC4uLi4uXHJcbiAgICAgICAgICAgIHZhciBsZWZ0Qm9yZGVyTm90V2hpdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB3aGlsZSAoKGxlZnRCb3JkZXJOb3RXaGl0ZSB8fCAhYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uTGVmdCkgJiYgbGVmdCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Qm9yZGVyTm90V2hpdGUgPSB0aGlzLmNvbnRhaW5zQmxhY2tQb2ludCh1cCwgZG93biwgbGVmdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRCb3JkZXJOb3RXaGl0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQtLTtcclxuICAgICAgICAgICAgICAgICAgICBhQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkxlZnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0LS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplRXhjZWVkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gLl9fXy5cclxuICAgICAgICAgICAgLy8gLiAgIC5cclxuICAgICAgICAgICAgLy8gLi4uLi5cclxuICAgICAgICAgICAgdmFyIHRvcEJvcmRlck5vdFdoaXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgd2hpbGUgKCh0b3BCb3JkZXJOb3RXaGl0ZSB8fCAhYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uVG9wKSAmJiB1cCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0b3BCb3JkZXJOb3RXaGl0ZSA9IHRoaXMuY29udGFpbnNCbGFja1BvaW50KGxlZnQsIHJpZ2h0LCB1cCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9wQm9yZGVyTm90V2hpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cC0tO1xyXG4gICAgICAgICAgICAgICAgICAgIGFCbGFja1BvaW50Rm91bmRPbkJvcmRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYXRMZWFzdE9uZUJsYWNrUG9pbnRGb3VuZE9uVG9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Ub3ApIHtcclxuICAgICAgICAgICAgICAgICAgICB1cC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh1cCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHNpemVFeGNlZWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYUJsYWNrUG9pbnRGb3VuZE9uQm9yZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBhdExlYXN0T25lQmxhY2tQb2ludEZvdW5kT25Cb3JkZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc2l6ZUV4Y2VlZGVkICYmIGF0TGVhc3RPbmVCbGFja1BvaW50Rm91bmRPbkJvcmRlcikge1xyXG4gICAgICAgICAgICB2YXIgbWF4U2l6ZSA9IHJpZ2h0IC0gbGVmdDtcclxuICAgICAgICAgICAgdmFyIHogPSBudWxsO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgeiA9PT0gbnVsbCAmJiBpIDwgbWF4U2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB6ID0gdGhpcy5nZXRCbGFja1BvaW50T25TZWdtZW50KGxlZnQsIGRvd24gLSBpLCBsZWZ0ICsgaSwgZG93bik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHogPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0ID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gZ28gZG93biByaWdodFxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgdCA9PT0gbnVsbCAmJiBpIDwgbWF4U2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ID0gdGhpcy5nZXRCbGFja1BvaW50T25TZWdtZW50KGxlZnQsIHVwICsgaSwgbGVmdCArIGksIHVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHggPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBnbyBkb3duIGxlZnRcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IHggPT09IG51bGwgJiYgaSA8IG1heFNpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXMuZ2V0QmxhY2tQb2ludE9uU2VnbWVudChyaWdodCwgdXAgKyBpLCByaWdodCAtIGksIHVwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoeCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHkgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBnbyB1cCBsZWZ0XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyB5ID09PSBudWxsICYmIGkgPCBtYXhTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHkgPSB0aGlzLmdldEJsYWNrUG9pbnRPblNlZ21lbnQocmlnaHQsIGRvd24gLSBpLCByaWdodCAtIGksIGRvd24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXJFZGdlcyh5LCB6LCB4LCB0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5wcm90b3R5cGUuZ2V0QmxhY2tQb2ludE9uU2VnbWVudCA9IGZ1bmN0aW9uIChhWCAvKmZsb2F0Ki8sIGFZIC8qZmxvYXQqLywgYlggLypmbG9hdCovLCBiWSAvKmZsb2F0Ki8pIHtcclxuICAgICAgICB2YXIgZGlzdCA9IE1hdGhVdGlsc18xLmRlZmF1bHQucm91bmQoTWF0aFV0aWxzXzEuZGVmYXVsdC5kaXN0YW5jZShhWCwgYVksIGJYLCBiWSkpO1xyXG4gICAgICAgIHZhciB4U3RlcCA9IChiWCAtIGFYKSAvIGRpc3Q7XHJcbiAgICAgICAgdmFyIHlTdGVwID0gKGJZIC0gYVkpIC8gZGlzdDtcclxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZChhWCArIGkgKiB4U3RlcCk7XHJcbiAgICAgICAgICAgIHZhciB5ID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5yb3VuZChhWSArIGkgKiB5U3RlcCk7XHJcbiAgICAgICAgICAgIGlmIChpbWFnZS5nZXQoeCwgeSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHgsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogcmVjZW50ZXJzIHRoZSBwb2ludHMgb2YgYSBjb25zdGFudCBkaXN0YW5jZSB0b3dhcmRzIHRoZSBjZW50ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geSBib3R0b20gbW9zdCBwb2ludFxyXG4gICAgICogQHBhcmFtIHogbGVmdCBtb3N0IHBvaW50XHJcbiAgICAgKiBAcGFyYW0geCByaWdodCBtb3N0IHBvaW50XHJcbiAgICAgKiBAcGFyYW0gdCB0b3AgbW9zdCBwb2ludFxyXG4gICAgICogQHJldHVybiB7QGxpbmsgUmVzdWx0UG9pbnR9W10gZGVzY3JpYmluZyB0aGUgY29ybmVycyBvZiB0aGUgcmVjdGFuZ3VsYXJcclxuICAgICAqICAgICAgICAgcmVnaW9uLiBUaGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBvcHBvc2VkIG9uIHRoZSBkaWFnb25hbCwgYXNcclxuICAgICAqICAgICAgICAgYXJlIHRoZSBzZWNvbmQgYW5kIHRoaXJkLiBUaGUgZmlyc3QgcG9pbnQgd2lsbCBiZSB0aGUgdG9wbW9zdFxyXG4gICAgICogICAgICAgICBwb2ludCBhbmQgdGhlIGxhc3QsIHRoZSBib3R0b21tb3N0LiBUaGUgc2Vjb25kIHBvaW50IHdpbGwgYmVcclxuICAgICAqICAgICAgICAgbGVmdG1vc3QgYW5kIHRoZSB0aGlyZCwgdGhlIHJpZ2h0bW9zdFxyXG4gICAgICovXHJcbiAgICBXaGl0ZVJlY3RhbmdsZURldGVjdG9yLnByb3RvdHlwZS5jZW50ZXJFZGdlcyA9IGZ1bmN0aW9uICh5LCB6LCB4LCB0KSB7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyAgICAgICB0ICAgICAgICAgICAgdFxyXG4gICAgICAgIC8vICB6ICAgICAgICAgICAgICAgICAgICAgIHhcclxuICAgICAgICAvLyAgICAgICAgeCAgICBPUiAgICB6XHJcbiAgICAgICAgLy8gICB5ICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICAgICAgLy9cclxuICAgICAgICB2YXIgeWkgPSB5LmdldFgoKTtcclxuICAgICAgICB2YXIgeWogPSB5LmdldFkoKTtcclxuICAgICAgICB2YXIgemkgPSB6LmdldFgoKTtcclxuICAgICAgICB2YXIgemogPSB6LmdldFkoKTtcclxuICAgICAgICB2YXIgeGkgPSB4LmdldFgoKTtcclxuICAgICAgICB2YXIgeGogPSB4LmdldFkoKTtcclxuICAgICAgICB2YXIgdGkgPSB0LmdldFgoKTtcclxuICAgICAgICB2YXIgdGogPSB0LmdldFkoKTtcclxuICAgICAgICB2YXIgQ09SUiA9IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3IuQ09SUjtcclxuICAgICAgICBpZiAoeWkgPCB0aGlzLndpZHRoIC8gMi4wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHRpIC0gQ09SUiwgdGogKyBDT1JSKSxcclxuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoemkgKyBDT1JSLCB6aiArIENPUlIpLFxyXG4gICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdCh4aSAtIENPUlIsIHhqIC0gQ09SUiksXHJcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHlpICsgQ09SUiwgeWogLSBDT1JSKVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQodGkgKyBDT1JSLCB0aiArIENPUlIpLFxyXG4gICAgICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdCh6aSArIENPUlIsIHpqIC0gQ09SUiksXHJcbiAgICAgICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHhpIC0gQ09SUiwgeGogKyBDT1JSKSxcclxuICAgICAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoeWkgLSBDT1JSLCB5aiAtIENPUlIpXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgc2VnbWVudCBjb250YWlucyBhIGJsYWNrIHBvaW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGEgICAgICAgICAgbWluIHZhbHVlIG9mIHRoZSBzY2FubmVkIGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSBiICAgICAgICAgIG1heCB2YWx1ZSBvZiB0aGUgc2Nhbm5lZCBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gZml4ZWQgICAgICB2YWx1ZSBvZiBmaXhlZCBjb29yZGluYXRlXHJcbiAgICAgKiBAcGFyYW0gaG9yaXpvbnRhbCBzZXQgdG8gdHJ1ZSBpZiBzY2FuIG11c3QgYmUgaG9yaXpvbnRhbCwgZmFsc2UgaWYgdmVydGljYWxcclxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBhIGJsYWNrIHBvaW50IGhhcyBiZWVuIGZvdW5kLCBlbHNlIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBXaGl0ZVJlY3RhbmdsZURldGVjdG9yLnByb3RvdHlwZS5jb250YWluc0JsYWNrUG9pbnQgPSBmdW5jdGlvbiAoYSAvKmludCovLCBiIC8qaW50Ki8sIGZpeGVkIC8qaW50Ki8sIGhvcml6b250YWwpIHtcclxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xyXG4gICAgICAgIGlmIChob3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSBhOyB4IDw9IGI7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldCh4LCBmaXhlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IGE7IHkgPD0gYjsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGZpeGVkLCB5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBXaGl0ZVJlY3RhbmdsZURldGVjdG9yLklOSVRfU0laRSA9IDEwO1xyXG4gICAgV2hpdGVSZWN0YW5nbGVEZXRlY3Rvci5DT1JSID0gMTtcclxuICAgIHJldHVybiBXaGl0ZVJlY3RhbmdsZURldGVjdG9yO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBXaGl0ZVJlY3RhbmdsZURldGVjdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1XaGl0ZVJlY3RhbmdsZURldGVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIDxwPlRoaXMgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBwZXJmb3JtaW5nIG1hdGhlbWF0aWNhbCBvcGVyYXRpb25zIG92ZXJcclxuICogdGhlIEdhbG9pcyBGaWVsZHMuIE9wZXJhdGlvbnMgdXNlIGEgZ2l2ZW4gcHJpbWl0aXZlIHBvbHlub21pYWwgaW4gY2FsY3VsYXRpb25zLjwvcD5cclxuICpcclxuICogPHA+VGhyb3VnaG91dCB0aGlzIHBhY2thZ2UsIGVsZW1lbnRzIG9mIHRoZSBHRiBhcmUgcmVwcmVzZW50ZWQgYXMgYW4ge0Bjb2RlIGludH1cclxuICogZm9yIGNvbnZlbmllbmNlIGFuZCBzcGVlZCAoYnV0IGF0IHRoZSBjb3N0IG9mIG1lbW9yeSkuXHJcbiAqIDwvcD5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICogQGF1dGhvciBEYXZpZCBPbGl2aWVyXHJcbiAqL1xyXG52YXIgQWJzdHJhY3RHZW5lcmljR0YgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBYnN0cmFjdEdlbmVyaWNHRigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiAyIHRvIHRoZSBwb3dlciBvZiBhIGluIEdGKHNpemUpXHJcbiAgICAgKi9cclxuICAgIEFic3RyYWN0R2VuZXJpY0dGLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4cFRhYmxlW2FdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBiYXNlIDIgbG9nIG9mIGEgaW4gR0Yoc2l6ZSlcclxuICAgICAqL1xyXG4gICAgQWJzdHJhY3RHZW5lcmljR0YucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChhIC8qaW50Ki8pIHtcclxuICAgICAgICBpZiAoYSA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5sb2dUYWJsZVthXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEltcGxlbWVudHMgYm90aCBhZGRpdGlvbiBhbmQgc3VidHJhY3Rpb24gLS0gdGhleSBhcmUgdGhlIHNhbWUgaW4gR0Yoc2l6ZSkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBzdW0vZGlmZmVyZW5jZSBvZiBhIGFuZCBiXHJcbiAgICAgKi9cclxuICAgIEFic3RyYWN0R2VuZXJpY0dGLmFkZE9yU3VidHJhY3QgPSBmdW5jdGlvbiAoYSAvKmludCovLCBiIC8qaW50Ki8pIHtcclxuICAgICAgICByZXR1cm4gYSBeIGI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFic3RyYWN0R2VuZXJpY0dGO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdEdlbmVyaWNHRjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RHZW5lcmljR0YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24geyovXHJcbnZhciBHZW5lcmljR0ZQb2x5XzEgPSByZXF1aXJlKFwiLi9HZW5lcmljR0ZQb2x5XCIpO1xyXG52YXIgQWJzdHJhY3RHZW5lcmljR0ZfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0R2VuZXJpY0dGXCIpO1xyXG52YXIgSW50ZWdlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvSW50ZWdlclwiKTtcclxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxudmFyIEFyaXRobWV0aWNFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Bcml0aG1ldGljRXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogPHA+VGhpcyBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIHBlcmZvcm1pbmcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMgb3ZlclxyXG4gKiB0aGUgR2Fsb2lzIEZpZWxkcy4gT3BlcmF0aW9ucyB1c2UgYSBnaXZlbiBwcmltaXRpdmUgcG9seW5vbWlhbCBpbiBjYWxjdWxhdGlvbnMuPC9wPlxyXG4gKlxyXG4gKiA8cD5UaHJvdWdob3V0IHRoaXMgcGFja2FnZSwgZWxlbWVudHMgb2YgdGhlIEdGIGFyZSByZXByZXNlbnRlZCBhcyBhbiB7QGNvZGUgaW50fVxyXG4gKiBmb3IgY29udmVuaWVuY2UgYW5kIHNwZWVkIChidXQgYXQgdGhlIGNvc3Qgb2YgbWVtb3J5KS5cclxuICogPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKiBAYXV0aG9yIERhdmlkIE9saXZpZXJcclxuICovXHJcbnZhciBHZW5lcmljR0YgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoR2VuZXJpY0dGLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSByZXByZXNlbnRhdGlvbiBvZiBHRihzaXplKSB1c2luZyB0aGUgZ2l2ZW4gcHJpbWl0aXZlIHBvbHlub21pYWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHByaW1pdGl2ZSBpcnJlZHVjaWJsZSBwb2x5bm9taWFsIHdob3NlIGNvZWZmaWNpZW50cyBhcmUgcmVwcmVzZW50ZWQgYnlcclxuICAgICAqICB0aGUgYml0cyBvZiBhbiBpbnQsIHdoZXJlIHRoZSBsZWFzdC1zaWduaWZpY2FudCBiaXQgcmVwcmVzZW50cyB0aGUgY29uc3RhbnRcclxuICAgICAqICBjb2VmZmljaWVudFxyXG4gICAgICogQHBhcmFtIHNpemUgdGhlIHNpemUgb2YgdGhlIGZpZWxkXHJcbiAgICAgKiBAcGFyYW0gYiB0aGUgZmFjdG9yIGIgaW4gdGhlIGdlbmVyYXRvciBwb2x5bm9taWFsIGNhbiBiZSAwLSBvciAxLWJhc2VkXHJcbiAgICAgKiAgKGcoeCkgPSAoeCthXmIpKHgrYV4oYisxKSkuLi4oeCthXihiKzJ0LTEpKSkuXHJcbiAgICAgKiAgSW4gbW9zdCBjYXNlcyBpdCBzaG91bGQgYmUgMSwgYnV0IGZvciBRUiBjb2RlIGl0IGlzIDAuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEdlbmVyaWNHRihwcmltaXRpdmUgLyppbnQqLywgc2l6ZSAvKmludCovLCBnZW5lcmF0b3JCYXNlIC8qaW50Ki8pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcclxuICAgICAgICBfdGhpcy5zaXplID0gc2l6ZTtcclxuICAgICAgICBfdGhpcy5nZW5lcmF0b3JCYXNlID0gZ2VuZXJhdG9yQmFzZTtcclxuICAgICAgICB2YXIgZXhwVGFibGUgPSBuZXcgSW50MzJBcnJheShzaXplKTtcclxuICAgICAgICB2YXIgeCA9IDE7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICAgICAgZXhwVGFibGVbaV0gPSB4O1xyXG4gICAgICAgICAgICB4ICo9IDI7IC8vIHdlJ3JlIGFzc3VtaW5nIHRoZSBnZW5lcmF0b3IgYWxwaGEgaXMgMlxyXG4gICAgICAgICAgICBpZiAoeCA+PSBzaXplKSB7XHJcbiAgICAgICAgICAgICAgICB4IF49IHByaW1pdGl2ZTtcclxuICAgICAgICAgICAgICAgIHggJj0gc2l6ZSAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuZXhwVGFibGUgPSBleHBUYWJsZTtcclxuICAgICAgICB2YXIgbG9nVGFibGUgPSBuZXcgSW50MzJBcnJheShzaXplKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemUgLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgbG9nVGFibGVbZXhwVGFibGVbaV1dID0gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMubG9nVGFibGUgPSBsb2dUYWJsZTtcclxuICAgICAgICAvLyBsb2dUYWJsZVswXSA9PSAwIGJ1dCB0aGlzIHNob3VsZCBuZXZlciBiZSB1c2VkXHJcbiAgICAgICAgX3RoaXMuemVybyA9IG5ldyBHZW5lcmljR0ZQb2x5XzEuZGVmYXVsdChfdGhpcywgSW50MzJBcnJheS5mcm9tKFswXSkpO1xyXG4gICAgICAgIF90aGlzLm9uZSA9IG5ldyBHZW5lcmljR0ZQb2x5XzEuZGVmYXVsdChfdGhpcywgSW50MzJBcnJheS5mcm9tKFsxXSkpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEdlbmVyaWNHRi5wcm90b3R5cGUuZ2V0WmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xyXG4gICAgfTtcclxuICAgIEdlbmVyaWNHRi5wcm90b3R5cGUuZ2V0T25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9uZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gdGhlIG1vbm9taWFsIHJlcHJlc2VudGluZyBjb2VmZmljaWVudCAqIHheZGVncmVlXHJcbiAgICAgKi9cclxuICAgIEdlbmVyaWNHRi5wcm90b3R5cGUuYnVpbGRNb25vbWlhbCA9IGZ1bmN0aW9uIChkZWdyZWUgLyppbnQqLywgY29lZmZpY2llbnQgLyppbnQqLykge1xyXG4gICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy56ZXJvO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoZGVncmVlICsgMSk7XHJcbiAgICAgICAgY29lZmZpY2llbnRzWzBdID0gY29lZmZpY2llbnQ7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5XzEuZGVmYXVsdCh0aGlzLCBjb2VmZmljaWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBtdWx0aXBsaWNhdGl2ZSBpbnZlcnNlIG9mIGFcclxuICAgICAqL1xyXG4gICAgR2VuZXJpY0dGLnByb3RvdHlwZS5pbnZlcnNlID0gZnVuY3Rpb24gKGEgLyppbnQqLykge1xyXG4gICAgICAgIGlmIChhID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBcml0aG1ldGljRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVt0aGlzLnNpemUgLSB0aGlzLmxvZ1RhYmxlW2FdIC0gMV07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHByb2R1Y3Qgb2YgYSBhbmQgYiBpbiBHRihzaXplKVxyXG4gICAgICovXHJcbiAgICBHZW5lcmljR0YucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKGEgLyppbnQqLywgYiAvKmludCovKSB7XHJcbiAgICAgICAgaWYgKGEgPT09IDAgfHwgYiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbKHRoaXMubG9nVGFibGVbYV0gKyB0aGlzLmxvZ1RhYmxlW2JdKSAlICh0aGlzLnNpemUgLSAxKV07XHJcbiAgICB9O1xyXG4gICAgR2VuZXJpY0dGLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNpemU7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJpY0dGLnByb3RvdHlwZS5nZXRHZW5lcmF0b3JCYXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRvckJhc2U7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgR2VuZXJpY0dGLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKCdHRigweCcgKyBJbnRlZ2VyXzEuZGVmYXVsdC50b0hleFN0cmluZyh0aGlzLnByaW1pdGl2ZSkgKyAnLCcgKyB0aGlzLnNpemUgKyAnKScpO1xyXG4gICAgfTtcclxuICAgIEdlbmVyaWNHRi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICByZXR1cm4gbyA9PT0gdGhpcztcclxuICAgIH07XHJcbiAgICBHZW5lcmljR0YuQVpURUNfREFUQV8xMiA9IG5ldyBHZW5lcmljR0YoMHgxMDY5LCA0MDk2LCAxKTsgLy8geF4xMiArIHheNiArIHheNSArIHheMyArIDFcclxuICAgIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzEwID0gbmV3IEdlbmVyaWNHRigweDQwOSwgMTAyNCwgMSk7IC8vIHheMTAgKyB4XjMgKyAxXHJcbiAgICBHZW5lcmljR0YuQVpURUNfREFUQV82ID0gbmV3IEdlbmVyaWNHRigweDQzLCA2NCwgMSk7IC8vIHheNiArIHggKyAxXHJcbiAgICBHZW5lcmljR0YuQVpURUNfUEFSQU0gPSBuZXcgR2VuZXJpY0dGKDB4MTMsIDE2LCAxKTsgLy8geF40ICsgeCArIDFcclxuICAgIEdlbmVyaWNHRi5RUl9DT0RFX0ZJRUxEXzI1NiA9IG5ldyBHZW5lcmljR0YoMHgwMTFkLCAyNTYsIDApOyAvLyB4XjggKyB4XjQgKyB4XjMgKyB4XjIgKyAxXHJcbiAgICBHZW5lcmljR0YuREFUQV9NQVRSSVhfRklFTERfMjU2ID0gbmV3IEdlbmVyaWNHRigweDAxMmQsIDI1NiwgMSk7IC8vIHheOCArIHheNSArIHheMyArIHheMiArIDFcclxuICAgIEdlbmVyaWNHRi5BWlRFQ19EQVRBXzggPSBHZW5lcmljR0YuREFUQV9NQVRSSVhfRklFTERfMjU2O1xyXG4gICAgR2VuZXJpY0dGLk1BWElDT0RFX0ZJRUxEXzY0ID0gR2VuZXJpY0dGLkFaVEVDX0RBVEFfNjtcclxuICAgIHJldHVybiBHZW5lcmljR0Y7XHJcbn0oQWJzdHJhY3RHZW5lcmljR0ZfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEdlbmVyaWNHRjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJpY0dGLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5jb21tb24ucmVlZHNvbG9tb24geyovXHJcbnZhciBBYnN0cmFjdEdlbmVyaWNHRl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RHZW5lcmljR0ZcIik7XHJcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N5c3RlbVwiKTtcclxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIDxwPlJlcHJlc2VudHMgYSBwb2x5bm9taWFsIHdob3NlIGNvZWZmaWNpZW50cyBhcmUgZWxlbWVudHMgb2YgYSBHRi5cclxuICogSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgYXJlIGltbXV0YWJsZS48L3A+XHJcbiAqXHJcbiAqIDxwPk11Y2ggY3JlZGl0IGlzIGR1ZSB0byBXaWxsaWFtIFJ1Y2tsaWRnZSBzaW5jZSBwb3J0aW9ucyBvZiB0aGlzIGNvZGUgYXJlIGFuIGluZGlyZWN0XHJcbiAqIHBvcnQgb2YgaGlzIEMrKyBSZWVkLVNvbG9tb24gaW1wbGVtZW50YXRpb24uPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIEdlbmVyaWNHRlBvbHkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBmaWVsZCB0aGUge0BsaW5rIEdlbmVyaWNHRn0gaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBmaWVsZCB0byB1c2VcclxuICAgICAqIHRvIHBlcmZvcm0gY29tcHV0YXRpb25zXHJcbiAgICAgKiBAcGFyYW0gY29lZmZpY2llbnRzIGNvZWZmaWNpZW50cyBhcyBpbnRzIHJlcHJlc2VudGluZyBlbGVtZW50cyBvZiBHRihzaXplKSwgYXJyYW5nZWRcclxuICAgICAqIGZyb20gbW9zdCBzaWduaWZpY2FudCAoaGlnaGVzdC1wb3dlciB0ZXJtKSBjb2VmZmljaWVudCB0byBsZWFzdCBzaWduaWZpY2FudFxyXG4gICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYXJndW1lbnQgaXMgbnVsbCBvciBlbXB0eSxcclxuICAgICAqIG9yIGlmIGxlYWRpbmcgY29lZmZpY2llbnQgaXMgMCBhbmQgdGhpcyBpcyBub3QgYVxyXG4gICAgICogY29uc3RhbnQgcG9seW5vbWlhbCAodGhhdCBpcywgaXQgaXMgbm90IHRoZSBtb25vbWlhbCBcIjBcIilcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gR2VuZXJpY0dGUG9seShmaWVsZCwgY29lZmZpY2llbnRzKSB7XHJcbiAgICAgICAgaWYgKGNvZWZmaWNpZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xyXG4gICAgICAgIHZhciBjb2VmZmljaWVudHNMZW5ndGggPSBjb2VmZmljaWVudHMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChjb2VmZmljaWVudHNMZW5ndGggPiAxICYmIGNvZWZmaWNpZW50c1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBMZWFkaW5nIHRlcm0gbXVzdCBiZSBub24temVybyBmb3IgYW55dGhpbmcgZXhjZXB0IHRoZSBjb25zdGFudCBwb2x5bm9taWFsIFwiMFwiXHJcbiAgICAgICAgICAgIHZhciBmaXJzdE5vblplcm8gPSAxO1xyXG4gICAgICAgICAgICB3aGlsZSAoZmlyc3ROb25aZXJvIDwgY29lZmZpY2llbnRzTGVuZ3RoICYmIGNvZWZmaWNpZW50c1tmaXJzdE5vblplcm9dID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlyc3ROb25aZXJvID09PSBjb2VmZmljaWVudHNMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gSW50MzJBcnJheS5mcm9tKFswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvZWZmaWNpZW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZWZmaWNpZW50c0xlbmd0aCAtIGZpcnN0Tm9uWmVybyk7XHJcbiAgICAgICAgICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShjb2VmZmljaWVudHMsIGZpcnN0Tm9uWmVybywgdGhpcy5jb2VmZmljaWVudHMsIDAsIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gY29lZmZpY2llbnRzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLmdldENvZWZmaWNpZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIGRlZ3JlZSBvZiB0aGlzIHBvbHlub21pYWxcclxuICAgICAqL1xyXG4gICAgR2VuZXJpY0dGUG9seS5wcm90b3R5cGUuZ2V0RGVncmVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGggLSAxO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB0cnVlIGlmZiB0aGlzIHBvbHlub21pYWwgaXMgdGhlIG1vbm9taWFsIFwiMFwiXHJcbiAgICAgKi9cclxuICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHNbMF0gPT09IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIGNvZWZmaWNpZW50IG9mIHheZGVncmVlIHRlcm0gaW4gdGhpcyBwb2x5bm9taWFsXHJcbiAgICAgKi9cclxuICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLmdldENvZWZmaWNpZW50ID0gZnVuY3Rpb24gKGRlZ3JlZSAvKmludCovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29lZmZpY2llbnRzW3RoaXMuY29lZmZpY2llbnRzLmxlbmd0aCAtIDEgLSBkZWdyZWVdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBldmFsdWF0aW9uIG9mIHRoaXMgcG9seW5vbWlhbCBhdCBhIGdpdmVuIHBvaW50XHJcbiAgICAgKi9cclxuICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLmV2YWx1YXRlQXQgPSBmdW5jdGlvbiAoYSAvKmludCovKSB7XHJcbiAgICAgICAgaWYgKGEgPT09IDApIHtcclxuICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHheMCBjb2VmZmljaWVudFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2VmZmljaWVudCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgaWYgKGEgPT09IDEpIHtcclxuICAgICAgICAgICAgLy8gSnVzdCB0aGUgc3VtIG9mIHRoZSBjb2VmZmljaWVudHNcclxuICAgICAgICAgICAgcmVzdWx0ID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gY29lZmZpY2llbnRzLmxlbmd0aDsgaSAhPT0gbGVuZ3RoXzE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvZWZmaWNpZW50ID0gY29lZmZpY2llbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gQWJzdHJhY3RHZW5lcmljR0ZfMS5kZWZhdWx0LmFkZE9yU3VidHJhY3QocmVzdWx0LCBjb2VmZmljaWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0ID0gY29lZmZpY2llbnRzWzBdO1xyXG4gICAgICAgIHZhciBzaXplID0gY29lZmZpY2llbnRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IEFic3RyYWN0R2VuZXJpY0dGXzEuZGVmYXVsdC5hZGRPclN1YnRyYWN0KGZpZWxkLm11bHRpcGx5KGEsIHJlc3VsdCksIGNvZWZmaWNpZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJpY0dGUG9seS5wcm90b3R5cGUuYWRkT3JTdWJ0cmFjdCA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgIGlmICghdGhpcy5maWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdHZW5lcmljR0ZQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIEdlbmVyaWNHRiBmaWVsZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNtYWxsZXJDb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcclxuICAgICAgICB2YXIgbGFyZ2VyQ29lZmZpY2llbnRzID0gb3RoZXIuY29lZmZpY2llbnRzO1xyXG4gICAgICAgIGlmIChzbWFsbGVyQ29lZmZpY2llbnRzLmxlbmd0aCA+IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIHRlbXAgPSBzbWFsbGVyQ29lZmZpY2llbnRzO1xyXG4gICAgICAgICAgICBzbWFsbGVyQ29lZmZpY2llbnRzID0gbGFyZ2VyQ29lZmZpY2llbnRzO1xyXG4gICAgICAgICAgICBsYXJnZXJDb2VmZmljaWVudHMgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3VtRGlmZiA9IG5ldyBJbnQzMkFycmF5KGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHZhciBsZW5ndGhEaWZmID0gbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aCAtIHNtYWxsZXJDb2VmZmljaWVudHMubGVuZ3RoO1xyXG4gICAgICAgIC8vIENvcHkgaGlnaC1vcmRlciB0ZXJtcyBvbmx5IGZvdW5kIGluIGhpZ2hlci1kZWdyZWUgcG9seW5vbWlhbCdzIGNvZWZmaWNpZW50c1xyXG4gICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KGxhcmdlckNvZWZmaWNpZW50cywgMCwgc3VtRGlmZiwgMCwgbGVuZ3RoRGlmZik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbmd0aERpZmY7IGkgPCBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc3VtRGlmZltpXSA9IEFic3RyYWN0R2VuZXJpY0dGXzEuZGVmYXVsdC5hZGRPclN1YnRyYWN0KHNtYWxsZXJDb2VmZmljaWVudHNbaSAtIGxlbmd0aERpZmZdLCBsYXJnZXJDb2VmZmljaWVudHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNHRlBvbHkodGhpcy5maWVsZCwgc3VtRGlmZik7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJpY0dGUG9seS5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnR2VuZXJpY0dGUG9seXMgZG8gbm90IGhhdmUgc2FtZSBHZW5lcmljR0YgZmllbGQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkgfHwgb3RoZXIuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQuZ2V0WmVybygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYUNvZWZmaWNpZW50cyA9IHRoaXMuY29lZmZpY2llbnRzO1xyXG4gICAgICAgIHZhciBhTGVuZ3RoID0gYUNvZWZmaWNpZW50cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7XHJcbiAgICAgICAgdmFyIGJMZW5ndGggPSBiQ29lZmZpY2llbnRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KGFMZW5ndGggKyBiTGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYUNvZWZmID0gYUNvZWZmaWNpZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiTGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3RbaSArIGpdID0gQWJzdHJhY3RHZW5lcmljR0ZfMS5kZWZhdWx0LmFkZE9yU3VidHJhY3QocHJvZHVjdFtpICsgal0sIGZpZWxkLm11bHRpcGx5KGFDb2VmZiwgYkNvZWZmaWNpZW50c1tqXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgR2VuZXJpY0dGUG9seShmaWVsZCwgcHJvZHVjdCk7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJpY0dGUG9seS5wcm90b3R5cGUubXVsdGlwbHlTY2FsYXIgPSBmdW5jdGlvbiAoc2NhbGFyIC8qaW50Ki8pIHtcclxuICAgICAgICBpZiAoc2NhbGFyID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpZWxkLmdldFplcm8oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNjYWxhciA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZDtcclxuICAgICAgICB2YXIgcHJvZHVjdCA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xyXG4gICAgICAgIHZhciBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBwcm9kdWN0W2ldID0gZmllbGQubXVsdGlwbHkoY29lZmZpY2llbnRzW2ldLCBzY2FsYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNHRlBvbHkoZmllbGQsIHByb2R1Y3QpO1xyXG4gICAgfTtcclxuICAgIEdlbmVyaWNHRlBvbHkucHJvdG90eXBlLm11bHRpcGx5QnlNb25vbWlhbCA9IGZ1bmN0aW9uIChkZWdyZWUgLyppbnQqLywgY29lZmZpY2llbnQgLyppbnQqLykge1xyXG4gICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWVsZC5nZXRaZXJvKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcclxuICAgICAgICB2YXIgc2l6ZSA9IGNvZWZmaWNpZW50cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShzaXplICsgZGVncmVlKTtcclxuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHByb2R1Y3RbaV0gPSBmaWVsZC5tdWx0aXBseShjb2VmZmljaWVudHNbaV0sIGNvZWZmaWNpZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljR0ZQb2x5KGZpZWxkLCBwcm9kdWN0KTtcclxuICAgIH07XHJcbiAgICBHZW5lcmljR0ZQb2x5LnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnR2VuZXJpY0dGUG9seXMgZG8gbm90IGhhdmUgc2FtZSBHZW5lcmljR0YgZmllbGQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdEaXZpZGUgYnkgMCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkO1xyXG4gICAgICAgIHZhciBxdW90aWVudCA9IGZpZWxkLmdldFplcm8oKTtcclxuICAgICAgICB2YXIgcmVtYWluZGVyID0gdGhpcztcclxuICAgICAgICB2YXIgZGVub21pbmF0b3JMZWFkaW5nVGVybSA9IG90aGVyLmdldENvZWZmaWNpZW50KG90aGVyLmdldERlZ3JlZSgpKTtcclxuICAgICAgICB2YXIgaW52ZXJzZURlbm9taW5hdG9yTGVhZGluZ1Rlcm0gPSBmaWVsZC5pbnZlcnNlKGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xyXG4gICAgICAgIHdoaWxlIChyZW1haW5kZXIuZ2V0RGVncmVlKCkgPj0gb3RoZXIuZ2V0RGVncmVlKCkgJiYgIXJlbWFpbmRlci5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICB2YXIgZGVncmVlRGlmZmVyZW5jZSA9IHJlbWFpbmRlci5nZXREZWdyZWUoKSAtIG90aGVyLmdldERlZ3JlZSgpO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBmaWVsZC5tdWx0aXBseShyZW1haW5kZXIuZ2V0Q29lZmZpY2llbnQocmVtYWluZGVyLmdldERlZ3JlZSgpKSwgaW52ZXJzZURlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xyXG4gICAgICAgICAgICB2YXIgdGVybSA9IG90aGVyLm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmZXJlbmNlLCBzY2FsZSk7XHJcbiAgICAgICAgICAgIHZhciBpdGVyYXRpb25RdW90aWVudCA9IGZpZWxkLmJ1aWxkTW9ub21pYWwoZGVncmVlRGlmZmVyZW5jZSwgc2NhbGUpO1xyXG4gICAgICAgICAgICBxdW90aWVudCA9IHF1b3RpZW50LmFkZE9yU3VidHJhY3QoaXRlcmF0aW9uUXVvdGllbnQpO1xyXG4gICAgICAgICAgICByZW1haW5kZXIgPSByZW1haW5kZXIuYWRkT3JTdWJ0cmFjdCh0ZXJtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtxdW90aWVudCwgcmVtYWluZGVyXTtcclxuICAgIH07XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBHZW5lcmljR0ZQb2x5LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgZm9yICh2YXIgZGVncmVlID0gdGhpcy5nZXREZWdyZWUoKTsgZGVncmVlID49IDA7IGRlZ3JlZS0tKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2VmZmljaWVudCA9IHRoaXMuZ2V0Q29lZmZpY2llbnQoZGVncmVlKTtcclxuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcgLSAnO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZWZmaWNpZW50ID0gLWNvZWZmaWNpZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnICsgJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAwIHx8IGNvZWZmaWNpZW50ICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFscGhhUG93ZXIgPSB0aGlzLmZpZWxkLmxvZyhjb2VmZmljaWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhUG93ZXIgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcxJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYWxwaGFQb3dlciA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ2EnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdhXic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBhbHBoYVBvd2VyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkZWdyZWUgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAneCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ3heJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGRlZ3JlZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gR2VuZXJpY0dGUG9seTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gR2VuZXJpY0dGUG9seTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJpY0dGUG9seS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uIHsqL1xyXG52YXIgR2VuZXJpY0dGXzEgPSByZXF1aXJlKFwiLi9HZW5lcmljR0ZcIik7XHJcbnZhciBHZW5lcmljR0ZQb2x5XzEgPSByZXF1aXJlKFwiLi9HZW5lcmljR0ZQb2x5XCIpO1xyXG52YXIgUmVlZFNvbG9tb25FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9SZWVkU29sb21vbkV4Y2VwdGlvblwiKTtcclxudmFyIElsbGVnYWxTdGF0ZUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIDxwPkltcGxlbWVudHMgUmVlZC1Tb2xvbW9uIGRlY29kaW5nLCBhcyB0aGUgbmFtZSBpbXBsaWVzLjwvcD5cclxuICpcclxuICogPHA+VGhlIGFsZ29yaXRobSB3aWxsIG5vdCBiZSBleHBsYWluZWQgaGVyZSwgYnV0IHRoZSBmb2xsb3dpbmcgcmVmZXJlbmNlcyB3ZXJlIGhlbHBmdWxcclxuICogaW4gY3JlYXRpbmcgdGhpcyBpbXBsZW1lbnRhdGlvbjo8L3A+XHJcbiAqXHJcbiAqIDx1bD5cclxuICogPGxpPkJydWNlIE1hZ2dzLlxyXG4gKiA8YSBocmVmPVwiaHR0cDovL3d3dy5jcy5jbXUuZWR1L2Fmcy9jcy5jbXUuZWR1L3Byb2plY3QvcHNjaWNvLWd1eWIvcmVhbHdvcmxkL3d3dy9yc19kZWNvZGUucHNcIj5cclxuICogXCJEZWNvZGluZyBSZWVkLVNvbG9tb24gQ29kZXNcIjwvYT4gKHNlZSBkaXNjdXNzaW9uIG9mIEZvcm5leSdzIEZvcm11bGEpPC9saT5cclxuICogPGxpPkouSS4gSGFsbC4gPGEgaHJlZj1cInd3dy5tdGgubXN1LmVkdS9+amhhbGwvY2xhc3Nlcy9jb2Rlbm90ZXMvR1JTLnBkZlwiPlxyXG4gKiBcIkNoYXB0ZXIgNS4gR2VuZXJhbGl6ZWQgUmVlZC1Tb2xvbW9uIENvZGVzXCI8L2E+XHJcbiAqIChzZWUgZGlzY3Vzc2lvbiBvZiBFdWNsaWRlYW4gYWxnb3JpdGhtKTwvbGk+XHJcbiAqIDwvdWw+XHJcbiAqXHJcbiAqIDxwPk11Y2ggY3JlZGl0IGlzIGR1ZSB0byBXaWxsaWFtIFJ1Y2tsaWRnZSBzaW5jZSBwb3J0aW9ucyBvZiB0aGlzIGNvZGUgYXJlIGFuIGluZGlyZWN0XHJcbiAqIHBvcnQgb2YgaGlzIEMrKyBSZWVkLVNvbG9tb24gaW1wbGVtZW50YXRpb24uPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKiBAYXV0aG9yIFdpbGxpYW0gUnVja2xpZGdlXHJcbiAqIEBhdXRob3Igc2FuZm9yZHNxdWlyZXNcclxuICovXHJcbnZhciBSZWVkU29sb21vbkRlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSZWVkU29sb21vbkRlY29kZXIoZmllbGQpIHtcclxuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIDxwPkRlY29kZXMgZ2l2ZW4gc2V0IG9mIHJlY2VpdmVkIGNvZGV3b3Jkcywgd2hpY2ggaW5jbHVkZSBib3RoIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb25cclxuICAgICAqIGNvZGV3b3Jkcy4gUmVhbGx5LCB0aGlzIG1lYW5zIGl0IHVzZXMgUmVlZC1Tb2xvbW9uIHRvIGRldGVjdCBhbmQgY29ycmVjdCBlcnJvcnMsIGluLXBsYWNlLFxyXG4gICAgICogaW4gdGhlIGlucHV0LjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZWQgZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHNcclxuICAgICAqIEBwYXJhbSB0d29TIG51bWJlciBvZiBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyBhdmFpbGFibGVcclxuICAgICAqIEB0aHJvd3MgUmVlZFNvbG9tb25FeGNlcHRpb24gaWYgZGVjb2RpbmcgZmFpbHMgZm9yIGFueSByZWFzb25cclxuICAgICAqL1xyXG4gICAgUmVlZFNvbG9tb25EZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVjZWl2ZWQsIHR3b1MgLyppbnQqLykge1xyXG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQ7XHJcbiAgICAgICAgdmFyIHBvbHkgPSBuZXcgR2VuZXJpY0dGUG9seV8xLmRlZmF1bHQoZmllbGQsIHJlY2VpdmVkKTtcclxuICAgICAgICB2YXIgc3luZHJvbWVDb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheSh0d29TKTtcclxuICAgICAgICB2YXIgbm9FcnJvciA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0d29TOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGV2YWxSZXN1bHQgPSBwb2x5LmV2YWx1YXRlQXQoZmllbGQuZXhwKGkgKyBmaWVsZC5nZXRHZW5lcmF0b3JCYXNlKCkpKTtcclxuICAgICAgICAgICAgc3luZHJvbWVDb2VmZmljaWVudHNbc3luZHJvbWVDb2VmZmljaWVudHMubGVuZ3RoIC0gMSAtIGldID0gZXZhbFJlc3VsdDtcclxuICAgICAgICAgICAgaWYgKGV2YWxSZXN1bHQgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIG5vRXJyb3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9FcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzeW5kcm9tZSA9IG5ldyBHZW5lcmljR0ZQb2x5XzEuZGVmYXVsdChmaWVsZCwgc3luZHJvbWVDb2VmZmljaWVudHMpO1xyXG4gICAgICAgIHZhciBzaWdtYU9tZWdhID0gdGhpcy5ydW5FdWNsaWRlYW5BbGdvcml0aG0oZmllbGQuYnVpbGRNb25vbWlhbCh0d29TLCAxKSwgc3luZHJvbWUsIHR3b1MpO1xyXG4gICAgICAgIHZhciBzaWdtYSA9IHNpZ21hT21lZ2FbMF07XHJcbiAgICAgICAgdmFyIG9tZWdhID0gc2lnbWFPbWVnYVsxXTtcclxuICAgICAgICB2YXIgZXJyb3JMb2NhdGlvbnMgPSB0aGlzLmZpbmRFcnJvckxvY2F0aW9ucyhzaWdtYSk7XHJcbiAgICAgICAgdmFyIGVycm9yTWFnbml0dWRlcyA9IHRoaXMuZmluZEVycm9yTWFnbml0dWRlcyhvbWVnYSwgZXJyb3JMb2NhdGlvbnMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3JMb2NhdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gcmVjZWl2ZWQubGVuZ3RoIC0gMSAtIGZpZWxkLmxvZyhlcnJvckxvY2F0aW9uc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0JhZCBlcnJvciBsb2NhdGlvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlY2VpdmVkW3Bvc2l0aW9uXSA9IEdlbmVyaWNHRl8xLmRlZmF1bHQuYWRkT3JTdWJ0cmFjdChyZWNlaXZlZFtwb3NpdGlvbl0sIGVycm9yTWFnbml0dWRlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlZWRTb2xvbW9uRGVjb2Rlci5wcm90b3R5cGUucnVuRXVjbGlkZWFuQWxnb3JpdGhtID0gZnVuY3Rpb24gKGEsIGIsIFIgLyppbnQqLykge1xyXG4gICAgICAgIC8vIEFzc3VtZSBhJ3MgZGVncmVlIGlzID49IGInc1xyXG4gICAgICAgIGlmIChhLmdldERlZ3JlZSgpIDwgYi5nZXREZWdyZWUoKSkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGE7XHJcbiAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICBiID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZDtcclxuICAgICAgICB2YXIgckxhc3QgPSBhO1xyXG4gICAgICAgIHZhciByID0gYjtcclxuICAgICAgICB2YXIgdExhc3QgPSBmaWVsZC5nZXRaZXJvKCk7XHJcbiAgICAgICAgdmFyIHQgPSBmaWVsZC5nZXRPbmUoKTtcclxuICAgICAgICAvLyBSdW4gRXVjbGlkZWFuIGFsZ29yaXRobSB1bnRpbCByJ3MgZGVncmVlIGlzIGxlc3MgdGhhbiBSLzJcclxuICAgICAgICB3aGlsZSAoci5nZXREZWdyZWUoKSA+PSAoUiAvIDIgfCAwKSkge1xyXG4gICAgICAgICAgICB2YXIgckxhc3RMYXN0ID0gckxhc3Q7XHJcbiAgICAgICAgICAgIHZhciB0TGFzdExhc3QgPSB0TGFzdDtcclxuICAgICAgICAgICAgckxhc3QgPSByO1xyXG4gICAgICAgICAgICB0TGFzdCA9IHQ7XHJcbiAgICAgICAgICAgIC8vIERpdmlkZSByTGFzdExhc3QgYnkgckxhc3QsIHdpdGggcXVvdGllbnQgaW4gcSBhbmQgcmVtYWluZGVyIGluIHJcclxuICAgICAgICAgICAgaWYgKHJMYXN0LmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPb3BzLCBFdWNsaWRlYW4gYWxnb3JpdGhtIGFscmVhZHkgdGVybWluYXRlZD9cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWVkU29sb21vbkV4Y2VwdGlvbl8xLmRlZmF1bHQoJ3Jfe2ktMX0gd2FzIHplcm8nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByID0gckxhc3RMYXN0O1xyXG4gICAgICAgICAgICB2YXIgcSA9IGZpZWxkLmdldFplcm8oKTtcclxuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yTGVhZGluZ1Rlcm0gPSByTGFzdC5nZXRDb2VmZmljaWVudChyTGFzdC5nZXREZWdyZWUoKSk7XHJcbiAgICAgICAgICAgIHZhciBkbHRJbnZlcnNlID0gZmllbGQuaW52ZXJzZShkZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcclxuICAgICAgICAgICAgd2hpbGUgKHIuZ2V0RGVncmVlKCkgPj0gckxhc3QuZ2V0RGVncmVlKCkgJiYgIXIuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZWdyZWVEaWZmID0gci5nZXREZWdyZWUoKSAtIHJMYXN0LmdldERlZ3JlZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gZmllbGQubXVsdGlwbHkoci5nZXRDb2VmZmljaWVudChyLmdldERlZ3JlZSgpKSwgZGx0SW52ZXJzZSk7XHJcbiAgICAgICAgICAgICAgICBxID0gcS5hZGRPclN1YnRyYWN0KGZpZWxkLmJ1aWxkTW9ub21pYWwoZGVncmVlRGlmZiwgc2NhbGUpKTtcclxuICAgICAgICAgICAgICAgIHIgPSByLmFkZE9yU3VidHJhY3Qockxhc3QubXVsdGlwbHlCeU1vbm9taWFsKGRlZ3JlZURpZmYsIHNjYWxlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdCA9IHEubXVsdGlwbHkodExhc3QpLmFkZE9yU3VidHJhY3QodExhc3RMYXN0KTtcclxuICAgICAgICAgICAgaWYgKHIuZ2V0RGVncmVlKCkgPj0gckxhc3QuZ2V0RGVncmVlKCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMS5kZWZhdWx0KCdEaXZpc2lvbiBhbGdvcml0aG0gZmFpbGVkIHRvIHJlZHVjZSBwb2x5bm9taWFsPycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaWdtYVRpbGRlQXRaZXJvID0gdC5nZXRDb2VmZmljaWVudCgwKTtcclxuICAgICAgICBpZiAoc2lnbWFUaWxkZUF0WmVybyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVlZFNvbG9tb25FeGNlcHRpb25fMS5kZWZhdWx0KCdzaWdtYVRpbGRlKDApIHdhcyB6ZXJvJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbnZlcnNlID0gZmllbGQuaW52ZXJzZShzaWdtYVRpbGRlQXRaZXJvKTtcclxuICAgICAgICB2YXIgc2lnbWEgPSB0Lm11bHRpcGx5U2NhbGFyKGludmVyc2UpO1xyXG4gICAgICAgIHZhciBvbWVnYSA9IHIubXVsdGlwbHlTY2FsYXIoaW52ZXJzZSk7XHJcbiAgICAgICAgcmV0dXJuIFtzaWdtYSwgb21lZ2FdO1xyXG4gICAgfTtcclxuICAgIFJlZWRTb2xvbW9uRGVjb2Rlci5wcm90b3R5cGUuZmluZEVycm9yTG9jYXRpb25zID0gZnVuY3Rpb24gKGVycm9yTG9jYXRvcikge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYSBkaXJlY3QgYXBwbGljYXRpb24gb2YgQ2hpZW4ncyBzZWFyY2hcclxuICAgICAgICB2YXIgbnVtRXJyb3JzID0gZXJyb3JMb2NhdG9yLmdldERlZ3JlZSgpO1xyXG4gICAgICAgIGlmIChudW1FcnJvcnMgPT09IDEpIHsgLy8gc2hvcnRjdXRcclxuICAgICAgICAgICAgcmV0dXJuIEludDMyQXJyYXkuZnJvbShbZXJyb3JMb2NhdG9yLmdldENvZWZmaWNpZW50KDEpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW50MzJBcnJheShudW1FcnJvcnMpO1xyXG4gICAgICAgIHZhciBlID0gMDtcclxuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZmllbGQuZ2V0U2l6ZSgpICYmIGUgPCBudW1FcnJvcnM7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JMb2NhdG9yLmV2YWx1YXRlQXQoaSkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtlXSA9IGZpZWxkLmludmVyc2UoaSk7XHJcbiAgICAgICAgICAgICAgICBlKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGUgIT09IG51bUVycm9ycykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVlZFNvbG9tb25FeGNlcHRpb25fMS5kZWZhdWx0KCdFcnJvciBsb2NhdG9yIGRlZ3JlZSBkb2VzIG5vdCBtYXRjaCBudW1iZXIgb2Ygcm9vdHMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBSZWVkU29sb21vbkRlY29kZXIucHJvdG90eXBlLmZpbmRFcnJvck1hZ25pdHVkZXMgPSBmdW5jdGlvbiAoZXJyb3JFdmFsdWF0b3IsIGVycm9yTG9jYXRpb25zKSB7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBkaXJlY3RseSBhcHBseWluZyBGb3JuZXkncyBGb3JtdWxhXHJcbiAgICAgICAgdmFyIHMgPSBlcnJvckxvY2F0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KHMpO1xyXG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGQ7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHhpSW52ZXJzZSA9IGZpZWxkLmludmVyc2UoZXJyb3JMb2NhdGlvbnNbaV0pO1xyXG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSAxO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IGopIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBkZW5vbWluYXRvciA9IGZpZWxkLm11bHRpcGx5KGRlbm9taW5hdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIEdlbmVyaWNHRi5hZGRPclN1YnRyYWN0KDEsIGZpZWxkLm11bHRpcGx5KGVycm9yTG9jYXRpb25zW2pdLCB4aUludmVyc2UpKSlcclxuICAgICAgICAgICAgICAgICAgICAvLyBBYm92ZSBzaG91bGQgd29yayBidXQgZmFpbHMgb24gc29tZSBBcHBsZSBhbmQgTGludXggSkRLcyBkdWUgdG8gYSBIb3RzcG90IGJ1Zy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBCZWxvdyBpcyBhIGZ1bm55LWxvb2tpbmcgd29ya2Fyb3VuZCBmcm9tIFN0ZXZlbiBQYXJrZXNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGVybSA9IGZpZWxkLm11bHRpcGx5KGVycm9yTG9jYXRpb25zW2pdLCB4aUludmVyc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXJtUGx1czEgPSAodGVybSAmIDB4MSkgPT09IDAgPyB0ZXJtIHwgMSA6IHRlcm0gJiB+MTtcclxuICAgICAgICAgICAgICAgICAgICBkZW5vbWluYXRvciA9IGZpZWxkLm11bHRpcGx5KGRlbm9taW5hdG9yLCB0ZXJtUGx1czEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IGZpZWxkLm11bHRpcGx5KGVycm9yRXZhbHVhdG9yLmV2YWx1YXRlQXQoeGlJbnZlcnNlKSwgZmllbGQuaW52ZXJzZShkZW5vbWluYXRvcikpO1xyXG4gICAgICAgICAgICBpZiAoZmllbGQuZ2V0R2VuZXJhdG9yQmFzZSgpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSBmaWVsZC5tdWx0aXBseShyZXN1bHRbaV0sIHhpSW52ZXJzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVlZFNvbG9tb25EZWNvZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSZWVkU29sb21vbkRlY29kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZWRTb2xvbW9uRGVjb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBHZW5lcmljR0ZQb2x5XzEgPSByZXF1aXJlKFwiLi9HZW5lcmljR0ZQb2x5XCIpO1xyXG52YXIgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TeXN0ZW1cIik7XHJcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiA8cD5JbXBsZW1lbnRzIFJlZWQtU29sb21vbiBlbmNvZGluZywgYXMgdGhlIG5hbWUgaW1wbGllcy48L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqIEBhdXRob3IgV2lsbGlhbSBSdWNrbGlkZ2VcclxuICovXHJcbnZhciBSZWVkU29sb21vbkVuY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEEgcmVlZCBzb2xvbW9uIGVycm9yLWNvcnJlY3RpbmcgZW5jb2RpbmcgY29uc3RydWN0b3IgaXMgY3JlYXRlZCBieVxyXG4gICAgICogcGFzc2luZyBhcyBHYWxvaXMgRmllbGQgd2l0aCBvZiBzaXplIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgY29kZVxyXG4gICAgICogd29yZHMgKHN5bWJvbHMpIGluIHRoZSBhbHBoYWJldCAodGhlIG51bWJlciBvZiB2YWx1ZXMgaW4gZWFjaFxyXG4gICAgICogZWxlbWVudCBvZiBhcnJheXMgdGhhdCBhcmUgZW5jb2RlZC9kZWNvZGVkKS5cclxuICAgICAqIEBwYXJhbSBmaWVsZCBBIGdhbG9pcyBmaWVsZCB3aXRoIGEgbnVtYmVyIG9mIGVsZW1lbnRzIGVxdWFsIHRvIHRoZSBzaXplXHJcbiAgICAgKiBvZiB0aGUgYWxwaGFiZXQgb2Ygc3ltYm9scyB0byBlbmNvZGUuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlZWRTb2xvbW9uRW5jb2RlcihmaWVsZCkge1xyXG4gICAgICAgIHRoaXMuZmllbGQgPSBmaWVsZDtcclxuICAgICAgICB0aGlzLmNhY2hlZEdlbmVyYXRvcnMgPSBbXTtcclxuICAgICAgICB0aGlzLmNhY2hlZEdlbmVyYXRvcnMucHVzaChuZXcgR2VuZXJpY0dGUG9seV8xLmRlZmF1bHQoZmllbGQsIEludDMyQXJyYXkuZnJvbShbMV0pKSk7XHJcbiAgICB9XHJcbiAgICBSZWVkU29sb21vbkVuY29kZXIucHJvdG90eXBlLmJ1aWxkR2VuZXJhdG9yID0gZnVuY3Rpb24gKGRlZ3JlZSAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIGNhY2hlZEdlbmVyYXRvcnMgPSB0aGlzLmNhY2hlZEdlbmVyYXRvcnM7XHJcbiAgICAgICAgaWYgKGRlZ3JlZSA+PSBjYWNoZWRHZW5lcmF0b3JzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgbGFzdEdlbmVyYXRvciA9IGNhY2hlZEdlbmVyYXRvcnNbY2FjaGVkR2VuZXJhdG9ycy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgdmFyIGZpZWxkID0gdGhpcy5maWVsZDtcclxuICAgICAgICAgICAgZm9yICh2YXIgZCA9IGNhY2hlZEdlbmVyYXRvcnMubGVuZ3RoOyBkIDw9IGRlZ3JlZTsgZCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEdlbmVyYXRvciA9IGxhc3RHZW5lcmF0b3IubXVsdGlwbHkobmV3IEdlbmVyaWNHRlBvbHlfMS5kZWZhdWx0KGZpZWxkLCBJbnQzMkFycmF5LmZyb20oWzEsIGZpZWxkLmV4cChkIC0gMSArIGZpZWxkLmdldEdlbmVyYXRvckJhc2UoKSldKSkpO1xyXG4gICAgICAgICAgICAgICAgY2FjaGVkR2VuZXJhdG9ycy5wdXNoKG5leHRHZW5lcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgbGFzdEdlbmVyYXRvciA9IG5leHRHZW5lcmF0b3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZEdlbmVyYXRvcnNbZGVncmVlXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPkVuY29kZSBhIHNlcXVlbmNlIG9mIGNvZGUgd29yZHMgKHN5bWJvbHMpIHVzaW5nIFJlZWQtU29sb21vbiB0byBhbGxvdyBkZWNvZGVyc1xyXG4gICAgICogdG8gZGV0ZWN0IGFuZCBjb3JyZWN0IGVycm9ycyB0aGF0IG1heSBoYXZlIGJlZW4gaW50cm9kdWNlZCB3aGVuIHRoZSByZXN1bHRpbmdcclxuICAgICAqIGRhdGEgaXMgc3RvcmVkIG9yIHRyYW5zbWl0dGVkLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdG9FbmNvZGUgYXJyYXkgdXNlZCBmb3IgYm90aCBhbmQgb3V0cHV0LiBDYWxsZXIgaW5pdGlhbGl6ZXMgdGhlIGFycmF5IHdpdGhcclxuICAgICAqIHRoZSBjb2RlIHdvcmRzIChzeW1ib2xzKSB0byBiZSBlbmNvZGVkIGZvbGxvd2VkIGJ5IGVtcHR5IGVsZW1lbnRzIGFsbG9jYXRlZCB0byBtYWtlXHJcbiAgICAgKiBzcGFjZSBmb3IgZXJyb3ItY29ycmVjdGlvbiBjb2RlIHdvcmRzIGluIHRoZSBlbmNvZGVkIG91dHB1dC4gVGhlIGFycmF5IGNvbnRhaW5zXHJcbiAgICAgKiB0aGUgZW5jZG9kZWQgb3V0cHV0IHdoZW4gZW5jb2RlIHJldHVybnMuIENvZGUgd29yZHMgYXJlIGVuY29kZWQgYXMgbnVtYmVycyBmcm9tXHJcbiAgICAgKiAwIHRvIG4tMSwgd2hlcmUgbiBpcyB0aGUgbnVtYmVyIG9mIHBvc3NpYmxlIGNvZGUgd29yZHMgKHN5bWJvbHMpLCBhcyBkZXRlcm1pbmVkXHJcbiAgICAgKiBieSB0aGUgc2l6ZSBvZiB0aGUgR2Fsb2lzIEZpZWxkIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3Igb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0gZWNCeXRlcyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIHJlc2VydmVkIGluIHRoZSBhcnJheSAoZmlyc3QgcGFyYW1ldGVyKVxyXG4gICAgICogdG8gc3RvcmUgZXJyb3ItY29ycmVjdGlvbiBjb2RlIHdvcmRzLiBUaHVzLCB0aGUgbnVtYmVyIG9mIGNvZGUgd29yZHMgKHN5bWJvbHMpXHJcbiAgICAgKiB0byBlbmNvZGUgaW4gdGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aHVzIHRvRW5jb2RlLmxlbmd0aCAtIGVjQnl0ZXMuXHJcbiAgICAgKiBOb3RlLCB0aGUgdXNlIG9mIFwiYnl0ZXNcIiBpbiB0aGUgbmFtZSBvZiB0aGlzIHBhcmFtZXRlciBpcyBtaXNsZWFkaW5nLCBhcyB0aGVyZSBtYXlcclxuICAgICAqIGJlIG1vcmUgb3IgZmV3ZXIgdGhhbiAyNTYgc3ltYm9scyBiZWluZyBlbmNvZGVkLCBhcyBkZXRlcm1pbmVkIGJ5IHRoZSBudW1iZXIgb2ZcclxuICAgICAqIGVsZW1lbnRzIGluIHRoZSBHYWxvaXMgRmllbGQgcGFzc2VkIGFzIGEgY29uc3RydWN0b3IgdG8gdGhpcyBvYmplY3QuXHJcbiAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiB0aHJvd24gaW4gcmVzcG9uc2UgdG8gdmFsaWRhdGlvbiBlcnJyb3MuXHJcbiAgICAgKi9cclxuICAgIFJlZWRTb2xvbW9uRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHRvRW5jb2RlLCBlY0J5dGVzIC8qaW50Ki8pIHtcclxuICAgICAgICBpZiAoZWNCeXRlcyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnTm8gZXJyb3IgY29ycmVjdGlvbiBieXRlcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGF0YUJ5dGVzID0gdG9FbmNvZGUubGVuZ3RoIC0gZWNCeXRlcztcclxuICAgICAgICBpZiAoZGF0YUJ5dGVzIDw9IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ05vIGRhdGEgYnl0ZXMgcHJvdmlkZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IHRoaXMuYnVpbGRHZW5lcmF0b3IoZWNCeXRlcyk7XHJcbiAgICAgICAgdmFyIGluZm9Db2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShkYXRhQnl0ZXMpO1xyXG4gICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KHRvRW5jb2RlLCAwLCBpbmZvQ29lZmZpY2llbnRzLCAwLCBkYXRhQnl0ZXMpO1xyXG4gICAgICAgIHZhciBpbmZvID0gbmV3IEdlbmVyaWNHRlBvbHlfMS5kZWZhdWx0KHRoaXMuZmllbGQsIGluZm9Db2VmZmljaWVudHMpO1xyXG4gICAgICAgIGluZm8gPSBpbmZvLm11bHRpcGx5QnlNb25vbWlhbChlY0J5dGVzLCAxKTtcclxuICAgICAgICB2YXIgcmVtYWluZGVyID0gaW5mby5kaXZpZGUoZ2VuZXJhdG9yKVsxXTtcclxuICAgICAgICB2YXIgY29lZmZpY2llbnRzID0gcmVtYWluZGVyLmdldENvZWZmaWNpZW50cygpO1xyXG4gICAgICAgIHZhciBudW1aZXJvQ29lZmZpY2llbnRzID0gZWNCeXRlcyAtIGNvZWZmaWNpZW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1aZXJvQ29lZmZpY2llbnRzOyBpKyspIHtcclxuICAgICAgICAgICAgdG9FbmNvZGVbZGF0YUJ5dGVzICsgaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShjb2VmZmljaWVudHMsIDAsIHRvRW5jb2RlLCBkYXRhQnl0ZXMgKyBudW1aZXJvQ29lZmZpY2llbnRzLCBjb2VmZmljaWVudHMubGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUmVlZFNvbG9tb25FbmNvZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSZWVkU29sb21vbkVuY29kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlZWRTb2xvbW9uRW5jb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vZGVjb2Rlci9EZWNvZGVyXCIpO1xyXG52YXIgUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0XCIpO1xyXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XHJcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0RlY29kZUhpbnRUeXBlXCIpO1xyXG52YXIgUmVzdWx0TWV0YWRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0TWV0YWRhdGFUeXBlXCIpO1xyXG52YXIgQml0TWF0cml4XzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0JpdE1hdHJpeFwiKTtcclxudmFyIERldGVjdG9yXzEgPSByZXF1aXJlKFwiLi9kZXRlY3Rvci9EZXRlY3RvclwiKTtcclxudmFyIFN5c3RlbV8xID0gcmVxdWlyZShcIi4uL3V0aWwvU3lzdGVtXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG4vKipcclxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjYW4gZGV0ZWN0IGFuZCBkZWNvZGUgRGF0YSBNYXRyaXggY29kZXMgaW4gYW4gaW1hZ2UuXHJcbiAqXHJcbiAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxyXG4gKi9cclxudmFyIERhdGFNYXRyaXhSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhTWF0cml4UmVhZGVyKCkge1xyXG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBEZWNvZGVyXzEuZGVmYXVsdCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2NhdGVzIGFuZCBkZWNvZGVzIGEgRGF0YSBNYXRyaXggY29kZSBpbiBhbiBpbWFnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIGEgU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY29udGVudCBlbmNvZGVkIGJ5IHRoZSBEYXRhIE1hdHJpeCBjb2RlXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZm91bmRcclxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgRGF0YSBNYXRyaXggY29kZSBjYW5ub3QgYmUgZGVjb2RlZFxyXG4gICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXHJcbiAgICAgKi9cclxuICAgIC8vIEBPdmVycmlkZVxyXG4gICAgLy8gcHVibGljIFJlc3VsdCBkZWNvZGUoQmluYXJ5Qml0bWFwIGltYWdlKSB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24sIENoZWNrc3VtRXhjZXB0aW9uLCBGb3JtYXRFeGNlcHRpb24ge1xyXG4gICAgLy8gICByZXR1cm4gZGVjb2RlKGltYWdlLCBudWxsKTtcclxuICAgIC8vIH1cclxuICAgIC8vIEBPdmVycmlkZVxyXG4gICAgRGF0YU1hdHJpeFJlYWRlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGltYWdlLCBoaW50cykge1xyXG4gICAgICAgIGlmIChoaW50cyA9PT0gdm9pZCAwKSB7IGhpbnRzID0gbnVsbDsgfVxyXG4gICAgICAgIHZhciBkZWNvZGVyUmVzdWx0O1xyXG4gICAgICAgIHZhciBwb2ludHM7XHJcbiAgICAgICAgaWYgKGhpbnRzICE9IG51bGwgJiYgaGludHMuaGFzKERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5QVVJFX0JBUkNPREUpKSB7XHJcbiAgICAgICAgICAgIHZhciBiaXRzID0gRGF0YU1hdHJpeFJlYWRlci5leHRyYWN0UHVyZUJpdHMoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSk7XHJcbiAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSB0aGlzLmRlY29kZXIuZGVjb2RlKGJpdHMpO1xyXG4gICAgICAgICAgICBwb2ludHMgPSBEYXRhTWF0cml4UmVhZGVyLk5PX1BPSU5UUztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBkZXRlY3RvclJlc3VsdCA9IG5ldyBEZXRlY3Rvcl8xLmRlZmF1bHQoaW1hZ2UuZ2V0QmxhY2tNYXRyaXgoKSkuZGV0ZWN0KCk7XHJcbiAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSB0aGlzLmRlY29kZXIuZGVjb2RlKGRldGVjdG9yUmVzdWx0LmdldEJpdHMoKSk7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IGRldGVjdG9yUmVzdWx0LmdldFBvaW50cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmF3Qnl0ZXMgPSBkZWNvZGVyUmVzdWx0LmdldFJhd0J5dGVzKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBSZXN1bHRfMS5kZWZhdWx0KGRlY29kZXJSZXN1bHQuZ2V0VGV4dCgpLCByYXdCeXRlcywgOCAqIHJhd0J5dGVzLmxlbmd0aCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5EQVRBX01BVFJJWCwgU3lzdGVtXzEuZGVmYXVsdC5jdXJyZW50VGltZU1pbGxpcygpKTtcclxuICAgICAgICB2YXIgYnl0ZVNlZ21lbnRzID0gZGVjb2RlclJlc3VsdC5nZXRCeXRlU2VnbWVudHMoKTtcclxuICAgICAgICBpZiAoYnl0ZVNlZ21lbnRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuQllURV9TRUdNRU5UUywgYnl0ZVNlZ21lbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVjTGV2ZWwgPSBkZWNvZGVyUmVzdWx0LmdldEVDTGV2ZWwoKTtcclxuICAgICAgICBpZiAoZWNMZXZlbCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0LkVSUk9SX0NPUlJFQ1RJT05fTEVWRUwsIGVjTGV2ZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8vIEBPdmVycmlkZVxyXG4gICAgRGF0YU1hdHJpeFJlYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgZGV0ZWN0cyBhIGNvZGUgaW4gYSBcInB1cmVcIiBpbWFnZSAtLSB0aGF0IGlzLCBwdXJlIG1vbm9jaHJvbWUgaW1hZ2VcclxuICAgICAqIHdoaWNoIGNvbnRhaW5zIG9ubHkgYW4gdW5yb3RhdGVkLCB1bnNrZXdlZCwgaW1hZ2Ugb2YgYSBjb2RlLCB3aXRoIHNvbWUgd2hpdGUgYm9yZGVyXHJcbiAgICAgKiBhcm91bmQgaXQuIFRoaXMgaXMgYSBzcGVjaWFsaXplZCBtZXRob2QgdGhhdCB3b3JrcyBleGNlcHRpb25hbGx5IGZhc3QgaW4gdGhpcyBzcGVjaWFsXHJcbiAgICAgKiBjYXNlLlxyXG4gICAgICpcclxuICAgICAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuUVJDb2RlUmVhZGVyI2V4dHJhY3RQdXJlQml0cyhCaXRNYXRyaXgpXHJcbiAgICAgKi9cclxuICAgIERhdGFNYXRyaXhSZWFkZXIuZXh0cmFjdFB1cmVCaXRzID0gZnVuY3Rpb24gKGltYWdlKSB7XHJcbiAgICAgICAgdmFyIGxlZnRUb3BCbGFjayA9IGltYWdlLmdldFRvcExlZnRPbkJpdCgpO1xyXG4gICAgICAgIHZhciByaWdodEJvdHRvbUJsYWNrID0gaW1hZ2UuZ2V0Qm90dG9tUmlnaHRPbkJpdCgpO1xyXG4gICAgICAgIGlmIChsZWZ0VG9wQmxhY2sgPT0gbnVsbCB8fCByaWdodEJvdHRvbUJsYWNrID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IHRoaXMubW9kdWxlU2l6ZShsZWZ0VG9wQmxhY2ssIGltYWdlKTtcclxuICAgICAgICB2YXIgdG9wID0gbGVmdFRvcEJsYWNrWzFdO1xyXG4gICAgICAgIHZhciBib3R0b20gPSByaWdodEJvdHRvbUJsYWNrWzFdO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gbGVmdFRvcEJsYWNrWzBdO1xyXG4gICAgICAgIHZhciByaWdodCA9IHJpZ2h0Qm90dG9tQmxhY2tbMF07XHJcbiAgICAgICAgdmFyIG1hdHJpeFdpZHRoID0gKHJpZ2h0IC0gbGVmdCArIDEpIC8gbW9kdWxlU2l6ZTtcclxuICAgICAgICB2YXIgbWF0cml4SGVpZ2h0ID0gKGJvdHRvbSAtIHRvcCArIDEpIC8gbW9kdWxlU2l6ZTtcclxuICAgICAgICBpZiAobWF0cml4V2lkdGggPD0gMCB8fCBtYXRyaXhIZWlnaHQgPD0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFB1c2ggaW4gdGhlIFwiYm9yZGVyXCIgYnkgaGFsZiB0aGUgbW9kdWxlIHdpZHRoIHNvIHRoYXQgd2Ugc3RhcnRcclxuICAgICAgICAvLyBzYW1wbGluZyBpbiB0aGUgbWlkZGxlIG9mIHRoZSBtb2R1bGUuIEp1c3QgaW4gY2FzZSB0aGUgaW1hZ2UgaXMgYVxyXG4gICAgICAgIC8vIGxpdHRsZSBvZmYsIHRoaXMgd2lsbCBoZWxwIHJlY292ZXIuXHJcbiAgICAgICAgdmFyIG51ZGdlID0gbW9kdWxlU2l6ZSAvIDI7XHJcbiAgICAgICAgdG9wICs9IG51ZGdlO1xyXG4gICAgICAgIGxlZnQgKz0gbnVkZ2U7XHJcbiAgICAgICAgLy8gTm93IGp1c3QgcmVhZCBvZmYgdGhlIGJpdHNcclxuICAgICAgICB2YXIgYml0cyA9IG5ldyBCaXRNYXRyaXhfMS5kZWZhdWx0KG1hdHJpeFdpZHRoLCBtYXRyaXhIZWlnaHQpO1xyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgbWF0cml4SGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgdmFyIGlPZmZzZXQgPSB0b3AgKyB5ICogbW9kdWxlU2l6ZTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBtYXRyaXhXaWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGxlZnQgKyB4ICogbW9kdWxlU2l6ZSwgaU9mZnNldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBiaXRzLnNldCh4LCB5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYml0cztcclxuICAgIH07XHJcbiAgICBEYXRhTWF0cml4UmVhZGVyLm1vZHVsZVNpemUgPSBmdW5jdGlvbiAobGVmdFRvcEJsYWNrLCBpbWFnZSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IGltYWdlLmdldFdpZHRoKCk7XHJcbiAgICAgICAgdmFyIHggPSBsZWZ0VG9wQmxhY2tbMF07XHJcbiAgICAgICAgdmFyIHkgPSBsZWZ0VG9wQmxhY2tbMV07XHJcbiAgICAgICAgd2hpbGUgKHggPCB3aWR0aCAmJiBpbWFnZS5nZXQoeCwgeSkpIHtcclxuICAgICAgICAgICAgeCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeCA9PT0gd2lkdGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IHggLSBsZWZ0VG9wQmxhY2tbMF07XHJcbiAgICAgICAgaWYgKG1vZHVsZVNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZTtcclxuICAgIH07XHJcbiAgICBEYXRhTWF0cml4UmVhZGVyLk5PX1BPSU5UUyA9IFtdO1xyXG4gICAgcmV0dXJuIERhdGFNYXRyaXhSZWFkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGFNYXRyaXhSZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFNYXRyaXhSZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEJpdE1hdHJpeF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9CaXRNYXRyaXhcIik7XHJcbnZhciBWZXJzaW9uXzEgPSByZXF1aXJlKFwiLi9WZXJzaW9uXCIpO1xyXG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xyXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJicm93bkBnb29nbGUuY29tIChCcmlhbiBCcm93bilcclxuICovXHJcbnZhciBCaXRNYXRyaXhQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBiaXRNYXRyaXgge0BsaW5rIEJpdE1hdHJpeH0gdG8gcGFyc2VcclxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGRpbWVuc2lvbiBpcyA8IDggb3IgPiAxNDQgb3Igbm90IDAgbW9kIDJcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQml0TWF0cml4UGFyc2VyKGJpdE1hdHJpeCkge1xyXG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBiaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgaWYgKGRpbWVuc2lvbiA8IDggfHwgZGltZW5zaW9uID4gMTQ0IHx8IChkaW1lbnNpb24gJiAweDAxKSAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZlcnNpb24gPSBCaXRNYXRyaXhQYXJzZXIucmVhZFZlcnNpb24oYml0TWF0cml4KTtcclxuICAgICAgICB0aGlzLm1hcHBpbmdCaXRNYXRyaXggPSB0aGlzLmV4dHJhY3REYXRhUmVnaW9uKGJpdE1hdHJpeCk7XHJcbiAgICAgICAgdGhpcy5yZWFkTWFwcGluZ01hdHJpeCA9IG5ldyBCaXRNYXRyaXhfMS5kZWZhdWx0KHRoaXMubWFwcGluZ0JpdE1hdHJpeC5nZXRXaWR0aCgpLCB0aGlzLm1hcHBpbmdCaXRNYXRyaXguZ2V0SGVpZ2h0KCkpO1xyXG4gICAgfVxyXG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5nZXRWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5DcmVhdGVzIHRoZSB2ZXJzaW9uIG9iamVjdCBiYXNlZCBvbiB0aGUgZGltZW5zaW9uIG9mIHRoZSBvcmlnaW5hbCBiaXQgbWF0cml4IGZyb21cclxuICAgICAqIHRoZSBkYXRhbWF0cml4IGNvZGUuPC9wPlxyXG4gICAgICpcclxuICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiBUYWJsZSA3IC0gRUNDIDIwMCBzeW1ib2wgYXR0cmlidXRlczwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYml0TWF0cml4IE9yaWdpbmFsIHtAbGluayBCaXRNYXRyaXh9IGluY2x1ZGluZyBhbGlnbm1lbnQgcGF0dGVybnNcclxuICAgICAqIEByZXR1cm4ge0BsaW5rIFZlcnNpb259IGVuY2Fwc3VsYXRpbmcgdGhlIERhdGEgTWF0cml4IENvZGUncyBcInZlcnNpb25cIlxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG1hcHBpbmcgbWF0cml4IGFyZSBub3QgdmFsaWRcclxuICAgICAqIERhdGEgTWF0cml4IGRpbWVuc2lvbnMuXHJcbiAgICAgKi9cclxuICAgIEJpdE1hdHJpeFBhcnNlci5yZWFkVmVyc2lvbiA9IGZ1bmN0aW9uIChiaXRNYXRyaXgpIHtcclxuICAgICAgICB2YXIgbnVtUm93cyA9IGJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcclxuICAgICAgICB2YXIgbnVtQ29sdW1ucyA9IGJpdE1hdHJpeC5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHJldHVybiBWZXJzaW9uXzEuZGVmYXVsdC5nZXRWZXJzaW9uRm9yRGltZW5zaW9ucyhudW1Sb3dzLCBudW1Db2x1bW5zKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPlJlYWRzIHRoZSBiaXRzIGluIHRoZSB7QGxpbmsgQml0TWF0cml4fSByZXByZXNlbnRpbmcgdGhlIG1hcHBpbmcgbWF0cml4IChObyBhbGlnbm1lbnQgcGF0dGVybnMpXHJcbiAgICAgKiBpbiB0aGUgY29ycmVjdCBvcmRlciBpbiBvcmRlciB0byByZWNvbnN0aXR1dGUgdGhlIGNvZGV3b3JkcyBieXRlcyBjb250YWluZWQgd2l0aGluIHRoZVxyXG4gICAgICogRGF0YSBNYXRyaXggQ29kZS48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgRGF0YSBNYXRyaXggQ29kZVxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyBleHBlY3RlZCBpcyBub3QgcmVhZFxyXG4gICAgICovXHJcbiAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlYWRDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbnQ4QXJyYXkodGhpcy52ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkpO1xyXG4gICAgICAgIHZhciByZXN1bHRPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciByb3cgPSA0O1xyXG4gICAgICAgIHZhciBjb2x1bW4gPSAwO1xyXG4gICAgICAgIHZhciBudW1Sb3dzID0gdGhpcy5tYXBwaW5nQml0TWF0cml4LmdldEhlaWdodCgpO1xyXG4gICAgICAgIHZhciBudW1Db2x1bW5zID0gdGhpcy5tYXBwaW5nQml0TWF0cml4LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdmFyIGNvcm5lcjFSZWFkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGNvcm5lcjJSZWFkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGNvcm5lcjNSZWFkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGNvcm5lcjRSZWFkID0gZmFsc2U7XHJcbiAgICAgICAgLy8gUmVhZCBhbGwgb2YgdGhlIGNvZGV3b3Jkc1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIGZvdXIgY29ybmVyIGNhc2VzXHJcbiAgICAgICAgICAgIGlmICgocm93ID09PSBudW1Sb3dzKSAmJiAoY29sdW1uID09PSAwKSAmJiAhY29ybmVyMVJlYWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXIxKG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcclxuICAgICAgICAgICAgICAgIHJvdyAtPSAyO1xyXG4gICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XHJcbiAgICAgICAgICAgICAgICBjb3JuZXIxUmVhZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHJvdyA9PT0gbnVtUm93cyAtIDIpICYmIChjb2x1bW4gPT09IDApICYmICgobnVtQ29sdW1ucyAmIDB4MDMpICE9PSAwKSAmJiAhY29ybmVyMlJlYWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXIyKG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcclxuICAgICAgICAgICAgICAgIHJvdyAtPSAyO1xyXG4gICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XHJcbiAgICAgICAgICAgICAgICBjb3JuZXIyUmVhZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHJvdyA9PT0gbnVtUm93cyArIDQpICYmIChjb2x1bW4gPT09IDIpICYmICgobnVtQ29sdW1ucyAmIDB4MDcpID09PSAwKSAmJiAhY29ybmVyM1JlYWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXIzKG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcclxuICAgICAgICAgICAgICAgIHJvdyAtPSAyO1xyXG4gICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XHJcbiAgICAgICAgICAgICAgICBjb3JuZXIzUmVhZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHJvdyA9PT0gbnVtUm93cyAtIDIpICYmIChjb2x1bW4gPT09IDApICYmICgobnVtQ29sdW1ucyAmIDB4MDcpID09PSA0KSAmJiAhY29ybmVyNFJlYWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRPZmZzZXQrK10gPSB0aGlzLnJlYWRDb3JuZXI0KG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcclxuICAgICAgICAgICAgICAgIHJvdyAtPSAyO1xyXG4gICAgICAgICAgICAgICAgY29sdW1uICs9IDI7XHJcbiAgICAgICAgICAgICAgICBjb3JuZXI0UmVhZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTd2VlcCB1cHdhcmQgZGlhZ29uYWxseSB0byB0aGUgcmlnaHRcclxuICAgICAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHJvdyA8IG51bVJvd3MpICYmIChjb2x1bW4gPj0gMCkgJiYgIXRoaXMucmVhZE1hcHBpbmdNYXRyaXguZ2V0KGNvbHVtbiwgcm93KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0T2Zmc2V0KytdID0gdGhpcy5yZWFkVXRhaChyb3csIGNvbHVtbiwgbnVtUm93cywgbnVtQ29sdW1ucykgJiAweGZmO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByb3cgLT0gMjtcclxuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMjtcclxuICAgICAgICAgICAgICAgIH0gd2hpbGUgKChyb3cgPj0gMCkgJiYgKGNvbHVtbiA8IG51bUNvbHVtbnMpKTtcclxuICAgICAgICAgICAgICAgIHJvdyArPSAxO1xyXG4gICAgICAgICAgICAgICAgY29sdW1uICs9IDM7XHJcbiAgICAgICAgICAgICAgICAvLyBTd2VlcCBkb3dud2FyZCBkaWFnb25hbGx5IHRvIHRoZSBsZWZ0XHJcbiAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChyb3cgPj0gMCkgJiYgKGNvbHVtbiA8IG51bUNvbHVtbnMpICYmICF0aGlzLnJlYWRNYXBwaW5nTWF0cml4LmdldChjb2x1bW4sIHJvdykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdE9mZnNldCsrXSA9IHRoaXMucmVhZFV0YWgocm93LCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpICYgMHhmZjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcm93ICs9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uIC09IDI7XHJcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgocm93IDwgbnVtUm93cykgJiYgKGNvbHVtbiA+PSAwKSk7XHJcbiAgICAgICAgICAgICAgICByb3cgKz0gMztcclxuICAgICAgICAgICAgICAgIGNvbHVtbiArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAoKHJvdyA8IG51bVJvd3MpIHx8IChjb2x1bW4gPCBudW1Db2x1bW5zKSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdE9mZnNldCAhPT0gdGhpcy52ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPlJlYWRzIGEgYml0IG9mIHRoZSBtYXBwaW5nIG1hdHJpeCBhY2NvdW50aW5nIGZvciBib3VuZGFyeSB3cmFwcGluZy48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJvdyBSb3cgdG8gcmVhZCBpbiB0aGUgbWFwcGluZyBtYXRyaXhcclxuICAgICAqIEBwYXJhbSBjb2x1bW4gQ29sdW1uIHRvIHJlYWQgaW4gdGhlIG1hcHBpbmcgbWF0cml4XHJcbiAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcclxuICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxyXG4gICAgICogQHJldHVybiB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYml0IGluIHRoZSBtYXBwaW5nIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlYWRNb2R1bGUgPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpIHtcclxuICAgICAgICAvLyBBZGp1c3QgdGhlIHJvdyBhbmQgY29sdW1uIGluZGljZXMgYmFzZWQgb24gYm91bmRhcnkgd3JhcHBpbmdcclxuICAgICAgICBpZiAocm93IDwgMCkge1xyXG4gICAgICAgICAgICByb3cgKz0gbnVtUm93cztcclxuICAgICAgICAgICAgY29sdW1uICs9IDQgLSAoKG51bVJvd3MgKyA0KSAmIDB4MDcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29sdW1uIDwgMCkge1xyXG4gICAgICAgICAgICBjb2x1bW4gKz0gbnVtQ29sdW1ucztcclxuICAgICAgICAgICAgcm93ICs9IDQgLSAoKG51bUNvbHVtbnMgKyA0KSAmIDB4MDcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlYWRNYXBwaW5nTWF0cml4LnNldChjb2x1bW4sIHJvdyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwcGluZ0JpdE1hdHJpeC5nZXQoY29sdW1uLCByb3cpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogPHA+UmVhZHMgdGhlIDggYml0cyBvZiB0aGUgc3RhbmRhcmQgVXRhaC1zaGFwZWQgcGF0dGVybi48L3A+XHJcbiAgICAgKlxyXG4gICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCA1LjguMSBGaWd1cmUgNjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcm93IEN1cnJlbnQgcm93IGluIHRoZSBtYXBwaW5nIG1hdHJpeCwgYW5jaG9yZWQgYXQgdGhlIDh0aCBiaXQgKExTQikgb2YgdGhlIHBhdHRlcm5cclxuICAgICAqIEBwYXJhbSBjb2x1bW4gQ3VycmVudCBjb2x1bW4gaW4gdGhlIG1hcHBpbmcgbWF0cml4LCBhbmNob3JlZCBhdCB0aGUgOHRoIGJpdCAoTFNCKSBvZiB0aGUgcGF0dGVyblxyXG4gICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XHJcbiAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcclxuICAgICAqIEByZXR1cm4gYnl0ZSBmcm9tIHRoZSB1dGFoIHNoYXBlXHJcbiAgICAgKi9cclxuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUucmVhZFV0YWggPSBmdW5jdGlvbiAocm93LCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpIHtcclxuICAgICAgICB2YXIgY3VycmVudEJ5dGUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93IC0gMiwgY29sdW1uIC0gMiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcclxuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAyLCBjb2x1bW4gLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdyAtIDEsIGNvbHVtbiAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93IC0gMSwgY29sdW1uIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcclxuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3cgLSAxLCBjb2x1bW4sIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUocm93LCBjb2x1bW4gLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKHJvdywgY29sdW1uIC0gMSwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcclxuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShyb3csIGNvbHVtbiwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcclxuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRCeXRlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogPHA+UmVhZHMgdGhlIDggYml0cyBvZiB0aGUgc3BlY2lhbCBjb3JuZXIgY29uZGl0aW9uIDEuPC9wPlxyXG4gICAgICpcclxuICAgICAqIDxwPlNlZSBJU08gMTYwMjI6MjAwNiwgRmlndXJlIEYuMzwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcclxuICAgICAqIEBwYXJhbSBudW1Db2x1bW5zIE51bWJlciBvZiBjb2x1bW5zIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxyXG4gICAgICogQHJldHVybiBieXRlIGZyb20gdGhlIENvcm5lciBjb25kaXRpb24gMVxyXG4gICAgICovXHJcbiAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlYWRDb3JuZXIxID0gZnVuY3Rpb24gKG51bVJvd3MsIG51bUNvbHVtbnMpIHtcclxuICAgICAgICB2YXIgY3VycmVudEJ5dGUgPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDAsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUobnVtUm93cyAtIDEsIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMiwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMywgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPlJlYWRzIHRoZSA4IGJpdHMgb2YgdGhlIHNwZWNpYWwgY29ybmVyIGNvbmRpdGlvbiAyLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYsIEZpZ3VyZSBGLjQ8L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XHJcbiAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcclxuICAgICAqIEByZXR1cm4gYnl0ZSBmcm9tIHRoZSBDb3JuZXIgY29uZGl0aW9uIDJcclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5yZWFkQ29ybmVyMiA9IGZ1bmN0aW9uIChudW1Sb3dzLCBudW1Db2x1bW5zKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRCeXRlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAzLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAyLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSA0LCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAzLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudEJ5dGU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5SZWFkcyB0aGUgOCBiaXRzIG9mIHRoZSBzcGVjaWFsIGNvcm5lciBjb25kaXRpb24gMy48L3A+XHJcbiAgICAgKlxyXG4gICAgICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCBGaWd1cmUgRi41PC9wPlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBudW1Sb3dzIE51bWJlciBvZiByb3dzIGluIHRoZSBtYXBwaW5nIG1hdHJpeFxyXG4gICAgICogQHBhcmFtIG51bUNvbHVtbnMgTnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hcHBpbmcgbWF0cml4XHJcbiAgICAgKiBAcmV0dXJuIGJ5dGUgZnJvbSB0aGUgQ29ybmVyIGNvbmRpdGlvbiAzXHJcbiAgICAgKi9cclxuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUucmVhZENvcm5lcjMgPSBmdW5jdGlvbiAobnVtUm93cywgbnVtQ29sdW1ucykge1xyXG4gICAgICAgIHZhciBjdXJyZW50Qnl0ZSA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgMCwgbnVtUm93cywgbnVtQ29sdW1ucykpIHtcclxuICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3VycmVudEJ5dGUgPDw9IDE7XHJcbiAgICAgICAgaWYgKHRoaXMucmVhZE1vZHVsZShudW1Sb3dzIC0gMSwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDMsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMCwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDMsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDIsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRCeXRlIDw8PSAxO1xyXG4gICAgICAgIGlmICh0aGlzLnJlYWRNb2R1bGUoMSwgbnVtQ29sdW1ucyAtIDEsIG51bVJvd3MsIG51bUNvbHVtbnMpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRCeXRlIHw9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXJyZW50Qnl0ZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPlJlYWRzIHRoZSA4IGJpdHMgb2YgdGhlIHNwZWNpYWwgY29ybmVyIGNvbmRpdGlvbiA0LjwvcD5cclxuICAgICAqXHJcbiAgICAgKiA8cD5TZWUgSVNPIDE2MDIyOjIwMDYsIEZpZ3VyZSBGLjY8L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG51bVJvd3MgTnVtYmVyIG9mIHJvd3MgaW4gdGhlIG1hcHBpbmcgbWF0cml4XHJcbiAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgbWFwcGluZyBtYXRyaXhcclxuICAgICAqIEByZXR1cm4gYnl0ZSBmcm9tIHRoZSBDb3JuZXIgY29uZGl0aW9uIDRcclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5yZWFkQ29ybmVyNCA9IGZ1bmN0aW9uIChudW1Sb3dzLCBudW1Db2x1bW5zKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRCeXRlID0gMDtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAzLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAyLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKG51bVJvd3MgLSAxLCAwLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAyLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDAsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDEsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDIsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICBpZiAodGhpcy5yZWFkTW9kdWxlKDMsIG51bUNvbHVtbnMgLSAxLCBudW1Sb3dzLCBudW1Db2x1bW5zKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Qnl0ZSB8PSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudEJ5dGU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5FeHRyYWN0cyB0aGUgZGF0YSByZWdpb24gZnJvbSBhIHtAbGluayBCaXRNYXRyaXh9IHRoYXQgY29udGFpbnNcclxuICAgICAqIGFsaWdubWVudCBwYXR0ZXJucy48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJpdE1hdHJpeCBPcmlnaW5hbCB7QGxpbmsgQml0TWF0cml4fSB3aXRoIGFsaWdubWVudCBwYXR0ZXJuc1xyXG4gICAgICogQHJldHVybiBCaXRNYXRyaXggdGhhdCBoYXMgdGhlIGFsaWdubWVudCBwYXR0ZXJucyByZW1vdmVkXHJcbiAgICAgKi9cclxuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUuZXh0cmFjdERhdGFSZWdpb24gPSBmdW5jdGlvbiAoYml0TWF0cml4KSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbFNpemVSb3dzID0gdGhpcy52ZXJzaW9uLmdldFN5bWJvbFNpemVSb3dzKCk7XHJcbiAgICAgICAgdmFyIHN5bWJvbFNpemVDb2x1bW5zID0gdGhpcy52ZXJzaW9uLmdldFN5bWJvbFNpemVDb2x1bW5zKCk7XHJcbiAgICAgICAgaWYgKGJpdE1hdHJpeC5nZXRIZWlnaHQoKSAhPT0gc3ltYm9sU2l6ZVJvd3MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0RpbWVuc2lvbiBvZiBiaXRNYXRyaXggbXVzdCBtYXRjaCB0aGUgdmVyc2lvbiBzaXplJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkYXRhUmVnaW9uU2l6ZVJvd3MgPSB0aGlzLnZlcnNpb24uZ2V0RGF0YVJlZ2lvblNpemVSb3dzKCk7XHJcbiAgICAgICAgdmFyIGRhdGFSZWdpb25TaXplQ29sdW1ucyA9IHRoaXMudmVyc2lvbi5nZXREYXRhUmVnaW9uU2l6ZUNvbHVtbnMoKTtcclxuICAgICAgICB2YXIgbnVtRGF0YVJlZ2lvbnNSb3cgPSBzeW1ib2xTaXplUm93cyAvIGRhdGFSZWdpb25TaXplUm93cyB8IDA7XHJcbiAgICAgICAgdmFyIG51bURhdGFSZWdpb25zQ29sdW1uID0gc3ltYm9sU2l6ZUNvbHVtbnMgLyBkYXRhUmVnaW9uU2l6ZUNvbHVtbnMgfCAwO1xyXG4gICAgICAgIHZhciBzaXplRGF0YVJlZ2lvblJvdyA9IG51bURhdGFSZWdpb25zUm93ICogZGF0YVJlZ2lvblNpemVSb3dzO1xyXG4gICAgICAgIHZhciBzaXplRGF0YVJlZ2lvbkNvbHVtbiA9IG51bURhdGFSZWdpb25zQ29sdW1uICogZGF0YVJlZ2lvblNpemVDb2x1bW5zO1xyXG4gICAgICAgIHZhciBiaXRNYXRyaXhXaXRob3V0QWxpZ25tZW50ID0gbmV3IEJpdE1hdHJpeF8xLmRlZmF1bHQoc2l6ZURhdGFSZWdpb25Db2x1bW4sIHNpemVEYXRhUmVnaW9uUm93KTtcclxuICAgICAgICBmb3IgKHZhciBkYXRhUmVnaW9uUm93ID0gMDsgZGF0YVJlZ2lvblJvdyA8IG51bURhdGFSZWdpb25zUm93OyArK2RhdGFSZWdpb25Sb3cpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFSZWdpb25Sb3dPZmZzZXQgPSBkYXRhUmVnaW9uUm93ICogZGF0YVJlZ2lvblNpemVSb3dzO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBkYXRhUmVnaW9uQ29sdW1uID0gMDsgZGF0YVJlZ2lvbkNvbHVtbiA8IG51bURhdGFSZWdpb25zQ29sdW1uOyArK2RhdGFSZWdpb25Db2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhUmVnaW9uQ29sdW1uT2Zmc2V0ID0gZGF0YVJlZ2lvbkNvbHVtbiAqIGRhdGFSZWdpb25TaXplQ29sdW1ucztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YVJlZ2lvblNpemVSb3dzOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZFJvd09mZnNldCA9IGRhdGFSZWdpb25Sb3cgKiAoZGF0YVJlZ2lvblNpemVSb3dzICsgMikgKyAxICsgaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd3JpdGVSb3dPZmZzZXQgPSBkYXRhUmVnaW9uUm93T2Zmc2V0ICsgaTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFSZWdpb25TaXplQ29sdW1uczsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFkQ29sdW1uT2Zmc2V0ID0gZGF0YVJlZ2lvbkNvbHVtbiAqIChkYXRhUmVnaW9uU2l6ZUNvbHVtbnMgKyAyKSArIDEgKyBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0TWF0cml4LmdldChyZWFkQ29sdW1uT2Zmc2V0LCByZWFkUm93T2Zmc2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdyaXRlQ29sdW1uT2Zmc2V0ID0gZGF0YVJlZ2lvbkNvbHVtbk9mZnNldCArIGo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRNYXRyaXhXaXRob3V0QWxpZ25tZW50LnNldCh3cml0ZUNvbHVtbk9mZnNldCwgd3JpdGVSb3dPZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiaXRNYXRyaXhXaXRob3V0QWxpZ25tZW50O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCaXRNYXRyaXhQYXJzZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJpdE1hdHJpeFBhcnNlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0TWF0cml4UGFyc2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIDxwPkVuY2Fwc3VsYXRlcyBhIGJsb2NrIG9mIGRhdGEgd2l0aGluIGEgRGF0YSBNYXRyaXggQ29kZS4gRGF0YSBNYXRyaXggQ29kZXMgbWF5IHNwbGl0IHRoZWlyIGRhdGEgaW50b1xyXG4gKiBtdWx0aXBsZSBibG9ja3MsIGVhY2ggb2Ygd2hpY2ggaXMgYSB1bml0IG9mIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzLiBFYWNoXHJcbiAqIGlzIHJlcHJlc2VudGVkIGJ5IGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIGJicm93bkBnb29nbGUuY29tIChCcmlhbiBCcm93bilcclxuICovXHJcbnZhciBEYXRhQmxvY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhQmxvY2sobnVtRGF0YUNvZGV3b3JkcywgY29kZXdvcmRzKSB7XHJcbiAgICAgICAgdGhpcy5udW1EYXRhQ29kZXdvcmRzID0gbnVtRGF0YUNvZGV3b3JkcztcclxuICAgICAgICB0aGlzLmNvZGV3b3JkcyA9IGNvZGV3b3JkcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogPHA+V2hlbiBEYXRhIE1hdHJpeCBDb2RlcyB1c2UgbXVsdGlwbGUgZGF0YSBibG9ja3MsIHRoZXkgYWN0dWFsbHkgaW50ZXJsZWF2ZSB0aGUgYnl0ZXMgb2YgZWFjaCBvZiB0aGVtLlxyXG4gICAgICogVGhhdCBpcywgdGhlIGZpcnN0IGJ5dGUgb2YgZGF0YSBibG9jayAxIHRvIG4gaXMgd3JpdHRlbiwgdGhlbiB0aGUgc2Vjb25kIGJ5dGVzLCBhbmQgc28gb24uIFRoaXNcclxuICAgICAqIG1ldGhvZCB3aWxsIHNlcGFyYXRlIHRoZSBkYXRhIGludG8gb3JpZ2luYWwgYmxvY2tzLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmF3Q29kZXdvcmRzIGJ5dGVzIGFzIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgRGF0YSBNYXRyaXggQ29kZVxyXG4gICAgICogQHBhcmFtIHZlcnNpb24gdmVyc2lvbiBvZiB0aGUgRGF0YSBNYXRyaXggQ29kZVxyXG4gICAgICogQHJldHVybiBEYXRhQmxvY2tzIGNvbnRhaW5pbmcgb3JpZ2luYWwgYnl0ZXMsIFwiZGUtaW50ZXJsZWF2ZWRcIiBmcm9tIHJlcHJlc2VudGF0aW9uIGluIHRoZVxyXG4gICAgICogICAgICAgICBEYXRhIE1hdHJpeCBDb2RlXHJcbiAgICAgKi9cclxuICAgIERhdGFCbG9jay5nZXREYXRhQmxvY2tzID0gZnVuY3Rpb24gKHJhd0NvZGV3b3JkcywgdmVyc2lvbikge1xyXG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xyXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIG51bWJlciBhbmQgc2l6ZSBvZiBkYXRhIGJsb2NrcyB1c2VkIGJ5IHRoaXMgdmVyc2lvblxyXG4gICAgICAgIHZhciBlY0Jsb2NrcyA9IHZlcnNpb24uZ2V0RUNCbG9ja3MoKTtcclxuICAgICAgICAvLyBGaXJzdCBjb3VudCB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGEgYmxvY2tzXHJcbiAgICAgICAgdmFyIHRvdGFsQmxvY2tzID0gMDtcclxuICAgICAgICB2YXIgZWNCbG9ja0FycmF5ID0gZWNCbG9ja3MuZ2V0RUNCbG9ja3MoKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBlY0Jsb2NrQXJyYXlfMSA9IF9fdmFsdWVzKGVjQmxvY2tBcnJheSksIGVjQmxvY2tBcnJheV8xXzEgPSBlY0Jsb2NrQXJyYXlfMS5uZXh0KCk7ICFlY0Jsb2NrQXJyYXlfMV8xLmRvbmU7IGVjQmxvY2tBcnJheV8xXzEgPSBlY0Jsb2NrQXJyYXlfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlY0Jsb2NrID0gZWNCbG9ja0FycmF5XzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRvdGFsQmxvY2tzICs9IGVjQmxvY2suZ2V0Q291bnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVjQmxvY2tBcnJheV8xXzEgJiYgIWVjQmxvY2tBcnJheV8xXzEuZG9uZSAmJiAoX2EgPSBlY0Jsb2NrQXJyYXlfMS5yZXR1cm4pKSBfYS5jYWxsKGVjQmxvY2tBcnJheV8xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdyBlc3RhYmxpc2ggRGF0YUJsb2NrcyBvZiB0aGUgYXBwcm9wcmlhdGUgc2l6ZSBhbmQgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzXHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0b3RhbEJsb2Nrcyk7XHJcbiAgICAgICAgdmFyIG51bVJlc3VsdEJsb2NrcyA9IDA7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgZWNCbG9ja0FycmF5XzIgPSBfX3ZhbHVlcyhlY0Jsb2NrQXJyYXkpLCBlY0Jsb2NrQXJyYXlfMl8xID0gZWNCbG9ja0FycmF5XzIubmV4dCgpOyAhZWNCbG9ja0FycmF5XzJfMS5kb25lOyBlY0Jsb2NrQXJyYXlfMl8xID0gZWNCbG9ja0FycmF5XzIubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWNCbG9jayA9IGVjQmxvY2tBcnJheV8yXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVjQmxvY2suZ2V0Q291bnQoKTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bURhdGFDb2Rld29yZHMgPSBlY0Jsb2NrLmdldERhdGFDb2Rld29yZHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtQmxvY2tDb2Rld29yZHMgPSBlY0Jsb2Nrcy5nZXRFQ0NvZGV3b3JkcygpICsgbnVtRGF0YUNvZGV3b3JkcztcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbbnVtUmVzdWx0QmxvY2tzKytdID0gbmV3IERhdGFCbG9jayhudW1EYXRhQ29kZXdvcmRzLCBuZXcgVWludDhBcnJheShudW1CbG9ja0NvZGV3b3JkcykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWNCbG9ja0FycmF5XzJfMSAmJiAhZWNCbG9ja0FycmF5XzJfMS5kb25lICYmIChfYiA9IGVjQmxvY2tBcnJheV8yLnJldHVybikpIF9iLmNhbGwoZWNCbG9ja0FycmF5XzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWxsIGJsb2NrcyBoYXZlIHRoZSBzYW1lIGFtb3VudCBvZiBkYXRhLCBleGNlcHQgdGhhdCB0aGUgbGFzdCBuXHJcbiAgICAgICAgLy8gKHdoZXJlIG4gbWF5IGJlIDApIGhhdmUgMSBsZXNzIGJ5dGUuIEZpZ3VyZSBvdXQgd2hlcmUgdGhlc2Ugc3RhcnQuXHJcbiAgICAgICAgLy8gVE9ETyhiYnJvd24pOiBUaGVyZSBpcyBvbmx5IG9uZSBjYXNlIHdoZXJlIHRoZXJlIGlzIGEgZGlmZmVyZW5jZSBmb3IgRGF0YSBNYXRyaXggZm9yIHNpemUgMTQ0XHJcbiAgICAgICAgdmFyIGxvbmdlckJsb2Nrc1RvdGFsQ29kZXdvcmRzID0gcmVzdWx0WzBdLmNvZGV3b3Jkcy5sZW5ndGg7XHJcbiAgICAgICAgLy8gaW50IHNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3JkcyA9IGxvbmdlckJsb2Nrc1RvdGFsQ29kZXdvcmRzIC0gMTtcclxuICAgICAgICB2YXIgbG9uZ2VyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyA9IGxvbmdlckJsb2Nrc1RvdGFsQ29kZXdvcmRzIC0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHMoKTtcclxuICAgICAgICB2YXIgc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHMgPSBsb25nZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzIC0gMTtcclxuICAgICAgICAvLyBUaGUgbGFzdCBlbGVtZW50cyBvZiByZXN1bHQgbWF5IGJlIDEgZWxlbWVudCBzaG9ydGVyIGZvciAxNDQgbWF0cml4XHJcbiAgICAgICAgLy8gZmlyc3QgZmlsbCBvdXQgYXMgbWFueSBlbGVtZW50cyBhcyBhbGwgb2YgdGhlbSBoYXZlIG1pbnVzIDFcclxuICAgICAgICB2YXIgcmF3Q29kZXdvcmRzT2Zmc2V0ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1SZXN1bHRCbG9ja3M7IGorKykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tpXSA9IHJhd0NvZGV3b3Jkc1tyYXdDb2Rld29yZHNPZmZzZXQrK107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRmlsbCBvdXQgdGhlIGxhc3QgZGF0YSBibG9jayBpbiB0aGUgbG9uZ2VyIG9uZXNcclxuICAgICAgICB2YXIgc3BlY2lhbFZlcnNpb24gPSB2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA9PT0gMjQ7XHJcbiAgICAgICAgdmFyIG51bUxvbmdlckJsb2NrcyA9IHNwZWNpYWxWZXJzaW9uID8gOCA6IG51bVJlc3VsdEJsb2NrcztcclxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUxvbmdlckJsb2NrczsgaisrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtqXS5jb2Rld29yZHNbbG9uZ2VyQmxvY2tzTnVtRGF0YUNvZGV3b3JkcyAtIDFdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93IGFkZCBpbiBlcnJvciBjb3JyZWN0aW9uIGJsb2Nrc1xyXG4gICAgICAgIHZhciBtYXggPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gbG9uZ2VyQmxvY2tzTnVtRGF0YUNvZGV3b3JkczsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBqT2Zmc2V0ID0gc3BlY2lhbFZlcnNpb24gPyAoaiArIDgpICUgbnVtUmVzdWx0QmxvY2tzIDogajtcclxuICAgICAgICAgICAgICAgIHZhciBpT2Zmc2V0ID0gc3BlY2lhbFZlcnNpb24gJiYgak9mZnNldCA+IDcgPyBpIC0gMSA6IGk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbak9mZnNldF0uY29kZXdvcmRzW2lPZmZzZXRdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3Q29kZXdvcmRzT2Zmc2V0ICE9PSByYXdDb2Rld29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgRGF0YUJsb2NrLnByb3RvdHlwZS5nZXROdW1EYXRhQ29kZXdvcmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm51bURhdGFDb2Rld29yZHM7XHJcbiAgICB9O1xyXG4gICAgRGF0YUJsb2NrLnByb3RvdHlwZS5nZXRDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXdvcmRzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXRhQmxvY2s7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGFCbG9jaztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0YUJsb2NrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBEZWNvZGVyUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0RlY29kZXJSZXN1bHRcIik7XHJcbnZhciBCaXRTb3VyY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vQml0U291cmNlXCIpO1xyXG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcclxudmFyIFN0cmluZ0VuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TdHJpbmdFbmNvZGluZ1wiKTtcclxudmFyIFN0cmluZ1V0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL1N0cmluZ1V0aWxzXCIpO1xyXG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xyXG52YXIgSWxsZWdhbFN0YXRlRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vSWxsZWdhbFN0YXRlRXhjZXB0aW9uXCIpO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBNb2RlO1xyXG4oZnVuY3Rpb24gKE1vZGUpIHtcclxuICAgIE1vZGVbTW9kZVtcIlBBRF9FTkNPREVcIl0gPSAwXSA9IFwiUEFEX0VOQ09ERVwiO1xyXG4gICAgTW9kZVtNb2RlW1wiQVNDSUlfRU5DT0RFXCJdID0gMV0gPSBcIkFTQ0lJX0VOQ09ERVwiO1xyXG4gICAgTW9kZVtNb2RlW1wiQzQwX0VOQ09ERVwiXSA9IDJdID0gXCJDNDBfRU5DT0RFXCI7XHJcbiAgICBNb2RlW01vZGVbXCJURVhUX0VOQ09ERVwiXSA9IDNdID0gXCJURVhUX0VOQ09ERVwiO1xyXG4gICAgTW9kZVtNb2RlW1wiQU5TSVgxMl9FTkNPREVcIl0gPSA0XSA9IFwiQU5TSVgxMl9FTkNPREVcIjtcclxuICAgIE1vZGVbTW9kZVtcIkVESUZBQ1RfRU5DT0RFXCJdID0gNV0gPSBcIkVESUZBQ1RfRU5DT0RFXCI7XHJcbiAgICBNb2RlW01vZGVbXCJCQVNFMjU2X0VOQ09ERVwiXSA9IDZdID0gXCJCQVNFMjU2X0VOQ09ERVwiO1xyXG59KShNb2RlIHx8IChNb2RlID0ge30pKTtcclxuLyoqXHJcbiAqIDxwPkRhdGEgTWF0cml4IENvZGVzIGNhbiBlbmNvZGUgdGV4dCBhcyBiaXRzIGluIG9uZSBvZiBzZXZlcmFsIG1vZGVzLCBhbmQgY2FuIHVzZSBtdWx0aXBsZSBtb2Rlc1xyXG4gKiBpbiBvbmUgRGF0YSBNYXRyaXggQ29kZS4gVGhpcyBjbGFzcyBkZWNvZGVzIHRoZSBiaXRzIGJhY2sgaW50byB0ZXh0LjwvcD5cclxuICpcclxuICogPHA+U2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuMSAtIDUuMi45LjI8L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIERlY29kZWRCaXRTdHJlYW1QYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEZWNvZGVkQml0U3RyZWFtUGFyc2VyKCkge1xyXG4gICAgfVxyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGUgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcclxuICAgICAgICB2YXIgYml0cyA9IG5ldyBCaXRTb3VyY2VfMS5kZWZhdWx0KGJ5dGVzKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdFRyYWlsZXIgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB2YXIgYnl0ZVNlZ21lbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdmFyIG1vZGUgPSBNb2RlLkFTQ0lJX0VOQ09ERTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBNb2RlLkFTQ0lJX0VOQ09ERSkge1xyXG4gICAgICAgICAgICAgICAgbW9kZSA9IHRoaXMuZGVjb2RlQXNjaWlTZWdtZW50KGJpdHMsIHJlc3VsdCwgcmVzdWx0VHJhaWxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuQzQwX0VOQ09ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVDNDBTZWdtZW50KGJpdHMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5URVhUX0VOQ09ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVUZXh0U2VnbWVudChiaXRzLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGUuQU5TSVgxMl9FTkNPREU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjb2RlQW5zaVgxMlNlZ21lbnQoYml0cywgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlLkVESUZBQ1RfRU5DT0RFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY29kZUVkaWZhY3RTZWdtZW50KGJpdHMsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5CQVNFMjU2X0VOQ09ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVCYXNlMjU2U2VnbWVudChiaXRzLCByZXN1bHQsIGJ5dGVTZWdtZW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtb2RlID0gTW9kZS5BU0NJSV9FTkNPREU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChtb2RlICE9PSBNb2RlLlBBRF9FTkNPREUgJiYgYml0cy5hdmFpbGFibGUoKSA+IDApO1xyXG4gICAgICAgIGlmIChyZXN1bHRUcmFpbGVyLmxlbmd0aCgpID4gMCkge1xyXG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKHJlc3VsdFRyYWlsZXIudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRGVjb2RlclJlc3VsdF8xLmRlZmF1bHQoYnl0ZXMsIHJlc3VsdC50b1N0cmluZygpLCBieXRlU2VnbWVudHMubGVuZ3RoID09PSAwID8gbnVsbCA6IGJ5dGVTZWdtZW50cywgbnVsbCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi4zIGFuZCBBbm5leCBDLCBUYWJsZSBDLjJcclxuICAgICAqL1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVBc2NpaVNlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0LCByZXN1bHRUcmFpbGVyKSB7XHJcbiAgICAgICAgdmFyIHVwcGVyU2hpZnQgPSBmYWxzZTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHZhciBvbmVCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcclxuICAgICAgICAgICAgaWYgKG9uZUJ5dGUgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob25lQnl0ZSA8PSAxMjgpIHsgLy8gQVNDSUkgZGF0YSAoQVNDSUkgdmFsdWUgKyAxKVxyXG4gICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvbmVCeXRlICs9IDEyODtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1cHBlclNoaWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUob25lQnl0ZSAtIDEpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkFTQ0lJX0VOQ09ERTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvbmVCeXRlID09PSAxMjkpIHsgLy8gUGFkXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5QQURfRU5DT0RFO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9uZUJ5dGUgPD0gMjI5KSB7IC8vIDItZGlnaXQgZGF0YSAwMC05OSAoTnVtZXJpYyBWYWx1ZSArIDEzMClcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9uZUJ5dGUgLSAxMzA7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPCAxMCkgeyAvLyBwYWQgd2l0aCAnMCcgZm9yIHNpbmdsZSBkaWdpdCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcwJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcnICsgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChvbmVCeXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzA6IC8vIExhdGNoIHRvIEM0MCBlbmNvZGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkM0MF9FTkNPREU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzE6IC8vIExhdGNoIHRvIEJhc2UgMjU2IGVuY29kYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuQkFTRTI1Nl9FTkNPREU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzI6IC8vIEZOQzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KSk7IC8vIHRyYW5zbGF0ZSBhcyBBU0NJSSAyOVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzMzogLy8gU3RydWN0dXJlZCBBcHBlbmRcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzNDogLy8gUmVhZGVyIFByb2dyYW1taW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSB0aGVzZSBzeW1ib2xzIGZvciBub3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3cgUmVhZGVyRXhjZXB0aW9uLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM1OiAvLyBVcHBlciBTaGlmdCAoc2hpZnQgdG8gRXh0ZW5kZWQgQVNDSUkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDIzNjogLy8gMDUgTWFjcm9cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnWyk+XFx1MDAxRTA1XFx1MDAxRCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRUcmFpbGVyLmluc2VydCgwLCAnXFx1MDAxRVxcdTAwMDQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMzc6IC8vIDA2IE1hY3JvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1spPlxcdTAwMUUwNlxcdTAwMUQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0VHJhaWxlci5pbnNlcnQoMCwgJ1xcdTAwMUVcXHUwMDA0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM4OiAvLyBMYXRjaCB0byBBTlNJIFgxMiBlbmNvZGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBNb2RlLkFOU0lYMTJfRU5DT0RFO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjM5OiAvLyBMYXRjaCB0byBUZXh0IGVuY29kYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1vZGUuVEVYVF9FTkNPREU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyNDA6IC8vIExhdGNoIHRvIEVESUZBQ1QgZW5jb2RhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW9kZS5FRElGQUNUX0VOQ09ERTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI0MTogLy8gRUNJIENoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPKGJicm93bik6IEkgdGhpbmsgd2UgbmVlZCB0byBzdXBwb3J0IEVDSVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBSZWFkZXJFeGNlcHRpb24uZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIHRoaXMgc3ltYm9sIGZvciBub3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IHRvIGJlIHVzZWQgaW4gQVNDSUkgZW5jb2RhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd29yayBhcm91bmQgZW5jb2RlcnMgdGhhdCBlbmQgd2l0aCAyNTQsIGxhdGNoIGJhY2sgdG8gQVNDSUlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uZUJ5dGUgIT09IDI1NCB8fCBiaXRzLmF2YWlsYWJsZSgpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAoYml0cy5hdmFpbGFibGUoKSA+IDApO1xyXG4gICAgICAgIHJldHVybiBNb2RlLkFTQ0lJX0VOQ09ERTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjUgYW5kIEFubmV4IEMsIFRhYmxlIEMuMVxyXG4gICAgICovXHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUM0MFNlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0KSB7XHJcbiAgICAgICAgLy8gVGhyZWUgQzQwIHZhbHVlcyBhcmUgZW5jb2RlZCBpbiBhIDE2LWJpdCB2YWx1ZSBhc1xyXG4gICAgICAgIC8vICgxNjAwICogQzEpICsgKDQwICogQzIpICsgQzMgKyAxXHJcbiAgICAgICAgLy8gVE9ETyhiYnJvd24pOiBUaGUgVXBwZXIgU2hpZnQgd2l0aCBDNDAgZG9lc24ndCB3b3JrIGluIHRoZSA0IHZhbHVlIHNjZW5hcmlvIGFsbCB0aGUgdGltZVxyXG4gICAgICAgIHZhciB1cHBlclNoaWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGNWYWx1ZXMgPSBbXTtcclxuICAgICAgICB2YXIgc2hpZnQgPSAwO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgYnl0ZSBsZWZ0IHRoZW4gaXQgd2lsbCBiZSBlbmNvZGVkIGFzIEFTQ0lJXHJcbiAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpID09PSA4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDI1NCkgeyAvLyBVbmxhdGNoIGNvZGV3b3JkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYXJzZVR3b0J5dGVzKGZpcnN0Qnl0ZSwgYml0cy5yZWFkQml0cyg4KSwgY1ZhbHVlcyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY1ZhbHVlID0gY1ZhbHVlc1tpXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2hpZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IGNWYWx1ZSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY1ZhbHVlIDwgdGhpcy5DNDBfQkFTSUNfU0VUX0NIQVJTLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGM0MGNoYXIgPSB0aGlzLkM0MF9CQVNJQ19TRVRfQ0hBUlNbY1ZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGM0MGNoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoYzQwY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyAxMjgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNWYWx1ZSA8IHRoaXMuQzQwX1NISUZUMl9TRVRfQ0hBUlMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYzQwY2hhciA9IHRoaXMuQzQwX1NISUZUMl9TRVRfQ0hBUlNbY1ZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGM0MGNoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoYzQwY2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIEZOQzFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKDI5KSk7IC8vIHRyYW5zbGF0ZSBhcyBBU0NJSSAyOVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDMwOiAvLyBVcHBlciBTaGlmdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyAyMjQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyA5NikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjYgYW5kIEFubmV4IEMsIFRhYmxlIEMuMlxyXG4gICAgICovXHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZVRleHRTZWdtZW50ID0gZnVuY3Rpb24gKGJpdHMsIHJlc3VsdCkge1xyXG4gICAgICAgIC8vIFRocmVlIFRleHQgdmFsdWVzIGFyZSBlbmNvZGVkIGluIGEgMTYtYml0IHZhbHVlIGFzXHJcbiAgICAgICAgLy8gKDE2MDAgKiBDMSkgKyAoNDAgKiBDMikgKyBDMyArIDFcclxuICAgICAgICAvLyBUT0RPKGJicm93bik6IFRoZSBVcHBlciBTaGlmdCB3aXRoIFRleHQgZG9lc24ndCB3b3JrIGluIHRoZSA0IHZhbHVlIHNjZW5hcmlvIGFsbCB0aGUgdGltZVxyXG4gICAgICAgIHZhciB1cHBlclNoaWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGNWYWx1ZXMgPSBbXTtcclxuICAgICAgICB2YXIgc2hpZnQgPSAwO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgYnl0ZSBsZWZ0IHRoZW4gaXQgd2lsbCBiZSBlbmNvZGVkIGFzIEFTQ0lJXHJcbiAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpID09PSA4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDI1NCkgeyAvLyBVbmxhdGNoIGNvZGV3b3JkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYXJzZVR3b0J5dGVzKGZpcnN0Qnl0ZSwgYml0cy5yZWFkQml0cyg4KSwgY1ZhbHVlcyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY1ZhbHVlID0gY1ZhbHVlc1tpXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2hpZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCAzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IGNWYWx1ZSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY1ZhbHVlIDwgdGhpcy5URVhUX0JBU0lDX1NFVF9DSEFSUy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0Q2hhciA9IHRoaXMuVEVYVF9CQVNJQ19TRVRfQ0hBUlNbY1ZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cHBlclNoaWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKHRleHRDaGFyLmNoYXJDb2RlQXQoMCkgKyAxMjgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlclNoaWZ0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKHRleHRDaGFyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSArIDEyOCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmcuZnJvbUNoYXJDb2RlKGNWYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaGlmdCAyIGZvciBUZXh0IGlzIHRoZSBzYW1lIGVuY29kaW5nIGFzIEM0MFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1ZhbHVlIDwgdGhpcy5URVhUX1NISUZUMl9TRVRfQ0hBUlMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dENoYXIgPSB0aGlzLlRFWFRfU0hJRlQyX1NFVF9DSEFSU1tjVmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwcGVyU2hpZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUodGV4dENoYXIuY2hhckNvZGVBdCgwKSArIDEyOCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyU2hpZnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQodGV4dENoYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI3OiAvLyBGTkMxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSgyOSkpOyAvLyB0cmFuc2xhdGUgYXMgQVNDSUkgMjlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzMDogLy8gVXBwZXIgU2hpZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjVmFsdWUgPCB0aGlzLlRFWFRfU0hJRlQzX1NFVF9DSEFSUy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0Q2hhciA9IHRoaXMuVEVYVF9TSElGVDNfU0VUX0NIQVJTW2NWYWx1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBwZXJTaGlmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSh0ZXh0Q2hhci5jaGFyQ29kZUF0KDApICsgMTI4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJTaGlmdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0ZXh0Q2hhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChiaXRzLmF2YWlsYWJsZSgpID4gMCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIDUuMi43XHJcbiAgICAgKi9cclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlQW5zaVgxMlNlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0KSB7XHJcbiAgICAgICAgLy8gVGhyZWUgQU5TSSBYMTIgdmFsdWVzIGFyZSBlbmNvZGVkIGluIGEgMTYtYml0IHZhbHVlIGFzXHJcbiAgICAgICAgLy8gKDE2MDAgKiBDMSkgKyAoNDAgKiBDMikgKyBDMyArIDFcclxuICAgICAgICB2YXIgY1ZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgb25seSBvbmUgYnl0ZSBsZWZ0IHRoZW4gaXQgd2lsbCBiZSBlbmNvZGVkIGFzIEFTQ0lJXHJcbiAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpID09PSA4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGZpcnN0Qnl0ZSA9IGJpdHMucmVhZEJpdHMoOCk7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDI1NCkgeyAvLyBVbmxhdGNoIGNvZGV3b3JkXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYXJzZVR3b0J5dGVzKGZpcnN0Qnl0ZSwgYml0cy5yZWFkQml0cyg4KSwgY1ZhbHVlcyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY1ZhbHVlID0gY1ZhbHVlc1tpXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiAvLyBYMTIgc2VnbWVudCB0ZXJtaW5hdG9yIDxDUj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxyJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gWDEyIHNlZ21lbnQgc2VwYXJhdG9yICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnKicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IC8vIFgxMiBzdWItZWxlbWVudCBzZXBhcmF0b3IgPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCc+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzogLy8gc3BhY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnICcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY1ZhbHVlIDwgMTQpIHsgLy8gMCAtIDlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjVmFsdWUgKyA0NCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNWYWx1ZSA8IDQwKSB7IC8vIEEgLSBaXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY1ZhbHVlICsgNTEpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChiaXRzLmF2YWlsYWJsZSgpID4gMCk7XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5wYXJzZVR3b0J5dGVzID0gZnVuY3Rpb24gKGZpcnN0Qnl0ZSwgc2Vjb25kQnl0ZSwgcmVzdWx0KSB7XHJcbiAgICAgICAgdmFyIGZ1bGxCaXRWYWx1ZSA9IChmaXJzdEJ5dGUgPDwgOCkgKyBzZWNvbmRCeXRlIC0gMTtcclxuICAgICAgICB2YXIgdGVtcCA9IE1hdGguZmxvb3IoZnVsbEJpdFZhbHVlIC8gMTYwMCk7XHJcbiAgICAgICAgcmVzdWx0WzBdID0gdGVtcDtcclxuICAgICAgICBmdWxsQml0VmFsdWUgLT0gdGVtcCAqIDE2MDA7XHJcbiAgICAgICAgdGVtcCA9IE1hdGguZmxvb3IoZnVsbEJpdFZhbHVlIC8gNDApO1xyXG4gICAgICAgIHJlc3VsdFsxXSA9IHRlbXA7XHJcbiAgICAgICAgcmVzdWx0WzJdID0gZnVsbEJpdFZhbHVlIC0gdGVtcCAqIDQwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2VlIElTTyAxNjAyMjoyMDA2LCA1LjIuOCBhbmQgQW5uZXggQyBUYWJsZSBDLjNcclxuICAgICAqL1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVFZGlmYWN0U2VnbWVudCA9IGZ1bmN0aW9uIChiaXRzLCByZXN1bHQpIHtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG9ubHkgdHdvIG9yIGxlc3MgYnl0ZXMgbGVmdCB0aGVuIGl0IHdpbGwgYmUgZW5jb2RlZCBhcyBBU0NJSVxyXG4gICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8PSAxNikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWRpZmFjdFZhbHVlID0gYml0cy5yZWFkQml0cyg2KTtcclxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB0aGUgdW5sYXRjaCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgIGlmIChlZGlmYWN0VmFsdWUgPT09IDB4MUYpIHsgLy8gMDExMTExXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCByZXN0IG9mIGJ5dGUsIHdoaWNoIHNob3VsZCBiZSAwLCBhbmQgc3RvcFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaXRzTGVmdCA9IDggLSBiaXRzLmdldEJpdE9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXRzTGVmdCAhPT0gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRzLnJlYWRCaXRzKGJpdHNMZWZ0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKChlZGlmYWN0VmFsdWUgJiAweDIwKSA9PT0gMCkgeyAvLyBubyAxIGluIHRoZSBsZWFkaW5nICg2dGgpIGJpdFxyXG4gICAgICAgICAgICAgICAgICAgIGVkaWZhY3RWYWx1ZSB8PSAweDQwOyAvLyBBZGQgYSBsZWFkaW5nIDAxIHRvIHRoZSA2IGJpdCBiaW5hcnkgdmFsdWVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShlZGlmYWN0VmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKGJpdHMuYXZhaWxhYmxlKCkgPiAwKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgNS4yLjkgYW5kIEFubmV4IEIsIEIuMlxyXG4gICAgICovXHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUJhc2UyNTZTZWdtZW50ID0gZnVuY3Rpb24gKGJpdHMsIHJlc3VsdCwgYnl0ZVNlZ21lbnRzKSB7XHJcbiAgICAgICAgLy8gRmlndXJlIG91dCBob3cgbG9uZyB0aGUgQmFzZSAyNTYgU2VnbWVudCBpcy5cclxuICAgICAgICB2YXIgY29kZXdvcmRQb3NpdGlvbiA9IDEgKyBiaXRzLmdldEJ5dGVPZmZzZXQoKTsgLy8gcG9zaXRpb24gaXMgMS1pbmRleGVkXHJcbiAgICAgICAgdmFyIGQxID0gdGhpcy51bnJhbmRvbWl6ZTI1NVN0YXRlKGJpdHMucmVhZEJpdHMoOCksIGNvZGV3b3JkUG9zaXRpb24rKyk7XHJcbiAgICAgICAgdmFyIGNvdW50O1xyXG4gICAgICAgIGlmIChkMSA9PT0gMCkgeyAvLyBSZWFkIHRoZSByZW1haW5kZXIgb2YgdGhlIHN5bWJvbFxyXG4gICAgICAgICAgICBjb3VudCA9IGJpdHMuYXZhaWxhYmxlKCkgLyA4IHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZDEgPCAyNTApIHtcclxuICAgICAgICAgICAgY291bnQgPSBkMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvdW50ID0gMjUwICogKGQxIC0gMjQ5KSArIHRoaXMudW5yYW5kb21pemUyNTVTdGF0ZShiaXRzLnJlYWRCaXRzKDgpLCBjb2Rld29yZFBvc2l0aW9uKyspO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSdyZSBzZWVpbmcgTmVnYXRpdmVBcnJheVNpemVFeGNlcHRpb24gZXJyb3JzIGZyb20gdXNlcnMuXHJcbiAgICAgICAgaWYgKGNvdW50IDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjb3VudCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIEhhdmUgc2VlbiB0aGlzIHBhcnRpY3VsYXIgZXJyb3IgaW4gdGhlIHdpbGQsIHN1Y2ggYXMgYXRcclxuICAgICAgICAgICAgLy8gaHR0cDovL3d3dy5iY2dlbi5jb20vZGVtby9JREF1dG9tYXRpb25TdHJlYW1pbmdEYXRhTWF0cml4LmFzcHg/TU9ERT0zJkQ9RnJlZCZQRk1UPTMmUFQ9RiZYPTAuMyZPPTAmTE09MC4yXHJcbiAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgOCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBieXRlc1tpXSA9IHRoaXMudW5yYW5kb21pemUyNTVTdGF0ZShiaXRzLnJlYWRCaXRzKDgpLCBjb2Rld29yZFBvc2l0aW9uKyspO1xyXG4gICAgICAgIH1cclxuICAgICAgICBieXRlU2VnbWVudHMucHVzaChieXRlcyk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChTdHJpbmdFbmNvZGluZ18xLmRlZmF1bHQuZGVjb2RlKGJ5dGVzLCBTdHJpbmdVdGlsc18xLmRlZmF1bHQuSVNPODg1OTEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKHVlZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uXzEuZGVmYXVsdCgnUGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCByZXF1aXJlZCBlbmNvZGluZzogJyArIHVlZS5tZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIEFubmV4IEIsIEIuMlxyXG4gICAgICovXHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnVucmFuZG9taXplMjU1U3RhdGUgPSBmdW5jdGlvbiAocmFuZG9taXplZEJhc2UyNTZDb2Rld29yZCwgYmFzZTI1NkNvZGV3b3JkUG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgcHNldWRvUmFuZG9tTnVtYmVyID0gKCgxNDkgKiBiYXNlMjU2Q29kZXdvcmRQb3NpdGlvbikgJSAyNTUpICsgMTtcclxuICAgICAgICB2YXIgdGVtcFZhcmlhYmxlID0gcmFuZG9taXplZEJhc2UyNTZDb2Rld29yZCAtIHBzZXVkb1JhbmRvbU51bWJlcjtcclxuICAgICAgICByZXR1cm4gdGVtcFZhcmlhYmxlID49IDAgPyB0ZW1wVmFyaWFibGUgOiB0ZW1wVmFyaWFibGUgKyAyNTY7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYsIEFubmV4IEMgVGFibGUgQy4xXHJcbiAgICAgKiBUaGUgQzQwIEJhc2ljIENoYXJhY3RlciBTZXQgKConcyB1c2VkIGZvciBwbGFjZWhvbGRlcnMgZm9yIHRoZSBzaGlmdCB2YWx1ZXMpXHJcbiAgICAgKi9cclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQzQwX0JBU0lDX1NFVF9DSEFSUyA9IFtcclxuICAgICAgICAnKicsICcqJywgJyonLCAnICcsICcwJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnLCAnOCcsICc5JyxcclxuICAgICAgICAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJyxcclxuICAgICAgICAnTycsICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onXHJcbiAgICBdO1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5DNDBfU0hJRlQyX1NFVF9DSEFSUyA9IFtcclxuICAgICAgICAnIScsICdcIicsICcjJywgJyQnLCAnJScsICcmJywgJ1xcJycsICcoJywgJyknLCAnKicsICcrJywgJywnLCAnLScsICcuJyxcclxuICAgICAgICAnLycsICc6JywgJzsnLCAnPCcsICc9JywgJz4nLCAnPycsICdAJywgJ1snLCAnXFxcXCcsICddJywgJ14nLCAnXydcclxuICAgIF07XHJcbiAgICAvKipcclxuICAgICAqIFNlZSBJU08gMTYwMjI6MjAwNiwgQW5uZXggQyBUYWJsZSBDLjJcclxuICAgICAqIFRoZSBUZXh0IEJhc2ljIENoYXJhY3RlciBTZXQgKConcyB1c2VkIGZvciBwbGFjZWhvbGRlcnMgZm9yIHRoZSBzaGlmdCB2YWx1ZXMpXHJcbiAgICAgKi9cclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9CQVNJQ19TRVRfQ0hBUlMgPSBbXHJcbiAgICAgICAgJyonLCAnKicsICcqJywgJyAnLCAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXHJcbiAgICAgICAgJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJywgJ2cnLCAnaCcsICdpJywgJ2onLCAnaycsICdsJywgJ20nLCAnbicsXHJcbiAgICAgICAgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0JywgJ3UnLCAndicsICd3JywgJ3gnLCAneScsICd6J1xyXG4gICAgXTtcclxuICAgIC8vIFNoaWZ0IDIgZm9yIFRleHQgaXMgdGhlIHNhbWUgZW5jb2RpbmcgYXMgQzQwXHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfU0hJRlQyX1NFVF9DSEFSUyA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQzQwX1NISUZUMl9TRVRfQ0hBUlM7XHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfU0hJRlQzX1NFVF9DSEFSUyA9IFtcclxuICAgICAgICAnYCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLFxyXG4gICAgICAgICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICd7JywgJ3wnLCAnfScsICd+JywgU3RyaW5nLmZyb21DaGFyQ29kZSgxMjcpXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIERlY29kZWRCaXRTdHJlYW1QYXJzZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlY29kZWRCaXRTdHJlYW1QYXJzZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFJlZWRTb2xvbW9uRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9yZWVkc29sb21vbi9SZWVkU29sb21vbkRlY29kZXJcIik7XHJcbnZhciBHZW5lcmljR0ZfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vcmVlZHNvbG9tb24vR2VuZXJpY0dGXCIpO1xyXG52YXIgQml0TWF0cml4UGFyc2VyXzEgPSByZXF1aXJlKFwiLi9CaXRNYXRyaXhQYXJzZXJcIik7XHJcbnZhciBEYXRhQmxvY2tfMSA9IHJlcXVpcmUoXCIuL0RhdGFCbG9ja1wiKTtcclxudmFyIERlY29kZWRCaXRTdHJlYW1QYXJzZXJfMSA9IHJlcXVpcmUoXCIuL0RlY29kZWRCaXRTdHJlYW1QYXJzZXJcIik7XHJcbnZhciBDaGVja3N1bUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0NoZWNrc3VtRXhjZXB0aW9uXCIpO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiA8cD5UaGUgbWFpbiBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIERhdGEgTWF0cml4IENvZGUgZGVjb2RpbmcgLS0gYXMgb3Bwb3NlZCB0byBsb2NhdGluZyBhbmQgZXh0cmFjdGluZ1xyXG4gKiB0aGUgRGF0YSBNYXRyaXggQ29kZSBmcm9tIGFuIGltYWdlLjwvcD5cclxuICpcclxuICogQGF1dGhvciBiYnJvd25AZ29vZ2xlLmNvbSAoQnJpYW4gQnJvd24pXHJcbiAqL1xyXG52YXIgRGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlY29kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5yc0RlY29kZXIgPSBuZXcgUmVlZFNvbG9tb25EZWNvZGVyXzEuZGVmYXVsdChHZW5lcmljR0ZfMS5kZWZhdWx0LkRBVEFfTUFUUklYX0ZJRUxEXzI1Nik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIDxwPkRlY29kZXMgYSBEYXRhIE1hdHJpeCBDb2RlIHJlcHJlc2VudGVkIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0uIEEgMSBvciBcInRydWVcIiBpcyB0YWtlblxyXG4gICAgICogdG8gbWVhbiBhIGJsYWNrIG1vZHVsZS48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGJpdHMgYm9vbGVhbnMgcmVwcmVzZW50aW5nIHdoaXRlL2JsYWNrIERhdGEgTWF0cml4IENvZGUgbW9kdWxlc1xyXG4gICAgICogQHJldHVybiB0ZXh0IGFuZCBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgRGF0YSBNYXRyaXggQ29kZVxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIERhdGEgTWF0cml4IENvZGUgY2Fubm90IGJlIGRlY29kZWRcclxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xyXG4gICAgICovXHJcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoYml0cykge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIC8vIENvbnN0cnVjdCBhIHBhcnNlciBhbmQgcmVhZCB2ZXJzaW9uLCBlcnJvci1jb3JyZWN0aW9uIGxldmVsXHJcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBCaXRNYXRyaXhQYXJzZXJfMS5kZWZhdWx0KGJpdHMpO1xyXG4gICAgICAgIHZhciB2ZXJzaW9uID0gcGFyc2VyLmdldFZlcnNpb24oKTtcclxuICAgICAgICAvLyBSZWFkIGNvZGV3b3Jkc1xyXG4gICAgICAgIHZhciBjb2Rld29yZHMgPSBwYXJzZXIucmVhZENvZGV3b3JkcygpO1xyXG4gICAgICAgIC8vIFNlcGFyYXRlIGludG8gZGF0YSBibG9ja3NcclxuICAgICAgICB2YXIgZGF0YUJsb2NrcyA9IERhdGFCbG9ja18xLmRlZmF1bHQuZ2V0RGF0YUJsb2Nrcyhjb2Rld29yZHMsIHZlcnNpb24pO1xyXG4gICAgICAgIC8vIENvdW50IHRvdGFsIG51bWJlciBvZiBkYXRhIGJ5dGVzXHJcbiAgICAgICAgdmFyIHRvdGFsQnl0ZXMgPSAwO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGRhdGFCbG9ja3NfMSA9IF9fdmFsdWVzKGRhdGFCbG9ja3MpLCBkYXRhQmxvY2tzXzFfMSA9IGRhdGFCbG9ja3NfMS5uZXh0KCk7ICFkYXRhQmxvY2tzXzFfMS5kb25lOyBkYXRhQmxvY2tzXzFfMSA9IGRhdGFCbG9ja3NfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYiA9IGRhdGFCbG9ja3NfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdG90YWxCeXRlcyArPSBkYi5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhQmxvY2tzXzFfMSAmJiAhZGF0YUJsb2Nrc18xXzEuZG9uZSAmJiAoX2EgPSBkYXRhQmxvY2tzXzEucmV0dXJuKSkgX2EuY2FsbChkYXRhQmxvY2tzXzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxCeXRlcyk7XHJcbiAgICAgICAgdmFyIGRhdGFCbG9ja3NDb3VudCA9IGRhdGFCbG9ja3MubGVuZ3RoO1xyXG4gICAgICAgIC8vIEVycm9yLWNvcnJlY3QgYW5kIGNvcHkgZGF0YSBibG9ja3MgdG9nZXRoZXIgaW50byBhIHN0cmVhbSBvZiBieXRlc1xyXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YUJsb2Nrc0NvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgdmFyIGRhdGFCbG9jayA9IGRhdGFCbG9ja3Nbal07XHJcbiAgICAgICAgICAgIHZhciBjb2Rld29yZEJ5dGVzID0gZGF0YUJsb2NrLmdldENvZGV3b3JkcygpO1xyXG4gICAgICAgICAgICB2YXIgbnVtRGF0YUNvZGV3b3JkcyA9IGRhdGFCbG9jay5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29ycmVjdEVycm9ycyhjb2Rld29yZEJ5dGVzLCBudW1EYXRhQ29kZXdvcmRzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIERlLWludGVybGFjZSBkYXRhIGJsb2Nrcy5cclxuICAgICAgICAgICAgICAgIHJlc3VsdEJ5dGVzW2kgKiBkYXRhQmxvY2tzQ291bnQgKyBqXSA9IGNvZGV3b3JkQnl0ZXNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGVjb2RlIHRoZSBjb250ZW50cyBvZiB0aGF0IHN0cmVhbSBvZiBieXRlc1xyXG4gICAgICAgIHJldHVybiBEZWNvZGVkQml0U3RyZWFtUGFyc2VyXzEuZGVmYXVsdC5kZWNvZGUocmVzdWx0Qnl0ZXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogPHA+R2l2ZW4gZGF0YSBhbmQgZXJyb3ItY29ycmVjdGlvbiBjb2Rld29yZHMgcmVjZWl2ZWQsIHBvc3NpYmx5IGNvcnJ1cHRlZCBieSBlcnJvcnMsIGF0dGVtcHRzIHRvXHJcbiAgICAgKiBjb3JyZWN0IHRoZSBlcnJvcnMgaW4tcGxhY2UgdXNpbmcgUmVlZC1Tb2xvbW9uIGVycm9yIGNvcnJlY3Rpb24uPC9wPlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2Rld29yZEJ5dGVzIGRhdGEgYW5kIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzXHJcbiAgICAgKiBAcGFyYW0gbnVtRGF0YUNvZGV3b3JkcyBudW1iZXIgb2YgY29kZXdvcmRzIHRoYXQgYXJlIGRhdGEgYnl0ZXNcclxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xyXG4gICAgICovXHJcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5jb3JyZWN0RXJyb3JzID0gZnVuY3Rpb24gKGNvZGV3b3JkQnl0ZXMsIG51bURhdGFDb2Rld29yZHMpIHtcclxuICAgICAgICB2YXIgbnVtQ29kZXdvcmRzID0gY29kZXdvcmRCeXRlcy5sZW5ndGg7XHJcbiAgICAgICAgLy8gRmlyc3QgcmVhZCBpbnRvIGFuIGFycmF5IG9mIGludHNcclxuICAgICAgICB2YXIgY29kZXdvcmRzSW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZGV3b3JkQnl0ZXMpO1xyXG4gICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29kZXdvcmRzOyBpKyspIHtcclxuICAgICAgICAvLyAgIGNvZGV3b3Jkc0ludHNbaV0gPSBjb2Rld29yZEJ5dGVzW2ldICYgMHhGRjtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdGhpcy5yc0RlY29kZXIuZGVjb2RlKGNvZGV3b3Jkc0ludHMsIGNvZGV3b3JkQnl0ZXMubGVuZ3RoIC0gbnVtRGF0YUNvZGV3b3Jkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChpZ25vcmVkIC8qIFJlZWRTb2xvbW9uRXhjZXB0aW9uICovKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29weSBiYWNrIGludG8gYXJyYXkgb2YgYnl0ZXMgLS0gb25seSBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZSBieXRlcyB0aGF0IHdlcmUgZGF0YVxyXG4gICAgICAgIC8vIFdlIGRvbid0IGNhcmUgYWJvdXQgZXJyb3JzIGluIHRoZSBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3Jkc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0YUNvZGV3b3JkczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvZGV3b3JkQnl0ZXNbaV0gPSBjb2Rld29yZHNJbnRzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVjb2RlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGVjb2RlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVjb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbi8qKlxyXG4gKiA8cD5FbmNhcHN1bGF0ZXMgYSBzZXQgb2YgZXJyb3ItY29ycmVjdGlvbiBibG9ja3MgaW4gb25lIHN5bWJvbCB2ZXJzaW9uLiBNb3N0IHZlcnNpb25zIHdpbGxcclxuICogdXNlIGJsb2NrcyBvZiBkaWZmZXJpbmcgc2l6ZXMgd2l0aGluIG9uZSB2ZXJzaW9uLCBzbywgdGhpcyBlbmNhcHN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgZm9yXHJcbiAqIGVhY2ggc2V0IG9mIGJsb2Nrcy4gSXQgYWxzbyBob2xkcyB0aGUgbnVtYmVyIG9mIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHBlciBibG9jayBzaW5jZSBpdFxyXG4gKiB3aWxsIGJlIHRoZSBzYW1lIGFjcm9zcyBhbGwgYmxvY2tzIHdpdGhpbiBvbmUgdmVyc2lvbi48L3A+XHJcbiAqL1xyXG52YXIgRUNCbG9ja3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFQ0Jsb2NrcyhlY0NvZGV3b3JkcywgZWNCbG9ja3MxLCBlY0Jsb2NrczIpIHtcclxuICAgICAgICB0aGlzLmVjQ29kZXdvcmRzID0gZWNDb2Rld29yZHM7XHJcbiAgICAgICAgdGhpcy5lY0Jsb2NrcyA9IFtlY0Jsb2NrczFdO1xyXG4gICAgICAgIGVjQmxvY2tzMiAmJiB0aGlzLmVjQmxvY2tzLnB1c2goZWNCbG9ja3MyKTtcclxuICAgIH1cclxuICAgIEVDQmxvY2tzLnByb3RvdHlwZS5nZXRFQ0NvZGV3b3JkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lY0NvZGV3b3JkcztcclxuICAgIH07XHJcbiAgICBFQ0Jsb2Nrcy5wcm90b3R5cGUuZ2V0RUNCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWNCbG9ja3M7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEVDQmxvY2tzO1xyXG59KCkpO1xyXG5leHBvcnRzLkVDQmxvY2tzID0gRUNCbG9ja3M7XHJcbi8qKlxyXG4gKiA8cD5FbmNhcHN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgZm9yIG9uZSBlcnJvci1jb3JyZWN0aW9uIGJsb2NrIGluIG9uZSBzeW1ib2wgdmVyc2lvbi5cclxuICogVGhpcyBpbmNsdWRlcyB0aGUgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzLCBhbmQgdGhlIG51bWJlciBvZiB0aW1lcyBhIGJsb2NrIHdpdGggdGhlc2VcclxuICogcGFyYW1ldGVycyBpcyB1c2VkIGNvbnNlY3V0aXZlbHkgaW4gdGhlIERhdGEgTWF0cml4IGNvZGUgdmVyc2lvbidzIGZvcm1hdC48L3A+XHJcbiAqL1xyXG52YXIgRUNCID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRUNCKGNvdW50LCBkYXRhQ29kZXdvcmRzKSB7XHJcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xyXG4gICAgICAgIHRoaXMuZGF0YUNvZGV3b3JkcyA9IGRhdGFDb2Rld29yZHM7XHJcbiAgICB9XHJcbiAgICBFQ0IucHJvdG90eXBlLmdldENvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xyXG4gICAgfTtcclxuICAgIEVDQi5wcm90b3R5cGUuZ2V0RGF0YUNvZGV3b3JkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ29kZXdvcmRzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFQ0I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRUNCID0gRUNCO1xyXG4vKipcclxuICogVGhlIFZlcnNpb24gb2JqZWN0IGVuY2Fwc3VsYXRlcyBhdHRyaWJ1dGVzIGFib3V0IGEgcGFydGljdWxhclxyXG4gKiBzaXplIERhdGEgTWF0cml4IENvZGUuXHJcbiAqXHJcbiAqIEBhdXRob3IgYmJyb3duQGdvb2dsZS5jb20gKEJyaWFuIEJyb3duKVxyXG4gKi9cclxudmFyIFZlcnNpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBWZXJzaW9uKHZlcnNpb25OdW1iZXIsIHN5bWJvbFNpemVSb3dzLCBzeW1ib2xTaXplQ29sdW1ucywgZGF0YVJlZ2lvblNpemVSb3dzLCBkYXRhUmVnaW9uU2l6ZUNvbHVtbnMsIGVjQmxvY2tzKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uTnVtYmVyID0gdmVyc2lvbk51bWJlcjtcclxuICAgICAgICB0aGlzLnN5bWJvbFNpemVSb3dzID0gc3ltYm9sU2l6ZVJvd3M7XHJcbiAgICAgICAgdGhpcy5zeW1ib2xTaXplQ29sdW1ucyA9IHN5bWJvbFNpemVDb2x1bW5zO1xyXG4gICAgICAgIHRoaXMuZGF0YVJlZ2lvblNpemVSb3dzID0gZGF0YVJlZ2lvblNpemVSb3dzO1xyXG4gICAgICAgIHRoaXMuZGF0YVJlZ2lvblNpemVDb2x1bW5zID0gZGF0YVJlZ2lvblNpemVDb2x1bW5zO1xyXG4gICAgICAgIHRoaXMuZWNCbG9ja3MgPSBlY0Jsb2NrcztcclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHRvdGFsIG51bWJlciBvZiBjb2Rld29yZHNcclxuICAgICAgICB2YXIgdG90YWwgPSAwO1xyXG4gICAgICAgIHZhciBlY0NvZGV3b3JkcyA9IGVjQmxvY2tzLmdldEVDQ29kZXdvcmRzKCk7XHJcbiAgICAgICAgdmFyIGVjYkFycmF5ID0gZWNCbG9ja3MuZ2V0RUNCbG9ja3MoKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBlY2JBcnJheV8xID0gX192YWx1ZXMoZWNiQXJyYXkpLCBlY2JBcnJheV8xXzEgPSBlY2JBcnJheV8xLm5leHQoKTsgIWVjYkFycmF5XzFfMS5kb25lOyBlY2JBcnJheV8xXzEgPSBlY2JBcnJheV8xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVjQmxvY2sgPSBlY2JBcnJheV8xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBlY0Jsb2NrLmdldENvdW50KCkgKiAoZWNCbG9jay5nZXREYXRhQ29kZXdvcmRzKCkgKyBlY0NvZGV3b3Jkcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChlY2JBcnJheV8xXzEgJiYgIWVjYkFycmF5XzFfMS5kb25lICYmIChfYSA9IGVjYkFycmF5XzEucmV0dXJuKSkgX2EuY2FsbChlY2JBcnJheV8xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudG90YWxDb2Rld29yZHMgPSB0b3RhbDtcclxuICAgIH1cclxuICAgIFZlcnNpb24ucHJvdG90eXBlLmdldFZlcnNpb25OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmVyc2lvbk51bWJlcjtcclxuICAgIH07XHJcbiAgICBWZXJzaW9uLnByb3RvdHlwZS5nZXRTeW1ib2xTaXplUm93cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xTaXplUm93cztcclxuICAgIH07XHJcbiAgICBWZXJzaW9uLnByb3RvdHlwZS5nZXRTeW1ib2xTaXplQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zeW1ib2xTaXplQ29sdW1ucztcclxuICAgIH07XHJcbiAgICBWZXJzaW9uLnByb3RvdHlwZS5nZXREYXRhUmVnaW9uU2l6ZVJvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVJlZ2lvblNpemVSb3dzO1xyXG4gICAgfTtcclxuICAgIFZlcnNpb24ucHJvdG90eXBlLmdldERhdGFSZWdpb25TaXplQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhUmVnaW9uU2l6ZUNvbHVtbnM7XHJcbiAgICB9O1xyXG4gICAgVmVyc2lvbi5wcm90b3R5cGUuZ2V0VG90YWxDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG90YWxDb2Rld29yZHM7XHJcbiAgICB9O1xyXG4gICAgVmVyc2lvbi5wcm90b3R5cGUuZ2V0RUNCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWNCbG9ja3M7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5EZWR1Y2VzIHZlcnNpb24gaW5mb3JtYXRpb24gZnJvbSBEYXRhIE1hdHJpeCBkaW1lbnNpb25zLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbnVtUm93cyBOdW1iZXIgb2Ygcm93cyBpbiBtb2R1bGVzXHJcbiAgICAgKiBAcGFyYW0gbnVtQ29sdW1ucyBOdW1iZXIgb2YgY29sdW1ucyBpbiBtb2R1bGVzXHJcbiAgICAgKiBAcmV0dXJuIFZlcnNpb24gZm9yIGEgRGF0YSBNYXRyaXggQ29kZSBvZiB0aG9zZSBkaW1lbnNpb25zXHJcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBkaW1lbnNpb25zIGRvIGNvcnJlc3BvbmQgdG8gYSB2YWxpZCBEYXRhIE1hdHJpeCBzaXplXHJcbiAgICAgKi9cclxuICAgIFZlcnNpb24uZ2V0VmVyc2lvbkZvckRpbWVuc2lvbnMgPSBmdW5jdGlvbiAobnVtUm93cywgbnVtQ29sdW1ucykge1xyXG4gICAgICAgIHZhciBlXzIsIF9hO1xyXG4gICAgICAgIGlmICgobnVtUm93cyAmIDB4MDEpICE9PSAwIHx8IChudW1Db2x1bW5zICYgMHgwMSkgIT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhWZXJzaW9uLlZFUlNJT05TKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uLnN5bWJvbFNpemVSb3dzID09PSBudW1Sb3dzICYmIHZlcnNpb24uc3ltYm9sU2l6ZUNvbHVtbnMgPT09IG51bUNvbHVtbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVyc2lvbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICAvLyAgQE92ZXJyaWRlXHJcbiAgICBWZXJzaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJycgKyB0aGlzLnZlcnNpb25OdW1iZXI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWUgSVNPIDE2MDIyOjIwMDYgNS41LjEgVGFibGUgN1xyXG4gICAgICovXHJcbiAgICBWZXJzaW9uLmJ1aWxkVmVyc2lvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMSwgMTAsIDEwLCA4LCA4LCBuZXcgRUNCbG9ja3MoNSwgbmV3IEVDQigxLCAzKSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigyLCAxMiwgMTIsIDEwLCAxMCwgbmV3IEVDQmxvY2tzKDcsIG5ldyBFQ0IoMSwgNSkpKSxcclxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMywgMTQsIDE0LCAxMiwgMTIsIG5ldyBFQ0Jsb2NrcygxMCwgbmV3IEVDQigxLCA4KSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbig0LCAxNiwgMTYsIDE0LCAxNCwgbmV3IEVDQmxvY2tzKDEyLCBuZXcgRUNCKDEsIDEyKSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbig1LCAxOCwgMTgsIDE2LCAxNiwgbmV3IEVDQmxvY2tzKDE0LCBuZXcgRUNCKDEsIDE4KSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbig2LCAyMCwgMjAsIDE4LCAxOCwgbmV3IEVDQmxvY2tzKDE4LCBuZXcgRUNCKDEsIDIyKSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbig3LCAyMiwgMjIsIDIwLCAyMCwgbmV3IEVDQmxvY2tzKDIwLCBuZXcgRUNCKDEsIDMwKSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbig4LCAyNCwgMjQsIDIyLCAyMiwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDEsIDM2KSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbig5LCAyNiwgMjYsIDI0LCAyNCwgbmV3IEVDQmxvY2tzKDI4LCBuZXcgRUNCKDEsIDQ0KSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigxMCwgMzIsIDMyLCAxNCwgMTQsIG5ldyBFQ0Jsb2NrcygzNiwgbmV3IEVDQigxLCA2MikpKSxcclxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMTEsIDM2LCAzNiwgMTYsIDE2LCBuZXcgRUNCbG9ja3MoNDIsIG5ldyBFQ0IoMSwgODYpKSksXHJcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDEyLCA0MCwgNDAsIDE4LCAxOCwgbmV3IEVDQmxvY2tzKDQ4LCBuZXcgRUNCKDEsIDExNCkpKSxcclxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMTMsIDQ0LCA0NCwgMjAsIDIwLCBuZXcgRUNCbG9ja3MoNTYsIG5ldyBFQ0IoMSwgMTQ0KSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigxNCwgNDgsIDQ4LCAyMiwgMjIsIG5ldyBFQ0Jsb2Nrcyg2OCwgbmV3IEVDQigxLCAxNzQpKSksXHJcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDE1LCA1MiwgNTIsIDI0LCAyNCwgbmV3IEVDQmxvY2tzKDQyLCBuZXcgRUNCKDIsIDEwMikpKSxcclxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMTYsIDY0LCA2NCwgMTQsIDE0LCBuZXcgRUNCbG9ja3MoNTYsIG5ldyBFQ0IoMiwgMTQwKSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigxNywgNzIsIDcyLCAxNiwgMTYsIG5ldyBFQ0Jsb2NrcygzNiwgbmV3IEVDQig0LCA5MikpKSxcclxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMTgsIDgwLCA4MCwgMTgsIDE4LCBuZXcgRUNCbG9ja3MoNDgsIG5ldyBFQ0IoNCwgMTE0KSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigxOSwgODgsIDg4LCAyMCwgMjAsIG5ldyBFQ0Jsb2Nrcyg1NiwgbmV3IEVDQig0LCAxNDQpKSksXHJcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDIwLCA5NiwgOTYsIDIyLCAyMiwgbmV3IEVDQmxvY2tzKDY4LCBuZXcgRUNCKDQsIDE3NCkpKSxcclxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMjEsIDEwNCwgMTA0LCAyNCwgMjQsIG5ldyBFQ0Jsb2Nrcyg1NiwgbmV3IEVDQig2LCAxMzYpKSksXHJcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDIyLCAxMjAsIDEyMCwgMTgsIDE4LCBuZXcgRUNCbG9ja3MoNjgsIG5ldyBFQ0IoNiwgMTc1KSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigyMywgMTMyLCAxMzIsIDIwLCAyMCwgbmV3IEVDQmxvY2tzKDYyLCBuZXcgRUNCKDgsIDE2MykpKSxcclxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMjQsIDE0NCwgMTQ0LCAyMiwgMjIsIG5ldyBFQ0Jsb2Nrcyg2MiwgbmV3IEVDQig4LCAxNTYpLCBuZXcgRUNCKDIsIDE1NSkpKSxcclxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMjUsIDgsIDE4LCA2LCAxNiwgbmV3IEVDQmxvY2tzKDcsIG5ldyBFQ0IoMSwgNSkpKSxcclxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMjYsIDgsIDMyLCA2LCAxNCwgbmV3IEVDQmxvY2tzKDExLCBuZXcgRUNCKDEsIDEwKSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigyNywgMTIsIDI2LCAxMCwgMjQsIG5ldyBFQ0Jsb2NrcygxNCwgbmV3IEVDQigxLCAxNikpKSxcclxuICAgICAgICAgICAgbmV3IFZlcnNpb24oMjgsIDEyLCAzNiwgMTAsIDE2LCBuZXcgRUNCbG9ja3MoMTgsIG5ldyBFQ0IoMSwgMjIpKSksXHJcbiAgICAgICAgICAgIG5ldyBWZXJzaW9uKDI5LCAxNiwgMzYsIDE0LCAxNiwgbmV3IEVDQmxvY2tzKDI0LCBuZXcgRUNCKDEsIDMyKSkpLFxyXG4gICAgICAgICAgICBuZXcgVmVyc2lvbigzMCwgMTYsIDQ4LCAxNCwgMjIsIG5ldyBFQ0Jsb2NrcygyOCwgbmV3IEVDQigxLCA0OSkpKVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG4gICAgVmVyc2lvbi5WRVJTSU9OUyA9IFZlcnNpb24uYnVpbGRWZXJzaW9ucygpO1xyXG4gICAgcmV0dXJuIFZlcnNpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFZlcnNpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVzdWx0UG9pbnRcIik7XHJcbnZhciBEZXRlY3RvclJlc3VsdF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9EZXRlY3RvclJlc3VsdFwiKTtcclxudmFyIEdyaWRTYW1wbGVySW5zdGFuY2VfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vR3JpZFNhbXBsZXJJbnN0YW5jZVwiKTtcclxudmFyIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3JfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vZGV0ZWN0b3IvV2hpdGVSZWN0YW5nbGVEZXRlY3RvclwiKTtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuLyoqXHJcbiAqIDxwPkVuY2Fwc3VsYXRlcyBsb2dpYyB0aGF0IGNhbiBkZXRlY3QgYSBEYXRhIE1hdHJpeCBDb2RlIGluIGFuIGltYWdlLCBldmVuIGlmIHRoZSBEYXRhIE1hdHJpeCBDb2RlXHJcbiAqIGlzIHJvdGF0ZWQgb3Igc2tld2VkLCBvciBwYXJ0aWFsbHkgb2JzY3VyZWQuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIERldGVjdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGV0ZWN0b3IoaW1hZ2UpIHtcclxuICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgdGhpcy5yZWN0YW5nbGVEZXRlY3RvciA9IG5ldyBXaGl0ZVJlY3RhbmdsZURldGVjdG9yXzEuZGVmYXVsdCh0aGlzLmltYWdlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogPHA+RGV0ZWN0cyBhIERhdGEgTWF0cml4IENvZGUgaW4gYW4gaW1hZ2UuPC9wPlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0BsaW5rIERldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGEgRGF0YSBNYXRyaXggQ29kZVxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBubyBEYXRhIE1hdHJpeCBDb2RlIGNhbiBiZSBmb3VuZFxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZGV0ZWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb3JuZXJQb2ludHMgPSB0aGlzLnJlY3RhbmdsZURldGVjdG9yLmRldGVjdCgpO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmRldGVjdFNvbGlkMShjb3JuZXJQb2ludHMpO1xyXG4gICAgICAgIHBvaW50cyA9IHRoaXMuZGV0ZWN0U29saWQyKHBvaW50cyk7XHJcbiAgICAgICAgcG9pbnRzWzNdID0gdGhpcy5jb3JyZWN0VG9wUmlnaHQocG9pbnRzKTtcclxuICAgICAgICBpZiAoIXBvaW50c1szXSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvaW50cyA9IHRoaXMuc2hpZnRUb01vZHVsZUNlbnRlcihwb2ludHMpO1xyXG4gICAgICAgIHZhciB0b3BMZWZ0ID0gcG9pbnRzWzBdO1xyXG4gICAgICAgIHZhciBib3R0b21MZWZ0ID0gcG9pbnRzWzFdO1xyXG4gICAgICAgIHZhciBib3R0b21SaWdodCA9IHBvaW50c1syXTtcclxuICAgICAgICB2YXIgdG9wUmlnaHQgPSBwb2ludHNbM107XHJcbiAgICAgICAgdmFyIGRpbWVuc2lvblRvcCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHRvcExlZnQsIHRvcFJpZ2h0KSArIDE7XHJcbiAgICAgICAgdmFyIGRpbWVuc2lvblJpZ2h0ID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4oYm90dG9tUmlnaHQsIHRvcFJpZ2h0KSArIDE7XHJcbiAgICAgICAgaWYgKChkaW1lbnNpb25Ub3AgJiAweDAxKSA9PT0gMSkge1xyXG4gICAgICAgICAgICBkaW1lbnNpb25Ub3AgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChkaW1lbnNpb25SaWdodCAmIDB4MDEpID09PSAxKSB7XHJcbiAgICAgICAgICAgIGRpbWVuc2lvblJpZ2h0ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICg0ICogZGltZW5zaW9uVG9wIDwgNyAqIGRpbWVuc2lvblJpZ2h0ICYmIDQgKiBkaW1lbnNpb25SaWdodCA8IDcgKiBkaW1lbnNpb25Ub3ApIHtcclxuICAgICAgICAgICAgLy8gVGhlIG1hdHJpeCBpcyBzcXVhcmVcclxuICAgICAgICAgICAgZGltZW5zaW9uVG9wID0gZGltZW5zaW9uUmlnaHQgPSBNYXRoLm1heChkaW1lbnNpb25Ub3AsIGRpbWVuc2lvblJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJpdHMgPSBEZXRlY3Rvci5zYW1wbGVHcmlkKHRoaXMuaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCB0b3BSaWdodCwgZGltZW5zaW9uVG9wLCBkaW1lbnNpb25SaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZXRlY3RvclJlc3VsdF8xLmRlZmF1bHQoYml0cywgW3RvcExlZnQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCB0b3BSaWdodF0pO1xyXG4gICAgfTtcclxuICAgIERldGVjdG9yLnNoaWZ0UG9pbnQgPSBmdW5jdGlvbiAocG9pbnQsIHRvLCBkaXYpIHtcclxuICAgICAgICB2YXIgeCA9ICh0by5nZXRYKCkgLSBwb2ludC5nZXRYKCkpIC8gKGRpdiArIDEpO1xyXG4gICAgICAgIHZhciB5ID0gKHRvLmdldFkoKSAtIHBvaW50LmdldFkoKSkgLyAoZGl2ICsgMSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQocG9pbnQuZ2V0WCgpICsgeCwgcG9pbnQuZ2V0WSgpICsgeSk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0b3IubW92ZUF3YXkgPSBmdW5jdGlvbiAocG9pbnQsIGZyb21YLCBmcm9tWSkge1xyXG4gICAgICAgIHZhciB4ID0gcG9pbnQuZ2V0WCgpO1xyXG4gICAgICAgIHZhciB5ID0gcG9pbnQuZ2V0WSgpO1xyXG4gICAgICAgIGlmICh4IDwgZnJvbVgpIHtcclxuICAgICAgICAgICAgeCAtPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgeCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA8IGZyb21ZKSB7XHJcbiAgICAgICAgICAgIHkgLT0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHkgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoeCwgeSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlY3QgYSBzb2xpZCBzaWRlIHdoaWNoIGhhcyBtaW5pbXVtIHRyYW5zaXRpb24uXHJcbiAgICAgKi9cclxuICAgIERldGVjdG9yLnByb3RvdHlwZS5kZXRlY3RTb2xpZDEgPSBmdW5jdGlvbiAoY29ybmVyUG9pbnRzKSB7XHJcbiAgICAgICAgLy8gMCAgMlxyXG4gICAgICAgIC8vIDEgIDNcclxuICAgICAgICB2YXIgcG9pbnRBID0gY29ybmVyUG9pbnRzWzBdO1xyXG4gICAgICAgIHZhciBwb2ludEIgPSBjb3JuZXJQb2ludHNbMV07XHJcbiAgICAgICAgdmFyIHBvaW50QyA9IGNvcm5lclBvaW50c1szXTtcclxuICAgICAgICB2YXIgcG9pbnREID0gY29ybmVyUG9pbnRzWzJdO1xyXG4gICAgICAgIHZhciB0ckFCID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBLCBwb2ludEIpO1xyXG4gICAgICAgIHZhciB0ckJDID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRCLCBwb2ludEMpO1xyXG4gICAgICAgIHZhciB0ckNEID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRDLCBwb2ludEQpO1xyXG4gICAgICAgIHZhciB0ckRBID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRELCBwb2ludEEpO1xyXG4gICAgICAgIC8vIDAuLjNcclxuICAgICAgICAvLyA6ICA6XHJcbiAgICAgICAgLy8gMS0tMlxyXG4gICAgICAgIHZhciBtaW4gPSB0ckFCO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbcG9pbnRELCBwb2ludEEsIHBvaW50QiwgcG9pbnRDXTtcclxuICAgICAgICBpZiAobWluID4gdHJCQykge1xyXG4gICAgICAgICAgICBtaW4gPSB0ckJDO1xyXG4gICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludEE7XHJcbiAgICAgICAgICAgIHBvaW50c1sxXSA9IHBvaW50QjtcclxuICAgICAgICAgICAgcG9pbnRzWzJdID0gcG9pbnRDO1xyXG4gICAgICAgICAgICBwb2ludHNbM10gPSBwb2ludEQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtaW4gPiB0ckNEKSB7XHJcbiAgICAgICAgICAgIG1pbiA9IHRyQ0Q7XHJcbiAgICAgICAgICAgIHBvaW50c1swXSA9IHBvaW50QjtcclxuICAgICAgICAgICAgcG9pbnRzWzFdID0gcG9pbnRDO1xyXG4gICAgICAgICAgICBwb2ludHNbMl0gPSBwb2ludEQ7XHJcbiAgICAgICAgICAgIHBvaW50c1szXSA9IHBvaW50QTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pbiA+IHRyREEpIHtcclxuICAgICAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRDO1xyXG4gICAgICAgICAgICBwb2ludHNbMV0gPSBwb2ludEQ7XHJcbiAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50QTtcclxuICAgICAgICAgICAgcG9pbnRzWzNdID0gcG9pbnRCO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZWN0IGEgc2Vjb25kIHNvbGlkIHNpZGUgbmV4dCB0byBmaXJzdCBzb2xpZCBzaWRlLlxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuZGV0ZWN0U29saWQyID0gZnVuY3Rpb24gKHBvaW50cykge1xyXG4gICAgICAgIC8vIEEuLkRcclxuICAgICAgICAvLyA6ICA6XHJcbiAgICAgICAgLy8gQi0tQ1xyXG4gICAgICAgIHZhciBwb2ludEEgPSBwb2ludHNbMF07XHJcbiAgICAgICAgdmFyIHBvaW50QiA9IHBvaW50c1sxXTtcclxuICAgICAgICB2YXIgcG9pbnRDID0gcG9pbnRzWzJdO1xyXG4gICAgICAgIHZhciBwb2ludEQgPSBwb2ludHNbM107XHJcbiAgICAgICAgLy8gVHJhbnNpdGlvbiBkZXRlY3Rpb24gb24gdGhlIGVkZ2UgaXMgbm90IHN0YWJsZS5cclxuICAgICAgICAvLyBUbyBzYWZlbHkgZGV0ZWN0LCBzaGlmdCB0aGUgcG9pbnRzIHRvIHRoZSBtb2R1bGUgY2VudGVyLlxyXG4gICAgICAgIHZhciB0ciA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QSwgcG9pbnREKTtcclxuICAgICAgICB2YXIgcG9pbnRCcyA9IERldGVjdG9yLnNoaWZ0UG9pbnQocG9pbnRCLCBwb2ludEMsICh0ciArIDEpICogNCk7XHJcbiAgICAgICAgdmFyIHBvaW50Q3MgPSBEZXRlY3Rvci5zaGlmdFBvaW50KHBvaW50QywgcG9pbnRCLCAodHIgKyAxKSAqIDQpO1xyXG4gICAgICAgIHZhciB0ckJBID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRCcywgcG9pbnRBKTtcclxuICAgICAgICB2YXIgdHJDRCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50Q3MsIHBvaW50RCk7XHJcbiAgICAgICAgLy8gMC4uM1xyXG4gICAgICAgIC8vIHwgIDpcclxuICAgICAgICAvLyAxLS0yXHJcbiAgICAgICAgaWYgKHRyQkEgPCB0ckNEKSB7XHJcbiAgICAgICAgICAgIC8vIHNvbGlkIHNpZGVzOiBBLUItQ1xyXG4gICAgICAgICAgICBwb2ludHNbMF0gPSBwb2ludEE7XHJcbiAgICAgICAgICAgIHBvaW50c1sxXSA9IHBvaW50QjtcclxuICAgICAgICAgICAgcG9pbnRzWzJdID0gcG9pbnRDO1xyXG4gICAgICAgICAgICBwb2ludHNbM10gPSBwb2ludEQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBzb2xpZCBzaWRlczogQi1DLURcclxuICAgICAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRCO1xyXG4gICAgICAgICAgICBwb2ludHNbMV0gPSBwb2ludEM7XHJcbiAgICAgICAgICAgIHBvaW50c1syXSA9IHBvaW50RDtcclxuICAgICAgICAgICAgcG9pbnRzWzNdID0gcG9pbnRBO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9pbnRzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgY29ybmVyIHBvc2l0aW9uIG9mIHRoZSB3aGl0ZSB0b3AgcmlnaHQgbW9kdWxlLlxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuY29ycmVjdFRvcFJpZ2h0ID0gZnVuY3Rpb24gKHBvaW50cykge1xyXG4gICAgICAgIC8vIEEuLkRcclxuICAgICAgICAvLyB8ICA6XHJcbiAgICAgICAgLy8gQi0tQ1xyXG4gICAgICAgIHZhciBwb2ludEEgPSBwb2ludHNbMF07XHJcbiAgICAgICAgdmFyIHBvaW50QiA9IHBvaW50c1sxXTtcclxuICAgICAgICB2YXIgcG9pbnRDID0gcG9pbnRzWzJdO1xyXG4gICAgICAgIHZhciBwb2ludEQgPSBwb2ludHNbM107XHJcbiAgICAgICAgLy8gc2hpZnQgcG9pbnRzIGZvciBzYWZlIHRyYW5zaXRpb24gZGV0ZWN0aW9uLlxyXG4gICAgICAgIHZhciB0clRvcCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QSwgcG9pbnREKTtcclxuICAgICAgICB2YXIgdHJSaWdodCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QiwgcG9pbnREKTtcclxuICAgICAgICB2YXIgcG9pbnRBcyA9IERldGVjdG9yLnNoaWZ0UG9pbnQocG9pbnRBLCBwb2ludEIsICh0clJpZ2h0ICsgMSkgKiA0KTtcclxuICAgICAgICB2YXIgcG9pbnRDcyA9IERldGVjdG9yLnNoaWZ0UG9pbnQocG9pbnRDLCBwb2ludEIsICh0clRvcCArIDEpICogNCk7XHJcbiAgICAgICAgdHJUb3AgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEFzLCBwb2ludEQpO1xyXG4gICAgICAgIHRyUmlnaHQgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludENzLCBwb2ludEQpO1xyXG4gICAgICAgIHZhciBjYW5kaWRhdGUxID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChwb2ludEQuZ2V0WCgpICsgKHBvaW50Qy5nZXRYKCkgLSBwb2ludEIuZ2V0WCgpKSAvICh0clRvcCArIDEpLCBwb2ludEQuZ2V0WSgpICsgKHBvaW50Qy5nZXRZKCkgLSBwb2ludEIuZ2V0WSgpKSAvICh0clRvcCArIDEpKTtcclxuICAgICAgICB2YXIgY2FuZGlkYXRlMiA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQocG9pbnRELmdldFgoKSArIChwb2ludEEuZ2V0WCgpIC0gcG9pbnRCLmdldFgoKSkgLyAodHJSaWdodCArIDEpLCBwb2ludEQuZ2V0WSgpICsgKHBvaW50QS5nZXRZKCkgLSBwb2ludEIuZ2V0WSgpKSAvICh0clJpZ2h0ICsgMSkpO1xyXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKGNhbmRpZGF0ZTEpKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoY2FuZGlkYXRlMikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZChjYW5kaWRhdGUyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN1bWMxID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBcywgY2FuZGlkYXRlMSkgKyB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludENzLCBjYW5kaWRhdGUxKTtcclxuICAgICAgICB2YXIgc3VtYzIgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludEFzLCBjYW5kaWRhdGUyKSArIHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50Q3MsIGNhbmRpZGF0ZTIpO1xyXG4gICAgICAgIGlmIChzdW1jMSA+IHN1bWMyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGUxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTI7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2hpZnQgdGhlIGVkZ2UgcG9pbnRzIHRvIHRoZSBtb2R1bGUgY2VudGVyLlxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuc2hpZnRUb01vZHVsZUNlbnRlciA9IGZ1bmN0aW9uIChwb2ludHMpIHtcclxuICAgICAgICAvLyBBLi5EXHJcbiAgICAgICAgLy8gfCAgOlxyXG4gICAgICAgIC8vIEItLUNcclxuICAgICAgICB2YXIgcG9pbnRBID0gcG9pbnRzWzBdO1xyXG4gICAgICAgIHZhciBwb2ludEIgPSBwb2ludHNbMV07XHJcbiAgICAgICAgdmFyIHBvaW50QyA9IHBvaW50c1syXTtcclxuICAgICAgICB2YXIgcG9pbnREID0gcG9pbnRzWzNdO1xyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBwc2V1ZG8gZGltZW5zaW9uc1xyXG4gICAgICAgIHZhciBkaW1IID0gdGhpcy50cmFuc2l0aW9uc0JldHdlZW4ocG9pbnRBLCBwb2ludEQpICsgMTtcclxuICAgICAgICB2YXIgZGltViA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QywgcG9pbnREKSArIDE7XHJcbiAgICAgICAgLy8gc2hpZnQgcG9pbnRzIGZvciBzYWZlIGRpbWVuc2lvbiBkZXRlY3Rpb25cclxuICAgICAgICB2YXIgcG9pbnRBcyA9IERldGVjdG9yLnNoaWZ0UG9pbnQocG9pbnRBLCBwb2ludEIsIGRpbVYgKiA0KTtcclxuICAgICAgICB2YXIgcG9pbnRDcyA9IERldGVjdG9yLnNoaWZ0UG9pbnQocG9pbnRDLCBwb2ludEIsIGRpbUggKiA0KTtcclxuICAgICAgICAvLyAgY2FsY3VsYXRlIG1vcmUgcHJlY2lzZSBkaW1lbnNpb25zXHJcbiAgICAgICAgZGltSCA9IHRoaXMudHJhbnNpdGlvbnNCZXR3ZWVuKHBvaW50QXMsIHBvaW50RCkgKyAxO1xyXG4gICAgICAgIGRpbVYgPSB0aGlzLnRyYW5zaXRpb25zQmV0d2Vlbihwb2ludENzLCBwb2ludEQpICsgMTtcclxuICAgICAgICBpZiAoKGRpbUggJiAweDAxKSA9PT0gMSkge1xyXG4gICAgICAgICAgICBkaW1IICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoZGltViAmIDB4MDEpID09PSAxKSB7XHJcbiAgICAgICAgICAgIGRpbVYgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2hpdGVSZWN0YW5nbGVEZXRlY3RvciByZXR1cm5zIHBvaW50cyBpbnNpZGUgb2YgdGhlIHJlY3RhbmdsZS5cclxuICAgICAgICAvLyBJIHdhbnQgcG9pbnRzIG9uIHRoZSBlZGdlcy5cclxuICAgICAgICB2YXIgY2VudGVyWCA9IChwb2ludEEuZ2V0WCgpICsgcG9pbnRCLmdldFgoKSArIHBvaW50Qy5nZXRYKCkgKyBwb2ludEQuZ2V0WCgpKSAvIDQ7XHJcbiAgICAgICAgdmFyIGNlbnRlclkgPSAocG9pbnRBLmdldFkoKSArIHBvaW50Qi5nZXRZKCkgKyBwb2ludEMuZ2V0WSgpICsgcG9pbnRELmdldFkoKSkgLyA0O1xyXG4gICAgICAgIHBvaW50QSA9IERldGVjdG9yLm1vdmVBd2F5KHBvaW50QSwgY2VudGVyWCwgY2VudGVyWSk7XHJcbiAgICAgICAgcG9pbnRCID0gRGV0ZWN0b3IubW92ZUF3YXkocG9pbnRCLCBjZW50ZXJYLCBjZW50ZXJZKTtcclxuICAgICAgICBwb2ludEMgPSBEZXRlY3Rvci5tb3ZlQXdheShwb2ludEMsIGNlbnRlclgsIGNlbnRlclkpO1xyXG4gICAgICAgIHBvaW50RCA9IERldGVjdG9yLm1vdmVBd2F5KHBvaW50RCwgY2VudGVyWCwgY2VudGVyWSk7XHJcbiAgICAgICAgdmFyIHBvaW50QnM7XHJcbiAgICAgICAgdmFyIHBvaW50RHM7XHJcbiAgICAgICAgLy8gc2hpZnQgcG9pbnRzIHRvIHRoZSBjZW50ZXIgb2YgZWFjaCBtb2R1bGVzXHJcbiAgICAgICAgcG9pbnRBcyA9IERldGVjdG9yLnNoaWZ0UG9pbnQocG9pbnRBLCBwb2ludEIsIGRpbVYgKiA0KTtcclxuICAgICAgICBwb2ludEFzID0gRGV0ZWN0b3Iuc2hpZnRQb2ludChwb2ludEFzLCBwb2ludEQsIGRpbUggKiA0KTtcclxuICAgICAgICBwb2ludEJzID0gRGV0ZWN0b3Iuc2hpZnRQb2ludChwb2ludEIsIHBvaW50QSwgZGltViAqIDQpO1xyXG4gICAgICAgIHBvaW50QnMgPSBEZXRlY3Rvci5zaGlmdFBvaW50KHBvaW50QnMsIHBvaW50QywgZGltSCAqIDQpO1xyXG4gICAgICAgIHBvaW50Q3MgPSBEZXRlY3Rvci5zaGlmdFBvaW50KHBvaW50QywgcG9pbnRELCBkaW1WICogNCk7XHJcbiAgICAgICAgcG9pbnRDcyA9IERldGVjdG9yLnNoaWZ0UG9pbnQocG9pbnRDcywgcG9pbnRCLCBkaW1IICogNCk7XHJcbiAgICAgICAgcG9pbnREcyA9IERldGVjdG9yLnNoaWZ0UG9pbnQocG9pbnRELCBwb2ludEMsIGRpbVYgKiA0KTtcclxuICAgICAgICBwb2ludERzID0gRGV0ZWN0b3Iuc2hpZnRQb2ludChwb2ludERzLCBwb2ludEEsIGRpbUggKiA0KTtcclxuICAgICAgICByZXR1cm4gW3BvaW50QXMsIHBvaW50QnMsIHBvaW50Q3MsIHBvaW50RHNdO1xyXG4gICAgfTtcclxuICAgIERldGVjdG9yLnByb3RvdHlwZS5pc1ZhbGlkID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICByZXR1cm4gcC5nZXRYKCkgPj0gMCAmJiBwLmdldFgoKSA8IHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSAmJiBwLmdldFkoKSA+IDAgJiYgcC5nZXRZKCkgPCB0aGlzLmltYWdlLmdldEhlaWdodCgpO1xyXG4gICAgfTtcclxuICAgIERldGVjdG9yLnNhbXBsZUdyaWQgPSBmdW5jdGlvbiAoaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0LCB0b3BSaWdodCwgZGltZW5zaW9uWCwgZGltZW5zaW9uWSkge1xyXG4gICAgICAgIHZhciBzYW1wbGVyID0gR3JpZFNhbXBsZXJJbnN0YW5jZV8xLmRlZmF1bHQuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICByZXR1cm4gc2FtcGxlci5zYW1wbGVHcmlkKGltYWdlLCBkaW1lbnNpb25YLCBkaW1lbnNpb25ZLCAwLjUsIDAuNSwgZGltZW5zaW9uWCAtIDAuNSwgMC41LCBkaW1lbnNpb25YIC0gMC41LCBkaW1lbnNpb25ZIC0gMC41LCAwLjUsIGRpbWVuc2lvblkgLSAwLjUsIHRvcExlZnQuZ2V0WCgpLCB0b3BMZWZ0LmdldFkoKSwgdG9wUmlnaHQuZ2V0WCgpLCB0b3BSaWdodC5nZXRZKCksIGJvdHRvbVJpZ2h0LmdldFgoKSwgYm90dG9tUmlnaHQuZ2V0WSgpLCBib3R0b21MZWZ0LmdldFgoKSwgYm90dG9tTGVmdC5nZXRZKCkpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2YgYmxhY2svd2hpdGUgdHJhbnNpdGlvbnMgYmV0d2VlbiB0d28gcG9pbnRzLCB1c2luZyBzb21ldGhpbmcgbGlrZSBCcmVzZW5oYW0ncyBhbGdvcml0aG0uXHJcbiAgICAgKi9cclxuICAgIERldGVjdG9yLnByb3RvdHlwZS50cmFuc2l0aW9uc0JldHdlZW4gPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcclxuICAgICAgICAvLyBTZWUgUVIgQ29kZSBEZXRlY3Rvciwgc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKClcclxuICAgICAgICB2YXIgZnJvbVggPSBNYXRoLnRydW5jKGZyb20uZ2V0WCgpKTtcclxuICAgICAgICB2YXIgZnJvbVkgPSBNYXRoLnRydW5jKGZyb20uZ2V0WSgpKTtcclxuICAgICAgICB2YXIgdG9YID0gTWF0aC50cnVuYyh0by5nZXRYKCkpO1xyXG4gICAgICAgIHZhciB0b1kgPSBNYXRoLnRydW5jKHRvLmdldFkoKSk7XHJcbiAgICAgICAgdmFyIHN0ZWVwID0gTWF0aC5hYnModG9ZIC0gZnJvbVkpID4gTWF0aC5hYnModG9YIC0gZnJvbVgpO1xyXG4gICAgICAgIGlmIChzdGVlcCkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGZyb21YO1xyXG4gICAgICAgICAgICBmcm9tWCA9IGZyb21ZO1xyXG4gICAgICAgICAgICBmcm9tWSA9IHRlbXA7XHJcbiAgICAgICAgICAgIHRlbXAgPSB0b1g7XHJcbiAgICAgICAgICAgIHRvWCA9IHRvWTtcclxuICAgICAgICAgICAgdG9ZID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnModG9YIC0gZnJvbVgpO1xyXG4gICAgICAgIHZhciBkeSA9IE1hdGguYWJzKHRvWSAtIGZyb21ZKTtcclxuICAgICAgICB2YXIgZXJyb3IgPSAtZHggLyAyO1xyXG4gICAgICAgIHZhciB5c3RlcCA9IGZyb21ZIDwgdG9ZID8gMSA6IC0xO1xyXG4gICAgICAgIHZhciB4c3RlcCA9IGZyb21YIDwgdG9YID8gMSA6IC0xO1xyXG4gICAgICAgIHZhciB0cmFuc2l0aW9ucyA9IDA7XHJcbiAgICAgICAgdmFyIGluQmxhY2sgPSB0aGlzLmltYWdlLmdldChzdGVlcCA/IGZyb21ZIDogZnJvbVgsIHN0ZWVwID8gZnJvbVggOiBmcm9tWSk7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IGZyb21YLCB5ID0gZnJvbVk7IHggIT09IHRvWDsgeCArPSB4c3RlcCkge1xyXG4gICAgICAgICAgICB2YXIgaXNCbGFjayA9IHRoaXMuaW1hZ2UuZ2V0KHN0ZWVwID8geSA6IHgsIHN0ZWVwID8geCA6IHkpO1xyXG4gICAgICAgICAgICBpZiAoaXNCbGFjayAhPT0gaW5CbGFjaykge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbnMrKztcclxuICAgICAgICAgICAgICAgIGluQmxhY2sgPSBpc0JsYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVycm9yICs9IGR5O1xyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA9PT0gdG9ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB5ICs9IHlzdGVwO1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgLT0gZHg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zaXRpb25zO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEZXRlY3RvcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGV0ZWN0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURldGVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBPbmVEUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9PbmVEUmVhZGVyXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIDxwPkVuY2Fwc3VsYXRlcyBmdW5jdGlvbmFsaXR5IGFuZCBpbXBsZW1lbnRhdGlvbiB0aGF0IGlzIGNvbW1vbiB0byBVUEMgYW5kIEVBTiBmYW1pbGllc1xyXG4gKiBvZiBvbmUtZGltZW5zaW9uYWwgYmFyY29kZXMuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKiBAYXV0aG9yIGFsYXNkYWlyQGdvb2dsZS5jb20gKEFsYXNkYWlyIE1hY2tpbnRvc2gpXHJcbiAqL1xyXG52YXIgQWJzdHJhY3RVUENFQU5SZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWJzdHJhY3RVUENFQU5SZWFkZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBYnN0cmFjdFVQQ0VBTlJlYWRlcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBwcml2YXRlIGZpbmFsIFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQgZXh0ZW5zaW9uUmVhZGVyO1xyXG4gICAgLy8gcHJpdmF0ZSBmaW5hbCBFQU5NYW51ZmFjdHVyZXJPcmdTdXBwb3J0IGVhbk1hblN1cHBvcnQ7XHJcbiAgICAvKlxyXG4gICAgcHJvdGVjdGVkIFVQQ0VBTlJlYWRlcigpIHtcclxuICAgICAgICBkZWNvZGVSb3dTdHJpbmdCdWZmZXIgPSBuZXcgU3RyaW5nQnVpbGRlcigyMCk7XHJcbiAgICAgICAgZXh0ZW5zaW9uUmVhZGVyID0gbmV3IFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQoKTtcclxuICAgICAgICBlYW5NYW5TdXBwb3J0ID0gbmV3IEVBTk1hbnVmYWN0dXJlck9yZ1N1cHBvcnQoKTtcclxuICAgIH1cclxuICAgICovXHJcbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5maW5kU3RhcnRHdWFyZFBhdHRlcm4gPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgdmFyIGZvdW5kU3RhcnQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgc3RhcnRSYW5nZSA9IG51bGw7XHJcbiAgICAgICAgdmFyIG5leHRTdGFydCA9IDA7XHJcbiAgICAgICAgdmFyIGNvdW50ZXJzID0gWzAsIDAsIDBdO1xyXG4gICAgICAgIHdoaWxlICghZm91bmRTdGFydCkge1xyXG4gICAgICAgICAgICBjb3VudGVycyA9IFswLCAwLCAwXTtcclxuICAgICAgICAgICAgc3RhcnRSYW5nZSA9IEFic3RyYWN0VVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCBuZXh0U3RhcnQsIGZhbHNlLCB0aGlzLlNUQVJUX0VORF9QQVRURVJOLCBjb3VudGVycyk7XHJcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHN0YXJ0UmFuZ2VbMF07XHJcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHN0YXJ0UmFuZ2VbMV07XHJcbiAgICAgICAgICAgIHZhciBxdWlldFN0YXJ0ID0gc3RhcnQgLSAobmV4dFN0YXJ0IC0gc3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAocXVpZXRTdGFydCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmb3VuZFN0YXJ0ID0gcm93LmlzUmFuZ2UocXVpZXRTdGFydCwgc3RhcnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RhcnRSYW5nZTtcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5jaGVja0NoZWNrc3VtID0gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICByZXR1cm4gQWJzdHJhY3RVUENFQU5SZWFkZXIuY2hlY2tTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMpO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLmNoZWNrU3RhbmRhcmRVUENFQU5DaGVja3N1bSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xyXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB2YXIgY2hlY2sgPSBwYXJzZUludChzLmNoYXJBdChsZW5ndGggLSAxKSwgMTApO1xyXG4gICAgICAgIHJldHVybiBBYnN0cmFjdFVQQ0VBTlJlYWRlci5nZXRTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMuc3Vic3RyaW5nKDAsIGxlbmd0aCAtIDEpKSA9PT0gY2hlY2s7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuZ2V0U3RhbmRhcmRVUENFQU5DaGVja3N1bSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xyXG4gICAgICAgICAgICB2YXIgZGlnaXQgPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdCA8IDAgfHwgZGlnaXQgPiA5KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1bSArPSBkaWdpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VtICo9IDM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IHMuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgaWYgKGRpZ2l0IDwgMCB8fCBkaWdpdCA+IDkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VtICs9IGRpZ2l0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKDEwMDAgLSBzdW0pICUgMTA7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuZGVjb2RlRW5kID0gZnVuY3Rpb24gKHJvdywgZW5kU3RhcnQpIHtcclxuICAgICAgICByZXR1cm4gQWJzdHJhY3RVUENFQU5SZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIGVuZFN0YXJ0LCBmYWxzZSwgQWJzdHJhY3RVUENFQU5SZWFkZXIuU1RBUlRfRU5EX1BBVFRFUk4sIG5ldyBBcnJheShBYnN0cmFjdFVQQ0VBTlJlYWRlci5TVEFSVF9FTkRfUEFUVEVSTi5sZW5ndGgpLmZpbGwoMCkpO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4gPSBmdW5jdGlvbiAocm93LCByb3dPZmZzZXQsIHdoaXRlRmlyc3QsIHBhdHRlcm4sIGNvdW50ZXJzKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gcm93LmdldFNpemUoKTtcclxuICAgICAgICByb3dPZmZzZXQgPSB3aGl0ZUZpcnN0ID8gcm93LmdldE5leHRVbnNldChyb3dPZmZzZXQpIDogcm93LmdldE5leHRTZXQocm93T2Zmc2V0KTtcclxuICAgICAgICB2YXIgY291bnRlclBvc2l0aW9uID0gMDtcclxuICAgICAgICB2YXIgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xyXG4gICAgICAgIHZhciBwYXR0ZXJuTGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGlzV2hpdGUgPSB3aGl0ZUZpcnN0O1xyXG4gICAgICAgIGZvciAodmFyIHggPSByb3dPZmZzZXQ7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGlmIChyb3cuZ2V0KHgpICE9PSBpc1doaXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSBwYXR0ZXJuTGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChPbmVEUmVhZGVyXzEuZGVmYXVsdC5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgQWJzdHJhY3RVUENFQU5SZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpIDwgQWJzdHJhY3RVUENFQU5SZWFkZXIuTUFYX0FWR19WQVJJQU5DRSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3BhdHRlcm5TdGFydCwgeF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzbGljZSA9IGNvdW50ZXJzLnNsaWNlKDIsIGNvdW50ZXJzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudGVyUG9zaXRpb24gLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbaV0gPSBzbGljZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uIC0gMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbi0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMTtcclxuICAgICAgICAgICAgICAgIGlzV2hpdGUgPSAhaXNXaGl0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuZGVjb2RlRGlnaXQgPSBmdW5jdGlvbiAocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBwYXR0ZXJucykge1xyXG4gICAgICAgIHRoaXMucmVjb3JkUGF0dGVybihyb3csIHJvd09mZnNldCwgY291bnRlcnMpO1xyXG4gICAgICAgIHZhciBiZXN0VmFyaWFuY2UgPSB0aGlzLk1BWF9BVkdfVkFSSUFOQ0U7XHJcbiAgICAgICAgdmFyIGJlc3RNYXRjaCA9IC0xO1xyXG4gICAgICAgIHZhciBtYXggPSBwYXR0ZXJucy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IHBhdHRlcm5zW2ldO1xyXG4gICAgICAgICAgICB2YXIgdmFyaWFuY2UgPSBPbmVEUmVhZGVyXzEuZGVmYXVsdC5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgQWJzdHJhY3RVUENFQU5SZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpO1xyXG4gICAgICAgICAgICBpZiAodmFyaWFuY2UgPCBiZXN0VmFyaWFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RWYXJpYW5jZSA9IHZhcmlhbmNlO1xyXG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmVzdE1hdGNoID49IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGJlc3RNYXRjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVGhlc2UgdHdvIHZhbHVlcyBhcmUgY3JpdGljYWwgZm9yIGRldGVybWluaW5nIGhvdyBwZXJtaXNzaXZlIHRoZSBkZWNvZGluZyB3aWxsIGJlLlxyXG4gICAgLy8gV2UndmUgYXJyaXZlZCBhdCB0aGVzZSB2YWx1ZXMgdGhyb3VnaCBhIGxvdCBvZiB0cmlhbCBhbmQgZXJyb3IuIFNldHRpbmcgdGhlbSBhbnkgaGlnaGVyXHJcbiAgICAvLyBsZXRzIGZhbHNlIHBvc2l0aXZlcyBjcmVlcCBpbiBxdWlja2x5LlxyXG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuTUFYX0FWR19WQVJJQU5DRSA9IDAuNDg7XHJcbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSA9IDAuNztcclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQvZW5kIGd1YXJkIHBhdHRlcm4uXHJcbiAgICAgKi9cclxuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLlNUQVJUX0VORF9QQVRURVJOID0gWzEsIDEsIDFdO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYXR0ZXJuIG1hcmtpbmcgdGhlIG1pZGRsZSBvZiBhIFVQQy9FQU4gcGF0dGVybiwgc2VwYXJhdGluZyB0aGUgdHdvIGhhbHZlcy5cclxuICAgICAqL1xyXG4gICAgQWJzdHJhY3RVUENFQU5SZWFkZXIuTUlERExFX1BBVFRFUk4gPSBbMSwgMSwgMSwgMSwgMV07XHJcbiAgICAvKipcclxuICAgICAqIGVuZCBndWFyZCBwYXR0ZXJuLlxyXG4gICAgICovXHJcbiAgICBBYnN0cmFjdFVQQ0VBTlJlYWRlci5FTkRfUEFUVEVSTiA9IFsxLCAxLCAxLCAxLCAxLCAxXTtcclxuICAgIC8qKlxyXG4gICAgICogXCJPZGRcIiwgb3IgXCJMXCIgcGF0dGVybnMgdXNlZCB0byBlbmNvZGUgVVBDL0VBTiBkaWdpdHMuXHJcbiAgICAgKi9cclxuICAgIEFic3RyYWN0VVBDRUFOUmVhZGVyLkxfUEFUVEVSTlMgPSBbXHJcbiAgICAgICAgWzMsIDIsIDEsIDFdLFxyXG4gICAgICAgIFsyLCAyLCAyLCAxXSxcclxuICAgICAgICBbMiwgMSwgMiwgMl0sXHJcbiAgICAgICAgWzEsIDQsIDEsIDFdLFxyXG4gICAgICAgIFsxLCAxLCAzLCAyXSxcclxuICAgICAgICBbMSwgMiwgMywgMV0sXHJcbiAgICAgICAgWzEsIDEsIDEsIDRdLFxyXG4gICAgICAgIFsxLCAzLCAxLCAyXSxcclxuICAgICAgICBbMSwgMiwgMSwgM10sXHJcbiAgICAgICAgWzMsIDEsIDEsIDJdLFxyXG4gICAgXTtcclxuICAgIHJldHVybiBBYnN0cmFjdFVQQ0VBTlJlYWRlcjtcclxufShPbmVEUmVhZGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdFVQQ0VBTlJlYWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RVUENFQU5SZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5vbmVkIHsqL1xyXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XHJcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0RlY29kZUhpbnRUeXBlXCIpO1xyXG52YXIgUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0XCIpO1xyXG52YXIgUmVzdWx0UG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRQb2ludFwiKTtcclxudmFyIE9uZURSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL09uZURSZWFkZXJcIik7XHJcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xyXG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xyXG52YXIgQ2hlY2tzdW1FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9DaGVja3N1bUV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIDxwPkRlY29kZXMgQ29kZSAxMjggYmFyY29kZXMuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIENvZGUxMjhSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29kZTEyOFJlYWRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvZGUxMjhSZWFkZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQ29kZTEyOFJlYWRlci5maW5kU3RhcnRQYXR0ZXJuID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XHJcbiAgICAgICAgdmFyIHJvd09mZnNldCA9IHJvdy5nZXROZXh0U2V0KDApO1xyXG4gICAgICAgIHZhciBjb3VudGVyUG9zaXRpb24gPSAwO1xyXG4gICAgICAgIHZhciBjb3VudGVycyA9IFswLCAwLCAwLCAwLCAwLCAwXTtcclxuICAgICAgICB2YXIgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xyXG4gICAgICAgIHZhciBpc1doaXRlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHBhdHRlcm5MZW5ndGggPSA2O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSByb3dPZmZzZXQ7IGkgPCB3aWR0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChyb3cuZ2V0KGkpICE9PSBpc1doaXRlKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlclBvc2l0aW9uID09PSAocGF0dGVybkxlbmd0aCAtIDEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJlc3RWYXJpYW5jZSA9IENvZGUxMjhSZWFkZXIuTUFYX0FWR19WQVJJQU5DRTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmVzdE1hdGNoID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc3RhcnRDb2RlID0gQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0E7IHN0YXJ0Q29kZSA8PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQzsgc3RhcnRDb2RlKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhcmlhbmNlID0gT25lRFJlYWRlcl8xLmRlZmF1bHQucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIENvZGUxMjhSZWFkZXIuQ09ERV9QQVRURVJOU1tzdGFydENvZGVdLCBDb2RlMTI4UmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhcmlhbmNlIDwgYmVzdFZhcmlhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0VmFyaWFuY2UgPSB2YXJpYW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IHN0YXJ0Q29kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciB3aGl0ZXNwYWNlIGJlZm9yZSBzdGFydCBwYXR0ZXJuLCA+PSA1MCUgb2Ygd2lkdGggb2Ygc3RhcnQgcGF0dGVyblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuaXNSYW5nZShNYXRoLm1heCgwLCBwYXR0ZXJuU3RhcnQgLSAoaSAtIHBhdHRlcm5TdGFydCkgLyAyKSwgcGF0dGVyblN0YXJ0LCBmYWxzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuU3RhcnQsIGksIGJlc3RNYXRjaF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzLnNwbGljZSgwLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICBDb2RlMTI4UmVhZGVyLmRlY29kZUNvZGUgPSBmdW5jdGlvbiAocm93LCBjb3VudGVycywgcm93T2Zmc2V0KSB7XHJcbiAgICAgICAgT25lRFJlYWRlcl8xLmRlZmF1bHQucmVjb3JkUGF0dGVybihyb3csIHJvd09mZnNldCwgY291bnRlcnMpO1xyXG4gICAgICAgIHZhciBiZXN0VmFyaWFuY2UgPSBDb2RlMTI4UmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0U7IC8vIHdvcnN0IHZhcmlhbmNlIHdlJ2xsIGFjY2VwdFxyXG4gICAgICAgIHZhciBiZXN0TWF0Y2ggPSAtMTtcclxuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IENvZGUxMjhSZWFkZXIuQ09ERV9QQVRURVJOUy5sZW5ndGg7IGQrKykge1xyXG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IENvZGUxMjhSZWFkZXIuQ09ERV9QQVRURVJOU1tkXTtcclxuICAgICAgICAgICAgdmFyIHZhcmlhbmNlID0gdGhpcy5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgcGF0dGVybiwgQ29kZTEyOFJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSk7XHJcbiAgICAgICAgICAgIGlmICh2YXJpYW5jZSA8IGJlc3RWYXJpYW5jZSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdFZhcmlhbmNlID0gdmFyaWFuY2U7XHJcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gV2UncmUgb3Zlcmxvb2tpbmcgdGhlIGZhY3QgdGhhdCB0aGUgU1RPUCBwYXR0ZXJuIGhhcyA3IHZhbHVlcywgbm90IDYuXHJcbiAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvZGUxMjhSZWFkZXIucHJvdG90eXBlLmRlY29kZVJvdyA9IGZ1bmN0aW9uIChyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcclxuICAgICAgICB2YXIgY29udmVydEZOQzEgPSBoaW50cyAmJiAoaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5BU1NVTUVfR1MxKSA9PT0gdHJ1ZSk7XHJcbiAgICAgICAgdmFyIHN0YXJ0UGF0dGVybkluZm8gPSBDb2RlMTI4UmVhZGVyLmZpbmRTdGFydFBhdHRlcm4ocm93KTtcclxuICAgICAgICB2YXIgc3RhcnRDb2RlID0gc3RhcnRQYXR0ZXJuSW5mb1syXTtcclxuICAgICAgICB2YXIgY3VycmVudFJhd0NvZGVzSW5kZXggPSAwO1xyXG4gICAgICAgIHZhciByYXdDb2RlcyA9IG5ldyBVaW50OEFycmF5KDIwKTtcclxuICAgICAgICByYXdDb2Rlc1tjdXJyZW50UmF3Q29kZXNJbmRleCsrXSA9IHN0YXJ0Q29kZTtcclxuICAgICAgICB2YXIgY29kZVNldDtcclxuICAgICAgICBzd2l0Y2ggKHN0YXJ0Q29kZSkge1xyXG4gICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9BOlxyXG4gICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQjpcclxuICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9CO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0M6XHJcbiAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaXNOZXh0U2hpZnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgICAgICB2YXIgbGFzdFN0YXJ0ID0gc3RhcnRQYXR0ZXJuSW5mb1swXTtcclxuICAgICAgICB2YXIgbmV4dFN0YXJ0ID0gc3RhcnRQYXR0ZXJuSW5mb1sxXTtcclxuICAgICAgICB2YXIgY291bnRlcnMgPSBbMCwgMCwgMCwgMCwgMCwgMF07XHJcbiAgICAgICAgdmFyIGxhc3RDb2RlID0gMDtcclxuICAgICAgICB2YXIgY29kZSA9IDA7XHJcbiAgICAgICAgdmFyIGNoZWNrc3VtVG90YWwgPSBzdGFydENvZGU7XHJcbiAgICAgICAgdmFyIG11bHRpcGxpZXIgPSAwO1xyXG4gICAgICAgIHZhciBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlID0gdHJ1ZTtcclxuICAgICAgICB2YXIgdXBwZXJNb2RlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XHJcbiAgICAgICAgICAgIHZhciB1bnNoaWZ0ID0gaXNOZXh0U2hpZnRlZDtcclxuICAgICAgICAgICAgaXNOZXh0U2hpZnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBTYXZlIG9mZiBsYXN0IGNvZGVcclxuICAgICAgICAgICAgbGFzdENvZGUgPSBjb2RlO1xyXG4gICAgICAgICAgICAvLyBEZWNvZGUgYW5vdGhlciBjb2RlIGZyb20gaW1hZ2VcclxuICAgICAgICAgICAgY29kZSA9IENvZGUxMjhSZWFkZXIuZGVjb2RlQ29kZShyb3csIGNvdW50ZXJzLCBuZXh0U3RhcnQpO1xyXG4gICAgICAgICAgICByYXdDb2Rlc1tjdXJyZW50UmF3Q29kZXNJbmRleCsrXSA9IGNvZGU7XHJcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHdoZXRoZXIgdGhlIGxhc3QgY29kZSB3YXMgcHJpbnRhYmxlIG9yIG5vdCAoZXhjbHVkaW5nIENPREVfU1RPUClcclxuICAgICAgICAgICAgaWYgKGNvZGUgIT09IENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBZGQgdG8gY2hlY2tzdW0gY29tcHV0YXRpb24gKGlmIG5vdCBDT0RFX1NUT1Agb2YgY291cnNlKVxyXG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gQ29kZTEyOFJlYWRlci5DT0RFX1NUT1ApIHtcclxuICAgICAgICAgICAgICAgIG11bHRpcGxpZXIrKztcclxuICAgICAgICAgICAgICAgIGNoZWNrc3VtVG90YWwgKz0gbXVsdGlwbGllciAqIGNvZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB3aGVyZSB0aGUgbmV4dCBjb2RlIHdpbGwgdG8gc3RhcnRcclxuICAgICAgICAgICAgbGFzdFN0YXJ0ID0gbmV4dFN0YXJ0O1xyXG4gICAgICAgICAgICBuZXh0U3RhcnQgKz0gY291bnRlcnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywgY3VycmVudCkgeyByZXR1cm4gcHJldmlvdXMgKyBjdXJyZW50OyB9LCAwKTtcclxuICAgICAgICAgICAgLy8gVGFrZSBjYXJlIG9mIGlsbGVnYWwgc3RhcnQgY29kZXNcclxuICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9BOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQjpcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0M6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGVTZXQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA8IDY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGlmdFVwcGVyTW9kZSA9PT0gdXBwZXJNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJyAnLmNoYXJDb2RlQXQoMCkgKyBjb2RlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJyAnLmNoYXJDb2RlQXQoMCkgKyBjb2RlICsgMTI4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29kZSA8IDk2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaGlmdFVwcGVyTW9kZSA9PT0gdXBwZXJNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSAtIDY0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSArIDY0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGxldCBDT0RFX1NUT1AsIHdoaWNoIGFsd2F5cyBhcHBlYXJzLCBhZmZlY3Qgd2hldGhlciB3aGV0aGVyIHdlIHRoaW5rIHRoZSBsYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgd2FzIHByaW50YWJsZSBvciBub3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENoYXJhY3Rlcldhc1ByaW50YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZlcnRGTkMxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuMy43LiBhbmQgNS40LjYuNC4gSWYgdGhlIGZpcnN0IGNoYXIgYWZ0ZXIgdGhlIHN0YXJ0IGNvZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIEZOQzEgdGhlbiB0aGlzIGlzIEdTMS0xMjguIFdlIGFkZCB0aGUgc3ltYm9sb2d5IGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ11DMSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuNy41LiBFdmVyeSBzdWJzZXF1ZW50IEZOQzEgaXMgcmV0dXJuZWQgYXMgQVNDSUkgMjkgKEdTKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzRfQTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVwcGVyTW9kZSAmJiBzaGlmdFVwcGVyTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlck1vZGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh1cHBlck1vZGUgJiYgc2hpZnRVcHBlck1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBwZXJNb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU0hJRlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXh0U2hpZnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZVNldCA9IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9COlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2RlIDwgOTYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoaWZ0VXBwZXJNb2RlID09PSB1cHBlck1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnICcuY2hhckNvZGVBdCgwKSArIGNvZGUgKyAxMjgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdFVwcGVyTW9kZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENvZGUxMjhSZWFkZXIuQ09ERV9TVE9QKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmVydEZOQzEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC4zLjcuIGFuZCA1LjQuNi40LiBJZiB0aGUgZmlyc3QgY2hhciBhZnRlciB0aGUgc3RhcnQgY29kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgRk5DMSB0aGVuIHRoaXMgaXMgR1MxLTEyOC4gV2UgYWRkIHRoZSBzeW1ib2xvZ3kgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXUMxJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdTMSBzcGVjaWZpY2F0aW9uIDUuNC43LjUuIEV2ZXJ5IHN1YnNlcXVlbnQgRk5DMSBpcyByZXR1cm5lZCBhcyBBU0NJSSAyOSAoR1MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyOSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18zOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmc/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfNF9COlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXBwZXJNb2RlICYmIHNoaWZ0VXBwZXJNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwcGVyTW9kZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVwcGVyTW9kZSAmJiBzaGlmdFVwcGVyTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cHBlck1vZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnRVcHBlck1vZGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0VXBwZXJNb2RlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9TSElGVDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05leHRTaGlmdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlU2V0ID0gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ29kZTEyOFJlYWRlci5DT0RFX1NUT1A6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0M6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCAxMDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCAxMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcwJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gY29kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdENoYXJhY3Rlcldhc1ByaW50YWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZlcnRGTkMxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuMy43LiBhbmQgNS40LjYuNC4gSWYgdGhlIGZpcnN0IGNoYXIgYWZ0ZXIgdGhlIHN0YXJ0IGNvZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIEZOQzEgdGhlbiB0aGlzIGlzIEdTMS0xMjguIFdlIGFkZCB0aGUgc3ltYm9sb2d5IGlkZW50aWZpZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ11DMSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHUzEgc3BlY2lmaWNhdGlvbiA1LjQuNy41LiBFdmVyeSBzdWJzZXF1ZW50IEZOQzEgaXMgcmV0dXJuZWQgYXMgQVNDSUkgMjkgKEdTKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9COlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9CO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBVbnNoaWZ0IGJhY2sgdG8gYW5vdGhlciBjb2RlIHNldCBpZiB3ZSB3ZXJlIHNoaWZ0ZWRcclxuICAgICAgICAgICAgaWYgKHVuc2hpZnQpIHtcclxuICAgICAgICAgICAgICAgIGNvZGVTZXQgPSBjb2RlU2V0ID09PSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BID8gQ29kZTEyOFJlYWRlci5DT0RFX0NPREVfQiA6IENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0E7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxhc3RQYXR0ZXJuU2l6ZSA9IG5leHRTdGFydCAtIGxhc3RTdGFydDtcclxuICAgICAgICAvLyBDaGVjayBmb3IgYW1wbGUgd2hpdGVzcGFjZSBmb2xsb3dpbmcgcGF0dGVybiwgYnV0LCB0byBkbyB0aGlzIHdlIGZpcnN0IG5lZWQgdG8gcmVtZW1iZXIgdGhhdFxyXG4gICAgICAgIC8vIHdlIGZ1ZGdlZCBkZWNvZGluZyBDT0RFX1NUT1Agc2luY2UgaXQgYWN0dWFsbHkgaGFzIDcgYmFycywgbm90IDYuIFRoZXJlIGlzIGEgYmxhY2sgYmFyIGxlZnRcclxuICAgICAgICAvLyB0byByZWFkIG9mZi4gV291bGQgYmUgc2xpZ2h0bHkgYmV0dGVyIHRvIHByb3Blcmx5IHJlYWQuIEhlcmUgd2UganVzdCBza2lwIGl0OlxyXG4gICAgICAgIG5leHRTdGFydCA9IHJvdy5nZXROZXh0VW5zZXQobmV4dFN0YXJ0KTtcclxuICAgICAgICBpZiAoIXJvdy5pc1JhbmdlKG5leHRTdGFydCwgTWF0aC5taW4ocm93LmdldFNpemUoKSwgbmV4dFN0YXJ0ICsgKG5leHRTdGFydCAtIGxhc3RTdGFydCkgLyAyKSwgZmFsc2UpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHVsbCBvdXQgZnJvbSBzdW0gdGhlIHZhbHVlIG9mIHRoZSBwZW51bHRpbWF0ZSBjaGVjayBjb2RlXHJcbiAgICAgICAgY2hlY2tzdW1Ub3RhbCAtPSBtdWx0aXBsaWVyICogbGFzdENvZGU7XHJcbiAgICAgICAgLy8gbGFzdENvZGUgaXMgdGhlIGNoZWNrc3VtIHRoZW46XHJcbiAgICAgICAgaWYgKGNoZWNrc3VtVG90YWwgJSAxMDMgIT09IGxhc3RDb2RlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTmVlZCB0byBwdWxsIG91dCB0aGUgY2hlY2sgZGlnaXRzIGZyb20gc3RyaW5nXHJcbiAgICAgICAgdmFyIHJlc3VsdExlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHJlc3VsdExlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvLyBmYWxzZSBwb3NpdGl2ZVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE9ubHkgYm90aGVyIGlmIHRoZSByZXN1bHQgaGFkIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIsIGFuZCBpZiB0aGUgY2hlY2tzdW0gZGlnaXQgaGFwcGVuZWQgdG9cclxuICAgICAgICAvLyBiZSBhIHByaW50YWJsZSBjaGFyYWN0ZXIuIElmIGl0IHdhcyBqdXN0IGludGVycHJldGVkIGFzIGEgY29udHJvbCBjb2RlLCBub3RoaW5nIHRvIHJlbW92ZS5cclxuICAgICAgICBpZiAocmVzdWx0TGVuZ3RoID4gMCAmJiBsYXN0Q2hhcmFjdGVyV2FzUHJpbnRhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2RlU2V0ID09PSBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9DKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc3Vic3RyaW5nKDAsIHJlc3VsdExlbmd0aCAtIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZygwLCByZXN1bHRMZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGVmdCA9IChzdGFydFBhdHRlcm5JbmZvWzFdICsgc3RhcnRQYXR0ZXJuSW5mb1swXSkgLyAyLjA7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gbGFzdFN0YXJ0ICsgbGFzdFBhdHRlcm5TaXplIC8gMi4wO1xyXG4gICAgICAgIHZhciByYXdDb2Rlc1NpemUgPSByYXdDb2Rlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHJhd0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkocmF3Q29kZXNTaXplKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NvZGVzU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJhd0J5dGVzW2ldID0gcmF3Q29kZXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb2ludHMgPSBbbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChsZWZ0LCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHJpZ2h0LCByb3dOdW1iZXIpXTtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdF8xLmRlZmF1bHQocmVzdWx0LCByYXdCeXRlcywgMCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5DT0RFXzEyOCwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xyXG4gICAgfTtcclxuICAgIENvZGUxMjhSZWFkZXIuQ09ERV9QQVRURVJOUyA9IFtcclxuICAgICAgICBbMiwgMSwgMiwgMiwgMiwgMl0sXHJcbiAgICAgICAgWzIsIDIsIDIsIDEsIDIsIDJdLFxyXG4gICAgICAgIFsyLCAyLCAyLCAyLCAyLCAxXSxcclxuICAgICAgICBbMSwgMiwgMSwgMiwgMiwgM10sXHJcbiAgICAgICAgWzEsIDIsIDEsIDMsIDIsIDJdLFxyXG4gICAgICAgIFsxLCAzLCAxLCAyLCAyLCAyXSxcclxuICAgICAgICBbMSwgMiwgMiwgMiwgMSwgM10sXHJcbiAgICAgICAgWzEsIDIsIDIsIDMsIDEsIDJdLFxyXG4gICAgICAgIFsxLCAzLCAyLCAyLCAxLCAyXSxcclxuICAgICAgICBbMiwgMiwgMSwgMiwgMSwgM10sXHJcbiAgICAgICAgWzIsIDIsIDEsIDMsIDEsIDJdLFxyXG4gICAgICAgIFsyLCAzLCAxLCAyLCAxLCAyXSxcclxuICAgICAgICBbMSwgMSwgMiwgMiwgMywgMl0sXHJcbiAgICAgICAgWzEsIDIsIDIsIDEsIDMsIDJdLFxyXG4gICAgICAgIFsxLCAyLCAyLCAyLCAzLCAxXSxcclxuICAgICAgICBbMSwgMSwgMywgMiwgMiwgMl0sXHJcbiAgICAgICAgWzEsIDIsIDMsIDEsIDIsIDJdLFxyXG4gICAgICAgIFsxLCAyLCAzLCAyLCAyLCAxXSxcclxuICAgICAgICBbMiwgMiwgMywgMiwgMSwgMV0sXHJcbiAgICAgICAgWzIsIDIsIDEsIDEsIDMsIDJdLFxyXG4gICAgICAgIFsyLCAyLCAxLCAyLCAzLCAxXSxcclxuICAgICAgICBbMiwgMSwgMywgMiwgMSwgMl0sXHJcbiAgICAgICAgWzIsIDIsIDMsIDEsIDEsIDJdLFxyXG4gICAgICAgIFszLCAxLCAyLCAxLCAzLCAxXSxcclxuICAgICAgICBbMywgMSwgMSwgMiwgMiwgMl0sXHJcbiAgICAgICAgWzMsIDIsIDEsIDEsIDIsIDJdLFxyXG4gICAgICAgIFszLCAyLCAxLCAyLCAyLCAxXSxcclxuICAgICAgICBbMywgMSwgMiwgMiwgMSwgMl0sXHJcbiAgICAgICAgWzMsIDIsIDIsIDEsIDEsIDJdLFxyXG4gICAgICAgIFszLCAyLCAyLCAyLCAxLCAxXSxcclxuICAgICAgICBbMiwgMSwgMiwgMSwgMiwgM10sXHJcbiAgICAgICAgWzIsIDEsIDIsIDMsIDIsIDFdLFxyXG4gICAgICAgIFsyLCAzLCAyLCAxLCAyLCAxXSxcclxuICAgICAgICBbMSwgMSwgMSwgMywgMiwgM10sXHJcbiAgICAgICAgWzEsIDMsIDEsIDEsIDIsIDNdLFxyXG4gICAgICAgIFsxLCAzLCAxLCAzLCAyLCAxXSxcclxuICAgICAgICBbMSwgMSwgMiwgMywgMSwgM10sXHJcbiAgICAgICAgWzEsIDMsIDIsIDEsIDEsIDNdLFxyXG4gICAgICAgIFsxLCAzLCAyLCAzLCAxLCAxXSxcclxuICAgICAgICBbMiwgMSwgMSwgMywgMSwgM10sXHJcbiAgICAgICAgWzIsIDMsIDEsIDEsIDEsIDNdLFxyXG4gICAgICAgIFsyLCAzLCAxLCAzLCAxLCAxXSxcclxuICAgICAgICBbMSwgMSwgMiwgMSwgMywgM10sXHJcbiAgICAgICAgWzEsIDEsIDIsIDMsIDMsIDFdLFxyXG4gICAgICAgIFsxLCAzLCAyLCAxLCAzLCAxXSxcclxuICAgICAgICBbMSwgMSwgMywgMSwgMiwgM10sXHJcbiAgICAgICAgWzEsIDEsIDMsIDMsIDIsIDFdLFxyXG4gICAgICAgIFsxLCAzLCAzLCAxLCAyLCAxXSxcclxuICAgICAgICBbMywgMSwgMywgMSwgMiwgMV0sXHJcbiAgICAgICAgWzIsIDEsIDEsIDMsIDMsIDFdLFxyXG4gICAgICAgIFsyLCAzLCAxLCAxLCAzLCAxXSxcclxuICAgICAgICBbMiwgMSwgMywgMSwgMSwgM10sXHJcbiAgICAgICAgWzIsIDEsIDMsIDMsIDEsIDFdLFxyXG4gICAgICAgIFsyLCAxLCAzLCAxLCAzLCAxXSxcclxuICAgICAgICBbMywgMSwgMSwgMSwgMiwgM10sXHJcbiAgICAgICAgWzMsIDEsIDEsIDMsIDIsIDFdLFxyXG4gICAgICAgIFszLCAzLCAxLCAxLCAyLCAxXSxcclxuICAgICAgICBbMywgMSwgMiwgMSwgMSwgM10sXHJcbiAgICAgICAgWzMsIDEsIDIsIDMsIDEsIDFdLFxyXG4gICAgICAgIFszLCAzLCAyLCAxLCAxLCAxXSxcclxuICAgICAgICBbMywgMSwgNCwgMSwgMSwgMV0sXHJcbiAgICAgICAgWzIsIDIsIDEsIDQsIDEsIDFdLFxyXG4gICAgICAgIFs0LCAzLCAxLCAxLCAxLCAxXSxcclxuICAgICAgICBbMSwgMSwgMSwgMiwgMiwgNF0sXHJcbiAgICAgICAgWzEsIDEsIDEsIDQsIDIsIDJdLFxyXG4gICAgICAgIFsxLCAyLCAxLCAxLCAyLCA0XSxcclxuICAgICAgICBbMSwgMiwgMSwgNCwgMiwgMV0sXHJcbiAgICAgICAgWzEsIDQsIDEsIDEsIDIsIDJdLFxyXG4gICAgICAgIFsxLCA0LCAxLCAyLCAyLCAxXSxcclxuICAgICAgICBbMSwgMSwgMiwgMiwgMSwgNF0sXHJcbiAgICAgICAgWzEsIDEsIDIsIDQsIDEsIDJdLFxyXG4gICAgICAgIFsxLCAyLCAyLCAxLCAxLCA0XSxcclxuICAgICAgICBbMSwgMiwgMiwgNCwgMSwgMV0sXHJcbiAgICAgICAgWzEsIDQsIDIsIDEsIDEsIDJdLFxyXG4gICAgICAgIFsxLCA0LCAyLCAyLCAxLCAxXSxcclxuICAgICAgICBbMiwgNCwgMSwgMiwgMSwgMV0sXHJcbiAgICAgICAgWzIsIDIsIDEsIDEsIDEsIDRdLFxyXG4gICAgICAgIFs0LCAxLCAzLCAxLCAxLCAxXSxcclxuICAgICAgICBbMiwgNCwgMSwgMSwgMSwgMl0sXHJcbiAgICAgICAgWzEsIDMsIDQsIDEsIDEsIDFdLFxyXG4gICAgICAgIFsxLCAxLCAxLCAyLCA0LCAyXSxcclxuICAgICAgICBbMSwgMiwgMSwgMSwgNCwgMl0sXHJcbiAgICAgICAgWzEsIDIsIDEsIDIsIDQsIDFdLFxyXG4gICAgICAgIFsxLCAxLCA0LCAyLCAxLCAyXSxcclxuICAgICAgICBbMSwgMiwgNCwgMSwgMSwgMl0sXHJcbiAgICAgICAgWzEsIDIsIDQsIDIsIDEsIDFdLFxyXG4gICAgICAgIFs0LCAxLCAxLCAyLCAxLCAyXSxcclxuICAgICAgICBbNCwgMiwgMSwgMSwgMSwgMl0sXHJcbiAgICAgICAgWzQsIDIsIDEsIDIsIDEsIDFdLFxyXG4gICAgICAgIFsyLCAxLCAyLCAxLCA0LCAxXSxcclxuICAgICAgICBbMiwgMSwgNCwgMSwgMiwgMV0sXHJcbiAgICAgICAgWzQsIDEsIDIsIDEsIDIsIDFdLFxyXG4gICAgICAgIFsxLCAxLCAxLCAxLCA0LCAzXSxcclxuICAgICAgICBbMSwgMSwgMSwgMywgNCwgMV0sXHJcbiAgICAgICAgWzEsIDMsIDEsIDEsIDQsIDFdLFxyXG4gICAgICAgIFsxLCAxLCA0LCAxLCAxLCAzXSxcclxuICAgICAgICBbMSwgMSwgNCwgMywgMSwgMV0sXHJcbiAgICAgICAgWzQsIDEsIDEsIDEsIDEsIDNdLFxyXG4gICAgICAgIFs0LCAxLCAxLCAzLCAxLCAxXSxcclxuICAgICAgICBbMSwgMSwgMywgMSwgNCwgMV0sXHJcbiAgICAgICAgWzEsIDEsIDQsIDEsIDMsIDFdLFxyXG4gICAgICAgIFszLCAxLCAxLCAxLCA0LCAxXSxcclxuICAgICAgICBbNCwgMSwgMSwgMSwgMywgMV0sXHJcbiAgICAgICAgWzIsIDEsIDEsIDQsIDEsIDJdLFxyXG4gICAgICAgIFsyLCAxLCAxLCAyLCAxLCA0XSxcclxuICAgICAgICBbMiwgMSwgMSwgMiwgMywgMl0sXHJcbiAgICAgICAgWzIsIDMsIDMsIDEsIDEsIDEsIDJdXHJcbiAgICBdO1xyXG4gICAgQ29kZTEyOFJlYWRlci5NQVhfQVZHX1ZBUklBTkNFID0gMC4yNTtcclxuICAgIENvZGUxMjhSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UgPSAwLjc7XHJcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU0hJRlQgPSA5ODtcclxuICAgIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0MgPSA5OTtcclxuICAgIENvZGUxMjhSZWFkZXIuQ09ERV9DT0RFX0IgPSAxMDA7XHJcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfQ09ERV9BID0gMTAxO1xyXG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18xID0gMTAyO1xyXG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ18yID0gOTc7XHJcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfRk5DXzMgPSA5NjtcclxuICAgIENvZGUxMjhSZWFkZXIuQ09ERV9GTkNfNF9BID0gMTAxO1xyXG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX0ZOQ180X0IgPSAxMDA7XHJcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU1RBUlRfQSA9IDEwMztcclxuICAgIENvZGUxMjhSZWFkZXIuQ09ERV9TVEFSVF9CID0gMTA0O1xyXG4gICAgQ29kZTEyOFJlYWRlci5DT0RFX1NUQVJUX0MgPSAxMDU7XHJcbiAgICBDb2RlMTI4UmVhZGVyLkNPREVfU1RPUCA9IDEwNjtcclxuICAgIHJldHVybiBDb2RlMTI4UmVhZGVyO1xyXG59KE9uZURSZWFkZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvZGUxMjhSZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvZGUxMjhSZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5vbmVkIHsqL1xyXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XHJcbnZhciBDaGVja3N1bUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0NoZWNrc3VtRXhjZXB0aW9uXCIpO1xyXG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxudmFyIE9uZURSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL09uZURSZWFkZXJcIik7XHJcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRcIik7XHJcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFBvaW50XCIpO1xyXG4vKipcclxuICogPHA+RGVjb2RlcyBDb2RlIDM5IGJhcmNvZGVzLiBTdXBwb3J0cyBcIkZ1bGwgQVNDSUkgQ29kZSAzOVwiIGlmIFVTRV9DT0RFXzM5X0VYVEVOREVEX01PREUgaXMgc2V0LjwvcD5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICogQHNlZSBDb2RlOTNSZWFkZXJcclxuICovXHJcbnZhciBDb2RlMzlSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQ29kZTM5UmVhZGVyLCBfc3VwZXIpO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcmVhZGVyIHRoYXQgYXNzdW1lcyBhbGwgZW5jb2RlZCBkYXRhIGlzIGRhdGEsIGFuZCBkb2VzIG5vdCB0cmVhdCB0aGUgZmluYWxcclxuICAgICAqIGNoYXJhY3RlciBhcyBhIGNoZWNrIGRpZ2l0LiBJdCB3aWxsIG5vdCBkZWNvZGVkIFwiZXh0ZW5kZWQgQ29kZSAzOVwiIHNlcXVlbmNlcy5cclxuICAgICAqL1xyXG4gICAgLy8gcHVibGljIENvZGUzOVJlYWRlcigpIHtcclxuICAgIC8vICAgdGhpcyhmYWxzZSk7XHJcbiAgICAvLyB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSByZWFkZXIgdGhhdCBjYW4gYmUgY29uZmlndXJlZCB0byBjaGVjayB0aGUgbGFzdCBjaGFyYWN0ZXIgYXMgYSBjaGVjayBkaWdpdC5cclxuICAgICAqIEl0IHdpbGwgbm90IGRlY29kZWQgXCJleHRlbmRlZCBDb2RlIDM5XCIgc2VxdWVuY2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1c2luZ0NoZWNrRGlnaXQgaWYgdHJ1ZSwgdHJlYXQgdGhlIGxhc3QgZGF0YSBjaGFyYWN0ZXIgYXMgYSBjaGVjayBkaWdpdCwgbm90XHJcbiAgICAgKiBkYXRhLCBhbmQgdmVyaWZ5IHRoYXQgdGhlIGNoZWNrc3VtIHBhc3Nlcy5cclxuICAgICAqL1xyXG4gICAgLy8gcHVibGljIENvZGUzOVJlYWRlcihib29sZWFuIHVzaW5nQ2hlY2tEaWdpdCkge1xyXG4gICAgLy8gICB0aGlzKHVzaW5nQ2hlY2tEaWdpdCwgZmFsc2UpO1xyXG4gICAgLy8gfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcmVhZGVyIHRoYXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gY2hlY2sgdGhlIGxhc3QgY2hhcmFjdGVyIGFzIGEgY2hlY2sgZGlnaXQsXHJcbiAgICAgKiBvciBvcHRpb25hbGx5IGF0dGVtcHQgdG8gZGVjb2RlIFwiZXh0ZW5kZWQgQ29kZSAzOVwiIHNlcXVlbmNlcyB0aGF0IGFyZSB1c2VkIHRvIGVuY29kZVxyXG4gICAgICogdGhlIGZ1bGwgQVNDSUkgY2hhcmFjdGVyIHNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdXNpbmdDaGVja0RpZ2l0IGlmIHRydWUsIHRyZWF0IHRoZSBsYXN0IGRhdGEgY2hhcmFjdGVyIGFzIGEgY2hlY2sgZGlnaXQsIG5vdFxyXG4gICAgICogZGF0YSwgYW5kIHZlcmlmeSB0aGF0IHRoZSBjaGVja3N1bSBwYXNzZXMuXHJcbiAgICAgKiBAcGFyYW0gZXh0ZW5kZWRNb2RlIGlmIHRydWUsIHdpbGwgYXR0ZW1wdCB0byBkZWNvZGUgZXh0ZW5kZWQgQ29kZSAzOSBzZXF1ZW5jZXMgaW4gdGhlXHJcbiAgICAgKiB0ZXh0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBDb2RlMzlSZWFkZXIodXNpbmdDaGVja0RpZ2l0LCBleHRlbmRlZE1vZGUpIHtcclxuICAgICAgICBpZiAodXNpbmdDaGVja0RpZ2l0ID09PSB2b2lkIDApIHsgdXNpbmdDaGVja0RpZ2l0ID0gZmFsc2U7IH1cclxuICAgICAgICBpZiAoZXh0ZW5kZWRNb2RlID09PSB2b2lkIDApIHsgZXh0ZW5kZWRNb2RlID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnVzaW5nQ2hlY2tEaWdpdCA9IHVzaW5nQ2hlY2tEaWdpdDtcclxuICAgICAgICBfdGhpcy5leHRlbmRlZE1vZGUgPSBleHRlbmRlZE1vZGU7XHJcbiAgICAgICAgX3RoaXMuZGVjb2RlUm93UmVzdWx0ID0gJyc7XHJcbiAgICAgICAgX3RoaXMuY291bnRlcnMgPSBuZXcgQXJyYXkoOSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQ29kZTM5UmVhZGVyLnByb3RvdHlwZS5kZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XHJcbiAgICAgICAgdmFyIHRoZUNvdW50ZXJzID0gdGhpcy5jb3VudGVycztcclxuICAgICAgICB0aGVDb3VudGVycy5maWxsKDApO1xyXG4gICAgICAgIHRoaXMuZGVjb2RlUm93UmVzdWx0ID0gJyc7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gQ29kZTM5UmVhZGVyLmZpbmRBc3Rlcmlza1BhdHRlcm4ocm93LCB0aGVDb3VudGVycyk7XHJcbiAgICAgICAgLy8gUmVhZCBvZmYgd2hpdGUgc3BhY2VcclxuICAgICAgICB2YXIgbmV4dFN0YXJ0ID0gcm93LmdldE5leHRTZXQoc3RhcnRbMV0pO1xyXG4gICAgICAgIHZhciBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHZhciBkZWNvZGVkQ2hhcjtcclxuICAgICAgICB2YXIgbGFzdFN0YXJ0O1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgQ29kZTM5UmVhZGVyLnJlY29yZFBhdHRlcm4ocm93LCBuZXh0U3RhcnQsIHRoZUNvdW50ZXJzKTtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBDb2RlMzlSZWFkZXIudG9OYXJyb3dXaWRlUGF0dGVybih0aGVDb3VudGVycyk7XHJcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlY29kZWRDaGFyID0gQ29kZTM5UmVhZGVyLnBhdHRlcm5Ub0NoYXIocGF0dGVybik7XHJcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlUm93UmVzdWx0ICs9IGRlY29kZWRDaGFyO1xyXG4gICAgICAgICAgICBsYXN0U3RhcnQgPSBuZXh0U3RhcnQ7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0aGVDb3VudGVyc18xID0gX192YWx1ZXModGhlQ291bnRlcnMpLCB0aGVDb3VudGVyc18xXzEgPSB0aGVDb3VudGVyc18xLm5leHQoKTsgIXRoZUNvdW50ZXJzXzFfMS5kb25lOyB0aGVDb3VudGVyc18xXzEgPSB0aGVDb3VudGVyc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudGVyID0gdGhlQ291bnRlcnNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGFydCArPSBjb3VudGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhlQ291bnRlcnNfMV8xICYmICF0aGVDb3VudGVyc18xXzEuZG9uZSAmJiAoX2EgPSB0aGVDb3VudGVyc18xLnJldHVybikpIF9hLmNhbGwodGhlQ291bnRlcnNfMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUmVhZCBvZmYgd2hpdGUgc3BhY2VcclxuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gcm93LmdldE5leHRTZXQobmV4dFN0YXJ0KTtcclxuICAgICAgICB9IHdoaWxlIChkZWNvZGVkQ2hhciAhPT0gJyonKTtcclxuICAgICAgICB0aGlzLmRlY29kZVJvd1Jlc3VsdCA9IHRoaXMuZGVjb2RlUm93UmVzdWx0LnN1YnN0cmluZygwLCB0aGlzLmRlY29kZVJvd1Jlc3VsdC5sZW5ndGggLSAxKTsgLy8gcmVtb3ZlIGFzdGVyaXNrXHJcbiAgICAgICAgLy8gTG9vayBmb3Igd2hpdGVzcGFjZSBhZnRlciBwYXR0ZXJuOlxyXG4gICAgICAgIHZhciBsYXN0UGF0dGVyblNpemUgPSAwO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHRoZUNvdW50ZXJzXzIgPSBfX3ZhbHVlcyh0aGVDb3VudGVycyksIHRoZUNvdW50ZXJzXzJfMSA9IHRoZUNvdW50ZXJzXzIubmV4dCgpOyAhdGhlQ291bnRlcnNfMl8xLmRvbmU7IHRoZUNvdW50ZXJzXzJfMSA9IHRoZUNvdW50ZXJzXzIubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IHRoZUNvdW50ZXJzXzJfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGxhc3RQYXR0ZXJuU2l6ZSArPSBjb3VudGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhlQ291bnRlcnNfMl8xICYmICF0aGVDb3VudGVyc18yXzEuZG9uZSAmJiAoX2IgPSB0aGVDb3VudGVyc18yLnJldHVybikpIF9iLmNhbGwodGhlQ291bnRlcnNfMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd2hpdGVTcGFjZUFmdGVyRW5kID0gbmV4dFN0YXJ0IC0gbGFzdFN0YXJ0IC0gbGFzdFBhdHRlcm5TaXplO1xyXG4gICAgICAgIC8vIElmIDUwJSBvZiBsYXN0IHBhdHRlcm4gc2l6ZSwgZm9sbG93aW5nIGxhc3QgcGF0dGVybiwgaXMgbm90IHdoaXRlc3BhY2UsIGZhaWxcclxuICAgICAgICAvLyAoYnV0IGlmIGl0J3Mgd2hpdGVzcGFjZSB0byB0aGUgdmVyeSBlbmQgb2YgdGhlIGltYWdlLCB0aGF0J3MgT0spXHJcbiAgICAgICAgaWYgKG5leHRTdGFydCAhPT0gZW5kICYmICh3aGl0ZVNwYWNlQWZ0ZXJFbmQgKiAyKSA8IGxhc3RQYXR0ZXJuU2l6ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnVzaW5nQ2hlY2tEaWdpdCkge1xyXG4gICAgICAgICAgICB2YXIgbWF4ID0gdGhpcy5kZWNvZGVSb3dSZXN1bHQubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdG90YWwgKz0gQ29kZTM5UmVhZGVyLkFMUEhBQkVUX1NUUklORy5pbmRleE9mKHRoaXMuZGVjb2RlUm93UmVzdWx0LmNoYXJBdChpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVjb2RlUm93UmVzdWx0LmNoYXJBdChtYXgpICE9PSBDb2RlMzlSZWFkZXIuQUxQSEFCRVRfU1RSSU5HLmNoYXJBdCh0b3RhbCAlIDQzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlUm93UmVzdWx0ID0gdGhpcy5kZWNvZGVSb3dSZXN1bHQuc3Vic3RyaW5nKDAsIG1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRlY29kZVJvd1Jlc3VsdC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgLy8gZmFsc2UgcG9zaXRpdmVcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0U3RyaW5nO1xyXG4gICAgICAgIGlmICh0aGlzLmV4dGVuZGVkTW9kZSkge1xyXG4gICAgICAgICAgICByZXN1bHRTdHJpbmcgPSBDb2RlMzlSZWFkZXIuZGVjb2RlRXh0ZW5kZWQodGhpcy5kZWNvZGVSb3dSZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0U3RyaW5nID0gdGhpcy5kZWNvZGVSb3dSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsZWZ0ID0gKHN0YXJ0WzFdICsgc3RhcnRbMF0pIC8gMi4wO1xyXG4gICAgICAgIHZhciByaWdodCA9IGxhc3RTdGFydCArIGxhc3RQYXR0ZXJuU2l6ZSAvIDIuMDtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdF8xLmRlZmF1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAwLCBbbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChsZWZ0LCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHJpZ2h0LCByb3dOdW1iZXIpXSwgQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuQ09ERV8zOSwgbmV3IERhdGUoKS5nZXRUaW1lKCkpO1xyXG4gICAgfTtcclxuICAgIENvZGUzOVJlYWRlci5maW5kQXN0ZXJpc2tQYXR0ZXJuID0gZnVuY3Rpb24gKHJvdywgY291bnRlcnMpIHtcclxuICAgICAgICB2YXIgd2lkdGggPSByb3cuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHZhciByb3dPZmZzZXQgPSByb3cuZ2V0TmV4dFNldCgwKTtcclxuICAgICAgICB2YXIgY291bnRlclBvc2l0aW9uID0gMDtcclxuICAgICAgICB2YXIgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xyXG4gICAgICAgIHZhciBpc1doaXRlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHBhdHRlcm5MZW5ndGggPSBjb3VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHJvd09mZnNldDsgaSA8IHdpZHRoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHJvdy5nZXQoaSkgIT09IGlzV2hpdGUpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3Igd2hpdGVzcGFjZSBiZWZvcmUgc3RhcnQgcGF0dGVybiwgPj0gNTAlIG9mIHdpZHRoIG9mIHN0YXJ0IHBhdHRlcm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b05hcnJvd1dpZGVQYXR0ZXJuKGNvdW50ZXJzKSA9PT0gQ29kZTM5UmVhZGVyLkFTVEVSSVNLX0VOQ09ESU5HICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5pc1JhbmdlKE1hdGgubWF4KDAsIHBhdHRlcm5TdGFydCAtIE1hdGguZmxvb3IoKGkgLSBwYXR0ZXJuU3RhcnQpIC8gMikpLCBwYXR0ZXJuU3RhcnQsIGZhbHNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3BhdHRlcm5TdGFydCwgaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm5TdGFydCArPSBjb3VudGVyc1swXSArIGNvdW50ZXJzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzLmNvcHlXaXRoaW4oMCwgMiwgMiArIGNvdW50ZXJQb3NpdGlvbiAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbiAtIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIC8vIEZvciBlZmZpY2llbmN5LCByZXR1cm5zIC0xIG9uIGZhaWx1cmUuIE5vdCB0aHJvd2luZyBoZXJlIHNhdmVkIGFzIG1hbnkgYXMgNzAwIGV4Y2VwdGlvbnNcclxuICAgIC8vIHBlciBpbWFnZSB3aGVuIHVzaW5nIHNvbWUgb2Ygb3VyIGJsYWNrYm94IGltYWdlcy5cclxuICAgIENvZGUzOVJlYWRlci50b05hcnJvd1dpZGVQYXR0ZXJuID0gZnVuY3Rpb24gKGNvdW50ZXJzKSB7XHJcbiAgICAgICAgdmFyIGVfMywgX2E7XHJcbiAgICAgICAgdmFyIG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBtYXhOYXJyb3dDb3VudGVyID0gMDtcclxuICAgICAgICB2YXIgd2lkZUNvdW50ZXJzO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgdmFyIG1pbkNvdW50ZXIgPSAweDdmZmZmZmZmO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY291bnRlcnNfMSA9IF9fdmFsdWVzKGNvdW50ZXJzKSwgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCk7ICFjb3VudGVyc18xXzEuZG9uZTsgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IGNvdW50ZXJzXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlciA8IG1pbkNvdW50ZXIgJiYgY291bnRlciA+IG1heE5hcnJvd0NvdW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluQ291bnRlciA9IGNvdW50ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNfMV8xICYmICFjb3VudGVyc18xXzEuZG9uZSAmJiAoX2EgPSBjb3VudGVyc18xLnJldHVybikpIF9hLmNhbGwoY291bnRlcnNfMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWF4TmFycm93Q291bnRlciA9IG1pbkNvdW50ZXI7XHJcbiAgICAgICAgICAgIHdpZGVDb3VudGVycyA9IDA7XHJcbiAgICAgICAgICAgIHZhciB0b3RhbFdpZGVDb3VudGVyc1dpZHRoID0gMDtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNvdW50ZXJzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb3VudGVyID0gY291bnRlcnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlciA+IG1heE5hcnJvd0NvdW50ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuIHw9IDEgPDwgKG51bUNvdW50ZXJzIC0gMSAtIGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZGVDb3VudGVycysrO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsV2lkZUNvdW50ZXJzV2lkdGggKz0gY291bnRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod2lkZUNvdW50ZXJzID09PSAzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBGb3VuZCAzIHdpZGUgY291bnRlcnMsIGJ1dCBhcmUgdGhleSBjbG9zZSBlbm91Z2ggaW4gd2lkdGg/XHJcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gcGVyZm9ybSBhIGNoZWFwLCBjb25zZXJ2YXRpdmUgY2hlY2sgdG8gc2VlIGlmIGFueSBpbmRpdmlkdWFsXHJcbiAgICAgICAgICAgICAgICAvLyBjb3VudGVyIGlzIG1vcmUgdGhhbiAxLjUgdGltZXMgdGhlIGF2ZXJhZ2U6XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUNvdW50ZXJzICYmIHdpZGVDb3VudGVycyA+IDA7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudGVyID0gY291bnRlcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPiBtYXhOYXJyb3dDb3VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVDb3VudGVycy0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0b3RhbFdpZGVDb3VudGVyc1dpZHRoID0gMyAqIGF2ZXJhZ2UsIHNvIHRoaXMgY2hlY2tzIGlmIGNvdW50ZXIgPj0gMy8yICogYXZlcmFnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ZXIgKiAyKSA+PSB0b3RhbFdpZGVDb3VudGVyc1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0dGVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKHdpZGVDb3VudGVycyA+IDMpO1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcbiAgICBDb2RlMzlSZWFkZXIucGF0dGVyblRvQ2hhciA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDb2RlMzlSZWFkZXIuQ0hBUkFDVEVSX0VOQ09ESU5HUy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoQ29kZTM5UmVhZGVyLkNIQVJBQ1RFUl9FTkNPRElOR1NbaV0gPT09IHBhdHRlcm4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBDb2RlMzlSZWFkZXIuQUxQSEFCRVRfU1RSSU5HLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGF0dGVybiA9PT0gQ29kZTM5UmVhZGVyLkFTVEVSSVNLX0VOQ09ESU5HKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnKic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICBDb2RlMzlSZWFkZXIuZGVjb2RlRXh0ZW5kZWQgPSBmdW5jdGlvbiAoZW5jb2RlZCkge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBlbmNvZGVkLmxlbmd0aDtcclxuICAgICAgICB2YXIgZGVjb2RlZCA9ICcnO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGMgPSBlbmNvZGVkLmNoYXJBdChpKTtcclxuICAgICAgICAgICAgaWYgKGMgPT09ICcrJyB8fCBjID09PSAnJCcgfHwgYyA9PT0gJyUnIHx8IGMgPT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBlbmNvZGVkLmNoYXJBdChpICsgMSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjb2RlZENoYXIgPSAnXFwwJztcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJysnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyArQSB0byArWiBtYXAgdG8gYSB0byB6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSArIDMyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnJCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICRBIHRvICRaIG1hcCB0byBjb250cm9sIGNvZGVzIFNIIHRvIFNCXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSAtIDY0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICVBIHRvICVFIG1hcCB0byBjb250cm9sIGNvZGVzIEVTQyB0byBVU1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSAnQScgJiYgbmV4dCA8PSAnRScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgLSAzOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA+PSAnRicgJiYgbmV4dCA8PSAnSicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgLSAxMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA+PSAnSycgJiYgbmV4dCA8PSAnTycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgKyAxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA+PSAnUCcgJiYgbmV4dCA8PSAnVCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0LmNoYXJDb2RlQXQoMCkgKyA0Myk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICdcXDAnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdWJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnQCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1cnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQ2hhciA9ICdgJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnWCcgfHwgbmV4dCA9PT0gJ1knIHx8IG5leHQgPT09ICdaJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSAnXFx4N2YnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICcvJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gL0EgdG8gL08gbWFwIHRvICEgdG8gLCBhbmQgL1ogbWFwcyB0byA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49ICdBJyAmJiBuZXh0IDw9ICdPJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5leHQuY2hhckNvZGVBdCgwKSAtIDMyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnWicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRDaGFyID0gJzonO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlY29kZWQgKz0gZGVjb2RlZENoYXI7XHJcbiAgICAgICAgICAgICAgICAvLyBidW1wIHVwIGkgYWdhaW4gc2luY2Ugd2UgcmVhZCB0d28gY2hhcmFjdGVyc1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGVjb2RlZCArPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xyXG4gICAgfTtcclxuICAgIENvZGUzOVJlYWRlci5BTFBIQUJFVF9TVFJJTkcgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLS4gJC8rJSc7XHJcbiAgICAvKipcclxuICAgICAqIFRoZXNlIHJlcHJlc2VudCB0aGUgZW5jb2RpbmdzIG9mIGNoYXJhY3RlcnMsIGFzIHBhdHRlcm5zIG9mIHdpZGUgYW5kIG5hcnJvdyBiYXJzLlxyXG4gICAgICogVGhlIDkgbGVhc3Qtc2lnbmlmaWNhbnQgYml0cyBvZiBlYWNoIGludCBjb3JyZXNwb25kIHRvIHRoZSBwYXR0ZXJuIG9mIHdpZGUgYW5kIG5hcnJvdyxcclxuICAgICAqIHdpdGggMXMgcmVwcmVzZW50aW5nIFwid2lkZVwiIGFuZCAwcyByZXByZXNlbnRpbmcgbmFycm93LlxyXG4gICAgICovXHJcbiAgICBDb2RlMzlSZWFkZXIuQ0hBUkFDVEVSX0VOQ09ESU5HUyA9IFtcclxuICAgICAgICAweDAzNCwgMHgxMjEsIDB4MDYxLCAweDE2MCwgMHgwMzEsIDB4MTMwLCAweDA3MCwgMHgwMjUsIDB4MTI0LCAweDA2NCxcclxuICAgICAgICAweDEwOSwgMHgwNDksIDB4MTQ4LCAweDAxOSwgMHgxMTgsIDB4MDU4LCAweDAwRCwgMHgxMEMsIDB4MDRDLCAweDAxQyxcclxuICAgICAgICAweDEwMywgMHgwNDMsIDB4MTQyLCAweDAxMywgMHgxMTIsIDB4MDUyLCAweDAwNywgMHgxMDYsIDB4MDQ2LCAweDAxNixcclxuICAgICAgICAweDE4MSwgMHgwQzEsIDB4MUMwLCAweDA5MSwgMHgxOTAsIDB4MEQwLCAweDA4NSwgMHgxODQsIDB4MEM0LCAweDBBOCxcclxuICAgICAgICAweDBBMiwgMHgwOEEsIDB4MDJBIC8vIC8tJVxyXG4gICAgXTtcclxuICAgIENvZGUzOVJlYWRlci5BU1RFUklTS19FTkNPRElORyA9IDB4MDk0O1xyXG4gICAgcmV0dXJuIENvZGUzOVJlYWRlcjtcclxufShPbmVEUmVhZGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb2RlMzlSZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvZGUzOVJlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XHJcbnZhciBVUENFQU5SZWFkZXJfMSA9IHJlcXVpcmUoXCIuL1VQQ0VBTlJlYWRlclwiKTtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiA8cD5JbXBsZW1lbnRzIGRlY29kaW5nIG9mIHRoZSBFQU4tMTMgZm9ybWF0LjwvcD5cclxuICpcclxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICogQGF1dGhvciBhbGFzZGFpckBnb29nbGUuY29tIChBbGFzZGFpciBNYWNraW50b3NoKVxyXG4gKi9cclxudmFyIEVBTjEzUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEVBTjEzUmVhZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRUFOMTNSZWFkZXIoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycyA9IFswLCAwLCAwLCAwXTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBFQU4xM1JlYWRlci5wcm90b3R5cGUuZGVjb2RlTWlkZGxlID0gZnVuY3Rpb24gKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XHJcbiAgICAgICAgdmFyIGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycztcclxuICAgICAgICBjb3VudGVyc1swXSA9IDA7XHJcbiAgICAgICAgY291bnRlcnNbMV0gPSAwO1xyXG4gICAgICAgIGNvdW50ZXJzWzJdID0gMDtcclxuICAgICAgICBjb3VudGVyc1szXSA9IDA7XHJcbiAgICAgICAgdmFyIGVuZCA9IHJvdy5nZXRTaXplKCk7XHJcbiAgICAgICAgdmFyIHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XHJcbiAgICAgICAgdmFyIGxnUGF0dGVybkZvdW5kID0gMDtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDYgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcclxuICAgICAgICAgICAgdmFyIGJlc3RNYXRjaCA9IFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBVUENFQU5SZWFkZXJfMS5kZWZhdWx0LkxfQU5EX0dfUEFUVEVSTlMpO1xyXG4gICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyBiZXN0TWF0Y2ggJSAxMCkpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY291bnRlcnNfMSA9IF9fdmFsdWVzKGNvdW50ZXJzKSwgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCk7ICFjb3VudGVyc18xXzEuZG9uZTsgY291bnRlcnNfMV8xID0gY291bnRlcnNfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IGNvdW50ZXJzXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzXzFfMSAmJiAhY291bnRlcnNfMV8xLmRvbmUgJiYgKF9hID0gY291bnRlcnNfMS5yZXR1cm4pKSBfYS5jYWxsKGNvdW50ZXJzXzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChiZXN0TWF0Y2ggPj0gMTApIHtcclxuICAgICAgICAgICAgICAgIGxnUGF0dGVybkZvdW5kIHw9IDEgPDwgKDUgLSB4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHRTdHJpbmcgPSBFQU4xM1JlYWRlci5kZXRlcm1pbmVGaXJzdERpZ2l0KHJlc3VsdFN0cmluZywgbGdQYXR0ZXJuRm91bmQpO1xyXG4gICAgICAgIHZhciBtaWRkbGVSYW5nZSA9IFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuZmluZEd1YXJkUGF0dGVybihyb3csIHJvd09mZnNldCwgdHJ1ZSwgVVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5NSURETEVfUEFUVEVSTiwgbmV3IEFycmF5KFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuTUlERExFX1BBVFRFUk4ubGVuZ3RoKS5maWxsKDApKTtcclxuICAgICAgICByb3dPZmZzZXQgPSBtaWRkbGVSYW5nZVsxXTtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDYgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcclxuICAgICAgICAgICAgdmFyIGJlc3RNYXRjaCA9IFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBVUENFQU5SZWFkZXJfMS5kZWZhdWx0LkxfUEFUVEVSTlMpO1xyXG4gICAgICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoJzAnLmNoYXJDb2RlQXQoMCkgKyBiZXN0TWF0Y2gpKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvdW50ZXJzXzIgPSBfX3ZhbHVlcyhjb3VudGVycyksIGNvdW50ZXJzXzJfMSA9IGNvdW50ZXJzXzIubmV4dCgpOyAhY291bnRlcnNfMl8xLmRvbmU7IGNvdW50ZXJzXzJfMSA9IGNvdW50ZXJzXzIubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSBjb3VudGVyc18yXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc18yXzEgJiYgIWNvdW50ZXJzXzJfMS5kb25lICYmIChfYiA9IGNvdW50ZXJzXzIucmV0dXJuKSkgX2IuY2FsbChjb3VudGVyc18yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyByb3dPZmZzZXQ6IHJvd09mZnNldCwgcmVzdWx0U3RyaW5nOiByZXN1bHRTdHJpbmcgfTtcclxuICAgIH07XHJcbiAgICBFQU4xM1JlYWRlci5wcm90b3R5cGUuZ2V0QmFyY29kZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuRUFOXzEzO1xyXG4gICAgfTtcclxuICAgIEVBTjEzUmVhZGVyLmRldGVybWluZUZpcnN0RGlnaXQgPSBmdW5jdGlvbiAocmVzdWx0U3RyaW5nLCBsZ1BhdHRlcm5Gb3VuZCkge1xyXG4gICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgMTA7IGQrKykge1xyXG4gICAgICAgICAgICBpZiAobGdQYXR0ZXJuRm91bmQgPT09IHRoaXMuRklSU1RfRElHSVRfRU5DT0RJTkdTW2RdKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGQpKSArIHJlc3VsdFN0cmluZztcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRTdHJpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIEVBTjEzUmVhZGVyLkZJUlNUX0RJR0lUX0VOQ09ESU5HUyA9IFsweDAwLCAweDBCLCAweDBELCAweEUsIDB4MTMsIDB4MTksIDB4MUMsIDB4MTUsIDB4MTYsIDB4MUFdO1xyXG4gICAgcmV0dXJuIEVBTjEzUmVhZGVyO1xyXG59KFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRUFOMTNSZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVBTjEzUmVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcclxudmFyIFVQQ0VBTlJlYWRlcl8xID0gcmVxdWlyZShcIi4vVVBDRUFOUmVhZGVyXCIpO1xyXG4vKipcclxuICogPHA+SW1wbGVtZW50cyBkZWNvZGluZyBvZiB0aGUgRUFOLTggZm9ybWF0LjwvcD5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICovXHJcbnZhciBFQU44UmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEVBTjhSZWFkZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFQU44UmVhZGVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRUFOOFJlYWRlci5wcm90b3R5cGUuZGVjb2RlTWlkZGxlID0gZnVuY3Rpb24gKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XHJcbiAgICAgICAgdmFyIGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycztcclxuICAgICAgICBjb3VudGVyc1swXSA9IDA7XHJcbiAgICAgICAgY291bnRlcnNbMV0gPSAwO1xyXG4gICAgICAgIGNvdW50ZXJzWzJdID0gMDtcclxuICAgICAgICBjb3VudGVyc1szXSA9IDA7XHJcbiAgICAgICAgdmFyIGVuZCA9IHJvdy5nZXRTaXplKCk7XHJcbiAgICAgICAgdmFyIHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA0ICYmIHJvd09mZnNldCA8IGVuZDsgeCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBiZXN0TWF0Y2ggPSBVUENFQU5SZWFkZXJfMS5kZWZhdWx0LmRlY29kZURpZ2l0KHJvdywgY291bnRlcnMsIHJvd09mZnNldCwgVVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5MX1BBVFRFUk5TKTtcclxuICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoKSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb3VudGVyc18xID0gX192YWx1ZXMoY291bnRlcnMpLCBjb3VudGVyc18xXzEgPSBjb3VudGVyc18xLm5leHQoKTsgIWNvdW50ZXJzXzFfMS5kb25lOyBjb3VudGVyc18xXzEgPSBjb3VudGVyc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudGVyID0gY291bnRlcnNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNfMV8xICYmICFjb3VudGVyc18xXzEuZG9uZSAmJiAoX2EgPSBjb3VudGVyc18xLnJldHVybikpIF9hLmNhbGwoY291bnRlcnNfMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pZGRsZVJhbmdlID0gVVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5maW5kR3VhcmRQYXR0ZXJuKHJvdywgcm93T2Zmc2V0LCB0cnVlLCBVUENFQU5SZWFkZXJfMS5kZWZhdWx0Lk1JRERMRV9QQVRURVJOLCBuZXcgQXJyYXkoVVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5NSURETEVfUEFUVEVSTi5sZW5ndGgpLmZpbGwoMCkpO1xyXG4gICAgICAgIHJvd09mZnNldCA9IG1pZGRsZVJhbmdlWzFdO1xyXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNCAmJiByb3dPZmZzZXQgPCBlbmQ7IHgrKykge1xyXG4gICAgICAgICAgICB2YXIgYmVzdE1hdGNoID0gVVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5kZWNvZGVEaWdpdChyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuTF9QQVRURVJOUyk7XHJcbiAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCkpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY291bnRlcnNfMiA9IF9fdmFsdWVzKGNvdW50ZXJzKSwgY291bnRlcnNfMl8xID0gY291bnRlcnNfMi5uZXh0KCk7ICFjb3VudGVyc18yXzEuZG9uZTsgY291bnRlcnNfMl8xID0gY291bnRlcnNfMi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnRlciA9IGNvdW50ZXJzXzJfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICByb3dPZmZzZXQgKz0gY291bnRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzXzJfMSAmJiAhY291bnRlcnNfMl8xLmRvbmUgJiYgKF9iID0gY291bnRlcnNfMi5yZXR1cm4pKSBfYi5jYWxsKGNvdW50ZXJzXzIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IHJvd09mZnNldDogcm93T2Zmc2V0LCByZXN1bHRTdHJpbmc6IHJlc3VsdFN0cmluZyB9O1xyXG4gICAgfTtcclxuICAgIEVBTjhSZWFkZXIucHJvdG90eXBlLmdldEJhcmNvZGVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkVBTl84O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFQU44UmVhZGVyO1xyXG59KFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRUFOOFJlYWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RUFOOFJlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLm9uZWQgeyovXHJcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcclxudmFyIERlY29kZUhpbnRUeXBlXzEgPSByZXF1aXJlKFwiLi4vRGVjb2RlSGludFR5cGVcIik7XHJcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRcIik7XHJcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFBvaW50XCIpO1xyXG52YXIgT25lRFJlYWRlcl8xID0gcmVxdWlyZShcIi4vT25lRFJlYWRlclwiKTtcclxudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XHJcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuLi91dGlsL1N5c3RlbVwiKTtcclxudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiA8cD5EZWNvZGVzIElURiBiYXJjb2Rlcy48L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgVGppZWNvXHJcbiAqL1xyXG52YXIgSVRGUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKElURlJlYWRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIElURlJlYWRlcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICAvLyBTdG9yZXMgdGhlIGFjdHVhbCBuYXJyb3cgbGluZSB3aWR0aCBvZiB0aGUgaW1hZ2UgYmVpbmcgZGVjb2RlZC5cclxuICAgICAgICBfdGhpcy5uYXJyb3dMaW5lV2lkdGggPSAtMTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBTZWUgSVRGV3JpdGVyLlBBVFRFUk5TXHJcbiAgICAvKlxyXG5cclxuICAgIC8hKipcclxuICAgICAqIFBhdHRlcm5zIG9mIFdpZGUgLyBOYXJyb3cgbGluZXMgdG8gaW5kaWNhdGUgZWFjaCBkaWdpdFxyXG4gICAgICohL1xyXG4gICAgKi9cclxuICAgIElURlJlYWRlci5wcm90b3R5cGUuZGVjb2RlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93LCBoaW50cykge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIC8vIEZpbmQgb3V0IHdoZXJlIHRoZSBNaWRkbGUgc2VjdGlvbiAocGF5bG9hZCkgc3RhcnRzICYgZW5kc1xyXG4gICAgICAgIHZhciBzdGFydFJhbmdlID0gdGhpcy5kZWNvZGVTdGFydChyb3cpO1xyXG4gICAgICAgIHZhciBlbmRSYW5nZSA9IHRoaXMuZGVjb2RlRW5kKHJvdyk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIElURlJlYWRlci5kZWNvZGVNaWRkbGUocm93LCBzdGFydFJhbmdlWzFdLCBlbmRSYW5nZVswXSwgcmVzdWx0KTtcclxuICAgICAgICB2YXIgcmVzdWx0U3RyaW5nID0gcmVzdWx0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdmFyIGFsbG93ZWRMZW5ndGhzID0gbnVsbDtcclxuICAgICAgICBpZiAoaGludHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBhbGxvd2VkTGVuZ3RocyA9IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuQUxMT1dFRF9MRU5HVEhTKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsbG93ZWRMZW5ndGhzID09IG51bGwpIHtcclxuICAgICAgICAgICAgYWxsb3dlZExlbmd0aHMgPSBJVEZSZWFkZXIuREVGQVVMVF9BTExPV0VEX0xFTkdUSFM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRvIGF2b2lkIGZhbHNlIHBvc2l0aXZlcyB3aXRoIDJEIGJhcmNvZGVzIChhbmQgb3RoZXIgcGF0dGVybnMpLCBtYWtlXHJcbiAgICAgICAgLy8gYW4gYXNzdW1wdGlvbiB0aGF0IHRoZSBkZWNvZGVkIHN0cmluZyBtdXN0IGJlIGEgJ3N0YW5kYXJkJyBsZW5ndGggaWYgaXQncyBzaG9ydFxyXG4gICAgICAgIHZhciBsZW5ndGggPSByZXN1bHRTdHJpbmcubGVuZ3RoO1xyXG4gICAgICAgIHZhciBsZW5ndGhPSyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBtYXhBbGxvd2VkTGVuZ3RoID0gMDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBhbGxvd2VkTGVuZ3Roc18xID0gX192YWx1ZXMoYWxsb3dlZExlbmd0aHMpLCBhbGxvd2VkTGVuZ3Roc18xXzEgPSBhbGxvd2VkTGVuZ3Roc18xLm5leHQoKTsgIWFsbG93ZWRMZW5ndGhzXzFfMS5kb25lOyBhbGxvd2VkTGVuZ3Roc18xXzEgPSBhbGxvd2VkTGVuZ3Roc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYWxsb3dlZExlbmd0aHNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGhPSyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBtYXhBbGxvd2VkTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4QWxsb3dlZExlbmd0aCA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dlZExlbmd0aHNfMV8xICYmICFhbGxvd2VkTGVuZ3Roc18xXzEuZG9uZSAmJiAoX2EgPSBhbGxvd2VkTGVuZ3Roc18xLnJldHVybikpIF9hLmNhbGwoYWxsb3dlZExlbmd0aHNfMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWxlbmd0aE9LICYmIGxlbmd0aCA+IG1heEFsbG93ZWRMZW5ndGgpIHtcclxuICAgICAgICAgICAgbGVuZ3RoT0sgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWxlbmd0aE9LKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwb2ludHMgPSBbbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChzdGFydFJhbmdlWzFdLCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGVuZFJhbmdlWzBdLCByb3dOdW1iZXIpXTtcclxuICAgICAgICB2YXIgcmVzdWx0UmV0dXJuID0gbmV3IFJlc3VsdF8xLmRlZmF1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAvLyBubyBuYXR1cmFsIGJ5dGUgcmVwcmVzZW50YXRpb24gZm9yIHRoZXNlIGJhcmNvZGVzXHJcbiAgICAgICAgMCwgcG9pbnRzLCBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5JVEYsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0UmV0dXJuO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAvISoqXHJcbiAgICAgKiBAcGFyYW0gcm93ICAgICAgICAgIHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXHJcbiAgICAgKiBAcGFyYW0gcGF5bG9hZFN0YXJ0IG9mZnNldCBvZiBzdGFydCBwYXR0ZXJuXHJcbiAgICAgKiBAcGFyYW0gcmVzdWx0U3RyaW5nIHtAbGluayBTdHJpbmdCdWlsZGVyfSB0byBhcHBlbmQgZGVjb2RlZCBjaGFycyB0b1xyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBkZWNvZGluZyBjb3VsZCBub3QgY29tcGxldGUgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgKiEvKi9cclxuICAgIElURlJlYWRlci5kZWNvZGVNaWRkbGUgPSBmdW5jdGlvbiAocm93LCBwYXlsb2FkU3RhcnQsIHBheWxvYWRFbmQsIHJlc3VsdFN0cmluZykge1xyXG4gICAgICAgIC8vIERpZ2l0cyBhcmUgaW50ZXJsZWF2ZWQgaW4gcGFpcnMgLSA1IGJsYWNrIGxpbmVzIGZvciBvbmUgZGlnaXQsIGFuZCB0aGVcclxuICAgICAgICAvLyA1XHJcbiAgICAgICAgLy8gaW50ZXJsZWF2ZWQgd2hpdGUgbGluZXMgZm9yIHRoZSBzZWNvbmQgZGlnaXQuXHJcbiAgICAgICAgLy8gVGhlcmVmb3JlLCBuZWVkIHRvIHNjYW4gMTAgbGluZXMgYW5kIHRoZW5cclxuICAgICAgICAvLyBzcGxpdCB0aGVzZSBpbnRvIHR3byBhcnJheXNcclxuICAgICAgICB2YXIgY291bnRlckRpZ2l0UGFpciA9IG5ldyBBcnJheSgxMCk7IC8vIDEwXHJcbiAgICAgICAgdmFyIGNvdW50ZXJCbGFjayA9IG5ldyBBcnJheSg1KTsgLy8gNVxyXG4gICAgICAgIHZhciBjb3VudGVyV2hpdGUgPSBuZXcgQXJyYXkoNSk7IC8vIDVcclxuICAgICAgICBjb3VudGVyRGlnaXRQYWlyLmZpbGwoMCk7XHJcbiAgICAgICAgY291bnRlckJsYWNrLmZpbGwoMCk7XHJcbiAgICAgICAgY291bnRlcldoaXRlLmZpbGwoMCk7XHJcbiAgICAgICAgd2hpbGUgKHBheWxvYWRTdGFydCA8IHBheWxvYWRFbmQpIHtcclxuICAgICAgICAgICAgLy8gR2V0IDEwIHJ1bnMgb2YgYmxhY2svd2hpdGUuXHJcbiAgICAgICAgICAgIE9uZURSZWFkZXJfMS5kZWZhdWx0LnJlY29yZFBhdHRlcm4ocm93LCBwYXlsb2FkU3RhcnQsIGNvdW50ZXJEaWdpdFBhaXIpO1xyXG4gICAgICAgICAgICAvLyBTcGxpdCB0aGVtIGludG8gZWFjaCBhcnJheVxyXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IDU7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHR3b0sgPSAyICogaztcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJCbGFja1trXSA9IGNvdW50ZXJEaWdpdFBhaXJbdHdvS107XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyV2hpdGVba10gPSBjb3VudGVyRGlnaXRQYWlyW3R3b0sgKyAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYmVzdE1hdGNoID0gSVRGUmVhZGVyLmRlY29kZURpZ2l0KGNvdW50ZXJCbGFjayk7XHJcbiAgICAgICAgICAgIHJlc3VsdFN0cmluZy5hcHBlbmQoYmVzdE1hdGNoLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICBiZXN0TWF0Y2ggPSB0aGlzLmRlY29kZURpZ2l0KGNvdW50ZXJXaGl0ZSk7XHJcbiAgICAgICAgICAgIHJlc3VsdFN0cmluZy5hcHBlbmQoYmVzdE1hdGNoLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICBjb3VudGVyRGlnaXRQYWlyLmZvckVhY2goZnVuY3Rpb24gKGNvdW50ZXJEaWdpdCkge1xyXG4gICAgICAgICAgICAgICAgcGF5bG9hZFN0YXJ0ICs9IGNvdW50ZXJEaWdpdDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qLyEqKlxyXG4gICAgICogSWRlbnRpZnkgd2hlcmUgdGhlIHN0YXJ0IG9mIHRoZSBtaWRkbGUgLyBwYXlsb2FkIHNlY3Rpb24gc3RhcnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByb3cgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcclxuICAgICAqIEByZXR1cm4gQXJyYXksIGNvbnRhaW5pbmcgaW5kZXggb2Ygc3RhcnQgb2YgJ3N0YXJ0IGJsb2NrJyBhbmQgZW5kIG9mXHJcbiAgICAgKiAgICAgICAgICdzdGFydCBibG9jaydcclxuICAgICAqIS8qL1xyXG4gICAgSVRGUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVTdGFydCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICB2YXIgZW5kU3RhcnQgPSBJVEZSZWFkZXIuc2tpcFdoaXRlU3BhY2Uocm93KTtcclxuICAgICAgICB2YXIgc3RhcnRQYXR0ZXJuID0gSVRGUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCBlbmRTdGFydCwgSVRGUmVhZGVyLlNUQVJUX1BBVFRFUk4pO1xyXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgd2lkdGggb2YgYSBuYXJyb3cgbGluZSBpbiBwaXhlbHMuIFdlIGNhbiBkbyB0aGlzIGJ5XHJcbiAgICAgICAgLy8gZ2V0dGluZyB0aGUgd2lkdGggb2YgdGhlIHN0YXJ0IHBhdHRlcm4gYW5kIGRpdmlkaW5nIGJ5IDQgYmVjYXVzZSBpdHNcclxuICAgICAgICAvLyBtYWRlIHVwIG9mIDQgbmFycm93IGxpbmVzLlxyXG4gICAgICAgIHRoaXMubmFycm93TGluZVdpZHRoID0gKHN0YXJ0UGF0dGVyblsxXSAtIHN0YXJ0UGF0dGVyblswXSkgLyA0O1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVRdWlldFpvbmUocm93LCBzdGFydFBhdHRlcm5bMF0pO1xyXG4gICAgICAgIHJldHVybiBzdGFydFBhdHRlcm47XHJcbiAgICB9O1xyXG4gICAgLyovISoqXHJcbiAgICAgKiBUaGUgc3RhcnQgJiBlbmQgcGF0dGVybnMgbXVzdCBiZSBwcmUvcG9zdCBmaXhlZCBieSBhIHF1aWV0IHpvbmUuIFRoaXNcclxuICAgICAqIHpvbmUgbXVzdCBiZSBhdCBsZWFzdCAxMCB0aW1lcyB0aGUgd2lkdGggb2YgYSBuYXJyb3cgbGluZS4gIFNjYW4gYmFjayB1bnRpbFxyXG4gICAgICogd2UgZWl0aGVyIGdldCB0byB0aGUgc3RhcnQgb2YgdGhlIGJhcmNvZGUgb3IgbWF0Y2ggdGhlIG5lY2Vzc2FyeSBudW1iZXIgb2ZcclxuICAgICAqIHF1aWV0IHpvbmUgcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IEl0cyBhc3N1bWVkIHRoZSByb3cgaXMgcmV2ZXJzZWQgd2hlbiB1c2luZyB0aGlzIG1ldGhvZCB0byBmaW5kXHJcbiAgICAgKiBxdWlldCB6b25lIGFmdGVyIHRoZSBlbmQgcGF0dGVybi5cclxuICAgICAqXHJcbiAgICAgKiByZWY6IGh0dHA6Ly93d3cuYmFyY29kZS0xLm5ldC9pMjVjb2RlLmh0bWxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcm93IGJpdCBhcnJheSByZXByZXNlbnRpbmcgdGhlIHNjYW5uZWQgYmFyY29kZS5cclxuICAgICAqIEBwYXJhbSBzdGFydFBhdHRlcm4gaW5kZXggaW50byByb3cgb2YgdGhlIHN0YXJ0IG9yIGVuZCBwYXR0ZXJuLlxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiB0aGUgcXVpZXQgem9uZSBjYW5ub3QgYmUgZm91bmRcclxuICAgICAqIS8qL1xyXG4gICAgSVRGUmVhZGVyLnByb3RvdHlwZS52YWxpZGF0ZVF1aWV0Wm9uZSA9IGZ1bmN0aW9uIChyb3csIHN0YXJ0UGF0dGVybikge1xyXG4gICAgICAgIHZhciBxdWlldENvdW50ID0gdGhpcy5uYXJyb3dMaW5lV2lkdGggKiAxMDsgLy8gZXhwZWN0IHRvIGZpbmQgdGhpcyBtYW55IHBpeGVscyBvZiBxdWlldCB6b25lXHJcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vdCBzbyBtYW55IHBpeGVsIGF0IGFsbCBsZXQncyB0cnkgYXMgbWFueSBhcyBwb3NzaWJsZVxyXG4gICAgICAgIHF1aWV0Q291bnQgPSBxdWlldENvdW50IDwgc3RhcnRQYXR0ZXJuID8gcXVpZXRDb3VudCA6IHN0YXJ0UGF0dGVybjtcclxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnRQYXR0ZXJuIC0gMTsgcXVpZXRDb3VudCA+IDAgJiYgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKHJvdy5nZXQoaSkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHF1aWV0Q291bnQtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHF1aWV0Q291bnQgIT09IDApIHtcclxuICAgICAgICAgICAgLy8gVW5hYmxlIHRvIGZpbmQgdGhlIG5lY2Vzc2FyeSBudW1iZXIgb2YgcXVpZXQgem9uZSBwaXhlbHMuXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIC8hKipcclxuICAgICAqIFNraXAgYWxsIHdoaXRlc3BhY2UgdW50aWwgd2UgZ2V0IHRvIHRoZSBmaXJzdCBibGFjayBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByb3cgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcclxuICAgICAqIEByZXR1cm4gaW5kZXggb2YgdGhlIGZpcnN0IGJsYWNrIGxpbmUuXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIFRocm93cyBleGNlcHRpb24gaWYgbm8gYmxhY2sgbGluZXMgYXJlIGZvdW5kIGluIHRoZSByb3dcclxuICAgICAqIS8qL1xyXG4gICAgSVRGUmVhZGVyLnNraXBXaGl0ZVNwYWNlID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XHJcbiAgICAgICAgdmFyIGVuZFN0YXJ0ID0gcm93LmdldE5leHRTZXQoMCk7XHJcbiAgICAgICAgaWYgKGVuZFN0YXJ0ID09PSB3aWR0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbmRTdGFydDtcclxuICAgIH07XHJcbiAgICAvKi8hKipcclxuICAgICAqIElkZW50aWZ5IHdoZXJlIHRoZSBlbmQgb2YgdGhlIG1pZGRsZSAvIHBheWxvYWQgc2VjdGlvbiBlbmRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByb3cgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlcyB0byBzZWFyY2hcclxuICAgICAqIEByZXR1cm4gQXJyYXksIGNvbnRhaW5pbmcgaW5kZXggb2Ygc3RhcnQgb2YgJ2VuZCBibG9jaycgYW5kIGVuZCBvZiAnZW5kXHJcbiAgICAgKiAgICAgICAgIGJsb2NrJ1xyXG4gICAgICohLyovXHJcbiAgICBJVEZSZWFkZXIucHJvdG90eXBlLmRlY29kZUVuZCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICAvLyBGb3IgY29udmVuaWVuY2UsIHJldmVyc2UgdGhlIHJvdyBhbmQgdGhlblxyXG4gICAgICAgIC8vIHNlYXJjaCBmcm9tICd0aGUgc3RhcnQnIGZvciB0aGUgZW5kIGJsb2NrXHJcbiAgICAgICAgcm93LnJldmVyc2UoKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgZW5kU3RhcnQgPSBJVEZSZWFkZXIuc2tpcFdoaXRlU3BhY2Uocm93KTtcclxuICAgICAgICAgICAgdmFyIGVuZFBhdHRlcm4gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBlbmRQYXR0ZXJuID0gSVRGUmVhZGVyLmZpbmRHdWFyZFBhdHRlcm4ocm93LCBlbmRTdGFydCwgSVRGUmVhZGVyLkVORF9QQVRURVJOX1JFVkVSU0VEWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoTm90Rm91bmRFeGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIGVuZFBhdHRlcm4gPSBJVEZSZWFkZXIuZmluZEd1YXJkUGF0dGVybihyb3csIGVuZFN0YXJ0LCBJVEZSZWFkZXIuRU5EX1BBVFRFUk5fUkVWRVJTRURbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRoZSBzdGFydCAmIGVuZCBwYXR0ZXJucyBtdXN0IGJlIHByZS9wb3N0IGZpeGVkIGJ5IGEgcXVpZXQgem9uZS4gVGhpc1xyXG4gICAgICAgICAgICAvLyB6b25lIG11c3QgYmUgYXQgbGVhc3QgMTAgdGltZXMgdGhlIHdpZHRoIG9mIGEgbmFycm93IGxpbmUuXHJcbiAgICAgICAgICAgIC8vIHJlZjogaHR0cDovL3d3dy5iYXJjb2RlLTEubmV0L2kyNWNvZGUuaHRtbFxyXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUXVpZXRab25lKHJvdywgZW5kUGF0dGVyblswXSk7XHJcbiAgICAgICAgICAgIC8vIE5vdyByZWNhbGN1bGF0ZSB0aGUgaW5kaWNlcyBvZiB3aGVyZSB0aGUgJ2VuZGJsb2NrJyBzdGFydHMgJiBzdG9wcyB0b1xyXG4gICAgICAgICAgICAvLyBhY2NvbW1vZGF0ZVxyXG4gICAgICAgICAgICAvLyB0aGUgcmV2ZXJzZWQgbmF0dXJlIG9mIHRoZSBzZWFyY2hcclxuICAgICAgICAgICAgdmFyIHRlbXAgPSBlbmRQYXR0ZXJuWzBdO1xyXG4gICAgICAgICAgICBlbmRQYXR0ZXJuWzBdID0gcm93LmdldFNpemUoKSAtIGVuZFBhdHRlcm5bMV07XHJcbiAgICAgICAgICAgIGVuZFBhdHRlcm5bMV0gPSByb3cuZ2V0U2l6ZSgpIC0gdGVtcDtcclxuICAgICAgICAgICAgcmV0dXJuIGVuZFBhdHRlcm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAvLyBQdXQgdGhlIHJvdyBiYWNrIHRoZSByaWdodCB3YXkuXHJcbiAgICAgICAgICAgIHJvdy5yZXZlcnNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICAvISoqXHJcbiAgICAgKiBAcGFyYW0gcm93ICAgICAgIHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXHJcbiAgICAgKiBAcGFyYW0gcm93T2Zmc2V0IHBvc2l0aW9uIHRvIHN0YXJ0IHNlYXJjaFxyXG4gICAgICogQHBhcmFtIHBhdHRlcm4gICBwYXR0ZXJuIG9mIGNvdW50cyBvZiBudW1iZXIgb2YgYmxhY2sgYW5kIHdoaXRlIHBpeGVscyB0aGF0IGFyZVxyXG4gICAgICogICAgICAgICAgICAgICAgICBiZWluZyBzZWFyY2hlZCBmb3IgYXMgYSBwYXR0ZXJuXHJcbiAgICAgKiBAcmV0dXJuIHN0YXJ0L2VuZCBob3Jpem9udGFsIG9mZnNldCBvZiBndWFyZCBwYXR0ZXJuLCBhcyBhbiBhcnJheSBvZiB0d29cclxuICAgICAqICAgICAgICAgaW50c1xyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBwYXR0ZXJuIGlzIG5vdCBmb3VuZFxyXG4gICAgICohLyovXHJcbiAgICBJVEZSZWFkZXIuZmluZEd1YXJkUGF0dGVybiA9IGZ1bmN0aW9uIChyb3csIHJvd09mZnNldCwgcGF0dGVybikge1xyXG4gICAgICAgIHZhciBwYXR0ZXJuTGVuZ3RoID0gcGF0dGVybi5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGNvdW50ZXJzID0gbmV3IEFycmF5KHBhdHRlcm5MZW5ndGgpO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XHJcbiAgICAgICAgdmFyIGlzV2hpdGUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgY291bnRlclBvc2l0aW9uID0gMDtcclxuICAgICAgICB2YXIgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xyXG4gICAgICAgIGNvdW50ZXJzLmZpbGwoMCk7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IHJvd09mZnNldDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgaWYgKHJvdy5nZXQoeCkgIT09IGlzV2hpdGUpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9uZURSZWFkZXJfMS5kZWZhdWx0LnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBJVEZSZWFkZXIuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UpIDwgSVRGUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuU3RhcnQsIHhdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShjb3VudGVycywgMiwgY291bnRlcnMsIDAsIGNvdW50ZXJQb3NpdGlvbiAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbiAtIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb25dID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIC8qLyEqKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gZGVjb2RlIGEgc2VxdWVuY2Ugb2YgSVRGIGJsYWNrL3doaXRlIGxpbmVzIGludG8gc2luZ2xlXHJcbiAgICAgKiBkaWdpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY291bnRlcnMgdGhlIGNvdW50cyBvZiBydW5zIG9mIG9ic2VydmVkIGJsYWNrL3doaXRlL2JsYWNrLy4uLiB2YWx1ZXNcclxuICAgICAqIEByZXR1cm4gVGhlIGRlY29kZWQgZGlnaXRcclxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgZGlnaXQgY2Fubm90IGJlIGRlY29kZWRcclxuICAgICAqIS8qL1xyXG4gICAgSVRGUmVhZGVyLmRlY29kZURpZ2l0ID0gZnVuY3Rpb24gKGNvdW50ZXJzKSB7XHJcbiAgICAgICAgdmFyIGJlc3RWYXJpYW5jZSA9IElURlJlYWRlci5NQVhfQVZHX1ZBUklBTkNFOyAvLyB3b3JzdCB2YXJpYW5jZSB3ZSdsbCBhY2NlcHRcclxuICAgICAgICB2YXIgYmVzdE1hdGNoID0gLTE7XHJcbiAgICAgICAgdmFyIG1heCA9IElURlJlYWRlci5QQVRURVJOUy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGF0dGVybiA9IElURlJlYWRlci5QQVRURVJOU1tpXTtcclxuICAgICAgICAgICAgdmFyIHZhcmlhbmNlID0gT25lRFJlYWRlcl8xLmRlZmF1bHQucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIElURlJlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSk7XHJcbiAgICAgICAgICAgIGlmICh2YXJpYW5jZSA8IGJlc3RWYXJpYW5jZSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdFZhcmlhbmNlID0gdmFyaWFuY2U7XHJcbiAgICAgICAgICAgICAgICBiZXN0TWF0Y2ggPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhcmlhbmNlID09PSBiZXN0VmFyaWFuY2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGZpbmQgYSBzZWNvbmQgJ2Jlc3QgbWF0Y2gnIHdpdGggdGhlIHNhbWUgdmFyaWFuY2UsIHdlIGNhbiBub3QgcmVsaWFibHkgcmVwb3J0IHRvIGhhdmUgYSBzdWl0YWJsZSBtYXRjaFxyXG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiZXN0TWF0Y2ggJSAxMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSVRGUmVhZGVyLlcgPSAzOyAvLyBQaXhlbCB3aWR0aCBvZiBhIDN4IHdpZGUgbGluZVxyXG4gICAgSVRGUmVhZGVyLncgPSAyOyAvLyBQaXhlbCB3aWR0aCBvZiBhIDJ4IHdpZGUgbGluZVxyXG4gICAgSVRGUmVhZGVyLk4gPSAxOyAvLyBQaXhlZCB3aWR0aCBvZiBhIG5hcnJvdyBsaW5lXHJcbiAgICBJVEZSZWFkZXIuUEFUVEVSTlMgPSBbXHJcbiAgICAgICAgWzEsIDEsIDIsIDIsIDFdLFxyXG4gICAgICAgIFsyLCAxLCAxLCAxLCAyXSxcclxuICAgICAgICBbMSwgMiwgMSwgMSwgMl0sXHJcbiAgICAgICAgWzIsIDIsIDEsIDEsIDFdLFxyXG4gICAgICAgIFsxLCAxLCAyLCAxLCAyXSxcclxuICAgICAgICBbMiwgMSwgMiwgMSwgMV0sXHJcbiAgICAgICAgWzEsIDIsIDIsIDEsIDFdLFxyXG4gICAgICAgIFsxLCAxLCAxLCAyLCAyXSxcclxuICAgICAgICBbMiwgMSwgMSwgMiwgMV0sXHJcbiAgICAgICAgWzEsIDIsIDEsIDIsIDFdLFxyXG4gICAgICAgIFsxLCAxLCAzLCAzLCAxXSxcclxuICAgICAgICBbMywgMSwgMSwgMSwgM10sXHJcbiAgICAgICAgWzEsIDMsIDEsIDEsIDNdLFxyXG4gICAgICAgIFszLCAzLCAxLCAxLCAxXSxcclxuICAgICAgICBbMSwgMSwgMywgMSwgM10sXHJcbiAgICAgICAgWzMsIDEsIDMsIDEsIDFdLFxyXG4gICAgICAgIFsxLCAzLCAzLCAxLCAxXSxcclxuICAgICAgICBbMSwgMSwgMSwgMywgM10sXHJcbiAgICAgICAgWzMsIDEsIDEsIDMsIDFdLFxyXG4gICAgICAgIFsxLCAzLCAxLCAzLCAxXSAvLyA5XHJcbiAgICBdO1xyXG4gICAgSVRGUmVhZGVyLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjM4O1xyXG4gICAgSVRGUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFID0gMC41O1xyXG4gICAgLyogLyEqKiBWYWxpZCBJVEYgbGVuZ3Rocy4gQW55dGhpbmcgbG9uZ2VyIHRoYW4gdGhlIGxhcmdlc3QgdmFsdWUgaXMgYWxzbyBhbGxvd2VkLiAqIS8qL1xyXG4gICAgSVRGUmVhZGVyLkRFRkFVTFRfQUxMT1dFRF9MRU5HVEhTID0gWzYsIDgsIDEwLCAxMiwgMTRdO1xyXG4gICAgLyovISoqXHJcbiAgICAgKiBTdGFydC9lbmQgZ3VhcmQgcGF0dGVybi5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBUaGUgZW5kIHBhdHRlcm4gaXMgcmV2ZXJzZWQgYmVjYXVzZSB0aGUgcm93IGlzIHJldmVyc2VkIGJlZm9yZVxyXG4gICAgICogc2VhcmNoaW5nIGZvciB0aGUgRU5EX1BBVFRFUk5cclxuICAgICAqIS8qL1xyXG4gICAgSVRGUmVhZGVyLlNUQVJUX1BBVFRFUk4gPSBbMSwgMSwgMSwgMV07XHJcbiAgICBJVEZSZWFkZXIuRU5EX1BBVFRFUk5fUkVWRVJTRUQgPSBbXHJcbiAgICAgICAgWzEsIDEsIDJdLFxyXG4gICAgICAgIFsxLCAxLCAzXSAvLyAzeFxyXG4gICAgXTtcclxuICAgIHJldHVybiBJVEZSZWFkZXI7XHJcbn0oT25lRFJlYWRlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSVRGUmVhZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JVEZSZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5vbmVkIHsqL1xyXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XHJcbnZhciBDb2RlMzlSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0NvZGUzOVJlYWRlclwiKTtcclxudmFyIENvZGUxMjhSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0NvZGUxMjhSZWFkZXJcIik7XHJcbnZhciBSU1MxNFJlYWRlcl8xID0gcmVxdWlyZShcIi4vcnNzL1JTUzE0UmVhZGVyXCIpO1xyXG52YXIgRGVjb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuLi9EZWNvZGVIaW50VHlwZVwiKTtcclxudmFyIElURlJlYWRlcl8xID0gcmVxdWlyZShcIi4vSVRGUmVhZGVyXCIpO1xyXG52YXIgTXVsdGlGb3JtYXRVUENFQU5SZWFkZXJfMSA9IHJlcXVpcmUoXCIuL011bHRpRm9ybWF0VVBDRUFOUmVhZGVyXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxudmFyIE9uZURSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL09uZURSZWFkZXJcIik7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIERhbmllbCBTd2l0a2luIDxkc3dpdGtpbkBnb29nbGUuY29tPlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIE11bHRpRm9ybWF0T25lRFJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNdWx0aUZvcm1hdE9uZURSZWFkZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNdWx0aUZvcm1hdE9uZURSZWFkZXIoaGludHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnJlYWRlcnMgPSBbXTtcclxuICAgICAgICB2YXIgcG9zc2libGVGb3JtYXRzID0gIWhpbnRzID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuUE9TU0lCTEVfRk9STUFUUyk7XHJcbiAgICAgICAgdmFyIHVzZUNvZGUzOUNoZWNrRGlnaXQgPSBoaW50cyAmJiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0LkFTU1VNRV9DT0RFXzM5X0NIRUNLX0RJR0lUKSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMpIHtcclxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5FQU5fMTMpIHx8XHJcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuRUFOXzgpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyXzEuZGVmYXVsdChoaW50cykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdC5FQU5fMTMpIHx8XHJcbiAgICAgICAgICAgIC8vICAgICBwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdC5VUENfQSkgfHxcclxuICAgICAgICAgICAgLy8gICAgIHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0LkVBTl84KSB8fFxyXG4gICAgICAgICAgICAvLyAgICAgcG9zc2libGVGb3JtYXRzLmluY2x1ZGVzKEJhcmNvZGVGb3JtYXQuVVBDX0UpKSB7XHJcbiAgICAgICAgICAgIC8vICAgcmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlcihoaW50cykpO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuQ09ERV8zOSkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTM5UmVhZGVyXzEuZGVmYXVsdCh1c2VDb2RlMzlDaGVja0RpZ2l0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0LkNPREVfOTMpKSB7XHJcbiAgICAgICAgICAgIC8vICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RlOTNSZWFkZXIoKSk7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5DT0RFXzEyOCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTEyOFJlYWRlcl8xLmRlZmF1bHQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5JVEYpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IElURlJlYWRlcl8xLmRlZmF1bHQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0LkNPREFCQVIpKSB7XHJcbiAgICAgICAgICAgIC8vICAgIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RhQmFyUmVhZGVyKCkpO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZUZvcm1hdHMuaW5jbHVkZXMoQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuUlNTXzE0KSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMucmVhZGVycy5wdXNoKG5ldyBSU1MxNFJlYWRlcl8xLmRlZmF1bHQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmNsdWRlcyhCYXJjb2RlRm9ybWF0LlJTU19FWFBBTkRFRCkpIHtcclxuICAgICAgICAgICAgLy8gICB0aGlzLnJlYWRlcnMucHVzaChuZXcgUlNTRXhwYW5kZWRSZWFkZXIoKSk7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLnJlYWRlcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMucmVhZGVycy5wdXNoKG5ldyBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlcihoaW50cykpO1xyXG4gICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUzOVJlYWRlcl8xLmRlZmF1bHQoKSk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMucmVhZGVycy5wdXNoKG5ldyBDb2RhQmFyUmVhZGVyKCkpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLnJlYWRlcnMucHVzaChuZXcgQ29kZTkzUmVhZGVyKCkpO1xyXG4gICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyXzEuZGVmYXVsdChoaW50cykpO1xyXG4gICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IENvZGUxMjhSZWFkZXJfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgICAgICBfdGhpcy5yZWFkZXJzLnB1c2gobmV3IElURlJlYWRlcl8xLmRlZmF1bHQoKSk7XHJcbiAgICAgICAgICAgIF90aGlzLnJlYWRlcnMucHVzaChuZXcgUlNTMTRSZWFkZXJfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLnJlYWRlcnMucHVzaChuZXcgUlNTRXhwYW5kZWRSZWFkZXIoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIEBPdmVycmlkZVxyXG4gICAgTXVsdGlGb3JtYXRPbmVEUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlYWRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRlcnNbaV0uZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKHJlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjb250aW51ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICAvLyBAT3ZlcnJpZGVcclxuICAgIE11bHRpRm9ybWF0T25lRFJlYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHJlYWRlcikgeyByZXR1cm4gcmVhZGVyLnJlc2V0KCk7IH0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNdWx0aUZvcm1hdE9uZURSZWFkZXI7XHJcbn0oT25lRFJlYWRlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTXVsdGlGb3JtYXRPbmVEUmVhZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NdWx0aUZvcm1hdE9uZURSZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEJhcmNvZGVGb3JtYXRfMSA9IHJlcXVpcmUoXCIuLi9CYXJjb2RlRm9ybWF0XCIpO1xyXG52YXIgRGVjb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuLi9EZWNvZGVIaW50VHlwZVwiKTtcclxudmFyIE9uZURSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL09uZURSZWFkZXJcIik7XHJcbnZhciBFQU4xM1JlYWRlcl8xID0gcmVxdWlyZShcIi4vRUFOMTNSZWFkZXJcIik7XHJcbnZhciBFQU44UmVhZGVyXzEgPSByZXF1aXJlKFwiLi9FQU44UmVhZGVyXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIDxwPkEgcmVhZGVyIHRoYXQgY2FuIHJlYWQgYWxsIGF2YWlsYWJsZSBVUEMvRUFOIGZvcm1hdHMuIElmIGEgY2FsbGVyIHdhbnRzIHRvIHRyeSB0b1xyXG4gKiByZWFkIGFsbCBzdWNoIGZvcm1hdHMsIGl0IGlzIG1vc3QgZWZmaWNpZW50IHRvIHVzZSB0aGlzIGltcGxlbWVudGF0aW9uIHJhdGhlciB0aGFuIGludm9rZVxyXG4gKiBpbmRpdmlkdWFsIHJlYWRlcnMuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTXVsdGlGb3JtYXRVUENFQU5SZWFkZXIoaGludHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIHZhciBwb3NzaWJsZUZvcm1hdHMgPSBoaW50cyA9PSBudWxsID8gbnVsbCA6IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuUE9TU0lCTEVfRk9STUFUUyk7XHJcbiAgICAgICAgdmFyIHJlYWRlcnMgPSBbXTtcclxuICAgICAgICBpZiAocG9zc2libGVGb3JtYXRzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmRleE9mKEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkVBTl8xMykgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBFQU4xM1JlYWRlcl8xLmRlZmF1bHQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvc3NpYmxlRm9ybWF0cy5pbmRleE9mKEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LkVBTl84KSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZWFkZXJzLnB1c2gobmV3IEVBTjhSZWFkZXJfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRvZG8gYWRkIFVQQ19BLCBVUENfRVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVhZGVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmVhZGVycy5wdXNoKG5ldyBFQU4xM1JlYWRlcl8xLmRlZmF1bHQoKSk7XHJcbiAgICAgICAgICAgIHJlYWRlcnMucHVzaChuZXcgRUFOOFJlYWRlcl8xLmRlZmF1bHQoKSk7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gYWRkIFVQQ19BLCBVUENfRVxyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5yZWFkZXJzID0gcmVhZGVycztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNdWx0aUZvcm1hdFVQQ0VBTlJlYWRlci5wcm90b3R5cGUuZGVjb2RlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93LCBoaW50cykge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5yZWFkZXJzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlYWRlciA9IF9jLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgaGludHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZWFuMTNNYXlCZVVQQ0FcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIE11bHRpRm9ybWF0VVBDRUFOUmVhZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZV8yLCBfYTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMucmVhZGVycyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZWFkZXIgPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJlYWRlci5yZXNldCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTXVsdGlGb3JtYXRVUENFQU5SZWFkZXI7XHJcbn0oT25lRFJlYWRlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTXVsdGlGb3JtYXRVUENFQU5SZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU11bHRpRm9ybWF0VVBDRUFOUmVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEJpdEFycmF5XzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0JpdEFycmF5XCIpO1xyXG52YXIgRGVjb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuLi9EZWNvZGVIaW50VHlwZVwiKTtcclxudmFyIFJlc3VsdE1ldGFkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdE1ldGFkYXRhVHlwZVwiKTtcclxudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0UG9pbnRcIik7XHJcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogRW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIGFsbCBmYW1pbGllc1xyXG4gKiBvZiBvbmUtZGltZW5zaW9uYWwgYmFyY29kZXMuXHJcbiAqXHJcbiAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqL1xyXG52YXIgT25lRFJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE9uZURSZWFkZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvKlxyXG4gICAgQE92ZXJyaWRlXHJcbiAgICBwdWJsaWMgUmVzdWx0IGRlY29kZShCaW5hcnlCaXRtYXAgaW1hZ2UpIHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uIHtcclxuICAgICAgcmV0dXJuIGRlY29kZShpbWFnZSwgbnVsbCk7XHJcbiAgICB9XHJcbiAgICAqL1xyXG4gICAgLy8gTm90ZSB0aGF0IHdlIGRvbid0IHRyeSByb3RhdGlvbiB3aXRob3V0IHRoZSB0cnkgaGFyZGVyIGZsYWcsIGV2ZW4gaWYgcm90YXRpb24gd2FzIHN1cHBvcnRlZC5cclxuICAgIC8vIEBPdmVycmlkZVxyXG4gICAgT25lRFJlYWRlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGltYWdlLCBoaW50cykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvRGVjb2RlKGltYWdlLCBoaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChuZmUpIHtcclxuICAgICAgICAgICAgdmFyIHRyeUhhcmRlciA9IGhpbnRzICYmIChoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0LlRSWV9IQVJERVIpID09PSB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKHRyeUhhcmRlciAmJiBpbWFnZS5pc1JvdGF0ZVN1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm90YXRlZEltYWdlID0gaW1hZ2Uucm90YXRlQ291bnRlckNsb2Nrd2lzZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZG9EZWNvZGUocm90YXRlZEltYWdlLCBoaW50cyk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWNvcmQgdGhhdCB3ZSBmb3VuZCBpdCByb3RhdGVkIDkwIGRlZ3JlZXMgQ0NXIC8gMjcwIGRlZ3JlZXMgQ1dcclxuICAgICAgICAgICAgICAgIHZhciBtZXRhZGF0YSA9IHJlc3VsdC5nZXRSZXN1bHRNZXRhZGF0YSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWVudGF0aW9uXzEgPSAyNzA7XHJcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgIT09IG51bGwgJiYgKG1ldGFkYXRhLmdldChSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0Lk9SSUVOVEFUSU9OKSA9PT0gdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBCdXQgaWYgd2UgZm91bmQgaXQgcmV2ZXJzZWQgaW4gZG9EZWNvZGUoKSwgYWRkIGluIHRoYXQgcmVzdWx0IGhlcmU6XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb25fMSA9IChvcmllbnRhdGlvbl8xICsgbWV0YWRhdGEuZ2V0KFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuT1JJRU5UQVRJT04pICUgMzYwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0Lk9SSUVOVEFUSU9OLCBvcmllbnRhdGlvbl8xKTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSByZXN1bHQgcG9pbnRzXHJcbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRzID0gcmVzdWx0LmdldFJlc3VsdFBvaW50cygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBvaW50cyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSByb3RhdGVkSW1hZ2UuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzW2ldID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChoZWlnaHQgLSBwb2ludHNbaV0uZ2V0WSgpIC0gMSwgcG9pbnRzW2ldLmdldFgoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBAT3ZlcnJpZGVcclxuICAgIE9uZURSZWFkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGRvIG5vdGhpbmdcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdlJ3JlIGdvaW5nIHRvIGV4YW1pbmUgcm93cyBmcm9tIHRoZSBtaWRkbGUgb3V0d2FyZCwgc2VhcmNoaW5nIGFsdGVybmF0ZWx5IGFib3ZlIGFuZCBiZWxvdyB0aGVcclxuICAgICAqIG1pZGRsZSwgYW5kIGZhcnRoZXIgb3V0IGVhY2ggdGltZS4gcm93U3RlcCBpcyB0aGUgbnVtYmVyIG9mIHJvd3MgYmV0d2VlbiBlYWNoIHN1Y2Nlc3NpdmVcclxuICAgICAqIGF0dGVtcHQgYWJvdmUgYW5kIGJlbG93IHRoZSBtaWRkbGUuIFNvIHdlJ2Qgc2NhbiByb3cgbWlkZGxlLCB0aGVuIG1pZGRsZSAtIHJvd1N0ZXAsIHRoZW5cclxuICAgICAqIG1pZGRsZSArIHJvd1N0ZXAsIHRoZW4gbWlkZGxlIC0gKDIgKiByb3dTdGVwKSwgZXRjLlxyXG4gICAgICogcm93U3RlcCBpcyBiaWdnZXIgYXMgdGhlIGltYWdlIGlzIHRhbGxlciwgYnV0IGlzIGFsd2F5cyBhdCBsZWFzdCAxLiBXZSd2ZSBzb21ld2hhdCBhcmJpdHJhcmlseVxyXG4gICAgICogZGVjaWRlZCB0aGF0IG1vdmluZyB1cCBhbmQgZG93biBieSBhYm91dCAxLzE2IG9mIHRoZSBpbWFnZSBpcyBwcmV0dHkgZ29vZDsgd2UgdHJ5IG1vcmUgb2YgdGhlXHJcbiAgICAgKiBpbWFnZSBpZiBcInRyeWluZyBoYXJkZXJcIi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW1hZ2UgVGhlIGltYWdlIHRvIGRlY29kZVxyXG4gICAgICogQHBhcmFtIGhpbnRzIEFueSBoaW50cyB0aGF0IHdlcmUgcmVxdWVzdGVkXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBjb250ZW50cyBvZiB0aGUgZGVjb2RlZCBiYXJjb2RlXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIEFueSBzcG9udGFuZW91cyBlcnJvcnMgd2hpY2ggb2NjdXJcclxuICAgICAqL1xyXG4gICAgT25lRFJlYWRlci5wcm90b3R5cGUuZG9EZWNvZGUgPSBmdW5jdGlvbiAoaW1hZ2UsIGhpbnRzKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2UuZ2V0V2lkdGgoKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgdmFyIHJvdyA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQod2lkdGgpO1xyXG4gICAgICAgIHZhciB0cnlIYXJkZXIgPSBoaW50cyAmJiAoaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5UUllfSEFSREVSKSA9PT0gdHJ1ZSk7XHJcbiAgICAgICAgdmFyIHJvd1N0ZXAgPSBNYXRoLm1heCgxLCBoZWlnaHQgPj4gKHRyeUhhcmRlciA/IDggOiA1KSk7XHJcbiAgICAgICAgdmFyIG1heExpbmVzO1xyXG4gICAgICAgIGlmICh0cnlIYXJkZXIpIHtcclxuICAgICAgICAgICAgbWF4TGluZXMgPSBoZWlnaHQ7IC8vIExvb2sgYXQgdGhlIHdob2xlIGltYWdlLCBub3QganVzdCB0aGUgY2VudGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtYXhMaW5lcyA9IDE1OyAvLyAxNSByb3dzIHNwYWNlZCAxLzMyIGFwYXJ0IGlzIHJvdWdobHkgdGhlIG1pZGRsZSBoYWxmIG9mIHRoZSBpbWFnZVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWlkZGxlID0gTWF0aC50cnVuYyhoZWlnaHQgLyAyKTtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG1heExpbmVzOyB4KyspIHtcclxuICAgICAgICAgICAgLy8gU2Nhbm5pbmcgZnJvbSB0aGUgbWlkZGxlIG91dC4gRGV0ZXJtaW5lIHdoaWNoIHJvdyB3ZSdyZSBsb29raW5nIGF0IG5leHQ6XHJcbiAgICAgICAgICAgIHZhciByb3dTdGVwc0Fib3ZlT3JCZWxvdyA9IE1hdGgudHJ1bmMoKHggKyAxKSAvIDIpO1xyXG4gICAgICAgICAgICB2YXIgaXNBYm92ZSA9ICh4ICYgMHgwMSkgPT09IDA7IC8vIGkuZS4gaXMgeCBldmVuP1xyXG4gICAgICAgICAgICB2YXIgcm93TnVtYmVyID0gbWlkZGxlICsgcm93U3RlcCAqIChpc0Fib3ZlID8gcm93U3RlcHNBYm92ZU9yQmVsb3cgOiAtcm93U3RlcHNBYm92ZU9yQmVsb3cpO1xyXG4gICAgICAgICAgICBpZiAocm93TnVtYmVyIDwgMCB8fCByb3dOdW1iZXIgPj0gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBPb3BzLCBpZiB3ZSBydW4gb2ZmIHRoZSB0b3Agb3IgYm90dG9tLCBzdG9wXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBFc3RpbWF0ZSBibGFjayBwb2ludCBmb3IgdGhpcyByb3cgYW5kIGxvYWQgaXQ6XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByb3cgPSBpbWFnZS5nZXRCbGFja1Jvdyhyb3dOdW1iZXIsIHJvdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGF0dGVtcHQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID09PSAxKSB7IC8vIHRyeWluZyBhZ2Fpbj9cclxuICAgICAgICAgICAgICAgICAgICByb3cucmV2ZXJzZSgpOyAvLyByZXZlcnNlIHRoZSByb3cgYW5kIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSB3aWxsIG9ubHkgZXZlciBkcmF3IHJlc3VsdCBwb2ludHMgKm9uY2UqIGluIHRoZSBsaWZlIG9mIHRoaXMgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luY2Ugd2Ugd2FudCB0byBhdm9pZCBkcmF3aW5nIHRoZSB3cm9uZyBwb2ludHMgYWZ0ZXIgZmxpcHBpbmcgdGhlIHJvdywgYW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IHdhbnQgdG8gY2x1dHRlciB3aXRoIG5vaXNlIGZyb20gZXZlcnkgc2luZ2xlIHJvdyBzY2FuIC0tIGp1c3QgdGhlIHNjYW5zXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBzdGFydCBvbiB0aGUgY2VudGVyIGxpbmUuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhpbnRzICYmIChoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0Lk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLKSA9PT0gdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0hpbnRzXzEgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpbnRzLmZvckVhY2goZnVuY3Rpb24gKGhpbnQsIGtleSkgeyByZXR1cm4gbmV3SGludHNfMS5zZXQoa2V5LCBoaW50KTsgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0hpbnRzXzEuZGVsZXRlKERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpbnRzID0gbmV3SGludHNfMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGEgYmFyY29kZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzXzEuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBoaW50cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZm91bmQgb3VyIGJhcmNvZGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgaXQgd2FzIHVwc2lkZSBkb3duLCBzbyBub3RlIHRoYXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuT1JJRU5UQVRJT04sIDE4MCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFuZCByZW1lbWJlciB0byBmbGlwIHRoZSByZXN1bHQgcG9pbnRzIGhvcml6b250YWxseS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHJlc3VsdC5nZXRSZXN1bHRQb2ludHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50cyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdCh3aWR0aCAtIHBvaW50c1swXS5nZXRYKCkgLSAxLCBwb2ludHNbMF0uZ2V0WSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50c1sxXSA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQod2lkdGggLSBwb2ludHNbMV0uZ2V0WCgpIC0gMSwgcG9pbnRzWzFdLmdldFkoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdCB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKHJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udGludWUgLS0ganVzdCBjb3VsZG4ndCBkZWNvZGUgdGhpcyByb3dcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XHJcbiAgICAgICAgICAgIC8vIFdoaWxlIHdlIGhhdmUgdGhlIGltYWdlIGRhdGEgaW4gYSBCaXRBcnJheSwgaXQncyBmYWlybHkgY2hlYXAgdG8gcmV2ZXJzZSBpdCBpbiBwbGFjZSB0b1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgZGVjb2RpbmcgdXBzaWRlIGRvd24gYmFyY29kZXMuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgMjsgYXR0ZW1wdCsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhdGVfMSA9IF9sb29wXzEoYXR0ZW1wdCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlXzEgPT09IFwib2JqZWN0XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlXzEudmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVjb3JkcyB0aGUgc2l6ZSBvZiBzdWNjZXNzaXZlIHJ1bnMgb2Ygd2hpdGUgYW5kIGJsYWNrIHBpeGVscyBpbiBhIHJvdywgc3RhcnRpbmcgYXQgYSBnaXZlbiBwb2ludC5cclxuICAgICAqIFRoZSB2YWx1ZXMgYXJlIHJlY29yZGVkIGluIHRoZSBnaXZlbiBhcnJheSwgYW5kIHRoZSBudW1iZXIgb2YgcnVucyByZWNvcmRlZCBpcyBlcXVhbCB0byB0aGUgc2l6ZVxyXG4gICAgICogb2YgdGhlIGFycmF5LiBJZiB0aGUgcm93IHN0YXJ0cyBvbiBhIHdoaXRlIHBpeGVsIGF0IHRoZSBnaXZlbiBzdGFydCBwb2ludCwgdGhlbiB0aGUgZmlyc3QgY291bnRcclxuICAgICAqIHJlY29yZGVkIGlzIHRoZSBydW4gb2Ygd2hpdGUgcGl4ZWxzIHN0YXJ0aW5nIGZyb20gdGhhdCBwb2ludDsgbGlrZXdpc2UgaXQgaXMgdGhlIGNvdW50IG9mIGEgcnVuXHJcbiAgICAgKiBvZiBibGFjayBwaXhlbHMgaWYgdGhlIHJvdyBiZWdpbiBvbiBhIGJsYWNrIHBpeGVscyBhdCB0aGF0IHBvaW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByb3cgcm93IHRvIGNvdW50IGZyb21cclxuICAgICAqIEBwYXJhbSBzdGFydCBvZmZzZXQgaW50byByb3cgdG8gc3RhcnQgYXRcclxuICAgICAqIEBwYXJhbSBjb3VudGVycyBhcnJheSBpbnRvIHdoaWNoIHRvIHJlY29yZCBjb3VudHNcclxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgY291bnRlcnMgY2Fubm90IGJlIGZpbGxlZCBlbnRpcmVseSBmcm9tIHJvdyBiZWZvcmUgcnVubmluZyBvdXRcclxuICAgICAqICBvZiBwaXhlbHNcclxuICAgICAqL1xyXG4gICAgT25lRFJlYWRlci5yZWNvcmRQYXR0ZXJuID0gZnVuY3Rpb24gKHJvdywgc3RhcnQsIGNvdW50ZXJzKSB7XHJcbiAgICAgICAgdmFyIG51bUNvdW50ZXJzID0gY291bnRlcnMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBudW1Db3VudGVyczsgaW5kZXgrKylcclxuICAgICAgICAgICAgY291bnRlcnNbaW5kZXhdID0gMDtcclxuICAgICAgICB2YXIgZW5kID0gcm93LmdldFNpemUoKTtcclxuICAgICAgICBpZiAoc3RhcnQgPj0gZW5kKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzV2hpdGUgPSAhcm93LmdldChzdGFydCk7XHJcbiAgICAgICAgdmFyIGNvdW50ZXJQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgdmFyIGkgPSBzdGFydDtcclxuICAgICAgICB3aGlsZSAoaSA8IGVuZCkge1xyXG4gICAgICAgICAgICBpZiAocm93LmdldChpKSAhPT0gaXNXaGl0ZSkge1xyXG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCsrY291bnRlclBvc2l0aW9uID09PSBudW1Db3VudGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgd2UgcmVhZCBmdWxseSB0aGUgbGFzdCBzZWN0aW9uIG9mIHBpeGVscyBhbmQgZmlsbGVkIHVwIG91ciBjb3VudGVycyAtLSBvciBmaWxsZWRcclxuICAgICAgICAvLyB0aGUgbGFzdCBjb3VudGVyIGJ1dCByYW4gb2ZmIHRoZSBzaWRlIG9mIHRoZSBpbWFnZSwgT0suIE90aGVyd2lzZSwgYSBwcm9ibGVtLlxyXG4gICAgICAgIGlmICghKGNvdW50ZXJQb3NpdGlvbiA9PT0gbnVtQ291bnRlcnMgfHwgKGNvdW50ZXJQb3NpdGlvbiA9PT0gbnVtQ291bnRlcnMgLSAxICYmIGkgPT09IGVuZCkpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT25lRFJlYWRlci5yZWNvcmRQYXR0ZXJuSW5SZXZlcnNlID0gZnVuY3Rpb24gKHJvdywgc3RhcnQsIGNvdW50ZXJzKSB7XHJcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBtb3JlIGVmZmljaWVudCBJIGd1ZXNzXHJcbiAgICAgICAgdmFyIG51bVRyYW5zaXRpb25zTGVmdCA9IGNvdW50ZXJzLmxlbmd0aDtcclxuICAgICAgICB2YXIgbGFzdCA9IHJvdy5nZXQoc3RhcnQpO1xyXG4gICAgICAgIHdoaWxlIChzdGFydCA+IDAgJiYgbnVtVHJhbnNpdGlvbnNMZWZ0ID49IDApIHtcclxuICAgICAgICAgICAgaWYgKHJvdy5nZXQoLS1zdGFydCkgIT09IGxhc3QpIHtcclxuICAgICAgICAgICAgICAgIG51bVRyYW5zaXRpb25zTGVmdC0tO1xyXG4gICAgICAgICAgICAgICAgbGFzdCA9ICFsYXN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChudW1UcmFuc2l0aW9uc0xlZnQgPj0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9uZURSZWFkZXIucmVjb3JkUGF0dGVybihyb3csIHN0YXJ0ICsgMSwgY291bnRlcnMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBob3cgY2xvc2VseSBhIHNldCBvZiBvYnNlcnZlZCBjb3VudHMgb2YgcnVucyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgbWF0Y2hlcyBhIGdpdmVuXHJcbiAgICAgKiB0YXJnZXQgcGF0dGVybi4gVGhpcyBpcyByZXBvcnRlZCBhcyB0aGUgcmF0aW8gb2YgdGhlIHRvdGFsIHZhcmlhbmNlIGZyb20gdGhlIGV4cGVjdGVkIHBhdHRlcm5cclxuICAgICAqIHByb3BvcnRpb25zIGFjcm9zcyBhbGwgcGF0dGVybiBlbGVtZW50cywgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcGF0dGVybi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY291bnRlcnMgb2JzZXJ2ZWQgY291bnRlcnNcclxuICAgICAqIEBwYXJhbSBwYXR0ZXJuIGV4cGVjdGVkIHBhdHRlcm5cclxuICAgICAqIEBwYXJhbSBtYXhJbmRpdmlkdWFsVmFyaWFuY2UgVGhlIG1vc3QgYW55IGNvdW50ZXIgY2FuIGRpZmZlciBiZWZvcmUgd2UgZ2l2ZSB1cFxyXG4gICAgICogQHJldHVybiByYXRpbyBvZiB0b3RhbCB2YXJpYW5jZSBiZXR3ZWVuIGNvdW50ZXJzIGFuZCBwYXR0ZXJuIGNvbXBhcmVkIHRvIHRvdGFsIHBhdHRlcm4gc2l6ZVxyXG4gICAgICovXHJcbiAgICBPbmVEUmVhZGVyLnBhdHRlcm5NYXRjaFZhcmlhbmNlID0gZnVuY3Rpb24gKGNvdW50ZXJzLCBwYXR0ZXJuLCBtYXhJbmRpdmlkdWFsVmFyaWFuY2UpIHtcclxuICAgICAgICB2YXIgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcclxuICAgICAgICB2YXIgcGF0dGVybkxlbmd0aCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRvdGFsICs9IGNvdW50ZXJzW2ldO1xyXG4gICAgICAgICAgICBwYXR0ZXJuTGVuZ3RoICs9IHBhdHRlcm5baV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b3RhbCA8IHBhdHRlcm5MZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIG9uZSBwaXhlbCBwZXIgdW5pdCBvZiBiYXIgd2lkdGgsIGFzc3VtZSB0aGlzIGlzIHRvbyBzbWFsbFxyXG4gICAgICAgICAgICAvLyB0byByZWxpYWJseSBtYXRjaCwgc28gZmFpbDpcclxuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVuaXRCYXJXaWR0aCA9IHRvdGFsIC8gcGF0dGVybkxlbmd0aDtcclxuICAgICAgICBtYXhJbmRpdmlkdWFsVmFyaWFuY2UgKj0gdW5pdEJhcldpZHRoO1xyXG4gICAgICAgIHZhciB0b3RhbFZhcmlhbmNlID0gMC4wO1xyXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbnVtQ291bnRlcnM7IHgrKykge1xyXG4gICAgICAgICAgICB2YXIgY291bnRlciA9IGNvdW50ZXJzW3hdO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVkUGF0dGVybiA9IHBhdHRlcm5beF0gKiB1bml0QmFyV2lkdGg7XHJcbiAgICAgICAgICAgIHZhciB2YXJpYW5jZSA9IGNvdW50ZXIgPiBzY2FsZWRQYXR0ZXJuID8gY291bnRlciAtIHNjYWxlZFBhdHRlcm4gOiBzY2FsZWRQYXR0ZXJuIC0gY291bnRlcjtcclxuICAgICAgICAgICAgaWYgKHZhcmlhbmNlID4gbWF4SW5kaXZpZHVhbFZhcmlhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRvdGFsVmFyaWFuY2UgKz0gdmFyaWFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b3RhbFZhcmlhbmNlIC8gdG90YWw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9uZURSZWFkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE9uZURSZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9uZURSZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAoQykgMjAxMiBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEJhcmNvZGVGb3JtYXRfMSA9IHJlcXVpcmUoXCIuLi9CYXJjb2RlRm9ybWF0XCIpO1xyXG52YXIgQWJzdHJhY3RVUENFQU5SZWFkZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0VVBDRUFOUmVhZGVyXCIpO1xyXG52YXIgUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0XCIpO1xyXG52YXIgUmVzdWx0UG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRQb2ludFwiKTtcclxudmFyIFJlc3VsdE1ldGFkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdE1ldGFkYXRhVHlwZVwiKTtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBAc2VlIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0XHJcbiAqL1xyXG52YXIgVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVUENFQU5FeHRlbnNpb24yU3VwcG9ydCgpIHtcclxuICAgICAgICB0aGlzLmRlY29kZU1pZGRsZUNvdW50ZXJzID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgIHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyID0gJyc7XHJcbiAgICB9XHJcbiAgICBVUENFQU5FeHRlbnNpb24yU3VwcG9ydC5wcm90b3R5cGUuZGVjb2RlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93LCBleHRlbnNpb25TdGFydFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyO1xyXG4gICAgICAgIHZhciBlbmQgPSB0aGlzLmRlY29kZU1pZGRsZShyb3csIGV4dGVuc2lvblN0YXJ0UmFuZ2UsIHJlc3VsdCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdFN0cmluZyA9IHJlc3VsdC50b1N0cmluZygpO1xyXG4gICAgICAgIHZhciBleHRlbnNpb25EYXRhID0gVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnQucGFyc2VFeHRlbnNpb25TdHJpbmcocmVzdWx0U3RyaW5nKTtcclxuICAgICAgICB2YXIgcmVzdWx0UG9pbnRzID0gW1xyXG4gICAgICAgICAgICBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KChleHRlbnNpb25TdGFydFJhbmdlWzBdICsgZXh0ZW5zaW9uU3RhcnRSYW5nZVsxXSkgLyAyLjAsIHJvd051bWJlciksXHJcbiAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoZW5kLCByb3dOdW1iZXIpXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgZXh0ZW5zaW9uUmVzdWx0ID0gbmV3IFJlc3VsdF8xLmRlZmF1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAwLCByZXN1bHRQb2ludHMsIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlVQQ19FQU5fRVhURU5TSU9OLCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XHJcbiAgICAgICAgaWYgKGV4dGVuc2lvbkRhdGEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBleHRlbnNpb25SZXN1bHQucHV0QWxsTWV0YWRhdGEoZXh0ZW5zaW9uRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleHRlbnNpb25SZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnQucHJvdG90eXBlLmRlY29kZU1pZGRsZSA9IGZ1bmN0aW9uIChyb3csIHN0YXJ0UmFuZ2UsIHJlc3VsdFN0cmluZykge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnM7XHJcbiAgICAgICAgY291bnRlcnNbMF0gPSAwO1xyXG4gICAgICAgIGNvdW50ZXJzWzFdID0gMDtcclxuICAgICAgICBjb3VudGVyc1syXSA9IDA7XHJcbiAgICAgICAgY291bnRlcnNbM10gPSAwO1xyXG4gICAgICAgIHZhciBlbmQgPSByb3cuZ2V0U2l6ZSgpO1xyXG4gICAgICAgIHZhciByb3dPZmZzZXQgPSBzdGFydFJhbmdlWzFdO1xyXG4gICAgICAgIHZhciBjaGVja1Bhcml0eSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCAyICYmIHJvd09mZnNldCA8IGVuZDsgeCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBiZXN0TWF0Y2ggPSBBYnN0cmFjdFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuZGVjb2RlRGlnaXQocm93LCBjb3VudGVycywgcm93T2Zmc2V0LCBBYnN0cmFjdFVQQ0VBTlJlYWRlcl8xLmRlZmF1bHQuTF9BTkRfR19QQVRURVJOUyk7XHJcbiAgICAgICAgICAgIHJlc3VsdFN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgnMCcuY2hhckNvZGVBdCgwKSArIGJlc3RNYXRjaCAlIDEwKSk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb3VudGVyc18xID0gX192YWx1ZXMoY291bnRlcnMpLCBjb3VudGVyc18xXzEgPSBjb3VudGVyc18xLm5leHQoKTsgIWNvdW50ZXJzXzFfMS5kb25lOyBjb3VudGVyc18xXzEgPSBjb3VudGVyc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudGVyID0gY291bnRlcnNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd09mZnNldCArPSBjb3VudGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnRlcnNfMV8xICYmICFjb3VudGVyc18xXzEuZG9uZSAmJiAoX2EgPSBjb3VudGVyc18xLnJldHVybikpIF9hLmNhbGwoY291bnRlcnNfMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJlc3RNYXRjaCA+PSAxMCkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tQYXJpdHkgfD0gMSA8PCAoMSAtIHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh4ICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWFkIG9mZiBzZXBhcmF0b3IgaWYgbm90IGxhc3RcclxuICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IHJvdy5nZXROZXh0U2V0KHJvd09mZnNldCk7XHJcbiAgICAgICAgICAgICAgICByb3dPZmZzZXQgPSByb3cuZ2V0TmV4dFVuc2V0KHJvd09mZnNldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdFN0cmluZy5sZW5ndGggIT09IDIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFyc2VJbnQocmVzdWx0U3RyaW5nLnRvU3RyaW5nKCkpICUgNCAhPT0gY2hlY2tQYXJpdHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm93T2Zmc2V0O1xyXG4gICAgfTtcclxuICAgIFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0LnBhcnNlRXh0ZW5zaW9uU3RyaW5nID0gZnVuY3Rpb24gKHJhdykge1xyXG4gICAgICAgIGlmIChyYXcubGVuZ3RoICE9PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IE1hcChbW1Jlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuSVNTVUVfTlVNQkVSLCBwYXJzZUludChyYXcpXV0pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBVUENFQU5FeHRlbnNpb24yU3VwcG9ydDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTAgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcclxuLy8gaW1wb3J0IFVQQ0VBTlJlYWRlciBmcm9tICcuL1VQQ0VBTlJlYWRlcic7XHJcbnZhciBBYnN0cmFjdFVQQ0VBTlJlYWRlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RVUENFQU5SZWFkZXJcIik7XHJcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRcIik7XHJcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFBvaW50XCIpO1xyXG52YXIgUmVzdWx0TWV0YWRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0TWV0YWRhdGFUeXBlXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIEBzZWUgVVBDRUFORXh0ZW5zaW9uMlN1cHBvcnRcclxuICovXHJcbnZhciBVUENFQU5FeHRlbnNpb241U3VwcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0KCkge1xyXG4gICAgICAgIHRoaXMuQ0hFQ0tfRElHSVRfRU5DT0RJTkdTID0gWzB4MTgsIDB4MTQsIDB4MTIsIDB4MTEsIDB4MEMsIDB4MDYsIDB4MDMsIDB4MEEsIDB4MDksIDB4MDVdO1xyXG4gICAgICAgIHRoaXMuZGVjb2RlTWlkZGxlQ291bnRlcnMgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXIgPSAnJztcclxuICAgIH1cclxuICAgIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0LnByb3RvdHlwZS5kZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3csIGV4dGVuc2lvblN0YXJ0UmFuZ2UpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5kZWNvZGVSb3dTdHJpbmdCdWZmZXI7XHJcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMuZGVjb2RlTWlkZGxlKHJvdywgZXh0ZW5zaW9uU3RhcnRSYW5nZSwgcmVzdWx0KTtcclxuICAgICAgICB2YXIgcmVzdWx0U3RyaW5nID0gcmVzdWx0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdmFyIGV4dGVuc2lvbkRhdGEgPSBVUENFQU5FeHRlbnNpb241U3VwcG9ydC5wYXJzZUV4dGVuc2lvblN0cmluZyhyZXN1bHRTdHJpbmcpO1xyXG4gICAgICAgIHZhciByZXN1bHRQb2ludHMgPSBbXHJcbiAgICAgICAgICAgIG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoKGV4dGVuc2lvblN0YXJ0UmFuZ2VbMF0gKyBleHRlbnNpb25TdGFydFJhbmdlWzFdKSAvIDIuMCwgcm93TnVtYmVyKSxcclxuICAgICAgICAgICAgbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChlbmQsIHJvd051bWJlcilcclxuICAgICAgICBdO1xyXG4gICAgICAgIHZhciBleHRlbnNpb25SZXN1bHQgPSBuZXcgUmVzdWx0XzEuZGVmYXVsdChyZXN1bHRTdHJpbmcsIG51bGwsIDAsIHJlc3VsdFBvaW50cywgQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuVVBDX0VBTl9FWFRFTlNJT04sIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcclxuICAgICAgICBpZiAoZXh0ZW5zaW9uRGF0YSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGV4dGVuc2lvblJlc3VsdC5wdXRBbGxNZXRhZGF0YShleHRlbnNpb25EYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvblJlc3VsdDtcclxuICAgIH07XHJcbiAgICBVUENFQU5FeHRlbnNpb241U3VwcG9ydC5wcm90b3R5cGUuZGVjb2RlTWlkZGxlID0gZnVuY3Rpb24gKHJvdywgc3RhcnRSYW5nZSwgcmVzdWx0U3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgdmFyIGNvdW50ZXJzID0gdGhpcy5kZWNvZGVNaWRkbGVDb3VudGVycztcclxuICAgICAgICBjb3VudGVyc1swXSA9IDA7XHJcbiAgICAgICAgY291bnRlcnNbMV0gPSAwO1xyXG4gICAgICAgIGNvdW50ZXJzWzJdID0gMDtcclxuICAgICAgICBjb3VudGVyc1szXSA9IDA7XHJcbiAgICAgICAgdmFyIGVuZCA9IHJvdy5nZXRTaXplKCk7XHJcbiAgICAgICAgdmFyIHJvd09mZnNldCA9IHN0YXJ0UmFuZ2VbMV07XHJcbiAgICAgICAgdmFyIGxnUGF0dGVybkZvdW5kID0gMDtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IDUgJiYgcm93T2Zmc2V0IDwgZW5kOyB4KyspIHtcclxuICAgICAgICAgICAgdmFyIGJlc3RNYXRjaCA9IEFic3RyYWN0VVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5kZWNvZGVEaWdpdChyb3csIGNvdW50ZXJzLCByb3dPZmZzZXQsIEFic3RyYWN0VVBDRUFOUmVhZGVyXzEuZGVmYXVsdC5MX0FORF9HX1BBVFRFUk5TKTtcclxuICAgICAgICAgICAgcmVzdWx0U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKCcwJy5jaGFyQ29kZUF0KDApICsgYmVzdE1hdGNoICUgMTApKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvdW50ZXJzXzEgPSBfX3ZhbHVlcyhjb3VudGVycyksIGNvdW50ZXJzXzFfMSA9IGNvdW50ZXJzXzEubmV4dCgpOyAhY291bnRlcnNfMV8xLmRvbmU7IGNvdW50ZXJzXzFfMSA9IGNvdW50ZXJzXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSBjb3VudGVyc18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93T2Zmc2V0ICs9IGNvdW50ZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyc18xXzEgJiYgIWNvdW50ZXJzXzFfMS5kb25lICYmIChfYSA9IGNvdW50ZXJzXzEucmV0dXJuKSkgX2EuY2FsbChjb3VudGVyc18xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYmVzdE1hdGNoID49IDEwKSB7XHJcbiAgICAgICAgICAgICAgICBsZ1BhdHRlcm5Gb3VuZCB8PSAxIDw8ICg0IC0geCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHggIT09IDQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlYWQgb2ZmIHNlcGFyYXRvciBpZiBub3QgbGFzdFxyXG4gICAgICAgICAgICAgICAgcm93T2Zmc2V0ID0gcm93LmdldE5leHRTZXQocm93T2Zmc2V0KTtcclxuICAgICAgICAgICAgICAgIHJvd09mZnNldCA9IHJvdy5nZXROZXh0VW5zZXQocm93T2Zmc2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0U3RyaW5nLmxlbmd0aCAhPT0gNSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGVja0RpZ2l0ID0gdGhpcy5kZXRlcm1pbmVDaGVja0RpZ2l0KGxnUGF0dGVybkZvdW5kKTtcclxuICAgICAgICBpZiAoVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQuZXh0ZW5zaW9uQ2hlY2tzdW0ocmVzdWx0U3RyaW5nLnRvU3RyaW5nKCkpICE9PSBjaGVja0RpZ2l0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJvd09mZnNldDtcclxuICAgIH07XHJcbiAgICBVUENFQU5FeHRlbnNpb241U3VwcG9ydC5leHRlbnNpb25DaGVja3N1bSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBsZW5ndGggLSAyOyBpID49IDA7IGkgLT0gMikge1xyXG4gICAgICAgICAgICBzdW0gKz0gcy5jaGFyQXQoaSkuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdW0gKj0gMztcclxuICAgICAgICBmb3IgKHZhciBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDIpIHtcclxuICAgICAgICAgICAgc3VtICs9IHMuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VtICo9IDM7XHJcbiAgICAgICAgcmV0dXJuIHN1bSAlIDEwO1xyXG4gICAgfTtcclxuICAgIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0LnByb3RvdHlwZS5kZXRlcm1pbmVDaGVja0RpZ2l0ID0gZnVuY3Rpb24gKGxnUGF0dGVybkZvdW5kKSB7XHJcbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCAxMDsgZCsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsZ1BhdHRlcm5Gb3VuZCA9PT0gdGhpcy5DSEVDS19ESUdJVF9FTkNPRElOR1NbZF0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICBVUENFQU5FeHRlbnNpb241U3VwcG9ydC5wYXJzZUV4dGVuc2lvblN0cmluZyA9IGZ1bmN0aW9uIChyYXcpIHtcclxuICAgICAgICBpZiAocmF3Lmxlbmd0aCAhPT0gNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbHVlID0gVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQucGFyc2VFeHRlbnNpb241U3RyaW5nKHJhdyk7XHJcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTWFwKFtbUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5TVUdHRVNURURfUFJJQ0UsIHZhbHVlXV0pO1xyXG4gICAgfTtcclxuICAgIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0LnBhcnNlRXh0ZW5zaW9uNVN0cmluZyA9IGZ1bmN0aW9uIChyYXcpIHtcclxuICAgICAgICB2YXIgY3VycmVuY3k7XHJcbiAgICAgICAgc3dpdGNoIChyYXcuY2hhckF0KDApKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJzAnOlxyXG4gICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnwqMnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJzUnOlxyXG4gICAgICAgICAgICAgICAgY3VycmVuY3kgPSAnJCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnOSc6XHJcbiAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2U6IGh0dHA6Ly93d3cuam9sbHl0ZWNoLmNvbVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChyYXcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICc5MDAwMCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIHN1Z2dlc3RlZCByZXRhaWwgcHJpY2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnOTk5OTEnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wbGVtZW50YXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnMC4wMCc7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnOTk5OTAnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ1VzZWQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLi4uIHVua25vd24gY3VycmVuY3k/XHJcbiAgICAgICAgICAgICAgICBjdXJyZW5jeSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBjdXJyZW5jeSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByYXdBbW91bnQgPSBwYXJzZUludChyYXcuc3Vic3RyaW5nKDEpKTtcclxuICAgICAgICB2YXIgdW5pdHNTdHJpbmcgPSAocmF3QW1vdW50IC8gMTAwKS50b1N0cmluZygpO1xyXG4gICAgICAgIHZhciBodW5kcmVkdGhzID0gcmF3QW1vdW50ICUgMTAwO1xyXG4gICAgICAgIHZhciBodW5kcmVkdGhzU3RyaW5nID0gaHVuZHJlZHRocyA8IDEwID8gJzAnICsgaHVuZHJlZHRocyA6IGh1bmRyZWR0aHMudG9TdHJpbmcoKTsgLy8gZml4bWVcclxuICAgICAgICByZXR1cm4gY3VycmVuY3kgKyB1bml0c1N0cmluZyArICcuJyArIGh1bmRyZWR0aHNTdHJpbmc7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBVUENFQU5FeHRlbnNpb241U3VwcG9ydDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VVBDRUFORXh0ZW5zaW9uNVN1cHBvcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAoQykgMjAxMCBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEFic3RyYWN0VVBDRUFOUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdFVQQ0VBTlJlYWRlclwiKTtcclxudmFyIFVQQ0VBTkV4dGVuc2lvbjVTdXBwb3J0XzEgPSByZXF1aXJlKFwiLi9VUENFQU5FeHRlbnNpb241U3VwcG9ydFwiKTtcclxudmFyIFVQQ0VBTkV4dGVuc2lvbjJTdXBwb3J0XzEgPSByZXF1aXJlKFwiLi9VUENFQU5FeHRlbnNpb24yU3VwcG9ydFwiKTtcclxudmFyIFVQQ0VBTkV4dGVuc2lvblN1cHBvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBVUENFQU5FeHRlbnNpb25TdXBwb3J0KCkge1xyXG4gICAgfVxyXG4gICAgVVBDRUFORXh0ZW5zaW9uU3VwcG9ydC5kZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3csIHJvd09mZnNldCkge1xyXG4gICAgICAgIHZhciBleHRlbnNpb25TdGFydFJhbmdlID0gQWJzdHJhY3RVUENFQU5SZWFkZXJfMS5kZWZhdWx0LmZpbmRHdWFyZFBhdHRlcm4ocm93LCByb3dPZmZzZXQsIGZhbHNlLCB0aGlzLkVYVEVOU0lPTl9TVEFSVF9QQVRURVJOLCBuZXcgQXJyYXkodGhpcy5FWFRFTlNJT05fU1RBUlRfUEFUVEVSTi5sZW5ndGgpLmZpbGwoMCkpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB2YXIgZml2ZVN1cHBvcnQgPSBuZXcgVVBDRUFORXh0ZW5zaW9uNVN1cHBvcnRfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmaXZlU3VwcG9ydC5kZWNvZGVSb3cocm93TnVtYmVyLCByb3csIGV4dGVuc2lvblN0YXJ0UmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB2YXIgdHdvU3VwcG9ydCA9IG5ldyBVUENFQU5FeHRlbnNpb24yU3VwcG9ydF8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHR3b1N1cHBvcnQuZGVjb2RlUm93KHJvd051bWJlciwgcm93LCBleHRlbnNpb25TdGFydFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVVBDRUFORXh0ZW5zaW9uU3VwcG9ydC5FWFRFTlNJT05fU1RBUlRfUEFUVEVSTiA9IFsxLCAxLCAyXTtcclxuICAgIHJldHVybiBVUENFQU5FeHRlbnNpb25TdXBwb3J0O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBVUENFQU5FeHRlbnNpb25TdXBwb3J0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1VUENFQU5FeHRlbnNpb25TdXBwb3J0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vQmFyY29kZUZvcm1hdFwiKTtcclxudmFyIERlY29kZUhpbnRUeXBlXzEgPSByZXF1aXJlKFwiLi4vRGVjb2RlSGludFR5cGVcIik7XHJcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRcIik7XHJcbnZhciBSZXN1bHRNZXRhZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuLi9SZXN1bHRNZXRhZGF0YVR5cGVcIik7XHJcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFBvaW50XCIpO1xyXG52YXIgVVBDRUFORXh0ZW5zaW9uU3VwcG9ydF8xID0gcmVxdWlyZShcIi4vVVBDRUFORXh0ZW5zaW9uU3VwcG9ydFwiKTtcclxudmFyIEFic3RyYWN0VVBDRUFOUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdFVQQ0VBTlJlYWRlclwiKTtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbnZhciBGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9Gb3JtYXRFeGNlcHRpb25cIik7XHJcbnZhciBDaGVja3N1bUV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0NoZWNrc3VtRXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogPHA+RW5jYXBzdWxhdGVzIGZ1bmN0aW9uYWxpdHkgYW5kIGltcGxlbWVudGF0aW9uIHRoYXQgaXMgY29tbW9uIHRvIFVQQyBhbmQgRUFOIGZhbWlsaWVzXHJcbiAqIG9mIG9uZS1kaW1lbnNpb25hbCBiYXJjb2Rlcy48L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgZHN3aXRraW5AZ29vZ2xlLmNvbSAoRGFuaWVsIFN3aXRraW4pXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqIEBhdXRob3IgYWxhc2RhaXJAZ29vZ2xlLmNvbSAoQWxhc2RhaXIgTWFja2ludG9zaClcclxuICovXHJcbnZhciBVUENFQU5SZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoVVBDRUFOUmVhZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVVBDRUFOUmVhZGVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyID0gJyc7XHJcbiAgICAgICAgVVBDRUFOUmVhZGVyLkxfQU5EX0dfUEFUVEVSTlMgPSBVUENFQU5SZWFkZXIuTF9QQVRURVJOUy5tYXAoZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgICAgICByZXR1cm4gYXJyLnNsaWNlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDEwOyBpIDwgMjA7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgd2lkdGhzID0gVVBDRUFOUmVhZGVyLkxfUEFUVEVSTlNbaSAtIDEwXTtcclxuICAgICAgICAgICAgdmFyIHJldmVyc2VkV2lkdGhzID0gbmV3IEFycmF5KHdpZHRocy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHdpZHRocy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgcmV2ZXJzZWRXaWR0aHNbal0gPSB3aWR0aHNbd2lkdGhzLmxlbmd0aCAtIGogLSAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBVUENFQU5SZWFkZXIuTF9BTkRfR19QQVRURVJOU1tpXSA9IHJldmVyc2VkV2lkdGhzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBVUENFQU5SZWFkZXIucHJvdG90eXBlLmRlY29kZVJvdyA9IGZ1bmN0aW9uIChyb3dOdW1iZXIsIHJvdywgaGludHMpIHtcclxuICAgICAgICB2YXIgc3RhcnRHdWFyZFJhbmdlID0gVVBDRUFOUmVhZGVyLmZpbmRTdGFydEd1YXJkUGF0dGVybihyb3cpO1xyXG4gICAgICAgIHZhciByZXN1bHRQb2ludENhbGxiYWNrID0gaGludHMgPT0gbnVsbCA/IG51bGwgOiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0Lk5FRURfUkVTVUxUX1BPSU5UX0NBTExCQUNLKTtcclxuICAgICAgICBpZiAocmVzdWx0UG9pbnRDYWxsYmFjayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHRQb2ludF8xID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdCgoc3RhcnRHdWFyZFJhbmdlWzBdICsgc3RhcnRHdWFyZFJhbmdlWzFdKSAvIDIuMCwgcm93TnVtYmVyKTtcclxuICAgICAgICAgICAgcmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocmVzdWx0UG9pbnRfMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWRlbGxvID0gdGhpcy5kZWNvZGVNaWRkbGUocm93LCBzdGFydEd1YXJkUmFuZ2UsIHRoaXMuZGVjb2RlUm93U3RyaW5nQnVmZmVyKTtcclxuICAgICAgICB2YXIgZW5kU3RhcnQgPSBidWRlbGxvLnJvd09mZnNldDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gYnVkZWxsby5yZXN1bHRTdHJpbmc7XHJcbiAgICAgICAgaWYgKHJlc3VsdFBvaW50Q2FsbGJhY2sgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0UG9pbnRfMiA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoZW5kU3RhcnQsIHJvd051bWJlcik7XHJcbiAgICAgICAgICAgIHJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KHJlc3VsdFBvaW50XzIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZW5kUmFuZ2UgPSBVUENFQU5SZWFkZXIuZGVjb2RlRW5kKHJvdywgZW5kU3RhcnQpO1xyXG4gICAgICAgIGlmIChyZXN1bHRQb2ludENhbGxiYWNrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdFBvaW50XzMgPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KChlbmRSYW5nZVswXSArIGVuZFJhbmdlWzFdKSAvIDIuMCwgcm93TnVtYmVyKTtcclxuICAgICAgICAgICAgcmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocmVzdWx0UG9pbnRfMyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBhIHF1aWV0IHpvbmUgYXQgbGVhc3QgYXMgYmlnIGFzIHRoZSBlbmQgcGF0dGVybiBhZnRlciB0aGUgYmFyY29kZS4gVGhlXHJcbiAgICAgICAgLy8gc3BlYyBtaWdodCB3YW50IG1vcmUgd2hpdGVzcGFjZSwgYnV0IGluIHByYWN0aWNlIHRoaXMgaXMgdGhlIG1heGltdW0gd2UgY2FuIGNvdW50IG9uLlxyXG4gICAgICAgIHZhciBlbmQgPSBlbmRSYW5nZVsxXTtcclxuICAgICAgICB2YXIgcXVpZXRFbmQgPSBlbmQgKyAoZW5kIC0gZW5kUmFuZ2VbMF0pO1xyXG4gICAgICAgIGlmIChxdWlldEVuZCA+PSByb3cuZ2V0U2l6ZSgpIHx8ICFyb3cuaXNSYW5nZShlbmQsIHF1aWV0RW5kLCBmYWxzZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0U3RyaW5nID0gcmVzdWx0LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgLy8gVVBDL0VBTiBzaG91bGQgbmV2ZXIgYmUgbGVzcyB0aGFuIDggY2hhcnMgYW55d2F5XHJcbiAgICAgICAgaWYgKHJlc3VsdFN0cmluZy5sZW5ndGggPCA4KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghVVBDRUFOUmVhZGVyLmNoZWNrQ2hlY2tzdW0ocmVzdWx0U3RyaW5nKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsZWZ0ID0gKHN0YXJ0R3VhcmRSYW5nZVsxXSArIHN0YXJ0R3VhcmRSYW5nZVswXSkgLyAyLjA7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gKGVuZFJhbmdlWzFdICsgZW5kUmFuZ2VbMF0pIC8gMi4wO1xyXG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLmdldEJhcmNvZGVGb3JtYXQoKTtcclxuICAgICAgICB2YXIgcmVzdWx0UG9pbnQgPSBbbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChsZWZ0LCByb3dOdW1iZXIpLCBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHJpZ2h0LCByb3dOdW1iZXIpXTtcclxuICAgICAgICB2YXIgZGVjb2RlUmVzdWx0ID0gbmV3IFJlc3VsdF8xLmRlZmF1bHQocmVzdWx0U3RyaW5nLCBudWxsLCAwLCByZXN1bHRQb2ludCwgZm9ybWF0LCBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XHJcbiAgICAgICAgdmFyIGV4dGVuc2lvbkxlbmd0aCA9IDA7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGV4dGVuc2lvblJlc3VsdCA9IFVQQ0VBTkV4dGVuc2lvblN1cHBvcnRfMS5kZWZhdWx0LmRlY29kZVJvdyhyb3dOdW1iZXIsIHJvdywgZW5kUmFuZ2VbMV0pO1xyXG4gICAgICAgICAgICBkZWNvZGVSZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5VUENfRUFOX0VYVEVOU0lPTiwgZXh0ZW5zaW9uUmVzdWx0LmdldFRleHQoKSk7XHJcbiAgICAgICAgICAgIGRlY29kZVJlc3VsdC5wdXRBbGxNZXRhZGF0YShleHRlbnNpb25SZXN1bHQuZ2V0UmVzdWx0TWV0YWRhdGEoKSk7XHJcbiAgICAgICAgICAgIGRlY29kZVJlc3VsdC5hZGRSZXN1bHRQb2ludHMoZXh0ZW5zaW9uUmVzdWx0LmdldFJlc3VsdFBvaW50cygpKTtcclxuICAgICAgICAgICAgZXh0ZW5zaW9uTGVuZ3RoID0gZXh0ZW5zaW9uUmVzdWx0LmdldFRleHQoKS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFsbG93ZWRFeHRlbnNpb25zID0gaGludHMgPT0gbnVsbCA/IG51bGwgOiBoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0LkFMTE9XRURfRUFOX0VYVEVOU0lPTlMpO1xyXG4gICAgICAgIGlmIChhbGxvd2VkRXh0ZW5zaW9ucyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBsZW5ndGhfMSBpbiBhbGxvd2VkRXh0ZW5zaW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbkxlbmd0aC50b1N0cmluZygpID09PSBsZW5ndGhfMSkgeyAvLyBjaGVjayBtZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuRUFOXzEzIHx8IGZvcm1hdCA9PT0gQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuVVBDX0EpIHtcclxuICAgICAgICAgICAgLy8gbGV0IGNvdW50cnlJRCA9IGVhbk1hblN1cHBvcnQubG9va3VwQ29udHJ5SWRlbnRpZmllcihyZXN1bHRTdHJpbmcpOyB0b2RvXHJcbiAgICAgICAgICAgIC8vIGlmIChjb3VudHJ5SUQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyAgICAgZGVjb2RlUmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZS5QT1NTSUJMRV9DT1VOVFJZLCBjb3VudHJ5SUQpO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWNvZGVSZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgVVBDRUFOUmVhZGVyLmNoZWNrQ2hlY2tzdW0gPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgIHJldHVybiBVUENFQU5SZWFkZXIuY2hlY2tTdGFuZGFyZFVQQ0VBTkNoZWNrc3VtKHMpO1xyXG4gICAgfTtcclxuICAgIFVQQ0VBTlJlYWRlci5jaGVja1N0YW5kYXJkVVBDRUFOQ2hlY2tzdW0gPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuZ3RoID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgdmFyIGNoZWNrID0gcGFyc2VJbnQocy5jaGFyQXQobGVuZ3RoIC0gMSksIDEwKTtcclxuICAgICAgICByZXR1cm4gVVBDRUFOUmVhZGVyLmdldFN0YW5kYXJkVVBDRUFOQ2hlY2tzdW0ocy5zdWJzdHJpbmcoMCwgbGVuZ3RoIC0gMSkpID09PSBjaGVjaztcclxuICAgIH07XHJcbiAgICBVUENFQU5SZWFkZXIuZ2V0U3RhbmRhcmRVUENFQU5DaGVja3N1bSA9IGZ1bmN0aW9uIChzKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xyXG4gICAgICAgICAgICB2YXIgZGlnaXQgPSBzLmNoYXJBdChpKS5jaGFyQ29kZUF0KDApIC0gJzAnLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdCA8IDAgfHwgZGlnaXQgPiA5KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1bSArPSBkaWdpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VtICo9IDM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IHMuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgaWYgKGRpZ2l0IDwgMCB8fCBkaWdpdCA+IDkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3VtICs9IGRpZ2l0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKDEwMDAgLSBzdW0pICUgMTA7XHJcbiAgICB9O1xyXG4gICAgVVBDRUFOUmVhZGVyLmRlY29kZUVuZCA9IGZ1bmN0aW9uIChyb3csIGVuZFN0YXJ0KSB7XHJcbiAgICAgICAgcmV0dXJuIFVQQ0VBTlJlYWRlci5maW5kR3VhcmRQYXR0ZXJuKHJvdywgZW5kU3RhcnQsIGZhbHNlLCBVUENFQU5SZWFkZXIuU1RBUlRfRU5EX1BBVFRFUk4sIG5ldyBBcnJheShVUENFQU5SZWFkZXIuU1RBUlRfRU5EX1BBVFRFUk4ubGVuZ3RoKS5maWxsKDApKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVVBDRUFOUmVhZGVyO1xyXG59KEFic3RyYWN0VVBDRUFOUmVhZGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBVUENFQU5SZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVQQ0VBTlJlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIE9uZURSZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi9PbmVEUmVhZGVyXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxudmFyIE1hdGhVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9kZXRlY3Rvci9NYXRoVXRpbHNcIik7XHJcbnZhciBBYnN0cmFjdFJTU1JlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBYnN0cmFjdFJTU1JlYWRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFic3RyYWN0UlNTUmVhZGVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGVjb2RlRmluZGVyQ291bnRlcnMgPSBuZXcgQXJyYXkoNCk7XHJcbiAgICAgICAgX3RoaXMuZGF0YUNoYXJhY3RlckNvdW50ZXJzID0gbmV3IEFycmF5KDgpO1xyXG4gICAgICAgIF90aGlzLm9kZFJvdW5kaW5nRXJyb3JzID0gbmV3IEFycmF5KDQpO1xyXG4gICAgICAgIF90aGlzLmV2ZW5Sb3VuZGluZ0Vycm9ycyA9IG5ldyBBcnJheSg0KTtcclxuICAgICAgICBfdGhpcy5vZGRDb3VudHMgPSBuZXcgQXJyYXkoX3RoaXMuZGF0YUNoYXJhY3RlckNvdW50ZXJzLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgIF90aGlzLmV2ZW5Db3VudHMgPSBuZXcgQXJyYXkoX3RoaXMuZGF0YUNoYXJhY3RlckNvdW50ZXJzLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEFic3RyYWN0UlNTUmVhZGVyLnByb3RvdHlwZS5nZXREZWNvZGVGaW5kZXJDb3VudGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVGaW5kZXJDb3VudGVycztcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5wcm90b3R5cGUuZ2V0RGF0YUNoYXJhY3RlckNvdW50ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFDaGFyYWN0ZXJDb3VudGVycztcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5wcm90b3R5cGUuZ2V0T2RkUm91bmRpbmdFcnJvcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2RkUm91bmRpbmdFcnJvcnM7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RSU1NSZWFkZXIucHJvdG90eXBlLmdldEV2ZW5Sb3VuZGluZ0Vycm9ycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVuUm91bmRpbmdFcnJvcnM7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RSU1NSZWFkZXIucHJvdG90eXBlLmdldE9kZENvdW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vZGRDb3VudHM7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RSU1NSZWFkZXIucHJvdG90eXBlLmdldEV2ZW5Db3VudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbkNvdW50cztcclxuICAgIH07XHJcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5wcm90b3R5cGUucGFyc2VGaW5kZXJWYWx1ZSA9IGZ1bmN0aW9uIChjb3VudGVycywgZmluZGVyUGF0dGVybnMpIHtcclxuICAgICAgICBmb3IgKHZhciB2YWx1ZSA9IDA7IHZhbHVlIDwgZmluZGVyUGF0dGVybnMubGVuZ3RoOyB2YWx1ZSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChPbmVEUmVhZGVyXzEuZGVmYXVsdC5wYXR0ZXJuTWF0Y2hWYXJpYW5jZShjb3VudGVycywgZmluZGVyUGF0dGVybnNbdmFsdWVdLCBBYnN0cmFjdFJTU1JlYWRlci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSkgPCBBYnN0cmFjdFJTU1JlYWRlci5NQVhfQVZHX1ZBUklBTkNFKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGFycmF5IHZhbHVlcyB0byBzdW1cclxuICAgICAqIEByZXR1cm4gc3VtIG9mIHZhbHVlc1xyXG4gICAgICogQGRlcHJlY2F0ZWQgY2FsbCB7QGxpbmsgTWF0aFV0aWxzI3N1bShpbnRbXSl9XHJcbiAgICAgKi9cclxuICAgIEFic3RyYWN0UlNTUmVhZGVyLmNvdW50ID0gZnVuY3Rpb24gKGFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGhVdGlsc18xLmRlZmF1bHQuc3VtKG5ldyBJbnQzMkFycmF5KGFycmF5KSk7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RSU1NSZWFkZXIuaW5jcmVtZW50ID0gZnVuY3Rpb24gKGFycmF5LCBlcnJvcnMpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBiaWdnZXN0RXJyb3IgPSBlcnJvcnNbMF07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JzW2ldID4gYmlnZ2VzdEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBiaWdnZXN0RXJyb3IgPSBlcnJvcnNbaV07XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYXJyYXlbaW5kZXhdKys7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RSU1NSZWFkZXIuZGVjcmVtZW50ID0gZnVuY3Rpb24gKGFycmF5LCBlcnJvcnMpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBiaWdnZXN0RXJyb3IgPSBlcnJvcnNbMF07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZXJyb3JzW2ldIDwgYmlnZ2VzdEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBiaWdnZXN0RXJyb3IgPSBlcnJvcnNbaV07XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYXJyYXlbaW5kZXhdLS07XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RSU1NSZWFkZXIuaXNGaW5kZXJQYXR0ZXJuID0gZnVuY3Rpb24gKGNvdW50ZXJzKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgdmFyIGZpcnN0VHdvU3VtID0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcclxuICAgICAgICB2YXIgc3VtID0gZmlyc3RUd29TdW0gKyBjb3VudGVyc1syXSArIGNvdW50ZXJzWzNdO1xyXG4gICAgICAgIHZhciByYXRpbyA9IGZpcnN0VHdvU3VtIC8gc3VtO1xyXG4gICAgICAgIGlmIChyYXRpbyA+PSBBYnN0cmFjdFJTU1JlYWRlci5NSU5fRklOREVSX1BBVFRFUk5fUkFUSU8gJiYgcmF0aW8gPD0gQWJzdHJhY3RSU1NSZWFkZXIuTUFYX0ZJTkRFUl9QQVRURVJOX1JBVElPKSB7XHJcbiAgICAgICAgICAgIC8vIHBhc3NlcyByYXRpbyB0ZXN0IGluIHNwZWMsIGJ1dCBzZWUgaWYgdGhlIGNvdW50cyBhcmUgdW5yZWFzb25hYmxlXHJcbiAgICAgICAgICAgIHZhciBtaW5Db3VudGVyID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcbiAgICAgICAgICAgIHZhciBtYXhDb3VudGVyID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb3VudGVyc18xID0gX192YWx1ZXMoY291bnRlcnMpLCBjb3VudGVyc18xXzEgPSBjb3VudGVyc18xLm5leHQoKTsgIWNvdW50ZXJzXzFfMS5kb25lOyBjb3VudGVyc18xXzEgPSBjb3VudGVyc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudGVyID0gY291bnRlcnNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3VudGVyID4gbWF4Q291bnRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhDb3VudGVyID0gY291bnRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXIgPCBtaW5Db3VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvdW50ZXIgPSBjb3VudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJzXzFfMSAmJiAhY291bnRlcnNfMV8xLmRvbmUgJiYgKF9hID0gY291bnRlcnNfMS5yZXR1cm4pKSBfYS5jYWxsKGNvdW50ZXJzXzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtYXhDb3VudGVyIDwgMTAgKiBtaW5Db3VudGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQWJzdHJhY3RSU1NSZWFkZXIuTUFYX0FWR19WQVJJQU5DRSA9IDAuMjtcclxuICAgIEFic3RyYWN0UlNTUmVhZGVyLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFID0gMC40NTtcclxuICAgIEFic3RyYWN0UlNTUmVhZGVyLk1JTl9GSU5ERVJfUEFUVEVSTl9SQVRJTyA9IDkuNSAvIDEyLjA7XHJcbiAgICBBYnN0cmFjdFJTU1JlYWRlci5NQVhfRklOREVSX1BBVFRFUk5fUkFUSU8gPSAxMi41IC8gMTQuMDtcclxuICAgIHJldHVybiBBYnN0cmFjdFJTU1JlYWRlcjtcclxufShPbmVEUmVhZGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdFJTU1JlYWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJzdHJhY3RSU1NSZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIERhdGFDaGFyYWN0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhQ2hhcmFjdGVyKHZhbHVlLCBjaGVja3N1bVBvcnRpb24pIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5jaGVja3N1bVBvcnRpb24gPSBjaGVja3N1bVBvcnRpb247XHJcbiAgICB9XHJcbiAgICBEYXRhQ2hhcmFjdGVyLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBEYXRhQ2hhcmFjdGVyLnByb3RvdHlwZS5nZXRDaGVja3N1bVBvcnRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tzdW1Qb3J0aW9uO1xyXG4gICAgfTtcclxuICAgIERhdGFDaGFyYWN0ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlICsgJygnICsgdGhpcy5jaGVja3N1bVBvcnRpb24gKyAnKSc7XHJcbiAgICB9O1xyXG4gICAgRGF0YUNoYXJhY3Rlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgRGF0YUNoYXJhY3RlcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGhhdCA9IG87XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IHRoYXQudmFsdWUgJiYgdGhpcy5jaGVja3N1bVBvcnRpb24gPT09IHRoYXQuY2hlY2tzdW1Qb3J0aW9uO1xyXG4gICAgfTtcclxuICAgIERhdGFDaGFyYWN0ZXIucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlIF4gdGhpcy5jaGVja3N1bVBvcnRpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGFDaGFyYWN0ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGFDaGFyYWN0ZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFDaGFyYWN0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVzdWx0UG9pbnRcIik7XHJcbnZhciBGaW5kZXJQYXR0ZXJuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmluZGVyUGF0dGVybih2YWx1ZSwgc3RhcnRFbmQsIHN0YXJ0LCBlbmQsIHJvd051bWJlcikge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnN0YXJ0RW5kID0gc3RhcnRFbmQ7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRFbmQgPSBzdGFydEVuZDtcclxuICAgICAgICB0aGlzLnJlc3VsdFBvaW50cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMucmVzdWx0UG9pbnRzLnB1c2gobmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChzdGFydCwgcm93TnVtYmVyKSk7XHJcbiAgICAgICAgdGhpcy5yZXN1bHRQb2ludHMucHVzaChuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGVuZCwgcm93TnVtYmVyKSk7XHJcbiAgICB9XHJcbiAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5nZXRTdGFydEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydEVuZDtcclxuICAgIH07XHJcbiAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5nZXRSZXN1bHRQb2ludHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0UG9pbnRzO1xyXG4gICAgfTtcclxuICAgIEZpbmRlclBhdHRlcm4ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgaWYgKCEobyBpbnN0YW5jZW9mIEZpbmRlclBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoYXQgPSBvO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSB0aGF0LnZhbHVlO1xyXG4gICAgfTtcclxuICAgIEZpbmRlclBhdHRlcm4ucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBGaW5kZXJQYXR0ZXJuO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBGaW5kZXJQYXR0ZXJuO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaW5kZXJQYXR0ZXJuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRGF0YUNoYXJhY3Rlcl8xID0gcmVxdWlyZShcIi4vRGF0YUNoYXJhY3RlclwiKTtcclxudmFyIFBhaXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUGFpciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBhaXIodmFsdWUsIGNoZWNrc3VtUG9ydGlvbiwgZmluZGVyUGF0dGVybikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHZhbHVlLCBjaGVja3N1bVBvcnRpb24pIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY291bnQgPSAwO1xyXG4gICAgICAgIF90aGlzLmZpbmRlclBhdHRlcm4gPSBmaW5kZXJQYXR0ZXJuO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFBhaXIucHJvdG90eXBlLmdldEZpbmRlclBhdHRlcm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZGVyUGF0dGVybjtcclxuICAgIH07XHJcbiAgICBQYWlyLnByb3RvdHlwZS5nZXRDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcclxuICAgIH07XHJcbiAgICBQYWlyLnByb3RvdHlwZS5pbmNyZW1lbnRDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBhaXI7XHJcbn0oRGF0YUNoYXJhY3Rlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUGFpcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFpci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEFic3RyYWN0UlNTUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdFJTU1JlYWRlclwiKTtcclxudmFyIFBhaXJfMSA9IHJlcXVpcmUoXCIuL1BhaXJcIik7XHJcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9SZXN1bHRcIik7XHJcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uLy4uL0RlY29kZUhpbnRUeXBlXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XHJcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi4vLi4vQmFyY29kZUZvcm1hdFwiKTtcclxudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVzdWx0UG9pbnRcIik7XHJcbnZhciBGaW5kZXJQYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9GaW5kZXJQYXR0ZXJuXCIpO1xyXG52YXIgRGF0YUNoYXJhY3Rlcl8xID0gcmVxdWlyZShcIi4vRGF0YUNoYXJhY3RlclwiKTtcclxudmFyIE1hdGhVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9kZXRlY3Rvci9NYXRoVXRpbHNcIik7XHJcbnZhciBSU1NVdGlsc18xID0gcmVxdWlyZShcIi4vUlNTVXRpbHNcIik7XHJcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N5c3RlbVwiKTtcclxudmFyIE9uZURSZWFkZXJfMSA9IHJlcXVpcmUoXCIuLi9PbmVEUmVhZGVyXCIpO1xyXG52YXIgUlNTMTRSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoUlNTMTRSZWFkZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSU1MxNFJlYWRlcigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5wb3NzaWJsZUxlZnRQYWlycyA9IFtdO1xyXG4gICAgICAgIF90aGlzLnBvc3NpYmxlUmlnaHRQYWlycyA9IFtdO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFJTUzE0UmVhZGVyLnByb3RvdHlwZS5kZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XHJcbiAgICAgICAgdmFyIGxlZnRQYWlyID0gdGhpcy5kZWNvZGVQYWlyKHJvdywgZmFsc2UsIHJvd051bWJlciwgaGludHMpO1xyXG4gICAgICAgIFJTUzE0UmVhZGVyLmFkZE9yVGFsbHkodGhpcy5wb3NzaWJsZUxlZnRQYWlycywgbGVmdFBhaXIpO1xyXG4gICAgICAgIHJvdy5yZXZlcnNlKCk7XHJcbiAgICAgICAgdmFyIHJpZ2h0UGFpciA9IHRoaXMuZGVjb2RlUGFpcihyb3csIHRydWUsIHJvd051bWJlciwgaGludHMpO1xyXG4gICAgICAgIFJTUzE0UmVhZGVyLmFkZE9yVGFsbHkodGhpcy5wb3NzaWJsZVJpZ2h0UGFpcnMsIHJpZ2h0UGFpcik7XHJcbiAgICAgICAgcm93LnJldmVyc2UoKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKHRoaXMucG9zc2libGVMZWZ0UGFpcnMpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IF9kLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnQuZ2V0Q291bnQoKSA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZSA9IF9fdmFsdWVzKHRoaXMucG9zc2libGVSaWdodFBhaXJzKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0ID0gX2YudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmlnaHQuZ2V0Q291bnQoKSA+IDEgJiYgUlNTMTRSZWFkZXIuY2hlY2tDaGVja3N1bShsZWZ0LCByaWdodCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUlNTMTRSZWFkZXIuY29uc3RydWN0UmVzdWx0KGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICBSU1MxNFJlYWRlci5hZGRPclRhbGx5ID0gZnVuY3Rpb24gKHBvc3NpYmxlUGFpcnMsIHBhaXIpIHtcclxuICAgICAgICB2YXIgZV8zLCBfYTtcclxuICAgICAgICBpZiAocGFpciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcG9zc2libGVQYWlyc18xID0gX192YWx1ZXMocG9zc2libGVQYWlycyksIHBvc3NpYmxlUGFpcnNfMV8xID0gcG9zc2libGVQYWlyc18xLm5leHQoKTsgIXBvc3NpYmxlUGFpcnNfMV8xLmRvbmU7IHBvc3NpYmxlUGFpcnNfMV8xID0gcG9zc2libGVQYWlyc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gcG9zc2libGVQYWlyc18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAob3RoZXIuZ2V0VmFsdWUoKSA9PT0gcGFpci5nZXRWYWx1ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3RoZXIuaW5jcmVtZW50Q291bnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZVBhaXJzXzFfMSAmJiAhcG9zc2libGVQYWlyc18xXzEuZG9uZSAmJiAoX2EgPSBwb3NzaWJsZVBhaXJzXzEucmV0dXJuKSkgX2EuY2FsbChwb3NzaWJsZVBhaXJzXzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgICAgICBwb3NzaWJsZVBhaXJzLnB1c2gocGFpcik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJTUzE0UmVhZGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnBvc3NpYmxlTGVmdFBhaXJzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5wb3NzaWJsZVJpZ2h0UGFpcnMubGVuZ3RoID0gMDtcclxuICAgIH07XHJcbiAgICBSU1MxNFJlYWRlci5jb25zdHJ1Y3RSZXN1bHQgPSBmdW5jdGlvbiAobGVmdFBhaXIsIHJpZ2h0UGFpcikge1xyXG4gICAgICAgIHZhciBzeW1ib2xWYWx1ZSA9IDQ1MzcwNzcgKiBsZWZ0UGFpci5nZXRWYWx1ZSgpICsgcmlnaHRQYWlyLmdldFZhbHVlKCk7XHJcbiAgICAgICAgdmFyIHRleHQgPSBuZXcgU3RyaW5nKHN5bWJvbFZhbHVlKS50b1N0cmluZygpO1xyXG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTMgLSB0ZXh0Lmxlbmd0aDsgaSA+IDA7IGktLSkge1xyXG4gICAgICAgICAgICBidWZmZXIuYXBwZW5kKCcwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1ZmZlci5hcHBlbmQodGV4dCk7XHJcbiAgICAgICAgdmFyIGNoZWNrRGlnaXQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTM7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZGlnaXQgPSBidWZmZXIuY2hhckF0KGkpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgY2hlY2tEaWdpdCArPSAoKGkgJiAweDAxKSA9PT0gMCkgPyAzICogZGlnaXQgOiBkaWdpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hlY2tEaWdpdCA9IDEwIC0gKGNoZWNrRGlnaXQgJSAxMCk7XHJcbiAgICAgICAgaWYgKGNoZWNrRGlnaXQgPT09IDEwKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRGlnaXQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWZmZXIuYXBwZW5kKGNoZWNrRGlnaXQudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgdmFyIGxlZnRQb2ludHMgPSBsZWZ0UGFpci5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0UmVzdWx0UG9pbnRzKCk7XHJcbiAgICAgICAgdmFyIHJpZ2h0UG9pbnRzID0gcmlnaHRQYWlyLmdldEZpbmRlclBhdHRlcm4oKS5nZXRSZXN1bHRQb2ludHMoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdF8xLmRlZmF1bHQoYnVmZmVyLnRvU3RyaW5nKCksIG51bGwsIDAsIFtsZWZ0UG9pbnRzWzBdLCBsZWZ0UG9pbnRzWzFdLCByaWdodFBvaW50c1swXSwgcmlnaHRQb2ludHNbMV1dLCBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5SU1NfMTQsIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcclxuICAgIH07XHJcbiAgICBSU1MxNFJlYWRlci5jaGVja0NoZWNrc3VtID0gZnVuY3Rpb24gKGxlZnRQYWlyLCByaWdodFBhaXIpIHtcclxuICAgICAgICB2YXIgY2hlY2tWYWx1ZSA9IChsZWZ0UGFpci5nZXRDaGVja3N1bVBvcnRpb24oKSArIDE2ICogcmlnaHRQYWlyLmdldENoZWNrc3VtUG9ydGlvbigpKSAlIDc5O1xyXG4gICAgICAgIHZhciB0YXJnZXRDaGVja1ZhbHVlID0gOSAqIGxlZnRQYWlyLmdldEZpbmRlclBhdHRlcm4oKS5nZXRWYWx1ZSgpICsgcmlnaHRQYWlyLmdldEZpbmRlclBhdHRlcm4oKS5nZXRWYWx1ZSgpO1xyXG4gICAgICAgIGlmICh0YXJnZXRDaGVja1ZhbHVlID4gNzIpIHtcclxuICAgICAgICAgICAgdGFyZ2V0Q2hlY2tWYWx1ZS0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0Q2hlY2tWYWx1ZSA+IDgpIHtcclxuICAgICAgICAgICAgdGFyZ2V0Q2hlY2tWYWx1ZS0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hlY2tWYWx1ZSA9PT0gdGFyZ2V0Q2hlY2tWYWx1ZTtcclxuICAgIH07XHJcbiAgICBSU1MxNFJlYWRlci5wcm90b3R5cGUuZGVjb2RlUGFpciA9IGZ1bmN0aW9uIChyb3csIHJpZ2h0LCByb3dOdW1iZXIsIGhpbnRzKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIHN0YXJ0RW5kID0gdGhpcy5maW5kRmluZGVyUGF0dGVybihyb3csIHJpZ2h0KTtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhcnNlRm91bmRGaW5kZXJQYXR0ZXJuKHJvdywgcm93TnVtYmVyLCByaWdodCwgc3RhcnRFbmQpO1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0UG9pbnRDYWxsYmFjayA9IGhpbnRzID09IG51bGwgPyBudWxsIDogaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRQb2ludENhbGxiYWNrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSAoc3RhcnRFbmRbMF0gKyBzdGFydEVuZFsxXSkgLyAyLjA7XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByb3cgaXMgYWN0dWFsbHkgcmV2ZXJzZWRcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIgPSByb3cuZ2V0U2l6ZSgpIC0gMSAtIGNlbnRlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdFBvaW50Q2FsbGJhY2suZm91bmRQb3NzaWJsZVJlc3VsdFBvaW50KG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoY2VudGVyLCByb3dOdW1iZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgb3V0c2lkZSA9IHRoaXMuZGVjb2RlRGF0YUNoYXJhY3Rlcihyb3csIHBhdHRlcm4sIHRydWUpO1xyXG4gICAgICAgICAgICB2YXIgaW5zaWRlID0gdGhpcy5kZWNvZGVEYXRhQ2hhcmFjdGVyKHJvdywgcGF0dGVybiwgZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhaXJfMS5kZWZhdWx0KDE1OTcgKiBvdXRzaWRlLmdldFZhbHVlKCkgKyBpbnNpZGUuZ2V0VmFsdWUoKSwgb3V0c2lkZS5nZXRDaGVja3N1bVBvcnRpb24oKSArIDQgKiBpbnNpZGUuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCksIHBhdHRlcm4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSU1MxNFJlYWRlci5wcm90b3R5cGUuZGVjb2RlRGF0YUNoYXJhY3RlciA9IGZ1bmN0aW9uIChyb3csIHBhdHRlcm4sIG91dHNpZGVDaGFyKSB7XHJcbiAgICAgICAgdmFyIGNvdW50ZXJzID0gdGhpcy5nZXREYXRhQ2hhcmFjdGVyQ291bnRlcnMoKTtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNvdW50ZXJzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGNvdW50ZXJzW3hdID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG91dHNpZGVDaGFyKSB7XHJcbiAgICAgICAgICAgIE9uZURSZWFkZXJfMS5kZWZhdWx0LnJlY29yZFBhdHRlcm5JblJldmVyc2Uocm93LCBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMF0sIGNvdW50ZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIE9uZURSZWFkZXJfMS5kZWZhdWx0LnJlY29yZFBhdHRlcm4ocm93LCBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMV0gKyAxLCBjb3VudGVycyk7XHJcbiAgICAgICAgICAgIC8vIHJldmVyc2UgaXRcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBjb3VudGVycy5sZW5ndGggLSAxOyBpIDwgajsgaSsrLCBqLS0pIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gY291bnRlcnNbaV07XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tpXSA9IGNvdW50ZXJzW2pdO1xyXG4gICAgICAgICAgICAgICAgY291bnRlcnNbal0gPSB0ZW1wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBudW1Nb2R1bGVzID0gb3V0c2lkZUNoYXIgPyAxNiA6IDE1O1xyXG4gICAgICAgIHZhciBlbGVtZW50V2lkdGggPSBNYXRoVXRpbHNfMS5kZWZhdWx0LnN1bShuZXcgSW50MzJBcnJheShjb3VudGVycykpIC8gbnVtTW9kdWxlcztcclxuICAgICAgICB2YXIgb2RkQ291bnRzID0gdGhpcy5nZXRPZGRDb3VudHMoKTtcclxuICAgICAgICB2YXIgZXZlbkNvdW50cyA9IHRoaXMuZ2V0RXZlbkNvdW50cygpO1xyXG4gICAgICAgIHZhciBvZGRSb3VuZGluZ0Vycm9ycyA9IHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKTtcclxuICAgICAgICB2YXIgZXZlblJvdW5kaW5nRXJyb3JzID0gdGhpcy5nZXRFdmVuUm91bmRpbmdFcnJvcnMoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNvdW50ZXJzW2ldIC8gZWxlbWVudFdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgY291bnQgPSBNYXRoLmZsb29yKHZhbHVlICsgMC41KTtcclxuICAgICAgICAgICAgaWYgKGNvdW50IDwgMSkge1xyXG4gICAgICAgICAgICAgICAgY291bnQgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNvdW50ID4gOCkge1xyXG4gICAgICAgICAgICAgICAgY291bnQgPSA4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBNYXRoLmZsb29yKGkgLyAyKTtcclxuICAgICAgICAgICAgaWYgKChpICYgMHgwMSkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIG9kZENvdW50c1tvZmZzZXRdID0gY291bnQ7XHJcbiAgICAgICAgICAgICAgICBvZGRSb3VuZGluZ0Vycm9yc1tvZmZzZXRdID0gdmFsdWUgLSBjb3VudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV2ZW5Db3VudHNbb2Zmc2V0XSA9IGNvdW50O1xyXG4gICAgICAgICAgICAgICAgZXZlblJvdW5kaW5nRXJyb3JzW29mZnNldF0gPSB2YWx1ZSAtIGNvdW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRqdXN0T2RkRXZlbkNvdW50cyhvdXRzaWRlQ2hhciwgbnVtTW9kdWxlcyk7XHJcbiAgICAgICAgdmFyIG9kZFN1bSA9IDA7XHJcbiAgICAgICAgdmFyIG9kZENoZWNrc3VtUG9ydGlvbiA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IG9kZENvdW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBvZGRDaGVja3N1bVBvcnRpb24gKj0gOTtcclxuICAgICAgICAgICAgb2RkQ2hlY2tzdW1Qb3J0aW9uICs9IG9kZENvdW50c1tpXTtcclxuICAgICAgICAgICAgb2RkU3VtICs9IG9kZENvdW50c1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV2ZW5DaGVja3N1bVBvcnRpb24gPSAwO1xyXG4gICAgICAgIHZhciBldmVuU3VtID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gZXZlbkNvdW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBldmVuQ2hlY2tzdW1Qb3J0aW9uICo9IDk7XHJcbiAgICAgICAgICAgIGV2ZW5DaGVja3N1bVBvcnRpb24gKz0gZXZlbkNvdW50c1tpXTtcclxuICAgICAgICAgICAgZXZlblN1bSArPSBldmVuQ291bnRzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2hlY2tzdW1Qb3J0aW9uID0gb2RkQ2hlY2tzdW1Qb3J0aW9uICsgMyAqIGV2ZW5DaGVja3N1bVBvcnRpb247XHJcbiAgICAgICAgaWYgKG91dHNpZGVDaGFyKSB7XHJcbiAgICAgICAgICAgIGlmICgob2RkU3VtICYgMHgwMSkgIT09IDAgfHwgb2RkU3VtID4gMTIgfHwgb2RkU3VtIDwgNCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9ICgxMiAtIG9kZFN1bSkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgb2RkV2lkZXN0ID0gUlNTMTRSZWFkZXIuT1VUU0lERV9PRERfV0lERVNUW2dyb3VwXTtcclxuICAgICAgICAgICAgdmFyIGV2ZW5XaWRlc3QgPSA5IC0gb2RkV2lkZXN0O1xyXG4gICAgICAgICAgICB2YXIgdk9kZCA9IFJTU1V0aWxzXzEuZGVmYXVsdC5nZXRSU1N2YWx1ZShvZGRDb3VudHMsIG9kZFdpZGVzdCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB2YXIgdkV2ZW4gPSBSU1NVdGlsc18xLmRlZmF1bHQuZ2V0UlNTdmFsdWUoZXZlbkNvdW50cywgZXZlbldpZGVzdCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciB0RXZlbiA9IFJTUzE0UmVhZGVyLk9VVFNJREVfRVZFTl9UT1RBTF9TVUJTRVRbZ3JvdXBdO1xyXG4gICAgICAgICAgICB2YXIgZ1N1bSA9IFJTUzE0UmVhZGVyLk9VVFNJREVfR1NVTVtncm91cF07XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0YUNoYXJhY3Rlcl8xLmRlZmF1bHQodk9kZCAqIHRFdmVuICsgdkV2ZW4gKyBnU3VtLCBjaGVja3N1bVBvcnRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKChldmVuU3VtICYgMHgwMSkgIT09IDAgfHwgZXZlblN1bSA+IDEwIHx8IGV2ZW5TdW0gPCA0KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gKDEwIC0gZXZlblN1bSkgLyAyO1xyXG4gICAgICAgICAgICB2YXIgb2RkV2lkZXN0ID0gUlNTMTRSZWFkZXIuSU5TSURFX09ERF9XSURFU1RbZ3JvdXBdO1xyXG4gICAgICAgICAgICB2YXIgZXZlbldpZGVzdCA9IDkgLSBvZGRXaWRlc3Q7XHJcbiAgICAgICAgICAgIHZhciB2T2RkID0gUlNTVXRpbHNfMS5kZWZhdWx0LmdldFJTU3ZhbHVlKG9kZENvdW50cywgb2RkV2lkZXN0LCB0cnVlKTtcclxuICAgICAgICAgICAgdmFyIHZFdmVuID0gUlNTVXRpbHNfMS5kZWZhdWx0LmdldFJTU3ZhbHVlKGV2ZW5Db3VudHMsIGV2ZW5XaWRlc3QsIGZhbHNlKTtcclxuICAgICAgICAgICAgdmFyIHRPZGQgPSBSU1MxNFJlYWRlci5JTlNJREVfT0REX1RPVEFMX1NVQlNFVFtncm91cF07XHJcbiAgICAgICAgICAgIHZhciBnU3VtID0gUlNTMTRSZWFkZXIuSU5TSURFX0dTVU1bZ3JvdXBdO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFDaGFyYWN0ZXJfMS5kZWZhdWx0KHZFdmVuICogdE9kZCArIHZPZGQgKyBnU3VtLCBjaGVja3N1bVBvcnRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSU1MxNFJlYWRlci5wcm90b3R5cGUuZmluZEZpbmRlclBhdHRlcm4gPSBmdW5jdGlvbiAocm93LCByaWdodEZpbmRlclBhdHRlcm4pIHtcclxuICAgICAgICB2YXIgY291bnRlcnMgPSB0aGlzLmdldERlY29kZUZpbmRlckNvdW50ZXJzKCk7XHJcbiAgICAgICAgY291bnRlcnNbMF0gPSAwO1xyXG4gICAgICAgIGNvdW50ZXJzWzFdID0gMDtcclxuICAgICAgICBjb3VudGVyc1syXSA9IDA7XHJcbiAgICAgICAgY291bnRlcnNbM10gPSAwO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJvdy5nZXRTaXplKCk7XHJcbiAgICAgICAgdmFyIGlzV2hpdGUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgcm93T2Zmc2V0ID0gMDtcclxuICAgICAgICB3aGlsZSAocm93T2Zmc2V0IDwgd2lkdGgpIHtcclxuICAgICAgICAgICAgaXNXaGl0ZSA9ICFyb3cuZ2V0KHJvd09mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChyaWdodEZpbmRlclBhdHRlcm4gPT09IGlzV2hpdGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFdpbGwgZW5jb3VudGVyIHdoaXRlIGZpcnN0IHdoZW4gc2VhcmNoaW5nIGZvciByaWdodCBmaW5kZXIgcGF0dGVyblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm93T2Zmc2V0Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb3VudGVyUG9zaXRpb24gPSAwO1xyXG4gICAgICAgIHZhciBwYXR0ZXJuU3RhcnQgPSByb3dPZmZzZXQ7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IHJvd09mZnNldDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgaWYgKHJvdy5nZXQoeCkgIT09IGlzV2hpdGUpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IDMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQWJzdHJhY3RSU1NSZWFkZXJfMS5kZWZhdWx0LmlzRmluZGVyUGF0dGVybihjb3VudGVycykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtwYXR0ZXJuU3RhcnQsIHhdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuU3RhcnQgKz0gY291bnRlcnNbMF0gKyBjb3VudGVyc1sxXTtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1swXSA9IGNvdW50ZXJzWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzFdID0gY291bnRlcnNbM107XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbMl0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzNdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24tLTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJQb3NpdGlvbisrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDE7XHJcbiAgICAgICAgICAgICAgICBpc1doaXRlID0gIWlzV2hpdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIFJTUzE0UmVhZGVyLnByb3RvdHlwZS5wYXJzZUZvdW5kRmluZGVyUGF0dGVybiA9IGZ1bmN0aW9uIChyb3csIHJvd051bWJlciwgcmlnaHQsIHN0YXJ0RW5kKSB7XHJcbiAgICAgICAgLy8gQWN0dWFsbHkgd2UgZm91bmQgZWxlbWVudHMgMi01XHJcbiAgICAgICAgdmFyIGZpcnN0SXNCbGFjayA9IHJvdy5nZXQoc3RhcnRFbmRbMF0pO1xyXG4gICAgICAgIHZhciBmaXJzdEVsZW1lbnRTdGFydCA9IHN0YXJ0RW5kWzBdIC0gMTtcclxuICAgICAgICAvLyBMb2NhdGUgZWxlbWVudCAxXHJcbiAgICAgICAgd2hpbGUgKGZpcnN0RWxlbWVudFN0YXJ0ID49IDAgJiYgZmlyc3RJc0JsYWNrICE9PSByb3cuZ2V0KGZpcnN0RWxlbWVudFN0YXJ0KSkge1xyXG4gICAgICAgICAgICBmaXJzdEVsZW1lbnRTdGFydC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaXJzdEVsZW1lbnRTdGFydCsrO1xyXG4gICAgICAgIHZhciBmaXJzdENvdW50ZXIgPSBzdGFydEVuZFswXSAtIGZpcnN0RWxlbWVudFN0YXJ0O1xyXG4gICAgICAgIC8vIE1ha2UgJ2NvdW50ZXJzJyBob2xkIDEtNFxyXG4gICAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcclxuICAgICAgICB2YXIgY29weSA9IG5ldyBBcnJheShjb3VudGVycy5sZW5ndGgpO1xyXG4gICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KGNvdW50ZXJzLCAwLCBjb3B5LCAxLCBjb3VudGVycy5sZW5ndGggLSAxKTtcclxuICAgICAgICBjb3B5WzBdID0gZmlyc3RDb3VudGVyO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMucGFyc2VGaW5kZXJWYWx1ZShjb3B5LCBSU1MxNFJlYWRlci5GSU5ERVJfUEFUVEVSTlMpO1xyXG4gICAgICAgIHZhciBzdGFydCA9IGZpcnN0RWxlbWVudFN0YXJ0O1xyXG4gICAgICAgIHZhciBlbmQgPSBzdGFydEVuZFsxXTtcclxuICAgICAgICBpZiAocmlnaHQpIHtcclxuICAgICAgICAgICAgLy8gcm93IGlzIGFjdHVhbGx5IHJldmVyc2VkXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gcm93LmdldFNpemUoKSAtIDEgLSBzdGFydDtcclxuICAgICAgICAgICAgZW5kID0gcm93LmdldFNpemUoKSAtIDEgLSBlbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRmluZGVyUGF0dGVybl8xLmRlZmF1bHQodmFsdWUsIFtmaXJzdEVsZW1lbnRTdGFydCwgc3RhcnRFbmRbMV1dLCBzdGFydCwgZW5kLCByb3dOdW1iZXIpO1xyXG4gICAgfTtcclxuICAgIFJTUzE0UmVhZGVyLnByb3RvdHlwZS5hZGp1c3RPZGRFdmVuQ291bnRzID0gZnVuY3Rpb24gKG91dHNpZGVDaGFyLCBudW1Nb2R1bGVzKSB7XHJcbiAgICAgICAgdmFyIG9kZFN1bSA9IE1hdGhVdGlsc18xLmRlZmF1bHQuc3VtKG5ldyBJbnQzMkFycmF5KHRoaXMuZ2V0T2RkQ291bnRzKCkpKTtcclxuICAgICAgICB2YXIgZXZlblN1bSA9IE1hdGhVdGlsc18xLmRlZmF1bHQuc3VtKG5ldyBJbnQzMkFycmF5KHRoaXMuZ2V0RXZlbkNvdW50cygpKSk7XHJcbiAgICAgICAgdmFyIGluY3JlbWVudE9kZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBkZWNyZW1lbnRPZGQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaW5jcmVtZW50RXZlbiA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBkZWNyZW1lbnRFdmVuID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKG91dHNpZGVDaGFyKSB7XHJcbiAgICAgICAgICAgIGlmIChvZGRTdW0gPiAxMikge1xyXG4gICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvZGRTdW0gPCA0KSB7XHJcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVuU3VtID4gMTIpIHtcclxuICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW5TdW0gPCA0KSB7XHJcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG9kZFN1bSA+IDExKSB7XHJcbiAgICAgICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9kZFN1bSA8IDUpIHtcclxuICAgICAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2ZW5TdW0gPiAxMCkge1xyXG4gICAgICAgICAgICAgICAgZGVjcmVtZW50RXZlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlblN1bSA8IDQpIHtcclxuICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaXNtYXRjaCA9IG9kZFN1bSArIGV2ZW5TdW0gLSBudW1Nb2R1bGVzO1xyXG4gICAgICAgIHZhciBvZGRQYXJpdHlCYWQgPSAob2RkU3VtICYgMHgwMSkgPT09IChvdXRzaWRlQ2hhciA/IDEgOiAwKTtcclxuICAgICAgICB2YXIgZXZlblBhcml0eUJhZCA9IChldmVuU3VtICYgMHgwMSkgPT09IDE7XHJcbiAgICAgICAgaWYgKG1pc21hdGNoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1pc21hdGNoID09PSAtMSkge1xyXG4gICAgICAgICAgICBpZiAob2RkUGFyaXR5QmFkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtaXNtYXRjaCA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAob2RkUGFyaXR5QmFkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW5QYXJpdHlCYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBCb3RoIGJhZFxyXG4gICAgICAgICAgICAgICAgaWYgKG9kZFN1bSA8IGV2ZW5TdW0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRPZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gTm90aGluZyB0byBkbyFcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5jcmVtZW50T2RkKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWNyZW1lbnRPZGQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBBYnN0cmFjdFJTU1JlYWRlcl8xLmRlZmF1bHQuaW5jcmVtZW50KHRoaXMuZ2V0T2RkQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWNyZW1lbnRPZGQpIHtcclxuICAgICAgICAgICAgQWJzdHJhY3RSU1NSZWFkZXJfMS5kZWZhdWx0LmRlY3JlbWVudCh0aGlzLmdldE9kZENvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5jcmVtZW50RXZlbikge1xyXG4gICAgICAgICAgICBpZiAoZGVjcmVtZW50RXZlbikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIEFic3RyYWN0UlNTUmVhZGVyXzEuZGVmYXVsdC5pbmNyZW1lbnQodGhpcy5nZXRFdmVuQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWNyZW1lbnRFdmVuKSB7XHJcbiAgICAgICAgICAgIEFic3RyYWN0UlNTUmVhZGVyXzEuZGVmYXVsdC5kZWNyZW1lbnQodGhpcy5nZXRFdmVuQ291bnRzKCksIHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSU1MxNFJlYWRlci5PVVRTSURFX0VWRU5fVE9UQUxfU1VCU0VUID0gWzEsIDEwLCAzNCwgNzAsIDEyNl07XHJcbiAgICBSU1MxNFJlYWRlci5JTlNJREVfT0REX1RPVEFMX1NVQlNFVCA9IFs0LCAyMCwgNDgsIDgxXTtcclxuICAgIFJTUzE0UmVhZGVyLk9VVFNJREVfR1NVTSA9IFswLCAxNjEsIDk2MSwgMjAxNSwgMjcxNV07XHJcbiAgICBSU1MxNFJlYWRlci5JTlNJREVfR1NVTSA9IFswLCAzMzYsIDEwMzYsIDE1MTZdO1xyXG4gICAgUlNTMTRSZWFkZXIuT1VUU0lERV9PRERfV0lERVNUID0gWzgsIDYsIDQsIDMsIDFdO1xyXG4gICAgUlNTMTRSZWFkZXIuSU5TSURFX09ERF9XSURFU1QgPSBbMiwgNCwgNiwgOF07XHJcbiAgICBSU1MxNFJlYWRlci5GSU5ERVJfUEFUVEVSTlMgPSBbXHJcbiAgICAgICAgWzMsIDgsIDIsIDFdLFxyXG4gICAgICAgIFszLCA1LCA1LCAxXSxcclxuICAgICAgICBbMywgMywgNywgMV0sXHJcbiAgICAgICAgWzMsIDEsIDksIDFdLFxyXG4gICAgICAgIFsyLCA3LCA0LCAxXSxcclxuICAgICAgICBbMiwgNSwgNiwgMV0sXHJcbiAgICAgICAgWzIsIDMsIDgsIDFdLFxyXG4gICAgICAgIFsxLCA1LCA3LCAxXSxcclxuICAgICAgICBbMSwgMywgOSwgMV0sXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIFJTUzE0UmVhZGVyO1xyXG59KEFic3RyYWN0UlNTUmVhZGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSU1MxNFJlYWRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UlNTMTRSZWFkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFJTUyB1dGlsIGZ1bmN0aW9ucy5cclxuICovXHJcbnZhciBSU1NVdGlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJTU1V0aWxzKCkge1xyXG4gICAgfVxyXG4gICAgUlNTVXRpbHMucHJvdG90eXBlLlJTU1V0aWxzID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgUlNTVXRpbHMuZ2V0UlNTdmFsdWUgPSBmdW5jdGlvbiAod2lkdGhzLCBtYXhXaWR0aCwgbm9OYXJyb3cpIHtcclxuICAgICAgICB2YXIgZV8xLCBfYTtcclxuICAgICAgICB2YXIgbiA9IDA7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgd2lkdGhzXzEgPSBfX3ZhbHVlcyh3aWR0aHMpLCB3aWR0aHNfMV8xID0gd2lkdGhzXzEubmV4dCgpOyAhd2lkdGhzXzFfMS5kb25lOyB3aWR0aHNfMV8xID0gd2lkdGhzXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2lkdGggPSB3aWR0aHNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgbiArPSB3aWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoc18xXzEgJiYgIXdpZHRoc18xXzEuZG9uZSAmJiAoX2EgPSB3aWR0aHNfMS5yZXR1cm4pKSBfYS5jYWxsKHdpZHRoc18xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWwgPSAwO1xyXG4gICAgICAgIHZhciBuYXJyb3dNYXNrID0gMDtcclxuICAgICAgICB2YXIgZWxlbWVudHMgPSB3aWR0aHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGJhciA9IDA7IGJhciA8IGVsZW1lbnRzIC0gMTsgYmFyKyspIHtcclxuICAgICAgICAgICAgdmFyIGVsbVdpZHRoID0gdm9pZCAwO1xyXG4gICAgICAgICAgICBmb3IgKGVsbVdpZHRoID0gMSwgbmFycm93TWFzayB8PSAxIDw8IGJhcjsgZWxtV2lkdGggPCB3aWR0aHNbYmFyXTsgZWxtV2lkdGgrKywgbmFycm93TWFzayAmPSB+KDEgPDwgYmFyKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN1YlZhbCA9IFJTU1V0aWxzLmNvbWJpbnMobiAtIGVsbVdpZHRoIC0gMSwgZWxlbWVudHMgLSBiYXIgLSAyKTtcclxuICAgICAgICAgICAgICAgIGlmIChub05hcnJvdyAmJiAobmFycm93TWFzayA9PT0gMCkgJiYgKG4gLSBlbG1XaWR0aCAtIChlbGVtZW50cyAtIGJhciAtIDEpID49IGVsZW1lbnRzIC0gYmFyIC0gMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdWJWYWwgLT0gUlNTVXRpbHMuY29tYmlucyhuIC0gZWxtV2lkdGggLSAoZWxlbWVudHMgLSBiYXIpLCBlbGVtZW50cyAtIGJhciAtIDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRzIC0gYmFyIC0gMSA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbGVzc1ZhbCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbXh3RWxlbWVudCA9IG4gLSBlbG1XaWR0aCAtIChlbGVtZW50cyAtIGJhciAtIDIpOyBteHdFbGVtZW50ID4gbWF4V2lkdGg7IG14d0VsZW1lbnQtLSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXNzVmFsICs9IFJTU1V0aWxzLmNvbWJpbnMobiAtIGVsbVdpZHRoIC0gbXh3RWxlbWVudCAtIDEsIGVsZW1lbnRzIC0gYmFyIC0gMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN1YlZhbCAtPSBsZXNzVmFsICogKGVsZW1lbnRzIC0gMSAtIGJhcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuIC0gZWxtV2lkdGggPiBtYXhXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YlZhbC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFsICs9IHN1YlZhbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuIC09IGVsbVdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfTtcclxuICAgIFJTU1V0aWxzLmNvbWJpbnMgPSBmdW5jdGlvbiAobiwgcikge1xyXG4gICAgICAgIHZhciBtYXhEZW5vbTtcclxuICAgICAgICB2YXIgbWluRGVub207XHJcbiAgICAgICAgaWYgKG4gLSByID4gcikge1xyXG4gICAgICAgICAgICBtaW5EZW5vbSA9IHI7XHJcbiAgICAgICAgICAgIG1heERlbm9tID0gbiAtIHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtaW5EZW5vbSA9IG4gLSByO1xyXG4gICAgICAgICAgICBtYXhEZW5vbSA9IHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YWwgPSAxO1xyXG4gICAgICAgIHZhciBqID0gMTtcclxuICAgICAgICBmb3IgKHZhciBpID0gbjsgaSA+IG1heERlbm9tOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFsICo9IGk7XHJcbiAgICAgICAgICAgIGlmIChqIDw9IG1pbkRlbm9tKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgLz0gajtcclxuICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoKGogPD0gbWluRGVub20pKSB7XHJcbiAgICAgICAgICAgIHZhbCAvPSBqO1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJTU1V0aWxzO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBSU1NVdGlscztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UlNTVXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEJpdEFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29tbW9uL0JpdEFycmF5XCIpO1xyXG52YXIgQml0QXJyYXlCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQml0QXJyYXlCdWlsZGVyKCkge1xyXG4gICAgfVxyXG4gICAgQml0QXJyYXlCdWlsZGVyLmJ1aWxkQml0QXJyYXkgPSBmdW5jdGlvbiAocGFpcnMpIHtcclxuICAgICAgICB2YXIgY2hhck51bWJlciA9IChwYWlycy5sZW5ndGggKiAyKSAtIDE7XHJcbiAgICAgICAgaWYgKHBhaXJzW3BhaXJzLmxlbmd0aCAtIDFdLmdldFJpZ2h0Q2hhcigpID09IG51bGwpIHtcclxuICAgICAgICAgICAgY2hhck51bWJlciAtPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2l6ZSA9IDEyICogY2hhck51bWJlcjtcclxuICAgICAgICB2YXIgYmluYXJ5ID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdChzaXplKTtcclxuICAgICAgICB2YXIgYWNjUG9zID0gMDtcclxuICAgICAgICB2YXIgZmlyc3RQYWlyID0gcGFpcnNbMF07XHJcbiAgICAgICAgdmFyIGZpcnN0VmFsdWUgPSBmaXJzdFBhaXIuZ2V0UmlnaHRDaGFyKCkuZ2V0VmFsdWUoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTE7IGkgPj0gMDsgLS1pKSB7XHJcbiAgICAgICAgICAgIGlmICgoZmlyc3RWYWx1ZSAmICgxIDw8IGkpKSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICBiaW5hcnkuc2V0KGFjY1Bvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWNjUG9zKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcGFpcnMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQYWlyID0gcGFpcnNbaV07XHJcbiAgICAgICAgICAgIHZhciBsZWZ0VmFsdWUgPSBjdXJyZW50UGFpci5nZXRMZWZ0Q2hhcigpLmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxMTsgaiA+PSAwOyAtLWopIHtcclxuICAgICAgICAgICAgICAgIGlmICgobGVmdFZhbHVlICYgKDEgPDwgaikpICE9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBiaW5hcnkuc2V0KGFjY1Bvcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhY2NQb3MrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudFBhaXIuZ2V0UmlnaHRDaGFyKCkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJpZ2h0VmFsdWUgPSBjdXJyZW50UGFpci5nZXRSaWdodENoYXIoKS5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDExOyBqID49IDA7IC0taikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocmlnaHRWYWx1ZSAmICgxIDw8IGopKSAhPSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmFyeS5zZXQoYWNjUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYWNjUG9zKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJpbmFyeTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQml0QXJyYXlCdWlsZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCaXRBcnJheUJ1aWxkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdEFycmF5QnVpbGRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXhwYW5kZWRQYWlyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXhwYW5kZWRQYWlyKGxlZnRDaGFyLCByaWdodENoYXIsIGZpbmRlclBhdHRlciwgbWF5QmVMYXN0KSB7XHJcbiAgICAgICAgdGhpcy5sZWZ0Y2hhciA9IGxlZnRDaGFyO1xyXG4gICAgICAgIHRoaXMucmlnaHRjaGFyID0gcmlnaHRDaGFyO1xyXG4gICAgICAgIHRoaXMuZmluZGVycGF0dGVybiA9IGZpbmRlclBhdHRlcjtcclxuICAgICAgICB0aGlzLm1heWJlTGFzdCA9IG1heUJlTGFzdDtcclxuICAgIH1cclxuICAgIEV4cGFuZGVkUGFpci5wcm90b3R5cGUubWF5QmVMYXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1heWJlTGFzdDtcclxuICAgIH07XHJcbiAgICBFeHBhbmRlZFBhaXIucHJvdG90eXBlLmdldExlZnRDaGFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRjaGFyO1xyXG4gICAgfTtcclxuICAgIEV4cGFuZGVkUGFpci5wcm90b3R5cGUuZ2V0UmlnaHRDaGFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0Y2hhcjtcclxuICAgIH07XHJcbiAgICBFeHBhbmRlZFBhaXIucHJvdG90eXBlLmdldEZpbmRlclBhdHRlcm4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZGVycGF0dGVybjtcclxuICAgIH07XHJcbiAgICBFeHBhbmRlZFBhaXIucHJvdG90eXBlLm11c3RCZUxhc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRjaGFyID09IG51bGw7XHJcbiAgICB9O1xyXG4gICAgRXhwYW5kZWRQYWlyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJ1sgJyArIHRoaXMubGVmdGNoYXIgKyAnLCAnICsgdGhpcy5yaWdodGNoYXIgKyAnIDogJyArICh0aGlzLmZpbmRlcnBhdHRlcm4gPT0gbnVsbCA/IFwibnVsbFwiIDogdGhpcy5maW5kZXJwYXR0ZXJuLmdldFZhbHVlKCkpICsgXCIgXVwiO1xyXG4gICAgfTtcclxuICAgIEV4cGFuZGVkUGFpci5lcXVhbHMgPSBmdW5jdGlvbiAobzEsIG8yKSB7XHJcbiAgICAgICAgaWYgKCEobzEgaW5zdGFuY2VvZiBFeHBhbmRlZFBhaXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEV4cGFuZGVkUGFpci5lcXVhbHNPck51bGwobzEubGVmdGNoYXIsIG8yLmxlZnRjaGFyKSAmJlxyXG4gICAgICAgICAgICBFeHBhbmRlZFBhaXIuZXF1YWxzT3JOdWxsKG8xLnJpZ2h0Y2hhciwgbzIucmlnaHRjaGFyKSAmJlxyXG4gICAgICAgICAgICBFeHBhbmRlZFBhaXIuZXF1YWxzT3JOdWxsKG8xLmZpbmRlcnBhdHRlcm4sIG8yLmZpbmRlcnBhdHRlcm4pO1xyXG4gICAgfTtcclxuICAgIEV4cGFuZGVkUGFpci5lcXVhbHNPck51bGwgPSBmdW5jdGlvbiAobzEsIG8yKSB7XHJcbiAgICAgICAgcmV0dXJuIG8xID09PSBudWxsID8gbzIgPT09IG51bGwgOiBFeHBhbmRlZFBhaXIuZXF1YWxzKG8xLCBvMik7XHJcbiAgICB9O1xyXG4gICAgRXhwYW5kZWRQYWlyLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvL3JldHVybiBFeHBhbmRlZFBhaXIuaGFzaE5vdE51bGwobGVmdENoYXIpIF4gaGFzaE5vdE51bGwocmlnaHRDaGFyKSBeIGhhc2hOb3ROdWxsKGZpbmRlclBhdHRlcm4pO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubGVmdGNoYXIuZ2V0VmFsdWUoKSBeIHRoaXMucmlnaHRjaGFyLmdldFZhbHVlKCkgXiB0aGlzLmZpbmRlcnBhdHRlcm4uZ2V0VmFsdWUoKTtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgLy8gVG8gZG8gLSBSZSBjaGVjayB0aGUgaW1wbGVtZW50YXRpb25cclxuICAgIEV4cGFuZGVkUGFpci5oYXNoTm90TnVsbCA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgcmV0dXJuIG8gPT09IG51bGwgPyAwIDogby5oYXNoQ29kZSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFeHBhbmRlZFBhaXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV4cGFuZGVkUGFpcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXhwYW5kZWRQYWlyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFeHBhbmRlZFJvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV4cGFuZGVkUm93KHBhaXJzLCByb3dOdW1iZXIsIHdhc1JldmVyc2VkKSB7XHJcbiAgICAgICAgdGhpcy5wYWlycyA9IHBhaXJzO1xyXG4gICAgICAgIHRoaXMucm93TnVtYmVyID0gcm93TnVtYmVyO1xyXG4gICAgICAgIHRoaXMud2FzUmV2ZXJzZWQgPSB3YXNSZXZlcnNlZDtcclxuICAgIH1cclxuICAgIEV4cGFuZGVkUm93LnByb3RvdHlwZS5nZXRQYWlycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYWlycztcclxuICAgIH07XHJcbiAgICBFeHBhbmRlZFJvdy5wcm90b3R5cGUuZ2V0Um93TnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvd051bWJlcjtcclxuICAgIH07XHJcbiAgICBFeHBhbmRlZFJvdy5wcm90b3R5cGUuaXNSZXZlcnNlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53YXNSZXZlcnNlZDtcclxuICAgIH07XHJcbiAgICAvLyBjaGVjayBpbXBsZW1lbnRhdGlvblxyXG4gICAgRXhwYW5kZWRSb3cucHJvdG90eXBlLmlzRXF1aXZhbGVudCA9IGZ1bmN0aW9uIChvdGhlclBhaXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tFcXVhbGl0aXR5KHRoaXMsIG90aGVyUGFpcnMpO1xyXG4gICAgfTtcclxuICAgIC8vQE92ZXJyaWRlXHJcbiAgICBFeHBhbmRlZFJvdy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFwieyBcIiArIHRoaXMucGFpcnMgKyBcIiB9XCI7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUd28gcm93cyBhcmUgZXF1YWwgaWYgdGhleSBjb250YWluIHRoZSBzYW1lIHBhaXJzIGluIHRoZSBzYW1lIG9yZGVyLlxyXG4gICAgICovXHJcbiAgICAvL0BPdmVycmlkZVxyXG4gICAgLy8gY2hlY2sgaW1wbGVtZW50YXRpb25cclxuICAgIEV4cGFuZGVkUm93LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobzEsIG8yKSB7XHJcbiAgICAgICAgaWYgKCEobzEgaW5zdGFuY2VvZiBFeHBhbmRlZFJvdykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jaGVja0VxdWFsaXRpdHkobzEsIG8yKSAmJiBvMS53YXNSZXZlcnNlZCA9PT0gbzIud2FzUmV2ZXJzZWQ7XHJcbiAgICB9O1xyXG4gICAgRXhwYW5kZWRSb3cucHJvdG90eXBlLmNoZWNrRXF1YWxpdGl0eSA9IGZ1bmN0aW9uIChwYWlyMSwgcGFpcjIpIHtcclxuICAgICAgICBpZiAoIXBhaXIxIHx8ICFwYWlyMilcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgcGFpcjEuZm9yRWFjaChmdW5jdGlvbiAoZTEsIGkpIHtcclxuICAgICAgICAgICAgcGFpcjIuZm9yRWFjaChmdW5jdGlvbiAoZTIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlMS5nZXRMZWZ0Q2hhcigpLmdldFZhbHVlKCkgPT09IGUyLmdldExlZnRDaGFyKCkuZ2V0VmFsdWUoKSAmJiBlMS5nZXRSaWdodENoYXIoKS5nZXRWYWx1ZSgpID09PSBlMi5nZXRSaWdodENoYXIoKS5nZXRWYWx1ZSgpICYmIGUxLmdldEZpbmRlclBhdHRlcigpLmdldFZhbHVlKCkgPT09IGUyLmdldEZpbmRlclBhdHRlcigpLmdldFZhbHVlKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFeHBhbmRlZFJvdztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXhwYW5kZWRSb3c7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV4cGFuZGVkUm93LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0JhcmNvZGVGb3JtYXRcIik7XHJcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xyXG52YXIgUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vUmVzdWx0XCIpO1xyXG52YXIgTWF0aFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29tbW9uL2RldGVjdG9yL01hdGhVdGlsc1wiKTtcclxudmFyIEFic3RyYWN0UlNTUmVhZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vcnNzL0Fic3RyYWN0UlNTUmVhZGVyXCIpO1xyXG52YXIgRGF0YUNoYXJhY3Rlcl8xID0gcmVxdWlyZShcIi4uLy4uL3Jzcy9EYXRhQ2hhcmFjdGVyXCIpO1xyXG52YXIgRmluZGVyUGF0dGVybl8xID0gcmVxdWlyZShcIi4uLy4uL3Jzcy9GaW5kZXJQYXR0ZXJuXCIpO1xyXG52YXIgUlNTVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9yc3MvUlNTVXRpbHNcIik7XHJcbnZhciBBYnN0cmFjdEV4cGFuZGVkRGVjb2RlckNvbXBsZW1lbnRfMSA9IHJlcXVpcmUoXCIuL2RlY29kZXJzL0Fic3RyYWN0RXhwYW5kZWREZWNvZGVyQ29tcGxlbWVudFwiKTtcclxudmFyIEV4cGFuZGVkUGFpcl8xID0gcmVxdWlyZShcIi4vRXhwYW5kZWRQYWlyXCIpO1xyXG52YXIgRXhwYW5kZWRSb3dfMSA9IHJlcXVpcmUoXCIuL0V4cGFuZGVkUm93XCIpO1xyXG52YXIgQml0QXJyYXlCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi9CaXRBcnJheUJ1aWxkZXJcIik7XHJcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL1N5c3RlbVwiKTtcclxuLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XHJcbi8vIGltcG9ydCBqYXZhLnV0aWwuSXRlcmF0b3I7XHJcbi8vIGltcG9ydCBqYXZhLnV0aWwuTGlzdDtcclxuLy8gaW1wb3J0IGphdmEudXRpbC5NYXA7XHJcbi8vIGltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbnM7XHJcbnZhciBSU1NFeHBhbmRlZFJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhSU1NFeHBhbmRlZFJlYWRlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJTU0V4cGFuZGVkUmVhZGVyKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnBhaXJzID0gbmV3IEFycmF5KFJTU0V4cGFuZGVkUmVhZGVyLk1BWF9QQUlSUyk7XHJcbiAgICAgICAgX3RoaXMucm93cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIF90aGlzLnN0YXJ0RW5kID0gWzJdO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFJTU0V4cGFuZGVkUmVhZGVyLnByb3RvdHlwZS5kZWNvZGVSb3cgPSBmdW5jdGlvbiAocm93TnVtYmVyLCByb3csIGhpbnRzKSB7XHJcbiAgICAgICAgLy8gUm93cyBjYW4gc3RhcnQgd2l0aCBldmVuIHBhdHRlcm4gaW4gY2FzZSBpbiBwcmV2IHJvd3MgdGhlcmUgd2hlcmUgb2RkIG51bWJlciBvZiBwYXR0ZXJzLlxyXG4gICAgICAgIC8vIFNvIGxldHMgdHJ5IHR3aWNlXHJcbiAgICAgICAgLy90aGlzLnBhaXJzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5wYWlycy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnRGcm9tRXZlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSU1NFeHBhbmRlZFJlYWRlci5jb25zdHJ1Y3RSZXN1bHQodGhpcy5kZWNvZGVSb3cycGFpcnMocm93TnVtYmVyLCByb3cpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gT0tcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLnN0YXJ0RnJvbUV2ZW4gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBSU1NFeHBhbmRlZFJlYWRlci5jb25zdHJ1Y3RSZXN1bHQodGhpcy5kZWNvZGVSb3cycGFpcnMocm93TnVtYmVyLCByb3cpKTtcclxuICAgIH07XHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wYWlycy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMucm93cy5sZW5ndGggPSAwO1xyXG4gICAgfTtcclxuICAgIC8vIE5vdCBwcml2YXRlIGZvciB0ZXN0aW5nXHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5wcm90b3R5cGUuZGVjb2RlUm93MnBhaXJzID0gZnVuY3Rpb24gKHJvd051bWJlciwgcm93KSB7XHJcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFpcnMucHVzaCh0aGlzLnJldHJpZXZlTmV4dFBhaXIocm93LCB0aGlzLnBhaXJzLCByb3dOdW1iZXIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoTm90Rm91bmRFeGNlcHRpb24pIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYWlycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGV4aXQgdGhpcyBsb29wIHdoZW4gcmV0cmlldmVOZXh0UGFpcigpIGZhaWxzIGFuZCB0aHJvd3NcclxuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IHZlcmlmeSBzZXF1ZW5jZSBvZiBmaW5kZXIgcGF0dGVybnMgYXMgaW4gY2hlY2tQYWlyU2VxdWVuY2UoKVxyXG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2hlY2tzdW0oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYWlycztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRyeVN0YWNrZWREZWNvZGU7XHJcbiAgICAgICAgaWYgKHRoaXMucm93cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdHJ5U3RhY2tlZERlY29kZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0cnlTdGFja2VkRGVjb2RlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vbGV0IHRyeVN0YWNrZWREZWNvZGUgPSAhdGhpcy5yb3dzLmlzRW1wdHkoKTtcclxuICAgICAgICB0aGlzLnN0b3JlUm93KHJvd051bWJlciwgZmFsc2UpOyAvLyBUT0RPOiBkZWFsIHdpdGggcmV2ZXJzZWQgcm93c1xyXG4gICAgICAgIGlmICh0cnlTdGFja2VkRGVjb2RlKSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGltYWdlIGlzIDE4MC1yb3RhdGVkLCB0aGVuIHJvd3MgYXJlIHNvcnRlZCBpbiB3cm9uZyBkaXJlY3Rpb24uXHJcbiAgICAgICAgICAgIC8vIFRyeSB0d2ljZSB3aXRoIGJvdGggdGhlIGRpcmVjdGlvbnMuXHJcbiAgICAgICAgICAgIHZhciBwcyA9IHRoaXMuY2hlY2tSb3dzQm9vbGVhbihmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmIChwcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHMgPSB0aGlzLmNoZWNrUm93c0Jvb2xlYW4odHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChwcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgfTtcclxuICAgIC8vTmVlZCB0byBWZXJpZnlcclxuICAgIFJTU0V4cGFuZGVkUmVhZGVyLnByb3RvdHlwZS5jaGVja1Jvd3NCb29sZWFuID0gZnVuY3Rpb24gKHJldmVyc2UpIHtcclxuICAgICAgICAvLyBMaW1pdCBudW1iZXIgb2Ygcm93cyB3ZSBhcmUgY2hlY2tpbmdcclxuICAgICAgICAvLyBXZSB1c2UgcmVjdXJzaXZlIGFsZ29yaXRobSB3aXRoIHB1cmUgY29tcGxleGl0eSBhbmQgZG9uJ3Qgd2FudCBpdCB0byB0YWtlIGZvcmV2ZXJcclxuICAgICAgICAvLyBTdGFja2VkIGJhcmNvZGUgY2FuIGhhdmUgdXAgdG8gMTEgcm93cywgc28gMjUgc2VlbXMgcmVhc29uYWJsZSBlbm91Z2hcclxuICAgICAgICBpZiAodGhpcy5yb3dzLmxlbmd0aCA+IDI1KSB7XHJcbiAgICAgICAgICAgIHRoaXMucm93cy5sZW5ndGggPSAwOyAvLyBXZSB3aWxsIG5ldmVyIGhhdmUgYSBjaGFuY2UgdG8gZ2V0IHJlc3VsdCwgc28gY2xlYXIgaXRcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcclxuICAgICAgICBpZiAocmV2ZXJzZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJvd3MgPSB0aGlzLnJvd3MucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAvL0NvbGxlY3Rpb25zLnJldmVyc2UodGhpcy5yb3dzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBzID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBwcyA9IHRoaXMuY2hlY2tSb3dzKG5ldyBBcnJheSgpLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gT0tcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXZlcnNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm93cyA9IHRoaXMucm93cy5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIC8vQ29sbGVjdGlvbnMucmV2ZXJzZSh0aGlzLnJvd3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHM7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJ5IHRvIGNvbnN0cnVjdCBhIHZhbGlkIHJvd3Mgc2VxdWVuY2VcclxuICAgIC8vIFJlY3Vyc2lvbiBpcyB1c2VkIHRvIGltcGxlbWVudCBiYWNrdHJhY2tpbmdcclxuICAgIFJTU0V4cGFuZGVkUmVhZGVyLnByb3RvdHlwZS5jaGVja1Jvd3MgPSBmdW5jdGlvbiAoY29sbGVjdGVkUm93cywgY3VycmVudFJvdykge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBjdXJyZW50Um93OyBpIDwgdGhpcy5yb3dzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbaV07XHJcbiAgICAgICAgICAgIHRoaXMucGFpcnMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGNvbGxlY3RlZFJvd3NfMSA9IF9fdmFsdWVzKGNvbGxlY3RlZFJvd3MpLCBjb2xsZWN0ZWRSb3dzXzFfMSA9IGNvbGxlY3RlZFJvd3NfMS5uZXh0KCk7ICFjb2xsZWN0ZWRSb3dzXzFfMS5kb25lOyBjb2xsZWN0ZWRSb3dzXzFfMSA9IGNvbGxlY3RlZFJvd3NfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sbGVjdGVkUm93ID0gY29sbGVjdGVkUm93c18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWlycy5wdXNoKGNvbGxlY3RlZFJvdy5nZXRQYWlycygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxlY3RlZFJvd3NfMV8xICYmICFjb2xsZWN0ZWRSb3dzXzFfMS5kb25lICYmIChfYSA9IGNvbGxlY3RlZFJvd3NfMS5yZXR1cm4pKSBfYS5jYWxsKGNvbGxlY3RlZFJvd3NfMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYWlycy5wdXNoKHJvdy5nZXRQYWlycygpKTtcclxuICAgICAgICAgICAgaWYgKCFSU1NFeHBhbmRlZFJlYWRlci5pc1ZhbGlkU2VxdWVuY2UodGhpcy5wYWlycykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrQ2hlY2tzdW0oKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFpcnM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJzID0gbmV3IEFycmF5KGNvbGxlY3RlZFJvd3MpO1xyXG4gICAgICAgICAgICBycy5wdXNoKHJvdyk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpb246IHRyeSB0byBhZGQgbW9yZSByb3dzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGVja1Jvd3MocnMsIGkgKyAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZmFpbGVkLCB0cnkgdGhlIG5leHQgY2FuZGlkYXRlXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gV2hldGhlciB0aGUgcGFpcnMgZm9ybSBhIHZhbGlkIGZpbmQgcGF0dGVybiBzZXF1ZW5jZSxcclxuICAgIC8vIGVpdGhlciBjb21wbGV0ZSBvciBhIHByZWZpeFxyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuaXNWYWxpZFNlcXVlbmNlID0gZnVuY3Rpb24gKHBhaXJzKSB7XHJcbiAgICAgICAgdmFyIGVfMiwgX2E7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUVEVSTl9TRVFVRU5DRVMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VxdWVuY2UgPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChwYWlycy5sZW5ndGggPiBzZXF1ZW5jZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzdG9wXzEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYWlycy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYWlyc1tqXS5nZXRGaW5kZXJQYXR0ZXJuKCkuZ2V0VmFsdWUoKSAhPSBzZXF1ZW5jZVtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wXzEgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0b3BfMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIucHJvdG90eXBlLnN0b3JlUm93ID0gZnVuY3Rpb24gKHJvd051bWJlciwgd2FzUmV2ZXJzZWQpIHtcclxuICAgICAgICAvLyBEaXNjYXJkIGlmIGR1cGxpY2F0ZSBhYm92ZSBvciBiZWxvdzsgb3RoZXJ3aXNlIGluc2VydCBpbiBvcmRlciBieSByb3cgbnVtYmVyLlxyXG4gICAgICAgIHZhciBpbnNlcnRQb3MgPSAwO1xyXG4gICAgICAgIHZhciBwcmV2SXNTYW1lID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIG5leHRJc1NhbWUgPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAoaW5zZXJ0UG9zIDwgdGhpcy5yb3dzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgZXJvdyA9IHRoaXMucm93c1tpbnNlcnRQb3NdO1xyXG4gICAgICAgICAgICBpZiAoZXJvdy5nZXRSb3dOdW1iZXIoKSA+IHJvd051bWJlcikge1xyXG4gICAgICAgICAgICAgICAgbmV4dElzU2FtZSA9IGVyb3cuaXNFcXVpdmFsZW50KHRoaXMucGFpcnMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldklzU2FtZSA9IGVyb3cuaXNFcXVpdmFsZW50KHRoaXMucGFpcnMpO1xyXG4gICAgICAgICAgICBpbnNlcnRQb3MrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5leHRJc1NhbWUgfHwgcHJldklzU2FtZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdoZW4gdGhlIHJvdyB3YXMgcGFydGlhbGx5IGRlY29kZWQgKGUuZy4gMiBwYWlycyBmb3VuZCBpbnN0ZWFkIG9mIDMpLFxyXG4gICAgICAgIC8vIGl0IHdpbGwgcHJldmVudCB1cyBmcm9tIGRldGVjdGluZyB0aGUgYmFyY29kZS5cclxuICAgICAgICAvLyBUcnkgdG8gbWVyZ2UgcGFydGlhbCByb3dzXHJcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgcm93IGlzIHBhcnQgb2YgYW4gYWxscmVhZHkgZGV0ZWN0ZWQgcm93XHJcbiAgICAgICAgaWYgKFJTU0V4cGFuZGVkUmVhZGVyLmlzUGFydGlhbFJvdyh0aGlzLnBhaXJzLCB0aGlzLnJvd3MpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb3dzLnB1c2goaW5zZXJ0UG9zLCBuZXcgRXhwYW5kZWRSb3dfMS5kZWZhdWx0KHRoaXMucGFpcnMsIHJvd051bWJlciwgd2FzUmV2ZXJzZWQpKTtcclxuICAgICAgICB0aGlzLnJlbW92ZVBhcnRpYWxSb3dzKHRoaXMucGFpcnMsIHRoaXMucm93cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVtb3ZlIGFsbCB0aGUgcm93cyB0aGF0IGNvbnRhaW5zIG9ubHkgc3BlY2lmaWVkIHBhaXJzXHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5wcm90b3R5cGUucmVtb3ZlUGFydGlhbFJvd3MgPSBmdW5jdGlvbiAocGFpcnMsIHJvd3MpIHtcclxuICAgICAgICB2YXIgZV8zLCBfYSwgZV80LCBfYiwgZV81LCBfYztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBmb3IgKEl0ZXJhdG9yPEV4cGFuZGVkUm93PiBpdGVyYXRvciA9IHJvd3MuaXRlcmF0b3IoKTsgaXRlcmF0b3IuaGFzTmV4dCgpOykge1xyXG4gICAgICAgICAgICAvLyAgIEV4cGFuZGVkUm93IHIgPSBpdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgICAgIC8vICAgaWYgKHIuZ2V0UGFpcnMoKS5zaXplKCkgPT0gcGFpcnMuc2l6ZSgpKSB7XHJcbiAgICAgICAgICAgIC8vICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgLy8gICB9XHJcbiAgICAgICAgICAgIC8vICAgYm9vbGVhbiBhbGxGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vICAgZm9yIChFeHBhbmRlZFBhaXIgcCA6IHIuZ2V0UGFpcnMoKSkge1xyXG4gICAgICAgICAgICAvLyAgICAgYm9vbGVhbiBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyAgICAgZm9yIChFeHBhbmRlZFBhaXIgcHAgOiBwYWlycykge1xyXG4gICAgICAgICAgICAvLyAgICAgICBpZiAocC5lcXVhbHMocHApKSB7XHJcbiAgICAgICAgICAgIC8vICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvLyAgICAgICB9XHJcbiAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgIC8vICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgICAgIC8vICAgICAgIGFsbEZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgICAgICAvLyAgIH1cclxuICAgICAgICAgICAgLy8gICBpZiAoYWxsRm91bmQpIHtcclxuICAgICAgICAgICAgLy8gICAgIC8vICdwYWlycycgY29udGFpbnMgYWxsIHRoZSBwYWlycyBmcm9tIHRoZSByb3cgJ3InXHJcbiAgICAgICAgICAgIC8vICAgICBpdGVyYXRvci5yZW1vdmUoKTtcclxuICAgICAgICAgICAgLy8gICB9XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgcm93c18xID0gX192YWx1ZXMocm93cyksIHJvd3NfMV8xID0gcm93c18xLm5leHQoKTsgIXJvd3NfMV8xLmRvbmU7IHJvd3NfMV8xID0gcm93c18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IHJvd3NfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJvdy5nZXRQYWlycygpLmxlbmd0aCA9PT0gcGFpcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgYWxsRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IF9fdmFsdWVzKHJvdy5nZXRQYWlycygpKSwgX2UgPSBfZC5uZXh0KCk7ICFfZS5kb25lOyBfZSA9IF9kLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IF9lLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHBhaXJzXzEgPSBfX3ZhbHVlcyhwYWlycyksIHBhaXJzXzFfMSA9IHBhaXJzXzEubmV4dCgpOyAhcGFpcnNfMV8xLmRvbmU7IHBhaXJzXzFfMSA9IHBhaXJzXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBwID0gcGFpcnNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChFeHBhbmRlZFBhaXJfMS5kZWZhdWx0LmVxdWFscyhwLCBwcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfNV8xKSB7IGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWlyc18xXzEgJiYgIXBhaXJzXzFfMS5kb25lICYmIChfYyA9IHBhaXJzXzEucmV0dXJuKSkgX2MuY2FsbChwYWlyc18xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxGb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZSAmJiAhX2UuZG9uZSAmJiAoX2IgPSBfZC5yZXR1cm4pKSBfYi5jYWxsKF9kKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocm93c18xXzEgJiYgIXJvd3NfMV8xLmRvbmUgJiYgKF9hID0gcm93c18xLnJldHVybikpIF9hLmNhbGwocm93c18xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdHJ1ZSB3aGVuIG9uZSBvZiB0aGUgcm93cyBhbHJlYWR5IGNvbnRhaW5zIGFsbCB0aGUgcGFpcnNcclxuICAgIFJTU0V4cGFuZGVkUmVhZGVyLmlzUGFydGlhbFJvdyA9IGZ1bmN0aW9uIChwYWlycywgcm93cykge1xyXG4gICAgICAgIHZhciBlXzYsIF9hLCBlXzcsIF9iLCBlXzgsIF9jO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHJvd3NfMiA9IF9fdmFsdWVzKHJvd3MpLCByb3dzXzJfMSA9IHJvd3NfMi5uZXh0KCk7ICFyb3dzXzJfMS5kb25lOyByb3dzXzJfMSA9IHJvd3NfMi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciByID0gcm93c18yXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWxsRm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwYWlyc18yID0gX192YWx1ZXMocGFpcnMpLCBwYWlyc18yXzEgPSBwYWlyc18yLm5leHQoKTsgIXBhaXJzXzJfMS5kb25lOyBwYWlyc18yXzEgPSBwYWlyc18yLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBhaXJzXzJfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IF9fdmFsdWVzKHIuZ2V0UGFpcnMoKSksIF9lID0gX2QubmV4dCgpOyAhX2UuZG9uZTsgX2UgPSBfZC5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHAgPSBfZS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5lcXVhbHMocHApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzhfMSkgeyBlXzggPSB7IGVycm9yOiBlXzhfMSB9OyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2UgJiYgIV9lLmRvbmUgJiYgKF9jID0gX2QucmV0dXJuKSkgX2MuY2FsbChfZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOCkgdGhyb3cgZV84LmVycm9yOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfN18xKSB7IGVfNyA9IHsgZXJyb3I6IGVfN18xIH07IH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWlyc18yXzEgJiYgIXBhaXJzXzJfMS5kb25lICYmIChfYiA9IHBhaXJzXzIucmV0dXJuKSkgX2IuY2FsbChwYWlyc18yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzcpIHRocm93IGVfNy5lcnJvcjsgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFsbEZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHJvdyAncicgY29udGFpbiBhbGwgdGhlIHBhaXJzIGZyb20gJ3BhaXJzJ1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzZfMSkgeyBlXzYgPSB7IGVycm9yOiBlXzZfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocm93c18yXzEgJiYgIXJvd3NfMl8xLmRvbmUgJiYgKF9hID0gcm93c18yLnJldHVybikpIF9hLmNhbGwocm93c18yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvLyBPbmx5IHVzZWQgZm9yIHVuaXQgdGVzdGluZ1xyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIucHJvdG90eXBlLmdldFJvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm93cztcclxuICAgIH07XHJcbiAgICAvLyBOb3QgcHJpdmF0ZSBmb3IgdW5pdCB0ZXN0aW5nXHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5jb25zdHJ1Y3RSZXN1bHQgPSBmdW5jdGlvbiAocGFpcnMpIHtcclxuICAgICAgICB2YXIgYmluYXJ5ID0gQml0QXJyYXlCdWlsZGVyXzEuZGVmYXVsdC5idWlsZEJpdEFycmF5KHBhaXJzKTtcclxuICAgICAgICB2YXIgZGVjb2RlciA9IEFic3RyYWN0RXhwYW5kZWREZWNvZGVyQ29tcGxlbWVudF8xLmNyZWF0ZURlY29kZXIoYmluYXJ5KTtcclxuICAgICAgICB2YXIgcmVzdWx0aW5nU3RyaW5nID0gZGVjb2Rlci5wYXJzZUluZm9ybWF0aW9uKCk7XHJcbiAgICAgICAgdmFyIGZpcnN0UG9pbnRzID0gcGFpcnNbMF0uZ2V0RmluZGVyUGF0dGVybigpLmdldFJlc3VsdFBvaW50cygpO1xyXG4gICAgICAgIHZhciBsYXN0UG9pbnRzID0gcGFpcnNbcGFpcnMubGVuZ3RoIC0gMV0uZ2V0RmluZGVyUGF0dGVybigpLmdldFJlc3VsdFBvaW50cygpO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbZmlyc3RQb2ludHNbMF0sIGZpcnN0UG9pbnRzWzFdLCBsYXN0UG9pbnRzWzBdLCBsYXN0UG9pbnRzWzFdXTtcclxuICAgICAgICByZXR1cm4gbmV3IFJlc3VsdF8xLmRlZmF1bHQocmVzdWx0aW5nU3RyaW5nLCBudWxsLCBudWxsLCBwb2ludHMsIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlJTU19FWFBBTkRFRCwgbnVsbCk7XHJcbiAgICB9O1xyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIucHJvdG90eXBlLmNoZWNrQ2hlY2tzdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZpcnN0UGFpciA9IHRoaXMucGFpcnMuZ2V0KDApO1xyXG4gICAgICAgIHZhciBjaGVja0NoYXJhY3RlciA9IGZpcnN0UGFpci5nZXRMZWZ0Q2hhcigpO1xyXG4gICAgICAgIHZhciBmaXJzdENoYXJhY3RlciA9IGZpcnN0UGFpci5nZXRSaWdodENoYXIoKTtcclxuICAgICAgICBpZiAoZmlyc3RDaGFyYWN0ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGVja3N1bSA9IGZpcnN0Q2hhcmFjdGVyLmdldENoZWNrc3VtUG9ydGlvbigpO1xyXG4gICAgICAgIHZhciBzID0gMjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMucGFpcnMuc2l6ZSgpOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRQYWlyID0gdGhpcy5wYWlycy5nZXQoaSk7XHJcbiAgICAgICAgICAgIGNoZWNrc3VtICs9IGN1cnJlbnRQYWlyLmdldExlZnRDaGFyKCkuZ2V0Q2hlY2tzdW1Qb3J0aW9uKCk7XHJcbiAgICAgICAgICAgIHMrKztcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRSaWdodENoYXIgPSBjdXJyZW50UGFpci5nZXRSaWdodENoYXIoKTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRSaWdodENoYXIgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY2hlY2tzdW0gKz0gY3VycmVudFJpZ2h0Q2hhci5nZXRDaGVja3N1bVBvcnRpb24oKTtcclxuICAgICAgICAgICAgICAgIHMrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVja3N1bSAlPSAyMTE7XHJcbiAgICAgICAgdmFyIGNoZWNrQ2hhcmFjdGVyVmFsdWUgPSAyMTEgKiAocyAtIDQpICsgY2hlY2tzdW07XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrQ2hhcmFjdGVyVmFsdWUgPT0gY2hlY2tDaGFyYWN0ZXIuZ2V0VmFsdWUoKTtcclxuICAgIH07XHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5nZXROZXh0U2Vjb25kQmFyID0gZnVuY3Rpb24gKHJvdywgaW5pdGlhbFBvcykge1xyXG4gICAgICAgIHZhciBjdXJyZW50UG9zO1xyXG4gICAgICAgIGlmIChyb3cuZ2V0KGluaXRpYWxQb3MpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgPSByb3cuZ2V0TmV4dFVuc2V0KGluaXRpYWxQb3MpO1xyXG4gICAgICAgICAgICBjdXJyZW50UG9zID0gcm93LmdldE5leHRTZXQoY3VycmVudFBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50UG9zID0gcm93LmdldE5leHRTZXQoaW5pdGlhbFBvcyk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQb3MgPSByb3cuZ2V0TmV4dFVuc2V0KGN1cnJlbnRQb3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudFBvcztcclxuICAgIH07XHJcbiAgICAvLyBub3QgcHJpdmF0ZSBmb3IgdGVzdGluZ1xyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIucHJvdG90eXBlLnJldHJpZXZlTmV4dFBhaXIgPSBmdW5jdGlvbiAocm93LCBwcmV2aW91c1BhaXJzLCByb3dOdW1iZXIpIHtcclxuICAgICAgICB2YXIgaXNPZGRQYXR0ZXJuID0gcHJldmlvdXNQYWlycy5sZW5ndGggJSAyID09IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRGcm9tRXZlbikge1xyXG4gICAgICAgICAgICBpc09kZFBhdHRlcm4gPSAhaXNPZGRQYXR0ZXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGF0dGVybjtcclxuICAgICAgICB2YXIga2VlcEZpbmRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBmb3JjZWRPZmZzZXQgPSAtMTtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHRoaXMuZmluZE5leHRQYWlyKHJvdywgcHJldmlvdXNQYWlycywgZm9yY2VkT2Zmc2V0KTtcclxuICAgICAgICAgICAgcGF0dGVybiA9IHRoaXMucGFyc2VGb3VuZEZpbmRlclBhdHRlcm4ocm93LCByb3dOdW1iZXIsIGlzT2RkUGF0dGVybik7XHJcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlZE9mZnNldCA9IFJTU0V4cGFuZGVkUmVhZGVyLmdldE5leHRTZWNvbmRCYXIocm93LCB0aGlzLnN0YXJ0RW5kWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGtlZXBGaW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChrZWVwRmluZGluZyk7XHJcbiAgICAgICAgLy8gV2hlbiBzdGFja2VkIHN5bWJvbCBpcyBzcGxpdCBvdmVyIG11bHRpcGxlIHJvd3MsIHRoZXJlJ3Mgbm8gd2F5IHRvIGd1ZXNzIGlmIHRoaXMgcGFpciBjYW4gYmUgbGFzdCBvciBub3QuXHJcbiAgICAgICAgLy8gYm9vbGVhbiBtYXlCZUxhc3QgPSBjaGVja1BhaXJTZXF1ZW5jZShwcmV2aW91c1BhaXJzLCBwYXR0ZXJuKTtcclxuICAgICAgICB2YXIgbGVmdENoYXIgPSB0aGlzLmRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIHRydWUpO1xyXG4gICAgICAgIGlmICghdGhpcy5pc0VtcHR5UGFpcihwcmV2aW91c1BhaXJzKSAmJiBwcmV2aW91c1BhaXJzW3ByZXZpb3VzUGFpcnMubGVuZ3RoIC0gMV0ubXVzdEJlTGFzdCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJpZ2h0Q2hhcjtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByaWdodENoYXIgPSB0aGlzLmRlY29kZURhdGFDaGFyYWN0ZXIocm93LCBwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmlnaHRDaGFyID0gbnVsbDtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRXhwYW5kZWRQYWlyXzEuZGVmYXVsdChsZWZ0Q2hhciwgcmlnaHRDaGFyLCBwYXR0ZXJuLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5wcm90b3R5cGUuaXNFbXB0eVBhaXIgPSBmdW5jdGlvbiAocGFpcnMpIHtcclxuICAgICAgICBpZiAocGFpcnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIucHJvdG90eXBlLmZpbmROZXh0UGFpciA9IGZ1bmN0aW9uIChyb3csIHByZXZpb3VzUGFpcnMsIGZvcmNlZE9mZnNldCkge1xyXG4gICAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcclxuICAgICAgICBjb3VudGVyc1swXSA9IDA7XHJcbiAgICAgICAgY291bnRlcnNbMV0gPSAwO1xyXG4gICAgICAgIGNvdW50ZXJzWzJdID0gMDtcclxuICAgICAgICBjb3VudGVyc1szXSA9IDA7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gcm93LmdldFNpemUoKTtcclxuICAgICAgICB2YXIgcm93T2Zmc2V0O1xyXG4gICAgICAgIGlmIChmb3JjZWRPZmZzZXQgPj0gMCkge1xyXG4gICAgICAgICAgICByb3dPZmZzZXQgPSBmb3JjZWRPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNFbXB0eVBhaXIocHJldmlvdXNQYWlycykpIHtcclxuICAgICAgICAgICAgcm93T2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBsYXN0UGFpciA9IHByZXZpb3VzUGFpcnNbcHJldmlvdXNQYWlycy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgcm93T2Zmc2V0ID0gbGFzdFBhaXIuZ2V0RmluZGVyUGF0dGVybigpLmdldFN0YXJ0RW5kKClbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZWFyY2hpbmdFdmVuUGFpciA9IHByZXZpb3VzUGFpcnMubGVuZ3RoICUgMiAhPSAwO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0RnJvbUV2ZW4pIHtcclxuICAgICAgICAgICAgc2VhcmNoaW5nRXZlblBhaXIgPSAhc2VhcmNoaW5nRXZlblBhaXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpc1doaXRlID0gZmFsc2U7XHJcbiAgICAgICAgd2hpbGUgKHJvd09mZnNldCA8IHdpZHRoKSB7XHJcbiAgICAgICAgICAgIGlzV2hpdGUgPSAhcm93LmdldChyb3dPZmZzZXQpO1xyXG4gICAgICAgICAgICBpZiAoIWlzV2hpdGUpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJvd09mZnNldCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY291bnRlclBvc2l0aW9uID0gMDtcclxuICAgICAgICB2YXIgcGF0dGVyblN0YXJ0ID0gcm93T2Zmc2V0O1xyXG4gICAgICAgIGZvciAodmFyIHggPSByb3dPZmZzZXQ7IHggPCB3aWR0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGlmIChyb3cuZ2V0KHgpICE9IGlzV2hpdGUpIHtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT0gMykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2hpbmdFdmVuUGFpcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5yZXZlcnNlQ291bnRlcnMoY291bnRlcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoUlNTRXhwYW5kZWRSZWFkZXIuaXNGaW5kZXJQYXR0ZXJuKGNvdW50ZXJzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RW5kWzBdID0gcGF0dGVyblN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RW5kWzFdID0geDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoaW5nRXZlblBhaXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIucmV2ZXJzZUNvdW50ZXJzKGNvdW50ZXJzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbMF0gPSBjb3VudGVyc1syXTtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1sxXSA9IGNvdW50ZXJzWzNdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzWzJdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1szXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5yZXZlcnNlQ291bnRlcnMgPSBmdW5jdGlvbiAoY291bnRlcnMpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gY291bnRlcnMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoIC8gMjsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciB0bXAgPSBjb3VudGVyc1tpXTtcclxuICAgICAgICAgICAgY291bnRlcnNbaV0gPSBjb3VudGVyc1tsZW5ndGggLSBpIC0gMV07XHJcbiAgICAgICAgICAgIGNvdW50ZXJzW2xlbmd0aCAtIGkgLSAxXSA9IHRtcDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIucHJvdG90eXBlLnBhcnNlRm91bmRGaW5kZXJQYXR0ZXJuID0gZnVuY3Rpb24gKHJvdywgcm93TnVtYmVyLCBvZGRQYXR0ZXJuKSB7XHJcbiAgICAgICAgLy8gQWN0dWFsbHkgd2UgZm91bmQgZWxlbWVudHMgMi01LlxyXG4gICAgICAgIHZhciBmaXJzdENvdW50ZXI7XHJcbiAgICAgICAgdmFyIHN0YXJ0O1xyXG4gICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgaWYgKG9kZFBhdHRlcm4pIHtcclxuICAgICAgICAgICAgLy8gSWYgcGF0dGVybiBudW1iZXIgaXMgb2RkLCB3ZSBuZWVkIHRvIGxvY2F0ZSBlbGVtZW50IDEgKmJlZm9yZSogdGhlIGN1cnJlbnQgYmxvY2suXHJcbiAgICAgICAgICAgIHZhciBmaXJzdEVsZW1lbnRTdGFydCA9IHRoaXMuc3RhcnRFbmRbMF0gLSAxO1xyXG4gICAgICAgICAgICAvLyBMb2NhdGUgZWxlbWVudCAxXHJcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdEVsZW1lbnRTdGFydCA+PSAwICYmICFyb3cuZ2V0KGZpcnN0RWxlbWVudFN0YXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50U3RhcnQtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaXJzdEVsZW1lbnRTdGFydCsrO1xyXG4gICAgICAgICAgICBmaXJzdENvdW50ZXIgPSB0aGlzLnN0YXJ0RW5kWzBdIC0gZmlyc3RFbGVtZW50U3RhcnQ7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gZmlyc3RFbGVtZW50U3RhcnQ7XHJcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuc3RhcnRFbmRbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJZiBwYXR0ZXJuIG51bWJlciBpcyBldmVuLCB0aGUgcGF0dGVybiBpcyByZXZlcnNlZCwgc28gd2UgbmVlZCB0byBsb2NhdGUgZWxlbWVudCAxICphZnRlciogdGhlIGN1cnJlbnQgYmxvY2suXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5zdGFydEVuZFswXTtcclxuICAgICAgICAgICAgZW5kID0gcm93LmdldE5leHRVbnNldCh0aGlzLnN0YXJ0RW5kWzFdICsgMSk7XHJcbiAgICAgICAgICAgIGZpcnN0Q291bnRlciA9IGVuZCAtIHRoaXMuc3RhcnRFbmRbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1ha2UgJ2NvdW50ZXJzJyBob2xkIDEtNFxyXG4gICAgICAgIHZhciBjb3VudGVycyA9IHRoaXMuZ2V0RGVjb2RlRmluZGVyQ291bnRlcnMoKTtcclxuICAgICAgICBTeXN0ZW1fMS5kZWZhdWx0LmFycmF5Y29weShjb3VudGVycywgMCwgY291bnRlcnMsIDEsIGNvdW50ZXJzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIGNvdW50ZXJzWzBdID0gZmlyc3RDb3VudGVyO1xyXG4gICAgICAgIHZhciB2YWx1ZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucGFyc2VGaW5kZXJWYWx1ZShjb3VudGVycywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVFRFUk5TKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3JldHVybiBuZXcgRmluZGVyUGF0dGVybih2YWx1ZSwgbmV3IGludFtdIHsgc3RhcnQsIGVuZCB9LCBzdGFydCwgZW5kLCByb3dOdW1iZXJ9KTtcclxuICAgICAgICByZXR1cm4gbmV3IEZpbmRlclBhdHRlcm5fMS5kZWZhdWx0KHZhbHVlLCBbc3RhcnQsIGVuZF0sIHN0YXJ0LCBlbmQsIHJvd051bWJlcik7XHJcbiAgICB9O1xyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIucHJvdG90eXBlLmRlY29kZURhdGFDaGFyYWN0ZXIgPSBmdW5jdGlvbiAocm93LCBwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIGxlZnRDaGFyKSB7XHJcbiAgICAgICAgdmFyIGNvdW50ZXJzID0gdGhpcy5nZXREYXRhQ2hhcmFjdGVyQ291bnRlcnMoKTtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNvdW50ZXJzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGNvdW50ZXJzW3hdID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlZnRDaGFyKSB7XHJcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLnJlY29yZFBhdHRlcm5JblJldmVyc2Uocm93LCBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMF0sIGNvdW50ZXJzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIFJTU0V4cGFuZGVkUmVhZGVyLnJlY29yZFBhdHRlcm4ocm93LCBwYXR0ZXJuLmdldFN0YXJ0RW5kKClbMV0sIGNvdW50ZXJzKTtcclxuICAgICAgICAgICAgLy8gcmV2ZXJzZSBpdFxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IGNvdW50ZXJzLmxlbmd0aCAtIDE7IGkgPCBqOyBpKyssIGotLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBjb3VudGVyc1tpXTtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2ldID0gY291bnRlcnNbal07XHJcbiAgICAgICAgICAgICAgICBjb3VudGVyc1tqXSA9IHRlbXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IC8vY291bnRlcnNbXSBoYXMgdGhlIHBpeGVscyBvZiB0aGUgbW9kdWxlXHJcbiAgICAgICAgdmFyIG51bU1vZHVsZXMgPSAxNzsgLy9sZWZ0IGFuZCByaWdodCBkYXRhIGNoYXJhY3RlcnMgaGF2ZSBhbGwgdGhlIHNhbWUgbGVuZ3RoXHJcbiAgICAgICAgdmFyIGVsZW1lbnRXaWR0aCA9IE1hdGhVdGlsc18xLmRlZmF1bHQuc3VtKG5ldyBJbnQzMkFycmF5KGNvdW50ZXJzKSkgLyBudW1Nb2R1bGVzO1xyXG4gICAgICAgIC8vIFNhbml0eSBjaGVjazogZWxlbWVudCB3aWR0aCBmb3IgcGF0dGVybiBhbmQgdGhlIGNoYXJhY3RlciBzaG91bGQgbWF0Y2hcclxuICAgICAgICB2YXIgZXhwZWN0ZWRFbGVtZW50V2lkdGggPSAocGF0dGVybi5nZXRTdGFydEVuZCgpWzFdIC0gcGF0dGVybi5nZXRTdGFydEVuZCgpWzBdKSAvIDE1LjA7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGVsZW1lbnRXaWR0aCAtIGV4cGVjdGVkRWxlbWVudFdpZHRoKSAvIGV4cGVjdGVkRWxlbWVudFdpZHRoID4gMC4zKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9kZENvdW50cyA9IHRoaXMuZ2V0T2RkQ291bnRzKCk7XHJcbiAgICAgICAgdmFyIGV2ZW5Db3VudHMgPSB0aGlzLmdldEV2ZW5Db3VudHMoKTtcclxuICAgICAgICB2YXIgb2RkUm91bmRpbmdFcnJvcnMgPSB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCk7XHJcbiAgICAgICAgdmFyIGV2ZW5Sb3VuZGluZ0Vycm9ycyA9IHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWVfMSA9IDEuMCAqIGNvdW50ZXJzW2ldIC8gZWxlbWVudFdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgY291bnQgPSB2YWx1ZV8xICsgMC41OyAvLyBSb3VuZFxyXG4gICAgICAgICAgICBpZiAoY291bnQgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVfMSA8IDAuMykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb3VudCA+IDgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8xID4gOC43KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY291bnQgPSA4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpIC8gMjtcclxuICAgICAgICAgICAgaWYgKChpICYgMHgwMSkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgb2RkQ291bnRzW29mZnNldF0gPSBjb3VudDtcclxuICAgICAgICAgICAgICAgIG9kZFJvdW5kaW5nRXJyb3JzW29mZnNldF0gPSB2YWx1ZV8xIC0gY291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBldmVuQ291bnRzW29mZnNldF0gPSBjb3VudDtcclxuICAgICAgICAgICAgICAgIGV2ZW5Sb3VuZGluZ0Vycm9yc1tvZmZzZXRdID0gdmFsdWVfMSAtIGNvdW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRqdXN0T2RkRXZlbkNvdW50cyhudW1Nb2R1bGVzKTtcclxuICAgICAgICB2YXIgd2VpZ2h0Um93TnVtYmVyID0gNCAqIHBhdHRlcm4uZ2V0VmFsdWUoKSArIChpc09kZFBhdHRlcm4gPyAwIDogMikgKyAobGVmdENoYXIgPyAwIDogMSkgLSAxO1xyXG4gICAgICAgIHZhciBvZGRTdW0gPSAwO1xyXG4gICAgICAgIHZhciBvZGRDaGVja3N1bVBvcnRpb24gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBvZGRDb3VudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgaWYgKFJTU0V4cGFuZGVkUmVhZGVyLmlzTm90QTFsZWZ0KHBhdHRlcm4sIGlzT2RkUGF0dGVybiwgbGVmdENoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gUlNTRXhwYW5kZWRSZWFkZXIuV0VJR0hUU1t3ZWlnaHRSb3dOdW1iZXJdWzIgKiBpXTtcclxuICAgICAgICAgICAgICAgIG9kZENoZWNrc3VtUG9ydGlvbiArPSBvZGRDb3VudHNbaV0gKiB3ZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb2RkU3VtICs9IG9kZENvdW50c1tpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV2ZW5DaGVja3N1bVBvcnRpb24gPSAwO1xyXG4gICAgICAgIC8vaW50IGV2ZW5TdW0gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBldmVuQ291bnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChSU1NFeHBhbmRlZFJlYWRlci5pc05vdEExbGVmdChwYXR0ZXJuLCBpc09kZFBhdHRlcm4sIGxlZnRDaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IFJTU0V4cGFuZGVkUmVhZGVyLldFSUdIVFNbd2VpZ2h0Um93TnVtYmVyXVsyICogaSArIDFdO1xyXG4gICAgICAgICAgICAgICAgZXZlbkNoZWNrc3VtUG9ydGlvbiArPSBldmVuQ291bnRzW2ldICogd2VpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vZXZlblN1bSArPSBldmVuQ291bnRzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2hlY2tzdW1Qb3J0aW9uID0gb2RkQ2hlY2tzdW1Qb3J0aW9uICsgZXZlbkNoZWNrc3VtUG9ydGlvbjtcclxuICAgICAgICBpZiAoKG9kZFN1bSAmIDB4MDEpICE9IDAgfHwgb2RkU3VtID4gMTMgfHwgb2RkU3VtIDwgNCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBncm91cCA9ICgxMyAtIG9kZFN1bSkgLyAyO1xyXG4gICAgICAgIHZhciBvZGRXaWRlc3QgPSBSU1NFeHBhbmRlZFJlYWRlci5TWU1CT0xfV0lERVNUW2dyb3VwXTtcclxuICAgICAgICB2YXIgZXZlbldpZGVzdCA9IDkgLSBvZGRXaWRlc3Q7XHJcbiAgICAgICAgdmFyIHZPZGQgPSBSU1NVdGlsc18xLmRlZmF1bHQuZ2V0UlNTdmFsdWUob2RkQ291bnRzLCBvZGRXaWRlc3QsIHRydWUpO1xyXG4gICAgICAgIHZhciB2RXZlbiA9IFJTU1V0aWxzXzEuZGVmYXVsdC5nZXRSU1N2YWx1ZShldmVuQ291bnRzLCBldmVuV2lkZXN0LCBmYWxzZSk7XHJcbiAgICAgICAgdmFyIHRFdmVuID0gUlNTRXhwYW5kZWRSZWFkZXIuRVZFTl9UT1RBTF9TVUJTRVRbZ3JvdXBdO1xyXG4gICAgICAgIHZhciBnU3VtID0gUlNTRXhwYW5kZWRSZWFkZXIuR1NVTVtncm91cF07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdk9kZCAqIHRFdmVuICsgdkV2ZW4gKyBnU3VtO1xyXG4gICAgICAgIHJldHVybiBuZXcgRGF0YUNoYXJhY3Rlcl8xLmRlZmF1bHQodmFsdWUsIGNoZWNrc3VtUG9ydGlvbik7XHJcbiAgICB9O1xyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuaXNOb3RBMWxlZnQgPSBmdW5jdGlvbiAocGF0dGVybiwgaXNPZGRQYXR0ZXJuLCBsZWZ0Q2hhcikge1xyXG4gICAgICAgIC8vIEExOiBwYXR0ZXJuLmdldFZhbHVlIGlzIDAgKEEpLCBhbmQgaXQncyBhbiBvZGRQYXR0ZXJuLCBhbmQgaXQgaXMgYSBsZWZ0IGNoYXJcclxuICAgICAgICByZXR1cm4gIShwYXR0ZXJuLmdldFZhbHVlKCkgPT0gMCAmJiBpc09kZFBhdHRlcm4gJiYgbGVmdENoYXIpO1xyXG4gICAgfTtcclxuICAgIFJTU0V4cGFuZGVkUmVhZGVyLnByb3RvdHlwZS5hZGp1c3RPZGRFdmVuQ291bnRzID0gZnVuY3Rpb24gKG51bU1vZHVsZXMpIHtcclxuICAgICAgICB2YXIgb2RkU3VtID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5zdW0obmV3IEludDMyQXJyYXkodGhpcy5nZXRPZGRDb3VudHMoKSkpO1xyXG4gICAgICAgIHZhciBldmVuU3VtID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5zdW0obmV3IEludDMyQXJyYXkodGhpcy5nZXRFdmVuQ291bnRzKCkpKTtcclxuICAgICAgICB2YXIgaW5jcmVtZW50T2RkID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGRlY3JlbWVudE9kZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChvZGRTdW0gPiAxMykge1xyXG4gICAgICAgICAgICBkZWNyZW1lbnRPZGQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvZGRTdW0gPCA0KSB7XHJcbiAgICAgICAgICAgIGluY3JlbWVudE9kZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbmNyZW1lbnRFdmVuID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGRlY3JlbWVudEV2ZW4gPSBmYWxzZTtcclxuICAgICAgICBpZiAoZXZlblN1bSA+IDEzKSB7XHJcbiAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChldmVuU3VtIDwgNCkge1xyXG4gICAgICAgICAgICBpbmNyZW1lbnRFdmVuID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pc21hdGNoID0gb2RkU3VtICsgZXZlblN1bSAtIG51bU1vZHVsZXM7XHJcbiAgICAgICAgdmFyIG9kZFBhcml0eUJhZCA9IChvZGRTdW0gJiAweDAxKSA9PSAxO1xyXG4gICAgICAgIHZhciBldmVuUGFyaXR5QmFkID0gKGV2ZW5TdW0gJiAweDAxKSA9PSAwO1xyXG4gICAgICAgIGlmIChtaXNtYXRjaCA9PSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVjcmVtZW50T2RkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlY3JlbWVudEV2ZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1pc21hdGNoID09IC0xKSB7XHJcbiAgICAgICAgICAgIGlmIChvZGRQYXJpdHlCYWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVuUGFyaXR5QmFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmICghZXZlblBhcml0eUJhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluY3JlbWVudEV2ZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG1pc21hdGNoID09IDApIHtcclxuICAgICAgICAgICAgaWYgKG9kZFBhcml0eUJhZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFldmVuUGFyaXR5QmFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQm90aCBiYWRcclxuICAgICAgICAgICAgICAgIGlmIChvZGRTdW0gPCBldmVuU3VtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50T2RkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRFdmVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlY3JlbWVudE9kZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5jcmVtZW50RXZlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlblBhcml0eUJhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZG8hXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluY3JlbWVudE9kZCkge1xyXG4gICAgICAgICAgICBpZiAoZGVjcmVtZW50T2RkKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuaW5jcmVtZW50KHRoaXMuZ2V0T2RkQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWNyZW1lbnRPZGQpIHtcclxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuZGVjcmVtZW50KHRoaXMuZ2V0T2RkQ291bnRzKCksIHRoaXMuZ2V0T2RkUm91bmRpbmdFcnJvcnMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmNyZW1lbnRFdmVuKSB7XHJcbiAgICAgICAgICAgIGlmIChkZWNyZW1lbnRFdmVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUlNTRXhwYW5kZWRSZWFkZXIuaW5jcmVtZW50KHRoaXMuZ2V0RXZlbkNvdW50cygpLCB0aGlzLmdldE9kZFJvdW5kaW5nRXJyb3JzKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVjcmVtZW50RXZlbikge1xyXG4gICAgICAgICAgICBSU1NFeHBhbmRlZFJlYWRlci5kZWNyZW1lbnQodGhpcy5nZXRFdmVuQ291bnRzKCksIHRoaXMuZ2V0RXZlblJvdW5kaW5nRXJyb3JzKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5TWU1CT0xfV0lERVNUID0gWzcsIDUsIDQsIDMsIDFdO1xyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRVZFTl9UT1RBTF9TVUJTRVQgPSBbNCwgMjAsIDUyLCAxMDQsIDIwNF07XHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5HU1VNID0gWzAsIDM0OCwgMTM4OCwgMjk0OCwgMzk4OF07XHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUVEVSTlMgPSBbXHJcbiAgICAgICAgWzEsIDgsIDQsIDFdLFxyXG4gICAgICAgIFszLCA2LCA0LCAxXSxcclxuICAgICAgICBbMywgNCwgNiwgMV0sXHJcbiAgICAgICAgWzMsIDIsIDgsIDFdLFxyXG4gICAgICAgIFsyLCA2LCA1LCAxXSxcclxuICAgICAgICBbMiwgMiwgOSwgMV0gLy8gRlxyXG4gICAgXTtcclxuICAgIFJTU0V4cGFuZGVkUmVhZGVyLldFSUdIVFMgPSBbXHJcbiAgICAgICAgWzEsIDMsIDksIDI3LCA4MSwgMzIsIDk2LCA3N10sXHJcbiAgICAgICAgWzIwLCA2MCwgMTgwLCAxMTgsIDE0MywgNywgMjEsIDYzXSxcclxuICAgICAgICBbMTg5LCAxNDUsIDEzLCAzOSwgMTE3LCAxNDAsIDIwOSwgMjA1XSxcclxuICAgICAgICBbMTkzLCAxNTcsIDQ5LCAxNDcsIDE5LCA1NywgMTcxLCA5MV0sXHJcbiAgICAgICAgWzYyLCAxODYsIDEzNiwgMTk3LCAxNjksIDg1LCA0NCwgMTMyXSxcclxuICAgICAgICBbMTg1LCAxMzMsIDE4OCwgMTQyLCA0LCAxMiwgMzYsIDEwOF0sXHJcbiAgICAgICAgWzExMywgMTI4LCAxNzMsIDk3LCA4MCwgMjksIDg3LCA1MF0sXHJcbiAgICAgICAgWzE1MCwgMjgsIDg0LCA0MSwgMTIzLCAxNTgsIDUyLCAxNTZdLFxyXG4gICAgICAgIFs0NiwgMTM4LCAyMDMsIDE4NywgMTM5LCAyMDYsIDE5NiwgMTY2XSxcclxuICAgICAgICBbNzYsIDE3LCA1MSwgMTUzLCAzNywgMTExLCAxMjIsIDE1NV0sXHJcbiAgICAgICAgWzQzLCAxMjksIDE3NiwgMTA2LCAxMDcsIDExMCwgMTE5LCAxNDZdLFxyXG4gICAgICAgIFsxNiwgNDgsIDE0NCwgMTAsIDMwLCA5MCwgNTksIDE3N10sXHJcbiAgICAgICAgWzEwOSwgMTE2LCAxMzcsIDIwMCwgMTc4LCAxMTIsIDEyNSwgMTY0XSxcclxuICAgICAgICBbNzAsIDIxMCwgMjA4LCAyMDIsIDE4NCwgMTMwLCAxNzksIDExNV0sXHJcbiAgICAgICAgWzEzNCwgMTkxLCAxNTEsIDMxLCA5MywgNjgsIDIwNCwgMTkwXSxcclxuICAgICAgICBbMTQ4LCAyMiwgNjYsIDE5OCwgMTcyLCA5NCwgNzEsIDJdLFxyXG4gICAgICAgIFs2LCAxOCwgNTQsIDE2MiwgNjQsIDE5MiwgMTU0LCA0MF0sXHJcbiAgICAgICAgWzEyMCwgMTQ5LCAyNSwgNzUsIDE0LCA0MiwgMTI2LCAxNjddLFxyXG4gICAgICAgIFs3OSwgMjYsIDc4LCAyMywgNjksIDIwNywgMTk5LCAxNzVdLFxyXG4gICAgICAgIFsxMDMsIDk4LCA4MywgMzgsIDExNCwgMTMxLCAxODIsIDEyNF0sXHJcbiAgICAgICAgWzE2MSwgNjEsIDE4MywgMTI3LCAxNzAsIDg4LCA1MywgMTU5XSxcclxuICAgICAgICBbNTUsIDE2NSwgNzMsIDgsIDI0LCA3MiwgNSwgMTVdLFxyXG4gICAgICAgIFs0NSwgMTM1LCAxOTQsIDE2MCwgNTgsIDE3NCwgMTAwLCA4OV1cclxuICAgIF07XHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EgPSAwO1xyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CID0gMTtcclxuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQyA9IDI7XHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QgPSAzO1xyXG4gICAgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FID0gNDtcclxuICAgIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRiA9IDU7XHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUVEVSTl9TRVFVRU5DRVMgPSBbXHJcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BXSxcclxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQl0sXHJcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRF0sXHJcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DXSxcclxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRl0sXHJcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0YsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRl0sXHJcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9EXSxcclxuICAgICAgICBbUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0EsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9CLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQywgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9ELCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRV0sXHJcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0MsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0YsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRl0sXHJcbiAgICAgICAgW1JTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQSwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9BLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0IsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfQiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9DLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0QsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRCwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9FLCBSU1NFeHBhbmRlZFJlYWRlci5GSU5ERVJfUEFUX0UsIFJTU0V4cGFuZGVkUmVhZGVyLkZJTkRFUl9QQVRfRiwgUlNTRXhwYW5kZWRSZWFkZXIuRklOREVSX1BBVF9GXSxcclxuICAgIF07XHJcbiAgICBSU1NFeHBhbmRlZFJlYWRlci5NQVhfUEFJUlMgPSAxMTtcclxuICAgIHJldHVybiBSU1NFeHBhbmRlZFJlYWRlcjtcclxufShBYnN0cmFjdFJTU1JlYWRlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUlNTRXhwYW5kZWRSZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJTU0V4cGFuZGVkUmVhZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQUkwMTN4MHhEZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxM3gweERlY29kZXJcIik7XHJcbnZhciBBSTAxMzEwM2RlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQUkwMTMxMDNkZWNvZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQUkwMTMxMDNkZWNvZGVyKGluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluZm9ybWF0aW9uKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQUkwMTMxMDNkZWNvZGVyLnByb3RvdHlwZS5hZGRXZWlnaHRDb2RlID0gZnVuY3Rpb24gKGJ1Ziwgd2VpZ2h0KSB7XHJcbiAgICAgICAgYnVmLmFwcGVuZChcIigzMTAzKVwiKTtcclxuICAgIH07XHJcbiAgICBBSTAxMzEwM2RlY29kZXIucHJvdG90eXBlLmNoZWNrV2VpZ2h0ID0gZnVuY3Rpb24gKHdlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB3ZWlnaHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFJMDEzMTAzZGVjb2RlcjtcclxufShBSTAxM3gweERlY29kZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFJMDEzMTAzZGVjb2RlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QUkwMTMxMDNkZWNvZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQUkwMTN4MHhEZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxM3gweERlY29kZXJcIik7XHJcbnZhciBBSTAxMzIweERlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQUkwMTMyMHhEZWNvZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQUkwMTMyMHhEZWNvZGVyKGluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluZm9ybWF0aW9uKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQUkwMTMyMHhEZWNvZGVyLnByb3RvdHlwZS5hZGRXZWlnaHRDb2RlID0gZnVuY3Rpb24gKGJ1Ziwgd2VpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHdlaWdodCA8IDEwMDAwKSB7XHJcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoXCIoMzIwMilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBidWYuYXBwZW5kKFwiKDMyMDMpXCIpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBSTAxMzIweERlY29kZXIucHJvdG90eXBlLmNoZWNrV2VpZ2h0ID0gZnVuY3Rpb24gKHdlaWdodCkge1xyXG4gICAgICAgIGlmICh3ZWlnaHQgPCAxMDAwMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gd2VpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2VpZ2h0IC0gMTAwMDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFJMDEzMjB4RGVjb2RlcjtcclxufShBSTAxM3gweERlY29kZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFJMDEzMjB4RGVjb2RlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QUkwMTMyMHhEZWNvZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQUkwMWRlY29kZXJfMSA9IHJlcXVpcmUoXCIuL0FJMDFkZWNvZGVyXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XHJcbnZhciBBSTAxMzkyeERlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQUkwMTM5MnhEZWNvZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQUkwMTM5MnhEZWNvZGVyKGluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluZm9ybWF0aW9uKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQUkwMTM5MnhEZWNvZGVyLnByb3RvdHlwZS5wYXJzZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdldEluZm9ybWF0aW9uKCkuZ2V0U2l6ZSgpIDwgQUkwMTM5MnhEZWNvZGVyLkhFQURFUl9TSVpFICsgQUkwMWRlY29kZXJfMS5kZWZhdWx0LkdUSU5fU0laRSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWYgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluKGJ1ZiwgQUkwMTM5MnhEZWNvZGVyLkhFQURFUl9TSVpFKTtcclxuICAgICAgICB2YXIgbGFzdEFJZGlnaXQgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShBSTAxMzkyeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlcl8xLmRlZmF1bHQuR1RJTl9TSVpFLCBBSTAxMzkyeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFKTtcclxuICAgICAgICBidWYuYXBwZW5kKFwiKDM5MlwiKTtcclxuICAgICAgICBidWYuYXBwZW5kKGxhc3RBSWRpZ2l0KTtcclxuICAgICAgICBidWYuYXBwZW5kKCcpJyk7XHJcbiAgICAgICAgdmFyIGRlY29kZWRJbmZvcm1hdGlvbiA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5kZWNvZGVHZW5lcmFsUHVycG9zZUZpZWxkKEFJMDEzOTJ4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyXzEuZGVmYXVsdC5HVElOX1NJWkUgKyBBSTAxMzkyeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFLCBudWxsKTtcclxuICAgICAgICBidWYuYXBwZW5kKGRlY29kZWRJbmZvcm1hdGlvbi5nZXROZXdTdHJpbmcoKSk7XHJcbiAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIEFJMDEzOTJ4RGVjb2Rlci5IRUFERVJfU0laRSA9IDUgKyAxICsgMjtcclxuICAgIEFJMDEzOTJ4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUgPSAyO1xyXG4gICAgcmV0dXJuIEFJMDEzOTJ4RGVjb2RlcjtcclxufShBSTAxZGVjb2Rlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQUkwMTM5MnhEZWNvZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1BSTAxMzkyeERlY29kZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBBSTAxZGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQUkwMWRlY29kZXJcIik7XHJcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xyXG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcclxudmFyIEFJMDEzOTN4RGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBSTAxMzkzeERlY29kZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBSTAxMzkzeERlY29kZXIoaW5mb3JtYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaW5mb3JtYXRpb24pIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBBSTAxMzkzeERlY29kZXIucHJvdG90eXBlLnBhcnNlSW5mb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ2V0SW5mb3JtYXRpb24oKS5nZXRTaXplKCkgPCBBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlcl8xLmRlZmF1bHQuR1RJTl9TSVpFKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW4oYnVmLCBBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUpO1xyXG4gICAgICAgIHZhciBsYXN0QUlkaWdpdCA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyXzEuZGVmYXVsdC5HVElOX1NJWkUsIEFJMDEzOTN4RGVjb2Rlci5MQVNUX0RJR0lUX1NJWkUpO1xyXG4gICAgICAgIGJ1Zi5hcHBlbmQoXCIoMzkzXCIpO1xyXG4gICAgICAgIGJ1Zi5hcHBlbmQobGFzdEFJZGlnaXQpO1xyXG4gICAgICAgIGJ1Zi5hcHBlbmQoJyknKTtcclxuICAgICAgICB2YXIgZmlyc3RUaHJlZURpZ2l0cyA9IHRoaXMuZ2V0R2VuZXJhbERlY29kZXIoKS5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KEFJMDEzOTN4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDFkZWNvZGVyXzEuZGVmYXVsdC5HVElOX1NJWkUgKyBBSTAxMzkzeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFLCBBSTAxMzkzeERlY29kZXIuRklSU1RfVEhSRUVfRElHSVRTX1NJWkUpO1xyXG4gICAgICAgIGlmIChmaXJzdFRocmVlRGlnaXRzIC8gMTAwID09IDApIHtcclxuICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlyc3RUaHJlZURpZ2l0cyAvIDEwID09IDApIHtcclxuICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWYuYXBwZW5kKGZpcnN0VGhyZWVEaWdpdHMpO1xyXG4gICAgICAgIHZhciBnZW5lcmFsSW5mb3JtYXRpb24gPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZGVjb2RlR2VuZXJhbFB1cnBvc2VGaWVsZChBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxZGVjb2Rlcl8xLmRlZmF1bHQuR1RJTl9TSVpFICsgQUkwMTM5M3hEZWNvZGVyLkxBU1RfRElHSVRfU0laRSArIEFJMDEzOTN4RGVjb2Rlci5GSVJTVF9USFJFRV9ESUdJVFNfU0laRSwgbnVsbCk7XHJcbiAgICAgICAgYnVmLmFwcGVuZChnZW5lcmFsSW5mb3JtYXRpb24uZ2V0TmV3U3RyaW5nKCkpO1xyXG4gICAgICAgIHJldHVybiBidWYudG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICBBSTAxMzkzeERlY29kZXIuSEVBREVSX1NJWkUgPSA1ICsgMSArIDI7XHJcbiAgICBBSTAxMzkzeERlY29kZXIuTEFTVF9ESUdJVF9TSVpFID0gMjtcclxuICAgIEFJMDEzOTN4RGVjb2Rlci5GSVJTVF9USFJFRV9ESUdJVFNfU0laRSA9IDEwO1xyXG4gICAgcmV0dXJuIEFJMDEzOTN4RGVjb2RlcjtcclxufShBSTAxZGVjb2Rlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQUkwMTM5M3hEZWNvZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1BSTAxMzkzeERlY29kZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBBSTAxd2VpZ2h0RGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQUkwMXdlaWdodERlY29kZXJcIik7XHJcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xyXG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcclxudmFyIEFJMDEzeDB4MXhEZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFJMDEzeDB4MXhEZWNvZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQUkwMTN4MHgxeERlY29kZXIoaW5mb3JtYXRpb24sIGZpcnN0QUlkaWdpdHMsIGRhdGVDb2RlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5mb3JtYXRpb24pIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGF0ZUNvZGUgPSBkYXRlQ29kZTtcclxuICAgICAgICBfdGhpcy5maXJzdEFJZGlnaXRzID0gZmlyc3RBSWRpZ2l0cztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBBSTAxM3gweDF4RGVjb2Rlci5wcm90b3R5cGUucGFyc2VJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5nZXRJbmZvcm1hdGlvbigpLmdldFNpemUoKSAhPSBBSTAxM3gweDF4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDEzeDB4MXhEZWNvZGVyLkdUSU5fU0laRSArIEFJMDEzeDB4MXhEZWNvZGVyLldFSUdIVF9TSVpFICsgQUkwMTN4MHgxeERlY29kZXIuREFURV9TSVpFKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW4oYnVmLCBBSTAxM3gweDF4RGVjb2Rlci5IRUFERVJfU0laRSk7XHJcbiAgICAgICAgdGhpcy5lbmNvZGVDb21wcmVzc2VkV2VpZ2h0KGJ1ZiwgQUkwMTN4MHgxeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5HVElOX1NJWkUsIEFJMDEzeDB4MXhEZWNvZGVyLldFSUdIVF9TSVpFKTtcclxuICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWREYXRlKGJ1ZiwgQUkwMTN4MHgxeERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5HVElOX1NJWkUgKyBBSTAxM3gweDF4RGVjb2Rlci5XRUlHSFRfU0laRSk7XHJcbiAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIEFJMDEzeDB4MXhEZWNvZGVyLnByb3RvdHlwZS5lbmNvZGVDb21wcmVzc2VkRGF0ZSA9IGZ1bmN0aW9uIChidWYsIGN1cnJlbnRQb3MpIHtcclxuICAgICAgICB2YXIgbnVtZXJpY0RhdGUgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShjdXJyZW50UG9zLCBBSTAxM3gweDF4RGVjb2Rlci5EQVRFX1NJWkUpO1xyXG4gICAgICAgIGlmIChudW1lcmljRGF0ZSA9PSAzODQwMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1Zi5hcHBlbmQoJygnKTtcclxuICAgICAgICBidWYuYXBwZW5kKHRoaXMuZGF0ZUNvZGUpO1xyXG4gICAgICAgIGJ1Zi5hcHBlbmQoJyknKTtcclxuICAgICAgICB2YXIgZGF5ID0gbnVtZXJpY0RhdGUgJSAzMjtcclxuICAgICAgICBudW1lcmljRGF0ZSAvPSAzMjtcclxuICAgICAgICB2YXIgbW9udGggPSBudW1lcmljRGF0ZSAlIDEyICsgMTtcclxuICAgICAgICBudW1lcmljRGF0ZSAvPSAxMjtcclxuICAgICAgICB2YXIgeWVhciA9IG51bWVyaWNEYXRlO1xyXG4gICAgICAgIGlmICh5ZWFyIC8gMTAgPT0gMCkge1xyXG4gICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1Zi5hcHBlbmQoeWVhcik7XHJcbiAgICAgICAgaWYgKG1vbnRoIC8gMTAgPT0gMCkge1xyXG4gICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1Zi5hcHBlbmQobW9udGgpO1xyXG4gICAgICAgIGlmIChkYXkgLyAxMCA9PSAwKSB7XHJcbiAgICAgICAgICAgIGJ1Zi5hcHBlbmQoJzAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYnVmLmFwcGVuZChkYXkpO1xyXG4gICAgfTtcclxuICAgIEFJMDEzeDB4MXhEZWNvZGVyLnByb3RvdHlwZS5hZGRXZWlnaHRDb2RlID0gZnVuY3Rpb24gKGJ1Ziwgd2VpZ2h0KSB7XHJcbiAgICAgICAgYnVmLmFwcGVuZCgnKCcpO1xyXG4gICAgICAgIGJ1Zi5hcHBlbmQodGhpcy5maXJzdEFJZGlnaXRzKTtcclxuICAgICAgICBidWYuYXBwZW5kKHdlaWdodCAvIDEwMDAwMCk7XHJcbiAgICAgICAgYnVmLmFwcGVuZCgnKScpO1xyXG4gICAgfTtcclxuICAgIEFJMDEzeDB4MXhEZWNvZGVyLnByb3RvdHlwZS5jaGVja1dlaWdodCA9IGZ1bmN0aW9uICh3ZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gd2VpZ2h0ICUgMTAwMDAwO1xyXG4gICAgfTtcclxuICAgIEFJMDEzeDB4MXhEZWNvZGVyLkhFQURFUl9TSVpFID0gNyArIDE7XHJcbiAgICBBSTAxM3gweDF4RGVjb2Rlci5XRUlHSFRfU0laRSA9IDIwO1xyXG4gICAgQUkwMTN4MHgxeERlY29kZXIuREFURV9TSVpFID0gMTY7XHJcbiAgICByZXR1cm4gQUkwMTN4MHgxeERlY29kZXI7XHJcbn0oQUkwMXdlaWdodERlY29kZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFJMDEzeDB4MXhEZWNvZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1BSTAxM3gweDF4RGVjb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEFJMDF3ZWlnaHREZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxd2VpZ2h0RGVjb2RlclwiKTtcclxudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XHJcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xyXG52YXIgQUkwMTN4MHhEZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFJMDEzeDB4RGVjb2RlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFJMDEzeDB4RGVjb2RlcihpbmZvcm1hdGlvbikge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbmZvcm1hdGlvbikgfHwgdGhpcztcclxuICAgIH1cclxuICAgIEFJMDEzeDB4RGVjb2Rlci5wcm90b3R5cGUucGFyc2VJbmZvcm1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5nZXRJbmZvcm1hdGlvbigpLmdldFNpemUoKSAhPSBBSTAxM3gweERlY29kZXIuSEVBREVSX1NJWkUgKyBBSTAxd2VpZ2h0RGVjb2Rlcl8xLmRlZmF1bHQuR1RJTl9TSVpFICsgQUkwMTN4MHhEZWNvZGVyLldFSUdIVF9TSVpFKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW4oYnVmLCBBSTAxM3gweERlY29kZXIuSEVBREVSX1NJWkUpO1xyXG4gICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZFdlaWdodChidWYsIEFJMDEzeDB4RGVjb2Rlci5IRUFERVJfU0laRSArIEFJMDF3ZWlnaHREZWNvZGVyXzEuZGVmYXVsdC5HVElOX1NJWkUsIEFJMDEzeDB4RGVjb2Rlci5XRUlHSFRfU0laRSk7XHJcbiAgICAgICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIEFJMDEzeDB4RGVjb2Rlci5IRUFERVJfU0laRSA9IDQgKyAxO1xyXG4gICAgQUkwMTN4MHhEZWNvZGVyLldFSUdIVF9TSVpFID0gMTU7XHJcbiAgICByZXR1cm4gQUkwMTN4MHhEZWNvZGVyO1xyXG59KEFJMDF3ZWlnaHREZWNvZGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBSTAxM3gweERlY29kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFJMDEzeDB4RGVjb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEFJMDFkZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxZGVjb2RlclwiKTtcclxudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XHJcbnZhciBBSTAxQW5kT3RoZXJBSXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQUkwMUFuZE90aGVyQUlzLCBfc3VwZXIpO1xyXG4gICAgLy90aGUgc2Vjb25kIG9uZSBpcyB0aGUgZW5jb2RhdGlvbiBtZXRob2QsIGFuZCB0aGUgb3RoZXIgdHdvIGFyZSBmb3IgdGhlIHZhcmlhYmxlIGxlbmd0aFxyXG4gICAgZnVuY3Rpb24gQUkwMUFuZE90aGVyQUlzKGluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluZm9ybWF0aW9uKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQUkwMUFuZE90aGVyQUlzLnByb3RvdHlwZS5wYXJzZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBidWZmID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgYnVmZi5hcHBlbmQoXCIoMDEpXCIpO1xyXG4gICAgICAgIHZhciBpbml0aWFsR3RpblBvc2l0aW9uID0gYnVmZi5sZW5ndGgoKTtcclxuICAgICAgICB2YXIgZmlyc3RHdGluRGlnaXQgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShBSTAxQW5kT3RoZXJBSXMuSEVBREVSX1NJWkUsIDQpO1xyXG4gICAgICAgIGJ1ZmYuYXBwZW5kKGZpcnN0R3RpbkRpZ2l0KTtcclxuICAgICAgICB0aGlzLmVuY29kZUNvbXByZXNzZWRHdGluV2l0aG91dEFJKGJ1ZmYsIEFJMDFBbmRPdGhlckFJcy5IRUFERVJfU0laRSArIDQsIGluaXRpYWxHdGluUG9zaXRpb24pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZGVjb2RlQWxsQ29kZXMoYnVmZiwgQUkwMUFuZE90aGVyQUlzLkhFQURFUl9TSVpFICsgNDQpO1xyXG4gICAgfTtcclxuICAgIEFJMDFBbmRPdGhlckFJcy5IRUFERVJfU0laRSA9IDEgKyAxICsgMjsgLy9maXJzdCBiaXQgZW5jb2RlcyB0aGUgbGlua2FnZSBmbGFnLFxyXG4gICAgcmV0dXJuIEFJMDFBbmRPdGhlckFJcztcclxufShBSTAxZGVjb2Rlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQUkwMUFuZE90aGVyQUlzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1BSTAxQW5kT3RoZXJBSXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBBYnN0cmFjdEV4cGFuZGVkRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RFeHBhbmRlZERlY29kZXJcIik7XHJcbnZhciBBSTAxZGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhBSTAxZGVjb2RlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFJMDFkZWNvZGVyKGluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluZm9ybWF0aW9uKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQUkwMWRlY29kZXIucHJvdG90eXBlLmVuY29kZUNvbXByZXNzZWRHdGluID0gZnVuY3Rpb24gKGJ1ZiwgY3VycmVudFBvcykge1xyXG4gICAgICAgIGJ1Zi5hcHBlbmQoXCIoMDEpXCIpO1xyXG4gICAgICAgIHZhciBpbml0aWFsUG9zaXRpb24gPSBidWYubGVuZ3RoKCk7XHJcbiAgICAgICAgYnVmLmFwcGVuZCgnOScpO1xyXG4gICAgICAgIHRoaXMuZW5jb2RlQ29tcHJlc3NlZEd0aW5XaXRob3V0QUkoYnVmLCBjdXJyZW50UG9zLCBpbml0aWFsUG9zaXRpb24pO1xyXG4gICAgfTtcclxuICAgIEFJMDFkZWNvZGVyLnByb3RvdHlwZS5lbmNvZGVDb21wcmVzc2VkR3RpbldpdGhvdXRBSSA9IGZ1bmN0aW9uIChidWYsIGN1cnJlbnRQb3MsIGluaXRpYWxCdWZmZXJQb3NpdGlvbikge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50QmxvY2sgPSB0aGlzLmdldEdlbmVyYWxEZWNvZGVyKCkuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShjdXJyZW50UG9zICsgMTAgKiBpLCAxMCk7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2sgLyAxMDAgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgYnVmLmFwcGVuZCgnMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50QmxvY2sgLyAxMCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnVmLmFwcGVuZChjdXJyZW50QmxvY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBBSTAxZGVjb2Rlci5hcHBlbmRDaGVja0RpZ2l0KGJ1ZiwgaW5pdGlhbEJ1ZmZlclBvc2l0aW9uKTtcclxuICAgIH07XHJcbiAgICBBSTAxZGVjb2Rlci5hcHBlbmRDaGVja0RpZ2l0ID0gZnVuY3Rpb24gKGJ1ZiwgY3VycmVudFBvcykge1xyXG4gICAgICAgIHZhciBjaGVja0RpZ2l0ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEzOyBpKyspIHtcclxuICAgICAgICAgICAgLy9sZXQgZGlnaXQgPSBidWYuY2hhckF0KGkgKyBjdXJyZW50UG9zKSAtICcwJztcclxuICAgICAgICAgICAgLy9UbyBiZSBjaGVja2VkXHJcbiAgICAgICAgICAgIHZhciBkaWdpdCA9IGJ1Zi5jaGFyQXQoaSArIGN1cnJlbnRQb3MpLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgY2hlY2tEaWdpdCArPSAoaSAmIDB4MDEpID09IDAgPyAzICogZGlnaXQgOiBkaWdpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2hlY2tEaWdpdCA9IDEwIC0gKGNoZWNrRGlnaXQgJSAxMCk7XHJcbiAgICAgICAgaWYgKGNoZWNrRGlnaXQgPT0gMTApIHtcclxuICAgICAgICAgICAgY2hlY2tEaWdpdCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1Zi5hcHBlbmQoY2hlY2tEaWdpdCk7XHJcbiAgICB9O1xyXG4gICAgQUkwMWRlY29kZXIuR1RJTl9TSVpFID0gNDA7XHJcbiAgICByZXR1cm4gQUkwMWRlY29kZXI7XHJcbn0oQWJzdHJhY3RFeHBhbmRlZERlY29kZXJfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFJMDFkZWNvZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1BSTAxZGVjb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEFJMDFkZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxZGVjb2RlclwiKTtcclxudmFyIEFJMDF3ZWlnaHREZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEFJMDF3ZWlnaHREZWNvZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQUkwMXdlaWdodERlY29kZXIoaW5mb3JtYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaW5mb3JtYXRpb24pIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBBSTAxd2VpZ2h0RGVjb2Rlci5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZFdlaWdodCA9IGZ1bmN0aW9uIChidWYsIGN1cnJlbnRQb3MsIHdlaWdodFNpemUpIHtcclxuICAgICAgICB2YXIgb3JpZ2luYWxXZWlnaHROdW1lcmljID0gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoY3VycmVudFBvcywgd2VpZ2h0U2l6ZSk7XHJcbiAgICAgICAgdGhpcy5hZGRXZWlnaHRDb2RlKGJ1Ziwgb3JpZ2luYWxXZWlnaHROdW1lcmljKTtcclxuICAgICAgICB2YXIgd2VpZ2h0TnVtZXJpYyA9IHRoaXMuY2hlY2tXZWlnaHQob3JpZ2luYWxXZWlnaHROdW1lcmljKTtcclxuICAgICAgICB2YXIgY3VycmVudERpdmlzb3IgPSAxMDAwMDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHdlaWdodE51bWVyaWMgLyBjdXJyZW50RGl2aXNvciA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBidWYuYXBwZW5kKCcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudERpdmlzb3IgLz0gMTA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1Zi5hcHBlbmQod2VpZ2h0TnVtZXJpYyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFJMDF3ZWlnaHREZWNvZGVyO1xyXG59KEFJMDFkZWNvZGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBSTAxd2VpZ2h0RGVjb2RlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QUkwMXdlaWdodERlY29kZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEdlbmVyYWxBcHBJZERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL0dlbmVyYWxBcHBJZERlY29kZXJcIik7XHJcbnZhciBBYnN0cmFjdEV4cGFuZGVkRGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEFic3RyYWN0RXhwYW5kZWREZWNvZGVyKGluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5pbmZvcm1hdGlvbiA9IGluZm9ybWF0aW9uO1xyXG4gICAgICAgIHRoaXMuZ2VuZXJhbERlY29kZXIgPSBuZXcgR2VuZXJhbEFwcElkRGVjb2Rlcl8xLmRlZmF1bHQoaW5mb3JtYXRpb24pO1xyXG4gICAgfVxyXG4gICAgQWJzdHJhY3RFeHBhbmRlZERlY29kZXIucHJvdG90eXBlLmdldEluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluZm9ybWF0aW9uO1xyXG4gICAgfTtcclxuICAgIEFic3RyYWN0RXhwYW5kZWREZWNvZGVyLnByb3RvdHlwZS5nZXRHZW5lcmFsRGVjb2RlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmFsRGVjb2RlcjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQWJzdHJhY3RFeHBhbmRlZERlY29kZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFic3RyYWN0RXhwYW5kZWREZWNvZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYnN0cmFjdEV4cGFuZGVkRGVjb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgSWxsZWdhbFN0YXRlRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vSWxsZWdhbFN0YXRlRXhjZXB0aW9uXCIpO1xyXG52YXIgR2VuZXJhbEFwcElkRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vR2VuZXJhbEFwcElkRGVjb2RlclwiKTtcclxudmFyIEFJMDFBbmRPdGhlckFJc18xID0gcmVxdWlyZShcIi4vQUkwMUFuZE90aGVyQUlzXCIpO1xyXG52YXIgQW55QUlEZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BbnlBSURlY29kZXJcIik7XHJcbnZhciBBSTAxMzEwM2RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL0FJMDEzMTAzZGVjb2RlclwiKTtcclxudmFyIEFJMDEzMjB4RGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQUkwMTMyMHhEZWNvZGVyXCIpO1xyXG52YXIgQUkwMTM5MnhEZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxMzkyeERlY29kZXJcIik7XHJcbnZhciBBSTAxMzkzeERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL0FJMDEzOTN4RGVjb2RlclwiKTtcclxudmFyIEFJMDEzeDB4MXhEZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9BSTAxM3gweDF4RGVjb2RlclwiKTtcclxuZnVuY3Rpb24gY3JlYXRlRGVjb2RlcihpbmZvcm1hdGlvbikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoaW5mb3JtYXRpb24uZ2V0KDEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQUkwMUFuZE90aGVyQUlzXzEuZGVmYXVsdChpbmZvcm1hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaW5mb3JtYXRpb24uZ2V0KDIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW55QUlEZWNvZGVyXzEuZGVmYXVsdChpbmZvcm1hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmb3VyQml0RW5jb2RhdGlvbk1ldGhvZCA9IEdlbmVyYWxBcHBJZERlY29kZXJfMS5kZWZhdWx0LmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoaW5mb3JtYXRpb24sIDEsIDQpO1xyXG4gICAgICAgIHN3aXRjaCAoZm91ckJpdEVuY29kYXRpb25NZXRob2QpIHtcclxuICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IEFJMDEzMTAzZGVjb2Rlcl8xLmRlZmF1bHQoaW5mb3JtYXRpb24pO1xyXG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQUkwMTMyMHhEZWNvZGVyXzEuZGVmYXVsdChpbmZvcm1hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaXZlQml0RW5jb2RhdGlvbk1ldGhvZCA9IEdlbmVyYWxBcHBJZERlY29kZXJfMS5kZWZhdWx0LmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoaW5mb3JtYXRpb24sIDEsIDUpO1xyXG4gICAgICAgIHN3aXRjaCAoZml2ZUJpdEVuY29kYXRpb25NZXRob2QpIHtcclxuICAgICAgICAgICAgY2FzZSAxMjogcmV0dXJuIG5ldyBBSTAxMzkyeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uKTtcclxuICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIG5ldyBBSTAxMzkzeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNldmVuQml0RW5jb2RhdGlvbk1ldGhvZCA9IEdlbmVyYWxBcHBJZERlY29kZXJfMS5kZWZhdWx0LmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkoaW5mb3JtYXRpb24sIDEsIDcpO1xyXG4gICAgICAgIHN3aXRjaCAoc2V2ZW5CaXRFbmNvZGF0aW9uTWV0aG9kKSB7XHJcbiAgICAgICAgICAgIGNhc2UgNTY6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uLCAnMzEwJywgJzExJyk7XHJcbiAgICAgICAgICAgIGNhc2UgNTc6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uLCAnMzIwJywgJzExJyk7XHJcbiAgICAgICAgICAgIGNhc2UgNTg6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uLCAnMzEwJywgJzEzJyk7XHJcbiAgICAgICAgICAgIGNhc2UgNTk6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uLCAnMzIwJywgJzEzJyk7XHJcbiAgICAgICAgICAgIGNhc2UgNjA6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uLCAnMzEwJywgJzE1Jyk7XHJcbiAgICAgICAgICAgIGNhc2UgNjE6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uLCAnMzIwJywgJzE1Jyk7XHJcbiAgICAgICAgICAgIGNhc2UgNjI6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uLCAnMzEwJywgJzE3Jyk7XHJcbiAgICAgICAgICAgIGNhc2UgNjM6IHJldHVybiBuZXcgQUkwMTN4MHgxeERlY29kZXJfMS5kZWZhdWx0KGluZm9ybWF0aW9uLCAnMzIwJywgJzE3Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhlKTtcclxuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uXzEuZGVmYXVsdCgndW5rbm93biBkZWNvZGVyOiAnICsgaW5mb3JtYXRpb24pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuY3JlYXRlRGVjb2RlciA9IGNyZWF0ZURlY29kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFic3RyYWN0RXhwYW5kZWREZWNvZGVyQ29tcGxlbWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XHJcbnZhciBBYnN0cmFjdEV4cGFuZGVkRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RFeHBhbmRlZERlY29kZXJcIik7XHJcbnZhciBBbnlBSURlY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQW55QUlEZWNvZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQW55QUlEZWNvZGVyKGluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluZm9ybWF0aW9uKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgQW55QUlEZWNvZGVyLnByb3RvdHlwZS5wYXJzZUluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBidWYgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRHZW5lcmFsRGVjb2RlcigpLmRlY29kZUFsbENvZGVzKGJ1ZiwgQW55QUlEZWNvZGVyLkhFQURFUl9TSVpFKTtcclxuICAgIH07XHJcbiAgICBBbnlBSURlY29kZXIuSEVBREVSX1NJWkUgPSAyICsgMSArIDI7XHJcbiAgICByZXR1cm4gQW55QUlEZWNvZGVyO1xyXG59KEFic3RyYWN0RXhwYW5kZWREZWNvZGVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBbnlBSURlY29kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFueUFJRGVjb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQmxvY2tQYXJzZWRSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCbG9ja1BhcnNlZFJlc3VsdChmaW5pc2hlZCwgZGVjb2RlZEluZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgaWYgKGRlY29kZWRJbmZvcm1hdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmRlY29kZWRJbmZvcm1hdGlvbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmluaXNoZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlZEluZm9ybWF0aW9uID0gZGVjb2RlZEluZm9ybWF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEJsb2NrUGFyc2VkUmVzdWx0LnByb3RvdHlwZS5nZXREZWNvZGVkSW5mb3JtYXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlZEluZm9ybWF0aW9uO1xyXG4gICAgfTtcclxuICAgIEJsb2NrUGFyc2VkUmVzdWx0LnByb3RvdHlwZS5pc0ZpbmlzaGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaGVkO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCbG9ja1BhcnNlZFJlc3VsdDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2tQYXJzZWRSZXN1bHQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb2NrUGFyc2VkUmVzdWx0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRGVjb2RlZE9iamVjdF8xID0gcmVxdWlyZShcIi4vRGVjb2RlZE9iamVjdFwiKTtcclxudmFyIERlY29kZWRDaGFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKERlY29kZWRDaGFyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGVjb2RlZENoYXIobmV3UG9zaXRpb24sIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV3UG9zaXRpb24pIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEZWNvZGVkQ2hhci5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlZENoYXIucHJvdG90eXBlLmlzRk5DMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gRGVjb2RlZENoYXIuRk5DMTtcclxuICAgIH07XHJcbiAgICBEZWNvZGVkQ2hhci5GTkMxID0gJyQnO1xyXG4gICAgcmV0dXJuIERlY29kZWRDaGFyO1xyXG59KERlY29kZWRPYmplY3RfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERlY29kZWRDaGFyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWNvZGVkQ2hhci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIERlY29kZWRPYmplY3RfMSA9IHJlcXVpcmUoXCIuL0RlY29kZWRPYmplY3RcIik7XHJcbnZhciBEZWNvZGVkSW5mb3JtYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoRGVjb2RlZEluZm9ybWF0aW9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGVjb2RlZEluZm9ybWF0aW9uKG5ld1Bvc2l0aW9uLCBuZXdTdHJpbmcsIHJlbWFpbmluZ1ZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmV3UG9zaXRpb24pIHx8IHRoaXM7XHJcbiAgICAgICAgaWYgKHJlbWFpbmluZ1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbWFpbmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbWFpbmluZ1ZhbHVlID0gX3RoaXMucmVtYWluaW5nVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfdGhpcy5yZW1haW5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgX3RoaXMucmVtYWluaW5nVmFsdWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5uZXdTdHJpbmcgPSBuZXdTdHJpbmc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGVjb2RlZEluZm9ybWF0aW9uLnByb3RvdHlwZS5nZXROZXdTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3U3RyaW5nO1xyXG4gICAgfTtcclxuICAgIERlY29kZWRJbmZvcm1hdGlvbi5wcm90b3R5cGUuaXNSZW1haW5pbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nO1xyXG4gICAgfTtcclxuICAgIERlY29kZWRJbmZvcm1hdGlvbi5wcm90b3R5cGUuZ2V0UmVtYWluaW5nVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERlY29kZWRJbmZvcm1hdGlvbjtcclxufShEZWNvZGVkT2JqZWN0XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEZWNvZGVkSW5mb3JtYXRpb247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlY29kZWRJbmZvcm1hdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcclxudmFyIERlY29kZWRPYmplY3RfMSA9IHJlcXVpcmUoXCIuL0RlY29kZWRPYmplY3RcIik7XHJcbnZhciBEZWNvZGVkTnVtZXJpYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZWNvZGVkTnVtZXJpYywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERlY29kZWROdW1lcmljKG5ld1Bvc2l0aW9uLCBmaXJzdERpZ2l0LCBzZWNvbmREaWdpdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ld1Bvc2l0aW9uKSB8fCB0aGlzO1xyXG4gICAgICAgIGlmIChmaXJzdERpZ2l0IDwgMCB8fCBmaXJzdERpZ2l0ID4gMTAgfHwgc2Vjb25kRGlnaXQgPCAwIHx8IHNlY29uZERpZ2l0ID4gMTApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuZmlyc3REaWdpdCA9IGZpcnN0RGlnaXQ7XHJcbiAgICAgICAgX3RoaXMuc2Vjb25kRGlnaXQgPSBzZWNvbmREaWdpdDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEZWNvZGVkTnVtZXJpYy5wcm90b3R5cGUuZ2V0Rmlyc3REaWdpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maXJzdERpZ2l0O1xyXG4gICAgfTtcclxuICAgIERlY29kZWROdW1lcmljLnByb3RvdHlwZS5nZXRTZWNvbmREaWdpdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWNvbmREaWdpdDtcclxuICAgIH07XHJcbiAgICBEZWNvZGVkTnVtZXJpYy5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3REaWdpdCAqIDEwICsgdGhpcy5zZWNvbmREaWdpdDtcclxuICAgIH07XHJcbiAgICBEZWNvZGVkTnVtZXJpYy5wcm90b3R5cGUuaXNGaXJzdERpZ2l0Rk5DMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maXJzdERpZ2l0ID09IERlY29kZWROdW1lcmljLkZOQzE7XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlZE51bWVyaWMucHJvdG90eXBlLmlzU2Vjb25kRGlnaXRGTkMxID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlY29uZERpZ2l0ID09IERlY29kZWROdW1lcmljLkZOQzE7XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlZE51bWVyaWMucHJvdG90eXBlLmlzQW55Rk5DMSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maXJzdERpZ2l0ID09PSBEZWNvZGVkTnVtZXJpYy5GTkMxIHx8IHRoaXMuc2Vjb25kRGlnaXQgPT09IERlY29kZWROdW1lcmljLkZOQzE7XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlZE51bWVyaWMuRk5DMSA9IDEwO1xyXG4gICAgcmV0dXJuIERlY29kZWROdW1lcmljO1xyXG59KERlY29kZWRPYmplY3RfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERlY29kZWROdW1lcmljO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWNvZGVkTnVtZXJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRGVjb2RlZE9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlY29kZWRPYmplY3QobmV3UG9zaXRpb24pIHtcclxuICAgICAgICB0aGlzLm5ld1Bvc2l0aW9uID0gbmV3UG9zaXRpb247XHJcbiAgICB9XHJcbiAgICBEZWNvZGVkT2JqZWN0LnByb3RvdHlwZS5nZXROZXdQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXdQb3NpdGlvbjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVjb2RlZE9iamVjdDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGVjb2RlZE9iamVjdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVjb2RlZE9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxudmFyIEZpZWxkUGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmllbGRQYXJzZXIoKSB7XHJcbiAgICB9XHJcbiAgICBGaWVsZFBhcnNlci5wYXJzZUZpZWxkc0luR2VuZXJhbFB1cnBvc2UgPSBmdW5jdGlvbiAocmF3SW5mb3JtYXRpb24pIHtcclxuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYiwgZV8zLCBfYywgZV80LCBfZDtcclxuICAgICAgICBpZiAoIXJhd0luZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm9jZXNzaW5nIDItZGlnaXQgQUlzXHJcbiAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZmlyc3RUd29EaWdpdHMgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoMCwgMik7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2UgPSBfX3ZhbHVlcyhGaWVsZFBhcnNlci5UV09fRElHSVRfREFUQV9MRU5HVEgpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YUxlbmd0aCA9IF9mLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMF0gPT09IGZpcnN0VHdvRGlnaXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMV0gPT09IEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc1ZhcmlhYmxlQUkoMiwgZGF0YUxlbmd0aFsyXSwgcmF3SW5mb3JtYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkoMiwgZGF0YUxlbmd0aFsxXSwgcmF3SW5mb3JtYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9hID0gX2UucmV0dXJuKSkgX2EuY2FsbChfZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmF3SW5mb3JtYXRpb24ubGVuZ3RoIDwgMykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaXJzdFRocmVlRGlnaXRzID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIDMpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9nID0gX192YWx1ZXMoRmllbGRQYXJzZXIuVEhSRUVfRElHSVRfREFUQV9MRU5HVEgpLCBfaCA9IF9nLm5leHQoKTsgIV9oLmRvbmU7IF9oID0gX2cubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YUxlbmd0aCA9IF9oLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMF0gPT09IGZpcnN0VGhyZWVEaWdpdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFsxXSA9PT0gRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzVmFyaWFibGVBSSgzLCBkYXRhTGVuZ3RoWzJdLCByYXdJbmZvcm1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGaWVsZFBhcnNlci5wcm9jZXNzRml4ZWRBSSgzLCBkYXRhTGVuZ3RoWzFdLCByYXdJbmZvcm1hdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChfaCAmJiAhX2guZG9uZSAmJiAoX2IgPSBfZy5yZXR1cm4pKSBfYi5jYWxsKF9nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gX192YWx1ZXMoRmllbGRQYXJzZXIuVEhSRUVfRElHSVRfUExVU19ESUdJVF9EQVRBX0xFTkdUSCksIF9rID0gX2oubmV4dCgpOyAhX2suZG9uZTsgX2sgPSBfai5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhTGVuZ3RoID0gX2sudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFswXSA9PT0gZmlyc3RUaHJlZURpZ2l0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhTGVuZ3RoWzFdID09PSBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NWYXJpYWJsZUFJKDQsIGRhdGFMZW5ndGhbMl0sIHJhd0luZm9ybWF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZpZWxkUGFyc2VyLnByb2Nlc3NGaXhlZEFJKDQsIGRhdGFMZW5ndGhbMV0sIHJhd0luZm9ybWF0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9rICYmICFfay5kb25lICYmIChfYyA9IF9qLnJldHVybikpIF9jLmNhbGwoX2opO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IDQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZmlyc3RGb3VyRGlnaXRzID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIDQpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9sID0gX192YWx1ZXMoRmllbGRQYXJzZXIuRk9VUl9ESUdJVF9EQVRBX0xFTkdUSCksIF9tID0gX2wubmV4dCgpOyAhX20uZG9uZTsgX20gPSBfbC5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhTGVuZ3RoID0gX20udmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUxlbmd0aFswXSA9PT0gZmlyc3RGb3VyRGlnaXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFMZW5ndGhbMV0gPT09IEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc1ZhcmlhYmxlQUkoNCwgZGF0YUxlbmd0aFsyXSwgcmF3SW5mb3JtYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkoNCwgZGF0YUxlbmd0aFsxXSwgcmF3SW5mb3JtYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX20gJiYgIV9tLmRvbmUgJiYgKF9kID0gX2wucmV0dXJuKSkgX2QuY2FsbChfbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICB9O1xyXG4gICAgRmllbGRQYXJzZXIucHJvY2Vzc0ZpeGVkQUkgPSBmdW5jdGlvbiAoYWlTaXplLCBmaWVsZFNpemUsIHJhd0luZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IGFpU2l6ZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhaSA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZygwLCBhaVNpemUpO1xyXG4gICAgICAgIGlmIChyYXdJbmZvcm1hdGlvbi5sZW5ndGggPCBhaVNpemUgKyBmaWVsZFNpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZmllbGQgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoYWlTaXplLCBhaVNpemUgKyBmaWVsZFNpemUpO1xyXG4gICAgICAgIHZhciByZW1haW5pbmcgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcoYWlTaXplICsgZmllbGRTaXplKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJygnICsgYWkgKyAnKScgKyBmaWVsZDtcclxuICAgICAgICB2YXIgcGFyc2VkQUkgPSBGaWVsZFBhcnNlci5wYXJzZUZpZWxkc0luR2VuZXJhbFB1cnBvc2UocmVtYWluaW5nKTtcclxuICAgICAgICByZXR1cm4gcGFyc2VkQUkgPT0gbnVsbCA/IHJlc3VsdCA6IHJlc3VsdCArIHBhcnNlZEFJO1xyXG4gICAgfTtcclxuICAgIEZpZWxkUGFyc2VyLnByb2Nlc3NWYXJpYWJsZUFJID0gZnVuY3Rpb24gKGFpU2l6ZSwgdmFyaWFibGVGaWVsZFNpemUsIHJhd0luZm9ybWF0aW9uKSB7XHJcbiAgICAgICAgdmFyIGFpID0gcmF3SW5mb3JtYXRpb24uc3Vic3RyaW5nKDAsIGFpU2l6ZSk7XHJcbiAgICAgICAgdmFyIG1heFNpemU7XHJcbiAgICAgICAgaWYgKHJhd0luZm9ybWF0aW9uLmxlbmd0aCA8IGFpU2l6ZSArIHZhcmlhYmxlRmllbGRTaXplKSB7XHJcbiAgICAgICAgICAgIG1heFNpemUgPSByYXdJbmZvcm1hdGlvbi5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtYXhTaXplID0gYWlTaXplICsgdmFyaWFibGVGaWVsZFNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaWVsZCA9IHJhd0luZm9ybWF0aW9uLnN1YnN0cmluZyhhaVNpemUsIG1heFNpemUpO1xyXG4gICAgICAgIHZhciByZW1haW5pbmcgPSByYXdJbmZvcm1hdGlvbi5zdWJzdHJpbmcobWF4U2l6ZSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcoJyArIGFpICsgJyknICsgZmllbGQ7XHJcbiAgICAgICAgdmFyIHBhcnNlZEFJID0gRmllbGRQYXJzZXIucGFyc2VGaWVsZHNJbkdlbmVyYWxQdXJwb3NlKHJlbWFpbmluZyk7XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlZEFJID09IG51bGwgPyByZXN1bHQgOiByZXN1bHQgKyBwYXJzZWRBSTtcclxuICAgIH07XHJcbiAgICBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEggPSBbXTtcclxuICAgIEZpZWxkUGFyc2VyLlRXT19ESUdJVF9EQVRBX0xFTkdUSCA9IFtcclxuICAgICAgICBbXCIwMFwiLCAxOF0sXHJcbiAgICAgICAgW1wiMDFcIiwgMTRdLFxyXG4gICAgICAgIFtcIjAyXCIsIDE0XSxcclxuICAgICAgICBbXCIxMFwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcclxuICAgICAgICBbXCIxMVwiLCA2XSxcclxuICAgICAgICBbXCIxMlwiLCA2XSxcclxuICAgICAgICBbXCIxM1wiLCA2XSxcclxuICAgICAgICBbXCIxNVwiLCA2XSxcclxuICAgICAgICBbXCIxN1wiLCA2XSxcclxuICAgICAgICBbXCIyMFwiLCAyXSxcclxuICAgICAgICBbXCIyMVwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcclxuICAgICAgICBbXCIyMlwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDI5XSxcclxuICAgICAgICBbXCIzMFwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDhdLFxyXG4gICAgICAgIFtcIjM3XCIsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgOF0sXHJcbiAgICAgICAgLy9pbnRlcm5hbCBjb21wYW55IGNvZGVzXHJcbiAgICAgICAgW1wiOTBcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiOTFcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiOTJcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiOTNcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiOTRcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiOTVcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiOTZcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiOTdcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzXSxcclxuICAgICAgICBbXCI5OFwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcclxuICAgICAgICBbXCI5OVwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcclxuICAgIF07XHJcbiAgICBGaWVsZFBhcnNlci5USFJFRV9ESUdJVF9EQVRBX0xFTkdUSCA9IFtcclxuICAgICAgICAvLyBTYW1lIGZvcm1hdCBhcyBhYm92ZVxyXG4gICAgICAgIFtcIjI0MFwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcclxuICAgICAgICBbXCIyNDFcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiMjQyXCIsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgNl0sXHJcbiAgICAgICAgW1wiMjUwXCIsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxyXG4gICAgICAgIFtcIjI1MVwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcclxuICAgICAgICBbXCIyNTNcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxN10sXHJcbiAgICAgICAgW1wiMjU0XCIsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMjBdLFxyXG4gICAgICAgIFtcIjQwMFwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDMwXSxcclxuICAgICAgICBbXCI0MDFcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiNDAyXCIsIDE3XSxcclxuICAgICAgICBbXCI0MDNcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiNDEwXCIsIDEzXSxcclxuICAgICAgICBbXCI0MTFcIiwgMTNdLFxyXG4gICAgICAgIFtcIjQxMlwiLCAxM10sXHJcbiAgICAgICAgW1wiNDEzXCIsIDEzXSxcclxuICAgICAgICBbXCI0MTRcIiwgMTNdLFxyXG4gICAgICAgIFtcIjQyMFwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcclxuICAgICAgICBbXCI0MjFcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxNV0sXHJcbiAgICAgICAgW1wiNDIyXCIsIDNdLFxyXG4gICAgICAgIFtcIjQyM1wiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE1XSxcclxuICAgICAgICBbXCI0MjRcIiwgM10sXHJcbiAgICAgICAgW1wiNDI1XCIsIDNdLFxyXG4gICAgICAgIFtcIjQyNlwiLCAzXSxcclxuICAgIF07XHJcbiAgICBGaWVsZFBhcnNlci5USFJFRV9ESUdJVF9QTFVTX0RJR0lUX0RBVEFfTEVOR1RIID0gW1xyXG4gICAgICAgIC8vIFNhbWUgZm9ybWF0IGFzIGFib3ZlXHJcbiAgICAgICAgW1wiMzEwXCIsIDZdLFxyXG4gICAgICAgIFtcIjMxMVwiLCA2XSxcclxuICAgICAgICBbXCIzMTJcIiwgNl0sXHJcbiAgICAgICAgW1wiMzEzXCIsIDZdLFxyXG4gICAgICAgIFtcIjMxNFwiLCA2XSxcclxuICAgICAgICBbXCIzMTVcIiwgNl0sXHJcbiAgICAgICAgW1wiMzE2XCIsIDZdLFxyXG4gICAgICAgIFtcIjMyMFwiLCA2XSxcclxuICAgICAgICBbXCIzMjFcIiwgNl0sXHJcbiAgICAgICAgW1wiMzIyXCIsIDZdLFxyXG4gICAgICAgIFtcIjMyM1wiLCA2XSxcclxuICAgICAgICBbXCIzMjRcIiwgNl0sXHJcbiAgICAgICAgW1wiMzI1XCIsIDZdLFxyXG4gICAgICAgIFtcIjMyNlwiLCA2XSxcclxuICAgICAgICBbXCIzMjdcIiwgNl0sXHJcbiAgICAgICAgW1wiMzI4XCIsIDZdLFxyXG4gICAgICAgIFtcIjMyOVwiLCA2XSxcclxuICAgICAgICBbXCIzMzBcIiwgNl0sXHJcbiAgICAgICAgW1wiMzMxXCIsIDZdLFxyXG4gICAgICAgIFtcIjMzMlwiLCA2XSxcclxuICAgICAgICBbXCIzMzNcIiwgNl0sXHJcbiAgICAgICAgW1wiMzM0XCIsIDZdLFxyXG4gICAgICAgIFtcIjMzNVwiLCA2XSxcclxuICAgICAgICBbXCIzMzZcIiwgNl0sXHJcbiAgICAgICAgW1wiMzQwXCIsIDZdLFxyXG4gICAgICAgIFtcIjM0MVwiLCA2XSxcclxuICAgICAgICBbXCIzNDJcIiwgNl0sXHJcbiAgICAgICAgW1wiMzQzXCIsIDZdLFxyXG4gICAgICAgIFtcIjM0NFwiLCA2XSxcclxuICAgICAgICBbXCIzNDVcIiwgNl0sXHJcbiAgICAgICAgW1wiMzQ2XCIsIDZdLFxyXG4gICAgICAgIFtcIjM0N1wiLCA2XSxcclxuICAgICAgICBbXCIzNDhcIiwgNl0sXHJcbiAgICAgICAgW1wiMzQ5XCIsIDZdLFxyXG4gICAgICAgIFtcIjM1MFwiLCA2XSxcclxuICAgICAgICBbXCIzNTFcIiwgNl0sXHJcbiAgICAgICAgW1wiMzUyXCIsIDZdLFxyXG4gICAgICAgIFtcIjM1M1wiLCA2XSxcclxuICAgICAgICBbXCIzNTRcIiwgNl0sXHJcbiAgICAgICAgW1wiMzU1XCIsIDZdLFxyXG4gICAgICAgIFtcIjM1NlwiLCA2XSxcclxuICAgICAgICBbXCIzNTdcIiwgNl0sXHJcbiAgICAgICAgW1wiMzYwXCIsIDZdLFxyXG4gICAgICAgIFtcIjM2MVwiLCA2XSxcclxuICAgICAgICBbXCIzNjJcIiwgNl0sXHJcbiAgICAgICAgW1wiMzYzXCIsIDZdLFxyXG4gICAgICAgIFtcIjM2NFwiLCA2XSxcclxuICAgICAgICBbXCIzNjVcIiwgNl0sXHJcbiAgICAgICAgW1wiMzY2XCIsIDZdLFxyXG4gICAgICAgIFtcIjM2N1wiLCA2XSxcclxuICAgICAgICBbXCIzNjhcIiwgNl0sXHJcbiAgICAgICAgW1wiMzY5XCIsIDZdLFxyXG4gICAgICAgIFtcIjM5MFwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE1XSxcclxuICAgICAgICBbXCIzOTFcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxOF0sXHJcbiAgICAgICAgW1wiMzkyXCIsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMTVdLFxyXG4gICAgICAgIFtcIjM5M1wiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDE4XSxcclxuICAgICAgICBbXCI3MDNcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICBdO1xyXG4gICAgRmllbGRQYXJzZXIuRk9VUl9ESUdJVF9EQVRBX0xFTkdUSCA9IFtcclxuICAgICAgICAvLyBTYW1lIGZvcm1hdCBhcyBhYm92ZVxyXG4gICAgICAgIFtcIjcwMDFcIiwgMTNdLFxyXG4gICAgICAgIFtcIjcwMDJcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiNzAwM1wiLCAxMF0sXHJcbiAgICAgICAgW1wiODAwMVwiLCAxNF0sXHJcbiAgICAgICAgW1wiODAwMlwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDIwXSxcclxuICAgICAgICBbXCI4MDAzXCIsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxyXG4gICAgICAgIFtcIjgwMDRcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAzMF0sXHJcbiAgICAgICAgW1wiODAwNVwiLCA2XSxcclxuICAgICAgICBbXCI4MDA2XCIsIDE4XSxcclxuICAgICAgICBbXCI4MDA3XCIsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgMzBdLFxyXG4gICAgICAgIFtcIjgwMDhcIiwgRmllbGRQYXJzZXIuVkFSSUFCTEVfTEVOR1RILCAxMl0sXHJcbiAgICAgICAgW1wiODAxOFwiLCAxOF0sXHJcbiAgICAgICAgW1wiODAyMFwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDI1XSxcclxuICAgICAgICBbXCI4MTAwXCIsIDZdLFxyXG4gICAgICAgIFtcIjgxMDFcIiwgMTBdLFxyXG4gICAgICAgIFtcIjgxMDJcIiwgMl0sXHJcbiAgICAgICAgW1wiODExMFwiLCBGaWVsZFBhcnNlci5WQVJJQUJMRV9MRU5HVEgsIDcwXSxcclxuICAgICAgICBbXCI4MjAwXCIsIEZpZWxkUGFyc2VyLlZBUklBQkxFX0xFTkdUSCwgNzBdLFxyXG4gICAgXTtcclxuICAgIHJldHVybiBGaWVsZFBhcnNlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRmllbGRQYXJzZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpZWxkUGFyc2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBGb3JtYXRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9Gb3JtYXRFeGNlcHRpb25cIik7XHJcbnZhciBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9JbGxlZ2FsU3RhdGVFeGNlcHRpb25cIik7XHJcbnZhciBTdHJpbmdCdWlsZGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vdXRpbC9TdHJpbmdCdWlsZGVyXCIpO1xyXG52YXIgRGVjb2RlZENoYXJfMSA9IHJlcXVpcmUoXCIuL0RlY29kZWRDaGFyXCIpO1xyXG52YXIgRGVjb2RlZE51bWVyaWNfMSA9IHJlcXVpcmUoXCIuL0RlY29kZWROdW1lcmljXCIpO1xyXG52YXIgRGVjb2RlZEluZm9ybWF0aW9uXzEgPSByZXF1aXJlKFwiLi9EZWNvZGVkSW5mb3JtYXRpb25cIik7XHJcbnZhciBGaWVsZFBhcnNlcl8xID0gcmVxdWlyZShcIi4vRmllbGRQYXJzZXJcIik7XHJcbnZhciBCbG9ja1BhcnNlZFJlc3VsdF8xID0gcmVxdWlyZShcIi4vQmxvY2tQYXJzZWRSZXN1bHRcIik7XHJcbnZhciBHZW5lcmFsQXBwSWREZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR2VuZXJhbEFwcElkRGVjb2RlcihpbmZvcm1hdGlvbikge1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy5pbmZvcm1hdGlvbiA9IGluZm9ybWF0aW9uO1xyXG4gICAgfVxyXG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlQWxsQ29kZXMgPSBmdW5jdGlvbiAoYnVmZiwgaW5pdGlhbFBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IGluaXRpYWxQb3NpdGlvbjtcclxuICAgICAgICB2YXIgcmVtYWluaW5nID0gbnVsbDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHZhciBpbmZvID0gdGhpcy5kZWNvZGVHZW5lcmFsUHVycG9zZUZpZWxkKGN1cnJlbnRQb3NpdGlvbiwgcmVtYWluaW5nKTtcclxuICAgICAgICAgICAgdmFyIHBhcnNlZEZpZWxkcyA9IEZpZWxkUGFyc2VyXzEuZGVmYXVsdC5wYXJzZUZpZWxkc0luR2VuZXJhbFB1cnBvc2UoaW5mby5nZXROZXdTdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZWRGaWVsZHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgYnVmZi5hcHBlbmQocGFyc2VkRmllbGRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaW5mby5pc1JlbWFpbmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgPSBcIlwiICsgaW5mby5nZXRSZW1haW5pbmdWYWx1ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVtYWluaW5nID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uID09IGluZm8uZ2V0TmV3UG9zaXRpb24oKSkgeyAvLyBObyBzdGVwIGZvcndhcmQhXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50UG9zaXRpb24gPSBpbmZvLmdldE5ld1Bvc2l0aW9uKCk7XHJcbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmYudG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICBHZW5lcmFsQXBwSWREZWNvZGVyLnByb3RvdHlwZS5pc1N0aWxsTnVtZXJpYyA9IGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgICAvLyBJdCdzIG51bWVyaWMgaWYgaXQgc3RpbGwgaGFzIDcgcG9zaXRpb25zXHJcbiAgICAgICAgLy8gYW5kIG9uZSBvZiB0aGUgZmlyc3QgNCBiaXRzIGlzIFwiMVwiLlxyXG4gICAgICAgIGlmIChwb3MgKyA3ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvcyArIDQgPD0gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBwb3MgKyAzOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5mb3JtYXRpb24uZ2V0KGkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbmZvcm1hdGlvbi5nZXQocG9zICsgMyk7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlTnVtZXJpYyA9IGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgICBpZiAocG9zICsgNyA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1lcmljXzEgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA0KTtcclxuICAgICAgICAgICAgaWYgKG51bWVyaWNfMSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWROdW1lcmljXzEuZGVmYXVsdCh0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSwgRGVjb2RlZE51bWVyaWNfMS5kZWZhdWx0LkZOQzEsIERlY29kZWROdW1lcmljXzEuZGVmYXVsdC5GTkMxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWROdW1lcmljXzEuZGVmYXVsdCh0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSwgbnVtZXJpY18xIC0gMSwgRGVjb2RlZE51bWVyaWNfMS5kZWZhdWx0LkZOQzEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbnVtZXJpYyA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDcpO1xyXG4gICAgICAgIHZhciBkaWdpdDEgPSAobnVtZXJpYyAtIDgpIC8gMTE7XHJcbiAgICAgICAgdmFyIGRpZ2l0MiA9IChudW1lcmljIC0gOCkgJSAxMTtcclxuICAgICAgICByZXR1cm4gbmV3IERlY29kZWROdW1lcmljXzEuZGVmYXVsdChwb3MgKyA3LCBkaWdpdDEsIGRpZ2l0Mik7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5wcm90b3R5cGUuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheSA9IGZ1bmN0aW9uIChwb3MsIGJpdHMpIHtcclxuICAgICAgICByZXR1cm4gR2VuZXJhbEFwcElkRGVjb2Rlci5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHRoaXMuaW5mb3JtYXRpb24sIHBvcywgYml0cyk7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5ID0gZnVuY3Rpb24gKGluZm9ybWF0aW9uLCBwb3MsIGJpdHMpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYml0czsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmZvcm1hdGlvbi5nZXQocG9zICsgaSkpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlIHw9IDEgPDwgKGJpdHMgLSBpIC0gMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuICAgIEdlbmVyYWxBcHBJZERlY29kZXIucHJvdG90eXBlLmRlY29kZUdlbmVyYWxQdXJwb3NlRmllbGQgPSBmdW5jdGlvbiAocG9zLCByZW1haW5pbmcpIHtcclxuICAgICAgICAvL3RoaXMuYnVmZmVyLnNldExlbmd0aCgwKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlci5zZXRMZW5ndGhUb1plcm8oKTtcclxuICAgICAgICBpZiAocmVtYWluaW5nICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKHJlbWFpbmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudC5zZXRQb3NpdGlvbihwb3MpO1xyXG4gICAgICAgIHZhciBsYXN0RGVjb2RlZCA9IHRoaXMucGFyc2VCbG9ja3MoKTtcclxuICAgICAgICBpZiAobGFzdERlY29kZWQgIT0gbnVsbCAmJiBsYXN0RGVjb2RlZC5pc1JlbWFpbmluZygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZEluZm9ybWF0aW9uXzEuZGVmYXVsdCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSwgbGFzdERlY29kZWQuZ2V0UmVtYWluaW5nVmFsdWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRGVjb2RlZEluZm9ybWF0aW9uXzEuZGVmYXVsdCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5wcm90b3R5cGUucGFyc2VCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlzRmluaXNoZWQ7XHJcbiAgICAgICAgdmFyIHJlc3VsdDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHZhciBpbml0aWFsUG9zaXRpb24gPSB0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5pc0FscGhhKCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VBbHBoYUJsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICBpc0ZpbmlzaGVkID0gcmVzdWx0LmlzRmluaXNoZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnJlbnQuaXNJc29JZWM2NDYoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wYXJzZUlzb0llYzY0NkJsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICBpc0ZpbmlzaGVkID0gcmVzdWx0LmlzRmluaXNoZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgLy8gaXQgbXVzdCBiZSBudW1lcmljXHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnBhcnNlTnVtZXJpY0Jsb2NrKCk7XHJcbiAgICAgICAgICAgICAgICBpc0ZpbmlzaGVkID0gcmVzdWx0LmlzRmluaXNoZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcG9zaXRpb25DaGFuZ2VkID0gaW5pdGlhbFBvc2l0aW9uICE9IHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpO1xyXG4gICAgICAgICAgICBpZiAoIXBvc2l0aW9uQ2hhbmdlZCAmJiAhaXNGaW5pc2hlZCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICghaXNGaW5pc2hlZCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5nZXREZWNvZGVkSW5mb3JtYXRpb24oKTtcclxuICAgIH07XHJcbiAgICBHZW5lcmFsQXBwSWREZWNvZGVyLnByb3RvdHlwZS5wYXJzZU51bWVyaWNCbG9jayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5pc1N0aWxsTnVtZXJpYyh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcclxuICAgICAgICAgICAgdmFyIG51bWVyaWMgPSB0aGlzLmRlY29kZU51bWVyaWModGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24obnVtZXJpYy5nZXROZXdQb3NpdGlvbigpKTtcclxuICAgICAgICAgICAgaWYgKG51bWVyaWMuaXNGaXJzdERpZ2l0Rk5DMSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5mb3JtYXRpb24gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVtZXJpYy5pc1NlY29uZERpZ2l0Rk5DMSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uXzEuZGVmYXVsdCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbmZvcm1hdGlvbiA9IG5ldyBEZWNvZGVkSW5mb3JtYXRpb25fMS5kZWZhdWx0KHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpLCB0aGlzLmJ1ZmZlci50b1N0cmluZygpLCBudW1lcmljLmdldFNlY29uZERpZ2l0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdF8xLmRlZmF1bHQodHJ1ZSwgaW5mb3JtYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChudW1lcmljLmdldEZpcnN0RGlnaXQoKSk7XHJcbiAgICAgICAgICAgIGlmIChudW1lcmljLmlzU2Vjb25kRGlnaXRGTkMxKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmZvcm1hdGlvbiA9IG5ldyBEZWNvZGVkSW5mb3JtYXRpb25fMS5kZWZhdWx0KHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpLCB0aGlzLmJ1ZmZlci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHRfMS5kZWZhdWx0KHRydWUsIGluZm9ybWF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5hcHBlbmQobnVtZXJpYy5nZXRTZWNvbmREaWdpdCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNOdW1lcmljVG9BbHBoYU51bWVyaWNMYXRjaCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldEFscGhhKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbig0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdF8xLmRlZmF1bHQoZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIEdlbmVyYWxBcHBJZERlY29kZXIucHJvdG90eXBlLnBhcnNlSXNvSWVjNjQ2QmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNTdGlsbElzb0llYzY0Nih0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcclxuICAgICAgICAgICAgdmFyIGlzbyA9IHRoaXMuZGVjb2RlSXNvSWVjNjQ2KHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldFBvc2l0aW9uKGlzby5nZXROZXdQb3NpdGlvbigpKTtcclxuICAgICAgICAgICAgaWYgKGlzby5pc0ZOQzEoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZm9ybWF0aW9uID0gbmV3IERlY29kZWRJbmZvcm1hdGlvbl8xLmRlZmF1bHQodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCksIHRoaXMuYnVmZmVyLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdF8xLmRlZmF1bHQodHJ1ZSwgaW5mb3JtYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLmFwcGVuZChpc28uZ2V0VmFsdWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQWxwaGFPcjY0NlRvTnVtZXJpY0xhdGNoKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuaW5jcmVtZW50UG9zaXRpb24oMyk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXROdW1lcmljKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNBbHBoYVRvNjQ2VG9BbHBoYUxhdGNoKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50LmdldFBvc2l0aW9uKCkgKyA1IDwgdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5pbmNyZW1lbnRQb3NpdGlvbig1KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRQb3NpdGlvbih0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNldEFscGhhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQmxvY2tQYXJzZWRSZXN1bHRfMS5kZWZhdWx0KGZhbHNlKTtcclxuICAgIH07XHJcbiAgICBHZW5lcmFsQXBwSWREZWNvZGVyLnByb3RvdHlwZS5wYXJzZUFscGhhQmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNTdGlsbEFscGhhKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpKSkge1xyXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSB0aGlzLmRlY29kZUFscGhhbnVtZXJpYyh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRQb3NpdGlvbihhbHBoYS5nZXROZXdQb3NpdGlvbigpKTtcclxuICAgICAgICAgICAgaWYgKGFscGhhLmlzRk5DMSgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5mb3JtYXRpb24gPSBuZXcgRGVjb2RlZEluZm9ybWF0aW9uXzEuZGVmYXVsdCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSwgdGhpcy5idWZmZXIudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJsb2NrUGFyc2VkUmVzdWx0XzEuZGVmYXVsdCh0cnVlLCBpbmZvcm1hdGlvbik7IC8vZW5kIG9mIHRoZSBjaGFyIGJsb2NrXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5idWZmZXIuYXBwZW5kKGFscGhhLmdldFZhbHVlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0FscGhhT3I2NDZUb051bWVyaWNMYXRjaCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LmluY3JlbWVudFBvc2l0aW9uKDMpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0TnVtZXJpYygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzQWxwaGFUbzY0NlRvQWxwaGFMYXRjaCh0aGlzLmN1cnJlbnQuZ2V0UG9zaXRpb24oKSkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5nZXRQb3NpdGlvbigpICsgNSA8IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuaW5jcmVtZW50UG9zaXRpb24oNSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQuc2V0UG9zaXRpb24odGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zZXRJc29JZWM2NDYoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1BhcnNlZFJlc3VsdF8xLmRlZmF1bHQoZmFsc2UpO1xyXG4gICAgfTtcclxuICAgIEdlbmVyYWxBcHBJZERlY29kZXIucHJvdG90eXBlLmlzU3RpbGxJc29JZWM2NDYgPSBmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgaWYgKHBvcyArIDUgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaXZlQml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA1KTtcclxuICAgICAgICBpZiAoZml2ZUJpdFZhbHVlID49IDUgJiYgZml2ZUJpdFZhbHVlIDwgMTYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3MgKyA3ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2V2ZW5CaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDcpO1xyXG4gICAgICAgIGlmIChzZXZlbkJpdFZhbHVlID49IDY0ICYmIHNldmVuQml0VmFsdWUgPCAxMTYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3MgKyA4ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZWlnaHRCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDgpO1xyXG4gICAgICAgIHJldHVybiBlaWdodEJpdFZhbHVlID49IDIzMiAmJiBlaWdodEJpdFZhbHVlIDwgMjUzO1xyXG4gICAgfTtcclxuICAgIEdlbmVyYWxBcHBJZERlY29kZXIucHJvdG90eXBlLmRlY29kZUlzb0llYzY0NiA9IGZ1bmN0aW9uIChwb3MpIHtcclxuICAgICAgICB2YXIgZml2ZUJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNSk7XHJcbiAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA9PSAxNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyXzEuZGVmYXVsdChwb3MgKyA1LCBEZWNvZGVkQ2hhcl8xLmRlZmF1bHQuRk5DMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaXZlQml0VmFsdWUgPj0gNSAmJiBmaXZlQml0VmFsdWUgPCAxNSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyXzEuZGVmYXVsdChwb3MgKyA1LCAoJzAnICsgKGZpdmVCaXRWYWx1ZSAtIDUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZXZlbkJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNyk7XHJcbiAgICAgICAgaWYgKHNldmVuQml0VmFsdWUgPj0gNjQgJiYgc2V2ZW5CaXRWYWx1ZSA8IDkwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXJfMS5kZWZhdWx0KHBvcyArIDcsIChcIlwiICsgKHNldmVuQml0VmFsdWUgKyAxKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2V2ZW5CaXRWYWx1ZSA+PSA5MCAmJiBzZXZlbkJpdFZhbHVlIDwgMTE2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXJfMS5kZWZhdWx0KHBvcyArIDcsIChcIlwiICsgKHNldmVuQml0VmFsdWUgKyA3KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZWlnaHRCaXRWYWx1ZSA9IHRoaXMuZXh0cmFjdE51bWVyaWNWYWx1ZUZyb21CaXRBcnJheShwb3MsIDgpO1xyXG4gICAgICAgIHZhciBjO1xyXG4gICAgICAgIHN3aXRjaCAoZWlnaHRCaXRWYWx1ZSkge1xyXG4gICAgICAgICAgICBjYXNlIDIzMjpcclxuICAgICAgICAgICAgICAgIGMgPSAnISc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyMzM6XHJcbiAgICAgICAgICAgICAgICBjID0gJ1wiJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIzNDpcclxuICAgICAgICAgICAgICAgIGMgPSAnJSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyMzU6XHJcbiAgICAgICAgICAgICAgICBjID0gJyYnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjM2OlxyXG4gICAgICAgICAgICAgICAgYyA9ICdcXCcnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjM3OlxyXG4gICAgICAgICAgICAgICAgYyA9ICcoJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIzODpcclxuICAgICAgICAgICAgICAgIGMgPSAnKSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyMzk6XHJcbiAgICAgICAgICAgICAgICBjID0gJyonO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjQwOlxyXG4gICAgICAgICAgICAgICAgYyA9ICcrJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI0MTpcclxuICAgICAgICAgICAgICAgIGMgPSAnLCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyNDI6XHJcbiAgICAgICAgICAgICAgICBjID0gJy0nO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjQzOlxyXG4gICAgICAgICAgICAgICAgYyA9ICcuJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI0NDpcclxuICAgICAgICAgICAgICAgIGMgPSAnLyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyNDU6XHJcbiAgICAgICAgICAgICAgICBjID0gJzonO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjQ2OlxyXG4gICAgICAgICAgICAgICAgYyA9ICc7JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI0NzpcclxuICAgICAgICAgICAgICAgIGMgPSAnPCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyNDg6XHJcbiAgICAgICAgICAgICAgICBjID0gJz0nO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjQ5OlxyXG4gICAgICAgICAgICAgICAgYyA9ICc+JztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI1MDpcclxuICAgICAgICAgICAgICAgIGMgPSAnPyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAyNTE6XHJcbiAgICAgICAgICAgICAgICBjID0gJ18nO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjUyOlxyXG4gICAgICAgICAgICAgICAgYyA9ICcgJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcl8xLmRlZmF1bHQocG9zICsgOCwgYyk7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5wcm90b3R5cGUuaXNTdGlsbEFscGhhID0gZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgIGlmIChwb3MgKyA1ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBub3cgY2hlY2sgaWYgaXQncyBhIHZhbGlkIDUtYml0IHZhbHVlICgwLi45IGFuZCBGTkMxKVxyXG4gICAgICAgIHZhciBmaXZlQml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA1KTtcclxuICAgICAgICBpZiAoZml2ZUJpdFZhbHVlID49IDUgJiYgZml2ZUJpdFZhbHVlIDwgMTYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb3MgKyA2ID4gdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2l4Qml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA2KTtcclxuICAgICAgICByZXR1cm4gc2l4Qml0VmFsdWUgPj0gMTYgJiYgc2l4Qml0VmFsdWUgPCA2MzsgLy8gNjMgbm90IGluY2x1ZGVkXHJcbiAgICB9O1xyXG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlQWxwaGFudW1lcmljID0gZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgIHZhciBmaXZlQml0VmFsdWUgPSB0aGlzLmV4dHJhY3ROdW1lcmljVmFsdWVGcm9tQml0QXJyYXkocG9zLCA1KTtcclxuICAgICAgICBpZiAoZml2ZUJpdFZhbHVlID09IDE1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXJfMS5kZWZhdWx0KHBvcyArIDUsIERlY29kZWRDaGFyXzEuZGVmYXVsdC5GTkMxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpdmVCaXRWYWx1ZSA+PSA1ICYmIGZpdmVCaXRWYWx1ZSA8IDE1KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlZENoYXJfMS5kZWZhdWx0KHBvcyArIDUsICgnMCcgKyAoZml2ZUJpdFZhbHVlIC0gNSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNpeEJpdFZhbHVlID0gdGhpcy5leHRyYWN0TnVtZXJpY1ZhbHVlRnJvbUJpdEFycmF5KHBvcywgNik7XHJcbiAgICAgICAgaWYgKHNpeEJpdFZhbHVlID49IDMyICYmIHNpeEJpdFZhbHVlIDwgNTgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVkQ2hhcl8xLmRlZmF1bHQocG9zICsgNiwgKCcnICsgKHNpeEJpdFZhbHVlICsgMzMpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjO1xyXG4gICAgICAgIHN3aXRjaCAoc2l4Qml0VmFsdWUpIHtcclxuICAgICAgICAgICAgY2FzZSA1ODpcclxuICAgICAgICAgICAgICAgIGMgPSAnKic7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA1OTpcclxuICAgICAgICAgICAgICAgIGMgPSAnLCc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MDpcclxuICAgICAgICAgICAgICAgIGMgPSAnLSc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MTpcclxuICAgICAgICAgICAgICAgIGMgPSAnLic7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA2MjpcclxuICAgICAgICAgICAgICAgIGMgPSAnLyc7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMS5kZWZhdWx0KFwiRGVjb2RpbmcgaW52YWxpZCBhbHBoYW51bWVyaWMgdmFsdWU6IFwiICsgc2l4Qml0VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IERlY29kZWRDaGFyXzEuZGVmYXVsdChwb3MgKyA2LCBjKTtcclxuICAgIH07XHJcbiAgICBHZW5lcmFsQXBwSWREZWNvZGVyLnByb3RvdHlwZS5pc0FscGhhVG82NDZUb0FscGhhTGF0Y2ggPSBmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgaWYgKHBvcyArIDEgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNSAmJiBpICsgcG9zIDwgdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCk7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoaSA9PSAyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW5mb3JtYXRpb24uZ2V0KHBvcyArIDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaW5mb3JtYXRpb24uZ2V0KHBvcyArIGkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgR2VuZXJhbEFwcElkRGVjb2Rlci5wcm90b3R5cGUuaXNBbHBoYU9yNjQ2VG9OdW1lcmljTGF0Y2ggPSBmdW5jdGlvbiAocG9zKSB7XHJcbiAgICAgICAgLy8gTmV4dCBpcyBhbHBoYW51bWVyaWMgaWYgdGhlcmUgYXJlIDMgcG9zaXRpb25zIGFuZCB0aGV5IGFyZSBhbGwgemVyb3NcclxuICAgICAgICBpZiAocG9zICsgMyA+IHRoaXMuaW5mb3JtYXRpb24uZ2V0U2l6ZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IHBvcyArIDM7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvcm1hdGlvbi5nZXQoaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBHZW5lcmFsQXBwSWREZWNvZGVyLnByb3RvdHlwZS5pc051bWVyaWNUb0FscGhhTnVtZXJpY0xhdGNoID0gZnVuY3Rpb24gKHBvcykge1xyXG4gICAgICAgIC8vIE5leHQgaXMgYWxwaGFudW1lcmljIGlmIHRoZXJlIGFyZSA0IHBvc2l0aW9ucyBhbmQgdGhleSBhcmUgYWxsIHplcm9zLCBvclxyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc3Vic2V0IG9mIHRoaXMganVzdCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgc3ltYm9sXHJcbiAgICAgICAgaWYgKHBvcyArIDEgPiB0aGlzLmluZm9ybWF0aW9uLmdldFNpemUoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNCAmJiBpICsgcG9zIDwgdGhpcy5pbmZvcm1hdGlvbi5nZXRTaXplKCk7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pbmZvcm1hdGlvbi5nZXQocG9zICsgaSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gR2VuZXJhbEFwcElkRGVjb2RlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gR2VuZXJhbEFwcElkRGVjb2RlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2VuZXJhbEFwcElkRGVjb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXHJcbipcclxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cclxuLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNztcclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBpbXBvcnQgamF2YS51dGlsLkFycmF5cztcclxudmFyIEFycmF5c18xID0gcmVxdWlyZShcIi4uL3V0aWwvQXJyYXlzXCIpO1xyXG4vLyBpbXBvcnQgamF2YS51dGlsLkNvbGxlY3Rpb247XHJcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLmNvbW1vbi5kZXRlY3Rvci5NYXRoVXRpbHM7XHJcbnZhciBNYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZGV0ZWN0b3IvTWF0aFV0aWxzXCIpO1xyXG4vKipcclxuICogQGF1dGhvciBTSVRBIExhYiAoa2V2aW4ub3N1bGxpdmFuQHNpdGEuYWVybylcclxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XHJcbiAqL1xyXG52YXIgUERGNDE3Q29tbW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUERGNDE3Q29tbW9uKCkge1xyXG4gICAgfVxyXG4gICAgUERGNDE3Q29tbW9uLnByb3RvdHlwZS5QREY0MTdDb21tb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbW9kdWxlQml0Q291bnQgdmFsdWVzIHRvIHN1bVxyXG4gICAgICogQHJldHVybiBzdW0gb2YgdmFsdWVzXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBjYWxsIHtAbGluayBNYXRoVXRpbHMjc3VtKGludFtdKX1cclxuICAgICAqL1xyXG4gICAgLy8gQERlcHJlY2F0ZWRcclxuICAgIFBERjQxN0NvbW1vbi5nZXRCaXRDb3VudFN1bSA9IGZ1bmN0aW9uIChtb2R1bGVCaXRDb3VudCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoVXRpbHNfMS5kZWZhdWx0LnN1bShtb2R1bGVCaXRDb3VudCk7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3Q29tbW9uLnRvSW50QXJyYXkgPSBmdW5jdGlvbiAobGlzdCkge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIGlmIChsaXN0ID09IG51bGwgfHwgIWxpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQREY0MTdDb21tb24uRU1QVFlfSU5UX0FSUkFZO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkobGlzdC5sZW5ndGgpO1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBsaXN0XzEgPSBfX3ZhbHVlcyhsaXN0KSwgbGlzdF8xXzEgPSBsaXN0XzEubmV4dCgpOyAhbGlzdF8xXzEuZG9uZTsgbGlzdF8xXzEgPSBsaXN0XzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW50ZWdlciA9IGxpc3RfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2krK10gPSBpbnRlZ2VyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdF8xXzEgJiYgIWxpc3RfMV8xLmRvbmUgJiYgKF9hID0gbGlzdF8xLnJldHVybikpIF9hLmNhbGwobGlzdF8xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gc3ltYm9sIGVuY29kZWQgc3ltYm9sIHRvIHRyYW5zbGF0ZSB0byBhIGNvZGV3b3JkXHJcbiAgICAgKiBAcmV0dXJuIHRoZSBjb2Rld29yZCBjb3JyZXNwb25kaW5nIHRvIHRoZSBzeW1ib2wuXHJcbiAgICAgKi9cclxuICAgIFBERjQxN0NvbW1vbi5nZXRDb2Rld29yZCA9IGZ1bmN0aW9uIChzeW1ib2wgLyppbnQqLykge1xyXG4gICAgICAgIHZhciBpID0gQXJyYXlzXzEuZGVmYXVsdC5iaW5hcnlTZWFyY2goUERGNDE3Q29tbW9uLlNZTUJPTF9UQUJMRSwgc3ltYm9sICYgMHgzRkZGRik7XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChQREY0MTdDb21tb24uQ09ERVdPUkRfVEFCTEVbaV0gLSAxKSAlIFBERjQxN0NvbW1vbi5OVU1CRVJfT0ZfQ09ERVdPUkRTO1xyXG4gICAgfTtcclxuICAgIFBERjQxN0NvbW1vbi5OVU1CRVJfT0ZfQ09ERVdPUkRTID0gOTI5O1xyXG4gICAgLy8gTWF4aW11bSBDb2Rld29yZHMgKERhdGEgKyBFcnJvcikuXHJcbiAgICBQREY0MTdDb21tb24uTUFYX0NPREVXT1JEU19JTl9CQVJDT0RFID0gUERGNDE3Q29tbW9uLk5VTUJFUl9PRl9DT0RFV09SRFMgLSAxO1xyXG4gICAgUERGNDE3Q29tbW9uLk1JTl9ST1dTX0lOX0JBUkNPREUgPSAzO1xyXG4gICAgUERGNDE3Q29tbW9uLk1BWF9ST1dTX0lOX0JBUkNPREUgPSA5MDtcclxuICAgIC8vIE9uZSBsZWZ0IHJvdyBpbmRpY2F0aW9uIGNvbHVtbiArIG1heCAzMCBkYXRhIGNvbHVtbnMgKyBvbmUgcmlnaHQgcm93IGluZGljYXRvciBjb2x1bW5cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgLypmaW5hbCovIE1BWF9DT0RFV09SRFNfSU5fUk9XOiAvKmludCovIG51bWJlciA9IDMyO1xyXG4gICAgUERGNDE3Q29tbW9uLk1PRFVMRVNfSU5fQ09ERVdPUkQgPSAxNztcclxuICAgIFBERjQxN0NvbW1vbi5NT0RVTEVTX0lOX1NUT1BfUEFUVEVSTiA9IDE4O1xyXG4gICAgUERGNDE3Q29tbW9uLkJBUlNfSU5fTU9EVUxFID0gODtcclxuICAgIFBERjQxN0NvbW1vbi5FTVBUWV9JTlRfQVJSQVkgPSBuZXcgSW50MzJBcnJheShbXSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzb3J0ZWQgdGFibGUgb2YgYWxsIHBvc3NpYmxlIHN5bWJvbHMuIEV4dHJhY3RlZCBmcm9tIHRoZSBQREY0MTdcclxuICAgICAqIHNwZWNpZmljYXRpb24uIFRoZSBpbmRleCBvZiBhIHN5bWJvbCBpbiB0aGlzIHRhYmxlIGNvcnJlc3BvbmRzIHRvIHRoZVxyXG4gICAgICogaW5kZXggaW50byB0aGUgY29kZXdvcmQgdGFibGUuXHJcbiAgICAgKi9cclxuICAgIFBERjQxN0NvbW1vbi5TWU1CT0xfVEFCTEUgPSBJbnQzMkFycmF5LmZyb20oW1xyXG4gICAgICAgIDB4MTAyNWUsIDB4MTAyN2EsIDB4MTAyOWUsIDB4MTAyYmMsIDB4MTAyZjIsIDB4MTAyZjQsIDB4MTAzMmUsIDB4MTAzNGUsIDB4MTAzNWMsIDB4MTAzOTYsIDB4MTAzYTYsIDB4MTAzYWMsXHJcbiAgICAgICAgMHgxMDQyMiwgMHgxMDQyOCwgMHgxMDQzNiwgMHgxMDQ0MiwgMHgxMDQ0NCwgMHgxMDQ0OCwgMHgxMDQ1MCwgMHgxMDQ1ZSwgMHgxMDQ2NiwgMHgxMDQ2YywgMHgxMDQ3YSwgMHgxMDQ4MixcclxuICAgICAgICAweDEwNDllLCAweDEwNGEwLCAweDEwNGJjLCAweDEwNGM2LCAweDEwNGQ4LCAweDEwNGVlLCAweDEwNGYyLCAweDEwNGY0LCAweDEwNTA0LCAweDEwNTA4LCAweDEwNTEwLCAweDEwNTFlLFxyXG4gICAgICAgIDB4MTA1MjAsIDB4MTA1M2MsIDB4MTA1NDAsIDB4MTA1NzgsIDB4MTA1ODYsIDB4MTA1OGMsIDB4MTA1OTgsIDB4MTA1YjAsIDB4MTA1YmUsIDB4MTA1Y2UsIDB4MTA1ZGMsIDB4MTA1ZTIsXHJcbiAgICAgICAgMHgxMDVlNCwgMHgxMDVlOCwgMHgxMDVmNiwgMHgxMDYyZSwgMHgxMDY0ZSwgMHgxMDY1YywgMHgxMDY4ZSwgMHgxMDY5YywgMHgxMDZiOCwgMHgxMDZkZSwgMHgxMDZmYSwgMHgxMDcxNixcclxuICAgICAgICAweDEwNzI2LCAweDEwNzJjLCAweDEwNzQ2LCAweDEwNzRjLCAweDEwNzU4LCAweDEwNzZlLCAweDEwNzkyLCAweDEwNzk0LCAweDEwN2EyLCAweDEwN2E0LCAweDEwN2E4LCAweDEwN2I2LFxyXG4gICAgICAgIDB4MTA4MjIsIDB4MTA4MjgsIDB4MTA4NDIsIDB4MTA4NDgsIDB4MTA4NTAsIDB4MTA4NWUsIDB4MTA4NjYsIDB4MTA4NmMsIDB4MTA4N2EsIDB4MTA4ODIsIDB4MTA4ODQsIDB4MTA4OTAsXHJcbiAgICAgICAgMHgxMDg5ZSwgMHgxMDhhMCwgMHgxMDhiYywgMHgxMDhjNiwgMHgxMDhjYywgMHgxMDhkOCwgMHgxMDhlZSwgMHgxMDhmMiwgMHgxMDhmNCwgMHgxMDkwMiwgMHgxMDkwOCwgMHgxMDkxZSxcclxuICAgICAgICAweDEwOTIwLCAweDEwOTNjLCAweDEwOTQwLCAweDEwOTc4LCAweDEwOTg2LCAweDEwOTk4LCAweDEwOWIwLCAweDEwOWJlLCAweDEwOWNlLCAweDEwOWRjLCAweDEwOWUyLCAweDEwOWU0LFxyXG4gICAgICAgIDB4MTA5ZTgsIDB4MTA5ZjYsIDB4MTBhMDgsIDB4MTBhMTAsIDB4MTBhMWUsIDB4MTBhMjAsIDB4MTBhM2MsIDB4MTBhNDAsIDB4MTBhNzgsIDB4MTBhZjAsIDB4MTBiMDYsIDB4MTBiMGMsXHJcbiAgICAgICAgMHgxMGIxOCwgMHgxMGIzMCwgMHgxMGIzZSwgMHgxMGI2MCwgMHgxMGI3YywgMHgxMGI4ZSwgMHgxMGI5YywgMHgxMGJiOCwgMHgxMGJjMiwgMHgxMGJjNCwgMHgxMGJjOCwgMHgxMGJkMCxcclxuICAgICAgICAweDEwYmRlLCAweDEwYmU2LCAweDEwYmVjLCAweDEwYzJlLCAweDEwYzRlLCAweDEwYzVjLCAweDEwYzYyLCAweDEwYzY0LCAweDEwYzY4LCAweDEwYzc2LCAweDEwYzhlLCAweDEwYzljLFxyXG4gICAgICAgIDB4MTBjYjgsIDB4MTBjYzIsIDB4MTBjYzQsIDB4MTBjYzgsIDB4MTBjZDAsIDB4MTBjZGUsIDB4MTBjZTYsIDB4MTBjZWMsIDB4MTBjZmEsIDB4MTBkMGUsIDB4MTBkMWMsIDB4MTBkMzgsXHJcbiAgICAgICAgMHgxMGQ3MCwgMHgxMGQ3ZSwgMHgxMGQ4MiwgMHgxMGQ4NCwgMHgxMGQ4OCwgMHgxMGQ5MCwgMHgxMGQ5ZSwgMHgxMGRhMCwgMHgxMGRiYywgMHgxMGRjNiwgMHgxMGRjYywgMHgxMGRkOCxcclxuICAgICAgICAweDEwZGVlLCAweDEwZGYyLCAweDEwZGY0LCAweDEwZTE2LCAweDEwZTI2LCAweDEwZTJjLCAweDEwZTQ2LCAweDEwZTU4LCAweDEwZTZlLCAweDEwZTg2LCAweDEwZThjLCAweDEwZTk4LFxyXG4gICAgICAgIDB4MTBlYjAsIDB4MTBlYmUsIDB4MTBlY2UsIDB4MTBlZGMsIDB4MTBmMGEsIDB4MTBmMTIsIDB4MTBmMTQsIDB4MTBmMjIsIDB4MTBmMjgsIDB4MTBmMzYsIDB4MTBmNDIsIDB4MTBmNDQsXHJcbiAgICAgICAgMHgxMGY0OCwgMHgxMGY1MCwgMHgxMGY1ZSwgMHgxMGY2NiwgMHgxMGY2YywgMHgxMGZiMiwgMHgxMGZiNCwgMHgxMTAyMiwgMHgxMTAyOCwgMHgxMTA0MiwgMHgxMTA0OCwgMHgxMTA1MCxcclxuICAgICAgICAweDExMDVlLCAweDExMDdhLCAweDExMDgyLCAweDExMDg0LCAweDExMDkwLCAweDExMDllLCAweDExMGEwLCAweDExMGJjLCAweDExMGM2LCAweDExMGNjLCAweDExMGQ4LCAweDExMGVlLFxyXG4gICAgICAgIDB4MTEwZjIsIDB4MTEwZjQsIDB4MTExMDIsIDB4MTExMWUsIDB4MTExMjAsIDB4MTExM2MsIDB4MTExNDAsIDB4MTExNzgsIDB4MTExODYsIDB4MTExOTgsIDB4MTExYjAsIDB4MTExYmUsXHJcbiAgICAgICAgMHgxMTFjZSwgMHgxMTFkYywgMHgxMTFlMiwgMHgxMTFlNCwgMHgxMTFlOCwgMHgxMTFmNiwgMHgxMTIwOCwgMHgxMTIxZSwgMHgxMTIyMCwgMHgxMTI3OCwgMHgxMTJmMCwgMHgxMTMwYyxcclxuICAgICAgICAweDExMzMwLCAweDExMzNlLCAweDExMzYwLCAweDExMzdjLCAweDExMzhlLCAweDExMzljLCAweDExM2I4LCAweDExM2MyLCAweDExM2M4LCAweDExM2QwLCAweDExM2RlLCAweDExM2U2LFxyXG4gICAgICAgIDB4MTEzZWMsIDB4MTE0MDgsIDB4MTE0MTAsIDB4MTE0MWUsIDB4MTE0MjAsIDB4MTE0M2MsIDB4MTE0NDAsIDB4MTE0NzgsIDB4MTE0ZjAsIDB4MTE1ZTAsIDB4MTE2MGMsIDB4MTE2MTgsXHJcbiAgICAgICAgMHgxMTYzMCwgMHgxMTYzZSwgMHgxMTY2MCwgMHgxMTY3YywgMHgxMTZjMCwgMHgxMTZmOCwgMHgxMTcxYywgMHgxMTczOCwgMHgxMTc3MCwgMHgxMTc3ZSwgMHgxMTc4MiwgMHgxMTc4NCxcclxuICAgICAgICAweDExNzg4LCAweDExNzkwLCAweDExNzllLCAweDExN2EwLCAweDExN2JjLCAweDExN2M2LCAweDExN2NjLCAweDExN2Q4LCAweDExN2VlLCAweDExODJlLCAweDExODM0LCAweDExODRlLFxyXG4gICAgICAgIDB4MTE4NWMsIDB4MTE4NjIsIDB4MTE4NjQsIDB4MTE4NjgsIDB4MTE4NzYsIDB4MTE4OGUsIDB4MTE4OWMsIDB4MTE4YjgsIDB4MTE4YzIsIDB4MTE4YzgsIDB4MTE4ZDAsIDB4MTE4ZGUsXHJcbiAgICAgICAgMHgxMThlNiwgMHgxMThlYywgMHgxMThmYSwgMHgxMTkwZSwgMHgxMTkxYywgMHgxMTkzOCwgMHgxMTk3MCwgMHgxMTk3ZSwgMHgxMTk4MiwgMHgxMTk4NCwgMHgxMTk5MCwgMHgxMTk5ZSxcclxuICAgICAgICAweDExOWEwLCAweDExOWJjLCAweDExOWM2LCAweDExOWNjLCAweDExOWQ4LCAweDExOWVlLCAweDExOWYyLCAweDExOWY0LCAweDExYTBlLCAweDExYTFjLCAweDExYTM4LCAweDExYTcwLFxyXG4gICAgICAgIDB4MTFhN2UsIDB4MTFhZTAsIDB4MTFhZmMsIDB4MTFiMDgsIDB4MTFiMTAsIDB4MTFiMWUsIDB4MTFiMjAsIDB4MTFiM2MsIDB4MTFiNDAsIDB4MTFiNzgsIDB4MTFiOGMsIDB4MTFiOTgsXHJcbiAgICAgICAgMHgxMWJiMCwgMHgxMWJiZSwgMHgxMWJjZSwgMHgxMWJkYywgMHgxMWJlMiwgMHgxMWJlNCwgMHgxMWJlOCwgMHgxMWJmNiwgMHgxMWMxNiwgMHgxMWMyNiwgMHgxMWMyYywgMHgxMWM0NixcclxuICAgICAgICAweDExYzRjLCAweDExYzU4LCAweDExYzZlLCAweDExYzg2LCAweDExYzk4LCAweDExY2IwLCAweDExY2JlLCAweDExY2NlLCAweDExY2RjLCAweDExY2UyLCAweDExY2U0LCAweDExY2U4LFxyXG4gICAgICAgIDB4MTFjZjYsIDB4MTFkMDYsIDB4MTFkMGMsIDB4MTFkMTgsIDB4MTFkMzAsIDB4MTFkM2UsIDB4MTFkNjAsIDB4MTFkN2MsIDB4MTFkOGUsIDB4MTFkOWMsIDB4MTFkYjgsIDB4MTFkYzQsXHJcbiAgICAgICAgMHgxMWRjOCwgMHgxMWRkMCwgMHgxMWRkZSwgMHgxMWRlNiwgMHgxMWRlYywgMHgxMWRmYSwgMHgxMWUwYSwgMHgxMWUxMiwgMHgxMWUxNCwgMHgxMWUyMiwgMHgxMWUyNCwgMHgxMWUyOCxcclxuICAgICAgICAweDExZTM2LCAweDExZTQyLCAweDExZTQ0LCAweDExZTUwLCAweDExZTVlLCAweDExZTY2LCAweDExZTZjLCAweDExZTgyLCAweDExZTg0LCAweDExZTg4LCAweDExZTkwLCAweDExZTllLFxyXG4gICAgICAgIDB4MTFlYTAsIDB4MTFlYmMsIDB4MTFlYzYsIDB4MTFlY2MsIDB4MTFlZDgsIDB4MTFlZWUsIDB4MTFmMWEsIDB4MTFmMmUsIDB4MTFmMzIsIDB4MTFmMzQsIDB4MTFmNGUsIDB4MTFmNWMsXHJcbiAgICAgICAgMHgxMWY2MiwgMHgxMWY2NCwgMHgxMWY2OCwgMHgxMWY3NiwgMHgxMjA0OCwgMHgxMjA1ZSwgMHgxMjA4MiwgMHgxMjA4NCwgMHgxMjA5MCwgMHgxMjA5ZSwgMHgxMjBhMCwgMHgxMjBiYyxcclxuICAgICAgICAweDEyMGQ4LCAweDEyMGYyLCAweDEyMGY0LCAweDEyMTA4LCAweDEyMTFlLCAweDEyMTIwLCAweDEyMTNjLCAweDEyMTQwLCAweDEyMTc4LCAweDEyMTg2LCAweDEyMTk4LCAweDEyMWIwLFxyXG4gICAgICAgIDB4MTIxYmUsIDB4MTIxZTIsIDB4MTIxZTQsIDB4MTIxZTgsIDB4MTIxZjYsIDB4MTIyMDQsIDB4MTIyMTAsIDB4MTIyMWUsIDB4MTIyMjAsIDB4MTIyNzgsIDB4MTIyZjAsIDB4MTIzMDYsXHJcbiAgICAgICAgMHgxMjMwYywgMHgxMjMzMCwgMHgxMjMzZSwgMHgxMjM2MCwgMHgxMjM3YywgMHgxMjM4ZSwgMHgxMjM5YywgMHgxMjNiOCwgMHgxMjNjMiwgMHgxMjNjOCwgMHgxMjNkMCwgMHgxMjNlNixcclxuICAgICAgICAweDEyM2VjLCAweDEyNDFlLCAweDEyNDIwLCAweDEyNDNjLCAweDEyNGYwLCAweDEyNWUwLCAweDEyNjE4LCAweDEyNjNlLCAweDEyNjYwLCAweDEyNjdjLCAweDEyNmMwLCAweDEyNmY4LFxyXG4gICAgICAgIDB4MTI3MzgsIDB4MTI3NzAsIDB4MTI3N2UsIDB4MTI3ODIsIDB4MTI3ODQsIDB4MTI3OTAsIDB4MTI3OWUsIDB4MTI3YTAsIDB4MTI3YmMsIDB4MTI3YzYsIDB4MTI3Y2MsIDB4MTI3ZDgsXHJcbiAgICAgICAgMHgxMjdlZSwgMHgxMjgyMCwgMHgxMjgzYywgMHgxMjg0MCwgMHgxMjg3OCwgMHgxMjhmMCwgMHgxMjllMCwgMHgxMmJjMCwgMHgxMmMxOCwgMHgxMmMzMCwgMHgxMmMzZSwgMHgxMmM2MCxcclxuICAgICAgICAweDEyYzdjLCAweDEyY2MwLCAweDEyY2Y4LCAweDEyZGYwLCAweDEyZTFjLCAweDEyZTM4LCAweDEyZTcwLCAweDEyZTdlLCAweDEyZWUwLCAweDEyZWZjLCAweDEyZjA0LCAweDEyZjA4LFxyXG4gICAgICAgIDB4MTJmMTAsIDB4MTJmMjAsIDB4MTJmM2MsIDB4MTJmNDAsIDB4MTJmNzgsIDB4MTJmODYsIDB4MTJmOGMsIDB4MTJmOTgsIDB4MTJmYjAsIDB4MTJmYmUsIDB4MTJmY2UsIDB4MTJmZGMsXHJcbiAgICAgICAgMHgxMzAyZSwgMHgxMzA0ZSwgMHgxMzA1YywgMHgxMzA2MiwgMHgxMzA2OCwgMHgxMzA4ZSwgMHgxMzA5YywgMHgxMzBiOCwgMHgxMzBjMiwgMHgxMzBjOCwgMHgxMzBkMCwgMHgxMzBkZSxcclxuICAgICAgICAweDEzMGVjLCAweDEzMGZhLCAweDEzMTBlLCAweDEzMTM4LCAweDEzMTcwLCAweDEzMTdlLCAweDEzMTgyLCAweDEzMTg0LCAweDEzMTkwLCAweDEzMTllLCAweDEzMWEwLCAweDEzMWJjLFxyXG4gICAgICAgIDB4MTMxYzYsIDB4MTMxY2MsIDB4MTMxZDgsIDB4MTMxZjIsIDB4MTMxZjQsIDB4MTMyMGUsIDB4MTMyMWMsIDB4MTMyNzAsIDB4MTMyN2UsIDB4MTMyZTAsIDB4MTMyZmMsIDB4MTMzMDgsXHJcbiAgICAgICAgMHgxMzMxZSwgMHgxMzMyMCwgMHgxMzMzYywgMHgxMzM0MCwgMHgxMzM3OCwgMHgxMzM4NiwgMHgxMzM5OCwgMHgxMzNiMCwgMHgxMzNiZSwgMHgxMzNjZSwgMHgxMzNkYywgMHgxMzNlMixcclxuICAgICAgICAweDEzM2U0LCAweDEzM2U4LCAweDEzM2Y2LCAweDEzNDBlLCAweDEzNDFjLCAweDEzNDM4LCAweDEzNDcwLCAweDEzNDdlLCAweDEzNGUwLCAweDEzNGZjLCAweDEzNWMwLCAweDEzNWY4LFxyXG4gICAgICAgIDB4MTM2MDgsIDB4MTM2MTAsIDB4MTM2MWUsIDB4MTM2MjAsIDB4MTM2M2MsIDB4MTM2NDAsIDB4MTM2NzgsIDB4MTM2ZjAsIDB4MTM3MGMsIDB4MTM3MTgsIDB4MTM3MzAsIDB4MTM3M2UsXHJcbiAgICAgICAgMHgxMzc2MCwgMHgxMzc3YywgMHgxMzc5YywgMHgxMzdiOCwgMHgxMzdjMiwgMHgxMzdjNCwgMHgxMzdjOCwgMHgxMzdkMCwgMHgxMzdkZSwgMHgxMzdlNiwgMHgxMzdlYywgMHgxMzgxNixcclxuICAgICAgICAweDEzODI2LCAweDEzODJjLCAweDEzODQ2LCAweDEzODRjLCAweDEzODU4LCAweDEzODZlLCAweDEzODc0LCAweDEzODg2LCAweDEzODk4LCAweDEzOGIwLCAweDEzOGJlLCAweDEzOGNlLFxyXG4gICAgICAgIDB4MTM4ZGMsIDB4MTM4ZTIsIDB4MTM4ZTQsIDB4MTM4ZTgsIDB4MTM5MDYsIDB4MTM5MGMsIDB4MTM5MzAsIDB4MTM5M2UsIDB4MTM5NjAsIDB4MTM5N2MsIDB4MTM5OGUsIDB4MTM5OWMsXHJcbiAgICAgICAgMHgxMzliOCwgMHgxMzljOCwgMHgxMzlkMCwgMHgxMzlkZSwgMHgxMzllNiwgMHgxMzllYywgMHgxMzlmYSwgMHgxM2EwNiwgMHgxM2EwYywgMHgxM2ExOCwgMHgxM2EzMCwgMHgxM2EzZSxcclxuICAgICAgICAweDEzYTYwLCAweDEzYTdjLCAweDEzYWMwLCAweDEzYWY4LCAweDEzYjBlLCAweDEzYjFjLCAweDEzYjM4LCAweDEzYjcwLCAweDEzYjdlLCAweDEzYjg4LCAweDEzYjkwLCAweDEzYjllLFxyXG4gICAgICAgIDB4MTNiYTAsIDB4MTNiYmMsIDB4MTNiY2MsIDB4MTNiZDgsIDB4MTNiZWUsIDB4MTNiZjIsIDB4MTNiZjQsIDB4MTNjMTIsIDB4MTNjMTQsIDB4MTNjMjIsIDB4MTNjMjQsIDB4MTNjMjgsXHJcbiAgICAgICAgMHgxM2MzNiwgMHgxM2M0MiwgMHgxM2M0OCwgMHgxM2M1MCwgMHgxM2M1ZSwgMHgxM2M2NiwgMHgxM2M2YywgMHgxM2M4MiwgMHgxM2M4NCwgMHgxM2M5MCwgMHgxM2M5ZSwgMHgxM2NhMCxcclxuICAgICAgICAweDEzY2JjLCAweDEzY2M2LCAweDEzY2NjLCAweDEzY2Q4LCAweDEzY2VlLCAweDEzZDAyLCAweDEzZDA0LCAweDEzZDA4LCAweDEzZDEwLCAweDEzZDFlLCAweDEzZDIwLCAweDEzZDNjLFxyXG4gICAgICAgIDB4MTNkNDAsIDB4MTNkNzgsIDB4MTNkODYsIDB4MTNkOGMsIDB4MTNkOTgsIDB4MTNkYjAsIDB4MTNkYmUsIDB4MTNkY2UsIDB4MTNkZGMsIDB4MTNkZTQsIDB4MTNkZTgsIDB4MTNkZjYsXHJcbiAgICAgICAgMHgxM2UxYSwgMHgxM2UyZSwgMHgxM2UzMiwgMHgxM2UzNCwgMHgxM2U0ZSwgMHgxM2U1YywgMHgxM2U2MiwgMHgxM2U2NCwgMHgxM2U2OCwgMHgxM2U3NiwgMHgxM2U4ZSwgMHgxM2U5YyxcclxuICAgICAgICAweDEzZWI4LCAweDEzZWMyLCAweDEzZWM0LCAweDEzZWM4LCAweDEzZWQwLCAweDEzZWRlLCAweDEzZWU2LCAweDEzZWVjLCAweDEzZjI2LCAweDEzZjJjLCAweDEzZjNhLCAweDEzZjQ2LFxyXG4gICAgICAgIDB4MTNmNGMsIDB4MTNmNTgsIDB4MTNmNmUsIDB4MTNmNzIsIDB4MTNmNzQsIDB4MTQwODIsIDB4MTQwOWUsIDB4MTQwYTAsIDB4MTQwYmMsIDB4MTQxMDQsIDB4MTQxMDgsIDB4MTQxMTAsXHJcbiAgICAgICAgMHgxNDExZSwgMHgxNDEyMCwgMHgxNDEzYywgMHgxNDE0MCwgMHgxNDE3OCwgMHgxNDE4YywgMHgxNDE5OCwgMHgxNDFiMCwgMHgxNDFiZSwgMHgxNDFlMiwgMHgxNDFlNCwgMHgxNDFlOCxcclxuICAgICAgICAweDE0MjA4LCAweDE0MjEwLCAweDE0MjFlLCAweDE0MjIwLCAweDE0MjNjLCAweDE0MjQwLCAweDE0Mjc4LCAweDE0MmYwLCAweDE0MzA2LCAweDE0MzBjLCAweDE0MzE4LCAweDE0MzMwLFxyXG4gICAgICAgIDB4MTQzM2UsIDB4MTQzNjAsIDB4MTQzN2MsIDB4MTQzOGUsIDB4MTQzYzIsIDB4MTQzYzQsIDB4MTQzYzgsIDB4MTQzZDAsIDB4MTQzZTYsIDB4MTQzZWMsIDB4MTQ0MDgsIDB4MTQ0MTAsXHJcbiAgICAgICAgMHgxNDQxZSwgMHgxNDQyMCwgMHgxNDQzYywgMHgxNDQ0MCwgMHgxNDQ3OCwgMHgxNDRmMCwgMHgxNDVlMCwgMHgxNDYwYywgMHgxNDYxOCwgMHgxNDYzMCwgMHgxNDYzZSwgMHgxNDY2MCxcclxuICAgICAgICAweDE0NjdjLCAweDE0NmMwLCAweDE0NmY4LCAweDE0NzFjLCAweDE0NzM4LCAweDE0NzcwLCAweDE0NzdlLCAweDE0NzgyLCAweDE0Nzg0LCAweDE0Nzg4LCAweDE0NzkwLCAweDE0N2EwLFxyXG4gICAgICAgIDB4MTQ3YmMsIDB4MTQ3YzYsIDB4MTQ3Y2MsIDB4MTQ3ZDgsIDB4MTQ3ZWUsIDB4MTQ4MTAsIDB4MTQ4MjAsIDB4MTQ4M2MsIDB4MTQ4NDAsIDB4MTQ4NzgsIDB4MTQ4ZjAsIDB4MTQ5ZTAsXHJcbiAgICAgICAgMHgxNGJjMCwgMHgxNGMzMCwgMHgxNGMzZSwgMHgxNGM2MCwgMHgxNGM3YywgMHgxNGNjMCwgMHgxNGNmOCwgMHgxNGRmMCwgMHgxNGUzOCwgMHgxNGU3MCwgMHgxNGU3ZSwgMHgxNGVlMCxcclxuICAgICAgICAweDE0ZWZjLCAweDE0ZjA0LCAweDE0ZjA4LCAweDE0ZjEwLCAweDE0ZjFlLCAweDE0ZjIwLCAweDE0ZjNjLCAweDE0ZjQwLCAweDE0Zjc4LCAweDE0Zjg2LCAweDE0ZjhjLCAweDE0Zjk4LFxyXG4gICAgICAgIDB4MTRmYjAsIDB4MTRmY2UsIDB4MTRmZGMsIDB4MTUwMjAsIDB4MTUwNDAsIDB4MTUwNzgsIDB4MTUwZjAsIDB4MTUxZTAsIDB4MTUzYzAsIDB4MTU4NjAsIDB4MTU4N2MsIDB4MTU4YzAsXHJcbiAgICAgICAgMHgxNThmOCwgMHgxNTlmMCwgMHgxNWJlMCwgMHgxNWM3MCwgMHgxNWM3ZSwgMHgxNWNlMCwgMHgxNWNmYywgMHgxNWRjMCwgMHgxNWRmOCwgMHgxNWUwOCwgMHgxNWUxMCwgMHgxNWUyMCxcclxuICAgICAgICAweDE1ZTQwLCAweDE1ZTc4LCAweDE1ZWYwLCAweDE1ZjBjLCAweDE1ZjE4LCAweDE1ZjMwLCAweDE1ZjYwLCAweDE1ZjdjLCAweDE1ZjhlLCAweDE1ZjljLCAweDE1ZmI4LCAweDE2MDRlLFxyXG4gICAgICAgIDB4MTYwNWMsIDB4MTYwOGUsIDB4MTYwOWMsIDB4MTYwYjgsIDB4MTYwYzIsIDB4MTYwYzQsIDB4MTYwYzgsIDB4MTYwZGUsIDB4MTYxMGUsIDB4MTYxMWMsIDB4MTYxMzgsIDB4MTYxNzAsXHJcbiAgICAgICAgMHgxNjE3ZSwgMHgxNjE4NCwgMHgxNjE4OCwgMHgxNjE5MCwgMHgxNjE5ZSwgMHgxNjFhMCwgMHgxNjFiYywgMHgxNjFjNiwgMHgxNjFjYywgMHgxNjFkOCwgMHgxNjFmMiwgMHgxNjFmNCxcclxuICAgICAgICAweDE2MjBlLCAweDE2MjFjLCAweDE2MjM4LCAweDE2MjcwLCAweDE2MjdlLCAweDE2MmUwLCAweDE2MmZjLCAweDE2MzA0LCAweDE2MzA4LCAweDE2MzEwLCAweDE2MzFlLCAweDE2MzIwLFxyXG4gICAgICAgIDB4MTYzM2MsIDB4MTYzNDAsIDB4MTYzNzgsIDB4MTYzODYsIDB4MTYzOGMsIDB4MTYzOTgsIDB4MTYzYjAsIDB4MTYzYmUsIDB4MTYzY2UsIDB4MTYzZGMsIDB4MTYzZTIsIDB4MTYzZTQsXHJcbiAgICAgICAgMHgxNjNlOCwgMHgxNjNmNiwgMHgxNjQwZSwgMHgxNjQxYywgMHgxNjQzOCwgMHgxNjQ3MCwgMHgxNjQ3ZSwgMHgxNjRlMCwgMHgxNjRmYywgMHgxNjVjMCwgMHgxNjVmOCwgMHgxNjYxMCxcclxuICAgICAgICAweDE2NjFlLCAweDE2NjIwLCAweDE2NjNjLCAweDE2NjQwLCAweDE2Njc4LCAweDE2NmYwLCAweDE2NzE4LCAweDE2NzMwLCAweDE2NzNlLCAweDE2NzYwLCAweDE2NzdjLCAweDE2NzhlLFxyXG4gICAgICAgIDB4MTY3OWMsIDB4MTY3YjgsIDB4MTY3YzIsIDB4MTY3YzQsIDB4MTY3YzgsIDB4MTY3ZDAsIDB4MTY3ZGUsIDB4MTY3ZTYsIDB4MTY3ZWMsIDB4MTY4MWMsIDB4MTY4MzgsIDB4MTY4NzAsXHJcbiAgICAgICAgMHgxNjhlMCwgMHgxNjhmYywgMHgxNjljMCwgMHgxNjlmOCwgMHgxNmJmMCwgMHgxNmMxMCwgMHgxNmMxZSwgMHgxNmMyMCwgMHgxNmMzYywgMHgxNmM0MCwgMHgxNmM3OCwgMHgxNmNmMCxcclxuICAgICAgICAweDE2ZGUwLCAweDE2ZTE4LCAweDE2ZTMwLCAweDE2ZTNlLCAweDE2ZTYwLCAweDE2ZTdjLCAweDE2ZWMwLCAweDE2ZWY4LCAweDE2ZjFjLCAweDE2ZjM4LCAweDE2ZjcwLCAweDE2ZjdlLFxyXG4gICAgICAgIDB4MTZmODQsIDB4MTZmODgsIDB4MTZmOTAsIDB4MTZmOWUsIDB4MTZmYTAsIDB4MTZmYmMsIDB4MTZmYzYsIDB4MTZmY2MsIDB4MTZmZDgsIDB4MTcwMjYsIDB4MTcwMmMsIDB4MTcwNDYsXHJcbiAgICAgICAgMHgxNzA0YywgMHgxNzA1OCwgMHgxNzA2ZSwgMHgxNzA4NiwgMHgxNzA4YywgMHgxNzA5OCwgMHgxNzBiMCwgMHgxNzBiZSwgMHgxNzBjZSwgMHgxNzBkYywgMHgxNzBlOCwgMHgxNzEwNixcclxuICAgICAgICAweDE3MTBjLCAweDE3MTE4LCAweDE3MTMwLCAweDE3MTNlLCAweDE3MTYwLCAweDE3MTdjLCAweDE3MThlLCAweDE3MTljLCAweDE3MWI4LCAweDE3MWMyLCAweDE3MWM0LCAweDE3MWM4LFxyXG4gICAgICAgIDB4MTcxZDAsIDB4MTcxZGUsIDB4MTcxZTYsIDB4MTcxZWMsIDB4MTcxZmEsIDB4MTcyMDYsIDB4MTcyMGMsIDB4MTcyMTgsIDB4MTcyMzAsIDB4MTcyM2UsIDB4MTcyNjAsIDB4MTcyN2MsXHJcbiAgICAgICAgMHgxNzJjMCwgMHgxNzJmOCwgMHgxNzMwZSwgMHgxNzMxYywgMHgxNzMzOCwgMHgxNzM3MCwgMHgxNzM3ZSwgMHgxNzM4OCwgMHgxNzM5MCwgMHgxNzM5ZSwgMHgxNzNhMCwgMHgxNzNiYyxcclxuICAgICAgICAweDE3M2NjLCAweDE3M2Q4LCAweDE3M2VlLCAweDE3M2YyLCAweDE3M2Y0LCAweDE3NDBjLCAweDE3NDE4LCAweDE3NDMwLCAweDE3NDNlLCAweDE3NDYwLCAweDE3NDdjLCAweDE3NGMwLFxyXG4gICAgICAgIDB4MTc0ZjgsIDB4MTc1ZjAsIDB4MTc2MGUsIDB4MTc2MWMsIDB4MTc2MzgsIDB4MTc2NzAsIDB4MTc2N2UsIDB4MTc2ZTAsIDB4MTc2ZmMsIDB4MTc3MDgsIDB4MTc3MTAsIDB4MTc3MWUsXHJcbiAgICAgICAgMHgxNzcyMCwgMHgxNzczYywgMHgxNzc0MCwgMHgxNzc3OCwgMHgxNzc5OCwgMHgxNzdiMCwgMHgxNzdiZSwgMHgxNzdkYywgMHgxNzdlMiwgMHgxNzdlNCwgMHgxNzdlOCwgMHgxNzgyMixcclxuICAgICAgICAweDE3ODI0LCAweDE3ODI4LCAweDE3ODM2LCAweDE3ODQyLCAweDE3ODQ0LCAweDE3ODQ4LCAweDE3ODUwLCAweDE3ODVlLCAweDE3ODY2LCAweDE3ODZjLCAweDE3ODgyLCAweDE3ODg0LFxyXG4gICAgICAgIDB4MTc4ODgsIDB4MTc4OTAsIDB4MTc4OWUsIDB4MTc4YTAsIDB4MTc4YmMsIDB4MTc4YzYsIDB4MTc4Y2MsIDB4MTc4ZDgsIDB4MTc4ZWUsIDB4MTc4ZjIsIDB4MTc4ZjQsIDB4MTc5MDIsXHJcbiAgICAgICAgMHgxNzkwNCwgMHgxNzkwOCwgMHgxNzkxMCwgMHgxNzkxZSwgMHgxNzkyMCwgMHgxNzkzYywgMHgxNzk0MCwgMHgxNzk3OCwgMHgxNzk4NiwgMHgxNzk4YywgMHgxNzk5OCwgMHgxNzliMCxcclxuICAgICAgICAweDE3OWJlLCAweDE3OWNlLCAweDE3OWRjLCAweDE3OWUyLCAweDE3OWU0LCAweDE3OWU4LCAweDE3OWY2LCAweDE3YTA0LCAweDE3YTA4LCAweDE3YTEwLCAweDE3YTFlLCAweDE3YTIwLFxyXG4gICAgICAgIDB4MTdhM2MsIDB4MTdhNDAsIDB4MTdhNzgsIDB4MTdhZjAsIDB4MTdiMDYsIDB4MTdiMGMsIDB4MTdiMTgsIDB4MTdiMzAsIDB4MTdiM2UsIDB4MTdiNjAsIDB4MTdiN2MsIDB4MTdiOGUsXHJcbiAgICAgICAgMHgxN2I5YywgMHgxN2JiOCwgMHgxN2JjNCwgMHgxN2JjOCwgMHgxN2JkMCwgMHgxN2JkZSwgMHgxN2JlNiwgMHgxN2JlYywgMHgxN2MyZSwgMHgxN2MzMiwgMHgxN2MzNCwgMHgxN2M0ZSxcclxuICAgICAgICAweDE3YzVjLCAweDE3YzYyLCAweDE3YzY0LCAweDE3YzY4LCAweDE3Yzc2LCAweDE3YzhlLCAweDE3YzljLCAweDE3Y2I4LCAweDE3Y2MyLCAweDE3Y2M0LCAweDE3Y2M4LCAweDE3Y2QwLFxyXG4gICAgICAgIDB4MTdjZGUsIDB4MTdjZTYsIDB4MTdjZWMsIDB4MTdkMGUsIDB4MTdkMWMsIDB4MTdkMzgsIDB4MTdkNzAsIDB4MTdkODIsIDB4MTdkODQsIDB4MTdkODgsIDB4MTdkOTAsIDB4MTdkOWUsXHJcbiAgICAgICAgMHgxN2RhMCwgMHgxN2RiYywgMHgxN2RjNiwgMHgxN2RjYywgMHgxN2RkOCwgMHgxN2RlZSwgMHgxN2UyNiwgMHgxN2UyYywgMHgxN2UzYSwgMHgxN2U0NiwgMHgxN2U0YywgMHgxN2U1OCxcclxuICAgICAgICAweDE3ZTZlLCAweDE3ZTcyLCAweDE3ZTc0LCAweDE3ZTg2LCAweDE3ZThjLCAweDE3ZTk4LCAweDE3ZWIwLCAweDE3ZWNlLCAweDE3ZWRjLCAweDE3ZWUyLCAweDE3ZWU0LCAweDE3ZWU4LFxyXG4gICAgICAgIDB4MTdlZjYsIDB4MTgxM2EsIDB4MTgxNzIsIDB4MTgxNzQsIDB4MTgyMTYsIDB4MTgyMjYsIDB4MTgyM2EsIDB4MTgyNGMsIDB4MTgyNTgsIDB4MTgyNmUsIDB4MTgyNzIsIDB4MTgyNzQsXHJcbiAgICAgICAgMHgxODI5OCwgMHgxODJiZSwgMHgxODJlMiwgMHgxODJlNCwgMHgxODJlOCwgMHgxODJmNiwgMHgxODM1ZSwgMHgxODM3YSwgMHgxODNhZSwgMHgxODNkNiwgMHgxODQxNiwgMHgxODQyNixcclxuICAgICAgICAweDE4NDJjLCAweDE4NDNhLCAweDE4NDQ2LCAweDE4NDU4LCAweDE4NDZlLCAweDE4NDcyLCAweDE4NDc0LCAweDE4NDg2LCAweDE4NGIwLCAweDE4NGJlLCAweDE4NGNlLCAweDE4NGRjLFxyXG4gICAgICAgIDB4MTg0ZTIsIDB4MTg0ZTQsIDB4MTg0ZTgsIDB4MTg0ZjYsIDB4MTg1MDYsIDB4MTg1MGMsIDB4MTg1MTgsIDB4MTg1MzAsIDB4MTg1M2UsIDB4MTg1NjAsIDB4MTg1N2MsIDB4MTg1OGUsXHJcbiAgICAgICAgMHgxODU5YywgMHgxODViOCwgMHgxODVjMiwgMHgxODVjNCwgMHgxODVjOCwgMHgxODVkMCwgMHgxODVkZSwgMHgxODVlNiwgMHgxODVlYywgMHgxODVmYSwgMHgxODYxMiwgMHgxODYxNCxcclxuICAgICAgICAweDE4NjIyLCAweDE4NjI4LCAweDE4NjM2LCAweDE4NjQyLCAweDE4NjUwLCAweDE4NjVlLCAweDE4NjdhLCAweDE4NjgyLCAweDE4Njg0LCAweDE4Njg4LCAweDE4NjkwLCAweDE4NjllLFxyXG4gICAgICAgIDB4MTg2YTAsIDB4MTg2YmMsIDB4MTg2YzYsIDB4MTg2Y2MsIDB4MTg2ZDgsIDB4MTg2ZWUsIDB4MTg2ZjIsIDB4MTg2ZjQsIDB4MTg3MmUsIDB4MTg3NGUsIDB4MTg3NWMsIDB4MTg3OTYsXHJcbiAgICAgICAgMHgxODdhNiwgMHgxODdhYywgMHgxODdkMiwgMHgxODdkNCwgMHgxODgyNiwgMHgxODgyYywgMHgxODgzYSwgMHgxODg0NiwgMHgxODg0YywgMHgxODg1OCwgMHgxODg2ZSwgMHgxODg3MixcclxuICAgICAgICAweDE4ODc0LCAweDE4ODg2LCAweDE4ODk4LCAweDE4OGIwLCAweDE4OGJlLCAweDE4OGNlLCAweDE4OGRjLCAweDE4OGUyLCAweDE4OGU0LCAweDE4OGU4LCAweDE4OGY2LCAweDE4OTBjLFxyXG4gICAgICAgIDB4MTg5MzAsIDB4MTg5M2UsIDB4MTg5NjAsIDB4MTg5N2MsIDB4MTg5OGUsIDB4MTg5YjgsIDB4MTg5YzIsIDB4MTg5YzgsIDB4MTg5ZDAsIDB4MTg5ZGUsIDB4MTg5ZTYsIDB4MTg5ZWMsXHJcbiAgICAgICAgMHgxODlmYSwgMHgxOGExOCwgMHgxOGEzMCwgMHgxOGEzZSwgMHgxOGE2MCwgMHgxOGE3YywgMHgxOGFjMCwgMHgxOGFmOCwgMHgxOGIxYywgMHgxOGIzOCwgMHgxOGI3MCwgMHgxOGI3ZSxcclxuICAgICAgICAweDE4YjgyLCAweDE4Yjg0LCAweDE4Yjg4LCAweDE4YjkwLCAweDE4YjllLCAweDE4YmEwLCAweDE4YmJjLCAweDE4YmM2LCAweDE4YmNjLCAweDE4YmQ4LCAweDE4YmVlLCAweDE4YmYyLFxyXG4gICAgICAgIDB4MThiZjQsIDB4MThjMjIsIDB4MThjMjQsIDB4MThjMjgsIDB4MThjMzYsIDB4MThjNDIsIDB4MThjNDgsIDB4MThjNTAsIDB4MThjNWUsIDB4MThjNjYsIDB4MThjN2EsIDB4MThjODIsXHJcbiAgICAgICAgMHgxOGM4NCwgMHgxOGM5MCwgMHgxOGM5ZSwgMHgxOGNhMCwgMHgxOGNiYywgMHgxOGNjYywgMHgxOGNmMiwgMHgxOGNmNCwgMHgxOGQwNCwgMHgxOGQwOCwgMHgxOGQxMCwgMHgxOGQxZSxcclxuICAgICAgICAweDE4ZDIwLCAweDE4ZDNjLCAweDE4ZDQwLCAweDE4ZDc4LCAweDE4ZDg2LCAweDE4ZDk4LCAweDE4ZGNlLCAweDE4ZGUyLCAweDE4ZGU0LCAweDE4ZGU4LCAweDE4ZTJlLCAweDE4ZTMyLFxyXG4gICAgICAgIDB4MThlMzQsIDB4MThlNGUsIDB4MThlNWMsIDB4MThlNjIsIDB4MThlNjQsIDB4MThlNjgsIDB4MThlOGUsIDB4MThlOWMsIDB4MThlYjgsIDB4MThlYzIsIDB4MThlYzQsIDB4MThlYzgsXHJcbiAgICAgICAgMHgxOGVkMCwgMHgxOGVmYSwgMHgxOGYxNiwgMHgxOGYyNiwgMHgxOGYyYywgMHgxOGY0NiwgMHgxOGY0YywgMHgxOGY1OCwgMHgxOGY2ZSwgMHgxOGY4YSwgMHgxOGY5MiwgMHgxOGY5NCxcclxuICAgICAgICAweDE4ZmEyLCAweDE4ZmE0LCAweDE4ZmE4LCAweDE4ZmI2LCAweDE5MDJjLCAweDE5MDNhLCAweDE5MDQ2LCAweDE5MDRjLCAweDE5MDU4LCAweDE5MDcyLCAweDE5MDc0LCAweDE5MDg2LFxyXG4gICAgICAgIDB4MTkwOTgsIDB4MTkwYjAsIDB4MTkwYmUsIDB4MTkwY2UsIDB4MTkwZGMsIDB4MTkwZTIsIDB4MTkwZTgsIDB4MTkwZjYsIDB4MTkxMDYsIDB4MTkxMGMsIDB4MTkxMzAsIDB4MTkxM2UsXHJcbiAgICAgICAgMHgxOTE2MCwgMHgxOTE3YywgMHgxOTE4ZSwgMHgxOTE5YywgMHgxOTFiOCwgMHgxOTFjMiwgMHgxOTFjOCwgMHgxOTFkMCwgMHgxOTFkZSwgMHgxOTFlNiwgMHgxOTFlYywgMHgxOTFmYSxcclxuICAgICAgICAweDE5MjE4LCAweDE5MjNlLCAweDE5MjYwLCAweDE5MjdjLCAweDE5MmMwLCAweDE5MmY4LCAweDE5MzM4LCAweDE5MzcwLCAweDE5MzdlLCAweDE5MzgyLCAweDE5Mzg0LCAweDE5MzkwLFxyXG4gICAgICAgIDB4MTkzOWUsIDB4MTkzYTAsIDB4MTkzYmMsIDB4MTkzYzYsIDB4MTkzY2MsIDB4MTkzZDgsIDB4MTkzZWUsIDB4MTkzZjIsIDB4MTkzZjQsIDB4MTk0MzAsIDB4MTk0M2UsIDB4MTk0NjAsXHJcbiAgICAgICAgMHgxOTQ3YywgMHgxOTRjMCwgMHgxOTRmOCwgMHgxOTVmMCwgMHgxOTYzOCwgMHgxOTY3MCwgMHgxOTY3ZSwgMHgxOTZlMCwgMHgxOTZmYywgMHgxOTcwMiwgMHgxOTcwNCwgMHgxOTcwOCxcclxuICAgICAgICAweDE5NzEwLCAweDE5NzIwLCAweDE5NzNjLCAweDE5NzQwLCAweDE5Nzc4LCAweDE5Nzg2LCAweDE5NzhjLCAweDE5Nzk4LCAweDE5N2IwLCAweDE5N2JlLCAweDE5N2NlLCAweDE5N2RjLFxyXG4gICAgICAgIDB4MTk3ZTIsIDB4MTk3ZTQsIDB4MTk3ZTgsIDB4MTk4MjIsIDB4MTk4MjQsIDB4MTk4NDIsIDB4MTk4NDgsIDB4MTk4NTAsIDB4MTk4NWUsIDB4MTk4NjYsIDB4MTk4N2EsIDB4MTk4ODIsXHJcbiAgICAgICAgMHgxOTg4NCwgMHgxOTg5MCwgMHgxOTg5ZSwgMHgxOThhMCwgMHgxOThiYywgMHgxOThjYywgMHgxOThmMiwgMHgxOThmNCwgMHgxOTkwMiwgMHgxOTkwOCwgMHgxOTkxZSwgMHgxOTkyMCxcclxuICAgICAgICAweDE5OTNjLCAweDE5OTQwLCAweDE5OTc4LCAweDE5OTg2LCAweDE5OTk4LCAweDE5OWNlLCAweDE5OWUyLCAweDE5OWU0LCAweDE5OWU4LCAweDE5YTA4LCAweDE5YTEwLCAweDE5YTFlLFxyXG4gICAgICAgIDB4MTlhMjAsIDB4MTlhM2MsIDB4MTlhNDAsIDB4MTlhNzgsIDB4MTlhZjAsIDB4MTliMTgsIDB4MTliM2UsIDB4MTliNjAsIDB4MTliOWMsIDB4MTliYzIsIDB4MTliYzQsIDB4MTliYzgsXHJcbiAgICAgICAgMHgxOWJkMCwgMHgxOWJlNiwgMHgxOWMyZSwgMHgxOWMzNCwgMHgxOWM0ZSwgMHgxOWM1YywgMHgxOWM2MiwgMHgxOWM2NCwgMHgxOWM2OCwgMHgxOWM4ZSwgMHgxOWM5YywgMHgxOWNiOCxcclxuICAgICAgICAweDE5Y2MyLCAweDE5Y2M4LCAweDE5Y2QwLCAweDE5Y2U2LCAweDE5Y2ZhLCAweDE5ZDBlLCAweDE5ZDFjLCAweDE5ZDM4LCAweDE5ZDcwLCAweDE5ZDdlLCAweDE5ZDgyLCAweDE5ZDg0LFxyXG4gICAgICAgIDB4MTlkODgsIDB4MTlkOTAsIDB4MTlkYTAsIDB4MTlkY2MsIDB4MTlkZjIsIDB4MTlkZjQsIDB4MTllMTYsIDB4MTllMjYsIDB4MTllMmMsIDB4MTllNDYsIDB4MTllNGMsIDB4MTllNTgsXHJcbiAgICAgICAgMHgxOWU3NCwgMHgxOWU4NiwgMHgxOWU4YywgMHgxOWU5OCwgMHgxOWViMCwgMHgxOWViZSwgMHgxOWVjZSwgMHgxOWVlMiwgMHgxOWVlNCwgMHgxOWVlOCwgMHgxOWYwYSwgMHgxOWYxMixcclxuICAgICAgICAweDE5ZjE0LCAweDE5ZjIyLCAweDE5ZjI0LCAweDE5ZjI4LCAweDE5ZjQyLCAweDE5ZjQ0LCAweDE5ZjQ4LCAweDE5ZjUwLCAweDE5ZjVlLCAweDE5ZjZjLCAweDE5ZjlhLCAweDE5ZmFlLFxyXG4gICAgICAgIDB4MTlmYjIsIDB4MTlmYjQsIDB4MWEwNDYsIDB4MWEwNGMsIDB4MWEwNzIsIDB4MWEwNzQsIDB4MWEwODYsIDB4MWEwOGMsIDB4MWEwOTgsIDB4MWEwYjAsIDB4MWEwYmUsIDB4MWEwZTIsXHJcbiAgICAgICAgMHgxYTBlNCwgMHgxYTBlOCwgMHgxYTBmNiwgMHgxYTEwNiwgMHgxYTEwYywgMHgxYTExOCwgMHgxYTEzMCwgMHgxYTEzZSwgMHgxYTE2MCwgMHgxYTE3YywgMHgxYTE4ZSwgMHgxYTE5YyxcclxuICAgICAgICAweDFhMWI4LCAweDFhMWMyLCAweDFhMWM0LCAweDFhMWM4LCAweDFhMWQwLCAweDFhMWRlLCAweDFhMWU2LCAweDFhMWVjLCAweDFhMjE4LCAweDFhMjMwLCAweDFhMjNlLCAweDFhMjYwLFxyXG4gICAgICAgIDB4MWEyN2MsIDB4MWEyYzAsIDB4MWEyZjgsIDB4MWEzMWMsIDB4MWEzMzgsIDB4MWEzNzAsIDB4MWEzN2UsIDB4MWEzODIsIDB4MWEzODQsIDB4MWEzODgsIDB4MWEzOTAsIDB4MWEzOWUsXHJcbiAgICAgICAgMHgxYTNhMCwgMHgxYTNiYywgMHgxYTNjNiwgMHgxYTNjYywgMHgxYTNkOCwgMHgxYTNlZSwgMHgxYTNmMiwgMHgxYTNmNCwgMHgxYTQxOCwgMHgxYTQzMCwgMHgxYTQzZSwgMHgxYTQ2MCxcclxuICAgICAgICAweDFhNDdjLCAweDFhNGMwLCAweDFhNGY4LCAweDFhNWYwLCAweDFhNjFjLCAweDFhNjM4LCAweDFhNjcwLCAweDFhNjdlLCAweDFhNmUwLCAweDFhNmZjLCAweDFhNzAyLCAweDFhNzA0LFxyXG4gICAgICAgIDB4MWE3MDgsIDB4MWE3MTAsIDB4MWE3MWUsIDB4MWE3MjAsIDB4MWE3M2MsIDB4MWE3NDAsIDB4MWE3NzgsIDB4MWE3ODYsIDB4MWE3OGMsIDB4MWE3OTgsIDB4MWE3YjAsIDB4MWE3YmUsXHJcbiAgICAgICAgMHgxYTdjZSwgMHgxYTdkYywgMHgxYTdlMiwgMHgxYTdlNCwgMHgxYTdlOCwgMHgxYTgzMCwgMHgxYTg2MCwgMHgxYTg3YywgMHgxYThjMCwgMHgxYThmOCwgMHgxYTlmMCwgMHgxYWJlMCxcclxuICAgICAgICAweDFhYzcwLCAweDFhYzdlLCAweDFhY2UwLCAweDFhY2ZjLCAweDFhZGMwLCAweDFhZGY4LCAweDFhZTA0LCAweDFhZTA4LCAweDFhZTEwLCAweDFhZTIwLCAweDFhZTNjLCAweDFhZTQwLFxyXG4gICAgICAgIDB4MWFlNzgsIDB4MWFlZjAsIDB4MWFmMDYsIDB4MWFmMGMsIDB4MWFmMTgsIDB4MWFmMzAsIDB4MWFmM2UsIDB4MWFmNjAsIDB4MWFmN2MsIDB4MWFmOGUsIDB4MWFmOWMsIDB4MWFmYjgsXHJcbiAgICAgICAgMHgxYWZjNCwgMHgxYWZjOCwgMHgxYWZkMCwgMHgxYWZkZSwgMHgxYjA0MiwgMHgxYjA1ZSwgMHgxYjA3YSwgMHgxYjA4MiwgMHgxYjA4NCwgMHgxYjA4OCwgMHgxYjA5MCwgMHgxYjA5ZSxcclxuICAgICAgICAweDFiMGEwLCAweDFiMGJjLCAweDFiMGNjLCAweDFiMGYyLCAweDFiMGY0LCAweDFiMTAyLCAweDFiMTA0LCAweDFiMTA4LCAweDFiMTEwLCAweDFiMTFlLCAweDFiMTIwLCAweDFiMTNjLFxyXG4gICAgICAgIDB4MWIxNDAsIDB4MWIxNzgsIDB4MWIxODYsIDB4MWIxOTgsIDB4MWIxY2UsIDB4MWIxZTIsIDB4MWIxZTQsIDB4MWIxZTgsIDB4MWIyMDQsIDB4MWIyMDgsIDB4MWIyMTAsIDB4MWIyMWUsXHJcbiAgICAgICAgMHgxYjIyMCwgMHgxYjIzYywgMHgxYjI0MCwgMHgxYjI3OCwgMHgxYjJmMCwgMHgxYjMwYywgMHgxYjMzZSwgMHgxYjM2MCwgMHgxYjM5YywgMHgxYjNjMiwgMHgxYjNjNCwgMHgxYjNjOCxcclxuICAgICAgICAweDFiM2QwLCAweDFiM2U2LCAweDFiNDEwLCAweDFiNDFlLCAweDFiNDIwLCAweDFiNDNjLCAweDFiNDQwLCAweDFiNDc4LCAweDFiNGYwLCAweDFiNWUwLCAweDFiNjE4LCAweDFiNjYwLFxyXG4gICAgICAgIDB4MWI2N2MsIDB4MWI2YzAsIDB4MWI3MzgsIDB4MWI3ODIsIDB4MWI3ODQsIDB4MWI3ODgsIDB4MWI3OTAsIDB4MWI3OWUsIDB4MWI3YTAsIDB4MWI3Y2MsIDB4MWI4MmUsIDB4MWI4NGUsXHJcbiAgICAgICAgMHgxYjg1YywgMHgxYjg4ZSwgMHgxYjg5YywgMHgxYjhiOCwgMHgxYjhjMiwgMHgxYjhjNCwgMHgxYjhjOCwgMHgxYjhkMCwgMHgxYjhlNiwgMHgxYjhmYSwgMHgxYjkwZSwgMHgxYjkxYyxcclxuICAgICAgICAweDFiOTM4LCAweDFiOTcwLCAweDFiOTdlLCAweDFiOTgyLCAweDFiOTg0LCAweDFiOTg4LCAweDFiOTkwLCAweDFiOTllLCAweDFiOWEwLCAweDFiOWNjLCAweDFiOWYyLCAweDFiOWY0LFxyXG4gICAgICAgIDB4MWJhMGUsIDB4MWJhMWMsIDB4MWJhMzgsIDB4MWJhNzAsIDB4MWJhN2UsIDB4MWJhZTAsIDB4MWJhZmMsIDB4MWJiMDgsIDB4MWJiMTAsIDB4MWJiMjAsIDB4MWJiM2MsIDB4MWJiNDAsXHJcbiAgICAgICAgMHgxYmI5OCwgMHgxYmJjZSwgMHgxYmJlMiwgMHgxYmJlNCwgMHgxYmJlOCwgMHgxYmMxNiwgMHgxYmMyNiwgMHgxYmMyYywgMHgxYmM0NiwgMHgxYmM0YywgMHgxYmM1OCwgMHgxYmM3MixcclxuICAgICAgICAweDFiYzc0LCAweDFiYzg2LCAweDFiYzhjLCAweDFiYzk4LCAweDFiY2IwLCAweDFiY2JlLCAweDFiY2NlLCAweDFiY2UyLCAweDFiY2U0LCAweDFiY2U4LCAweDFiZDA2LCAweDFiZDBjLFxyXG4gICAgICAgIDB4MWJkMTgsIDB4MWJkMzAsIDB4MWJkM2UsIDB4MWJkNjAsIDB4MWJkN2MsIDB4MWJkOWMsIDB4MWJkYzIsIDB4MWJkYzQsIDB4MWJkYzgsIDB4MWJkZDAsIDB4MWJkZTYsIDB4MWJkZmEsXHJcbiAgICAgICAgMHgxYmUxMiwgMHgxYmUxNCwgMHgxYmUyMiwgMHgxYmUyNCwgMHgxYmUyOCwgMHgxYmU0MiwgMHgxYmU0NCwgMHgxYmU0OCwgMHgxYmU1MCwgMHgxYmU1ZSwgMHgxYmU2NiwgMHgxYmU4MixcclxuICAgICAgICAweDFiZTg0LCAweDFiZTg4LCAweDFiZTkwLCAweDFiZTllLCAweDFiZWEwLCAweDFiZWJjLCAweDFiZWNjLCAweDFiZWY0LCAweDFiZjFhLCAweDFiZjJlLCAweDFiZjMyLCAweDFiZjM0LFxyXG4gICAgICAgIDB4MWJmNGUsIDB4MWJmNWMsIDB4MWJmNjIsIDB4MWJmNjQsIDB4MWJmNjgsIDB4MWMwOWEsIDB4MWMwYjIsIDB4MWMwYjQsIDB4MWMxMWEsIDB4MWMxMzIsIDB4MWMxMzQsIDB4MWMxNjIsXHJcbiAgICAgICAgMHgxYzE2NCwgMHgxYzE2OCwgMHgxYzE3NiwgMHgxYzFiYSwgMHgxYzIxYSwgMHgxYzIzMiwgMHgxYzIzNCwgMHgxYzI0ZSwgMHgxYzI1YywgMHgxYzI2MiwgMHgxYzI2NCwgMHgxYzI2OCxcclxuICAgICAgICAweDFjMjc2LCAweDFjMjhlLCAweDFjMmMyLCAweDFjMmM0LCAweDFjMmM4LCAweDFjMmQwLCAweDFjMmRlLCAweDFjMmU2LCAweDFjMmVjLCAweDFjMmZhLCAweDFjMzE2LCAweDFjMzI2LFxyXG4gICAgICAgIDB4MWMzM2EsIDB4MWMzNDYsIDB4MWMzNGMsIDB4MWMzNzIsIDB4MWMzNzQsIDB4MWM0MWEsIDB4MWM0MmUsIDB4MWM0MzIsIDB4MWM0MzQsIDB4MWM0NGUsIDB4MWM0NWMsIDB4MWM0NjIsXHJcbiAgICAgICAgMHgxYzQ2NCwgMHgxYzQ2OCwgMHgxYzQ3NiwgMHgxYzQ4ZSwgMHgxYzQ5YywgMHgxYzRiOCwgMHgxYzRjMiwgMHgxYzRjOCwgMHgxYzRkMCwgMHgxYzRkZSwgMHgxYzRlNiwgMHgxYzRlYyxcclxuICAgICAgICAweDFjNGZhLCAweDFjNTFjLCAweDFjNTM4LCAweDFjNTcwLCAweDFjNTdlLCAweDFjNTgyLCAweDFjNTg0LCAweDFjNTg4LCAweDFjNTkwLCAweDFjNTllLCAweDFjNWEwLCAweDFjNWJjLFxyXG4gICAgICAgIDB4MWM1YzYsIDB4MWM1Y2MsIDB4MWM1ZDgsIDB4MWM1ZWUsIDB4MWM1ZjIsIDB4MWM1ZjQsIDB4MWM2MTYsIDB4MWM2MjYsIDB4MWM2MmMsIDB4MWM2M2EsIDB4MWM2NDYsIDB4MWM2NGMsXHJcbiAgICAgICAgMHgxYzY1OCwgMHgxYzY2ZSwgMHgxYzY3MiwgMHgxYzY3NCwgMHgxYzY4NiwgMHgxYzY4YywgMHgxYzY5OCwgMHgxYzZiMCwgMHgxYzZiZSwgMHgxYzZjZSwgMHgxYzZkYywgMHgxYzZlMixcclxuICAgICAgICAweDFjNmU0LCAweDFjNmU4LCAweDFjNzEyLCAweDFjNzE0LCAweDFjNzIyLCAweDFjNzI4LCAweDFjNzM2LCAweDFjNzQyLCAweDFjNzQ0LCAweDFjNzQ4LCAweDFjNzUwLCAweDFjNzVlLFxyXG4gICAgICAgIDB4MWM3NjYsIDB4MWM3NmMsIDB4MWM3N2EsIDB4MWM3YWUsIDB4MWM3ZDYsIDB4MWM3ZWEsIDB4MWM4MWEsIDB4MWM4MmUsIDB4MWM4MzIsIDB4MWM4MzQsIDB4MWM4NGUsIDB4MWM4NWMsXHJcbiAgICAgICAgMHgxYzg2MiwgMHgxYzg2NCwgMHgxYzg2OCwgMHgxYzg3NiwgMHgxYzg4ZSwgMHgxYzg5YywgMHgxYzhiOCwgMHgxYzhjMiwgMHgxYzhjOCwgMHgxYzhkMCwgMHgxYzhkZSwgMHgxYzhlNixcclxuICAgICAgICAweDFjOGVjLCAweDFjOGZhLCAweDFjOTBlLCAweDFjOTM4LCAweDFjOTcwLCAweDFjOTdlLCAweDFjOTgyLCAweDFjOTg0LCAweDFjOTkwLCAweDFjOTllLCAweDFjOWEwLCAweDFjOWJjLFxyXG4gICAgICAgIDB4MWM5YzYsIDB4MWM5Y2MsIDB4MWM5ZDgsIDB4MWM5ZWUsIDB4MWM5ZjIsIDB4MWM5ZjQsIDB4MWNhMzgsIDB4MWNhNzAsIDB4MWNhN2UsIDB4MWNhZTAsIDB4MWNhZmMsIDB4MWNiMDIsXHJcbiAgICAgICAgMHgxY2IwNCwgMHgxY2IwOCwgMHgxY2IxMCwgMHgxY2IyMCwgMHgxY2IzYywgMHgxY2I0MCwgMHgxY2I3OCwgMHgxY2I4NiwgMHgxY2I4YywgMHgxY2I5OCwgMHgxY2JiMCwgMHgxY2JiZSxcclxuICAgICAgICAweDFjYmNlLCAweDFjYmRjLCAweDFjYmUyLCAweDFjYmU0LCAweDFjYmU4LCAweDFjYmY2LCAweDFjYzE2LCAweDFjYzI2LCAweDFjYzJjLCAweDFjYzNhLCAweDFjYzQ2LCAweDFjYzU4LFxyXG4gICAgICAgIDB4MWNjNzIsIDB4MWNjNzQsIDB4MWNjODYsIDB4MWNjYjAsIDB4MWNjYmUsIDB4MWNjY2UsIDB4MWNjZTIsIDB4MWNjZTQsIDB4MWNjZTgsIDB4MWNkMDYsIDB4MWNkMGMsIDB4MWNkMTgsXHJcbiAgICAgICAgMHgxY2QzMCwgMHgxY2QzZSwgMHgxY2Q2MCwgMHgxY2Q3YywgMHgxY2Q5YywgMHgxY2RjMiwgMHgxY2RjNCwgMHgxY2RjOCwgMHgxY2RkMCwgMHgxY2RkZSwgMHgxY2RlNiwgMHgxY2RmYSxcclxuICAgICAgICAweDFjZTIyLCAweDFjZTI4LCAweDFjZTQyLCAweDFjZTUwLCAweDFjZTVlLCAweDFjZTY2LCAweDFjZTdhLCAweDFjZTgyLCAweDFjZTg0LCAweDFjZTg4LCAweDFjZTkwLCAweDFjZTllLFxyXG4gICAgICAgIDB4MWNlYTAsIDB4MWNlYmMsIDB4MWNlY2MsIDB4MWNlZjIsIDB4MWNlZjQsIDB4MWNmMmUsIDB4MWNmMzIsIDB4MWNmMzQsIDB4MWNmNGUsIDB4MWNmNWMsIDB4MWNmNjIsIDB4MWNmNjQsXHJcbiAgICAgICAgMHgxY2Y2OCwgMHgxY2Y5NiwgMHgxY2ZhNiwgMHgxY2ZhYywgMHgxY2ZjYSwgMHgxY2ZkMiwgMHgxY2ZkNCwgMHgxZDAyZSwgMHgxZDAzMiwgMHgxZDAzNCwgMHgxZDA0ZSwgMHgxZDA1YyxcclxuICAgICAgICAweDFkMDYyLCAweDFkMDY0LCAweDFkMDY4LCAweDFkMDc2LCAweDFkMDhlLCAweDFkMDljLCAweDFkMGI4LCAweDFkMGMyLCAweDFkMGM0LCAweDFkMGM4LCAweDFkMGQwLCAweDFkMGRlLFxyXG4gICAgICAgIDB4MWQwZTYsIDB4MWQwZWMsIDB4MWQwZmEsIDB4MWQxMWMsIDB4MWQxMzgsIDB4MWQxNzAsIDB4MWQxN2UsIDB4MWQxODIsIDB4MWQxODQsIDB4MWQxODgsIDB4MWQxOTAsIDB4MWQxOWUsXHJcbiAgICAgICAgMHgxZDFhMCwgMHgxZDFiYywgMHgxZDFjNiwgMHgxZDFjYywgMHgxZDFkOCwgMHgxZDFlZSwgMHgxZDFmMiwgMHgxZDFmNCwgMHgxZDIxYywgMHgxZDIzOCwgMHgxZDI3MCwgMHgxZDI3ZSxcclxuICAgICAgICAweDFkMmUwLCAweDFkMmZjLCAweDFkMzAyLCAweDFkMzA0LCAweDFkMzA4LCAweDFkMzEwLCAweDFkMzFlLCAweDFkMzIwLCAweDFkMzNjLCAweDFkMzQwLCAweDFkMzc4LCAweDFkMzg2LFxyXG4gICAgICAgIDB4MWQzOGMsIDB4MWQzOTgsIDB4MWQzYjAsIDB4MWQzYmUsIDB4MWQzY2UsIDB4MWQzZGMsIDB4MWQzZTIsIDB4MWQzZTQsIDB4MWQzZTgsIDB4MWQzZjYsIDB4MWQ0NzAsIDB4MWQ0N2UsXHJcbiAgICAgICAgMHgxZDRlMCwgMHgxZDRmYywgMHgxZDVjMCwgMHgxZDVmOCwgMHgxZDYwNCwgMHgxZDYwOCwgMHgxZDYxMCwgMHgxZDYyMCwgMHgxZDY0MCwgMHgxZDY3OCwgMHgxZDZmMCwgMHgxZDcwNixcclxuICAgICAgICAweDFkNzBjLCAweDFkNzE4LCAweDFkNzMwLCAweDFkNzNlLCAweDFkNzYwLCAweDFkNzdjLCAweDFkNzhlLCAweDFkNzljLCAweDFkN2I4LCAweDFkN2MyLCAweDFkN2M0LCAweDFkN2M4LFxyXG4gICAgICAgIDB4MWQ3ZDAsIDB4MWQ3ZGUsIDB4MWQ3ZTYsIDB4MWQ3ZWMsIDB4MWQ4MjYsIDB4MWQ4MmMsIDB4MWQ4M2EsIDB4MWQ4NDYsIDB4MWQ4NGMsIDB4MWQ4NTgsIDB4MWQ4NzIsIDB4MWQ4NzQsXHJcbiAgICAgICAgMHgxZDg4NiwgMHgxZDg4YywgMHgxZDg5OCwgMHgxZDhiMCwgMHgxZDhiZSwgMHgxZDhjZSwgMHgxZDhlMiwgMHgxZDhlNCwgMHgxZDhlOCwgMHgxZDhmNiwgMHgxZDkwYywgMHgxZDkxOCxcclxuICAgICAgICAweDFkOTMwLCAweDFkOTNlLCAweDFkOTYwLCAweDFkOTdjLCAweDFkOTljLCAweDFkOWMyLCAweDFkOWM0LCAweDFkOWM4LCAweDFkOWQwLCAweDFkOWU2LCAweDFkOWZhLCAweDFkYTBjLFxyXG4gICAgICAgIDB4MWRhMTgsIDB4MWRhMzAsIDB4MWRhM2UsIDB4MWRhNjAsIDB4MWRhN2MsIDB4MWRhYzAsIDB4MWRhZjgsIDB4MWRiMzgsIDB4MWRiODIsIDB4MWRiODQsIDB4MWRiODgsIDB4MWRiOTAsXHJcbiAgICAgICAgMHgxZGI5ZSwgMHgxZGJhMCwgMHgxZGJjYywgMHgxZGJmMiwgMHgxZGJmNCwgMHgxZGMyMiwgMHgxZGM0MiwgMHgxZGM0NCwgMHgxZGM0OCwgMHgxZGM1MCwgMHgxZGM1ZSwgMHgxZGM2NixcclxuICAgICAgICAweDFkYzdhLCAweDFkYzgyLCAweDFkYzg0LCAweDFkYzg4LCAweDFkYzkwLCAweDFkYzllLCAweDFkY2EwLCAweDFkY2JjLCAweDFkY2NjLCAweDFkY2YyLCAweDFkY2Y0LCAweDFkZDA0LFxyXG4gICAgICAgIDB4MWRkMDgsIDB4MWRkMTAsIDB4MWRkMWUsIDB4MWRkMjAsIDB4MWRkM2MsIDB4MWRkNDAsIDB4MWRkNzgsIDB4MWRkODYsIDB4MWRkOTgsIDB4MWRkY2UsIDB4MWRkZTIsIDB4MWRkZTQsXHJcbiAgICAgICAgMHgxZGRlOCwgMHgxZGUyZSwgMHgxZGUzMiwgMHgxZGUzNCwgMHgxZGU0ZSwgMHgxZGU1YywgMHgxZGU2MiwgMHgxZGU2NCwgMHgxZGU2OCwgMHgxZGU4ZSwgMHgxZGU5YywgMHgxZGViOCxcclxuICAgICAgICAweDFkZWMyLCAweDFkZWM0LCAweDFkZWM4LCAweDFkZWQwLCAweDFkZWU2LCAweDFkZWZhLCAweDFkZjE2LCAweDFkZjI2LCAweDFkZjJjLCAweDFkZjQ2LCAweDFkZjRjLCAweDFkZjU4LFxyXG4gICAgICAgIDB4MWRmNzIsIDB4MWRmNzQsIDB4MWRmOGEsIDB4MWRmOTIsIDB4MWRmOTQsIDB4MWRmYTIsIDB4MWRmYTQsIDB4MWRmYTgsIDB4MWUwOGEsIDB4MWUwOTIsIDB4MWUwOTQsIDB4MWUwYTIsXHJcbiAgICAgICAgMHgxZTBhNCwgMHgxZTBhOCwgMHgxZTBiNiwgMHgxZTBkYSwgMHgxZTEwYSwgMHgxZTExMiwgMHgxZTExNCwgMHgxZTEyMiwgMHgxZTEyNCwgMHgxZTEyOCwgMHgxZTEzNiwgMHgxZTE0MixcclxuICAgICAgICAweDFlMTQ0LCAweDFlMTQ4LCAweDFlMTUwLCAweDFlMTY2LCAweDFlMTZjLCAweDFlMTdhLCAweDFlMTlhLCAweDFlMWIyLCAweDFlMWI0LCAweDFlMjBhLCAweDFlMjEyLCAweDFlMjE0LFxyXG4gICAgICAgIDB4MWUyMjIsIDB4MWUyMjQsIDB4MWUyMjgsIDB4MWUyMzYsIDB4MWUyNDIsIDB4MWUyNDgsIDB4MWUyNTAsIDB4MWUyNWUsIDB4MWUyNjYsIDB4MWUyNmMsIDB4MWUyN2EsIDB4MWUyODIsXHJcbiAgICAgICAgMHgxZTI4NCwgMHgxZTI4OCwgMHgxZTI5MCwgMHgxZTJhMCwgMHgxZTJiYywgMHgxZTJjNiwgMHgxZTJjYywgMHgxZTJkOCwgMHgxZTJlZSwgMHgxZTJmMiwgMHgxZTJmNCwgMHgxZTMxYSxcclxuICAgICAgICAweDFlMzMyLCAweDFlMzM0LCAweDFlMzVjLCAweDFlMzYyLCAweDFlMzY0LCAweDFlMzY4LCAweDFlM2JhLCAweDFlNDBhLCAweDFlNDEyLCAweDFlNDE0LCAweDFlNDIyLCAweDFlNDI4LFxyXG4gICAgICAgIDB4MWU0MzYsIDB4MWU0NDIsIDB4MWU0NDgsIDB4MWU0NTAsIDB4MWU0NWUsIDB4MWU0NjYsIDB4MWU0NmMsIDB4MWU0N2EsIDB4MWU0ODIsIDB4MWU0ODQsIDB4MWU0OTAsIDB4MWU0OWUsXHJcbiAgICAgICAgMHgxZTRhMCwgMHgxZTRiYywgMHgxZTRjNiwgMHgxZTRjYywgMHgxZTRkOCwgMHgxZTRlZSwgMHgxZTRmMiwgMHgxZTRmNCwgMHgxZTUwMiwgMHgxZTUwNCwgMHgxZTUwOCwgMHgxZTUxMCxcclxuICAgICAgICAweDFlNTFlLCAweDFlNTIwLCAweDFlNTNjLCAweDFlNTQwLCAweDFlNTc4LCAweDFlNTg2LCAweDFlNThjLCAweDFlNTk4LCAweDFlNWIwLCAweDFlNWJlLCAweDFlNWNlLCAweDFlNWRjLFxyXG4gICAgICAgIDB4MWU1ZTIsIDB4MWU1ZTQsIDB4MWU1ZTgsIDB4MWU1ZjYsIDB4MWU2MWEsIDB4MWU2MmUsIDB4MWU2MzIsIDB4MWU2MzQsIDB4MWU2NGUsIDB4MWU2NWMsIDB4MWU2NjIsIDB4MWU2NjgsXHJcbiAgICAgICAgMHgxZTY4ZSwgMHgxZTY5YywgMHgxZTZiOCwgMHgxZTZjMiwgMHgxZTZjNCwgMHgxZTZjOCwgMHgxZTZkMCwgMHgxZTZlNiwgMHgxZTZmYSwgMHgxZTcxNiwgMHgxZTcyNiwgMHgxZTcyYyxcclxuICAgICAgICAweDFlNzNhLCAweDFlNzQ2LCAweDFlNzRjLCAweDFlNzU4LCAweDFlNzcyLCAweDFlNzc0LCAweDFlNzkyLCAweDFlNzk0LCAweDFlN2EyLCAweDFlN2E0LCAweDFlN2E4LCAweDFlN2I2LFxyXG4gICAgICAgIDB4MWU4MTIsIDB4MWU4MTQsIDB4MWU4MjIsIDB4MWU4MjQsIDB4MWU4MjgsIDB4MWU4MzYsIDB4MWU4NDIsIDB4MWU4NDQsIDB4MWU4NDgsIDB4MWU4NTAsIDB4MWU4NWUsIDB4MWU4NjYsXHJcbiAgICAgICAgMHgxZTg2YywgMHgxZTg3YSwgMHgxZTg4MiwgMHgxZTg4NCwgMHgxZTg4OCwgMHgxZTg5MCwgMHgxZTg5ZSwgMHgxZThhMCwgMHgxZThiYywgMHgxZThjNiwgMHgxZThjYywgMHgxZThkOCxcclxuICAgICAgICAweDFlOGVlLCAweDFlOGYyLCAweDFlOGY0LCAweDFlOTAyLCAweDFlOTA0LCAweDFlOTA4LCAweDFlOTEwLCAweDFlOTIwLCAweDFlOTNjLCAweDFlOTQwLCAweDFlOTc4LCAweDFlOTg2LFxyXG4gICAgICAgIDB4MWU5OGMsIDB4MWU5OTgsIDB4MWU5YjAsIDB4MWU5YmUsIDB4MWU5Y2UsIDB4MWU5ZGMsIDB4MWU5ZTIsIDB4MWU5ZTQsIDB4MWU5ZTgsIDB4MWU5ZjYsIDB4MWVhMDQsIDB4MWVhMDgsXHJcbiAgICAgICAgMHgxZWExMCwgMHgxZWEyMCwgMHgxZWE0MCwgMHgxZWE3OCwgMHgxZWFmMCwgMHgxZWIwNiwgMHgxZWIwYywgMHgxZWIxOCwgMHgxZWIzMCwgMHgxZWIzZSwgMHgxZWI2MCwgMHgxZWI3YyxcclxuICAgICAgICAweDFlYjhlLCAweDFlYjljLCAweDFlYmI4LCAweDFlYmMyLCAweDFlYmM0LCAweDFlYmM4LCAweDFlYmQwLCAweDFlYmRlLCAweDFlYmU2LCAweDFlYmVjLCAweDFlYzFhLCAweDFlYzJlLFxyXG4gICAgICAgIDB4MWVjMzIsIDB4MWVjMzQsIDB4MWVjNGUsIDB4MWVjNWMsIDB4MWVjNjIsIDB4MWVjNjQsIDB4MWVjNjgsIDB4MWVjOGUsIDB4MWVjOWMsIDB4MWVjYjgsIDB4MWVjYzIsIDB4MWVjYzQsXHJcbiAgICAgICAgMHgxZWNjOCwgMHgxZWNkMCwgMHgxZWNlNiwgMHgxZWNmYSwgMHgxZWQwZSwgMHgxZWQxYywgMHgxZWQzOCwgMHgxZWQ3MCwgMHgxZWQ3ZSwgMHgxZWQ4MiwgMHgxZWQ4NCwgMHgxZWQ4OCxcclxuICAgICAgICAweDFlZDkwLCAweDFlZDllLCAweDFlZGEwLCAweDFlZGNjLCAweDFlZGYyLCAweDFlZGY0LCAweDFlZTE2LCAweDFlZTI2LCAweDFlZTJjLCAweDFlZTNhLCAweDFlZTQ2LCAweDFlZTRjLFxyXG4gICAgICAgIDB4MWVlNTgsIDB4MWVlNmUsIDB4MWVlNzIsIDB4MWVlNzQsIDB4MWVlODYsIDB4MWVlOGMsIDB4MWVlOTgsIDB4MWVlYjAsIDB4MWVlYmUsIDB4MWVlY2UsIDB4MWVlZGMsIDB4MWVlZTIsXHJcbiAgICAgICAgMHgxZWVlNCwgMHgxZWVlOCwgMHgxZWYxMiwgMHgxZWYyMiwgMHgxZWYyNCwgMHgxZWYyOCwgMHgxZWYzNiwgMHgxZWY0MiwgMHgxZWY0NCwgMHgxZWY0OCwgMHgxZWY1MCwgMHgxZWY1ZSxcclxuICAgICAgICAweDFlZjY2LCAweDFlZjZjLCAweDFlZjdhLCAweDFlZmFlLCAweDFlZmIyLCAweDFlZmI0LCAweDFlZmQ2LCAweDFmMDk2LCAweDFmMGE2LCAweDFmMGFjLCAweDFmMGJhLCAweDFmMGNhLFxyXG4gICAgICAgIDB4MWYwZDIsIDB4MWYwZDQsIDB4MWYxMTYsIDB4MWYxMjYsIDB4MWYxMmMsIDB4MWYxM2EsIDB4MWYxNDYsIDB4MWYxNGMsIDB4MWYxNTgsIDB4MWYxNmUsIDB4MWYxNzIsIDB4MWYxNzQsXHJcbiAgICAgICAgMHgxZjE4YSwgMHgxZjE5MiwgMHgxZjE5NCwgMHgxZjFhMiwgMHgxZjFhNCwgMHgxZjFhOCwgMHgxZjFkYSwgMHgxZjIxNiwgMHgxZjIyNiwgMHgxZjIyYywgMHgxZjIzYSwgMHgxZjI0NixcclxuICAgICAgICAweDFmMjU4LCAweDFmMjZlLCAweDFmMjcyLCAweDFmMjc0LCAweDFmMjg2LCAweDFmMjhjLCAweDFmMjk4LCAweDFmMmIwLCAweDFmMmJlLCAweDFmMmNlLCAweDFmMmRjLCAweDFmMmUyLFxyXG4gICAgICAgIDB4MWYyZTQsIDB4MWYyZTgsIDB4MWYyZjYsIDB4MWYzMGEsIDB4MWYzMTIsIDB4MWYzMTQsIDB4MWYzMjIsIDB4MWYzMjgsIDB4MWYzNDIsIDB4MWYzNDQsIDB4MWYzNDgsIDB4MWYzNTAsXHJcbiAgICAgICAgMHgxZjM1ZSwgMHgxZjM2NiwgMHgxZjM3YSwgMHgxZjM5YSwgMHgxZjNhZSwgMHgxZjNiMiwgMHgxZjNiNCwgMHgxZjQxNiwgMHgxZjQyNiwgMHgxZjQyYywgMHgxZjQzYSwgMHgxZjQ0NixcclxuICAgICAgICAweDFmNDRjLCAweDFmNDU4LCAweDFmNDZlLCAweDFmNDcyLCAweDFmNDc0LCAweDFmNDg2LCAweDFmNDhjLCAweDFmNDk4LCAweDFmNGIwLCAweDFmNGJlLCAweDFmNGNlLCAweDFmNGRjLFxyXG4gICAgICAgIDB4MWY0ZTIsIDB4MWY0ZTQsIDB4MWY0ZTgsIDB4MWY0ZjYsIDB4MWY1MDYsIDB4MWY1MGMsIDB4MWY1MTgsIDB4MWY1MzAsIDB4MWY1M2UsIDB4MWY1NjAsIDB4MWY1N2MsIDB4MWY1OGUsXHJcbiAgICAgICAgMHgxZjU5YywgMHgxZjViOCwgMHgxZjVjMiwgMHgxZjVjNCwgMHgxZjVjOCwgMHgxZjVkMCwgMHgxZjVkZSwgMHgxZjVlNiwgMHgxZjVlYywgMHgxZjVmYSwgMHgxZjYwYSwgMHgxZjYxMixcclxuICAgICAgICAweDFmNjE0LCAweDFmNjIyLCAweDFmNjI0LCAweDFmNjI4LCAweDFmNjM2LCAweDFmNjQyLCAweDFmNjQ0LCAweDFmNjQ4LCAweDFmNjUwLCAweDFmNjVlLCAweDFmNjY2LCAweDFmNjdhLFxyXG4gICAgICAgIDB4MWY2ODIsIDB4MWY2ODQsIDB4MWY2ODgsIDB4MWY2OTAsIDB4MWY2OWUsIDB4MWY2YTAsIDB4MWY2YmMsIDB4MWY2Y2MsIDB4MWY2ZjIsIDB4MWY2ZjQsIDB4MWY3MWEsIDB4MWY3MmUsXHJcbiAgICAgICAgMHgxZjczMiwgMHgxZjczNCwgMHgxZjc0ZSwgMHgxZjc1YywgMHgxZjc2MiwgMHgxZjc2NCwgMHgxZjc2OCwgMHgxZjc3NiwgMHgxZjc5NiwgMHgxZjdhNiwgMHgxZjdhYywgMHgxZjdiYSxcclxuICAgICAgICAweDFmN2QyLCAweDFmN2Q0LCAweDFmODlhLCAweDFmOGFlLCAweDFmOGIyLCAweDFmOGI0LCAweDFmOGQ2LCAweDFmOGVhLCAweDFmOTFhLCAweDFmOTJlLCAweDFmOTMyLCAweDFmOTM0LFxyXG4gICAgICAgIDB4MWY5NGUsIDB4MWY5NWMsIDB4MWY5NjIsIDB4MWY5NjQsIDB4MWY5NjgsIDB4MWY5NzYsIDB4MWY5OTYsIDB4MWY5YTYsIDB4MWY5YWMsIDB4MWY5YmEsIDB4MWY5Y2EsIDB4MWY5ZDIsXHJcbiAgICAgICAgMHgxZjlkNCwgMHgxZmExYSwgMHgxZmEyZSwgMHgxZmEzMiwgMHgxZmEzNCwgMHgxZmE0ZSwgMHgxZmE1YywgMHgxZmE2MiwgMHgxZmE2NCwgMHgxZmE2OCwgMHgxZmE3NiwgMHgxZmE4ZSxcclxuICAgICAgICAweDFmYTljLCAweDFmYWI4LCAweDFmYWMyLCAweDFmYWM0LCAweDFmYWM4LCAweDFmYWQwLCAweDFmYWRlLCAweDFmYWU2LCAweDFmYWVjLCAweDFmYjE2LCAweDFmYjI2LCAweDFmYjJjLFxyXG4gICAgICAgIDB4MWZiM2EsIDB4MWZiNDYsIDB4MWZiNGMsIDB4MWZiNTgsIDB4MWZiNmUsIDB4MWZiNzIsIDB4MWZiNzQsIDB4MWZiOGEsIDB4MWZiOTIsIDB4MWZiOTQsIDB4MWZiYTIsIDB4MWZiYTQsXHJcbiAgICAgICAgMHgxZmJhOCwgMHgxZmJiNiwgMHgxZmJkYVxyXG4gICAgXSk7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgdGFibGUgY29udGFpbnMgdG8gY29kZXdvcmRzIGZvciBhbGwgc3ltYm9scy5cclxuICAgICAqL1xyXG4gICAgUERGNDE3Q29tbW9uLkNPREVXT1JEX1RBQkxFID0gSW50MzJBcnJheS5mcm9tKFtcclxuICAgICAgICAyNjI3LCAxODE5LCAyNjIyLCAyNjIxLCAxODEzLCAxODEyLCAyNzI5LCAyNzI0LCAyNzIzLCAyNzc5LCAyNzc0LCAyNzczLCA5MDIsIDg5NiwgOTA4LCA4NjgsIDg2NSwgODYxLCA4NTksIDI1MTEsXHJcbiAgICAgICAgODczLCA4NzEsIDE3ODAsIDgzNSwgMjQ5MywgODI1LCAyNDkxLCA4NDIsIDgzNywgODQ0LCAxNzY0LCAxNzYyLCA4MTEsIDgxMCwgODA5LCAyNDgzLCA4MDcsIDI0ODIsIDgwNiwgMjQ4MCwgODE1LFxyXG4gICAgICAgIDgxNCwgODEzLCA4MTIsIDI0ODQsIDgxNywgODE2LCAxNzQ1LCAxNzQ0LCAxNzQyLCAxNzQ2LCAyNjU1LCAyNjM3LCAyNjM1LCAyNjI2LCAyNjI1LCAyNjIzLCAyNjI4LCAxODIwLCAyNzUyLFxyXG4gICAgICAgIDI3MzksIDI3MzcsIDI3MjgsIDI3MjcsIDI3MjUsIDI3MzAsIDI3ODUsIDI3ODMsIDI3NzgsIDI3NzcsIDI3NzUsIDI3ODAsIDc4NywgNzgxLCA3NDcsIDczOSwgNzM2LCAyNDEzLCA3NTQsIDc1MixcclxuICAgICAgICAxNzE5LCA2OTIsIDY4OSwgNjgxLCAyMzcxLCA2NzgsIDIzNjksIDcwMCwgNjk3LCA2OTQsIDcwMywgMTY4OCwgMTY4NiwgNjQyLCA2MzgsIDIzNDMsIDYzMSwgMjM0MSwgNjI3LCAyMzM4LCA2NTEsXHJcbiAgICAgICAgNjQ2LCA2NDMsIDIzNDUsIDY1NCwgNjUyLCAxNjUyLCAxNjUwLCAxNjQ3LCAxNjU0LCA2MDEsIDU5OSwgMjMyMiwgNTk2LCAyMzIxLCA1OTQsIDIzMTksIDIzMTcsIDYxMSwgNjEwLCA2MDgsIDYwNixcclxuICAgICAgICAyMzI0LCA2MDMsIDIzMjMsIDYxNSwgNjE0LCA2MTIsIDE2MTcsIDE2MTYsIDE2MTQsIDE2MTIsIDYxNiwgMTYxOSwgMTYxOCwgMjU3NSwgMjUzOCwgMjUzNiwgOTA1LCA5MDEsIDg5OCwgOTA5LFxyXG4gICAgICAgIDI1MDksIDI1MDcsIDI1MDQsIDg3MCwgODY3LCA4NjQsIDg2MCwgMjUxMiwgODc1LCA4NzIsIDE3ODEsIDI0OTAsIDI0ODksIDI0ODcsIDI0ODUsIDE3NDgsIDgzNiwgODM0LCA4MzIsIDgzMCxcclxuICAgICAgICAyNDk0LCA4MjcsIDI0OTIsIDg0MywgODQxLCA4MzksIDg0NSwgMTc2NSwgMTc2MywgMjcwMSwgMjY3NiwgMjY3NCwgMjY1MywgMjY0OCwgMjY1NiwgMjYzNCwgMjYzMywgMjYzMSwgMjYyOSxcclxuICAgICAgICAxODIxLCAyNjM4LCAyNjM2LCAyNzcwLCAyNzYzLCAyNzYxLCAyNzUwLCAyNzQ1LCAyNzUzLCAyNzM2LCAyNzM1LCAyNzMzLCAyNzMxLCAxODQ4LCAyNzQwLCAyNzM4LCAyNzg2LCAyNzg0LCA1OTEsXHJcbiAgICAgICAgNTg4LCA1NzYsIDU2OSwgNTY2LCAyMjk2LCAxNTkwLCA1MzcsIDUzNCwgNTI2LCAyMjc2LCA1MjIsIDIyNzQsIDU0NSwgNTQyLCA1MzksIDU0OCwgMTU3MiwgMTU3MCwgNDgxLCAyMjQ1LCA0NjYsXHJcbiAgICAgICAgMjI0MiwgNDYyLCAyMjM5LCA0OTIsIDQ4NSwgNDgyLCAyMjQ5LCA0OTYsIDQ5NCwgMTUzNCwgMTUzMSwgMTUyOCwgMTUzOCwgNDEzLCAyMTk2LCA0MDYsIDIxOTEsIDIxODgsIDQyNSwgNDE5LFxyXG4gICAgICAgIDIyMDIsIDQxNSwgMjE5OSwgNDMyLCA0MzAsIDQyNywgMTQ3MiwgMTQ2NywgMTQ2NCwgNDMzLCAxNDc2LCAxNDc0LCAzNjgsIDM2NywgMjE2MCwgMzY1LCAyMTU5LCAzNjIsIDIxNTcsIDIxNTUsXHJcbiAgICAgICAgMjE1MiwgMzc4LCAzNzcsIDM3NSwgMjE2NiwgMzcyLCAyMTY1LCAzNjksIDIxNjIsIDM4MywgMzgxLCAzNzksIDIxNjgsIDE0MTksIDE0MTgsIDE0MTYsIDE0MTQsIDM4NSwgMTQxMSwgMzg0LFxyXG4gICAgICAgIDE0MjMsIDE0MjIsIDE0MjAsIDE0MjQsIDI0NjEsIDgwMiwgMjQ0MSwgMjQzOSwgNzkwLCA3ODYsIDc4MywgNzk0LCAyNDA5LCAyNDA2LCAyNDAzLCA3NTAsIDc0MiwgNzM4LCAyNDE0LCA3NTYsXHJcbiAgICAgICAgNzUzLCAxNzIwLCAyMzY3LCAyMzY1LCAyMzYyLCAyMzU5LCAxNjYzLCA2OTMsIDY5MSwgNjg0LCAyMzczLCA2ODAsIDIzNzAsIDcwMiwgNjk5LCA2OTYsIDcwNCwgMTY5MCwgMTY4NywgMjMzNyxcclxuICAgICAgICAyMzM2LCAyMzM0LCAyMzMyLCAxNjI0LCAyMzI5LCAxNjIyLCA2NDAsIDYzNywgMjM0NCwgNjM0LCAyMzQyLCA2MzAsIDIzNDAsIDY1MCwgNjQ4LCA2NDUsIDIzNDYsIDY1NSwgNjUzLCAxNjUzLFxyXG4gICAgICAgIDE2NTEsIDE2NDksIDE2NTUsIDI2MTIsIDI1OTcsIDI1OTUsIDI1NzEsIDI1NjgsIDI1NjUsIDI1NzYsIDI1MzQsIDI1MjksIDI1MjYsIDE3ODcsIDI1NDAsIDI1MzcsIDkwNywgOTA0LCA5MDAsXHJcbiAgICAgICAgOTEwLCAyNTAzLCAyNTAyLCAyNTAwLCAyNDk4LCAxNzY4LCAyNDk1LCAxNzY3LCAyNTEwLCAyNTA4LCAyNTA2LCA4NjksIDg2NiwgODYzLCAyNTEzLCA4NzYsIDg3NCwgMTc4MiwgMjcyMCwgMjcxMyxcclxuICAgICAgICAyNzExLCAyNjk3LCAyNjk0LCAyNjkxLCAyNzAyLCAyNjcyLCAyNjcwLCAyNjY0LCAxODI4LCAyNjc4LCAyNjc1LCAyNjQ3LCAyNjQ2LCAyNjQ0LCAyNjQyLCAxODIzLCAyNjM5LCAxODIyLCAyNjU0LFxyXG4gICAgICAgIDI2NTIsIDI2NTAsIDI2NTcsIDI3NzEsIDE4NTUsIDI3NjUsIDI3NjIsIDE4NTAsIDE4NDksIDI3NTEsIDI3NDksIDI3NDcsIDI3NTQsIDM1MywgMjE0OCwgMzQ0LCAzNDIsIDMzNiwgMjE0MixcclxuICAgICAgICAzMzIsIDIxNDAsIDM0NSwgMTM3NSwgMTM3MywgMzA2LCAyMTMwLCAyOTksIDIxMjgsIDI5NSwgMjEyNSwgMzE5LCAzMTQsIDMxMSwgMjEzMiwgMTM1NCwgMTM1MiwgMTM0OSwgMTM1NiwgMjYyLFxyXG4gICAgICAgIDI1NywgMjEwMSwgMjUzLCAyMDk2LCAyMDkzLCAyNzQsIDI3MywgMjY3LCAyMTA3LCAyNjMsIDIxMDQsIDI4MCwgMjc4LCAyNzUsIDEzMTYsIDEzMTEsIDEzMDgsIDEzMjAsIDEzMTgsIDIwNTIsXHJcbiAgICAgICAgMjAyLCAyMDUwLCAyMDQ0LCAyMDQwLCAyMTksIDIwNjMsIDIxMiwgMjA2MCwgMjA4LCAyMDU1LCAyMjQsIDIyMSwgMjA2NiwgMTI2MCwgMTI1OCwgMTI1MiwgMjMxLCAxMjQ4LCAyMjksIDEyNjYsXHJcbiAgICAgICAgMTI2NCwgMTI2MSwgMTI2OCwgMTU1LCAxOTk4LCAxNTMsIDE5OTYsIDE5OTQsIDE5OTEsIDE5ODgsIDE2NSwgMTY0LCAyMDA3LCAxNjIsIDIwMDYsIDE1OSwgMjAwMywgMjAwMCwgMTcyLCAxNzEsXHJcbiAgICAgICAgMTY5LCAyMDEyLCAxNjYsIDIwMTAsIDExODYsIDExODQsIDExODIsIDExNzksIDE3NSwgMTE3NiwgMTczLCAxMTkyLCAxMTkxLCAxMTg5LCAxMTg3LCAxNzYsIDExOTQsIDExOTMsIDIzMTMsXHJcbiAgICAgICAgMjMwNywgMjMwNSwgNTkyLCA1ODksIDIyOTQsIDIyOTIsIDIyODksIDU3OCwgNTcyLCA1NjgsIDIyOTcsIDU4MCwgMTU5MSwgMjI3MiwgMjI2NywgMjI2NCwgMTU0NywgNTM4LCA1MzYsIDUyOSxcclxuICAgICAgICAyMjc4LCA1MjUsIDIyNzUsIDU0NywgNTQ0LCA1NDEsIDE1NzQsIDE1NzEsIDIyMzcsIDIyMzUsIDIyMjksIDE0OTMsIDIyMjUsIDE0ODksIDQ3OCwgMjI0NywgNDcwLCAyMjQ0LCA0NjUsIDIyNDEsXHJcbiAgICAgICAgNDkzLCA0ODgsIDQ4NCwgMjI1MCwgNDk4LCA0OTUsIDE1MzYsIDE1MzMsIDE1MzAsIDE1MzksIDIxODcsIDIxODYsIDIxODQsIDIxODIsIDE0MzIsIDIxNzksIDE0MzAsIDIxNzYsIDE0MjcsIDQxNCxcclxuICAgICAgICA0MTIsIDIxOTcsIDQwOSwgMjE5NSwgNDA1LCAyMTkzLCAyMTkwLCA0MjYsIDQyNCwgNDIxLCAyMjAzLCA0MTgsIDIyMDEsIDQzMSwgNDI5LCAxNDczLCAxNDcxLCAxNDY5LCAxNDY2LCA0MzQsXHJcbiAgICAgICAgMTQ3NywgMTQ3NSwgMjQ3OCwgMjQ3MiwgMjQ3MCwgMjQ1OSwgMjQ1NywgMjQ1NCwgMjQ2MiwgODAzLCAyNDM3LCAyNDMyLCAyNDI5LCAxNzI2LCAyNDQzLCAyNDQwLCA3OTIsIDc4OSwgNzg1LFxyXG4gICAgICAgIDI0MDEsIDIzOTksIDIzOTMsIDE3MDIsIDIzODksIDE2OTksIDI0MTEsIDI0MDgsIDI0MDUsIDc0NSwgNzQxLCAyNDE1LCA3NTgsIDc1NSwgMTcyMSwgMjM1OCwgMjM1NywgMjM1NSwgMjM1MyxcclxuICAgICAgICAxNjYxLCAyMzUwLCAxNjYwLCAyMzQ3LCAxNjU3LCAyMzY4LCAyMzY2LCAyMzY0LCAyMzYxLCAxNjY2LCA2OTAsIDY4NywgMjM3NCwgNjgzLCAyMzcyLCA3MDEsIDY5OCwgNzA1LCAxNjkxLCAxNjg5LFxyXG4gICAgICAgIDI2MTksIDI2MTcsIDI2MTAsIDI2MDgsIDI2MDUsIDI2MTMsIDI1OTMsIDI1ODgsIDI1ODUsIDE4MDMsIDI1OTksIDI1OTYsIDI1NjMsIDI1NjEsIDI1NTUsIDE3OTcsIDI1NTEsIDE3OTUsIDI1NzMsXHJcbiAgICAgICAgMjU3MCwgMjU2NywgMjU3NywgMjUyNSwgMjUyNCwgMjUyMiwgMjUyMCwgMTc4NiwgMjUxNywgMTc4NSwgMjUxNCwgMTc4MywgMjUzNSwgMjUzMywgMjUzMSwgMjUyOCwgMTc4OCwgMjU0MSwgMjUzOSxcclxuICAgICAgICA5MDYsIDkwMywgOTExLCAyNzIxLCAxODQ0LCAyNzE1LCAyNzEyLCAxODM4LCAxODM2LCAyNjk5LCAyNjk2LCAyNjkzLCAyNzAzLCAxODI3LCAxODI2LCAxODI0LCAyNjczLCAyNjcxLCAyNjY5LFxyXG4gICAgICAgIDI2NjYsIDE4MjksIDI2NzksIDI2NzcsIDE4NTgsIDE4NTcsIDI3NzIsIDE4NTQsIDE4NTMsIDE4NTEsIDE4NTYsIDI3NjYsIDI3NjQsIDE0MywgMTk4NywgMTM5LCAxOTg2LCAxMzUsIDEzMyxcclxuICAgICAgICAxMzEsIDE5ODQsIDEyOCwgMTk4MywgMTI1LCAxOTgxLCAxMzgsIDEzNywgMTM2LCAxOTg1LCAxMTMzLCAxMTMyLCAxMTMwLCAxMTIsIDExMCwgMTk3NCwgMTA3LCAxOTczLCAxMDQsIDE5NzEsXHJcbiAgICAgICAgMTk2OSwgMTIyLCAxMjEsIDExOSwgMTE3LCAxOTc3LCAxMTQsIDE5NzYsIDEyNCwgMTExNSwgMTExNCwgMTExMiwgMTExMCwgMTExNywgMTExNiwgODQsIDgzLCAxOTUzLCA4MSwgMTk1MiwgNzgsXHJcbiAgICAgICAgMTk1MCwgMTk0OCwgMTk0NSwgOTQsIDkzLCA5MSwgMTk1OSwgODgsIDE5NTgsIDg1LCAxOTU1LCA5OSwgOTcsIDk1LCAxOTYxLCAxMDg2LCAxMDg1LCAxMDgzLCAxMDgxLCAxMDc4LCAxMDAsXHJcbiAgICAgICAgMTA5MCwgMTA4OSwgMTA4NywgMTA5MSwgNDksIDQ3LCAxOTE3LCA0NCwgMTkxNSwgMTkxMywgMTkxMCwgMTkwNywgNTksIDE5MjYsIDU2LCAxOTI1LCA1MywgMTkyMiwgMTkxOSwgNjYsIDY0LFxyXG4gICAgICAgIDE5MzEsIDYxLCAxOTI5LCAxMDQyLCAxMDQwLCAxMDM4LCA3MSwgMTAzNSwgNzAsIDEwMzIsIDY4LCAxMDQ4LCAxMDQ3LCAxMDQ1LCAxMDQzLCAxMDUwLCAxMDQ5LCAxMiwgMTAsIDE4NjksIDE4NjcsXHJcbiAgICAgICAgMTg2NCwgMTg2MSwgMjEsIDE4ODAsIDE5LCAxODc3LCAxODc0LCAxODcxLCAyOCwgMTg4OCwgMjUsIDE4ODYsIDIyLCAxODgzLCA5ODIsIDk4MCwgOTc3LCA5NzQsIDMyLCAzMCwgOTkxLCA5ODksXHJcbiAgICAgICAgOTg3LCA5ODQsIDM0LCA5OTUsIDk5NCwgOTkyLCAyMTUxLCAyMTUwLCAyMTQ3LCAyMTQ2LCAyMTQ0LCAzNTYsIDM1NSwgMzU0LCAyMTQ5LCAyMTM5LCAyMTM4LCAyMTM2LCAyMTM0LCAxMzU5LFxyXG4gICAgICAgIDM0MywgMzQxLCAzMzgsIDIxNDMsIDMzNSwgMjE0MSwgMzQ4LCAzNDcsIDM0NiwgMTM3NiwgMTM3NCwgMjEyNCwgMjEyMywgMjEyMSwgMjExOSwgMTMyNiwgMjExNiwgMTMyNCwgMzEwLCAzMDgsXHJcbiAgICAgICAgMzA1LCAyMTMxLCAzMDIsIDIxMjksIDI5OCwgMjEyNywgMzIwLCAzMTgsIDMxNiwgMzEzLCAyMTMzLCAzMjIsIDMyMSwgMTM1NSwgMTM1MywgMTM1MSwgMTM1NywgMjA5MiwgMjA5MSwgMjA4OSxcclxuICAgICAgICAyMDg3LCAxMjc2LCAyMDg0LCAxMjc0LCAyMDgxLCAxMjcxLCAyNTksIDIxMDIsIDI1NiwgMjEwMCwgMjUyLCAyMDk4LCAyMDk1LCAyNzIsIDI2OSwgMjEwOCwgMjY2LCAyMTA2LCAyODEsIDI3OSxcclxuICAgICAgICAyNzcsIDEzMTcsIDEzMTUsIDEzMTMsIDEzMTAsIDI4MiwgMTMyMSwgMTMxOSwgMjAzOSwgMjAzNywgMjAzNSwgMjAzMiwgMTIwMywgMjAyOSwgMTIwMCwgMTE5NywgMjA3LCAyMDUzLCAyMDUsXHJcbiAgICAgICAgMjA1MSwgMjAxLCAyMDQ5LCAyMDQ2LCAyMDQzLCAyMjAsIDIxOCwgMjA2NCwgMjE1LCAyMDYyLCAyMTEsIDIwNTksIDIyOCwgMjI2LCAyMjMsIDIwNjksIDEyNTksIDEyNTcsIDEyNTQsIDIzMixcclxuICAgICAgICAxMjUxLCAyMzAsIDEyNjcsIDEyNjUsIDEyNjMsIDIzMTYsIDIzMTUsIDIzMTIsIDIzMTEsIDIzMDksIDIzMTQsIDIzMDQsIDIzMDMsIDIzMDEsIDIyOTksIDE1OTMsIDIzMDgsIDIzMDYsIDU5MCxcclxuICAgICAgICAyMjg4LCAyMjg3LCAyMjg1LCAyMjgzLCAxNTc4LCAyMjgwLCAxNTc3LCAyMjk1LCAyMjkzLCAyMjkxLCA1NzksIDU3NywgNTc0LCA1NzEsIDIyOTgsIDU4MiwgNTgxLCAxNTkyLCAyMjYzLCAyMjYyLFxyXG4gICAgICAgIDIyNjAsIDIyNTgsIDE1NDUsIDIyNTUsIDE1NDQsIDIyNTIsIDE1NDEsIDIyNzMsIDIyNzEsIDIyNjksIDIyNjYsIDE1NTAsIDUzNSwgNTMyLCAyMjc5LCA1MjgsIDIyNzcsIDU0NiwgNTQzLCA1NDksXHJcbiAgICAgICAgMTU3NSwgMTU3MywgMjIyNCwgMjIyMiwgMjIyMCwgMTQ4NiwgMjIxNywgMTQ4NSwgMjIxNCwgMTQ4MiwgMTQ3OSwgMjIzOCwgMjIzNiwgMjIzNCwgMjIzMSwgMTQ5NiwgMjIyOCwgMTQ5MiwgNDgwLFxyXG4gICAgICAgIDQ3NywgMjI0OCwgNDczLCAyMjQ2LCA0NjksIDIyNDMsIDQ5MCwgNDg3LCAyMjUxLCA0OTcsIDE1MzcsIDE1MzUsIDE1MzIsIDI0NzcsIDI0NzYsIDI0NzQsIDI0NzksIDI0NjksIDI0NjgsIDI0NjYsXHJcbiAgICAgICAgMjQ2NCwgMTczMCwgMjQ3MywgMjQ3MSwgMjQ1MywgMjQ1MiwgMjQ1MCwgMjQ0OCwgMTcyOSwgMjQ0NSwgMTcyOCwgMjQ2MCwgMjQ1OCwgMjQ1NiwgMjQ2MywgODA1LCA4MDQsIDI0MjgsIDI0MjcsXHJcbiAgICAgICAgMjQyNSwgMjQyMywgMTcyNSwgMjQyMCwgMTcyNCwgMjQxNywgMTcyMiwgMjQzOCwgMjQzNiwgMjQzNCwgMjQzMSwgMTcyNywgMjQ0NCwgMjQ0MiwgNzkzLCA3OTEsIDc4OCwgNzk1LCAyMzg4LFxyXG4gICAgICAgIDIzODYsIDIzODQsIDE2OTcsIDIzODEsIDE2OTYsIDIzNzgsIDE2OTQsIDE2OTIsIDI0MDIsIDI0MDAsIDIzOTgsIDIzOTUsIDE3MDMsIDIzOTIsIDE3MDEsIDI0MTIsIDI0MTAsIDI0MDcsIDc1MSxcclxuICAgICAgICA3NDgsIDc0NCwgMjQxNiwgNzU5LCA3NTcsIDE4MDcsIDI2MjAsIDI2MTgsIDE4MDYsIDE4MDUsIDI2MTEsIDI2MDksIDI2MDcsIDI2MTQsIDE4MDIsIDE4MDEsIDE3OTksIDI1OTQsIDI1OTIsXHJcbiAgICAgICAgMjU5MCwgMjU4NywgMTgwNCwgMjYwMCwgMjU5OCwgMTc5NCwgMTc5MywgMTc5MSwgMTc4OSwgMjU2NCwgMjU2MiwgMjU2MCwgMjU1NywgMTc5OCwgMjU1NCwgMTc5NiwgMjU3NCwgMjU3MiwgMjU2OSxcclxuICAgICAgICAyNTc4LCAxODQ3LCAxODQ2LCAyNzIyLCAxODQzLCAxODQyLCAxODQwLCAxODQ1LCAyNzE2LCAyNzE0LCAxODM1LCAxODM0LCAxODMyLCAxODMwLCAxODM5LCAxODM3LCAyNzAwLCAyNjk4LCAyNjk1LFxyXG4gICAgICAgIDI3MDQsIDE4MTcsIDE4MTEsIDE4MTAsIDg5NywgODYyLCAxNzc3LCA4MjksIDgyNiwgODM4LCAxNzYwLCAxNzU4LCA4MDgsIDI0ODEsIDE3NDEsIDE3NDAsIDE3MzgsIDE3NDMsIDI2MjQsIDE4MTgsXHJcbiAgICAgICAgMjcyNiwgMjc3NiwgNzgyLCA3NDAsIDczNywgMTcxNSwgNjg2LCA2NzksIDY5NSwgMTY4MiwgMTY4MCwgNjM5LCA2MjgsIDIzMzksIDY0NywgNjQ0LCAxNjQ1LCAxNjQzLCAxNjQwLCAxNjQ4LFxyXG4gICAgICAgIDYwMiwgNjAwLCA1OTcsIDU5NSwgMjMyMCwgNTkzLCAyMzE4LCA2MDksIDYwNywgNjA0LCAxNjExLCAxNjEwLCAxNjA4LCAxNjA2LCA2MTMsIDE2MTUsIDE2MTMsIDIzMjgsIDkyNiwgOTI0LCA4OTIsXHJcbiAgICAgICAgODg2LCA4OTksIDg1NywgODUwLCAyNTA1LCAxNzc4LCA4MjQsIDgyMywgODIxLCA4MTksIDI0ODgsIDgxOCwgMjQ4NiwgODMzLCA4MzEsIDgyOCwgODQwLCAxNzYxLCAxNzU5LCAyNjQ5LCAyNjMyLFxyXG4gICAgICAgIDI2MzAsIDI3NDYsIDI3MzQsIDI3MzIsIDI3ODIsIDI3ODEsIDU3MCwgNTY3LCAxNTg3LCA1MzEsIDUyNywgNTIzLCA1NDAsIDE1NjYsIDE1NjQsIDQ3NiwgNDY3LCA0NjMsIDIyNDAsIDQ4NixcclxuICAgICAgICA0ODMsIDE1MjQsIDE1MjEsIDE1MTgsIDE1MjksIDQxMSwgNDAzLCAyMTkyLCAzOTksIDIxODksIDQyMywgNDE2LCAxNDYyLCAxNDU3LCAxNDU0LCA0MjgsIDE0NjgsIDE0NjUsIDIyMTAsIDM2NixcclxuICAgICAgICAzNjMsIDIxNTgsIDM2MCwgMjE1NiwgMzU3LCAyMTUzLCAzNzYsIDM3MywgMzcwLCAyMTYzLCAxNDEwLCAxNDA5LCAxNDA3LCAxNDA1LCAzODIsIDE0MDIsIDM4MCwgMTQxNywgMTQxNSwgMTQxMixcclxuICAgICAgICAxNDIxLCAyMTc1LCAyMTc0LCA3NzcsIDc3NCwgNzcxLCA3ODQsIDczMiwgNzI1LCA3MjIsIDI0MDQsIDc0MywgMTcxNiwgNjc2LCA2NzQsIDY2OCwgMjM2MywgNjY1LCAyMzYwLCA2ODUsIDE2ODQsXHJcbiAgICAgICAgMTY4MSwgNjI2LCA2MjQsIDYyMiwgMjMzNSwgNjIwLCAyMzMzLCA2MTcsIDIzMzAsIDY0MSwgNjM1LCA2NDksIDE2NDYsIDE2NDQsIDE2NDIsIDI1NjYsIDkyOCwgOTI1LCAyNTMwLCAyNTI3LFxyXG4gICAgICAgIDg5NCwgODkxLCA4ODgsIDI1MDEsIDI0OTksIDI0OTYsIDg1OCwgODU2LCA4NTQsIDg1MSwgMTc3OSwgMjY5MiwgMjY2OCwgMjY2NSwgMjY0NSwgMjY0MywgMjY0MCwgMjY1MSwgMjc2OCwgMjc1OSxcclxuICAgICAgICAyNzU3LCAyNzQ0LCAyNzQzLCAyNzQxLCAyNzQ4LCAzNTIsIDEzODIsIDM0MCwgMzM3LCAzMzMsIDEzNzEsIDEzNjksIDMwNywgMzAwLCAyOTYsIDIxMjYsIDMxNSwgMzEyLCAxMzQ3LCAxMzQyLFxyXG4gICAgICAgIDEzNTAsIDI2MSwgMjU4LCAyNTAsIDIwOTcsIDI0NiwgMjA5NCwgMjcxLCAyNjgsIDI2NCwgMTMwNiwgMTMwMSwgMTI5OCwgMjc2LCAxMzEyLCAxMzA5LCAyMTE1LCAyMDMsIDIwNDgsIDE5NSxcclxuICAgICAgICAyMDQ1LCAxOTEsIDIwNDEsIDIxMywgMjA5LCAyMDU2LCAxMjQ2LCAxMjQ0LCAxMjM4LCAyMjUsIDEyMzQsIDIyMiwgMTI1NiwgMTI1MywgMTI0OSwgMTI2MiwgMjA4MCwgMjA3OSwgMTU0LCAxOTk3LFxyXG4gICAgICAgIDE1MCwgMTk5NSwgMTQ3LCAxOTkyLCAxOTg5LCAxNjMsIDE2MCwgMjAwNCwgMTU2LCAyMDAxLCAxMTc1LCAxMTc0LCAxMTcyLCAxMTcwLCAxMTY3LCAxNzAsIDExNjQsIDE2NywgMTE4NSwgMTE4MyxcclxuICAgICAgICAxMTgwLCAxMTc3LCAxNzQsIDExOTAsIDExODgsIDIwMjUsIDIwMjQsIDIwMjIsIDU4NywgNTg2LCA1NjQsIDU1OSwgNTU2LCAyMjkwLCA1NzMsIDE1ODgsIDUyMCwgNTE4LCA1MTIsIDIyNjgsXHJcbiAgICAgICAgNTA4LCAyMjY1LCA1MzAsIDE1NjgsIDE1NjUsIDQ2MSwgNDU3LCAyMjMzLCA0NTAsIDIyMzAsIDQ0NiwgMjIyNiwgNDc5LCA0NzEsIDQ4OSwgMTUyNiwgMTUyMywgMTUyMCwgMzk3LCAzOTUsXHJcbiAgICAgICAgMjE4NSwgMzkyLCAyMTgzLCAzODksIDIxODAsIDIxNzcsIDQxMCwgMjE5NCwgNDAyLCA0MjIsIDE0NjMsIDE0NjEsIDE0NTksIDE0NTYsIDE0NzAsIDI0NTUsIDc5OSwgMjQzMywgMjQzMCwgNzc5LFxyXG4gICAgICAgIDc3NiwgNzczLCAyMzk3LCAyMzk0LCAyMzkwLCA3MzQsIDcyOCwgNzI0LCA3NDYsIDE3MTcsIDIzNTYsIDIzNTQsIDIzNTEsIDIzNDgsIDE2NTgsIDY3NywgNjc1LCA2NzMsIDY3MCwgNjY3LCA2ODgsXHJcbiAgICAgICAgMTY4NSwgMTY4MywgMjYwNiwgMjU4OSwgMjU4NiwgMjU1OSwgMjU1NiwgMjU1MiwgOTI3LCAyNTIzLCAyNTIxLCAyNTE4LCAyNTE1LCAxNzg0LCAyNTMyLCA4OTUsIDg5MywgODkwLCAyNzE4LFxyXG4gICAgICAgIDI3MDksIDI3MDcsIDI2ODksIDI2ODcsIDI2ODQsIDI2NjMsIDI2NjIsIDI2NjAsIDI2NTgsIDE4MjUsIDI2NjcsIDI3NjksIDE4NTIsIDI3NjAsIDI3NTgsIDE0MiwgMTQxLCAxMTM5LCAxMTM4LFxyXG4gICAgICAgIDEzNCwgMTMyLCAxMjksIDEyNiwgMTk4MiwgMTEyOSwgMTEyOCwgMTEyNiwgMTEzMSwgMTEzLCAxMTEsIDEwOCwgMTA1LCAxOTcyLCAxMDEsIDE5NzAsIDEyMCwgMTE4LCAxMTUsIDExMDksIDExMDgsXHJcbiAgICAgICAgMTEwNiwgMTEwNCwgMTIzLCAxMTEzLCAxMTExLCA4MiwgNzksIDE5NTEsIDc1LCAxOTQ5LCA3MiwgMTk0NiwgOTIsIDg5LCA4NiwgMTk1NiwgMTA3NywgMTA3NiwgMTA3NCwgMTA3MiwgOTgsXHJcbiAgICAgICAgMTA2OSwgOTYsIDEwODQsIDEwODIsIDEwNzksIDEwODgsIDE5NjgsIDE5NjcsIDQ4LCA0NSwgMTkxNiwgNDIsIDE5MTQsIDM5LCAxOTExLCAxOTA4LCA2MCwgNTcsIDU0LCAxOTIzLCA1MCwgMTkyMCxcclxuICAgICAgICAxMDMxLCAxMDMwLCAxMDI4LCAxMDI2LCA2NywgMTAyMywgNjUsIDEwMjAsIDYyLCAxMDQxLCAxMDM5LCAxMDM2LCAxMDMzLCA2OSwgMTA0NiwgMTA0NCwgMTk0NCwgMTk0MywgMTk0MSwgMTEsIDksXHJcbiAgICAgICAgMTg2OCwgNywgMTg2NSwgMTg2MiwgMTg1OSwgMjAsIDE4NzgsIDE2LCAxODc1LCAxMywgMTg3MiwgOTcwLCA5NjgsIDk2NiwgOTYzLCAyOSwgOTYwLCAyNiwgMjMsIDk4MywgOTgxLCA5NzgsIDk3NSxcclxuICAgICAgICAzMywgOTcxLCAzMSwgOTkwLCA5ODgsIDk4NSwgMTkwNiwgMTkwNCwgMTkwMiwgOTkzLCAzNTEsIDIxNDUsIDEzODMsIDMzMSwgMzMwLCAzMjgsIDMyNiwgMjEzNywgMzIzLCAyMTM1LCAzMzksXHJcbiAgICAgICAgMTM3MiwgMTM3MCwgMjk0LCAyOTMsIDI5MSwgMjg5LCAyMTIyLCAyODYsIDIxMjAsIDI4MywgMjExNywgMzA5LCAzMDMsIDMxNywgMTM0OCwgMTM0NiwgMTM0NCwgMjQ1LCAyNDQsIDI0MiwgMjA5MCxcclxuICAgICAgICAyMzksIDIwODgsIDIzNiwgMjA4NSwgMjA4MiwgMjYwLCAyMDk5LCAyNDksIDI3MCwgMTMwNywgMTMwNSwgMTMwMywgMTMwMCwgMTMxNCwgMTg5LCAyMDM4LCAxODYsIDIwMzYsIDE4MywgMjAzMyxcclxuICAgICAgICAyMDMwLCAyMDI2LCAyMDYsIDE5OCwgMjA0NywgMTk0LCAyMTYsIDEyNDcsIDEyNDUsIDEyNDMsIDEyNDAsIDIyNywgMTIzNywgMTI1NSwgMjMxMCwgMjMwMiwgMjMwMCwgMjI4NiwgMjI4NCxcclxuICAgICAgICAyMjgxLCA1NjUsIDU2MywgNTYxLCA1NTgsIDU3NSwgMTU4OSwgMjI2MSwgMjI1OSwgMjI1NiwgMjI1MywgMTU0MiwgNTIxLCA1MTksIDUxNywgNTE0LCAyMjcwLCA1MTEsIDUzMywgMTU2OSxcclxuICAgICAgICAxNTY3LCAyMjIzLCAyMjIxLCAyMjE4LCAyMjE1LCAxNDgzLCAyMjExLCAxNDgwLCA0NTksIDQ1NiwgNDUzLCAyMjMyLCA0NDksIDQ3NCwgNDkxLCAxNTI3LCAxNTI1LCAxNTIyLCAyNDc1LCAyNDY3LFxyXG4gICAgICAgIDI0NjUsIDI0NTEsIDI0NDksIDI0NDYsIDgwMSwgODAwLCAyNDI2LCAyNDI0LCAyNDIxLCAyNDE4LCAxNzIzLCAyNDM1LCA3ODAsIDc3OCwgNzc1LCAyMzg3LCAyMzg1LCAyMzgyLCAyMzc5LFxyXG4gICAgICAgIDE2OTUsIDIzNzUsIDE2OTMsIDIzOTYsIDczNSwgNzMzLCA3MzAsIDcyNywgNzQ5LCAxNzE4LCAyNjE2LCAyNjE1LCAyNjA0LCAyNjAzLCAyNjAxLCAyNTg0LCAyNTgzLCAyNTgxLCAyNTc5LFxyXG4gICAgICAgIDE4MDAsIDI1OTEsIDI1NTAsIDI1NDksIDI1NDcsIDI1NDUsIDE3OTIsIDI1NDIsIDE3OTAsIDI1NTgsIDkyOSwgMjcxOSwgMTg0MSwgMjcxMCwgMjcwOCwgMTgzMywgMTgzMSwgMjY5MCwgMjY4OCxcclxuICAgICAgICAyNjg2LCAxODE1LCAxODA5LCAxODA4LCAxNzc0LCAxNzU2LCAxNzU0LCAxNzM3LCAxNzM2LCAxNzM0LCAxNzM5LCAxODE2LCAxNzExLCAxNjc2LCAxNjc0LCA2MzMsIDYyOSwgMTYzOCwgMTYzNixcclxuICAgICAgICAxNjMzLCAxNjQxLCA1OTgsIDE2MDUsIDE2MDQsIDE2MDIsIDE2MDAsIDYwNSwgMTYwOSwgMTYwNywgMjMyNywgODg3LCA4NTMsIDE3NzUsIDgyMiwgODIwLCAxNzU3LCAxNzU1LCAxNTg0LCA1MjQsXHJcbiAgICAgICAgMTU2MCwgMTU1OCwgNDY4LCA0NjQsIDE1MTQsIDE1MTEsIDE1MDgsIDE1MTksIDQwOCwgNDA0LCA0MDAsIDE0NTIsIDE0NDcsIDE0NDQsIDQxNywgMTQ1OCwgMTQ1NSwgMjIwOCwgMzY0LCAzNjEsXHJcbiAgICAgICAgMzU4LCAyMTU0LCAxNDAxLCAxNDAwLCAxMzk4LCAxMzk2LCAzNzQsIDEzOTMsIDM3MSwgMTQwOCwgMTQwNiwgMTQwMywgMTQxMywgMjE3MywgMjE3MiwgNzcyLCA3MjYsIDcyMywgMTcxMiwgNjcyLFxyXG4gICAgICAgIDY2OSwgNjY2LCA2ODIsIDE2NzgsIDE2NzUsIDYyNSwgNjIzLCA2MjEsIDYxOCwgMjMzMSwgNjM2LCA2MzIsIDE2MzksIDE2MzcsIDE2MzUsIDkyMCwgOTE4LCA4ODQsIDg4MCwgODg5LCA4NDksXHJcbiAgICAgICAgODQ4LCA4NDcsIDg0NiwgMjQ5NywgODU1LCA4NTIsIDE3NzYsIDI2NDEsIDI3NDIsIDI3ODcsIDEzODAsIDMzNCwgMTM2NywgMTM2NSwgMzAxLCAyOTcsIDEzNDAsIDEzMzgsIDEzMzUsIDEzNDMsXHJcbiAgICAgICAgMjU1LCAyNTEsIDI0NywgMTI5NiwgMTI5MSwgMTI4OCwgMjY1LCAxMzAyLCAxMjk5LCAyMTEzLCAyMDQsIDE5NiwgMTkyLCAyMDQyLCAxMjMyLCAxMjMwLCAxMjI0LCAyMTQsIDEyMjAsIDIxMCxcclxuICAgICAgICAxMjQyLCAxMjM5LCAxMjM1LCAxMjUwLCAyMDc3LCAyMDc1LCAxNTEsIDE0OCwgMTk5MywgMTQ0LCAxOTkwLCAxMTYzLCAxMTYyLCAxMTYwLCAxMTU4LCAxMTU1LCAxNjEsIDExNTIsIDE1NyxcclxuICAgICAgICAxMTczLCAxMTcxLCAxMTY4LCAxMTY1LCAxNjgsIDExODEsIDExNzgsIDIwMjEsIDIwMjAsIDIwMTgsIDIwMjMsIDU4NSwgNTYwLCA1NTcsIDE1ODUsIDUxNiwgNTA5LCAxNTYyLCAxNTU5LCA0NTgsXHJcbiAgICAgICAgNDQ3LCAyMjI3LCA0NzIsIDE1MTYsIDE1MTMsIDE1MTAsIDM5OCwgMzk2LCAzOTMsIDM5MCwgMjE4MSwgMzg2LCAyMTc4LCA0MDcsIDE0NTMsIDE0NTEsIDE0NDksIDE0NDYsIDQyMCwgMTQ2MCxcclxuICAgICAgICAyMjA5LCA3NjksIDc2NCwgNzIwLCA3MTIsIDIzOTEsIDcyOSwgMTcxMywgNjY0LCA2NjMsIDY2MSwgNjU5LCAyMzUyLCA2NTYsIDIzNDksIDY3MSwgMTY3OSwgMTY3NywgMjU1MywgOTIyLCA5MTksXHJcbiAgICAgICAgMjUxOSwgMjUxNiwgODg1LCA4ODMsIDg4MSwgMjY4NSwgMjY2MSwgMjY1OSwgMjc2NywgMjc1NiwgMjc1NSwgMTQwLCAxMTM3LCAxMTM2LCAxMzAsIDEyNywgMTEyNSwgMTEyNCwgMTEyMiwgMTEyNyxcclxuICAgICAgICAxMDksIDEwNiwgMTAyLCAxMTAzLCAxMTAyLCAxMTAwLCAxMDk4LCAxMTYsIDExMDcsIDExMDUsIDE5ODAsIDgwLCA3NiwgNzMsIDE5NDcsIDEwNjgsIDEwNjcsIDEwNjUsIDEwNjMsIDkwLCAxMDYwLFxyXG4gICAgICAgIDg3LCAxMDc1LCAxMDczLCAxMDcwLCAxMDgwLCAxOTY2LCAxOTY1LCA0NiwgNDMsIDQwLCAxOTEyLCAzNiwgMTkwOSwgMTAxOSwgMTAxOCwgMTAxNiwgMTAxNCwgNTgsIDEwMTEsIDU1LCAxMDA4LFxyXG4gICAgICAgIDUxLCAxMDI5LCAxMDI3LCAxMDI0LCAxMDIxLCA2MywgMTAzNywgMTAzNCwgMTk0MCwgMTkzOSwgMTkzNywgMTk0MiwgOCwgMTg2NiwgNCwgMTg2MywgMSwgMTg2MCwgOTU2LCA5NTQsIDk1MixcclxuICAgICAgICA5NDksIDk0NiwgMTcsIDE0LCA5NjksIDk2NywgOTY0LCA5NjEsIDI3LCA5NTcsIDI0LCA5NzksIDk3NiwgOTcyLCAxOTAxLCAxOTAwLCAxODk4LCAxODk2LCA5ODYsIDE5MDUsIDE5MDMsIDM1MCxcclxuICAgICAgICAzNDksIDEzODEsIDMyOSwgMzI3LCAzMjQsIDEzNjgsIDEzNjYsIDI5MiwgMjkwLCAyODcsIDI4NCwgMjExOCwgMzA0LCAxMzQxLCAxMzM5LCAxMzM3LCAxMzQ1LCAyNDMsIDI0MCwgMjM3LCAyMDg2LFxyXG4gICAgICAgIDIzMywgMjA4MywgMjU0LCAxMjk3LCAxMjk1LCAxMjkzLCAxMjkwLCAxMzA0LCAyMTE0LCAxOTAsIDE4NywgMTg0LCAyMDM0LCAxODAsIDIwMzEsIDE3NywgMjAyNywgMTk5LCAxMjMzLCAxMjMxLFxyXG4gICAgICAgIDEyMjksIDEyMjYsIDIxNywgMTIyMywgMTI0MSwgMjA3OCwgMjA3NiwgNTg0LCA1NTUsIDU1NCwgNTUyLCA1NTAsIDIyODIsIDU2MiwgMTU4NiwgNTA3LCA1MDYsIDUwNCwgNTAyLCAyMjU3LCA0OTksXHJcbiAgICAgICAgMjI1NCwgNTE1LCAxNTYzLCAxNTYxLCA0NDUsIDQ0MywgNDQxLCAyMjE5LCA0MzgsIDIyMTYsIDQzNSwgMjIxMiwgNDYwLCA0NTQsIDQ3NSwgMTUxNywgMTUxNSwgMTUxMiwgMjQ0NywgNzk4LFxyXG4gICAgICAgIDc5NywgMjQyMiwgMjQxOSwgNzcwLCA3NjgsIDc2NiwgMjM4MywgMjM4MCwgMjM3NiwgNzIxLCA3MTksIDcxNywgNzE0LCA3MzEsIDE3MTQsIDI2MDIsIDI1ODIsIDI1ODAsIDI1NDgsIDI1NDYsXHJcbiAgICAgICAgMjU0MywgOTIzLCA5MjEsIDI3MTcsIDI3MDYsIDI3MDUsIDI2ODMsIDI2ODIsIDI2ODAsIDE3NzEsIDE3NTIsIDE3NTAsIDE3MzMsIDE3MzIsIDE3MzEsIDE3MzUsIDE4MTQsIDE3MDcsIDE2NzAsXHJcbiAgICAgICAgMTY2OCwgMTYzMSwgMTYyOSwgMTYyNiwgMTYzNCwgMTU5OSwgMTU5OCwgMTU5NiwgMTU5NCwgMTYwMywgMTYwMSwgMjMyNiwgMTc3MiwgMTc1MywgMTc1MSwgMTU4MSwgMTU1NCwgMTU1MiwgMTUwNCxcclxuICAgICAgICAxNTAxLCAxNDk4LCAxNTA5LCAxNDQyLCAxNDM3LCAxNDM0LCA0MDEsIDE0NDgsIDE0NDUsIDIyMDYsIDEzOTIsIDEzOTEsIDEzODksIDEzODcsIDEzODQsIDM1OSwgMTM5OSwgMTM5NywgMTM5NCxcclxuICAgICAgICAxNDA0LCAyMTcxLCAyMTcwLCAxNzA4LCAxNjcyLCAxNjY5LCA2MTksIDE2MzIsIDE2MzAsIDE2MjgsIDE3NzMsIDEzNzgsIDEzNjMsIDEzNjEsIDEzMzMsIDEzMjgsIDEzMzYsIDEyODYsIDEyODEsXHJcbiAgICAgICAgMTI3OCwgMjQ4LCAxMjkyLCAxMjg5LCAyMTExLCAxMjE4LCAxMjE2LCAxMjEwLCAxOTcsIDEyMDYsIDE5MywgMTIyOCwgMTIyNSwgMTIyMSwgMTIzNiwgMjA3MywgMjA3MSwgMTE1MSwgMTE1MCxcclxuICAgICAgICAxMTQ4LCAxMTQ2LCAxNTIsIDExNDMsIDE0OSwgMTE0MCwgMTQ1LCAxMTYxLCAxMTU5LCAxMTU2LCAxMTUzLCAxNTgsIDExNjksIDExNjYsIDIwMTcsIDIwMTYsIDIwMTQsIDIwMTksIDE1ODIsXHJcbiAgICAgICAgNTEwLCAxNTU2LCAxNTUzLCA0NTIsIDQ0OCwgMTUwNiwgMTUwMCwgMzk0LCAzOTEsIDM4NywgMTQ0MywgMTQ0MSwgMTQzOSwgMTQzNiwgMTQ1MCwgMjIwNywgNzY1LCA3MTYsIDcxMywgMTcwOSxcclxuICAgICAgICA2NjIsIDY2MCwgNjU3LCAxNjczLCAxNjcxLCA5MTYsIDkxNCwgODc5LCA4NzgsIDg3NywgODgyLCAxMTM1LCAxMTM0LCAxMTIxLCAxMTIwLCAxMTE4LCAxMTIzLCAxMDk3LCAxMDk2LCAxMDk0LFxyXG4gICAgICAgIDEwOTIsIDEwMywgMTEwMSwgMTA5OSwgMTk3OSwgMTA1OSwgMTA1OCwgMTA1NiwgMTA1NCwgNzcsIDEwNTEsIDc0LCAxMDY2LCAxMDY0LCAxMDYxLCAxMDcxLCAxOTY0LCAxOTYzLCAxMDA3LFxyXG4gICAgICAgIDEwMDYsIDEwMDQsIDEwMDIsIDk5OSwgNDEsIDk5NiwgMzcsIDEwMTcsIDEwMTUsIDEwMTIsIDEwMDksIDUyLCAxMDI1LCAxMDIyLCAxOTM2LCAxOTM1LCAxOTMzLCAxOTM4LCA5NDIsIDk0MCxcclxuICAgICAgICA5MzgsIDkzNSwgOTMyLCA1LCAyLCA5NTUsIDk1MywgOTUwLCA5NDcsIDE4LCA5NDMsIDE1LCA5NjUsIDk2MiwgOTU4LCAxODk1LCAxODk0LCAxODkyLCAxODkwLCA5NzMsIDE4OTksIDE4OTcsXHJcbiAgICAgICAgMTM3OSwgMzI1LCAxMzY0LCAxMzYyLCAyODgsIDI4NSwgMTMzNCwgMTMzMiwgMTMzMCwgMjQxLCAyMzgsIDIzNCwgMTI4NywgMTI4NSwgMTI4MywgMTI4MCwgMTI5NCwgMjExMiwgMTg4LCAxODUsXHJcbiAgICAgICAgMTgxLCAxNzgsIDIwMjgsIDEyMTksIDEyMTcsIDEyMTUsIDEyMTIsIDIwMCwgMTIwOSwgMTIyNywgMjA3NCwgMjA3MiwgNTgzLCA1NTMsIDU1MSwgMTU4MywgNTA1LCA1MDMsIDUwMCwgNTEzLFxyXG4gICAgICAgIDE1NTcsIDE1NTUsIDQ0NCwgNDQyLCA0MzksIDQzNiwgMjIxMywgNDU1LCA0NTEsIDE1MDcsIDE1MDUsIDE1MDIsIDc5NiwgNzYzLCA3NjIsIDc2MCwgNzY3LCA3MTEsIDcxMCwgNzA4LCA3MDYsXHJcbiAgICAgICAgMjM3NywgNzE4LCA3MTUsIDE3MTAsIDI1NDQsIDkxNywgOTE1LCAyNjgxLCAxNjI3LCAxNTk3LCAxNTk1LCAyMzI1LCAxNzY5LCAxNzQ5LCAxNzQ3LCAxNDk5LCAxNDM4LCAxNDM1LCAyMjA0LFxyXG4gICAgICAgIDEzOTAsIDEzODgsIDEzODUsIDEzOTUsIDIxNjksIDIxNjcsIDE3MDQsIDE2NjUsIDE2NjIsIDE2MjUsIDE2MjMsIDE2MjAsIDE3NzAsIDEzMjksIDEyODIsIDEyNzksIDIxMDksIDEyMTQsIDEyMDcsXHJcbiAgICAgICAgMTIyMiwgMjA2OCwgMjA2NSwgMTE0OSwgMTE0NywgMTE0NCwgMTE0MSwgMTQ2LCAxMTU3LCAxMTU0LCAyMDEzLCAyMDExLCAyMDA4LCAyMDE1LCAxNTc5LCAxNTQ5LCAxNTQ2LCAxNDk1LCAxNDg3LFxyXG4gICAgICAgIDE0MzMsIDE0MzEsIDE0MjgsIDE0MjUsIDM4OCwgMTQ0MCwgMjIwNSwgMTcwNSwgNjU4LCAxNjY3LCAxNjY0LCAxMTE5LCAxMDk1LCAxMDkzLCAxOTc4LCAxMDU3LCAxMDU1LCAxMDUyLCAxMDYyLFxyXG4gICAgICAgIDE5NjIsIDE5NjAsIDEwMDUsIDEwMDMsIDEwMDAsIDk5NywgMzgsIDEwMTMsIDEwMTAsIDE5MzIsIDE5MzAsIDE5MjcsIDE5MzQsIDk0MSwgOTM5LCA5MzYsIDkzMywgNiwgOTMwLCAzLCA5NTEsXHJcbiAgICAgICAgOTQ4LCA5NDQsIDE4ODksIDE4ODcsIDE4ODQsIDE4ODEsIDk1OSwgMTg5MywgMTg5MSwgMzUsIDEzNzcsIDEzNjAsIDEzNTgsIDEzMjcsIDEzMjUsIDEzMjIsIDEzMzEsIDEyNzcsIDEyNzUsXHJcbiAgICAgICAgMTI3MiwgMTI2OSwgMjM1LCAxMjg0LCAyMTEwLCAxMjA1LCAxMjA0LCAxMjAxLCAxMTk4LCAxODIsIDExOTUsIDE3OSwgMTIxMywgMjA3MCwgMjA2NywgMTU4MCwgNTAxLCAxNTUxLCAxNTQ4LFxyXG4gICAgICAgIDQ0MCwgNDM3LCAxNDk3LCAxNDk0LCAxNDkwLCAxNTAzLCA3NjEsIDcwOSwgNzA3LCAxNzA2LCA5MTMsIDkxMiwgMjE5OCwgMTM4NiwgMjE2NCwgMjE2MSwgMTYyMSwgMTc2NiwgMjEwMywgMTIwOCxcclxuICAgICAgICAyMDU4LCAyMDU0LCAxMTQ1LCAxMTQyLCAyMDA1LCAyMDAyLCAxOTk5LCAyMDA5LCAxNDg4LCAxNDI5LCAxNDI2LCAyMjAwLCAxNjk4LCAxNjU5LCAxNjU2LCAxOTc1LCAxMDUzLCAxOTU3LCAxOTU0LFxyXG4gICAgICAgIDEwMDEsIDk5OCwgMTkyNCwgMTkyMSwgMTkxOCwgMTkyOCwgOTM3LCA5MzQsIDkzMSwgMTg3OSwgMTg3NiwgMTg3MywgMTg3MCwgOTQ1LCAxODg1LCAxODgyLCAxMzIzLCAxMjczLCAxMjcwLFxyXG4gICAgICAgIDIxMDUsIDEyMDIsIDExOTksIDExOTYsIDEyMTEsIDIwNjEsIDIwNTcsIDE1NzYsIDE1NDMsIDE1NDAsIDE0ODQsIDE0ODEsIDE0NzgsIDE0OTEsIDE3MDBcclxuICAgIF0pO1xyXG4gICAgcmV0dXJuIFBERjQxN0NvbW1vbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUERGNDE3Q29tbW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QREY0MTdDb21tb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA5IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3O1xyXG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5CYXJjb2RlRm9ybWF0O1xyXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XHJcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLkNoZWNrc3VtRXhjZXB0aW9uO1xyXG52YXIgQ2hlY2tzdW1FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9DaGVja3N1bUV4Y2VwdGlvblwiKTtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuRm9ybWF0RXhjZXB0aW9uO1xyXG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xyXG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5Ob3RGb3VuZEV4Y2VwdGlvbjtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLlJlc3VsdDtcclxudmFyIFJlc3VsdF8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdFwiKTtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuY29tbW9uLkRlY29kZXJSZXN1bHQ7XHJcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLm11bHRpLk11bHRpcGxlQmFyY29kZVJlYWRlcjtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXIuUERGNDE3U2Nhbm5pbmdEZWNvZGVyO1xyXG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGV0ZWN0b3IuRGV0ZWN0b3I7XHJcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5kZXRlY3Rvci5QREY0MTdEZXRlY3RvclJlc3VsdDtcclxudmFyIFBERjQxN0NvbW1vbl8xID0gcmVxdWlyZShcIi4vUERGNDE3Q29tbW9uXCIpO1xyXG52YXIgSW50ZWdlcl8xID0gcmVxdWlyZShcIi4uL3V0aWwvSW50ZWdlclwiKTtcclxudmFyIFJlc3VsdE1ldGFkYXRhVHlwZV8xID0gcmVxdWlyZShcIi4uL1Jlc3VsdE1ldGFkYXRhVHlwZVwiKTtcclxudmFyIERldGVjdG9yXzEgPSByZXF1aXJlKFwiLi9kZXRlY3Rvci9EZXRlY3RvclwiKTtcclxudmFyIFBERjQxN1NjYW5uaW5nRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vZGVjb2Rlci9QREY0MTdTY2FubmluZ0RlY29kZXJcIik7XHJcbi8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0O1xyXG4vLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XHJcbi8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xyXG4vKipcclxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBjYW4gZGV0ZWN0IGFuZCBkZWNvZGUgUERGNDE3IGNvZGVzIGluIGFuIGltYWdlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcclxuICovXHJcbnZhciBQREY0MTdSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQREY0MTdSZWFkZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvLyBwcml2YXRlIHN0YXRpYyAvKmZpbmFsIFJlc3VsdFtdKi8gRU1QVFlfUkVTVUxUX0FSUkFZOiBSZXN1bHRbXSA9IG5ldyBSZXN1bHQoWzBdKTtcclxuICAgIC8qKlxyXG4gICAgICogTG9jYXRlcyBhbmQgZGVjb2RlcyBhIFBERjQxNyBjb2RlIGluIGFuIGltYWdlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gYSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjb250ZW50IGVuY29kZWQgYnkgdGhlIFBERjQxNyBjb2RlXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGEgUERGNDE3IGNvZGUgY2Fubm90IGJlIGZvdW5kLFxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYSBQREY0MTcgY2Fubm90IGJlIGRlY29kZWRcclxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgLy8gQE92ZXJyaWRlXHJcbiAgICBQREY0MTdSZWFkZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChpbWFnZSwgaGludHMpIHtcclxuICAgICAgICBpZiAoaGludHMgPT09IHZvaWQgMCkgeyBoaW50cyA9IG51bGw7IH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gUERGNDE3UmVhZGVyLmRlY29kZShpbWFnZSwgaGludHMsIGZhbHNlKTtcclxuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgcmVzdWx0Lmxlbmd0aCA9PT0gMCB8fCByZXN1bHRbMF0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQuZ2V0Tm90Rm91bmRJbnN0YW5jZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0WzBdO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBCaW5hcnlCaXRtYXBcclxuICAgICAqIEBwYXJhbSBpbWFnZVxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxyXG4gICAgICovXHJcbiAgICAvLyAgIEBPdmVycmlkZVxyXG4gICAgUERGNDE3UmVhZGVyLnByb3RvdHlwZS5kZWNvZGVNdWx0aXBsZSA9IGZ1bmN0aW9uIChpbWFnZSwgaGludHMpIHtcclxuICAgICAgICBpZiAoaGludHMgPT09IHZvaWQgMCkgeyBoaW50cyA9IG51bGw7IH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gUERGNDE3UmVhZGVyLmRlY29kZShpbWFnZSwgaGludHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoaWdub3JlZCkge1xyXG4gICAgICAgICAgICBpZiAoaWdub3JlZCBpbnN0YW5jZW9mIEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQgfHwgaWdub3JlZCBpbnN0YW5jZW9mIENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0LmdldE5vdEZvdW5kSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBpZ25vcmVkO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaW1hZ2VcclxuICAgICAqIEBwYXJhbSBoaW50c1xyXG4gICAgICogQHBhcmFtIG11bHRpcGxlXHJcbiAgICAgKlxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb27Dn1xyXG4gICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxyXG4gICAgICovXHJcbiAgICBQREY0MTdSZWFkZXIuZGVjb2RlID0gZnVuY3Rpb24gKGltYWdlLCBoaW50cywgbXVsdGlwbGUpIHtcclxuICAgICAgICB2YXIgZV8xLCBfYTtcclxuICAgICAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHZhciBkZXRlY3RvclJlc3VsdCA9IERldGVjdG9yXzEuZGVmYXVsdC5kZXRlY3RNdWx0aXBsZShpbWFnZSwgaGludHMsIG11bHRpcGxlKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGRldGVjdG9yUmVzdWx0LmdldFBvaW50cygpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IF9jLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlY29kZXJSZXN1bHQgPSBQREY0MTdTY2FubmluZ0RlY29kZXJfMS5kZWZhdWx0LmRlY29kZShkZXRlY3RvclJlc3VsdC5nZXRCaXRzKCksIHBvaW50c1s0XSwgcG9pbnRzWzVdLCBwb2ludHNbNl0sIHBvaW50c1s3XSwgUERGNDE3UmVhZGVyLmdldE1pbkNvZGV3b3JkV2lkdGgocG9pbnRzKSwgUERGNDE3UmVhZGVyLmdldE1heENvZGV3b3JkV2lkdGgocG9pbnRzKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFJlc3VsdF8xLmRlZmF1bHQoZGVjb2RlclJlc3VsdC5nZXRUZXh0KCksIGRlY29kZXJSZXN1bHQuZ2V0UmF3Qnl0ZXMoKSwgdW5kZWZpbmVkLCBwb2ludHMsIEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0LlBERl80MTcpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZGVjb2RlclJlc3VsdC5nZXRFQ0xldmVsKCkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBkZjQxN1Jlc3VsdE1ldGFkYXRhID0gZGVjb2RlclJlc3VsdC5nZXRPdGhlcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBkZjQxN1Jlc3VsdE1ldGFkYXRhICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5QREY0MTdfRVhUUkFfTUVUQURBVEEsIHBkZjQxN1Jlc3VsdE1ldGFkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0cy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH0pO1xyXG4gICAgfTtcclxuICAgIFBERjQxN1JlYWRlci5nZXRNYXhXaWR0aCA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcclxuICAgICAgICBpZiAocDEgPT0gbnVsbCB8fCBwMiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhNYXRoLmFicyhwMS5nZXRYKCkgLSBwMi5nZXRYKCkpKTtcclxuICAgIH07XHJcbiAgICBQREY0MTdSZWFkZXIuZ2V0TWluV2lkdGggPSBmdW5jdGlvbiAocDEsIHAyKSB7XHJcbiAgICAgICAgaWYgKHAxID09IG51bGwgfHwgcDIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gSW50ZWdlcl8xLmRlZmF1bHQuTUFYX1ZBTFVFO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC50cnVuYyhNYXRoLmFicyhwMS5nZXRYKCkgLSBwMi5nZXRYKCkpKTtcclxuICAgIH07XHJcbiAgICBQREY0MTdSZWFkZXIuZ2V0TWF4Q29kZXdvcmRXaWR0aCA9IGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5tYXgoTWF0aC5tYXgoUERGNDE3UmVhZGVyLmdldE1heFdpZHRoKHBbMF0sIHBbNF0pLCBQREY0MTdSZWFkZXIuZ2V0TWF4V2lkdGgocFs2XSwgcFsyXSkgKiBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1PRFVMRVNfSU5fQ09ERVdPUkQgL1xyXG4gICAgICAgICAgICBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOKSwgTWF0aC5tYXgoUERGNDE3UmVhZGVyLmdldE1heFdpZHRoKHBbMV0sIHBbNV0pLCBQREY0MTdSZWFkZXIuZ2V0TWF4V2lkdGgocFs3XSwgcFszXSkgKiBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1PRFVMRVNfSU5fQ09ERVdPUkQgL1xyXG4gICAgICAgICAgICBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1PRFVMRVNfSU5fU1RPUF9QQVRURVJOKSkpO1xyXG4gICAgfTtcclxuICAgIFBERjQxN1JlYWRlci5nZXRNaW5Db2Rld29yZFdpZHRoID0gZnVuY3Rpb24gKHApIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihNYXRoLm1pbihQREY0MTdSZWFkZXIuZ2V0TWluV2lkdGgocFswXSwgcFs0XSksIFBERjQxN1JlYWRlci5nZXRNaW5XaWR0aChwWzZdLCBwWzJdKSAqIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuTU9EVUxFU19JTl9DT0RFV09SRCAvXHJcbiAgICAgICAgICAgIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4pLCBNYXRoLm1pbihQREY0MTdSZWFkZXIuZ2V0TWluV2lkdGgocFsxXSwgcFs1XSksIFBERjQxN1JlYWRlci5nZXRNaW5XaWR0aChwWzddLCBwWzNdKSAqIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuTU9EVUxFU19JTl9DT0RFV09SRCAvXHJcbiAgICAgICAgICAgIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuTU9EVUxFU19JTl9TVE9QX1BBVFRFUk4pKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQE92ZXJyaWRlXHJcbiAgICBQREY0MTdSZWFkZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIG5vdGhpbmcgbmVlZHMgdG8gYmUgcmVzZXRcclxuICAgIH07XHJcbiAgICByZXR1cm4gUERGNDE3UmVhZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQREY0MTdSZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBERjQxN1JlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTc7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcclxuICovXHJcbnZhciBQREY0MTdSZXN1bHRNZXRhZGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBERjQxN1Jlc3VsdE1ldGFkYXRhKCkge1xyXG4gICAgICAgIHRoaXMuc2VnbWVudENvdW50ID0gLTE7XHJcbiAgICAgICAgdGhpcy5maWxlU2l6ZSA9IC0xO1xyXG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gLTE7XHJcbiAgICAgICAgdGhpcy5jaGVja3N1bSA9IC0xO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgU2VnbWVudCBJRCByZXByZXNlbnRzIHRoZSBzZWdtZW50IG9mIHRoZSB3aG9sZSBmaWxlIGRpc3RyaWJ1dGVkIG92ZXIgZGlmZmVyZW50IHN5bWJvbHMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBGaWxlIHNlZ21lbnQgaW5kZXhcclxuICAgICAqL1xyXG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLmdldFNlZ21lbnRJbmRleCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZWdtZW50SW5kZXg7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLnNldFNlZ21lbnRJbmRleCA9IGZ1bmN0aW9uIChzZWdtZW50SW5kZXgpIHtcclxuICAgICAgICB0aGlzLnNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIElzIHRoZSBzYW1lIGZvciBlYWNoIHJlbGF0ZWQgUERGNDE3IHN5bWJvbFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gRmlsZSBJRFxyXG4gICAgICovXHJcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuZ2V0RmlsZUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbGVJZDtcclxuICAgIH07XHJcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuc2V0RmlsZUlkID0gZnVuY3Rpb24gKGZpbGVJZCkge1xyXG4gICAgICAgIHRoaXMuZmlsZUlkID0gZmlsZUlkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBhbHdheXMgbnVsbFxyXG4gICAgICogQGRlcHJlY2F0ZWQgdXNlIGRlZGljYXRlZCBhbHJlYWR5IHBhcnNlZCBmaWVsZHNcclxuICAgICAqL1xyXG4gICAgLy8gICBARGVwcmVjYXRlZFxyXG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLmdldE9wdGlvbmFsRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25hbERhdGE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uYWxEYXRhIG9sZCBvcHRpb25hbCBkYXRhIGZvcm1hdCBhcyBpbnQgYXJyYXlcclxuICAgICAqIEBkZXByZWNhdGVkIHBhcnNlIGFuZCB1c2UgbmV3IGZpZWxkc1xyXG4gICAgICovXHJcbiAgICAvLyAgIEBEZXByZWNhdGVkXHJcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuc2V0T3B0aW9uYWxEYXRhID0gZnVuY3Rpb24gKG9wdGlvbmFsRGF0YSkge1xyXG4gICAgICAgIHRoaXMub3B0aW9uYWxEYXRhID0gb3B0aW9uYWxEYXRhO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB0cnVlIGlmIGl0IGlzIHRoZSBsYXN0IHNlZ21lbnRcclxuICAgICAqL1xyXG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLmlzTGFzdFNlZ21lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNlZ21lbnQ7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLnNldExhc3RTZWdtZW50ID0gZnVuY3Rpb24gKGxhc3RTZWdtZW50KSB7XHJcbiAgICAgICAgdGhpcy5sYXN0U2VnbWVudCA9IGxhc3RTZWdtZW50O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBjb3VudCBvZiBzZWdtZW50cywgLTEgaWYgbm90IHNldFxyXG4gICAgICovXHJcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuZ2V0U2VnbWVudENvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlZ21lbnRDb3VudDtcclxuICAgIH07XHJcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuc2V0U2VnbWVudENvdW50ID0gZnVuY3Rpb24gKHNlZ21lbnRDb3VudCAvKmludCovKSB7XHJcbiAgICAgICAgdGhpcy5zZWdtZW50Q291bnQgPSBzZWdtZW50Q291bnQ7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLmdldFNlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kZXIgfHwgbnVsbDtcclxuICAgIH07XHJcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuc2V0U2VuZGVyID0gZnVuY3Rpb24gKHNlbmRlcikge1xyXG4gICAgICAgIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xyXG4gICAgfTtcclxuICAgIFBERjQxN1Jlc3VsdE1ldGFkYXRhLnByb3RvdHlwZS5nZXRBZGRyZXNzZWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkcmVzc2VlIHx8IG51bGw7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLnNldEFkZHJlc3NlZSA9IGZ1bmN0aW9uIChhZGRyZXNzZWUpIHtcclxuICAgICAgICB0aGlzLmFkZHJlc3NlZSA9IGFkZHJlc3NlZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZpbGVuYW1lIG9mIHRoZSBlbmNvZGVkIGZpbGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIGZpbGVuYW1lXHJcbiAgICAgKi9cclxuICAgIFBERjQxN1Jlc3VsdE1ldGFkYXRhLnByb3RvdHlwZS5nZXRGaWxlTmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5maWxlTmFtZTtcclxuICAgIH07XHJcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuc2V0RmlsZU5hbWUgPSBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcclxuICAgICAgICB0aGlzLmZpbGVOYW1lID0gZmlsZU5hbWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBmaWxlc2l6ZSBpbiBieXRlcyBvZiB0aGUgZW5jb2RlZCBmaWxlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBmaWxlc2l6ZSBpbiBieXRlcywgLTEgaWYgbm90IHNldFxyXG4gICAgICovXHJcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuZ2V0RmlsZVNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZVNpemU7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3UmVzdWx0TWV0YWRhdGEucHJvdG90eXBlLnNldEZpbGVTaXplID0gZnVuY3Rpb24gKGZpbGVTaXplIC8qbG9uZyovKSB7XHJcbiAgICAgICAgdGhpcy5maWxlU2l6ZSA9IGZpbGVTaXplO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogMTYtYml0IENSQyBjaGVja3N1bSB1c2luZyBDQ0lUVC0xNlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gY3JjIGNoZWNrc3VtLCAtMSBpZiBub3Qgc2V0XHJcbiAgICAgKi9cclxuICAgIFBERjQxN1Jlc3VsdE1ldGFkYXRhLnByb3RvdHlwZS5nZXRDaGVja3N1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaGVja3N1bTtcclxuICAgIH07XHJcbiAgICBQREY0MTdSZXN1bHRNZXRhZGF0YS5wcm90b3R5cGUuc2V0Q2hlY2tzdW0gPSBmdW5jdGlvbiAoY2hlY2tzdW0gLyppbnQqLykge1xyXG4gICAgICAgIHRoaXMuY2hlY2tzdW0gPSBjaGVja3N1bTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIHVuaXggZXBvY2sgdGltZXN0YW1wLCBlbGFwc2VkIHNlY29uZHMgc2luY2UgMTk3MC0wMS0wMVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gZWxhcHNlZCBzZWNvbmRzLCAtMSBpZiBub3Qgc2V0XHJcbiAgICAgKi9cclxuICAgIFBERjQxN1Jlc3VsdE1ldGFkYXRhLnByb3RvdHlwZS5nZXRUaW1lc3RhbXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZXN0YW1wO1xyXG4gICAgfTtcclxuICAgIFBERjQxN1Jlc3VsdE1ldGFkYXRhLnByb3RvdHlwZS5zZXRUaW1lc3RhbXAgPSBmdW5jdGlvbiAodGltZXN0YW1wIC8qbG9uZyovKSB7XHJcbiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBERjQxN1Jlc3VsdE1ldGFkYXRhO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQREY0MTdSZXN1bHRNZXRhZGF0YTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UERGNDE3UmVzdWx0TWV0YWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXI7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcclxuICovXHJcbnZhciBCYXJjb2RlTWV0YWRhdGEgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCYXJjb2RlTWV0YWRhdGEoY29sdW1uQ291bnQsIHJvd0NvdW50VXBwZXJQYXJ0LCByb3dDb3VudExvd2VyUGFydCwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcclxuICAgICAgICB0aGlzLmNvbHVtbkNvdW50ID0gY29sdW1uQ291bnQ7XHJcbiAgICAgICAgdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbCA9IGVycm9yQ29ycmVjdGlvbkxldmVsO1xyXG4gICAgICAgIHRoaXMucm93Q291bnRVcHBlclBhcnQgPSByb3dDb3VudFVwcGVyUGFydDtcclxuICAgICAgICB0aGlzLnJvd0NvdW50TG93ZXJQYXJ0ID0gcm93Q291bnRMb3dlclBhcnQ7XHJcbiAgICAgICAgdGhpcy5yb3dDb3VudCA9IHJvd0NvdW50VXBwZXJQYXJ0ICsgcm93Q291bnRMb3dlclBhcnQ7XHJcbiAgICB9XHJcbiAgICBCYXJjb2RlTWV0YWRhdGEucHJvdG90eXBlLmdldENvbHVtbkNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkNvdW50O1xyXG4gICAgfTtcclxuICAgIEJhcmNvZGVNZXRhZGF0YS5wcm90b3R5cGUuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWw7XHJcbiAgICB9O1xyXG4gICAgQmFyY29kZU1ldGFkYXRhLnByb3RvdHlwZS5nZXRSb3dDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yb3dDb3VudDtcclxuICAgIH07XHJcbiAgICBCYXJjb2RlTWV0YWRhdGEucHJvdG90eXBlLmdldFJvd0NvdW50VXBwZXJQYXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvd0NvdW50VXBwZXJQYXJ0O1xyXG4gICAgfTtcclxuICAgIEJhcmNvZGVNZXRhZGF0YS5wcm90b3R5cGUuZ2V0Um93Q291bnRMb3dlclBhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm93Q291bnRMb3dlclBhcnQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJhcmNvZGVNZXRhZGF0YTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQmFyY29kZU1ldGFkYXRhO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXJjb2RlTWV0YWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2RlcjtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LlBERjQxN0NvbW1vbjtcclxudmFyIFBERjQxN0NvbW1vbl8xID0gcmVxdWlyZShcIi4uL1BERjQxN0NvbW1vblwiKTtcclxuLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XHJcbi8vIGltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbjtcclxuLy8gaW1wb3J0IGphdmEudXRpbC5IYXNoTWFwO1xyXG4vLyBpbXBvcnQgamF2YS51dGlsLk1hcDtcclxuLy8gaW1wb3J0IGphdmEudXRpbC5NYXAuRW50cnk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcclxuICovXHJcbnZhciBCYXJjb2RlVmFsdWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCYXJjb2RlVmFsdWUoKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBvY2N1cnJlbmNlIG9mIGEgdmFsdWVcclxuICAgICAqL1xyXG4gICAgQmFyY29kZVZhbHVlLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhbHVlID0gTWF0aC50cnVuYyh2YWx1ZSk7XHJcbiAgICAgICAgdmFyIGNvbmZpZGVuY2UgPSB0aGlzLnZhbHVlcy5nZXQodmFsdWUpO1xyXG4gICAgICAgIGlmIChjb25maWRlbmNlID09IG51bGwpIHtcclxuICAgICAgICAgICAgY29uZmlkZW5jZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbmZpZGVuY2UrKztcclxuICAgICAgICB0aGlzLnZhbHVlcy5zZXQodmFsdWUsIGNvbmZpZGVuY2UpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgbWF4aW11bSBvY2N1cnJlbmNlIG9mIGEgc2V0IHZhbHVlIGFuZCByZXR1cm5zIGFsbCB2YWx1ZXMgd2hpY2ggd2VyZSBzZXQgd2l0aCB0aGlzIG9jY3VycmVuY2UuXHJcbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IG9mIGludCwgY29udGFpbmluZyB0aGUgdmFsdWVzIHdpdGggdGhlIGhpZ2hlc3Qgb2NjdXJyZW5jZSwgb3IgbnVsbCwgaWYgbm8gdmFsdWUgd2FzIHNldFxyXG4gICAgICovXHJcbiAgICBCYXJjb2RlVmFsdWUucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIHZhciBtYXhDb25maWRlbmNlID0gLTE7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG4gICAgICAgICAgICAgICAgZ2V0S2V5OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXk7IH0sXHJcbiAgICAgICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWU7IH0sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChlbnRyeS5nZXRWYWx1ZSgpID4gbWF4Q29uZmlkZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4Q29uZmlkZW5jZSA9IGVudHJ5LmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGVudHJ5LmdldEtleSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChlbnRyeS5nZXRWYWx1ZSgpID09PSBtYXhDb25maWRlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeS5nZXRLZXkoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy52YWx1ZXMuZW50cmllcygpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9kID0gX19yZWFkKF9jLnZhbHVlLCAyKSwga2V5ID0gX2RbMF0sIHZhbHVlID0gX2RbMV07XHJcbiAgICAgICAgICAgICAgICBfbG9vcF8xKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUERGNDE3Q29tbW9uXzEuZGVmYXVsdC50b0ludEFycmF5KHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgQmFyY29kZVZhbHVlLnByb3RvdHlwZS5nZXRDb25maWRlbmNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmdldCh2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJhcmNvZGVWYWx1ZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQmFyY29kZVZhbHVlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXJjb2RlVmFsdWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xyXG4qXHJcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5kZWNvZGVyO1xyXG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5Ob3RGb3VuZEV4Y2VwdGlvbjtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLlJlc3VsdFBvaW50O1xyXG52YXIgUmVzdWx0UG9pbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9SZXN1bHRQb2ludFwiKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxyXG4gKi9cclxudmFyIEJvdW5kaW5nQm94ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQm91bmRpbmdCb3goaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCkge1xyXG4gICAgICAgIGlmIChpbWFnZSBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3JfMihpbWFnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yXzEoaW1hZ2UsIHRvcExlZnQsIGJvdHRvbUxlZnQsIHRvcFJpZ2h0LCBib3R0b21SaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGltYWdlXHJcbiAgICAgKiBAcGFyYW0gdG9wTGVmdFxyXG4gICAgICogQHBhcmFtIGJvdHRvbUxlZnRcclxuICAgICAqIEBwYXJhbSB0b3BSaWdodFxyXG4gICAgICogQHBhcmFtIGJvdHRvbVJpZ2h0XHJcbiAgICAgKlxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxyXG4gICAgICovXHJcbiAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuY29uc3RydWN0b3JfMSA9IGZ1bmN0aW9uIChpbWFnZSwgdG9wTGVmdCwgYm90dG9tTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0KSB7XHJcbiAgICAgICAgdmFyIGxlZnRVbnNwZWNpZmllZCA9IHRvcExlZnQgPT0gbnVsbCB8fCBib3R0b21MZWZ0ID09IG51bGw7XHJcbiAgICAgICAgdmFyIHJpZ2h0VW5zcGVjaWZpZWQgPSB0b3BSaWdodCA9PSBudWxsIHx8IGJvdHRvbVJpZ2h0ID09IG51bGw7XHJcbiAgICAgICAgaWYgKGxlZnRVbnNwZWNpZmllZCAmJiByaWdodFVuc3BlY2lmaWVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlZnRVbnNwZWNpZmllZCkge1xyXG4gICAgICAgICAgICB0b3BMZWZ0ID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdCgwLCB0b3BSaWdodC5nZXRZKCkpO1xyXG4gICAgICAgICAgICBib3R0b21MZWZ0ID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdCgwLCBib3R0b21SaWdodC5nZXRZKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaWdodFVuc3BlY2lmaWVkKSB7XHJcbiAgICAgICAgICAgIHRvcFJpZ2h0ID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChpbWFnZS5nZXRXaWR0aCgpIC0gMSwgdG9wTGVmdC5nZXRZKCkpO1xyXG4gICAgICAgICAgICBib3R0b21SaWdodCA9IG5ldyBSZXN1bHRQb2ludF8xLmRlZmF1bHQoaW1hZ2UuZ2V0V2lkdGgoKSAtIDEsIGJvdHRvbUxlZnQuZ2V0WSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xyXG4gICAgICAgIHRoaXMudG9wTGVmdCA9IHRvcExlZnQ7XHJcbiAgICAgICAgdGhpcy5ib3R0b21MZWZ0ID0gYm90dG9tTGVmdDtcclxuICAgICAgICB0aGlzLnRvcFJpZ2h0ID0gdG9wUmlnaHQ7XHJcbiAgICAgICAgdGhpcy5ib3R0b21SaWdodCA9IGJvdHRvbVJpZ2h0O1xyXG4gICAgICAgIHRoaXMubWluWCA9IE1hdGgudHJ1bmMoTWF0aC5taW4odG9wTGVmdC5nZXRYKCksIGJvdHRvbUxlZnQuZ2V0WCgpKSk7XHJcbiAgICAgICAgdGhpcy5tYXhYID0gTWF0aC50cnVuYyhNYXRoLm1heCh0b3BSaWdodC5nZXRYKCksIGJvdHRvbVJpZ2h0LmdldFgoKSkpO1xyXG4gICAgICAgIHRoaXMubWluWSA9IE1hdGgudHJ1bmMoTWF0aC5taW4odG9wTGVmdC5nZXRZKCksIHRvcFJpZ2h0LmdldFkoKSkpO1xyXG4gICAgICAgIHRoaXMubWF4WSA9IE1hdGgudHJ1bmMoTWF0aC5tYXgoYm90dG9tTGVmdC5nZXRZKCksIGJvdHRvbVJpZ2h0LmdldFkoKSkpO1xyXG4gICAgfTtcclxuICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcl8yID0gZnVuY3Rpb24gKGJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IGJvdW5kaW5nQm94LmltYWdlO1xyXG4gICAgICAgIHRoaXMudG9wTGVmdCA9IGJvdW5kaW5nQm94LmdldFRvcExlZnQoKTtcclxuICAgICAgICB0aGlzLmJvdHRvbUxlZnQgPSBib3VuZGluZ0JveC5nZXRCb3R0b21MZWZ0KCk7XHJcbiAgICAgICAgdGhpcy50b3BSaWdodCA9IGJvdW5kaW5nQm94LmdldFRvcFJpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5ib3R0b21SaWdodCA9IGJvdW5kaW5nQm94LmdldEJvdHRvbVJpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5taW5YID0gYm91bmRpbmdCb3guZ2V0TWluWCgpO1xyXG4gICAgICAgIHRoaXMubWF4WCA9IGJvdW5kaW5nQm94LmdldE1heFgoKTtcclxuICAgICAgICB0aGlzLm1pblkgPSBib3VuZGluZ0JveC5nZXRNaW5ZKCk7XHJcbiAgICAgICAgdGhpcy5tYXhZID0gYm91bmRpbmdCb3guZ2V0TWF4WSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxyXG4gICAgICovXHJcbiAgICBCb3VuZGluZ0JveC5tZXJnZSA9IGZ1bmN0aW9uIChsZWZ0Qm94LCByaWdodEJveCkge1xyXG4gICAgICAgIGlmIChsZWZ0Qm94ID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0Qm94O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmlnaHRCb3ggPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdEJveDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChsZWZ0Qm94LmltYWdlLCBsZWZ0Qm94LnRvcExlZnQsIGxlZnRCb3guYm90dG9tTGVmdCwgcmlnaHRCb3gudG9wUmlnaHQsIHJpZ2h0Qm94LmJvdHRvbVJpZ2h0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZE1pc3NpbmdSb3dzID0gZnVuY3Rpb24gKG1pc3NpbmdTdGFydFJvd3MsIG1pc3NpbmdFbmRSb3dzLCBpc0xlZnQpIHtcclxuICAgICAgICB2YXIgbmV3VG9wTGVmdCA9IHRoaXMudG9wTGVmdDtcclxuICAgICAgICB2YXIgbmV3Qm90dG9tTGVmdCA9IHRoaXMuYm90dG9tTGVmdDtcclxuICAgICAgICB2YXIgbmV3VG9wUmlnaHQgPSB0aGlzLnRvcFJpZ2h0O1xyXG4gICAgICAgIHZhciBuZXdCb3R0b21SaWdodCA9IHRoaXMuYm90dG9tUmlnaHQ7XHJcbiAgICAgICAgaWYgKG1pc3NpbmdTdGFydFJvd3MgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciB0b3BfMSA9IGlzTGVmdCA/IHRoaXMudG9wTGVmdCA6IHRoaXMudG9wUmlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBuZXdNaW5ZID0gTWF0aC50cnVuYyh0b3BfMS5nZXRZKCkgLSBtaXNzaW5nU3RhcnRSb3dzKTtcclxuICAgICAgICAgICAgaWYgKG5ld01pblkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdNaW5ZID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV3VG9wID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdCh0b3BfMS5nZXRYKCksIG5ld01pblkpO1xyXG4gICAgICAgICAgICBpZiAoaXNMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICBuZXdUb3BMZWZ0ID0gbmV3VG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3VG9wUmlnaHQgPSBuZXdUb3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pc3NpbmdFbmRSb3dzID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgYm90dG9tID0gaXNMZWZ0ID8gdGhpcy5ib3R0b21MZWZ0IDogdGhpcy5ib3R0b21SaWdodDtcclxuICAgICAgICAgICAgdmFyIG5ld01heFkgPSBNYXRoLnRydW5jKGJvdHRvbS5nZXRZKCkgKyBtaXNzaW5nRW5kUm93cyk7XHJcbiAgICAgICAgICAgIGlmIChuZXdNYXhZID49IHRoaXMuaW1hZ2UuZ2V0SGVpZ2h0KCkpIHtcclxuICAgICAgICAgICAgICAgIG5ld01heFkgPSB0aGlzLmltYWdlLmdldEhlaWdodCgpIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV3Qm90dG9tID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChib3R0b20uZ2V0WCgpLCBuZXdNYXhZKTtcclxuICAgICAgICAgICAgaWYgKGlzTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgbmV3Qm90dG9tTGVmdCA9IG5ld0JvdHRvbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld0JvdHRvbVJpZ2h0ID0gbmV3Qm90dG9tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcy5pbWFnZSwgbmV3VG9wTGVmdCwgbmV3Qm90dG9tTGVmdCwgbmV3VG9wUmlnaHQsIG5ld0JvdHRvbVJpZ2h0KTtcclxuICAgIH07XHJcbiAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0TWluWCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW5YO1xyXG4gICAgfTtcclxuICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRNYXhYID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1heFg7XHJcbiAgICB9O1xyXG4gICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldE1pblkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluWTtcclxuICAgIH07XHJcbiAgICBCb3VuZGluZ0JveC5wcm90b3R5cGUuZ2V0TWF4WSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXhZO1xyXG4gICAgfTtcclxuICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRUb3BMZWZ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvcExlZnQ7XHJcbiAgICB9O1xyXG4gICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldFRvcFJpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvcFJpZ2h0O1xyXG4gICAgfTtcclxuICAgIEJvdW5kaW5nQm94LnByb3RvdHlwZS5nZXRCb3R0b21MZWZ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbUxlZnQ7XHJcbiAgICB9O1xyXG4gICAgQm91bmRpbmdCb3gucHJvdG90eXBlLmdldEJvdHRvbVJpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbVJpZ2h0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCb3VuZGluZ0JveDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQm91bmRpbmdCb3g7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJvdW5kaW5nQm94LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxMyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5kZWNvZGVyO1xyXG4vKipcclxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XHJcbiAqL1xyXG52YXIgQ29kZXdvcmQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDb2Rld29yZChzdGFydFgsIGVuZFgsIGJ1Y2tldCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLnJvd051bWJlciA9IENvZGV3b3JkLkJBUkNPREVfUk9XX1VOS05PV047XHJcbiAgICAgICAgdGhpcy5zdGFydFggPSBNYXRoLnRydW5jKHN0YXJ0WCk7XHJcbiAgICAgICAgdGhpcy5lbmRYID0gTWF0aC50cnVuYyhlbmRYKTtcclxuICAgICAgICB0aGlzLmJ1Y2tldCA9IE1hdGgudHJ1bmMoYnVja2V0KTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gTWF0aC50cnVuYyh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBDb2Rld29yZC5wcm90b3R5cGUuaGFzVmFsaWRSb3dOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZFJvd051bWJlcih0aGlzLnJvd051bWJlcik7XHJcbiAgICB9O1xyXG4gICAgQ29kZXdvcmQucHJvdG90eXBlLmlzVmFsaWRSb3dOdW1iZXIgPSBmdW5jdGlvbiAocm93TnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHJvd051bWJlciAhPT0gQ29kZXdvcmQuQkFSQ09ERV9ST1dfVU5LTk9XTiAmJiB0aGlzLmJ1Y2tldCA9PT0gKHJvd051bWJlciAlIDMpICogMztcclxuICAgIH07XHJcbiAgICBDb2Rld29yZC5wcm90b3R5cGUuc2V0Um93TnVtYmVyQXNSb3dJbmRpY2F0b3JDb2x1bW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yb3dOdW1iZXIgPSBNYXRoLnRydW5jKChNYXRoLnRydW5jKHRoaXMudmFsdWUgLyAzMCkpICogMyArIE1hdGgudHJ1bmModGhpcy5idWNrZXQgLyAzKSk7XHJcbiAgICB9O1xyXG4gICAgQ29kZXdvcmQucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZFggLSB0aGlzLnN0YXJ0WDtcclxuICAgIH07XHJcbiAgICBDb2Rld29yZC5wcm90b3R5cGUuZ2V0U3RhcnRYID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0WDtcclxuICAgIH07XHJcbiAgICBDb2Rld29yZC5wcm90b3R5cGUuZ2V0RW5kWCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmRYO1xyXG4gICAgfTtcclxuICAgIENvZGV3b3JkLnByb3RvdHlwZS5nZXRCdWNrZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVja2V0O1xyXG4gICAgfTtcclxuICAgIENvZGV3b3JkLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBDb2Rld29yZC5wcm90b3R5cGUuZ2V0Um93TnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvd051bWJlcjtcclxuICAgIH07XHJcbiAgICBDb2Rld29yZC5wcm90b3R5cGUuc2V0Um93TnVtYmVyID0gZnVuY3Rpb24gKHJvd051bWJlcikge1xyXG4gICAgICAgIHRoaXMucm93TnVtYmVyID0gcm93TnVtYmVyO1xyXG4gICAgfTtcclxuICAgIC8vICAgQE92ZXJyaWRlXHJcbiAgICBDb2Rld29yZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm93TnVtYmVyICsgJ3wnICsgdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBDb2Rld29yZC5CQVJDT0RFX1JPV19VTktOT1dOID0gLTE7XHJcbiAgICByZXR1cm4gQ29kZXdvcmQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IENvZGV3b3JkO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db2Rld29yZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDkgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2RlcjtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuRm9ybWF0RXhjZXB0aW9uO1xyXG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xyXG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24uQ2hhcmFjdGVyU2V0RUNJO1xyXG52YXIgQ2hhcmFjdGVyU2V0RUNJXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0NoYXJhY3RlclNldEVDSVwiKTtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuY29tbW9uLkRlY29kZXJSZXN1bHQ7XHJcbnZhciBEZWNvZGVyUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0RlY29kZXJSZXN1bHRcIik7XHJcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5QREY0MTdSZXN1bHRNZXRhZGF0YTtcclxudmFyIFBERjQxN1Jlc3VsdE1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi4vUERGNDE3UmVzdWx0TWV0YWRhdGFcIik7XHJcbi8vIGltcG9ydCBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbTtcclxuLy8gaW1wb3J0IGphdmEubWF0aC5CaWdJbnRlZ2VyO1xyXG4vLyBpbXBvcnQgamF2YS5uaW8uY2hhcnNldC5DaGFyc2V0O1xyXG4vLyBpbXBvcnQgamF2YS5uaW8uY2hhcnNldC5TdGFuZGFyZENoYXJzZXRzO1xyXG4vLyBpbXBvcnQgamF2YS51dGlsLkFycmF5cztcclxudmFyIEFycmF5c18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvQXJyYXlzXCIpO1xyXG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcclxudmFyIEludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0ludGVnZXJcIik7XHJcbnZhciBMb25nXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9Mb25nXCIpO1xyXG52YXIgQnl0ZUFycmF5T3V0cHV0U3RyZWFtXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9CeXRlQXJyYXlPdXRwdXRTdHJlYW1cIik7XHJcbnZhciBTdHJpbmdFbmNvZGluZ18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvU3RyaW5nRW5jb2RpbmdcIik7XHJcbi8qcHJpdmF0ZSovIHZhciBNb2RlO1xyXG4oZnVuY3Rpb24gKE1vZGUpIHtcclxuICAgIE1vZGVbTW9kZVtcIkFMUEhBXCJdID0gMF0gPSBcIkFMUEhBXCI7XHJcbiAgICBNb2RlW01vZGVbXCJMT1dFUlwiXSA9IDFdID0gXCJMT1dFUlwiO1xyXG4gICAgTW9kZVtNb2RlW1wiTUlYRURcIl0gPSAyXSA9IFwiTUlYRURcIjtcclxuICAgIE1vZGVbTW9kZVtcIlBVTkNUXCJdID0gM10gPSBcIlBVTkNUXCI7XHJcbiAgICBNb2RlW01vZGVbXCJBTFBIQV9TSElGVFwiXSA9IDRdID0gXCJBTFBIQV9TSElGVFwiO1xyXG4gICAgTW9kZVtNb2RlW1wiUFVOQ1RfU0hJRlRcIl0gPSA1XSA9IFwiUFVOQ1RfU0hJRlRcIjtcclxufSkoTW9kZSB8fCAoTW9kZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBJbmRpcmVjdGx5IGFjY2VzcyB0aGUgZ2xvYmFsIEJpZ0ludCBjb25zdHJ1Y3RvciwgaXRcclxuICogYWxsb3dzIGJyb3dzZXJzIHRoYXQgZG9lc24ndCBzdXBwb3J0IEJpZ0ludCB0byBydW5cclxuICogdGhlIGxpYnJhcnkgd2l0aG91dCBicmVha2luZyBkdWUgdG8gXCJ1bmRlZmluZWQgQmlnSW50XCJcclxuICogZXJyb3JzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QmlnSW50Q29uc3RydWN0b3IoKSB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gd2luZG93WydCaWdJbnQnXSB8fCBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbFsnQmlnSW50J10gfHwgbnVsbDtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBzZWFyY2ggZ2xvYmFscyBmb3IgQmlnSW50IScpO1xyXG59XHJcbi8qKlxyXG4gKiBVc2VkIHRvIHN0b3JlIHRoZSBCaWdJbnQgY29uc3RydWN0b3IuXHJcbiAqL1xyXG52YXIgQmlnSW50ZWdlcjtcclxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIGJpZ2ludCB2YWx1ZS4gSXQgYWxsb3dzIGJyb3dzZXJzXHJcbiAqIHRoYXQgZG9lc24ndCBzdXBwb3J0IEJpZ0ludCB0byBydW4gdGhlIHJlc3Qgb2YgdGhlIGxpYnJhcnlcclxuICogYnkgbm90IGRpcmVjdGx5IGFjY2Vzc2luZyB0aGUgQmlnSW50IGNvbnN0cnVjdG9yLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQmlnSW50KG51bSkge1xyXG4gICAgaWYgKHR5cGVvZiBCaWdJbnRlZ2VyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIEJpZ0ludGVnZXIgPSBnZXRCaWdJbnRDb25zdHJ1Y3RvcigpO1xyXG4gICAgfVxyXG4gICAgaWYgKEJpZ0ludGVnZXIgPT09IG51bGwpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBpcyBub3Qgc3VwcG9ydGVkIScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJpZ0ludGVnZXIobnVtKTtcclxufVxyXG5mdW5jdGlvbiBnZXRFWFA5MDAoKSB7XHJcbiAgICAvLyBpbiBKYXZhIC0gYXJyYXkgd2l0aCBsZW5ndGggPSAxNlxyXG4gICAgdmFyIEVYUDkwMCA9IFtdO1xyXG4gICAgRVhQOTAwWzBdID0gY3JlYXRlQmlnSW50KDEpO1xyXG4gICAgdmFyIG5pbmVIdW5kcmVkID0gY3JlYXRlQmlnSW50KDkwMCk7XHJcbiAgICBFWFA5MDBbMV0gPSBuaW5lSHVuZHJlZDtcclxuICAgIC8vIGluIEphdmEgLSBhcnJheSB3aXRoIGxlbmd0aCA9IDE2XHJcbiAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAyOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICAgIEVYUDkwMFtpXSA9IEVYUDkwMFtpIC0gMV0gKiBuaW5lSHVuZHJlZDtcclxuICAgIH1cclxuICAgIHJldHVybiBFWFA5MDA7XHJcbn1cclxuLyoqXHJcbiAqIDxwPlRoaXMgY2xhc3MgY29udGFpbnMgdGhlIG1ldGhvZHMgZm9yIGRlY29kaW5nIHRoZSBQREY0MTcgY29kZXdvcmRzLjwvcD5cclxuICpcclxuICogQGF1dGhvciBTSVRBIExhYiAoa2V2aW4ub3N1bGxpdmFuQHNpdGEuYWVybylcclxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XHJcbiAqL1xyXG52YXIgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlY29kZWRCaXRTdHJlYW1QYXJzZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvLyAgIHByaXZhdGUgRGVjb2RlZEJpdFN0cmVhbVBhcnNlcigpIHtcclxuICAgIC8vIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2Rld29yZHNcclxuICAgICAqIEBwYXJhbSBlY0xldmVsXHJcbiAgICAgKlxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGUgPSBmdW5jdGlvbiAoY29kZXdvcmRzLCBlY0xldmVsKSB7XHJcbiAgICAgICAgLy8gcGFzcyBlbmNvZGluZyB0byByZXN1bHQgKHdpbGwgYmUgdXNlZCBmb3IgZGVjb2RlIHN5bWJvbHMgaW4gYnl0ZSBtb2RlKVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoJycpO1xyXG4gICAgICAgIC8vIGxldCBlbmNvZGluZzogQ2hhcnNldCA9IFN0YW5kYXJkQ2hhcnNldHMuSVNPXzg4NTlfMTtcclxuICAgICAgICB2YXIgZW5jb2RpbmcgPSBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LklTTzg4NTlfMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbm90ZSB0aGUgbmV4dCBjb21tYW5kIGlzIHNwZWNpZmljIGZyb20gdGhpcyBUeXBlU2NyaXB0IGxpYnJhcnlcclxuICAgICAgICAgKiBiZWNhdXNlIFRTIGNhbid0IHByb3Blcmx5IGNhc3Qgc29tZSB2YWx1ZXMgdG8gY2hhciBhbmRcclxuICAgICAgICAgKiBjb252ZXJ0IGl0IHRvIHN0cmluZyBsYXRlciBjb3JyZWN0bHkgZHVlIHRvIGVuY29kaW5nXHJcbiAgICAgICAgICogZGlmZmVyZW5jZXMgZnJvbSBKYXZhIHZlcnNpb24uIEFzIHJlcG9ydGVkIGhlcmU6XHJcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3p4aW5nLWpzL2xpYnJhcnkvcHVsbC8yNjQvZmlsZXMjcjM4MjgzMTU5M1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlc3VsdC5lbmFibGVEZWNvZGluZyhlbmNvZGluZyk7XHJcbiAgICAgICAgLy8gR2V0IGNvbXBhY3Rpb24gbW9kZVxyXG4gICAgICAgIHZhciBjb2RlSW5kZXggPSAxO1xyXG4gICAgICAgIHZhciBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcclxuICAgICAgICB2YXIgcmVzdWx0TWV0YWRhdGEgPSBuZXcgUERGNDE3UmVzdWx0TWV0YWRhdGFfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgd2hpbGUgKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcclxuICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5ieXRlQ29tcGFjdGlvbihjb2RlLCBjb2Rld29yZHMsIGVuY29kaW5nLCBjb2RlSW5kZXgsIHJlc3VsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gY29kZXdvcmRzW2NvZGVJbmRleCsrXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5udW1lcmljQ29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5FQ0lfQ0hBUlNFVDpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcnNldEVDSSA9IENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuZ2V0Q2hhcmFjdGVyU2V0RUNJQnlWYWx1ZShjb2Rld29yZHNbY29kZUluZGV4KytdKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbmNvZGluZyA9IENoYXJzZXQuZm9yTmFtZShjaGFyc2V0RUNJLmdldE5hbWUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuRUNJX0dFTkVSQUxfUFVSUE9TRTpcclxuICAgICAgICAgICAgICAgICAgICAvLyBDYW4ndCBkbyBhbnl0aGluZyB3aXRoIGdlbmVyaWMgRUNJOyBza2lwIGl0cyAyIGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggKz0gMjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5FQ0lfVVNFUl9ERUZJTkVEOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbid0IGRvIGFueXRoaW5nIHdpdGggdXNlciBFQ0k7IHNraXAgaXRzIDEgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQkVHSU5fTUFDUk9fUERGNDE3X0NPTlRST0xfQkxPQ0s6XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVNYWNyb0Jsb2NrKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHRNZXRhZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBub3Qgc2VlIHRoZXNlIG91dHNpZGUgYSBtYWNybyBibG9ja1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdGV4dCBjb21wYWN0aW9uLiBEdXJpbmcgdGVzdGluZyBudW1lcm91cyBiYXJjb2Rlc1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGVhcmVkIHRvIGJlIG1pc3NpbmcgdGhlIHN0YXJ0aW5nIG1vZGUuIEluIHRoZXNlIGNhc2VzIGRlZmF1bHRpbmdcclxuICAgICAgICAgICAgICAgICAgICAvLyB0byB0ZXh0IGNvbXBhY3Rpb24gc2VlbXMgdG8gd29yay5cclxuICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgtLTtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRleHRDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb2RlSW5kZXggPCBjb2Rld29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQuZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCgpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQuZ2V0Rm9ybWF0SW5zdGFuY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlY29kZXJSZXN1bHQgPSBuZXcgRGVjb2RlclJlc3VsdF8xLmRlZmF1bHQobnVsbCwgcmVzdWx0LnRvU3RyaW5nKCksIG51bGwsIGVjTGV2ZWwpO1xyXG4gICAgICAgIGRlY29kZXJSZXN1bHQuc2V0T3RoZXIocmVzdWx0TWV0YWRhdGEpO1xyXG4gICAgICAgIHJldHVybiBkZWNvZGVyUmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbnRcclxuICAgICAqIEBwYXJhbSBwYXJhbTFcclxuICAgICAqIEBwYXJhbSBjb2Rld29yZHNcclxuICAgICAqIEBwYXJhbSBpbnRcclxuICAgICAqIEBwYXJhbSBjb2RlSW5kZXhcclxuICAgICAqIEBwYXJhbSBQREY0MTdSZXN1bHRNZXRhZGF0YVxyXG4gICAgICogQHBhcmFtIHJlc3VsdE1ldGFkYXRhXHJcbiAgICAgKlxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgLy8gQFN1cHByZXNzV2FybmluZ3MoXCJkZXByZWNhdGlvblwiKVxyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVNYWNyb0Jsb2NrID0gZnVuY3Rpb24gKGNvZGV3b3JkcywgY29kZUluZGV4LCByZXN1bHRNZXRhZGF0YSkge1xyXG4gICAgICAgIGlmIChjb2RlSW5kZXggKyBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk5VTUJFUl9PRl9TRVFVRU5DRV9DT0RFV09SRFMgPiBjb2Rld29yZHNbMF0pIHtcclxuICAgICAgICAgICAgLy8gd2UgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBieXRlcyBsZWZ0IGZvciB0aGUgc2VnbWVudCBpbmRleFxyXG4gICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0LmdldEZvcm1hdEluc3RhbmNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZWdtZW50SW5kZXhBcnJheSA9IG5ldyBJbnQzMkFycmF5KERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUzsgaSsrLCBjb2RlSW5kZXgrKykge1xyXG4gICAgICAgICAgICBzZWdtZW50SW5kZXhBcnJheVtpXSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRTZWdtZW50SW5kZXgoSW50ZWdlcl8xLmRlZmF1bHQucGFyc2VJbnQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVCYXNlOTAwdG9CYXNlMTAoc2VnbWVudEluZGV4QXJyYXksIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUykpKTtcclxuICAgICAgICB2YXIgZmlsZUlkID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgY29kZUluZGV4ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50ZXh0Q29tcGFjdGlvbihjb2Rld29yZHMsIGNvZGVJbmRleCwgZmlsZUlkKTtcclxuICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRGaWxlSWQoZmlsZUlkLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgIHZhciBvcHRpb25hbEZpZWxkc1N0YXJ0ID0gLTE7XHJcbiAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2RlSW5kZXhdID09PSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRCkge1xyXG4gICAgICAgICAgICBvcHRpb25hbEZpZWxkc1N0YXJ0ID0gY29kZUluZGV4ICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGNvZGV3b3Jkc1tjb2RlSW5kZXhdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQkVHSU5fTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZXdvcmRzW2NvZGVJbmRleF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9GSUxFX05BTUU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIudGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBmaWxlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRGaWxlTmFtZShmaWxlTmFtZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1NFTkRFUjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZW5kZXIgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIudGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBzZW5kZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0U2VuZGVyKHNlbmRlci50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0FERFJFU1NFRTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzZWUgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIudGV4dENvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBhZGRyZXNzZWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0QWRkcmVzc2VlKGFkZHJlc3NlZS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1NFR01FTlRfQ09VTlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VnbWVudENvdW50ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXggPSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLm51bWVyaWNDb21wYWN0aW9uKGNvZGV3b3JkcywgY29kZUluZGV4ICsgMSwgc2VnbWVudENvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldFNlZ21lbnRDb3VudChJbnRlZ2VyXzEuZGVmYXVsdC5wYXJzZUludChzZWdtZW50Q291bnQudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfVElNRV9TVEFNUDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIubnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCB0aW1lc3RhbXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0VGltZXN0YW1wKExvbmdfMS5kZWZhdWx0LnBhcnNlTG9uZyh0aW1lc3RhbXAudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfQ0hFQ0tTVU06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tzdW0gPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIubnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBjaGVja3N1bSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRDaGVja3N1bShJbnRlZ2VyXzEuZGVmYXVsdC5wYXJzZUludChjaGVja3N1bS50b1N0cmluZygpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9GSUxFX1NJWkU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZVNpemUgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIubnVtZXJpY0NvbXBhY3Rpb24oY29kZXdvcmRzLCBjb2RlSW5kZXggKyAxLCBmaWxlU2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRNZXRhZGF0YS5zZXRGaWxlU2l6ZShMb25nXzEuZGVmYXVsdC5wYXJzZUxvbmcoZmlsZVNpemUudG9TdHJpbmcoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0LmdldEZvcm1hdEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdE1ldGFkYXRhLnNldExhc3RTZWdtZW50KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0LmdldEZvcm1hdEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29weSBvcHRpb25hbCBmaWVsZHMgdG8gYWRkaXRpb25hbCBvcHRpb25zXHJcbiAgICAgICAgaWYgKG9wdGlvbmFsRmllbGRzU3RhcnQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHZhciBvcHRpb25hbEZpZWxkc0xlbmd0aCA9IGNvZGVJbmRleCAtIG9wdGlvbmFsRmllbGRzU3RhcnQ7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHRNZXRhZGF0YS5pc0xhc3RTZWdtZW50KCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBpbmNsdWRlIHRlcm1pbmF0b3JcclxuICAgICAgICAgICAgICAgIG9wdGlvbmFsRmllbGRzTGVuZ3RoLS07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEuc2V0T3B0aW9uYWxEYXRhKEFycmF5c18xLmRlZmF1bHQuY29weU9mUmFuZ2UoY29kZXdvcmRzLCBvcHRpb25hbEZpZWxkc1N0YXJ0LCBvcHRpb25hbEZpZWxkc1N0YXJ0ICsgb3B0aW9uYWxGaWVsZHNMZW5ndGgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRleHQgQ29tcGFjdGlvbiBtb2RlIChzZWUgNS40LjEuNSkgcGVybWl0cyBhbGwgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnMgdG8gYmVcclxuICAgICAqIGVuY29kZWQsIGkuZS4gdmFsdWVzIDMyIC0gMTI2IGluY2x1c2l2ZSBpbiBhY2NvcmRhbmNlIHdpdGggSVNPL0lFQyA2NDYgKElSViksIGFzXHJcbiAgICAgKiB3ZWxsIGFzIHNlbGVjdGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29kZXdvcmRzIFRoZSBhcnJheSBvZiBjb2Rld29yZHMgKGRhdGEgKyBlcnJvcilcclxuICAgICAqIEBwYXJhbSBjb2RlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggaW50byB0aGUgY29kZXdvcmQgYXJyYXkuXHJcbiAgICAgKiBAcGFyYW0gcmVzdWx0ICAgIFRoZSBkZWNvZGVkIGRhdGEgaXMgYXBwZW5kZWQgdG8gdGhlIHJlc3VsdC5cclxuICAgICAqIEByZXR1cm4gVGhlIG5leHQgaW5kZXggaW50byB0aGUgY29kZXdvcmQgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIudGV4dENvbXBhY3Rpb24gPSBmdW5jdGlvbiAoY29kZXdvcmRzLCBjb2RlSW5kZXgsIHJlc3VsdCkge1xyXG4gICAgICAgIC8vIDIgY2hhcmFjdGVyIHBlciBjb2Rld29yZFxyXG4gICAgICAgIHZhciB0ZXh0Q29tcGFjdGlvbkRhdGEgPSBuZXcgSW50MzJBcnJheSgoY29kZXdvcmRzWzBdIC0gY29kZUluZGV4KSAqIDIpO1xyXG4gICAgICAgIC8vIFVzZWQgdG8gaG9sZCB0aGUgYnl0ZSBjb21wYWN0aW9uIHZhbHVlIGlmIHRoZXJlIGlzIGEgbW9kZSBzaGlmdFxyXG4gICAgICAgIHZhciBieXRlQ29tcGFjdGlvbkRhdGEgPSBuZXcgSW50MzJBcnJheSgoY29kZXdvcmRzWzBdIC0gY29kZUluZGV4KSAqIDIpO1xyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIGVuZCA9IGZhbHNlO1xyXG4gICAgICAgIHdoaWxlICgoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdKSAmJiAhZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcclxuICAgICAgICAgICAgaWYgKGNvZGUgPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0Q29tcGFjdGlvbkRhdGFbaW5kZXhdID0gY29kZSAvIDMwO1xyXG4gICAgICAgICAgICAgICAgdGV4dENvbXBhY3Rpb25EYXRhW2luZGV4ICsgMV0gPSBjb2RlICUgMzA7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWluaXRpYWxpemUgdGV4dCBjb21wYWN0aW9uIG1vZGUgdG8gYWxwaGEgc3ViIG1vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbXBhY3Rpb25EYXRhW2luZGV4KytdID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQkVHSU5fTUFDUk9fUERGNDE3X0NPTlRST0xfQkxPQ0s6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJFR0lOX01BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFDUk9fUERGNDE3X1RFUk1JTkFUT1I6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIE1vZGUgU2hpZnQgY29kZXdvcmQgOTEzIHNoYWxsIGNhdXNlIGEgdGVtcG9yYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN3aXRjaCBmcm9tIFRleHQgQ29tcGFjdGlvbiBtb2RlIHRvIEJ5dGUgQ29tcGFjdGlvbiBtb2RlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHN3aXRjaCBzaGFsbCBiZSBpbiBlZmZlY3QgZm9yIG9ubHkgdGhlIG5leHQgY29kZXdvcmQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFmdGVyIHdoaWNoIHRoZSBtb2RlIHNoYWxsIHJldmVydCB0byB0aGUgcHJldmFpbGluZyBzdWItbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgVGV4dCBDb21wYWN0aW9uIG1vZGUuIENvZGV3b3JkIDkxMyBpcyBvbmx5IGF2YWlsYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBUZXh0IENvbXBhY3Rpb24gbW9kZTsgaXRzIHVzZSBpcyBkZXNjcmliZWQgaW4gNS40LjIuNC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dENvbXBhY3Rpb25EYXRhW2luZGV4XSA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVDb21wYWN0aW9uRGF0YVtpbmRleF0gPSBjb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZVRleHRDb21wYWN0aW9uKHRleHRDb21wYWN0aW9uRGF0YSwgYnl0ZUNvbXBhY3Rpb25EYXRhLCBpbmRleCwgcmVzdWx0KTtcclxuICAgICAgICByZXR1cm4gY29kZUluZGV4O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIFRleHQgQ29tcGFjdGlvbiBtb2RlIGluY2x1ZGVzIGFsbCB0aGUgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnNcclxuICAgICAqIChpLmUuIHZhbHVlcyBmcm9tIDMyIHRvIDEyNikgYW5kIHRocmVlIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVyczogSFQgb3IgdGFiXHJcbiAgICAgKiAoOTogZSksIExGIG9yIGxpbmUgZmVlZCAoMTA6IGUpLCBhbmQgQ1Igb3IgY2FycmlhZ2VcclxuICAgICAqIHJldHVybiAoMTM6IGUpLiBUaGUgVGV4dCBDb21wYWN0aW9uIG1vZGUgYWxzbyBpbmNsdWRlcyB2YXJpb3VzIGxhdGNoXHJcbiAgICAgKiBhbmQgc2hpZnQgY2hhcmFjdGVycyB3aGljaCBhcmUgdXNlZCBleGNsdXNpdmVseSB3aXRoaW4gdGhlIG1vZGUuIFRoZSBUZXh0XHJcbiAgICAgKiBDb21wYWN0aW9uIG1vZGUgZW5jb2RlcyB1cCB0byAyIGNoYXJhY3RlcnMgcGVyIGNvZGV3b3JkLiBUaGUgY29tcGFjdGlvbiBydWxlc1xyXG4gICAgICogZm9yIGNvbnZlcnRpbmcgZGF0YSBpbnRvIFBERjQxNyBjb2Rld29yZHMgYXJlIGRlZmluZWQgaW4gNS40LjIuMi4gVGhlIHN1Yi1tb2RlXHJcbiAgICAgKiBzd2l0Y2hlcyBhcmUgZGVmaW5lZCBpbiA1LjQuMi4zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0ZXh0Q29tcGFjdGlvbkRhdGEgVGhlIHRleHQgY29tcGFjdGlvbiBkYXRhLlxyXG4gICAgICogQHBhcmFtIGJ5dGVDb21wYWN0aW9uRGF0YSBUaGUgYnl0ZSBjb21wYWN0aW9uIGRhdGEgaWYgdGhlcmVcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzIGEgbW9kZSBzaGlmdC5cclxuICAgICAqIEBwYXJhbSBsZW5ndGggICAgICAgICAgICAgVGhlIHNpemUgb2YgdGhlIHRleHQgY29tcGFjdGlvbiBhbmQgYnl0ZSBjb21wYWN0aW9uIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0gcmVzdWx0ICAgICAgICAgICAgIFRoZSBkZWNvZGVkIGRhdGEgaXMgYXBwZW5kZWQgdG8gdGhlIHJlc3VsdC5cclxuICAgICAqL1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVUZXh0Q29tcGFjdGlvbiA9IGZ1bmN0aW9uICh0ZXh0Q29tcGFjdGlvbkRhdGEsIGJ5dGVDb21wYWN0aW9uRGF0YSwgbGVuZ3RoLCByZXN1bHQpIHtcclxuICAgICAgICAvLyBCZWdpbm5pbmcgZnJvbSBhbiBpbml0aWFsIHN0YXRlIG9mIHRoZSBBbHBoYSBzdWItbW9kZVxyXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IGNvbXBhY3Rpb24gbW9kZSBmb3IgUERGNDE3IGluIGVmZmVjdCBhdCB0aGUgc3RhcnQgb2YgZWFjaCBzeW1ib2wgc2hhbGwgYWx3YXlzIGJlIFRleHRcclxuICAgICAgICAvLyBDb21wYWN0aW9uIG1vZGUgQWxwaGEgc3ViLW1vZGUgKGFscGhhYmV0aWM6IHVwcGVyY2FzZSkuIEEgbGF0Y2ggY29kZXdvcmQgZnJvbSBhbm90aGVyIG1vZGUgdG8gdGhlIFRleHRcclxuICAgICAgICAvLyBDb21wYWN0aW9uIG1vZGUgc2hhbGwgYWx3YXlzIHN3aXRjaCB0byB0aGUgVGV4dCBDb21wYWN0aW9uIEFscGhhIHN1Yi1tb2RlLlxyXG4gICAgICAgIHZhciBzdWJNb2RlID0gTW9kZS5BTFBIQTtcclxuICAgICAgICB2YXIgcHJpb3JUb1NoaWZ0TW9kZSA9IE1vZGUuQUxQSEE7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBzdWJNb2RlQ2ggPSB0ZXh0Q29tcGFjdGlvbkRhdGFbaV07XHJcbiAgICAgICAgICAgIHZhciBjaCA9IC8qY2hhciovICcnO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHN1Yk1vZGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5BTFBIQTpcclxuICAgICAgICAgICAgICAgICAgICAvLyBBbHBoYSAoYWxwaGFiZXRpYzogdXBwZXJjYXNlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCAyNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcHBlciBjYXNlIEFscGhhIENoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiA2NSA9ICdBJyBBU0NJSSAtPiB0aGVyZSBpcyBieXRlIGNvZGUgb2Ygc3ltYm9sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gLyooY2hhcikoJ0EnICsgc3ViTW9kZUNoKSAqLyBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1ICsgc3ViTW9kZUNoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkxMOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlLkxPV0VSO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1MOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlLk1JWEVEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlBTOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRvIHB1bmN0dWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JUb1NoaWZ0TW9kZSA9IHN1Yk1vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuUFVOQ1RfU0hJRlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gYnl0ZUNvbXBhY3Rpb25EYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZS5BTFBIQTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5MT1dFUjpcclxuICAgICAgICAgICAgICAgICAgICAvLyBMb3dlciAoYWxwaGFiZXRpYzogbG93ZXJjYXNlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCAyNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IC8qKGNoYXIpKCdhJyArIHN1Yk1vZGVDaCkqLyBTdHJpbmcuZnJvbUNoYXJDb2RlKDk3ICsgc3ViTW9kZUNoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gJyAnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkFTOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHRvIGFscGhhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JUb1NoaWZ0TW9kZSA9IHN1Yk1vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuQUxQSEFfU0hJRlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuTUlYRUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuUFM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hpZnQgdG8gcHVuY3R1YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvclRvU2hpZnRNb2RlID0gc3ViTW9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZS5QVU5DVF9TSElGVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gRG9lcyB0aGlzIG5lZWQgdG8gdXNlIHRoZSBjdXJyZW50IGNoYXJhY3RlciBlbmNvZGluZz8gU2VlIG90aGVyIG9jY3VycmVuY2VzIGJlbG93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuQUxQSEE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGUuTUlYRUQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTWl4ZWQgKHB1bmN0dWF0aW9uOiBlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlBMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NSVhFRF9DSEFSU1tzdWJNb2RlQ2hdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QTDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZS5QVU5DVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnICc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTEw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuTE9XRVI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQUw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuQUxQSEE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuUFM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hpZnQgdG8gcHVuY3R1YXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmlvclRvU2hpZnRNb2RlID0gc3ViTW9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZS5QVU5DVF9TSElGVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoLyooY2hhcikqLyBieXRlQ29tcGFjdGlvbkRhdGFbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlLkFMUEhBO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNb2RlLlBVTkNUOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFB1bmN0dWF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuUEFMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QVU5DVF9DSEFSU1tzdWJNb2RlQ2hdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QQUw6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuQUxQSEE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTU9ERV9TSElGVF9UT19CWVRFX0NPTVBBQ1RJT05fTU9ERTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKC8qKGNoYXIpKi8gYnl0ZUNvbXBhY3Rpb25EYXRhW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJNb2RlID0gTW9kZS5BTFBIQTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTW9kZS5BTFBIQV9TSElGVDpcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHN1Yi1tb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IHByaW9yVG9TaGlmdE1vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk1vZGVDaCA8IDI2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gLyooY2hhcikoJ0EnICsgc3ViTW9kZUNoKSovIFN0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBzdWJNb2RlQ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdWJNb2RlQ2gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnICc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuQUxQSEE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1vZGUuUFVOQ1RfU0hJRlQ6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBzdWItbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBwcmlvclRvU2hpZnRNb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJNb2RlQ2ggPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlBBTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuUFVOQ1RfQ0hBUlNbc3ViTW9kZUNoXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3ViTW9kZUNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuUEFMOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Yk1vZGUgPSBNb2RlLkFMUEhBO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1PREVfU0hJRlRfVE9fQllURV9DT01QQUNUSU9OX01PREU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUFMgYmVmb3JlIFNoaWZ0LXRvLUJ5dGUgaXMgdXNlZCBhcyBhIHBhZGRpbmcgY2hhcmFjdGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlZSA1LjQuMi40IG9mIHRoZSBzcGVjaWZpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgvKihjaGFyKSovIGJ5dGVDb21wYWN0aW9uRGF0YVtpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViTW9kZSA9IE1vZGUuQUxQSEE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgKGNoICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjaCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBkZWNvZGVkIGNoYXJhY3RlciB0byByZXN1bHRcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoY2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBCeXRlIENvbXBhY3Rpb24gbW9kZSAoc2VlIDUuNC4zKSBwZXJtaXRzIGFsbCAyNTYgcG9zc2libGUgOC1iaXQgYnl0ZSB2YWx1ZXMgdG8gYmUgZW5jb2RlZC5cclxuICAgICAqIFRoaXMgaW5jbHVkZXMgYWxsIEFTQ0lJIGNoYXJhY3RlcnMgdmFsdWUgMCB0byAxMjcgaW5jbHVzaXZlIGFuZCBwcm92aWRlcyBmb3IgaW50ZXJuYXRpb25hbFxyXG4gICAgICogY2hhcmFjdGVyIHNldCBzdXBwb3J0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtb2RlICAgICAgVGhlIGJ5dGUgY29tcGFjdGlvbiBtb2RlIGkuZS4gOTAxIG9yIDkyNFxyXG4gICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzIChkYXRhICsgZXJyb3IpXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgIEN1cnJlbnRseSBhY3RpdmUgY2hhcmFjdGVyIGVuY29kaW5nXHJcbiAgICAgKiBAcGFyYW0gY29kZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHJlc3VsdCAgICBUaGUgZGVjb2RlZCBkYXRhIGlzIGFwcGVuZGVkIHRvIHRoZSByZXN1bHQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBuZXh0IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmJ5dGVDb21wYWN0aW9uID0gZnVuY3Rpb24gKG1vZGUsIGNvZGV3b3JkcywgZW5jb2RpbmcsIGNvZGVJbmRleCwgcmVzdWx0KSB7XHJcbiAgICAgICAgdmFyIGRlY29kZWRCeXRlcyA9IG5ldyBCeXRlQXJyYXlPdXRwdXRTdHJlYW1fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICB2YXIgdmFsdWUgPSAvKmxvbmcqLyAwO1xyXG4gICAgICAgIHZhciBlbmQgPSBmYWxzZTtcclxuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxyXG4gICAgICAgICAgICAgICAgLy8gVG90YWwgbnVtYmVyIG9mIEJ5dGUgQ29tcGFjdGlvbiBjaGFyYWN0ZXJzIHRvIGJlIGVuY29kZWRcclxuICAgICAgICAgICAgICAgIC8vIGlzIG5vdCBhIG11bHRpcGxlIG9mIDZcclxuICAgICAgICAgICAgICAgIHZhciBieXRlQ29tcGFjdGVkQ29kZXdvcmRzID0gbmV3IEludDMyQXJyYXkoNik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKChjb2RlSW5kZXggPCBjb2Rld29yZHNbMF0pICYmICFlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBieXRlQ29tcGFjdGVkQ29kZXdvcmRzW2NvdW50KytdID0gbmV4dENvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFzZSA5MDBcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDkwMCAqIHZhbHVlICsgbmV4dENvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dENvZGUgPSBjb2Rld29yZHNbY29kZUluZGV4KytdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBlcmhhcHMgaXQgc2hvdWxkIGJlIG9rIHRvIGNoZWNrIG9ubHkgbmV4dENvZGUgPj0gVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0hcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5leHRDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CWVRFX0NPTVBBQ1RJT05fTU9ERV9MQVRDSF82OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQkVHSU5fTUFDUk9fUERGNDE3X0NPTlRST0xfQkxPQ0s6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfVEVSTUlOQVRPUjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjb3VudCAlIDUgPT09IDApICYmIChjb3VudCA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb2RlIGV2ZXJ5IDUgY29kZXdvcmRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0byBCYXNlIDI1NlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogLyppbnQqLyA9IDA7IGogPCA2OyArK2opIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQG5vdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogSmF2YVNjcmlwdCBzdG9yZXMgbnVtYmVycyBhcyA2NCBiaXRzIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIGJ1dCBhbGwgYml0d2lzZSBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgb24gMzIgYml0cyBiaW5hcnkgbnVtYmVycy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU28gdGhlIG5leHQgYml0d2lzZSBvcGVyYXRpb24gY291bGQgbm90IGJlIGRvbmUgd2l0aCBzaW1wbGUgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlZEJ5dGVzLndyaXRlKC8qKGJ5dGUpKi8gTnVtYmVyKGNyZWF0ZUJpZ0ludCh2YWx1ZSkgPj4gY3JlYXRlQmlnSW50KDggKiAoNSAtIGopKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVuZCBvZiBhbGwgY29kZXdvcmRzIGlzIHJlYWNoZWQgdGhlIGxhc3QgY29kZXdvcmQgbmVlZHMgdG8gYmUgYWRkZWRcclxuICAgICAgICAgICAgICAgIGlmIChjb2RlSW5kZXggPT09IGNvZGV3b3Jkc1swXSAmJiBuZXh0Q29kZSA8IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0gpIHtcclxuICAgICAgICAgICAgICAgICAgICBieXRlQ29tcGFjdGVkQ29kZXdvcmRzW2NvdW50KytdID0gbmV4dENvZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiBCeXRlIENvbXBhY3Rpb24gbW9kZSBpcyBpbnZva2VkIHdpdGggY29kZXdvcmQgOTAxLFxyXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxhc3QgZ3JvdXAgb2YgY29kZXdvcmRzIGlzIGludGVycHJldGVkIGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgICAvLyBhcyBvbmUgYnl0ZSBwZXIgY29kZXdvcmQsIHdpdGhvdXQgY29tcGFjdGlvbi5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlZEJ5dGVzLndyaXRlKC8qKGJ5dGUpKi8gYnl0ZUNvbXBhY3RlZENvZGV3b3Jkc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XHJcbiAgICAgICAgICAgICAgICAvLyBUb3RhbCBudW1iZXIgb2YgQnl0ZSBDb21wYWN0aW9uIGNoYXJhY3RlcnMgdG8gYmUgZW5jb2RlZFxyXG4gICAgICAgICAgICAgICAgLy8gaXMgYW4gaW50ZWdlciBtdWx0aXBsZSBvZiA2XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29kZUluZGV4IDwgY29kZXdvcmRzWzBdICYmICFlbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IGNvZGV3b3Jkc1tjb2RlSW5kZXgrK107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPCBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLlRFWFRfQ09NUEFDVElPTl9NT0RFX0xBVENIKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJhc2UgOTAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gOTAwICogdmFsdWUgKyBjb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CRUdJTl9NQUNST19QREY0MTdfQ09OVFJPTF9CTE9DSzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFDUk9fUERGNDE3X1RFUk1JTkFUT1I6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGNvdW50ICUgNSA9PT0gMCkgJiYgKGNvdW50ID4gMCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb2RlIGV2ZXJ5IDUgY29kZXdvcmRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gQmFzZSAyNTZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogQG5vdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICogSmF2YVNjcmlwdCBzdG9yZXMgbnVtYmVycyBhcyA2NCBiaXRzIGZsb2F0aW5nIHBvaW50IG51bWJlcnMsIGJ1dCBhbGwgYml0d2lzZSBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgb24gMzIgYml0cyBiaW5hcnkgbnVtYmVycy5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICogU28gdGhlIG5leHQgYml0d2lzZSBvcGVyYXRpb24gY291bGQgbm90IGJlIGRvbmUgd2l0aCBzaW1wbGUgbnVtYmVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqIC8qaW50Ki8gPSAwOyBqIDwgNjsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVkQnl0ZXMud3JpdGUoLyooYnl0ZSkqLyBOdW1iZXIoY3JlYXRlQmlnSW50KHZhbHVlKSA+PiBjcmVhdGVCaWdJbnQoOCAqICg1IC0gaikpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmRlY29kZShkZWNvZGVkQnl0ZXMudG9CeXRlQXJyYXkoKSwgZW5jb2RpbmcpKTtcclxuICAgICAgICByZXR1cm4gY29kZUluZGV4O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogTnVtZXJpYyBDb21wYWN0aW9uIG1vZGUgKHNlZSA1LjQuNCkgcGVybWl0cyBlZmZpY2llbnQgZW5jb2Rpbmcgb2YgbnVtZXJpYyBkYXRhIHN0cmluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzIChkYXRhICsgZXJyb3IpXHJcbiAgICAgKiBAcGFyYW0gY29kZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxyXG4gICAgICogQHBhcmFtIHJlc3VsdCAgICBUaGUgZGVjb2RlZCBkYXRhIGlzIGFwcGVuZGVkIHRvIHRoZSByZXN1bHQuXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBuZXh0IGluZGV4IGludG8gdGhlIGNvZGV3b3JkIGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uXHJcbiAgICAgKi9cclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIubnVtZXJpY0NvbXBhY3Rpb24gPSBmdW5jdGlvbiAoY29kZXdvcmRzLCBjb2RlSW5kZXggLyppbnQqLywgcmVzdWx0KSB7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICB2YXIgZW5kID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIG51bWVyaWNDb2Rld29yZHMgPSBuZXcgSW50MzJBcnJheShEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BWF9OVU1FUklDX0NPREVXT1JEUyk7XHJcbiAgICAgICAgd2hpbGUgKGNvZGVJbmRleCA8IGNvZGV3b3Jkc1swXSAmJiAhZW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2RlID0gY29kZXdvcmRzW2NvZGVJbmRleCsrXTtcclxuICAgICAgICAgICAgaWYgKGNvZGVJbmRleCA9PT0gY29kZXdvcmRzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb2RlIDwgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCkge1xyXG4gICAgICAgICAgICAgICAgbnVtZXJpY0NvZGV3b3Jkc1tjb3VudF0gPSBjb2RlO1xyXG4gICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5URVhUX0NPTVBBQ1RJT05fTU9ERV9MQVRDSDpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0g6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIXzY6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJFR0lOX01BQ1JPX1BERjQxN19DT05UUk9MX0JMT0NLOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQ6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSW5kZXgtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKChjb3VudCAlIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFYX05VTUVSSUNfQ09ERVdPUkRTID09PSAwIHx8IGNvZGUgPT09IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNRVJJQ19DT01QQUNUSU9OX01PREVfTEFUQ0ggfHwgZW5kKSAmJiBjb3VudCA+IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlLWludm9raW5nIE51bWVyaWMgQ29tcGFjdGlvbiBtb2RlIChieSB1c2luZyBjb2Rld29yZCA5MDJcclxuICAgICAgICAgICAgICAgIC8vIHdoaWxlIGluIE51bWVyaWMgQ29tcGFjdGlvbiBtb2RlKSBzZXJ2ZXMgIHRvIHRlcm1pbmF0ZSB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgTnVtZXJpYyBDb21wYWN0aW9uIG1vZGUgZ3JvdXBpbmcgYXMgZGVzY3JpYmVkIGluIDUuNC40LjIsXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhlbiB0byBzdGFydCBhIG5ldyBvbmUgZ3JvdXBpbmcuXHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlQmFzZTkwMHRvQmFzZTEwKG51bWVyaWNDb2Rld29yZHMsIGNvdW50KSk7XHJcbiAgICAgICAgICAgICAgICBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGVJbmRleDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnQgYSBsaXN0IG9mIE51bWVyaWMgQ29tcGFjdGVkIGNvZGV3b3JkcyBmcm9tIEJhc2UgOTAwIHRvIEJhc2UgMTAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvZGV3b3JkcyBUaGUgYXJyYXkgb2YgY29kZXdvcmRzXHJcbiAgICAgKiBAcGFyYW0gY291bnQgICAgIFRoZSBudW1iZXIgb2YgY29kZXdvcmRzXHJcbiAgICAgKiBAcmV0dXJuIFRoZSBkZWNvZGVkIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIE51bWVyaWMgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBFWEFNUExFXHJcbiAgICAgKiBFbmNvZGUgdGhlIGZpZnRlZW4gZGlnaXQgbnVtZXJpYyBzdHJpbmcgMDAwMjEzMjk4MTc0MDAwXHJcbiAgICAgKiBQcmVmaXggdGhlIG51bWVyaWMgc3RyaW5nIHdpdGggYSAxIGFuZCBzZXQgdGhlIGluaXRpYWwgdmFsdWUgb2ZcclxuICAgICAqIHQgPSAxIDAwMCAyMTMgMjk4IDE3NCAwMDBcclxuICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCAwXHJcbiAgICAgKiBkMCA9IDEgMDAwIDIxMyAyOTggMTc0IDAwMCBtb2QgOTAwID0gMjAwXHJcbiAgICAgKlxyXG4gICAgICogdCA9IDEgMDAwIDIxMyAyOTggMTc0IDAwMCBkaXYgOTAwID0gMSAxMTEgMzQ4IDEwOSAwODJcclxuICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCAxXHJcbiAgICAgKiBkMSA9IDEgMTExIDM0OCAxMDkgMDgyIG1vZCA5MDAgPSAyODJcclxuICAgICAqXHJcbiAgICAgKiB0ID0gMSAxMTEgMzQ4IDEwOSAwODIgZGl2IDkwMCA9IDEgMjM0IDgzMSAyMzJcclxuICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCAyXHJcbiAgICAgKiBkMiA9IDEgMjM0IDgzMSAyMzIgbW9kIDkwMCA9IDYzMlxyXG4gICAgICpcclxuICAgICAqIHQgPSAxIDIzNCA4MzEgMjMyIGRpdiA5MDAgPSAxIDM3MiAwMzRcclxuICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCAzXHJcbiAgICAgKiBkMyA9IDEgMzcyIDAzNCBtb2QgOTAwID0gNDM0XHJcbiAgICAgKlxyXG4gICAgICogdCA9IDEgMzcyIDAzNCBkaXYgOTAwID0gMSA1MjRcclxuICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCA0XHJcbiAgICAgKiBkNCA9IDEgNTI0IG1vZCA5MDAgPSA2MjRcclxuICAgICAqXHJcbiAgICAgKiB0ID0gMSA1MjQgZGl2IDkwMCA9IDFcclxuICAgICAqIENhbGN1bGF0ZSBjb2Rld29yZCA1XHJcbiAgICAgKiBkNSA9IDEgbW9kIDkwMCA9IDFcclxuICAgICAqIHQgPSAxIGRpdiA5MDAgPSAwXHJcbiAgICAgKiBDb2Rld29yZCBzZXF1ZW5jZSBpczogMSwgNjI0LCA0MzQsIDYzMiwgMjgyLCAyMDBcclxuICAgICAqXHJcbiAgICAgKiBEZWNvZGUgdGhlIGFib3ZlIGNvZGV3b3JkcyBpbnZvbHZlc1xyXG4gICAgICogICAxIHggOTAwIHBvd2VyIG9mIDUgKyA2MjQgeCA5MDAgcG93ZXIgb2YgNCArIDQzNCB4IDkwMCBwb3dlciBvZiAzICtcclxuICAgICAqIDYzMiB4IDkwMCBwb3dlciBvZiAyICsgMjgyIHggOTAwIHBvd2VyIG9mIDEgKyAyMDAgeCA5MDAgcG93ZXIgb2YgMCA9IDEwMDAyMTMyOTgxNzQwMDBcclxuICAgICAqXHJcbiAgICAgKiBSZW1vdmUgbGVhZGluZyAxID0+ICBSZXN1bHQgaXMgMDAwMjEzMjk4MTc0MDAwXHJcbiAgICAgKlxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVCYXNlOTAwdG9CYXNlMTAgPSBmdW5jdGlvbiAoY29kZXdvcmRzLCBjb3VudCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaWdJbnQoMCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0ICs9IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuRVhQOTAwW2NvdW50IC0gaSAtIDFdICogY3JlYXRlQmlnSW50KGNvZGV3b3Jkc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHRTdHJpbmcgPSByZXN1bHQudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAocmVzdWx0U3RyaW5nLmNoYXJBdCgwKSAhPT0gJzEnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRTdHJpbmcuc3Vic3RyaW5nKDEpO1xyXG4gICAgfTtcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuVEVYVF9DT01QQUNUSU9OX01PREVfTEFUQ0ggPSA5MDA7XHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJZVEVfQ09NUEFDVElPTl9NT0RFX0xBVENIID0gOTAxO1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5OVU1FUklDX0NPTVBBQ1RJT05fTU9ERV9MQVRDSCA9IDkwMjtcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQllURV9DT01QQUNUSU9OX01PREVfTEFUQ0hfNiA9IDkyNDtcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuRUNJX1VTRVJfREVGSU5FRCA9IDkyNTtcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuRUNJX0dFTkVSQUxfUFVSUE9TRSA9IDkyNjtcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuRUNJX0NIQVJTRVQgPSA5Mjc7XHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkJFR0lOX01BQ1JPX1BERjQxN19DT05UUk9MX0JMT0NLID0gOTI4O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5CRUdJTl9NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTEQgPSA5MjM7XHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19URVJNSU5BVE9SID0gOTIyO1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NT0RFX1NISUZUX1RPX0JZVEVfQ09NUEFDVElPTl9NT0RFID0gOTEzO1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQVhfTlVNRVJJQ19DT0RFV09SRFMgPSAxNTtcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0ZJTEVfTkFNRSA9IDA7XHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9TRUdNRU5UX0NPVU5UID0gMTtcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX1RJTUVfU1RBTVAgPSAyO1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfU0VOREVSID0gMztcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTUFDUk9fUERGNDE3X09QVElPTkFMX0ZJRUxEX0FERFJFU1NFRSA9IDQ7XHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLk1BQ1JPX1BERjQxN19PUFRJT05BTF9GSUVMRF9GSUxFX1NJWkUgPSA1O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NQUNST19QREY0MTdfT1BUSU9OQUxfRklFTERfQ0hFQ0tTVU0gPSA2O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QTCA9IDI1O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5MTCA9IDI3O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5BUyA9IDI3O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NTCA9IDI4O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5BTCA9IDI4O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QUyA9IDI5O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5QQUwgPSAyOTtcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuUFVOQ1RfQ0hBUlMgPSAnOzw+QFtcXFxcXV9gfiFcXHJcXHQsOlxcbi0uJC9cInwqKCk/e31cXCcnO1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5NSVhFRF9DSEFSUyA9ICcwMTIzNDU2Nzg5JlxcclxcdCw6Iy0uJC8rJSo9Xic7XHJcbiAgICAvKipcclxuICAgICAqIFRhYmxlIGNvbnRhaW5pbmcgdmFsdWVzIGZvciB0aGUgZXhwb25lbnQgb2YgOTAwLlxyXG4gICAgICogVGhpcyBpcyB1c2VkIGluIHRoZSBudW1lcmljIGNvbXBhY3Rpb24gZGVjb2RlIGFsZ29yaXRobS5cclxuICAgICAqL1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5FWFA5MDAgPSBnZXRCaWdJbnRDb25zdHJ1Y3RvcigpID8gZ2V0RVhQOTAwKCkgOiBbXTtcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuTlVNQkVSX09GX1NFUVVFTkNFX0NPREVXT1JEUyA9IDI7XHJcbiAgICByZXR1cm4gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVjb2RlZEJpdFN0cmVhbVBhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2RlcjtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LlBERjQxN0NvbW1vbjtcclxudmFyIFBERjQxN0NvbW1vbl8xID0gcmVxdWlyZShcIi4uL1BERjQxN0NvbW1vblwiKTtcclxudmFyIEZvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvRm9ybWF0dGVyXCIpO1xyXG4vKipcclxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XHJcbiAqL1xyXG52YXIgRGV0ZWN0aW9uUmVzdWx0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGV0ZWN0aW9uUmVzdWx0KGJhcmNvZGVNZXRhZGF0YSwgYm91bmRpbmdCb3gpIHtcclxuICAgICAgICAvKmZpbmFsKi8gdGhpcy5BREpVU1RfUk9XX05VTUJFUl9TS0lQID0gMjtcclxuICAgICAgICB0aGlzLmJhcmNvZGVNZXRhZGF0YSA9IGJhcmNvZGVNZXRhZGF0YTtcclxuICAgICAgICB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCA9IGJhcmNvZGVNZXRhZGF0YS5nZXRDb2x1bW5Db3VudCgpO1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveDtcclxuICAgICAgICAvLyB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnMgPSBuZXcgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMl07XHJcbiAgICAgICAgdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zID0gbmV3IEFycmF5KHRoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMik7XHJcbiAgICB9XHJcbiAgICBEZXRlY3Rpb25SZXN1bHQucHJvdG90eXBlLmdldERldGVjdGlvblJlc3VsdENvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5hZGp1c3RJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1swXSk7XHJcbiAgICAgICAgdGhpcy5hZGp1c3RJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdKTtcclxuICAgICAgICB2YXIgdW5hZGp1c3RlZENvZGV3b3JkQ291bnQgPSBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1BWF9DT0RFV09SRFNfSU5fQkFSQ09ERTtcclxuICAgICAgICB2YXIgcHJldmlvdXNVbmFkanVzdGVkQ291bnQ7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBwcmV2aW91c1VuYWRqdXN0ZWRDb3VudCA9IHVuYWRqdXN0ZWRDb2Rld29yZENvdW50O1xyXG4gICAgICAgICAgICB1bmFkanVzdGVkQ29kZXdvcmRDb3VudCA9IHRoaXMuYWRqdXN0Um93TnVtYmVyc0FuZEdldENvdW50KCk7XHJcbiAgICAgICAgfSB3aGlsZSAodW5hZGp1c3RlZENvZGV3b3JkQ291bnQgPiAwICYmIHVuYWRqdXN0ZWRDb2Rld29yZENvdW50IDwgcHJldmlvdXNVbmFkanVzdGVkQ291bnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnM7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS5hZGp1c3RJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzID0gZnVuY3Rpb24gKGRldGVjdGlvblJlc3VsdENvbHVtbikge1xyXG4gICAgICAgIGlmIChkZXRlY3Rpb25SZXN1bHRDb2x1bW4gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHRDb2x1bW5cclxuICAgICAgICAgICAgICAgIC5hZGp1c3RDb21wbGV0ZUluZGljYXRvckNvbHVtblJvd051bWJlcnModGhpcy5iYXJjb2RlTWV0YWRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBUT0RPIGVuc3VyZSB0aGF0IG5vIGRldGVjdGVkIGNvZGV3b3JkcyB3aXRoIHVua25vd24gcm93IG51bWJlciBhcmUgbGVmdFxyXG4gICAgLy8gd2Ugc2hvdWxkIGJlIGFibGUgdG8gZXN0aW1hdGUgdGhlIHJvdyBoZWlnaHQgYW5kIHVzZSBpdCBhcyBhIGhpbnQgZm9yIHRoZSByb3cgbnVtYmVyXHJcbiAgICAvLyB3ZSBzaG91bGQgYWxzbyBmaWxsIHRoZSByb3dzIHRvcCB0byBib3R0b20gYW5kIGJvdHRvbSB0byB0b3BcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiBudW1iZXIgb2YgY29kZXdvcmRzIHdoaWNoIGRvbid0IGhhdmUgYSB2YWxpZCByb3cgbnVtYmVyLiBOb3RlIHRoYXQgdGhlIGNvdW50IGlzIG5vdCBhY2N1cmF0ZSBhcyBjb2Rld29yZHNcclxuICAgICAqIHdpbGwgYmUgY291bnRlZCBzZXZlcmFsIHRpbWVzLiBJdCBqdXN0IHNlcnZlcyBhcyBhbiBpbmRpY2F0b3IgdG8gc2VlIHdoZW4gd2UgY2FuIHN0b3AgYWRqdXN0aW5nIHJvdyBudW1iZXJzXHJcbiAgICAgKi9cclxuICAgIERldGVjdGlvblJlc3VsdC5wcm90b3R5cGUuYWRqdXN0Um93TnVtYmVyc0FuZEdldENvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB1bmFkanVzdGVkQ291bnQgPSB0aGlzLmFkanVzdFJvd051bWJlcnNCeVJvdygpO1xyXG4gICAgICAgIGlmICh1bmFkanVzdGVkQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGJhcmNvZGVDb2x1bW4gLyppbnQqLyA9IDE7IGJhcmNvZGVDb2x1bW4gPCB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDE7IGJhcmNvZGVDb2x1bW4rKykge1xyXG4gICAgICAgICAgICB2YXIgY29kZXdvcmRzID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjb2Rld29yZHNSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3Jkc1JvdyA8IGNvZGV3b3Jkcy5sZW5ndGg7IGNvZGV3b3Jkc1JvdysrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFjb2Rld29yZHNbY29kZXdvcmRzUm93XS5oYXNWYWxpZFJvd051bWJlcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RSb3dOdW1iZXJzKGJhcmNvZGVDb2x1bW4sIGNvZGV3b3Jkc1JvdywgY29kZXdvcmRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5hZGp1c3RlZENvdW50O1xyXG4gICAgfTtcclxuICAgIERldGVjdGlvblJlc3VsdC5wcm90b3R5cGUuYWRqdXN0Um93TnVtYmVyc0J5Um93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuYWRqdXN0Um93TnVtYmVyc0Zyb21Cb3RoUkkoKTtcclxuICAgICAgICAvLyBUT0RPIHdlIHNob3VsZCBvbmx5IGRvIGZ1bGwgcm93IGFkanVzdG1lbnRzIGlmIHJvdyBudW1iZXJzIG9mIGxlZnQgYW5kIHJpZ2h0IHJvdyBpbmRpY2F0b3IgY29sdW1uIG1hdGNoLlxyXG4gICAgICAgIC8vIE1heWJlIGl0J3MgZXZlbiBiZXR0ZXIgdG8gY2FsY3VsYXRlZCB0aGUgaGVpZ2h0IChyb3dzOiBkKSBhbmQgZGl2aWRlIGl0IGJ5IHRoZSBudW1iZXIgb2YgYmFyY29kZVxyXG4gICAgICAgIC8vIHJvd3MuIFRoaXMsIHRvZ2V0aGVyIHdpdGggdGhlIExSSSBhbmQgUlJJIHJvdyBudW1iZXJzIHNob3VsZCBhbGxvdyB1cyB0byBnZXQgYSBnb29kIGVzdGltYXRlIHdoZXJlIGEgcm93XHJcbiAgICAgICAgLy8gbnVtYmVyIHN0YXJ0cyBhbmQgZW5kcy5cclxuICAgICAgICB2YXIgdW5hZGp1c3RlZENvdW50ID0gdGhpcy5hZGp1c3RSb3dOdW1iZXJzRnJvbUxSSSgpO1xyXG4gICAgICAgIHJldHVybiB1bmFkanVzdGVkQ291bnQgKyB0aGlzLmFkanVzdFJvd051bWJlcnNGcm9tUlJJKCk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS5hZGp1c3RSb3dOdW1iZXJzRnJvbUJvdGhSSSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdID09IG51bGwgfHwgdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBMUkljb2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbMF0uZ2V0Q29kZXdvcmRzKCk7XHJcbiAgICAgICAgdmFyIFJSSWNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdLmdldENvZGV3b3JkcygpO1xyXG4gICAgICAgIGZvciAodmFyIGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgTFJJY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcclxuICAgICAgICAgICAgaWYgKExSSWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIFJSSWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIExSSWNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmdldFJvd051bWJlcigpID09PSBSUkljb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYmFyY29kZUNvbHVtbiAvKmludCovID0gMTsgYmFyY29kZUNvbHVtbiA8PSB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudDsgYmFyY29kZUNvbHVtbisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZGV3b3JkID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpW2NvZGV3b3Jkc1Jvd107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlcihMUkljb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2Rld29yZC5oYXNWYWxpZFJvd051bWJlcigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uXS5nZXRDb2Rld29yZHMoKVtjb2Rld29yZHNSb3ddID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS5hZGp1c3RSb3dOdW1iZXJzRnJvbVJSSSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW3RoaXMuYmFyY29kZUNvbHVtbkNvdW50ICsgMV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVuYWRqdXN0ZWRDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIGNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1t0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDFdLmdldENvZGV3b3JkcygpO1xyXG4gICAgICAgIGZvciAodmFyIGNvZGV3b3Jkc1JvdyAvKmludCovID0gMDsgY29kZXdvcmRzUm93IDwgY29kZXdvcmRzLmxlbmd0aDsgY29kZXdvcmRzUm93KyspIHtcclxuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByb3dJbmRpY2F0b3JSb3dOdW1iZXIgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93XS5nZXRSb3dOdW1iZXIoKTtcclxuICAgICAgICAgICAgdmFyIGludmFsaWRSb3dDb3VudHMgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDE7IGJhcmNvZGVDb2x1bW4gPiAwICYmIGludmFsaWRSb3dDb3VudHMgPCB0aGlzLkFESlVTVF9ST1dfTlVNQkVSX1NLSVA7IGJhcmNvZGVDb2x1bW4tLSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvZGV3b3JkID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dLmdldENvZGV3b3JkcygpW2NvZGV3b3Jkc1Jvd107XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRSb3dDb3VudHMgPSBEZXRlY3Rpb25SZXN1bHQuYWRqdXN0Um93TnVtYmVySWZWYWxpZChyb3dJbmRpY2F0b3JSb3dOdW1iZXIsIGludmFsaWRSb3dDb3VudHMsIGNvZGV3b3JkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvZGV3b3JkLmhhc1ZhbGlkUm93TnVtYmVyKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdW5hZGp1c3RlZENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmFkanVzdGVkQ291bnQ7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS5hZGp1c3RSb3dOdW1iZXJzRnJvbUxSSSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB1bmFkanVzdGVkQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciBjb2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbMF0uZ2V0Q29kZXdvcmRzKCk7XHJcbiAgICAgICAgZm9yICh2YXIgY29kZXdvcmRzUm93IC8qaW50Ki8gPSAwOyBjb2Rld29yZHNSb3cgPCBjb2Rld29yZHMubGVuZ3RoOyBjb2Rld29yZHNSb3crKykge1xyXG4gICAgICAgICAgICBpZiAoY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHJvd0luZGljYXRvclJvd051bWJlciA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddLmdldFJvd051bWJlcigpO1xyXG4gICAgICAgICAgICB2YXIgaW52YWxpZFJvd0NvdW50cyA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGJhcmNvZGVDb2x1bW4gLyppbnQqLyA9IDE7IGJhcmNvZGVDb2x1bW4gPCB0aGlzLmJhcmNvZGVDb2x1bW5Db3VudCArIDEgJiYgaW52YWxpZFJvd0NvdW50cyA8IHRoaXMuQURKVVNUX1JPV19OVU1CRVJfU0tJUDsgYmFyY29kZUNvbHVtbisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZXdvcmQgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKClbY29kZXdvcmRzUm93XTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZFJvd0NvdW50cyA9IERldGVjdGlvblJlc3VsdC5hZGp1c3RSb3dOdW1iZXJJZlZhbGlkKHJvd0luZGljYXRvclJvd051bWJlciwgaW52YWxpZFJvd0NvdW50cywgY29kZXdvcmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmFkanVzdGVkQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuYWRqdXN0ZWRDb3VudDtcclxuICAgIH07XHJcbiAgICBEZXRlY3Rpb25SZXN1bHQuYWRqdXN0Um93TnVtYmVySWZWYWxpZCA9IGZ1bmN0aW9uIChyb3dJbmRpY2F0b3JSb3dOdW1iZXIsIGludmFsaWRSb3dDb3VudHMsIGNvZGV3b3JkKSB7XHJcbiAgICAgICAgaWYgKGNvZGV3b3JkID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGludmFsaWRSb3dDb3VudHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29kZXdvcmQuaGFzVmFsaWRSb3dOdW1iZXIoKSkge1xyXG4gICAgICAgICAgICBpZiAoY29kZXdvcmQuaXNWYWxpZFJvd051bWJlcihyb3dJbmRpY2F0b3JSb3dOdW1iZXIpKSB7XHJcbiAgICAgICAgICAgICAgICBjb2Rld29yZC5zZXRSb3dOdW1iZXIocm93SW5kaWNhdG9yUm93TnVtYmVyKTtcclxuICAgICAgICAgICAgICAgIGludmFsaWRSb3dDb3VudHMgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgKytpbnZhbGlkUm93Q291bnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnZhbGlkUm93Q291bnRzO1xyXG4gICAgfTtcclxuICAgIERldGVjdGlvblJlc3VsdC5wcm90b3R5cGUuYWRqdXN0Um93TnVtYmVycyA9IGZ1bmN0aW9uIChiYXJjb2RlQ29sdW1uLCBjb2Rld29yZHNSb3csIGNvZGV3b3Jkcykge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIHZhciBjb2Rld29yZCA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xyXG4gICAgICAgIHZhciBwcmV2aW91c0NvbHVtbkNvZGV3b3JkcyA9IHRoaXMuZGV0ZWN0aW9uUmVzdWx0Q29sdW1uc1tiYXJjb2RlQ29sdW1uIC0gMV0uZ2V0Q29kZXdvcmRzKCk7XHJcbiAgICAgICAgdmFyIG5leHRDb2x1bW5Db2Rld29yZHMgPSBwcmV2aW91c0NvbHVtbkNvZGV3b3JkcztcclxuICAgICAgICBpZiAodGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW4gKyAxXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIG5leHRDb2x1bW5Db2Rld29yZHMgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbiArIDFdLmdldENvZGV3b3JkcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsZXQgb3RoZXJDb2Rld29yZHM6IENvZGV3b3JkW10gPSBuZXcgQ29kZXdvcmRbMTRdO1xyXG4gICAgICAgIHZhciBvdGhlckNvZGV3b3JkcyA9IG5ldyBBcnJheSgxNCk7XHJcbiAgICAgICAgb3RoZXJDb2Rld29yZHNbMl0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xyXG4gICAgICAgIG90aGVyQ29kZXdvcmRzWzNdID0gbmV4dENvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xyXG4gICAgICAgIGlmIChjb2Rld29yZHNSb3cgPiAwKSB7XHJcbiAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzBdID0gY29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDFdO1xyXG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s0XSA9IHByZXZpb3VzQ29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDFdO1xyXG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s1XSA9IG5leHRDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93IC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2Rld29yZHNSb3cgPiAxKSB7XHJcbiAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzhdID0gY29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIDJdO1xyXG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1sxMF0gPSBwcmV2aW91c0NvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSAyXTtcclxuICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMTFdID0gbmV4dENvbHVtbkNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgLSAyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvZGV3b3Jkc1JvdyA8IGNvZGV3b3Jkcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzFdID0gY29kZXdvcmRzW2NvZGV3b3Jkc1JvdyArIDFdO1xyXG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s2XSA9IHByZXZpb3VzQ29sdW1uQ29kZXdvcmRzW2NvZGV3b3Jkc1JvdyArIDFdO1xyXG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s3XSA9IG5leHRDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93ICsgMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2Rld29yZHNSb3cgPCBjb2Rld29yZHMubGVuZ3RoIC0gMikge1xyXG4gICAgICAgICAgICBvdGhlckNvZGV3b3Jkc1s5XSA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3cgKyAyXTtcclxuICAgICAgICAgICAgb3RoZXJDb2Rld29yZHNbMTJdID0gcHJldmlvdXNDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93ICsgMl07XHJcbiAgICAgICAgICAgIG90aGVyQ29kZXdvcmRzWzEzXSA9IG5leHRDb2x1bW5Db2Rld29yZHNbY29kZXdvcmRzUm93ICsgMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG90aGVyQ29kZXdvcmRzXzEgPSBfX3ZhbHVlcyhvdGhlckNvZGV3b3JkcyksIG90aGVyQ29kZXdvcmRzXzFfMSA9IG90aGVyQ29kZXdvcmRzXzEubmV4dCgpOyAhb3RoZXJDb2Rld29yZHNfMV8xLmRvbmU7IG90aGVyQ29kZXdvcmRzXzFfMSA9IG90aGVyQ29kZXdvcmRzXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJDb2Rld29yZCA9IG90aGVyQ29kZXdvcmRzXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChEZXRlY3Rpb25SZXN1bHQuYWRqdXN0Um93TnVtYmVyKGNvZGV3b3JkLCBvdGhlckNvZGV3b3JkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyQ29kZXdvcmRzXzFfMSAmJiAhb3RoZXJDb2Rld29yZHNfMV8xLmRvbmUgJiYgKF9hID0gb3RoZXJDb2Rld29yZHNfMS5yZXR1cm4pKSBfYS5jYWxsKG90aGVyQ29kZXdvcmRzXzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHRydWUsIGlmIHJvdyBudW1iZXIgd2FzIGFkanVzdGVkLCBmYWxzZSBvdGhlcndpc2VcclxuICAgICAqL1xyXG4gICAgRGV0ZWN0aW9uUmVzdWx0LmFkanVzdFJvd051bWJlciA9IGZ1bmN0aW9uIChjb2Rld29yZCwgb3RoZXJDb2Rld29yZCkge1xyXG4gICAgICAgIGlmIChvdGhlckNvZGV3b3JkID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3RoZXJDb2Rld29yZC5oYXNWYWxpZFJvd051bWJlcigpICYmIG90aGVyQ29kZXdvcmQuZ2V0QnVja2V0KCkgPT09IGNvZGV3b3JkLmdldEJ1Y2tldCgpKSB7XHJcbiAgICAgICAgICAgIGNvZGV3b3JkLnNldFJvd051bWJlcihvdGhlckNvZGV3b3JkLmdldFJvd051bWJlcigpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBEZXRlY3Rpb25SZXN1bHQucHJvdG90eXBlLmdldEJhcmNvZGVDb2x1bW5Db3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQ7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS5nZXRCYXJjb2RlUm93Q291bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS5nZXRCYXJjb2RlRUNMZXZlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iYXJjb2RlTWV0YWRhdGEuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKTtcclxuICAgIH07XHJcbiAgICBEZXRlY3Rpb25SZXN1bHQucHJvdG90eXBlLnNldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xyXG4gICAgfTtcclxuICAgIERldGVjdGlvblJlc3VsdC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdCb3g7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS5zZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4gPSBmdW5jdGlvbiAoYmFyY29kZUNvbHVtbiwgZGV0ZWN0aW9uUmVzdWx0Q29sdW1uKSB7XHJcbiAgICAgICAgdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dID0gZGV0ZWN0aW9uUmVzdWx0Q29sdW1uO1xyXG4gICAgfTtcclxuICAgIERldGVjdGlvblJlc3VsdC5wcm90b3R5cGUuZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uID0gZnVuY3Rpb24gKGJhcmNvZGVDb2x1bW4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zW2JhcmNvZGVDb2x1bW5dO1xyXG4gICAgfTtcclxuICAgIC8vIEBPdmVycmlkZVxyXG4gICAgRGV0ZWN0aW9uUmVzdWx0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcm93SW5kaWNhdG9yQ29sdW1uID0gdGhpcy5kZXRlY3Rpb25SZXN1bHRDb2x1bW5zWzBdO1xyXG4gICAgICAgIGlmIChyb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByb3dJbmRpY2F0b3JDb2x1bW4gPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdHJ5IChcclxuICAgICAgICB2YXIgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAvLyApIHtcclxuICAgICAgICBmb3IgKHZhciBjb2Rld29yZHNSb3cgLyppbnQqLyA9IDA7IGNvZGV3b3Jkc1JvdyA8IHJvd0luZGljYXRvckNvbHVtbi5nZXRDb2Rld29yZHMoKS5sZW5ndGg7IGNvZGV3b3Jkc1JvdysrKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJ0NXICUzZDonLCBjb2Rld29yZHNSb3cpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBiYXJjb2RlQ29sdW1uIC8qaW50Ki8gPSAwOyBiYXJjb2RlQ29sdW1uIDwgdGhpcy5iYXJjb2RlQ29sdW1uQ291bnQgKyAyOyBiYXJjb2RlQ29sdW1uKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyAgICB8ICAgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZXdvcmQgPSB0aGlzLmRldGVjdGlvblJlc3VsdENvbHVtbnNbYmFyY29kZUNvbHVtbl0uZ2V0Q29kZXdvcmRzKClbY29kZXdvcmRzUm93XTtcclxuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnICAgIHwgICAnKTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyAlM2R8JTNkJywgY29kZXdvcmQuZ2V0Um93TnVtYmVyKCksIGNvZGV3b3JkLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyVuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZXIudG9TdHJpbmcoKTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERldGVjdGlvblJlc3VsdDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGV0ZWN0aW9uUmVzdWx0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZXRlY3Rpb25SZXN1bHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXI7XHJcbi8vIGltcG9ydCBqYXZhLnV0aWwuRm9ybWF0dGVyO1xyXG52YXIgRm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9Gb3JtYXR0ZXJcIik7XHJcbnZhciBCb3VuZGluZ0JveF8xID0gcmVxdWlyZShcIi4vQm91bmRpbmdCb3hcIik7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIEd1ZW50aGVyIEdyYXVcclxuICovXHJcbnZhciBEZXRlY3Rpb25SZXN1bHRDb2x1bW4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEZXRlY3Rpb25SZXN1bHRDb2x1bW4oYm91bmRpbmdCb3gpIHtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94XzEuZGVmYXVsdChib3VuZGluZ0JveCk7XHJcbiAgICAgICAgLy8gdGhpcy5jb2Rld29yZHMgPSBuZXcgQ29kZXdvcmRbYm91bmRpbmdCb3guZ2V0TWF4WSgpIC0gYm91bmRpbmdCb3guZ2V0TWluWSgpICsgMV07XHJcbiAgICAgICAgdGhpcy5jb2Rld29yZHMgPSBuZXcgQXJyYXkoYm91bmRpbmdCb3guZ2V0TWF4WSgpIC0gYm91bmRpbmdCb3guZ2V0TWluWSgpICsgMSk7XHJcbiAgICB9XHJcbiAgICAvKmZpbmFsKi8gRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLnByb3RvdHlwZS5nZXRDb2Rld29yZE5lYXJieSA9IGZ1bmN0aW9uIChpbWFnZVJvdykge1xyXG4gICAgICAgIHZhciBjb2Rld29yZCA9IHRoaXMuZ2V0Q29kZXdvcmQoaW1hZ2VSb3cpO1xyXG4gICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2Rld29yZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBEZXRlY3Rpb25SZXN1bHRDb2x1bW4uTUFYX05FQVJCWV9ESVNUQU5DRTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBuZWFySW1hZ2VSb3cgPSB0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KGltYWdlUm93KSAtIGk7XHJcbiAgICAgICAgICAgIGlmIChuZWFySW1hZ2VSb3cgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgY29kZXdvcmQgPSB0aGlzLmNvZGV3b3Jkc1tuZWFySW1hZ2VSb3ddO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZXdvcmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmVhckltYWdlUm93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChpbWFnZVJvdykgKyBpO1xyXG4gICAgICAgICAgICBpZiAobmVhckltYWdlUm93IDwgdGhpcy5jb2Rld29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBjb2Rld29yZCA9IHRoaXMuY29kZXdvcmRzW25lYXJJbWFnZVJvd107XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2Rld29yZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKmZpbmFsIGludCovIERldGVjdGlvblJlc3VsdENvbHVtbi5wcm90b3R5cGUuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXggPSBmdW5jdGlvbiAoaW1hZ2VSb3cpIHtcclxuICAgICAgICByZXR1cm4gaW1hZ2VSb3cgLSB0aGlzLmJvdW5kaW5nQm94LmdldE1pblkoKTtcclxuICAgIH07XHJcbiAgICAvKmZpbmFsIHZvaWQqLyBEZXRlY3Rpb25SZXN1bHRDb2x1bW4ucHJvdG90eXBlLnNldENvZGV3b3JkID0gZnVuY3Rpb24gKGltYWdlUm93LCBjb2Rld29yZCkge1xyXG4gICAgICAgIHRoaXMuY29kZXdvcmRzW3RoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoaW1hZ2VSb3cpXSA9IGNvZGV3b3JkO1xyXG4gICAgfTtcclxuICAgIC8qZmluYWwqLyBEZXRlY3Rpb25SZXN1bHRDb2x1bW4ucHJvdG90eXBlLmdldENvZGV3b3JkID0gZnVuY3Rpb24gKGltYWdlUm93KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXdvcmRzW3RoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoaW1hZ2VSb3cpXTtcclxuICAgIH07XHJcbiAgICAvKmZpbmFsKi8gRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ0JveDtcclxuICAgIH07XHJcbiAgICAvKmZpbmFsKi8gRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLnByb3RvdHlwZS5nZXRDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXdvcmRzO1xyXG4gICAgfTtcclxuICAgIC8vIEBPdmVycmlkZVxyXG4gICAgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZV8xLCBfYTtcclxuICAgICAgICB2YXIgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB2YXIgcm93ID0gMDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuY29kZXdvcmRzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvZGV3b3JkID0gX2MudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJyUzZDogICAgfCAgICVuJywgcm93KyspO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnJTNkOiAlM2R8JTNkJW4nLCByb3crKywgY29kZXdvcmQuZ2V0Um93TnVtYmVyKCksIGNvZGV3b3JkLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uLk1BWF9ORUFSQllfRElTVEFOQ0UgPSA1O1xyXG4gICAgcmV0dXJuIERldGVjdGlvblJlc3VsdENvbHVtbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGV0ZWN0aW9uUmVzdWx0Q29sdW1uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZXRlY3Rpb25SZXN1bHRDb2x1bW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LlBERjQxN0NvbW1vbjtcclxudmFyIFBERjQxN0NvbW1vbl8xID0gcmVxdWlyZShcIi4uL1BERjQxN0NvbW1vblwiKTtcclxudmFyIEJhcmNvZGVNZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vQmFyY29kZU1ldGFkYXRhXCIpO1xyXG52YXIgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uXzEgPSByZXF1aXJlKFwiLi9EZXRlY3Rpb25SZXN1bHRDb2x1bW5cIik7XHJcbnZhciBCYXJjb2RlVmFsdWVfMSA9IHJlcXVpcmUoXCIuL0JhcmNvZGVWYWx1ZVwiKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxyXG4gKi9cclxudmFyIERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4oYm91bmRpbmdCb3gsIGlzTGVmdCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGJvdW5kaW5nQm94KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9pc0xlZnQgPSBpc0xlZnQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uLnByb3RvdHlwZS5zZXRSb3dOdW1iZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5nZXRDb2Rld29yZHMoKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2Rld29yZCA9IF9jLnZhbHVlIC8qQ29kZXdvcmQqLztcclxuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZXdvcmQuc2V0Um93TnVtYmVyQXNSb3dJbmRpY2F0b3JDb2x1bW4oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVE9ETyBpbXBsZW1lbnQgcHJvcGVybHlcclxuICAgIC8vIFRPRE8gbWF5YmUgd2Ugc2hvdWxkIGFkZCBtaXNzaW5nIGNvZGV3b3JkcyB0byBzdG9yZSB0aGUgY29ycmVjdCByb3cgbnVtYmVyIHRvIG1ha2VcclxuICAgIC8vIGZpbmRpbmcgcm93IG51bWJlcnMgZm9yIG90aGVyIGNvbHVtbnMgZWFzaWVyXHJcbiAgICAvLyB1c2Ugcm93IGhlaWdodCBjb3VudCB0byBtYWtlIGRldGVjdGlvbiBvZiBpbnZhbGlkIHJvdyBudW1iZXJzIG1vcmUgcmVsaWFibGVcclxuICAgIERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbi5wcm90b3R5cGUuYWRqdXN0Q29tcGxldGVJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzID0gZnVuY3Rpb24gKGJhcmNvZGVNZXRhZGF0YSkge1xyXG4gICAgICAgIHZhciBjb2Rld29yZHMgPSB0aGlzLmdldENvZGV3b3JkcygpO1xyXG4gICAgICAgIHRoaXMuc2V0Um93TnVtYmVycygpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlSW5jb3JyZWN0Q29kZXdvcmRzKGNvZGV3b3JkcywgYmFyY29kZU1ldGFkYXRhKTtcclxuICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuX2lzTGVmdCA/IGJvdW5kaW5nQm94LmdldFRvcExlZnQoKSA6IGJvdW5kaW5nQm94LmdldFRvcFJpZ2h0KCk7XHJcbiAgICAgICAgdmFyIGJvdHRvbSA9IHRoaXMuX2lzTGVmdCA/IGJvdW5kaW5nQm94LmdldEJvdHRvbUxlZnQoKSA6IGJvdW5kaW5nQm94LmdldEJvdHRvbVJpZ2h0KCk7XHJcbiAgICAgICAgdmFyIGZpcnN0Um93ID0gdGhpcy5pbWFnZVJvd1RvQ29kZXdvcmRJbmRleChNYXRoLnRydW5jKHRvcC5nZXRZKCkpKTtcclxuICAgICAgICB2YXIgbGFzdFJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoTWF0aC50cnVuYyhib3R0b20uZ2V0WSgpKSk7XHJcbiAgICAgICAgLy8gV2UgbmVlZCB0byBiZSBjYXJlZnVsIHVzaW5nIHRoZSBhdmVyYWdlIHJvdyBoZWlnaHQuIEJhcmNvZGUgY291bGQgYmUgc2tld2VkIHNvIHRoYXQgd2UgaGF2ZSBzbWFsbGVyIGFuZFxyXG4gICAgICAgIC8vIHRhbGxlciByb3dzXHJcbiAgICAgICAgLy8gZmxvYXQgYXZlcmFnZVJvd0hlaWdodCA9IChsYXN0Um93IC0gZmlyc3RSb3cpIC8gLyooZmxvYXQpKi8gYmFyY29kZU1ldGFkYXRhLmdldFJvd0NvdW50KCk7XHJcbiAgICAgICAgdmFyIGJhcmNvZGVSb3cgPSAtMTtcclxuICAgICAgICB2YXIgbWF4Um93SGVpZ2h0ID0gMTtcclxuICAgICAgICB2YXIgY3VycmVudFJvd0hlaWdodCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgY29kZXdvcmRzUm93IC8qaW50Ki8gPSBmaXJzdFJvdzsgY29kZXdvcmRzUm93IDwgbGFzdFJvdzsgY29kZXdvcmRzUm93KyspIHtcclxuICAgICAgICAgICAgaWYgKGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb2Rld29yZCA9IGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddO1xyXG4gICAgICAgICAgICAvLyAgICAgIGZsb2F0IGV4cGVjdGVkUm93TnVtYmVyID0gKGNvZGV3b3Jkc1JvdyAtIGZpcnN0Um93KSAvIGF2ZXJhZ2VSb3dIZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vICAgICAgaWYgKE1hdGguYWJzKGNvZGV3b3JkLmdldFJvd051bWJlcigpIC0gZXhwZWN0ZWRSb3dOdW1iZXIpID4gMikge1xyXG4gICAgICAgICAgICAvLyAgICAgICAgU2ltcGxlTG9nLmxvZyhMRVZFTC5XQVJOSU5HLFxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgIFwiUmVtb3ZpbmcgY29kZXdvcmQsIHJvd051bWJlclNrZXcgdG9vIGhpZ2gsIGNvZGV3b3JkW1wiICsgY29kZXdvcmRzUm93ICsgXCJdOiBFeHBlY3RlZCBSb3c6IFwiICtcclxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgZXhwZWN0ZWRSb3dOdW1iZXIgKyBcIiwgUmVhbFJvdzogXCIgKyBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSArIFwiLCB2YWx1ZTogXCIgKyBjb2Rld29yZC5nZXRWYWx1ZSgpKTtcclxuICAgICAgICAgICAgLy8gICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZHNSb3ddID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gICAgICB9XHJcbiAgICAgICAgICAgIHZhciByb3dEaWZmZXJlbmNlID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCkgLSBiYXJjb2RlUm93O1xyXG4gICAgICAgICAgICAvLyBUT0RPIGltcHJvdmUgaGFuZGxpbmcgd2l0aCBjYXNlIHdoZXJlIGZpcnN0IHJvdyBpbmRpY2F0b3IgZG9lc24ndCBzdGFydCB3aXRoIDBcclxuICAgICAgICAgICAgaWYgKHJvd0RpZmZlcmVuY2UgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSb3dIZWlnaHQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyb3dEaWZmZXJlbmNlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhSb3dIZWlnaHQgPSBNYXRoLm1heChtYXhSb3dIZWlnaHQsIGN1cnJlbnRSb3dIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCA9IDE7XHJcbiAgICAgICAgICAgICAgICBiYXJjb2RlUm93ID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocm93RGlmZmVyZW5jZSA8IDAgfHxcclxuICAgICAgICAgICAgICAgIGNvZGV3b3JkLmdldFJvd051bWJlcigpID49IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpIHx8XHJcbiAgICAgICAgICAgICAgICByb3dEaWZmZXJlbmNlID4gY29kZXdvcmRzUm93KSB7XHJcbiAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tlZFJvd3MgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF4Um93SGVpZ2h0ID4gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWRSb3dzID0gKG1heFJvd0hlaWdodCAtIDIpICogcm93RGlmZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWRSb3dzID0gcm93RGlmZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBjbG9zZVByZXZpb3VzQ29kZXdvcmRGb3VuZCA9IGNoZWNrZWRSb3dzID49IGNvZGV3b3Jkc1JvdztcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDE7IGkgPD0gY2hlY2tlZFJvd3MgJiYgIWNsb3NlUHJldmlvdXNDb2Rld29yZEZvdW5kOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVyZSBtdXN0IGJlIChoZWlnaHQgKiByb3dEaWZmZXJlbmNlKSBudW1iZXIgb2YgY29kZXdvcmRzIG1pc3NpbmcuIEZvciBub3cgd2UgYXNzdW1lIGhlaWdodCA9IDEuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgaG9wZWZ1bGx5IGdldCByaWQgb2YgbW9zdCBwcm9ibGVtcyBhbHJlYWR5LlxyXG4gICAgICAgICAgICAgICAgICAgIGNsb3NlUHJldmlvdXNDb2Rld29yZEZvdW5kID0gY29kZXdvcmRzW2NvZGV3b3Jkc1JvdyAtIGldICE9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VQcmV2aW91c0NvZGV3b3JkRm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXJjb2RlUm93ID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0dXJuIChpbnQpIChhdmVyYWdlUm93SGVpZ2h0ICsgMC41KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4ucHJvdG90eXBlLmdldFJvd0hlaWdodHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVfMiwgX2E7XHJcbiAgICAgICAgdmFyIGJhcmNvZGVNZXRhZGF0YSA9IHRoaXMuZ2V0QmFyY29kZU1ldGFkYXRhKCk7XHJcbiAgICAgICAgaWYgKGJhcmNvZGVNZXRhZGF0YSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkanVzdEluY29tcGxldGVJbmRpY2F0b3JDb2x1bW5Sb3dOdW1iZXJzKGJhcmNvZGVNZXRhZGF0YSk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuZ2V0Q29kZXdvcmRzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZXdvcmQgPSBfYy52YWx1ZSAvKkNvZGV3b3JkKi87XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dOdW1iZXIgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocm93TnVtYmVyID49IHJlc3VsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBtb3JlIHJvd3MgdGhhbiB0aGUgYmFyY29kZSBtZXRhZGF0YSBhbGxvd3MgZm9yLCBpZ25vcmUgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyb3dOdW1iZXJdKys7XHJcbiAgICAgICAgICAgICAgICB9IC8vIGVsc2UgdGhyb3cgZXhjZXB0aW9uP1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8vIFRPRE8gbWF5YmUgd2Ugc2hvdWxkIGFkZCBtaXNzaW5nIGNvZGV3b3JkcyB0byBzdG9yZSB0aGUgY29ycmVjdCByb3cgbnVtYmVyIHRvIG1ha2VcclxuICAgIC8vIGZpbmRpbmcgcm93IG51bWJlcnMgZm9yIG90aGVyIGNvbHVtbnMgZWFzaWVyXHJcbiAgICAvLyB1c2Ugcm93IGhlaWdodCBjb3VudCB0byBtYWtlIGRldGVjdGlvbiBvZiBpbnZhbGlkIHJvdyBudW1iZXJzIG1vcmUgcmVsaWFibGVcclxuICAgIERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbi5wcm90b3R5cGUuYWRqdXN0SW5jb21wbGV0ZUluZGljYXRvckNvbHVtblJvd051bWJlcnMgPSBmdW5jdGlvbiAoYmFyY29kZU1ldGFkYXRhKSB7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gdGhpcy5nZXRCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIHZhciB0b3AgPSB0aGlzLl9pc0xlZnQgPyBib3VuZGluZ0JveC5nZXRUb3BMZWZ0KCkgOiBib3VuZGluZ0JveC5nZXRUb3BSaWdodCgpO1xyXG4gICAgICAgIHZhciBib3R0b20gPSB0aGlzLl9pc0xlZnQgPyBib3VuZGluZ0JveC5nZXRCb3R0b21MZWZ0KCkgOiBib3VuZGluZ0JveC5nZXRCb3R0b21SaWdodCgpO1xyXG4gICAgICAgIHZhciBmaXJzdFJvdyA9IHRoaXMuaW1hZ2VSb3dUb0NvZGV3b3JkSW5kZXgoTWF0aC50cnVuYyh0b3AuZ2V0WSgpKSk7XHJcbiAgICAgICAgdmFyIGxhc3RSb3cgPSB0aGlzLmltYWdlUm93VG9Db2Rld29yZEluZGV4KE1hdGgudHJ1bmMoYm90dG9tLmdldFkoKSkpO1xyXG4gICAgICAgIC8vIGZsb2F0IGF2ZXJhZ2VSb3dIZWlnaHQgPSAobGFzdFJvdyAtIGZpcnN0Um93KSAvIC8qKGZsb2F0KSovIGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpO1xyXG4gICAgICAgIHZhciBjb2Rld29yZHMgPSB0aGlzLmdldENvZGV3b3JkcygpO1xyXG4gICAgICAgIHZhciBiYXJjb2RlUm93ID0gLTE7XHJcbiAgICAgICAgdmFyIG1heFJvd0hlaWdodCA9IDE7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRSb3dIZWlnaHQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGNvZGV3b3Jkc1JvdyAvKmludCovID0gZmlyc3RSb3c7IGNvZGV3b3Jkc1JvdyA8IGxhc3RSb3c7IGNvZGV3b3Jkc1JvdysrKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZXdvcmRzUm93XSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY29kZXdvcmQgPSBjb2Rld29yZHNbY29kZXdvcmRzUm93XTtcclxuICAgICAgICAgICAgY29kZXdvcmQuc2V0Um93TnVtYmVyQXNSb3dJbmRpY2F0b3JDb2x1bW4oKTtcclxuICAgICAgICAgICAgdmFyIHJvd0RpZmZlcmVuY2UgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSAtIGJhcmNvZGVSb3c7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gaW1wcm92ZSBoYW5kbGluZyB3aXRoIGNhc2Ugd2hlcmUgZmlyc3Qgcm93IGluZGljYXRvciBkb2Vzbid0IHN0YXJ0IHdpdGggMFxyXG4gICAgICAgICAgICBpZiAocm93RGlmZmVyZW5jZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJvd0RpZmZlcmVuY2UgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIG1heFJvd0hlaWdodCA9IE1hdGgubWF4KG1heFJvd0hlaWdodCwgY3VycmVudFJvd0hlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Um93SGVpZ2h0ID0gMTtcclxuICAgICAgICAgICAgICAgIGJhcmNvZGVSb3cgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb2Rld29yZC5nZXRSb3dOdW1iZXIoKSA+PSBiYXJjb2RlTWV0YWRhdGEuZ2V0Um93Q291bnQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29kZXdvcmRzW2NvZGV3b3Jkc1Jvd10gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYmFyY29kZVJvdyA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFJvd0hlaWdodCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0dXJuIChpbnQpIChhdmVyYWdlUm93SGVpZ2h0ICsgMC41KTtcclxuICAgIH07XHJcbiAgICBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4ucHJvdG90eXBlLmdldEJhcmNvZGVNZXRhZGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZV8zLCBfYTtcclxuICAgICAgICB2YXIgY29kZXdvcmRzID0gdGhpcy5nZXRDb2Rld29yZHMoKTtcclxuICAgICAgICB2YXIgYmFyY29kZUNvbHVtbkNvdW50ID0gbmV3IEJhcmNvZGVWYWx1ZV8xLmRlZmF1bHQoKTtcclxuICAgICAgICB2YXIgYmFyY29kZVJvd0NvdW50VXBwZXJQYXJ0ID0gbmV3IEJhcmNvZGVWYWx1ZV8xLmRlZmF1bHQoKTtcclxuICAgICAgICB2YXIgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0ID0gbmV3IEJhcmNvZGVWYWx1ZV8xLmRlZmF1bHQoKTtcclxuICAgICAgICB2YXIgYmFyY29kZUVDTGV2ZWwgPSBuZXcgQmFyY29kZVZhbHVlXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGNvZGV3b3Jkc18xID0gX192YWx1ZXMoY29kZXdvcmRzKSwgY29kZXdvcmRzXzFfMSA9IGNvZGV3b3Jkc18xLm5leHQoKTsgIWNvZGV3b3Jkc18xXzEuZG9uZTsgY29kZXdvcmRzXzFfMSA9IGNvZGV3b3Jkc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvZGV3b3JkID0gY29kZXdvcmRzXzFfMS52YWx1ZSAvKkNvZGV3b3JkKi87XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29kZXdvcmQuc2V0Um93TnVtYmVyQXNSb3dJbmRpY2F0b3JDb2x1bW4oKTtcclxuICAgICAgICAgICAgICAgIHZhciByb3dJbmRpY2F0b3JWYWx1ZSA9IGNvZGV3b3JkLmdldFZhbHVlKCkgJSAzMDtcclxuICAgICAgICAgICAgICAgIHZhciBjb2Rld29yZFJvd051bWJlciA9IGNvZGV3b3JkLmdldFJvd051bWJlcigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0xlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2Rld29yZFJvd051bWJlciArPSAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChjb2Rld29yZFJvd051bWJlciAlIDMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5zZXRWYWx1ZShyb3dJbmRpY2F0b3JWYWx1ZSAqIDMgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlRUNMZXZlbC5zZXRWYWx1ZShyb3dJbmRpY2F0b3JWYWx1ZSAvIDMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlUm93Q291bnRMb3dlclBhcnQuc2V0VmFsdWUocm93SW5kaWNhdG9yVmFsdWUgJSAzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXJjb2RlQ29sdW1uQ291bnQuc2V0VmFsdWUocm93SW5kaWNhdG9yVmFsdWUgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChjb2Rld29yZHNfMV8xICYmICFjb2Rld29yZHNfMV8xLmRvbmUgJiYgKF9hID0gY29kZXdvcmRzXzEucmV0dXJuKSkgX2EuY2FsbChjb2Rld29yZHNfMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNYXliZSB3ZSBzaG91bGQgY2hlY2sgaWYgd2UgaGF2ZSBhbWJpZ3VvdXMgdmFsdWVzP1xyXG4gICAgICAgIGlmICgoYmFyY29kZUNvbHVtbkNvdW50LmdldFZhbHVlKCkubGVuZ3RoID09PSAwKSB8fFxyXG4gICAgICAgICAgICAoYmFyY29kZVJvd0NvdW50VXBwZXJQYXJ0LmdldFZhbHVlKCkubGVuZ3RoID09PSAwKSB8fFxyXG4gICAgICAgICAgICAoYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LmdldFZhbHVlKCkubGVuZ3RoID09PSAwKSB8fFxyXG4gICAgICAgICAgICAoYmFyY29kZUVDTGV2ZWwuZ2V0VmFsdWUoKS5sZW5ndGggPT09IDApIHx8XHJcbiAgICAgICAgICAgIGJhcmNvZGVDb2x1bW5Db3VudC5nZXRWYWx1ZSgpWzBdIDwgMSB8fFxyXG4gICAgICAgICAgICBiYXJjb2RlUm93Q291bnRVcHBlclBhcnQuZ2V0VmFsdWUoKVswXSArIGJhcmNvZGVSb3dDb3VudExvd2VyUGFydC5nZXRWYWx1ZSgpWzBdIDwgUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5NSU5fUk9XU19JTl9CQVJDT0RFIHx8XHJcbiAgICAgICAgICAgIGJhcmNvZGVSb3dDb3VudFVwcGVyUGFydC5nZXRWYWx1ZSgpWzBdICsgYmFyY29kZVJvd0NvdW50TG93ZXJQYXJ0LmdldFZhbHVlKClbMF0gPiBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1BWF9ST1dTX0lOX0JBUkNPREUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXJjb2RlTWV0YWRhdGEgPSBuZXcgQmFyY29kZU1ldGFkYXRhXzEuZGVmYXVsdChiYXJjb2RlQ29sdW1uQ291bnQuZ2V0VmFsdWUoKVswXSwgYmFyY29kZVJvd0NvdW50VXBwZXJQYXJ0LmdldFZhbHVlKClbMF0sIGJhcmNvZGVSb3dDb3VudExvd2VyUGFydC5nZXRWYWx1ZSgpWzBdLCBiYXJjb2RlRUNMZXZlbC5nZXRWYWx1ZSgpWzBdKTtcclxuICAgICAgICB0aGlzLnJlbW92ZUluY29ycmVjdENvZGV3b3Jkcyhjb2Rld29yZHMsIGJhcmNvZGVNZXRhZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIGJhcmNvZGVNZXRhZGF0YTtcclxuICAgIH07XHJcbiAgICBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4ucHJvdG90eXBlLnJlbW92ZUluY29ycmVjdENvZGV3b3JkcyA9IGZ1bmN0aW9uIChjb2Rld29yZHMsIGJhcmNvZGVNZXRhZGF0YSkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBjb2Rld29yZHMgd2hpY2ggZG8gbm90IG1hdGNoIHRoZSBtZXRhZGF0YVxyXG4gICAgICAgIC8vIFRPRE8gTWF5YmUgd2Ugc2hvdWxkIGtlZXAgdGhlIGluY29ycmVjdCBjb2Rld29yZHMgZm9yIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucz9cclxuICAgICAgICBmb3IgKHZhciBjb2Rld29yZFJvdyAvKmludCovID0gMDsgY29kZXdvcmRSb3cgPCBjb2Rld29yZHMubGVuZ3RoOyBjb2Rld29yZFJvdysrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2Rld29yZCA9IGNvZGV3b3Jkc1tjb2Rld29yZFJvd107XHJcbiAgICAgICAgICAgIGlmIChjb2Rld29yZHNbY29kZXdvcmRSb3ddID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByb3dJbmRpY2F0b3JWYWx1ZSA9IGNvZGV3b3JkLmdldFZhbHVlKCkgJSAzMDtcclxuICAgICAgICAgICAgdmFyIGNvZGV3b3JkUm93TnVtYmVyID0gY29kZXdvcmQuZ2V0Um93TnVtYmVyKCk7XHJcbiAgICAgICAgICAgIGlmIChjb2Rld29yZFJvd051bWJlciA+IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRSb3ddID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICBjb2Rld29yZFJvd051bWJlciArPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZXdvcmRSb3dOdW1iZXIgJSAzKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0luZGljYXRvclZhbHVlICogMyArIDEgIT09IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudFVwcGVyUGFydCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC50cnVuYyhyb3dJbmRpY2F0b3JWYWx1ZSAvIDMpICE9PSBiYXJjb2RlTWV0YWRhdGEuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dJbmRpY2F0b3JWYWx1ZSAlIDMgIT09IGJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudExvd2VyUGFydCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZFJvd10gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAocm93SW5kaWNhdG9yVmFsdWUgKyAxICE9PSBiYXJjb2RlTWV0YWRhdGEuZ2V0Q29sdW1uQ291bnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2Rld29yZHNbY29kZXdvcmRSb3ddID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uLnByb3RvdHlwZS5pc0xlZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzTGVmdDtcclxuICAgIH07XHJcbiAgICAvLyBAT3ZlcnJpZGVcclxuICAgIERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICdJc0xlZnQ6ICcgKyB0aGlzLl9pc0xlZnQgKyAnXFxuJyArIF9zdXBlci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uO1xyXG59KERldGVjdGlvblJlc3VsdENvbHVtbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGV0ZWN0aW9uUmVzdWx0Um93SW5kaWNhdG9yQ29sdW1uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xyXG4qXHJcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5kZWNvZGVyO1xyXG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24uZGV0ZWN0b3IuTWF0aFV0aWxzO1xyXG52YXIgTWF0aFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL2RldGVjdG9yL01hdGhVdGlsc1wiKTtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LlBERjQxN0NvbW1vbjtcclxudmFyIFBERjQxN0NvbW1vbl8xID0gcmVxdWlyZShcIi4uL1BERjQxN0NvbW1vblwiKTtcclxudmFyIEZsb2F0XzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9GbG9hdFwiKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgR3VlbnRoZXIgR3JhdVxyXG4gKiBAYXV0aG9yIGNyZWF0YWxlIEdtYkggKGNocmlzdG9waC5zY2h1bHpAY3JlYXRhbGUuZGUpXHJcbiAqL1xyXG52YXIgUERGNDE3Q29kZXdvcmREZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUERGNDE3Q29kZXdvcmREZWNvZGVyKCkge1xyXG4gICAgfVxyXG4gICAgLyogQG5vdGVcclxuICAgICAqIHRoaXMgYWN0aW9uIGhhdmUgdG8gYmUgcGVyZm9ybWVkIGJlZm9yZSBmaXJzdCB1c2Ugb2YgY2xhc3NcclxuICAgICAqIC0gc3RhdGljIGNvbnN0cnVjdG9yXHJcbiAgICAgKiB3b3JraW5nIHdpdGggMzJiaXQgZmxvYXQgKGJhc2VkIGZyb20gSmF2YSBsb2dpYylcclxuICAgICovXHJcbiAgICBQREY0MTdDb2Rld29yZERlY29kZXIuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBQcmUtY29tcHV0ZXMgdGhlIHN5bWJvbCByYXRpbyB0YWJsZS5cclxuICAgICAgICBmb3IgKCAvKmludCovdmFyIGkgPSAwOyBpIDwgUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5TWU1CT0xfVEFCTEUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTeW1ib2wgPSBQREY0MTdDb21tb25fMS5kZWZhdWx0LlNZTUJPTF9UQUJMRVtpXTtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnRCaXQgPSBjdXJyZW50U3ltYm9sICYgMHgxO1xyXG4gICAgICAgICAgICBmb3IgKCAvKmludCovdmFyIGogPSAwOyBqIDwgUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5CQVJTX0lOX01PRFVMRTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IDAuMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlICgoY3VycmVudFN5bWJvbCAmIDB4MSkgPT09IGN1cnJlbnRCaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaXplICs9IDEuMDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3ltYm9sID4+PSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudEJpdCA9IGN1cnJlbnRTeW1ib2wgJiAweDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoIVBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEVbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBQREY0MTdDb2Rld29yZERlY29kZXIuUkFUSU9TX1RBQkxFW2ldID0gbmV3IEFycmF5KFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuQkFSU19JTl9NT0RVTEUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLlJBVElPU19UQUJMRVtpXVtQREY0MTdDb21tb25fMS5kZWZhdWx0LkJBUlNfSU5fTU9EVUxFIC0gaiAtIDFdID0gTWF0aC5mcm91bmQoc2l6ZSAvIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuTU9EVUxFU19JTl9DT0RFV09SRCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5iU3ltYm9sVGFibGVSZWFkeSA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLmdldERlY29kZWRWYWx1ZSA9IGZ1bmN0aW9uIChtb2R1bGVCaXRDb3VudCkge1xyXG4gICAgICAgIHZhciBkZWNvZGVkVmFsdWUgPSBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0RGVjb2RlZENvZGV3b3JkVmFsdWUoUERGNDE3Q29kZXdvcmREZWNvZGVyLnNhbXBsZUJpdENvdW50cyhtb2R1bGVCaXRDb3VudCkpO1xyXG4gICAgICAgIGlmIChkZWNvZGVkVmFsdWUgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVkVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0Q2xvc2VzdERlY29kZWRWYWx1ZShtb2R1bGVCaXRDb3VudCk7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLnNhbXBsZUJpdENvdW50cyA9IGZ1bmN0aW9uIChtb2R1bGVCaXRDb3VudCkge1xyXG4gICAgICAgIHZhciBiaXRDb3VudFN1bSA9IE1hdGhVdGlsc18xLmRlZmF1bHQuc3VtKG1vZHVsZUJpdENvdW50KTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEludDMyQXJyYXkoUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5CQVJTX0lOX01PRFVMRSk7XHJcbiAgICAgICAgdmFyIGJpdENvdW50SW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBzdW1QcmV2aW91c0JpdHMgPSAwO1xyXG4gICAgICAgIGZvciAoIC8qaW50Ki92YXIgaSA9IDA7IGkgPCBQREY0MTdDb21tb25fMS5kZWZhdWx0Lk1PRFVMRVNfSU5fQ09ERVdPUkQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc2FtcGxlSW5kZXggPSBiaXRDb3VudFN1bSAvICgyICogUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5NT0RVTEVTX0lOX0NPREVXT1JEKSArXHJcbiAgICAgICAgICAgICAgICAoaSAqIGJpdENvdW50U3VtKSAvIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuTU9EVUxFU19JTl9DT0RFV09SRDtcclxuICAgICAgICAgICAgaWYgKHN1bVByZXZpb3VzQml0cyArIG1vZHVsZUJpdENvdW50W2JpdENvdW50SW5kZXhdIDw9IHNhbXBsZUluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBzdW1QcmV2aW91c0JpdHMgKz0gbW9kdWxlQml0Q291bnRbYml0Q291bnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICBiaXRDb3VudEluZGV4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0W2JpdENvdW50SW5kZXhdKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3Q29kZXdvcmREZWNvZGVyLmdldERlY29kZWRDb2Rld29yZFZhbHVlID0gZnVuY3Rpb24gKG1vZHVsZUJpdENvdW50KSB7XHJcbiAgICAgICAgdmFyIGRlY29kZWRWYWx1ZSA9IFBERjQxN0NvZGV3b3JkRGVjb2Rlci5nZXRCaXRWYWx1ZShtb2R1bGVCaXRDb3VudCk7XHJcbiAgICAgICAgcmV0dXJuIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuZ2V0Q29kZXdvcmQoZGVjb2RlZFZhbHVlKSA9PT0gLTEgPyAtMSA6IGRlY29kZWRWYWx1ZTtcclxuICAgIH07XHJcbiAgICBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0Qml0VmFsdWUgPSBmdW5jdGlvbiAobW9kdWxlQml0Q291bnQpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gLypsb25nKi8gMDtcclxuICAgICAgICBmb3IgKHZhciAvKmludCovIGkgPSAwOyBpIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICggLyppbnQqL3ZhciBiaXQgPSAwOyBiaXQgPCBtb2R1bGVCaXRDb3VudFtpXTsgYml0KyspIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IChyZXN1bHQgPDwgMSkgfCAoaSAlIDIgPT09IDAgPyAxIDogMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1hdGgudHJ1bmMocmVzdWx0KTtcclxuICAgIH07XHJcbiAgICAvLyB3b3JraW5nIHdpdGggMzJiaXQgZmxvYXQgKGFzIGluIEphdmEpXHJcbiAgICBQREY0MTdDb2Rld29yZERlY29kZXIuZ2V0Q2xvc2VzdERlY29kZWRWYWx1ZSA9IGZ1bmN0aW9uIChtb2R1bGVCaXRDb3VudCkge1xyXG4gICAgICAgIHZhciBiaXRDb3VudFN1bSA9IE1hdGhVdGlsc18xLmRlZmF1bHQuc3VtKG1vZHVsZUJpdENvdW50KTtcclxuICAgICAgICB2YXIgYml0Q291bnRSYXRpb3MgPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5CQVJTX0lOX01PRFVMRSk7XHJcbiAgICAgICAgaWYgKGJpdENvdW50U3VtID4gMSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciAvKmludCovIGkgPSAwOyBpIDwgYml0Q291bnRSYXRpb3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGJpdENvdW50UmF0aW9zW2ldID0gTWF0aC5mcm91bmQobW9kdWxlQml0Q291bnRbaV0gLyBiaXRDb3VudFN1bSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJlc3RNYXRjaEVycm9yID0gRmxvYXRfMS5kZWZhdWx0Lk1BWF9WQUxVRTtcclxuICAgICAgICB2YXIgYmVzdE1hdGNoID0gLTE7XHJcbiAgICAgICAgaWYgKCF0aGlzLmJTeW1ib2xUYWJsZVJlYWR5KSB7XHJcbiAgICAgICAgICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5pbml0aWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoIC8qaW50Ki92YXIgaiA9IDA7IGogPCBQREY0MTdDb2Rld29yZERlY29kZXIuUkFUSU9TX1RBQkxFLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIHZhciBlcnJvciA9IDAuMDtcclxuICAgICAgICAgICAgdmFyIHJhdGlvVGFibGVSb3cgPSBQREY0MTdDb2Rld29yZERlY29kZXIuUkFUSU9TX1RBQkxFW2pdO1xyXG4gICAgICAgICAgICBmb3IgKCAvKmludCovdmFyIGsgPSAwOyBrIDwgUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5CQVJTX0lOX01PRFVMRTsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGlmZiA9IE1hdGguZnJvdW5kKHJhdGlvVGFibGVSb3dba10gLSBiaXRDb3VudFJhdGlvc1trXSk7XHJcbiAgICAgICAgICAgICAgICBlcnJvciArPSBNYXRoLmZyb3VuZChkaWZmICogZGlmZik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPj0gYmVzdE1hdGNoRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXJyb3IgPCBiZXN0TWF0Y2hFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgYmVzdE1hdGNoRXJyb3IgPSBlcnJvcjtcclxuICAgICAgICAgICAgICAgIGJlc3RNYXRjaCA9IFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuU1lNQk9MX1RBQkxFW2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiZXN0TWF0Y2g7XHJcbiAgICB9O1xyXG4gICAgLy8gZmxhZyB0aGF0IHRoZSB0YWJsZSBpcyByZWFkeSBmb3IgdXNlXHJcbiAgICBQREY0MTdDb2Rld29yZERlY29kZXIuYlN5bWJvbFRhYmxlUmVhZHkgPSBmYWxzZTtcclxuICAgIFBERjQxN0NvZGV3b3JkRGVjb2Rlci5SQVRJT1NfVEFCTEUgPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5TWU1CT0xfVEFCTEUubGVuZ3RoKS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggPSBuZXcgQXJyYXkoUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5CQVJTX0lOX01PRFVMRSk7IH0pO1xyXG4gICAgcmV0dXJuIFBERjQxN0NvZGV3b3JkRGVjb2RlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUERGNDE3Q29kZXdvcmREZWNvZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QREY0MTdDb2Rld29yZERlY29kZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiogQ29weXJpZ2h0IDIwMTMgWlhpbmcgYXV0aG9yc1xyXG4qXHJcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXHJcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gcGFja2FnZSBjb20uZ29vZ2xlLnp4aW5nLnBkZjQxNy5kZWNvZGVyO1xyXG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5DaGVja3N1bUV4Y2VwdGlvbjtcclxudmFyIENoZWNrc3VtRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vQ2hlY2tzdW1FeGNlcHRpb25cIik7XHJcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLkZvcm1hdEV4Y2VwdGlvbjtcclxudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuTm90Rm91bmRFeGNlcHRpb247XHJcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xyXG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5jb21tb24uZGV0ZWN0b3IuTWF0aFV0aWxzO1xyXG52YXIgTWF0aFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL2RldGVjdG9yL01hdGhVdGlsc1wiKTtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LlBERjQxN0NvbW1vbjtcclxudmFyIFBERjQxN0NvbW1vbl8xID0gcmVxdWlyZShcIi4uL1BERjQxN0NvbW1vblwiKTtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXIuZWMuRXJyb3JDb3JyZWN0aW9uO1xyXG52YXIgRXJyb3JDb3JyZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9lYy9FcnJvckNvcnJlY3Rpb25cIik7XHJcbi8vIGxvY2FsXHJcbnZhciBCb3VuZGluZ0JveF8xID0gcmVxdWlyZShcIi4vQm91bmRpbmdCb3hcIik7XHJcbnZhciBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW5fMSA9IHJlcXVpcmUoXCIuL0RldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtblwiKTtcclxudmFyIERldGVjdGlvblJlc3VsdF8xID0gcmVxdWlyZShcIi4vRGV0ZWN0aW9uUmVzdWx0XCIpO1xyXG52YXIgRGV0ZWN0aW9uUmVzdWx0Q29sdW1uXzEgPSByZXF1aXJlKFwiLi9EZXRlY3Rpb25SZXN1bHRDb2x1bW5cIik7XHJcbnZhciBDb2Rld29yZF8xID0gcmVxdWlyZShcIi4vQ29kZXdvcmRcIik7XHJcbnZhciBCYXJjb2RlVmFsdWVfMSA9IHJlcXVpcmUoXCIuL0JhcmNvZGVWYWx1ZVwiKTtcclxudmFyIFBERjQxN0NvZGV3b3JkRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vUERGNDE3Q29kZXdvcmREZWNvZGVyXCIpO1xyXG52YXIgRGVjb2RlZEJpdFN0cmVhbVBhcnNlcl8xID0gcmVxdWlyZShcIi4vRGVjb2RlZEJpdFN0cmVhbVBhcnNlclwiKTtcclxuLy8gdXRpbHNcclxudmFyIEZvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvRm9ybWF0dGVyXCIpO1xyXG4vLyBpbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDtcclxuLy8gaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uO1xyXG4vLyBpbXBvcnQgamF2YS51dGlsLkZvcm1hdHRlcjtcclxuLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xyXG4vKipcclxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XHJcbiAqL1xyXG52YXIgUERGNDE3U2Nhbm5pbmdEZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUERGNDE3U2Nhbm5pbmdEZWNvZGVyKCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAVE9ETyBkb24ndCBwYXNzIGluIG1pbkNvZGV3b3JkV2lkdGggYW5kIG1heENvZGV3b3JkV2lkdGgsIHBhc3MgaW4gYmFyY29kZSBjb2x1bW5zIGZvciBzdGFydCBhbmQgc3RvcCBwYXR0ZXJuXHJcbiAgICAgKlxyXG4gICAgICogY29sdW1ucy4gVGhhdCB3YXkgd2lkdGggY2FuIGJlIGRlZHVjdGVkIGZyb20gdGhlIHBhdHRlcm4gY29sdW1uLlxyXG4gICAgICogVGhpcyBhcHByb2FjaCBhbHNvIGFsbG93cyB0byBkZXRlY3QgbW9yZSBkZXRhaWxzIGFib3V0IHRoZSBiYXJjb2RlLCBlLmcuIGlmIGEgYmFyIHR5cGUgKHdoaXRlIG9yIGJsYWNrKSBpcyB3aWRlclxyXG4gICAgICogdGhhbiBpdCBzaG91bGQgYmUuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgc2Nhbm5lciB1c2VkIGEgYmFkIGJsYWNrcG9pbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIEJpdE1hdHJpeFxyXG4gICAgICogQHBhcmFtIGltYWdlXHJcbiAgICAgKiBAcGFyYW0gUmVzdWx0UG9pbnRcclxuICAgICAqIEBwYXJhbSBpbWFnZVRvcExlZnRcclxuICAgICAqIEBwYXJhbSBSZXN1bHRQb2ludFxyXG4gICAgICogQHBhcmFtIGltYWdlQm90dG9tTGVmdFxyXG4gICAgICogQHBhcmFtIFJlc3VsdFBvaW50XHJcbiAgICAgKiBAcGFyYW0gaW1hZ2VUb3BSaWdodFxyXG4gICAgICogQHBhcmFtIFJlc3VsdFBvaW50XHJcbiAgICAgKiBAcGFyYW0gaW1hZ2VCb3R0b21SaWdodFxyXG4gICAgICogQHBhcmFtIGludFxyXG4gICAgICogQHBhcmFtIG1pbkNvZGV3b3JkV2lkdGhcclxuICAgICAqIEBwYXJhbSBpbnRcclxuICAgICAqIEBwYXJhbSBtYXhDb2Rld29yZFdpZHRoXHJcbiAgICAgKlxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cclxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmRlY29kZSA9IGZ1bmN0aW9uIChpbWFnZSwgaW1hZ2VUb3BMZWZ0LCBpbWFnZUJvdHRvbUxlZnQsIGltYWdlVG9wUmlnaHQsIGltYWdlQm90dG9tUmlnaHQsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcclxuICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBuZXcgQm91bmRpbmdCb3hfMS5kZWZhdWx0KGltYWdlLCBpbWFnZVRvcExlZnQsIGltYWdlQm90dG9tTGVmdCwgaW1hZ2VUb3BSaWdodCwgaW1hZ2VCb3R0b21SaWdodCk7XHJcbiAgICAgICAgdmFyIGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4gPSBudWxsO1xyXG4gICAgICAgIHZhciByaWdodFJvd0luZGljYXRvckNvbHVtbiA9IG51bGw7XHJcbiAgICAgICAgdmFyIGRldGVjdGlvblJlc3VsdDtcclxuICAgICAgICBmb3IgKHZhciBmaXJzdFBhc3MgLypib29sZWFuKi8gPSB0cnVlOzsgZmlyc3RQYXNzID0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaWYgKGltYWdlVG9wTGVmdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Um93SW5kaWNhdG9yQ29sdW1uID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldFJvd0luZGljYXRvckNvbHVtbihpbWFnZSwgYm91bmRpbmdCb3gsIGltYWdlVG9wTGVmdCwgdHJ1ZSwgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGltYWdlVG9wUmlnaHQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4gPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Um93SW5kaWNhdG9yQ29sdW1uKGltYWdlLCBib3VuZGluZ0JveCwgaW1hZ2VUb3BSaWdodCwgZmFsc2UsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5tZXJnZShsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbik7XHJcbiAgICAgICAgICAgIGlmIChkZXRlY3Rpb25SZXN1bHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0LmdldE5vdEZvdW5kSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVzdWx0Qm94ID0gZGV0ZWN0aW9uUmVzdWx0LmdldEJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgICAgIGlmIChmaXJzdFBhc3MgJiYgcmVzdWx0Qm94ICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIChyZXN1bHRCb3guZ2V0TWluWSgpIDwgYm91bmRpbmdCb3guZ2V0TWluWSgpIHx8IHJlc3VsdEJveC5nZXRNYXhZKCkgPiBib3VuZGluZ0JveC5nZXRNYXhZKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ0JveCA9IHJlc3VsdEJveDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRldGVjdGlvblJlc3VsdC5zZXRCb3VuZGluZ0JveChib3VuZGluZ0JveCk7XHJcbiAgICAgICAgdmFyIG1heEJhcmNvZGVDb2x1bW4gPSBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKyAxO1xyXG4gICAgICAgIGRldGVjdGlvblJlc3VsdC5zZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oMCwgbGVmdFJvd0luZGljYXRvckNvbHVtbik7XHJcbiAgICAgICAgZGV0ZWN0aW9uUmVzdWx0LnNldERldGVjdGlvblJlc3VsdENvbHVtbihtYXhCYXJjb2RlQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbik7XHJcbiAgICAgICAgdmFyIGxlZnRUb1JpZ2h0ID0gbGVmdFJvd0luZGljYXRvckNvbHVtbiAhPSBudWxsO1xyXG4gICAgICAgIGZvciAodmFyIGJhcmNvZGVDb2x1bW5Db3VudCAvKmludCovID0gMTsgYmFyY29kZUNvbHVtbkNvdW50IDw9IG1heEJhcmNvZGVDb2x1bW47IGJhcmNvZGVDb2x1bW5Db3VudCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXJjb2RlQ29sdW1uID0gbGVmdFRvUmlnaHQgPyBiYXJjb2RlQ29sdW1uQ291bnQgOiBtYXhCYXJjb2RlQ29sdW1uIC0gYmFyY29kZUNvbHVtbkNvdW50O1xyXG4gICAgICAgICAgICBpZiAoZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uKSAhPT0gLyogbnVsbCAqLyB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgY2FzZSBmb3IgdGhlIG9wcG9zaXRlIHJvdyBpbmRpY2F0b3IgY29sdW1uLCB3aGljaCBkb2Vzbid0IG5lZWQgdG8gYmUgZGVjb2RlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBkZXRlY3Rpb25SZXN1bHRDb2x1bW4gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGlmIChiYXJjb2RlQ29sdW1uID09PSAwIHx8IGJhcmNvZGVDb2x1bW4gPT09IG1heEJhcmNvZGVDb2x1bW4pIHtcclxuICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdENvbHVtbiA9IG5ldyBEZXRlY3Rpb25SZXN1bHRSb3dJbmRpY2F0b3JDb2x1bW5fMS5kZWZhdWx0KGJvdW5kaW5nQm94LCBiYXJjb2RlQ29sdW1uID09PSAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdENvbHVtbiA9IG5ldyBEZXRlY3Rpb25SZXN1bHRDb2x1bW5fMS5kZWZhdWx0KGJvdW5kaW5nQm94KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZXRlY3Rpb25SZXN1bHQuc2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4sIGRldGVjdGlvblJlc3VsdENvbHVtbik7XHJcbiAgICAgICAgICAgIHZhciBzdGFydENvbHVtbiA9IC0xO1xyXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTdGFydENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xyXG4gICAgICAgICAgICAvLyBUT0RPIHN0YXJ0IGF0IGEgcm93IGZvciB3aGljaCB3ZSBrbm93IHRoZSBzdGFydCBwb3NpdGlvbiwgdGhlbiBkZXRlY3QgdXB3YXJkcyBhbmQgZG93bndhcmRzIGZyb20gdGhlcmUuXHJcbiAgICAgICAgICAgIGZvciAodmFyIGltYWdlUm93IC8qaW50Ki8gPSBib3VuZGluZ0JveC5nZXRNaW5ZKCk7IGltYWdlUm93IDw9IGJvdW5kaW5nQm94LmdldE1heFkoKTsgaW1hZ2VSb3crKykge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0U3RhcnRDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uLCBpbWFnZVJvdywgbGVmdFRvUmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0Q29sdW1uIDwgMCB8fCBzdGFydENvbHVtbiA+IGJvdW5kaW5nQm94LmdldE1heFgoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c1N0YXJ0Q29sdW1uID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBwcmV2aW91c1N0YXJ0Q29sdW1uO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGNvZGV3b3JkID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmRldGVjdENvZGV3b3JkKGltYWdlLCBib3VuZGluZ0JveC5nZXRNaW5YKCksIGJvdW5kaW5nQm94LmdldE1heFgoKSwgbGVmdFRvUmlnaHQsIHN0YXJ0Q29sdW1uLCBpbWFnZVJvdywgbWluQ29kZXdvcmRXaWR0aCwgbWF4Q29kZXdvcmRXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRldGVjdGlvblJlc3VsdENvbHVtbi5zZXRDb2Rld29yZChpbWFnZVJvdywgY29kZXdvcmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzU3RhcnRDb2x1bW4gPSBzdGFydENvbHVtbjtcclxuICAgICAgICAgICAgICAgICAgICBtaW5Db2Rld29yZFdpZHRoID0gTWF0aC5taW4obWluQ29kZXdvcmRXaWR0aCwgY29kZXdvcmQuZ2V0V2lkdGgoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4Q29kZXdvcmRXaWR0aCA9IE1hdGgubWF4KG1heENvZGV3b3JkV2lkdGgsIGNvZGV3b3JkLmdldFdpZHRoKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQREY0MTdTY2FubmluZ0RlY29kZXIuY3JlYXRlRGVjb2RlclJlc3VsdChkZXRlY3Rpb25SZXN1bHQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBsZWZ0Um93SW5kaWNhdG9yQ29sdW1uXHJcbiAgICAgKiBAcGFyYW0gcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW5cclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXHJcbiAgICAgKi9cclxuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5tZXJnZSA9IGZ1bmN0aW9uIChsZWZ0Um93SW5kaWNhdG9yQ29sdW1uLCByaWdodFJvd0luZGljYXRvckNvbHVtbikge1xyXG4gICAgICAgIGlmIChsZWZ0Um93SW5kaWNhdG9yQ29sdW1uID09IG51bGwgJiYgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJhcmNvZGVNZXRhZGF0YSA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRCYXJjb2RlTWV0YWRhdGEobGVmdFJvd0luZGljYXRvckNvbHVtbiwgcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4pO1xyXG4gICAgICAgIGlmIChiYXJjb2RlTWV0YWRhdGEgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gQm91bmRpbmdCb3hfMS5kZWZhdWx0Lm1lcmdlKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5hZGp1c3RCb3VuZGluZ0JveChsZWZ0Um93SW5kaWNhdG9yQ29sdW1uKSwgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmFkanVzdEJvdW5kaW5nQm94KHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZXRlY3Rpb25SZXN1bHRfMS5kZWZhdWx0KGJhcmNvZGVNZXRhZGF0YSwgYm91bmRpbmdCb3gpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByb3dJbmRpY2F0b3JDb2x1bW5cclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uXHJcbiAgICAgKi9cclxuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5hZGp1c3RCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChyb3dJbmRpY2F0b3JDb2x1bW4pIHtcclxuICAgICAgICB2YXIgZV8xLCBfYTtcclxuICAgICAgICBpZiAocm93SW5kaWNhdG9yQ29sdW1uID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByb3dIZWlnaHRzID0gcm93SW5kaWNhdG9yQ29sdW1uLmdldFJvd0hlaWdodHMoKTtcclxuICAgICAgICBpZiAocm93SGVpZ2h0cyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF4Um93SGVpZ2h0ID0gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldE1heChyb3dIZWlnaHRzKTtcclxuICAgICAgICB2YXIgbWlzc2luZ1N0YXJ0Um93cyA9IDA7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcm93SGVpZ2h0c18xID0gX192YWx1ZXMocm93SGVpZ2h0cyksIHJvd0hlaWdodHNfMV8xID0gcm93SGVpZ2h0c18xLm5leHQoKTsgIXJvd0hlaWdodHNfMV8xLmRvbmU7IHJvd0hlaWdodHNfMV8xID0gcm93SGVpZ2h0c18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvd0hlaWdodCA9IHJvd0hlaWdodHNfMV8xLnZhbHVlIC8qaW50Ki87XHJcbiAgICAgICAgICAgICAgICBtaXNzaW5nU3RhcnRSb3dzICs9IG1heFJvd0hlaWdodCAtIHJvd0hlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmIChyb3dIZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChyb3dIZWlnaHRzXzFfMSAmJiAhcm93SGVpZ2h0c18xXzEuZG9uZSAmJiAoX2EgPSByb3dIZWlnaHRzXzEucmV0dXJuKSkgX2EuY2FsbChyb3dIZWlnaHRzXzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvZGV3b3JkcyA9IHJvd0luZGljYXRvckNvbHVtbi5nZXRDb2Rld29yZHMoKTtcclxuICAgICAgICBmb3IgKHZhciByb3cgLyppbnQqLyA9IDA7IG1pc3NpbmdTdGFydFJvd3MgPiAwICYmIGNvZGV3b3Jkc1tyb3ddID09IG51bGw7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIG1pc3NpbmdTdGFydFJvd3MtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1pc3NpbmdFbmRSb3dzID0gMDtcclxuICAgICAgICBmb3IgKHZhciByb3cgLyppbnQqLyA9IHJvd0hlaWdodHMubGVuZ3RoIC0gMTsgcm93ID49IDA7IHJvdy0tKSB7XHJcbiAgICAgICAgICAgIG1pc3NpbmdFbmRSb3dzICs9IG1heFJvd0hlaWdodCAtIHJvd0hlaWdodHNbcm93XTtcclxuICAgICAgICAgICAgaWYgKHJvd0hlaWdodHNbcm93XSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIHJvdyAvKmludCovID0gY29kZXdvcmRzLmxlbmd0aCAtIDE7IG1pc3NpbmdFbmRSb3dzID4gMCAmJiBjb2Rld29yZHNbcm93XSA9PSBudWxsOyByb3ctLSkge1xyXG4gICAgICAgICAgICBtaXNzaW5nRW5kUm93cy0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm93SW5kaWNhdG9yQ29sdW1uLmdldEJvdW5kaW5nQm94KCkuYWRkTWlzc2luZ1Jvd3MobWlzc2luZ1N0YXJ0Um93cywgbWlzc2luZ0VuZFJvd3MsIHJvd0luZGljYXRvckNvbHVtbi5pc0xlZnQoKSk7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldE1heCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcclxuICAgICAgICB2YXIgZV8yLCBfYTtcclxuICAgICAgICB2YXIgbWF4VmFsdWUgPSAtMTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB2YWx1ZXNfMSA9IF9fdmFsdWVzKHZhbHVlcyksIHZhbHVlc18xXzEgPSB2YWx1ZXNfMS5uZXh0KCk7ICF2YWx1ZXNfMV8xLmRvbmU7IHZhbHVlc18xXzEgPSB2YWx1ZXNfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc18xXzEudmFsdWUgLyppbnQqLztcclxuICAgICAgICAgICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXgobWF4VmFsdWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc18xXzEgJiYgIXZhbHVlc18xXzEuZG9uZSAmJiAoX2EgPSB2YWx1ZXNfMS5yZXR1cm4pKSBfYS5jYWxsKHZhbHVlc18xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXhWYWx1ZTtcclxuICAgIH07XHJcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0QmFyY29kZU1ldGFkYXRhID0gZnVuY3Rpb24gKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4sIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uKSB7XHJcbiAgICAgICAgdmFyIGxlZnRCYXJjb2RlTWV0YWRhdGE7XHJcbiAgICAgICAgaWYgKGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAobGVmdEJhcmNvZGVNZXRhZGF0YSA9IGxlZnRSb3dJbmRpY2F0b3JDb2x1bW4uZ2V0QmFyY29kZU1ldGFkYXRhKCkpID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0Um93SW5kaWNhdG9yQ29sdW1uID09IG51bGwgPyBudWxsIDogcmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4uZ2V0QmFyY29kZU1ldGFkYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByaWdodEJhcmNvZGVNZXRhZGF0YTtcclxuICAgICAgICBpZiAocmlnaHRSb3dJbmRpY2F0b3JDb2x1bW4gPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAocmlnaHRCYXJjb2RlTWV0YWRhdGEgPSByaWdodFJvd0luZGljYXRvckNvbHVtbi5nZXRCYXJjb2RlTWV0YWRhdGEoKSkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdEJhcmNvZGVNZXRhZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxlZnRCYXJjb2RlTWV0YWRhdGEuZ2V0Q29sdW1uQ291bnQoKSAhPT0gcmlnaHRCYXJjb2RlTWV0YWRhdGEuZ2V0Q29sdW1uQ291bnQoKSAmJlxyXG4gICAgICAgICAgICBsZWZ0QmFyY29kZU1ldGFkYXRhLmdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkgIT09IHJpZ2h0QmFyY29kZU1ldGFkYXRhLmdldEVycm9yQ29ycmVjdGlvbkxldmVsKCkgJiZcclxuICAgICAgICAgICAgbGVmdEJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpICE9PSByaWdodEJhcmNvZGVNZXRhZGF0YS5nZXRSb3dDb3VudCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGVmdEJhcmNvZGVNZXRhZGF0YTtcclxuICAgIH07XHJcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Um93SW5kaWNhdG9yQ29sdW1uID0gZnVuY3Rpb24gKGltYWdlLCBib3VuZGluZ0JveCwgc3RhcnRQb2ludCwgbGVmdFRvUmlnaHQsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcclxuICAgICAgICB2YXIgcm93SW5kaWNhdG9yQ29sdW1uID0gbmV3IERldGVjdGlvblJlc3VsdFJvd0luZGljYXRvckNvbHVtbl8xLmRlZmF1bHQoYm91bmRpbmdCb3gsIGxlZnRUb1JpZ2h0KTtcclxuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmNyZW1lbnQgPSBpID09PSAwID8gMSA6IC0xO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRDb2x1bW4gPSBNYXRoLnRydW5jKE1hdGgudHJ1bmMoc3RhcnRQb2ludC5nZXRYKCkpKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaW1hZ2VSb3cgLyppbnQqLyA9IE1hdGgudHJ1bmMoTWF0aC50cnVuYyhzdGFydFBvaW50LmdldFkoKSkpOyBpbWFnZVJvdyA8PSBib3VuZGluZ0JveC5nZXRNYXhZKCkgJiZcclxuICAgICAgICAgICAgICAgIGltYWdlUm93ID49IGJvdW5kaW5nQm94LmdldE1pblkoKTsgaW1hZ2VSb3cgKz0gaW5jcmVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY29kZXdvcmQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuZGV0ZWN0Q29kZXdvcmQoaW1hZ2UsIDAsIGltYWdlLmdldFdpZHRoKCksIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3csIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGV3b3JkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICByb3dJbmRpY2F0b3JDb2x1bW4uc2V0Q29kZXdvcmQoaW1hZ2VSb3csIGNvZGV3b3JkKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFRvUmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBjb2Rld29yZC5nZXRTdGFydFgoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gY29kZXdvcmQuZ2V0RW5kWCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcm93SW5kaWNhdG9yQ29sdW1uO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkZXRlY3Rpb25SZXN1bHRcclxuICAgICAqIEBwYXJhbSBCYXJjb2RlVmFsdWVcclxuICAgICAqIEBwYXJhbSBwYXJhbTJcclxuICAgICAqIEBwYXJhbSBwYXJhbTNcclxuICAgICAqIEBwYXJhbSBiYXJjb2RlTWF0cml4XHJcbiAgICAgKlxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxyXG4gICAgICovXHJcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuYWRqdXN0Q29kZXdvcmRDb3VudCA9IGZ1bmN0aW9uIChkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVNYXRyaXgpIHtcclxuICAgICAgICB2YXIgYmFyY29kZU1hdHJpeDAxID0gYmFyY29kZU1hdHJpeFswXVsxXTtcclxuICAgICAgICB2YXIgbnVtYmVyT2ZDb2Rld29yZHMgPSBiYXJjb2RlTWF0cml4MDEuZ2V0VmFsdWUoKTtcclxuICAgICAgICB2YXIgY2FsY3VsYXRlZE51bWJlck9mQ29kZXdvcmRzID0gZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICpcclxuICAgICAgICAgICAgZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpIC1cclxuICAgICAgICAgICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldE51bWJlck9mRUNDb2RlV29yZHMoZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVFQ0xldmVsKCkpO1xyXG4gICAgICAgIGlmIChudW1iZXJPZkNvZGV3b3Jkcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3JkcyA8IDEgfHwgY2FsY3VsYXRlZE51bWJlck9mQ29kZXdvcmRzID4gUERGNDE3Q29tbW9uXzEuZGVmYXVsdC5NQVhfQ09ERVdPUkRTX0lOX0JBUkNPREUpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdC5nZXROb3RGb3VuZEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmFyY29kZU1hdHJpeDAxLnNldFZhbHVlKGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3Jkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG51bWJlck9mQ29kZXdvcmRzWzBdICE9PSBjYWxjdWxhdGVkTnVtYmVyT2ZDb2Rld29yZHMpIHtcclxuICAgICAgICAgICAgLy8gVGhlIGNhbGN1bGF0ZWQgb25lIGlzIG1vcmUgcmVsaWFibGUgYXMgaXQgaXMgZGVyaXZlZCBmcm9tIHRoZSByb3cgaW5kaWNhdG9yIGNvbHVtbnNcclxuICAgICAgICAgICAgYmFyY29kZU1hdHJpeDAxLnNldFZhbHVlKGNhbGN1bGF0ZWROdW1iZXJPZkNvZGV3b3Jkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkZXRlY3Rpb25SZXN1bHRcclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxyXG4gICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvblxyXG4gICAgICovXHJcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuY3JlYXRlRGVjb2RlclJlc3VsdCA9IGZ1bmN0aW9uIChkZXRlY3Rpb25SZXN1bHQpIHtcclxuICAgICAgICB2YXIgYmFyY29kZU1hdHJpeCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5jcmVhdGVCYXJjb2RlTWF0cml4KGRldGVjdGlvblJlc3VsdCk7XHJcbiAgICAgICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmFkanVzdENvZGV3b3JkQ291bnQoZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlTWF0cml4KTtcclxuICAgICAgICB2YXIgZXJhc3VyZXMgLypDb2xsZWN0aW9uPEludGVnZXI+Ki8gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB2YXIgY29kZXdvcmRzID0gbmV3IEludDMyQXJyYXkoZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpICogZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpKTtcclxuICAgICAgICB2YXIgYW1iaWd1b3VzSW5kZXhWYWx1ZXNMaXN0ID0gLypMaXN0PGludFtdPiovIFtdO1xyXG4gICAgICAgIHZhciBhbWJpZ3VvdXNJbmRleGVzTGlzdCA9IC8qQ29sbGVjdGlvbjxJbnRlZ2VyPiovIG5ldyBBcnJheSgpO1xyXG4gICAgICAgIGZvciAodmFyIHJvdyAvKmludCovID0gMDsgcm93IDwgZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpOyByb3crKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBjb2x1bW4gLyppbnQqLyA9IDA7IGNvbHVtbiA8IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlQ29sdW1uQ291bnQoKTsgY29sdW1uKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBiYXJjb2RlTWF0cml4W3Jvd11bY29sdW1uICsgMV0uZ2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBjb2Rld29yZEluZGV4ID0gcm93ICogZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICsgY29sdW1uO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBlcmFzdXJlcy5wdXNoKGNvZGV3b3JkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1tjb2Rld29yZEluZGV4XSA9IHZhbHVlc1swXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFtYmlndW91c0luZGV4ZXNMaXN0LnB1c2goY29kZXdvcmRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYW1iaWd1b3VzSW5kZXhWYWx1ZXNMaXN0LnB1c2godmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYW1iaWd1b3VzSW5kZXhWYWx1ZXMgPSBuZXcgQXJyYXkoYW1iaWd1b3VzSW5kZXhWYWx1ZXNMaXN0Lmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IGFtYmlndW91c0luZGV4VmFsdWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFtYmlndW91c0luZGV4VmFsdWVzW2ldID0gYW1iaWd1b3VzSW5kZXhWYWx1ZXNMaXN0W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNyZWF0ZURlY29kZXJSZXN1bHRGcm9tQW1iaWd1b3VzVmFsdWVzKGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlRUNMZXZlbCgpLCBjb2Rld29yZHMsIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQudG9JbnRBcnJheShlcmFzdXJlcyksIFBERjQxN0NvbW1vbl8xLmRlZmF1bHQudG9JbnRBcnJheShhbWJpZ3VvdXNJbmRleGVzTGlzdCksIGFtYmlndW91c0luZGV4VmFsdWVzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGRlYWxzIHdpdGggdGhlIGZhY3QsIHRoYXQgdGhlIGRlY29kaW5nIHByb2Nlc3MgZG9lc24ndCBhbHdheXMgeWllbGQgYSBzaW5nbGUgbW9zdCBsaWtlbHkgdmFsdWUuIFRoZVxyXG4gICAgICogY3VycmVudCBlcnJvciBjb3JyZWN0aW9uIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgZGVhbCB3aXRoIGVyYXN1cmVzIHZlcnkgd2VsbCwgc28gaXQncyBiZXR0ZXIgdG8gcHJvdmlkZSBhIHZhbHVlXHJcbiAgICAgKiBmb3IgdGhlc2UgYW1iaWd1b3VzIGNvZGV3b3JkcyBpbnN0ZWFkIG9mIHRyZWF0aW5nIGl0IGFzIGFuIGVyYXN1cmUuIFRoZSBwcm9ibGVtIGlzIHRoYXQgd2UgZG9uJ3Qga25vdyB3aGljaCBvZlxyXG4gICAgICogdGhlIGFtYmlndW91cyB2YWx1ZXMgdG8gY2hvb3NlLiBXZSB0cnkgZGVjb2RlIHVzaW5nIHRoZSBmaXJzdCB2YWx1ZSwgYW5kIGlmIHRoYXQgZmFpbHMsIHdlIHVzZSBhbm90aGVyIG9mIHRoZVxyXG4gICAgICogYW1iaWd1b3VzIHZhbHVlcyBhbmQgdHJ5IHRvIGRlY29kZSBhZ2Fpbi4gVGhpcyB1c3VhbGx5IG9ubHkgaGFwcGVucyBvbiB2ZXJ5IGhhcmQgdG8gcmVhZCBhbmQgZGVjb2RlIGJhcmNvZGVzLFxyXG4gICAgICogc28gZGVjb2RpbmcgdGhlIG5vcm1hbCBiYXJjb2RlcyBpcyBub3QgYWZmZWN0ZWQgYnkgdGhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXJhc3VyZUFycmF5IGNvbnRhaW5zIHRoZSBpbmRleGVzIG9mIGVyYXN1cmVzXHJcbiAgICAgKiBAcGFyYW0gYW1iaWd1b3VzSW5kZXhlcyBhcnJheSB3aXRoIHRoZSBpbmRleGVzIHRoYXQgaGF2ZSBtb3JlIHRoYW4gb25lIG1vc3QgbGlrZWx5IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gYW1iaWd1b3VzSW5kZXhWYWx1ZXMgdHdvIGRpbWVuc2lvbmFsIGFycmF5IHRoYXQgY29udGFpbnMgdGhlIGFtYmlndW91cyB2YWx1ZXMuIFRoZSBmaXJzdCBkaW1lbnNpb24gbXVzdFxyXG4gICAgICogYmUgdGhlIHNhbWUgbGVuZ3RoIGFzIHRoZSBhbWJpZ3VvdXNJbmRleGVzIGFycmF5XHJcbiAgICAgKlxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb25cclxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNyZWF0ZURlY29kZXJSZXN1bHRGcm9tQW1iaWd1b3VzVmFsdWVzID0gZnVuY3Rpb24gKGVjTGV2ZWwsIGNvZGV3b3JkcywgZXJhc3VyZUFycmF5LCBhbWJpZ3VvdXNJbmRleGVzLCBhbWJpZ3VvdXNJbmRleFZhbHVlcykge1xyXG4gICAgICAgIHZhciBhbWJpZ3VvdXNJbmRleENvdW50ID0gbmV3IEludDMyQXJyYXkoYW1iaWd1b3VzSW5kZXhlcy5sZW5ndGgpO1xyXG4gICAgICAgIHZhciB0cmllcyA9IDEwMDtcclxuICAgICAgICB3aGlsZSAodHJpZXMtLSA+IDApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IGFtYmlndW91c0luZGV4Q291bnQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvZGV3b3Jkc1thbWJpZ3VvdXNJbmRleGVzW2ldXSA9IGFtYmlndW91c0luZGV4VmFsdWVzW2ldW2FtYmlndW91c0luZGV4Q291bnRbaV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmRlY29kZUNvZGV3b3Jkcyhjb2Rld29yZHMsIGVjTGV2ZWwsIGVyYXN1cmVBcnJheSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlnbm9yZWQgPSBlcnIgaW5zdGFuY2VvZiBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlnbm9yZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFtYmlndW91c0luZGV4Q291bnQubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBDaGVja3N1bUV4Y2VwdGlvbl8xLmRlZmF1bHQuZ2V0Q2hlY2tzdW1JbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7IGkgPCBhbWJpZ3VvdXNJbmRleENvdW50Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW1iaWd1b3VzSW5kZXhDb3VudFtpXSA8IGFtYmlndW91c0luZGV4VmFsdWVzW2ldLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXNJbmRleENvdW50W2ldKys7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXNJbmRleENvdW50W2ldID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gYW1iaWd1b3VzSW5kZXhDb3VudC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRDaGVja3N1bUluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRDaGVja3N1bUluc3RhbmNlKCk7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNyZWF0ZUJhcmNvZGVNYXRyaXggPSBmdW5jdGlvbiAoZGV0ZWN0aW9uUmVzdWx0KSB7XHJcbiAgICAgICAgdmFyIGVfMywgX2EsIGVfNCwgX2I7XHJcbiAgICAgICAgLy8gbGV0IGJhcmNvZGVNYXRyaXg6IEJhcmNvZGVWYWx1ZVtdW10gPVxyXG4gICAgICAgIC8vIG5ldyBCYXJjb2RlVmFsdWVbZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVSb3dDb3VudCgpXVtkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKyAyXTtcclxuICAgICAgICB2YXIgYmFyY29kZU1hdHJpeCA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGRldGVjdGlvblJlc3VsdC5nZXRCYXJjb2RlUm93Q291bnQoKSB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQXJyYXkoZGV0ZWN0aW9uUmVzdWx0LmdldEJhcmNvZGVDb2x1bW5Db3VudCgpICsgMik7IH0pO1xyXG4gICAgICAgIGZvciAodmFyIHJvdyAvKmludCovID0gMDsgcm93IDwgYmFyY29kZU1hdHJpeC5sZW5ndGg7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbl8xIC8qaW50Ki8gPSAwOyBjb2x1bW5fMSA8IGJhcmNvZGVNYXRyaXhbcm93XS5sZW5ndGg7IGNvbHVtbl8xKyspIHtcclxuICAgICAgICAgICAgICAgIGJhcmNvZGVNYXRyaXhbcm93XVtjb2x1bW5fMV0gPSBuZXcgQmFyY29kZVZhbHVlXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb2x1bW4gPSAwO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMoZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbnMoKSksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZXRlY3Rpb25SZXN1bHRDb2x1bW4gPSBfZC52YWx1ZSAvKkRldGVjdGlvblJlc3VsdENvbHVtbiovO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRldGVjdGlvblJlc3VsdENvbHVtbiAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2UgPSBfX3ZhbHVlcyhkZXRlY3Rpb25SZXN1bHRDb2x1bW4uZ2V0Q29kZXdvcmRzKCkpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZXdvcmQgPSBfZi52YWx1ZSAvKkNvZGV3b3JkKi87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3dOdW1iZXIgPSBjb2Rld29yZC5nZXRSb3dOdW1iZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm93TnVtYmVyID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd051bWJlciA+PSBiYXJjb2RlTWF0cml4Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBtb3JlIHJvd3MgdGhhbiB0aGUgYmFyY29kZSBtZXRhZGF0YSBhbGxvd3MgZm9yLCBpZ25vcmUgdGhlbS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhcmNvZGVNYXRyaXhbcm93TnVtYmVyXVtjb2x1bW5dLnNldFZhbHVlKGNvZGV3b3JkLmdldFZhbHVlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJhcmNvZGVNYXRyaXg7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmlzVmFsaWRCYXJjb2RlQ29sdW1uID0gZnVuY3Rpb24gKGRldGVjdGlvblJlc3VsdCwgYmFyY29kZUNvbHVtbikge1xyXG4gICAgICAgIHJldHVybiBiYXJjb2RlQ29sdW1uID49IDAgJiYgYmFyY29kZUNvbHVtbiA8PSBkZXRlY3Rpb25SZXN1bHQuZ2V0QmFyY29kZUNvbHVtbkNvdW50KCkgKyAxO1xyXG4gICAgfTtcclxuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRTdGFydENvbHVtbiA9IGZ1bmN0aW9uIChkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4sIGltYWdlUm93LCBsZWZ0VG9SaWdodCkge1xyXG4gICAgICAgIHZhciBlXzUsIF9hO1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSBsZWZ0VG9SaWdodCA/IDEgOiAtMTtcclxuICAgICAgICB2YXIgY29kZXdvcmQgPSBudWxsO1xyXG4gICAgICAgIGlmIChQREY0MTdTY2FubmluZ0RlY29kZXIuaXNWYWxpZEJhcmNvZGVDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uIC0gb2Zmc2V0KSkge1xyXG4gICAgICAgICAgICBjb2Rld29yZCA9IGRldGVjdGlvblJlc3VsdC5nZXREZXRlY3Rpb25SZXN1bHRDb2x1bW4oYmFyY29kZUNvbHVtbiAtIG9mZnNldCkuZ2V0Q29kZXdvcmQoaW1hZ2VSb3cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFRvUmlnaHQgPyBjb2Rld29yZC5nZXRFbmRYKCkgOiBjb2Rld29yZC5nZXRTdGFydFgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29kZXdvcmQgPSBkZXRlY3Rpb25SZXN1bHQuZ2V0RGV0ZWN0aW9uUmVzdWx0Q29sdW1uKGJhcmNvZGVDb2x1bW4pLmdldENvZGV3b3JkTmVhcmJ5KGltYWdlUm93KTtcclxuICAgICAgICBpZiAoY29kZXdvcmQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFRvUmlnaHQgPyBjb2Rld29yZC5nZXRTdGFydFgoKSA6IGNvZGV3b3JkLmdldEVuZFgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFBERjQxN1NjYW5uaW5nRGVjb2Rlci5pc1ZhbGlkQmFyY29kZUNvbHVtbihkZXRlY3Rpb25SZXN1bHQsIGJhcmNvZGVDb2x1bW4gLSBvZmZzZXQpKSB7XHJcbiAgICAgICAgICAgIGNvZGV3b3JkID0gZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uIC0gb2Zmc2V0KS5nZXRDb2Rld29yZE5lYXJieShpbWFnZVJvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2Rld29yZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsZWZ0VG9SaWdodCA/IGNvZGV3b3JkLmdldEVuZFgoKSA6IGNvZGV3b3JkLmdldFN0YXJ0WCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2tpcHBlZENvbHVtbnMgPSAwO1xyXG4gICAgICAgIHdoaWxlIChQREY0MTdTY2FubmluZ0RlY29kZXIuaXNWYWxpZEJhcmNvZGVDb2x1bW4oZGV0ZWN0aW9uUmVzdWx0LCBiYXJjb2RlQ29sdW1uIC0gb2Zmc2V0KSkge1xyXG4gICAgICAgICAgICBiYXJjb2RlQ29sdW1uIC09IG9mZnNldDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoZGV0ZWN0aW9uUmVzdWx0LmdldERldGVjdGlvblJlc3VsdENvbHVtbihiYXJjb2RlQ29sdW1uKS5nZXRDb2Rld29yZHMoKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNSb3dDb2Rld29yZCA9IF9jLnZhbHVlIC8qQ29kZXdvcmQqLztcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNSb3dDb2Rld29yZCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAobGVmdFRvUmlnaHQgPyBwcmV2aW91c1Jvd0NvZGV3b3JkLmdldEVuZFgoKSA6IHByZXZpb3VzUm93Q29kZXdvcmQuZ2V0U3RhcnRYKCkpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCAqXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZENvbHVtbnMgKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwcmV2aW91c1Jvd0NvZGV3b3JkLmdldEVuZFgoKSAtIHByZXZpb3VzUm93Q29kZXdvcmQuZ2V0U3RhcnRYKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNraXBwZWRDb2x1bW5zKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsZWZ0VG9SaWdodCA/IGRldGVjdGlvblJlc3VsdC5nZXRCb3VuZGluZ0JveCgpLmdldE1pblgoKSA6IGRldGVjdGlvblJlc3VsdC5nZXRCb3VuZGluZ0JveCgpLmdldE1heFgoKTtcclxuICAgIH07XHJcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuZGV0ZWN0Q29kZXdvcmQgPSBmdW5jdGlvbiAoaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgc3RhcnRDb2x1bW4sIGltYWdlUm93LCBtaW5Db2Rld29yZFdpZHRoLCBtYXhDb2Rld29yZFdpZHRoKSB7XHJcbiAgICAgICAgc3RhcnRDb2x1bW4gPSBQREY0MTdTY2FubmluZ0RlY29kZXIuYWRqdXN0Q29kZXdvcmRTdGFydENvbHVtbihpbWFnZSwgbWluQ29sdW1uLCBtYXhDb2x1bW4sIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3cpO1xyXG4gICAgICAgIC8vIHdlIHVzdWFsbHkga25vdyBmYWlybHkgZXhhY3Qgbm93IGhvdyBsb25nIGEgY29kZXdvcmQgaXMuIFdlIHNob3VsZCBwcm92aWRlIG1pbmltdW0gYW5kIG1heGltdW0gZXhwZWN0ZWQgbGVuZ3RoXHJcbiAgICAgICAgLy8gYW5kIHRyeSB0byBhZGp1c3QgdGhlIHJlYWQgcGl4ZWxzLCBlLmcuIHJlbW92ZSBzaW5nbGUgcGl4ZWwgZXJyb3JzIG9yIHRyeSB0byBjdXQgb2ZmIGV4Y2VlZGluZyBwaXhlbHMuXHJcbiAgICAgICAgLy8gbWluIGFuZCBtYXhDb2Rld29yZFdpZHRoIHNob3VsZCBub3QgYmUgdXNlZCBhcyB0aGV5IGFyZSBjYWxjdWxhdGVkIGZvciB0aGUgd2hvbGUgYmFyY29kZSBhbiBjYW4gYmUgaW5hY2N1cmF0ZVxyXG4gICAgICAgIC8vIGZvciB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgICAgIHZhciBtb2R1bGVCaXRDb3VudCA9IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRNb2R1bGVCaXRDb3VudChpbWFnZSwgbWluQ29sdW1uLCBtYXhDb2x1bW4sIGxlZnRUb1JpZ2h0LCBzdGFydENvbHVtbiwgaW1hZ2VSb3cpO1xyXG4gICAgICAgIGlmIChtb2R1bGVCaXRDb3VudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZW5kQ29sdW1uO1xyXG4gICAgICAgIHZhciBjb2Rld29yZEJpdENvdW50ID0gTWF0aFV0aWxzXzEuZGVmYXVsdC5zdW0obW9kdWxlQml0Q291bnQpO1xyXG4gICAgICAgIGlmIChsZWZ0VG9SaWdodCkge1xyXG4gICAgICAgICAgICBlbmRDb2x1bW4gPSBzdGFydENvbHVtbiArIGNvZGV3b3JkQml0Q291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoIC8gMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG1wQ291bnQgPSBtb2R1bGVCaXRDb3VudFtpXTtcclxuICAgICAgICAgICAgICAgIG1vZHVsZUJpdENvdW50W2ldID0gbW9kdWxlQml0Q291bnRbbW9kdWxlQml0Q291bnQubGVuZ3RoIC0gMSAtIGldO1xyXG4gICAgICAgICAgICAgICAgbW9kdWxlQml0Q291bnRbbW9kdWxlQml0Q291bnQubGVuZ3RoIC0gMSAtIGldID0gdG1wQ291bnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZW5kQ29sdW1uID0gc3RhcnRDb2x1bW47XHJcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uID0gZW5kQ29sdW1uIC0gY29kZXdvcmRCaXRDb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgY2hlY2sgZm9yIHdpZHRoIGFuZCBjb3JyZWN0aW9uIG9mIGJsYWNrIGFuZCB3aGl0ZSBiYXJzXHJcbiAgICAgICAgLy8gdXNlIHN0YXJ0IChhbmQgbWF5YmUgc3RvcCBwYXR0ZXJuKSB0byBkZXRlcm1pbmUgaWYgYmxhY2sgYmFycyBhcmUgd2lkZXIgdGhhbiB3aGl0ZSBiYXJzLiBJZiBzbywgYWRqdXN0LlxyXG4gICAgICAgIC8vIHNob3VsZCBwcm9iYWJseSBkb25lIG9ubHkgZm9yIGNvZGV3b3JkcyB3aXRoIGEgbG90IG1vcmUgdGhhbiAxNyBiaXRzLlxyXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgZml4ZXMgMTAtMS5wbmcsIHdoaWNoIGhhcyB3aWRlIGJsYWNrIGJhcnMgYW5kIHNtYWxsIHdoaXRlIGJhcnNcclxuICAgICAgICAvLyAgICBmb3IgKGxldCBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWxlQml0Q291bnQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAvLyAgICAgIGlmIChpICUgMiA9PT0gMCkge1xyXG4gICAgICAgIC8vICAgICAgICBtb2R1bGVCaXRDb3VudFtpXS0tO1xyXG4gICAgICAgIC8vICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgICAgbW9kdWxlQml0Q291bnRbaV0rKztcclxuICAgICAgICAvLyAgICAgIH1cclxuICAgICAgICAvLyAgICB9XHJcbiAgICAgICAgLy8gV2UgY291bGQgYWxzbyB1c2UgdGhlIHdpZHRoIG9mIHN1cnJvdW5kaW5nIGNvZGV3b3JkcyBmb3IgbW9yZSBhY2N1cmF0ZSByZXN1bHRzLCBidXQgdGhpcyBzZWVtc1xyXG4gICAgICAgIC8vIHN1ZmZpY2llbnQgZm9yIG5vd1xyXG4gICAgICAgIGlmICghUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmNoZWNrQ29kZXdvcmRTa2V3KGNvZGV3b3JkQml0Q291bnQsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGNvdWxkIHRyeSB0byB1c2UgdGhlIHN0YXJ0WCBhbmQgZW5kWCBwb3NpdGlvbiBvZiB0aGUgY29kZXdvcmQgaW4gdGhlIHNhbWUgY29sdW1uIGluIHRoZSBwcmV2aW91cyByb3csXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgYml0IGNvdW50IGZyb20gaXQgYW5kIG5vcm1hbGl6ZSBpdCB0byA4LiBUaGlzIHdvdWxkIGhlbHAgd2l0aCBzaW5nbGUgcGl4ZWwgZXJyb3JzLlxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlY29kZWRWYWx1ZSA9IFBERjQxN0NvZGV3b3JkRGVjb2Rlcl8xLmRlZmF1bHQuZ2V0RGVjb2RlZFZhbHVlKG1vZHVsZUJpdENvdW50KTtcclxuICAgICAgICB2YXIgY29kZXdvcmQgPSBQREY0MTdDb21tb25fMS5kZWZhdWx0LmdldENvZGV3b3JkKGRlY29kZWRWYWx1ZSk7XHJcbiAgICAgICAgaWYgKGNvZGV3b3JkID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2Rld29yZF8xLmRlZmF1bHQoc3RhcnRDb2x1bW4sIGVuZENvbHVtbiwgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldENvZGV3b3JkQnVja2V0TnVtYmVyKGRlY29kZWRWYWx1ZSksIGNvZGV3b3JkKTtcclxuICAgIH07XHJcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0TW9kdWxlQml0Q291bnQgPSBmdW5jdGlvbiAoaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgc3RhcnRDb2x1bW4sIGltYWdlUm93KSB7XHJcbiAgICAgICAgdmFyIGltYWdlQ29sdW1uID0gc3RhcnRDb2x1bW47XHJcbiAgICAgICAgdmFyIG1vZHVsZUJpdENvdW50ID0gbmV3IEludDMyQXJyYXkoOCk7XHJcbiAgICAgICAgdmFyIG1vZHVsZU51bWJlciA9IDA7XHJcbiAgICAgICAgdmFyIGluY3JlbWVudCA9IGxlZnRUb1JpZ2h0ID8gMSA6IC0xO1xyXG4gICAgICAgIHZhciBwcmV2aW91c1BpeGVsVmFsdWUgPSBsZWZ0VG9SaWdodDtcclxuICAgICAgICB3aGlsZSAoKGxlZnRUb1JpZ2h0ID8gaW1hZ2VDb2x1bW4gPCBtYXhDb2x1bW4gOiBpbWFnZUNvbHVtbiA+PSBtaW5Db2x1bW4pICYmXHJcbiAgICAgICAgICAgIG1vZHVsZU51bWJlciA8IG1vZHVsZUJpdENvdW50Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGltYWdlQ29sdW1uLCBpbWFnZVJvdykgPT09IHByZXZpb3VzUGl4ZWxWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgbW9kdWxlQml0Q291bnRbbW9kdWxlTnVtYmVyXSsrO1xyXG4gICAgICAgICAgICAgICAgaW1hZ2VDb2x1bW4gKz0gaW5jcmVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW9kdWxlTnVtYmVyKys7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c1BpeGVsVmFsdWUgPSAhcHJldmlvdXNQaXhlbFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb2R1bGVOdW1iZXIgPT09IG1vZHVsZUJpdENvdW50Lmxlbmd0aCB8fFxyXG4gICAgICAgICAgICAoKGltYWdlQ29sdW1uID09PSAobGVmdFRvUmlnaHQgPyBtYXhDb2x1bW4gOiBtaW5Db2x1bW4pKSAmJlxyXG4gICAgICAgICAgICAgICAgbW9kdWxlTnVtYmVyID09PSBtb2R1bGVCaXRDb3VudC5sZW5ndGggLSAxKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlQml0Q291bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXROdW1iZXJPZkVDQ29kZVdvcmRzID0gZnVuY3Rpb24gKGJhcmNvZGVFQ0xldmVsKSB7XHJcbiAgICAgICAgcmV0dXJuIDIgPDwgYmFyY29kZUVDTGV2ZWw7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmFkanVzdENvZGV3b3JkU3RhcnRDb2x1bW4gPSBmdW5jdGlvbiAoaW1hZ2UsIG1pbkNvbHVtbiwgbWF4Q29sdW1uLCBsZWZ0VG9SaWdodCwgY29kZXdvcmRTdGFydENvbHVtbiwgaW1hZ2VSb3cpIHtcclxuICAgICAgICB2YXIgY29ycmVjdGVkU3RhcnRDb2x1bW4gPSBjb2Rld29yZFN0YXJ0Q29sdW1uO1xyXG4gICAgICAgIHZhciBpbmNyZW1lbnQgPSBsZWZ0VG9SaWdodCA/IC0xIDogMTtcclxuICAgICAgICAvLyB0aGVyZSBzaG91bGQgYmUgbm8gYmxhY2sgcGl4ZWxzIGJlZm9yZSB0aGUgc3RhcnQgY29sdW1uLiBJZiB0aGVyZSBhcmUsIHRoZW4gd2UgbmVlZCB0byBzdGFydCBlYXJsaWVyLlxyXG4gICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7IGkgPCAyOyBpKyspIHtcclxuICAgICAgICAgICAgd2hpbGUgKChsZWZ0VG9SaWdodCA/IGNvcnJlY3RlZFN0YXJ0Q29sdW1uID49IG1pbkNvbHVtbiA6IGNvcnJlY3RlZFN0YXJ0Q29sdW1uIDwgbWF4Q29sdW1uKSAmJlxyXG4gICAgICAgICAgICAgICAgbGVmdFRvUmlnaHQgPT09IGltYWdlLmdldChjb3JyZWN0ZWRTdGFydENvbHVtbiwgaW1hZ2VSb3cpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoY29kZXdvcmRTdGFydENvbHVtbiAtIGNvcnJlY3RlZFN0YXJ0Q29sdW1uKSA+IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5DT0RFV09SRF9TS0VXX1NJWkUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29kZXdvcmRTdGFydENvbHVtbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvcnJlY3RlZFN0YXJ0Q29sdW1uICs9IGluY3JlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbmNyZW1lbnQgPSAtaW5jcmVtZW50O1xyXG4gICAgICAgICAgICBsZWZ0VG9SaWdodCA9ICFsZWZ0VG9SaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvcnJlY3RlZFN0YXJ0Q29sdW1uO1xyXG4gICAgfTtcclxuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5jaGVja0NvZGV3b3JkU2tldyA9IGZ1bmN0aW9uIChjb2Rld29yZFNpemUsIG1pbkNvZGV3b3JkV2lkdGgsIG1heENvZGV3b3JkV2lkdGgpIHtcclxuICAgICAgICByZXR1cm4gbWluQ29kZXdvcmRXaWR0aCAtIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5DT0RFV09SRF9TS0VXX1NJWkUgPD0gY29kZXdvcmRTaXplICYmXHJcbiAgICAgICAgICAgIGNvZGV3b3JkU2l6ZSA8PSBtYXhDb2Rld29yZFdpZHRoICsgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLkNPREVXT1JEX1NLRVdfU0laRTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uLFxyXG4gICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvblxyXG4gICAgICovXHJcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuZGVjb2RlQ29kZXdvcmRzID0gZnVuY3Rpb24gKGNvZGV3b3JkcywgZWNMZXZlbCwgZXJhc3VyZXMpIHtcclxuICAgICAgICBpZiAoY29kZXdvcmRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0LmdldEZvcm1hdEluc3RhbmNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBudW1FQ0NvZGV3b3JkcyA9IDEgPDwgKGVjTGV2ZWwgKyAxKTtcclxuICAgICAgICB2YXIgY29ycmVjdGVkRXJyb3JzQ291bnQgPSBQREY0MTdTY2FubmluZ0RlY29kZXIuY29ycmVjdEVycm9ycyhjb2Rld29yZHMsIGVyYXN1cmVzLCBudW1FQ0NvZGV3b3Jkcyk7XHJcbiAgICAgICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLnZlcmlmeUNvZGV3b3JkQ291bnQoY29kZXdvcmRzLCBudW1FQ0NvZGV3b3Jkcyk7XHJcbiAgICAgICAgLy8gRGVjb2RlIHRoZSBjb2Rld29yZHNcclxuICAgICAgICB2YXIgZGVjb2RlclJlc3VsdCA9IERlY29kZWRCaXRTdHJlYW1QYXJzZXJfMS5kZWZhdWx0LmRlY29kZShjb2Rld29yZHMsICcnICsgZWNMZXZlbCk7XHJcbiAgICAgICAgZGVjb2RlclJlc3VsdC5zZXRFcnJvcnNDb3JyZWN0ZWQoY29ycmVjdGVkRXJyb3JzQ291bnQpO1xyXG4gICAgICAgIGRlY29kZXJSZXN1bHQuc2V0RXJhc3VyZXMoZXJhc3VyZXMubGVuZ3RoKTtcclxuICAgICAgICByZXR1cm4gZGVjb2RlclJlc3VsdDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPkdpdmVuIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHJlY2VpdmVkLCBwb3NzaWJseSBjb3JydXB0ZWQgYnkgZXJyb3JzLCBhdHRlbXB0cyB0b1xyXG4gICAgICogY29ycmVjdCB0aGUgZXJyb3JzIGluLXBsYWNlLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29kZXdvcmRzICAgZGF0YSBhbmQgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHNcclxuICAgICAqIEBwYXJhbSBlcmFzdXJlcyBwb3NpdGlvbnMgb2YgYW55IGtub3duIGVyYXN1cmVzXHJcbiAgICAgKiBAcGFyYW0gbnVtRUNDb2Rld29yZHMgbnVtYmVyIG9mIGVycm9yIGNvcnJlY3Rpb24gY29kZXdvcmRzIHRoYXQgYXJlIGF2YWlsYWJsZSBpbiBjb2Rld29yZHNcclxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xyXG4gICAgICovXHJcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuY29ycmVjdEVycm9ycyA9IGZ1bmN0aW9uIChjb2Rld29yZHMsIGVyYXN1cmVzLCBudW1FQ0NvZGV3b3Jkcykge1xyXG4gICAgICAgIGlmIChlcmFzdXJlcyAhPSBudWxsICYmXHJcbiAgICAgICAgICAgIGVyYXN1cmVzLmxlbmd0aCA+IG51bUVDQ29kZXdvcmRzIC8gMiArIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5NQVhfRVJST1JTIHx8XHJcbiAgICAgICAgICAgIG51bUVDQ29kZXdvcmRzIDwgMCB8fFxyXG4gICAgICAgICAgICBudW1FQ0NvZGV3b3JkcyA+IFBERjQxN1NjYW5uaW5nRGVjb2Rlci5NQVhfRUNfQ09ERVdPUkRTKSB7XHJcbiAgICAgICAgICAgIC8vIFRvbyBtYW55IGVycm9ycyBvciBFQyBDb2Rld29yZHMgaXMgY29ycnVwdGVkXHJcbiAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRDaGVja3N1bUluc3RhbmNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBQREY0MTdTY2FubmluZ0RlY29kZXIuZXJyb3JDb3JyZWN0aW9uLmRlY29kZShjb2Rld29yZHMsIG51bUVDQ29kZXdvcmRzLCBlcmFzdXJlcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZnkgdGhhdCBhbGwgaXMgT0sgd2l0aCB0aGUgY29kZXdvcmQgYXJyYXkuXHJcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvblxyXG4gICAgICovXHJcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIudmVyaWZ5Q29kZXdvcmRDb3VudCA9IGZ1bmN0aW9uIChjb2Rld29yZHMsIG51bUVDQ29kZXdvcmRzKSB7XHJcbiAgICAgICAgaWYgKGNvZGV3b3Jkcy5sZW5ndGggPCA0KSB7XHJcbiAgICAgICAgICAgIC8vIENvZGV3b3JkIGFycmF5IHNpemUgc2hvdWxkIGJlIGF0IGxlYXN0IDQgYWxsb3dpbmcgZm9yXHJcbiAgICAgICAgICAgIC8vIENvdW50IENXLCBBdCBsZWFzdCBvbmUgRGF0YSBDVywgRXJyb3IgQ29ycmVjdGlvbiBDVywgRXJyb3IgQ29ycmVjdGlvbiBDV1xyXG4gICAgICAgICAgICB0aHJvdyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0LmdldEZvcm1hdEluc3RhbmNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBmaXJzdCBjb2Rld29yZCwgdGhlIFN5bWJvbCBMZW5ndGggRGVzY3JpcHRvciwgc2hhbGwgYWx3YXlzIGVuY29kZSB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGFcclxuICAgICAgICAvLyBjb2Rld29yZHMgaW4gdGhlIHN5bWJvbCwgaW5jbHVkaW5nIHRoZSBTeW1ib2wgTGVuZ3RoIERlc2NyaXB0b3IgaXRzZWxmLCBkYXRhIGNvZGV3b3JkcyBhbmQgcGFkXHJcbiAgICAgICAgLy8gY29kZXdvcmRzLCBidXQgZXhjbHVkaW5nIHRoZSBudW1iZXIgb2YgZXJyb3IgY29ycmVjdGlvbiBjb2Rld29yZHMuXHJcbiAgICAgICAgdmFyIG51bWJlck9mQ29kZXdvcmRzID0gY29kZXdvcmRzWzBdO1xyXG4gICAgICAgIGlmIChudW1iZXJPZkNvZGV3b3JkcyA+IGNvZGV3b3Jkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRGb3JtYXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobnVtYmVyT2ZDb2Rld29yZHMgPT09IDApIHtcclxuICAgICAgICAgICAgLy8gUmVzZXQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgLSA4IChBbGxvdyBmb3IgYXQgbGVhc3QgbGV2ZWwgMyBFcnJvciBDb3JyZWN0aW9uICg4IEVycm9yIENvZGV3b3JkcylcclxuICAgICAgICAgICAgaWYgKG51bUVDQ29kZXdvcmRzIDwgY29kZXdvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29kZXdvcmRzWzBdID0gY29kZXdvcmRzLmxlbmd0aCAtIG51bUVDQ29kZXdvcmRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRGb3JtYXRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRCaXRDb3VudEZvckNvZGV3b3JkID0gZnVuY3Rpb24gKGNvZGV3b3JkKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KDgpO1xyXG4gICAgICAgIHZhciBwcmV2aW91c1ZhbHVlID0gMDtcclxuICAgICAgICB2YXIgaSA9IHJlc3VsdC5sZW5ndGggLSAxO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmICgoY29kZXdvcmQgJiAweDEpICE9PSBwcmV2aW91c1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlID0gY29kZXdvcmQgJiAweDE7XHJcbiAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHRbaV0rKztcclxuICAgICAgICAgICAgY29kZXdvcmQgPj49IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmdldENvZGV3b3JkQnVja2V0TnVtYmVyID0gZnVuY3Rpb24gKGNvZGV3b3JkKSB7XHJcbiAgICAgICAgaWYgKGNvZGV3b3JkIGluc3RhbmNlb2YgSW50MzJBcnJheSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2Rld29yZEJ1Y2tldE51bWJlcl9JbnQzMkFycmF5KGNvZGV3b3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXJfbnVtYmVyKGNvZGV3b3JkKTtcclxuICAgIH07XHJcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Q29kZXdvcmRCdWNrZXROdW1iZXJfbnVtYmVyID0gZnVuY3Rpb24gKGNvZGV3b3JkKSB7XHJcbiAgICAgICAgcmV0dXJuIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRDb2Rld29yZEJ1Y2tldE51bWJlcihQREY0MTdTY2FubmluZ0RlY29kZXIuZ2V0Qml0Q291bnRGb3JDb2Rld29yZChjb2Rld29yZCkpO1xyXG4gICAgfTtcclxuICAgIFBERjQxN1NjYW5uaW5nRGVjb2Rlci5nZXRDb2Rld29yZEJ1Y2tldE51bWJlcl9JbnQzMkFycmF5ID0gZnVuY3Rpb24gKG1vZHVsZUJpdENvdW50KSB7XHJcbiAgICAgICAgcmV0dXJuIChtb2R1bGVCaXRDb3VudFswXSAtIG1vZHVsZUJpdENvdW50WzJdICsgbW9kdWxlQml0Q291bnRbNF0gLSBtb2R1bGVCaXRDb3VudFs2XSArIDkpICUgOTtcclxuICAgIH07XHJcbiAgICBQREY0MTdTY2FubmluZ0RlY29kZXIudG9TdHJpbmcgPSBmdW5jdGlvbiAoYmFyY29kZU1hdHJpeCkge1xyXG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIC8vIHRyeSAobGV0IGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIoKSkge1xyXG4gICAgICAgIGZvciAodmFyIHJvdyAvKmludCovID0gMDsgcm93IDwgYmFyY29kZU1hdHJpeC5sZW5ndGg7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdHRlci5mb3JtYXQoJ1JvdyAlMmQ6ICcsIHJvdyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGNvbHVtbiAvKmludCovID0gMDsgY29sdW1uIDwgYmFyY29kZU1hdHJpeFtyb3ddLmxlbmd0aDsgY29sdW1uKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiYXJjb2RlVmFsdWUgPSBiYXJjb2RlTWF0cml4W3Jvd11bY29sdW1uXTtcclxuICAgICAgICAgICAgICAgIGlmIChiYXJjb2RlVmFsdWUuZ2V0VmFsdWUoKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCcgICAgICAgICcsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLmZvcm1hdCgnJTRkKCUyZCknLCBiYXJjb2RlVmFsdWUuZ2V0VmFsdWUoKVswXSwgYmFyY29kZVZhbHVlLmdldENvbmZpZGVuY2UoYmFyY29kZVZhbHVlLmdldFZhbHVlKClbMF0pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3JtYXR0ZXIuZm9ybWF0KCclbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfTtcclxuICAgIC8qZmluYWwqLyBQREY0MTdTY2FubmluZ0RlY29kZXIuQ09ERVdPUkRfU0tFV19TSVpFID0gMjtcclxuICAgIC8qZmluYWwqLyBQREY0MTdTY2FubmluZ0RlY29kZXIuTUFYX0VSUk9SUyA9IDM7XHJcbiAgICAvKmZpbmFsKi8gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLk1BWF9FQ19DT0RFV09SRFMgPSA1MTI7XHJcbiAgICAvKmZpbmFsKi8gUERGNDE3U2Nhbm5pbmdEZWNvZGVyLmVycm9yQ29ycmVjdGlvbiA9IG5ldyBFcnJvckNvcnJlY3Rpb25fMS5kZWZhdWx0KCk7XHJcbiAgICByZXR1cm4gUERGNDE3U2Nhbm5pbmdEZWNvZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQREY0MTdTY2FubmluZ0RlY29kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBERjQxN1NjYW5uaW5nRGVjb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXHJcbipcclxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXIuZWM7XHJcbi8vIGltcG9ydCBjb20uZ29vZ2xlLnp4aW5nLkNoZWNrc3VtRXhjZXB0aW9uO1xyXG52YXIgQ2hlY2tzdW1FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9DaGVja3N1bUV4Y2VwdGlvblwiKTtcclxudmFyIE1vZHVsdXNQb2x5XzEgPSByZXF1aXJlKFwiLi9Nb2R1bHVzUG9seVwiKTtcclxudmFyIE1vZHVsdXNHRl8xID0gcmVxdWlyZShcIi4vTW9kdWx1c0dGXCIpO1xyXG4vKipcclxuICogPHA+UERGNDE3IGVycm9yIGNvcnJlY3Rpb24gaW1wbGVtZW50YXRpb24uPC9wPlxyXG4gKlxyXG4gKiA8cD5UaGlzIDxhIGhyZWY9XCJodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JlZWQlRTIlODAlOTNTb2xvbW9uX2Vycm9yX2NvcnJlY3Rpb24jRXhhbXBsZVwiPmV4YW1wbGU8L2E+XHJcbiAqIGlzIHF1aXRlIHVzZWZ1bCBpbiB1bmRlcnN0YW5kaW5nIHRoZSBhbGdvcml0aG0uPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKiBAc2VlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uLlJlZWRTb2xvbW9uRGVjb2RlclxyXG4gKi9cclxudmFyIEVycm9yQ29ycmVjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVycm9yQ29ycmVjdGlvbigpIHtcclxuICAgICAgICB0aGlzLmZpZWxkID0gTW9kdWx1c0dGXzEuZGVmYXVsdC5QREY0MTdfR0Y7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSByZWNlaXZlZCByZWNlaXZlZCBjb2Rld29yZHNcclxuICAgICAqIEBwYXJhbSBudW1FQ0NvZGV3b3JkcyBudW1iZXIgb2YgdGhvc2UgY29kZXdvcmRzIHVzZWQgZm9yIEVDXHJcbiAgICAgKiBAcGFyYW0gZXJhc3VyZXMgbG9jYXRpb24gb2YgZXJhc3VyZXNcclxuICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGVycm9yc1xyXG4gICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvcnMgY2Fubm90IGJlIGNvcnJlY3RlZCwgbWF5YmUgYmVjYXVzZSBvZiB0b28gbWFueSBlcnJvcnNcclxuICAgICAqL1xyXG4gICAgRXJyb3JDb3JyZWN0aW9uLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVjZWl2ZWQsIG51bUVDQ29kZXdvcmRzLCBlcmFzdXJlcykge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIHZhciBwb2x5ID0gbmV3IE1vZHVsdXNQb2x5XzEuZGVmYXVsdCh0aGlzLmZpZWxkLCByZWNlaXZlZCk7XHJcbiAgICAgICAgdmFyIFMgPSBuZXcgSW50MzJBcnJheShudW1FQ0NvZGV3b3Jkcyk7XHJcbiAgICAgICAgdmFyIGVycm9yID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gbnVtRUNDb2Rld29yZHM7IGkgPiAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIGV2YWx1YXRpb24gPSBwb2x5LmV2YWx1YXRlQXQodGhpcy5maWVsZC5leHAoaSkpO1xyXG4gICAgICAgICAgICBTW251bUVDQ29kZXdvcmRzIC0gaV0gPSBldmFsdWF0aW9uO1xyXG4gICAgICAgICAgICBpZiAoZXZhbHVhdGlvbiAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZXJyb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBrbm93bkVycm9ycyA9IHRoaXMuZmllbGQuZ2V0T25lKCk7XHJcbiAgICAgICAgaWYgKGVyYXN1cmVzICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGVyYXN1cmVzXzEgPSBfX3ZhbHVlcyhlcmFzdXJlcyksIGVyYXN1cmVzXzFfMSA9IGVyYXN1cmVzXzEubmV4dCgpOyAhZXJhc3VyZXNfMV8xLmRvbmU7IGVyYXN1cmVzXzFfMSA9IGVyYXN1cmVzXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyYXN1cmUgPSBlcmFzdXJlc18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmZpZWxkLmV4cChyZWNlaXZlZC5sZW5ndGggLSAxIC0gZXJhc3VyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkICgxIC0gYngpIHRlcm06XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlcm0gPSBuZXcgTW9kdWx1c1BvbHlfMS5kZWZhdWx0KHRoaXMuZmllbGQsIG5ldyBJbnQzMkFycmF5KFt0aGlzLmZpZWxkLnN1YnRyYWN0KDAsIGIpLCAxXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGtub3duRXJyb3JzID0ga25vd25FcnJvcnMubXVsdGlwbHkodGVybSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcmFzdXJlc18xXzEgJiYgIWVyYXN1cmVzXzFfMS5kb25lICYmIChfYSA9IGVyYXN1cmVzXzEucmV0dXJuKSkgX2EuY2FsbChlcmFzdXJlc18xKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3luZHJvbWUgPSBuZXcgTW9kdWx1c1BvbHlfMS5kZWZhdWx0KHRoaXMuZmllbGQsIFMpO1xyXG4gICAgICAgIC8vIHN5bmRyb21lID0gc3luZHJvbWUubXVsdGlwbHkoa25vd25FcnJvcnMpO1xyXG4gICAgICAgIHZhciBzaWdtYU9tZWdhID0gdGhpcy5ydW5FdWNsaWRlYW5BbGdvcml0aG0odGhpcy5maWVsZC5idWlsZE1vbm9taWFsKG51bUVDQ29kZXdvcmRzLCAxKSwgc3luZHJvbWUsIG51bUVDQ29kZXdvcmRzKTtcclxuICAgICAgICB2YXIgc2lnbWEgPSBzaWdtYU9tZWdhWzBdO1xyXG4gICAgICAgIHZhciBvbWVnYSA9IHNpZ21hT21lZ2FbMV07XHJcbiAgICAgICAgLy8gc2lnbWEgPSBzaWdtYS5tdWx0aXBseShrbm93bkVycm9ycyk7XHJcbiAgICAgICAgdmFyIGVycm9yTG9jYXRpb25zID0gdGhpcy5maW5kRXJyb3JMb2NhdGlvbnMoc2lnbWEpO1xyXG4gICAgICAgIHZhciBlcnJvck1hZ25pdHVkZXMgPSB0aGlzLmZpbmRFcnJvck1hZ25pdHVkZXMob21lZ2EsIHNpZ21hLCBlcnJvckxvY2F0aW9ucyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IGVycm9yTG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHJlY2VpdmVkLmxlbmd0aCAtIDEgLSB0aGlzLmZpZWxkLmxvZyhlcnJvckxvY2F0aW9uc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdC5nZXRDaGVja3N1bUluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVjZWl2ZWRbcG9zaXRpb25dID0gdGhpcy5maWVsZC5zdWJ0cmFjdChyZWNlaXZlZFtwb3NpdGlvbl0sIGVycm9yTWFnbml0dWRlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlcnJvckxvY2F0aW9ucy5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIE1vZHVsdXNQb2x5XHJcbiAgICAgKiBAcGFyYW0gYVxyXG4gICAgICogQHBhcmFtIE1vZHVsdXNQb2x5XHJcbiAgICAgKiBAcGFyYW0gYlxyXG4gICAgICogQHBhcmFtIGludFxyXG4gICAgICogQHBhcmFtIFJcclxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb25cclxuICAgICAqL1xyXG4gICAgRXJyb3JDb3JyZWN0aW9uLnByb3RvdHlwZS5ydW5FdWNsaWRlYW5BbGdvcml0aG0gPSBmdW5jdGlvbiAoYSwgYiwgUikge1xyXG4gICAgICAgIC8vIEFzc3VtZSBhJ3MgZGVncmVlIGlzID49IGInc1xyXG4gICAgICAgIGlmIChhLmdldERlZ3JlZSgpIDwgYi5nZXREZWdyZWUoKSkge1xyXG4gICAgICAgICAgICB2YXIgdGVtcCA9IGE7XHJcbiAgICAgICAgICAgIGEgPSBiO1xyXG4gICAgICAgICAgICBiID0gdGVtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJMYXN0ID0gYTtcclxuICAgICAgICB2YXIgciA9IGI7XHJcbiAgICAgICAgdmFyIHRMYXN0ID0gdGhpcy5maWVsZC5nZXRaZXJvKCk7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzLmZpZWxkLmdldE9uZSgpO1xyXG4gICAgICAgIC8vIFJ1biBFdWNsaWRlYW4gYWxnb3JpdGhtIHVudGlsIHIncyBkZWdyZWUgaXMgbGVzcyB0aGFuIFIvMlxyXG4gICAgICAgIHdoaWxlIChyLmdldERlZ3JlZSgpID49IE1hdGgucm91bmQoUiAvIDIpKSB7XHJcbiAgICAgICAgICAgIHZhciByTGFzdExhc3QgPSByTGFzdDtcclxuICAgICAgICAgICAgdmFyIHRMYXN0TGFzdCA9IHRMYXN0O1xyXG4gICAgICAgICAgICByTGFzdCA9IHI7XHJcbiAgICAgICAgICAgIHRMYXN0ID0gdDtcclxuICAgICAgICAgICAgLy8gRGl2aWRlIHJMYXN0TGFzdCBieSByTGFzdCwgd2l0aCBxdW90aWVudCBpbiBxIGFuZCByZW1haW5kZXIgaW4gclxyXG4gICAgICAgICAgICBpZiAockxhc3QuaXNaZXJvKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9vcHMsIEV1Y2xpZGVhbiBhbGdvcml0aG0gYWxyZWFkeSB0ZXJtaW5hdGVkP1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0LmdldENoZWNrc3VtSW5zdGFuY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByID0gckxhc3RMYXN0O1xyXG4gICAgICAgICAgICB2YXIgcSA9IHRoaXMuZmllbGQuZ2V0WmVybygpO1xyXG4gICAgICAgICAgICB2YXIgZGVub21pbmF0b3JMZWFkaW5nVGVybSA9IHJMYXN0LmdldENvZWZmaWNpZW50KHJMYXN0LmdldERlZ3JlZSgpKTtcclxuICAgICAgICAgICAgdmFyIGRsdEludmVyc2UgPSB0aGlzLmZpZWxkLmludmVyc2UoZGVub21pbmF0b3JMZWFkaW5nVGVybSk7XHJcbiAgICAgICAgICAgIHdoaWxlIChyLmdldERlZ3JlZSgpID49IHJMYXN0LmdldERlZ3JlZSgpICYmICFyLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVncmVlRGlmZiA9IHIuZ2V0RGVncmVlKCkgLSByTGFzdC5nZXREZWdyZWUoKTtcclxuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IHRoaXMuZmllbGQubXVsdGlwbHkoci5nZXRDb2VmZmljaWVudChyLmdldERlZ3JlZSgpKSwgZGx0SW52ZXJzZSk7XHJcbiAgICAgICAgICAgICAgICBxID0gcS5hZGQodGhpcy5maWVsZC5idWlsZE1vbm9taWFsKGRlZ3JlZURpZmYsIHNjYWxlKSk7XHJcbiAgICAgICAgICAgICAgICByID0gci5zdWJ0cmFjdChyTGFzdC5tdWx0aXBseUJ5TW9ub21pYWwoZGVncmVlRGlmZiwgc2NhbGUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ID0gcS5tdWx0aXBseSh0TGFzdCkuc3VidHJhY3QodExhc3RMYXN0KS5uZWdhdGl2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2lnbWFUaWxkZUF0WmVybyA9IHQuZ2V0Q29lZmZpY2llbnQoMCk7XHJcbiAgICAgICAgaWYgKHNpZ21hVGlsZGVBdFplcm8gPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0LmdldENoZWNrc3VtSW5zdGFuY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGludmVyc2UgPSB0aGlzLmZpZWxkLmludmVyc2Uoc2lnbWFUaWxkZUF0WmVybyk7XHJcbiAgICAgICAgdmFyIHNpZ21hID0gdC5tdWx0aXBseShpbnZlcnNlKTtcclxuICAgICAgICB2YXIgb21lZ2EgPSByLm11bHRpcGx5KGludmVyc2UpO1xyXG4gICAgICAgIHJldHVybiBbc2lnbWEsIG9tZWdhXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXJyb3JMb2NhdG9yXHJcbiAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uXHJcbiAgICAgKi9cclxuICAgIEVycm9yQ29ycmVjdGlvbi5wcm90b3R5cGUuZmluZEVycm9yTG9jYXRpb25zID0gZnVuY3Rpb24gKGVycm9yTG9jYXRvcikge1xyXG4gICAgICAgIC8vIFRoaXMgaXMgYSBkaXJlY3QgYXBwbGljYXRpb24gb2YgQ2hpZW4ncyBzZWFyY2hcclxuICAgICAgICB2YXIgbnVtRXJyb3JzID0gZXJyb3JMb2NhdG9yLmdldERlZ3JlZSgpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgSW50MzJBcnJheShudW1FcnJvcnMpO1xyXG4gICAgICAgIHZhciBlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAxOyBpIDwgdGhpcy5maWVsZC5nZXRTaXplKCkgJiYgZSA8IG51bUVycm9yczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvckxvY2F0b3IuZXZhbHVhdGVBdChpKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0W2VdID0gdGhpcy5maWVsZC5pbnZlcnNlKGkpO1xyXG4gICAgICAgICAgICAgICAgZSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlICE9PSBudW1FcnJvcnMpIHtcclxuICAgICAgICAgICAgdGhyb3cgQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0LmdldENoZWNrc3VtSW5zdGFuY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBFcnJvckNvcnJlY3Rpb24ucHJvdG90eXBlLmZpbmRFcnJvck1hZ25pdHVkZXMgPSBmdW5jdGlvbiAoZXJyb3JFdmFsdWF0b3IsIGVycm9yTG9jYXRvciwgZXJyb3JMb2NhdGlvbnMpIHtcclxuICAgICAgICB2YXIgZXJyb3JMb2NhdG9yRGVncmVlID0gZXJyb3JMb2NhdG9yLmdldERlZ3JlZSgpO1xyXG4gICAgICAgIHZhciBmb3JtYWxEZXJpdmF0aXZlQ29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoZXJyb3JMb2NhdG9yRGVncmVlKTtcclxuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAxOyBpIDw9IGVycm9yTG9jYXRvckRlZ3JlZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvcm1hbERlcml2YXRpdmVDb2VmZmljaWVudHNbZXJyb3JMb2NhdG9yRGVncmVlIC0gaV0gPVxyXG4gICAgICAgICAgICAgICAgdGhpcy5maWVsZC5tdWx0aXBseShpLCBlcnJvckxvY2F0b3IuZ2V0Q29lZmZpY2llbnQoaSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZm9ybWFsRGVyaXZhdGl2ZSA9IG5ldyBNb2R1bHVzUG9seV8xLmRlZmF1bHQodGhpcy5maWVsZCwgZm9ybWFsRGVyaXZhdGl2ZUNvZWZmaWNpZW50cyk7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBkaXJlY3RseSBhcHBseWluZyBGb3JuZXkncyBGb3JtdWxhXHJcbiAgICAgICAgdmFyIHMgPSBlcnJvckxvY2F0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBJbnQzMkFycmF5KHMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7IGkgPCBzOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHhpSW52ZXJzZSA9IHRoaXMuZmllbGQuaW52ZXJzZShlcnJvckxvY2F0aW9uc1tpXSk7XHJcbiAgICAgICAgICAgIHZhciBudW1lcmF0b3IgPSB0aGlzLmZpZWxkLnN1YnRyYWN0KDAsIGVycm9yRXZhbHVhdG9yLmV2YWx1YXRlQXQoeGlJbnZlcnNlKSk7XHJcbiAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IHRoaXMuZmllbGQuaW52ZXJzZShmb3JtYWxEZXJpdmF0aXZlLmV2YWx1YXRlQXQoeGlJbnZlcnNlKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuZmllbGQubXVsdGlwbHkobnVtZXJhdG9yLCBkZW5vbWluYXRvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEVycm9yQ29ycmVjdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXJyb3JDb3JyZWN0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvckNvcnJlY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxudmFyIEFyaXRobWV0aWNFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9Bcml0aG1ldGljRXhjZXB0aW9uXCIpO1xyXG52YXIgTW9kdWx1c0Jhc2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNb2R1bHVzQmFzZSgpIHtcclxuICAgIH1cclxuICAgIE1vZHVsdXNCYXNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICAgIHJldHVybiAoYSArIGIpICUgdGhpcy5tb2R1bHVzO1xyXG4gICAgfTtcclxuICAgIE1vZHVsdXNCYXNlLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLm1vZHVsdXMgKyBhIC0gYikgJSB0aGlzLm1vZHVsdXM7XHJcbiAgICB9O1xyXG4gICAgTW9kdWx1c0Jhc2UucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwVGFibGVbYV07XHJcbiAgICB9O1xyXG4gICAgTW9kdWx1c0Jhc2UucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgaWYgKGEgPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nVGFibGVbYV07XHJcbiAgICB9O1xyXG4gICAgTW9kdWx1c0Jhc2UucHJvdG90eXBlLmludmVyc2UgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIGlmIChhID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBBcml0aG1ldGljRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVt0aGlzLm1vZHVsdXMgLSB0aGlzLmxvZ1RhYmxlW2FdIC0gMV07XHJcbiAgICB9O1xyXG4gICAgTW9kdWx1c0Jhc2UucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBpZiAoYSA9PT0gMCB8fCBiID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5leHBUYWJsZVsodGhpcy5sb2dUYWJsZVthXSArIHRoaXMubG9nVGFibGVbYl0pICUgKHRoaXMubW9kdWx1cyAtIDEpXTtcclxuICAgIH07XHJcbiAgICBNb2R1bHVzQmFzZS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bHVzO1xyXG4gICAgfTtcclxuICAgIE1vZHVsdXNCYXNlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIHJldHVybiBvID09PSB0aGlzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNb2R1bHVzQmFzZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTW9kdWx1c0Jhc2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vZHVsdXNCYXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIHBhY2thZ2UgY29tLmdvb2dsZS56eGluZy5wZGY0MTcuZGVjb2Rlci5lYztcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcucGRmNDE3LlBERjQxN0NvbW1vbjtcclxudmFyIFBERjQxN0NvbW1vbl8xID0gcmVxdWlyZShcIi4uLy4uL1BERjQxN0NvbW1vblwiKTtcclxudmFyIE1vZHVsdXNQb2x5XzEgPSByZXF1aXJlKFwiLi9Nb2R1bHVzUG9seVwiKTtcclxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxudmFyIE1vZHVsdXNCYXNlXzEgPSByZXF1aXJlKFwiLi9Nb2R1bHVzQmFzZVwiKTtcclxuLyoqXHJcbiAqIDxwPkEgZmllbGQgYmFzZWQgb24gcG93ZXJzIG9mIGEgZ2VuZXJhdG9yIGludGVnZXIsIG1vZHVsbyBzb21lIG1vZHVsdXMuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKiBAc2VlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uLkdlbmVyaWNHRlxyXG4gKi9cclxudmFyIE1vZHVsdXNHRiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNb2R1bHVzR0YsIF9zdXBlcik7XHJcbiAgICAvLyBwcml2YXRlIC8qZmluYWwqLyBtb2R1bHVzOiAvKmludCovIG51bWJlcjtcclxuICAgIGZ1bmN0aW9uIE1vZHVsdXNHRihtb2R1bHVzLCBnZW5lcmF0b3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm1vZHVsdXMgPSBtb2R1bHVzO1xyXG4gICAgICAgIF90aGlzLmV4cFRhYmxlID0gbmV3IEludDMyQXJyYXkobW9kdWx1cyk7XHJcbiAgICAgICAgX3RoaXMubG9nVGFibGUgPSBuZXcgSW50MzJBcnJheShtb2R1bHVzKTtcclxuICAgICAgICB2YXIgeCA9IC8qaW50Ki8gMTtcclxuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgbW9kdWx1czsgaSsrKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4cFRhYmxlW2ldID0geDtcclxuICAgICAgICAgICAgeCA9ICh4ICogZ2VuZXJhdG9yKSAlIG1vZHVsdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgLyppbnQqLyA9IDA7IGkgPCBtb2R1bHVzIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmxvZ1RhYmxlW190aGlzLmV4cFRhYmxlW2ldXSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGxvZ1RhYmxlWzBdID09IDAgYnV0IHRoaXMgc2hvdWxkIG5ldmVyIGJlIHVzZWRcclxuICAgICAgICBfdGhpcy56ZXJvID0gbmV3IE1vZHVsdXNQb2x5XzEuZGVmYXVsdChfdGhpcywgbmV3IEludDMyQXJyYXkoWzBdKSk7XHJcbiAgICAgICAgX3RoaXMub25lID0gbmV3IE1vZHVsdXNQb2x5XzEuZGVmYXVsdChfdGhpcywgbmV3IEludDMyQXJyYXkoWzFdKSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTW9kdWx1c0dGLnByb3RvdHlwZS5nZXRaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnplcm87XHJcbiAgICB9O1xyXG4gICAgTW9kdWx1c0dGLnByb3RvdHlwZS5nZXRPbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub25lO1xyXG4gICAgfTtcclxuICAgIE1vZHVsdXNHRi5wcm90b3R5cGUuYnVpbGRNb25vbWlhbCA9IGZ1bmN0aW9uIChkZWdyZWUsIGNvZWZmaWNpZW50KSB7XHJcbiAgICAgICAgaWYgKGRlZ3JlZSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvZWZmaWNpZW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnplcm87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShkZWdyZWUgKyAxKTtcclxuICAgICAgICBjb2VmZmljaWVudHNbMF0gPSBjb2VmZmljaWVudDtcclxuICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5XzEuZGVmYXVsdCh0aGlzLCBjb2VmZmljaWVudHMpO1xyXG4gICAgfTtcclxuICAgIE1vZHVsdXNHRi5QREY0MTdfR0YgPSBuZXcgTW9kdWx1c0dGKFBERjQxN0NvbW1vbl8xLmRlZmF1bHQuTlVNQkVSX09GX0NPREVXT1JEUywgMyk7XHJcbiAgICByZXR1cm4gTW9kdWx1c0dGO1xyXG59KE1vZHVsdXNCYXNlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBNb2R1bHVzR0Y7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vZHVsdXNHRi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuKiBDb3B5cmlnaHQgMjAxMiBaWGluZyBhdXRob3JzXHJcbipcclxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBwYWNrYWdlIGNvbS5nb29nbGUuenhpbmcucGRmNDE3LmRlY29kZXIuZWM7XHJcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbnZhciBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL1N5c3RlbVwiKTtcclxudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKiBAc2VlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLnJlZWRzb2xvbW9uLkdlbmVyaWNHRlBvbHlcclxuICovXHJcbnZhciBNb2R1bHVzUG9seSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1vZHVsdXNQb2x5KGZpZWxkLCBjb2VmZmljaWVudHMpIHtcclxuICAgICAgICBpZiAoY29lZmZpY2llbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZpZWxkID0gZmllbGQ7XHJcbiAgICAgICAgdmFyIGNvZWZmaWNpZW50c0xlbmd0aCA9IC8qaW50Ki8gY29lZmZpY2llbnRzLmxlbmd0aDtcclxuICAgICAgICBpZiAoY29lZmZpY2llbnRzTGVuZ3RoID4gMSAmJiBjb2VmZmljaWVudHNbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgLy8gTGVhZGluZyB0ZXJtIG11c3QgYmUgbm9uLXplcm8gZm9yIGFueXRoaW5nIGV4Y2VwdCB0aGUgY29uc3RhbnQgcG9seW5vbWlhbCBcIjBcIlxyXG4gICAgICAgICAgICB2YXIgZmlyc3ROb25aZXJvID0gLyppbnQqLyAxO1xyXG4gICAgICAgICAgICB3aGlsZSAoZmlyc3ROb25aZXJvIDwgY29lZmZpY2llbnRzTGVuZ3RoICYmIGNvZWZmaWNpZW50c1tmaXJzdE5vblplcm9dID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlyc3ROb25aZXJvID09PSBjb2VmZmljaWVudHNMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29lZmZpY2llbnRzID0gbmV3IEludDMyQXJyYXkoY29lZmZpY2llbnRzTGVuZ3RoIC0gZmlyc3ROb25aZXJvKTtcclxuICAgICAgICAgICAgICAgIFN5c3RlbV8xLmRlZmF1bHQuYXJyYXljb3B5KGNvZWZmaWNpZW50cywgZmlyc3ROb25aZXJvLCB0aGlzLmNvZWZmaWNpZW50cywgMCwgdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb2VmZmljaWVudHMgPSBjb2VmZmljaWVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgTW9kdWx1c1BvbHkucHJvdG90eXBlLmdldENvZWZmaWNpZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHM7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIGRlZ3JlZSBvZiB0aGlzIHBvbHlub21pYWxcclxuICAgICAqL1xyXG4gICAgTW9kdWx1c1BvbHkucHJvdG90eXBlLmdldERlZ3JlZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoIC0gMTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gdHJ1ZSBpZmYgdGhpcyBwb2x5bm9taWFsIGlzIHRoZSBtb25vbWlhbCBcIjBcIlxyXG4gICAgICovXHJcbiAgICBNb2R1bHVzUG9seS5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50c1swXSA9PT0gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gY29lZmZpY2llbnQgb2YgeF5kZWdyZWUgdGVybSBpbiB0aGlzIHBvbHlub21pYWxcclxuICAgICAqL1xyXG4gICAgTW9kdWx1c1BvbHkucHJvdG90eXBlLmdldENvZWZmaWNpZW50ID0gZnVuY3Rpb24gKGRlZ3JlZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvZWZmaWNpZW50c1t0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGggLSAxIC0gZGVncmVlXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gZXZhbHVhdGlvbiBvZiB0aGlzIHBvbHlub21pYWwgYXQgYSBnaXZlbiBwb2ludFxyXG4gICAgICovXHJcbiAgICBNb2R1bHVzUG9seS5wcm90b3R5cGUuZXZhbHVhdGVBdCA9IGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgaWYgKGEgPT09IDApIHtcclxuICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gdGhlIHheMCBjb2VmZmljaWVudFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2VmZmljaWVudCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGEgPT09IDEpIHtcclxuICAgICAgICAgICAgLy8gSnVzdCB0aGUgc3VtIG9mIHRoZSBjb2VmZmljaWVudHNcclxuICAgICAgICAgICAgdmFyIHN1bSA9IC8qaW50Ki8gMDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5jb2VmZmljaWVudHMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvZWZmaWNpZW50ID0gX2MudmFsdWUgLyppbnQqLztcclxuICAgICAgICAgICAgICAgICAgICBzdW0gPSB0aGlzLmZpZWxkLmFkZChzdW0sIGNvZWZmaWNpZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSAvKmludCovIHRoaXMuY29lZmZpY2llbnRzWzBdO1xyXG4gICAgICAgIHZhciBzaXplID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMTsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpZWxkLmFkZCh0aGlzLmZpZWxkLm11bHRpcGx5KGEsIHJlc3VsdCksIHRoaXMuY29lZmZpY2llbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBNb2R1bHVzUG9seS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG90aGVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmZpZWxkLmVxdWFscyhvdGhlci5maWVsZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ01vZHVsdXNQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIE1vZHVsdXNHRiBmaWVsZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3RoZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNtYWxsZXJDb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcclxuICAgICAgICB2YXIgbGFyZ2VyQ29lZmZpY2llbnRzID0gb3RoZXIuY29lZmZpY2llbnRzO1xyXG4gICAgICAgIGlmIChzbWFsbGVyQ29lZmZpY2llbnRzLmxlbmd0aCA+IGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIHRlbXAgPSBzbWFsbGVyQ29lZmZpY2llbnRzO1xyXG4gICAgICAgICAgICBzbWFsbGVyQ29lZmZpY2llbnRzID0gbGFyZ2VyQ29lZmZpY2llbnRzO1xyXG4gICAgICAgICAgICBsYXJnZXJDb2VmZmljaWVudHMgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3VtRGlmZiA9IG5ldyBJbnQzMkFycmF5KGxhcmdlckNvZWZmaWNpZW50cy5sZW5ndGgpO1xyXG4gICAgICAgIHZhciBsZW5ndGhEaWZmID0gLyppbnQqLyBsYXJnZXJDb2VmZmljaWVudHMubGVuZ3RoIC0gc21hbGxlckNvZWZmaWNpZW50cy5sZW5ndGg7XHJcbiAgICAgICAgLy8gQ29weSBoaWdoLW9yZGVyIHRlcm1zIG9ubHkgZm91bmQgaW4gaGlnaGVyLWRlZ3JlZSBwb2x5bm9taWFsJ3MgY29lZmZpY2llbnRzXHJcbiAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkobGFyZ2VyQ29lZmZpY2llbnRzLCAwLCBzdW1EaWZmLCAwLCBsZW5ndGhEaWZmKTtcclxuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSBsZW5ndGhEaWZmOyBpIDwgbGFyZ2VyQ29lZmZpY2llbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN1bURpZmZbaV0gPSB0aGlzLmZpZWxkLmFkZChzbWFsbGVyQ29lZmZpY2llbnRzW2kgLSBsZW5ndGhEaWZmXSwgbGFyZ2VyQ29lZmZpY2llbnRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBzdW1EaWZmKTtcclxuICAgIH07XHJcbiAgICBNb2R1bHVzUG9seS5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnTW9kdWx1c1BvbHlzIGRvIG5vdCBoYXZlIHNhbWUgTW9kdWx1c0dGIGZpZWxkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvdGhlci5pc1plcm8oKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0aXZlKCkpO1xyXG4gICAgfTtcclxuICAgIE1vZHVsdXNQb2x5LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdGhlcikge1xyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIE1vZHVsdXNQb2x5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5T3RoZXIob3RoZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhcihvdGhlcik7XHJcbiAgICB9O1xyXG4gICAgTW9kdWx1c1BvbHkucHJvdG90eXBlLm11bHRpcGx5T3RoZXIgPSBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZmllbGQuZXF1YWxzKG90aGVyLmZpZWxkKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgnTW9kdWx1c1BvbHlzIGRvIG5vdCBoYXZlIHNhbWUgTW9kdWx1c0dGIGZpZWxkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpIHx8IG90aGVyLmlzWmVybygpKSB7XHJcbiAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLmZpZWxkLmdldFplcm8oKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBuZXcgSW50MzJBcnJheShbMF0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFDb2VmZmljaWVudHMgPSB0aGlzLmNvZWZmaWNpZW50cztcclxuICAgICAgICB2YXIgYUxlbmd0aCA9IC8qaW50Ki8gYUNvZWZmaWNpZW50cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGJDb2VmZmljaWVudHMgPSBvdGhlci5jb2VmZmljaWVudHM7XHJcbiAgICAgICAgdmFyIGJMZW5ndGggPSAvKmludCovIGJDb2VmZmljaWVudHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBwcm9kdWN0ID0gbmV3IEludDMyQXJyYXkoYUxlbmd0aCArIGJMZW5ndGggLSAxKTtcclxuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgYUxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhQ29lZmYgPSAvKmludCovIGFDb2VmZmljaWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogLyppbnQqLyA9IDA7IGogPCBiTGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHByb2R1Y3RbaSArIGpdID0gdGhpcy5maWVsZC5hZGQocHJvZHVjdFtpICsgal0sIHRoaXMuZmllbGQubXVsdGlwbHkoYUNvZWZmLCBiQ29lZmZpY2llbnRzW2pdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seSh0aGlzLmZpZWxkLCBwcm9kdWN0KTtcclxuICAgIH07XHJcbiAgICBNb2R1bHVzUG9seS5wcm90b3R5cGUubmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSAvKmludCovIHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgbmVnYXRpdmVDb2VmZmljaWVudHMgPSBuZXcgSW50MzJBcnJheShzaXplKTtcclxuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5lZ2F0aXZlQ29lZmZpY2llbnRzW2ldID0gdGhpcy5maWVsZC5zdWJ0cmFjdCgwLCB0aGlzLmNvZWZmaWNpZW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgbmVnYXRpdmVDb2VmZmljaWVudHMpO1xyXG4gICAgfTtcclxuICAgIE1vZHVsdXNQb2x5LnByb3RvdHlwZS5tdWx0aXBseVNjYWxhciA9IGZ1bmN0aW9uIChzY2FsYXIpIHtcclxuICAgICAgICBpZiAoc2NhbGFyID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kdWx1c1BvbHkodGhpcy5maWVsZCwgbmV3IEludDMyQXJyYXkoWzBdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY2FsYXIgPT09IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaXplID0gLyppbnQqLyB0aGlzLmNvZWZmaWNpZW50cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHByb2R1Y3QgPSBuZXcgSW50MzJBcnJheShzaXplKTtcclxuICAgICAgICBmb3IgKHZhciBpIC8qaW50Ki8gPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHByb2R1Y3RbaV0gPSB0aGlzLmZpZWxkLm11bHRpcGx5KHRoaXMuY29lZmZpY2llbnRzW2ldLCBzY2FsYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIHByb2R1Y3QpO1xyXG4gICAgfTtcclxuICAgIE1vZHVsdXNQb2x5LnByb3RvdHlwZS5tdWx0aXBseUJ5TW9ub21pYWwgPSBmdW5jdGlvbiAoZGVncmVlLCBjb2VmZmljaWVudCkge1xyXG4gICAgICAgIGlmIChkZWdyZWUgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2VmZmljaWVudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIG5ldyBJbnQzMkFycmF5KFswXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2l6ZSA9IC8qaW50Ki8gdGhpcy5jb2VmZmljaWVudHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBwcm9kdWN0ID0gbmV3IEludDMyQXJyYXkoc2l6ZSArIGRlZ3JlZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSAvKmludCovID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBwcm9kdWN0W2ldID0gdGhpcy5maWVsZC5tdWx0aXBseSh0aGlzLmNvZWZmaWNpZW50c1tpXSwgY29lZmZpY2llbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IE1vZHVsdXNQb2x5KHRoaXMuZmllbGQsIHByb2R1Y3QpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBNb2R1bHVzUG9seVtdIGRpdmlkZShvdGhlcjogTW9kdWx1c1BvbHkpIHtcclxuICAgICAgaWYgKCFmaWVsZC5lcXVhbHMob3RoZXIuZmllbGQpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbihcIk1vZHVsdXNQb2x5cyBkbyBub3QgaGF2ZSBzYW1lIE1vZHVsdXNHRiBmaWVsZFwiKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAob3RoZXIuaXNaZXJvKCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKFwiRGl2aWRlIGJ5IDBcIik7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgbGV0IHF1b3RpZW50OiBNb2R1bHVzUG9seSA9IGZpZWxkLmdldFplcm8oKTtcclxuICAgICAgbGV0IHJlbWFpbmRlcjogTW9kdWx1c1BvbHkgPSB0aGlzO1xyXG4gIFxyXG4gICAgICBsZXQgZGVub21pbmF0b3JMZWFkaW5nVGVybTogLyppbnQvIG51bWJlciA9IG90aGVyLmdldENvZWZmaWNpZW50KG90aGVyLmdldERlZ3JlZSgpKTtcclxuICAgICAgbGV0IGludmVyc2VEZW5vbWluYXRvckxlYWRpbmdUZXJtOiAvKmludC8gbnVtYmVyID0gZmllbGQuaW52ZXJzZShkZW5vbWluYXRvckxlYWRpbmdUZXJtKTtcclxuICBcclxuICAgICAgd2hpbGUgKHJlbWFpbmRlci5nZXREZWdyZWUoKSA+PSBvdGhlci5nZXREZWdyZWUoKSAmJiAhcmVtYWluZGVyLmlzWmVybygpKSB7XHJcbiAgICAgICAgbGV0IGRlZ3JlZURpZmZlcmVuY2U6IC8qaW50LyBudW1iZXIgPSByZW1haW5kZXIuZ2V0RGVncmVlKCkgLSBvdGhlci5nZXREZWdyZWUoKTtcclxuICAgICAgICBsZXQgc2NhbGU6IC8qaW50LyBudW1iZXIgPSBmaWVsZC5tdWx0aXBseShyZW1haW5kZXIuZ2V0Q29lZmZpY2llbnQocmVtYWluZGVyLmdldERlZ3JlZSgpKSwgaW52ZXJzZURlbm9taW5hdG9yTGVhZGluZ1Rlcm0pO1xyXG4gICAgICAgIGxldCB0ZXJtOiBNb2R1bHVzUG9seSA9IG90aGVyLm11bHRpcGx5QnlNb25vbWlhbChkZWdyZWVEaWZmZXJlbmNlLCBzY2FsZSk7XHJcbiAgICAgICAgbGV0IGl0ZXJhdGlvblF1b3RpZW50OiBNb2R1bHVzUG9seSA9IGZpZWxkLmJ1aWxkTW9ub21pYWwoZGVncmVlRGlmZmVyZW5jZSwgc2NhbGUpO1xyXG4gICAgICAgIHF1b3RpZW50ID0gcXVvdGllbnQuYWRkKGl0ZXJhdGlvblF1b3RpZW50KTtcclxuICAgICAgICByZW1haW5kZXIgPSByZW1haW5kZXIuc3VidHJhY3QodGVybSk7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgcmV0dXJuIG5ldyBNb2R1bHVzUG9seVtdIHsgcXVvdGllbnQsIHJlbWFpbmRlciB9O1xyXG4gICAgfVxyXG4gICAgKi9cclxuICAgIC8vIEBPdmVycmlkZVxyXG4gICAgTW9kdWx1c1BvbHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgU3RyaW5nQnVpbGRlcl8xLmRlZmF1bHQoIC8qOCAqIHRoaXMuZ2V0RGVncmVlKCkqLyk7IC8vIGR5bmFtaWMgc3RyaW5nIHNpemUgaW4gSlNcclxuICAgICAgICBmb3IgKHZhciBkZWdyZWUgLyppbnQqLyA9IHRoaXMuZ2V0RGVncmVlKCk7IGRlZ3JlZSA+PSAwOyBkZWdyZWUtLSkge1xyXG4gICAgICAgICAgICB2YXIgY29lZmZpY2llbnQgPSAvKmludCovIHRoaXMuZ2V0Q29lZmZpY2llbnQoZGVncmVlKTtcclxuICAgICAgICAgICAgaWYgKGNvZWZmaWNpZW50ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29lZmZpY2llbnQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnIC0gJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29lZmZpY2llbnQgPSAtY29lZmZpY2llbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCgpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcgKyAnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVncmVlID09PSAwIHx8IGNvZWZmaWNpZW50ICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChjb2VmZmljaWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGVncmVlICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCd4Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCd4XicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKGRlZ3JlZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQudG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTW9kdWx1c1BvbHk7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vZHVsdXNQb2x5O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Nb2R1bHVzUG9seS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuKiBDb3B5cmlnaHQgMjAwOSBaWGluZyBhdXRob3JzXHJcbipcclxuKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4qIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4qIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4qIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBpbXBvcnQgY29tLmdvb2dsZS56eGluZy5Ob3RGb3VuZEV4Y2VwdGlvbjtcclxuLy8gaW1wb3J0IGNvbS5nb29nbGUuenhpbmcuUmVzdWx0UG9pbnQ7XHJcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uLy4uL1Jlc3VsdFBvaW50XCIpO1xyXG52YXIgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TeXN0ZW1cIik7XHJcbnZhciBBcnJheXNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0FycmF5c1wiKTtcclxudmFyIFBERjQxN0RldGVjdG9yUmVzdWx0XzEgPSByZXF1aXJlKFwiLi9QREY0MTdEZXRlY3RvclJlc3VsdFwiKTtcclxuLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7XHJcbi8vIGltcG9ydCBqYXZhLnV0aWwuQXJyYXlzO1xyXG4vLyBpbXBvcnQgamF2YS51dGlsLkxpc3Q7XHJcbi8vIGltcG9ydCBqYXZhLnV0aWwuTWFwO1xyXG4vKipcclxuICogPHA+RW5jYXBzdWxhdGVzIGxvZ2ljIHRoYXQgY2FuIGRldGVjdCBhIFBERjQxNyBDb2RlIGluIGFuIGltYWdlLCBldmVuIGlmIHRoZVxyXG4gKiBQREY0MTcgQ29kZSBpcyByb3RhdGVkIG9yIHNrZXdlZCwgb3IgcGFydGlhbGx5IG9ic2N1cmVkLjwvcD5cclxuICpcclxuICogQGF1dGhvciBTSVRBIExhYiAoa2V2aW4ub3N1bGxpdmFuQHNpdGEuYWVybylcclxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbilcclxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XHJcbiAqL1xyXG52YXIgRGV0ZWN0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEZXRlY3RvcigpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogPHA+RGV0ZWN0cyBhIFBERjQxNyBDb2RlIGluIGFuIGltYWdlLiBPbmx5IGNoZWNrcyAwIGFuZCAxODAgZGVncmVlIHJvdGF0aW9ucy48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGltYWdlIGJhcmNvZGUgaW1hZ2UgdG8gZGVjb2RlXHJcbiAgICAgKiBAcGFyYW0gaGludHMgb3B0aW9uYWwgaGludHMgdG8gZGV0ZWN0b3JcclxuICAgICAqIEBwYXJhbSBtdWx0aXBsZSBpZiB0cnVlLCB0aGVuIHRoZSBpbWFnZSBpcyBzZWFyY2hlZCBmb3IgbXVsdGlwbGUgY29kZXMuIElmIGZhbHNlLCB0aGVuIGF0IG1vc3Qgb25lIGNvZGUgd2lsbFxyXG4gICAgICogYmUgZm91bmQgYW5kIHJldHVybmVkXHJcbiAgICAgKiBAcmV0dXJuIHtAbGluayBQREY0MTdEZXRlY3RvclJlc3VsdH0gZW5jYXBzdWxhdGluZyByZXN1bHRzIG9mIGRldGVjdGluZyBhIFBERjQxNyBjb2RlXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIG5vIFBERjQxNyBDb2RlIGNhbiBiZSBmb3VuZFxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5kZXRlY3RNdWx0aXBsZSA9IGZ1bmN0aW9uIChpbWFnZSwgaGludHMsIG11bHRpcGxlKSB7XHJcbiAgICAgICAgLy8gVE9ETyBkZXRlY3Rpb24gaW1wcm92ZW1lbnQsIHRyeUhhcmRlciBjb3VsZCB0cnkgc2V2ZXJhbCBkaWZmZXJlbnQgbHVtaW5hbmNlIHRocmVzaG9sZHMvYmxhY2twb2ludHMgb3IgZXZlblxyXG4gICAgICAgIC8vIGRpZmZlcmVudCBiaW5hcml6ZXJzXHJcbiAgICAgICAgLy8gYm9vbGVhbiB0cnlIYXJkZXIgPSBoaW50cyAhPSBudWxsICYmIGhpbnRzLmNvbnRhaW5zS2V5KERlY29kZUhpbnRUeXBlLlRSWV9IQVJERVIpO1xyXG4gICAgICAgIHZhciBiaXRNYXRyaXggPSBpbWFnZS5nZXRCbGFja01hdHJpeCgpO1xyXG4gICAgICAgIHZhciBiYXJjb2RlQ29vcmRpbmF0ZXMgPSBEZXRlY3Rvci5kZXRlY3QobXVsdGlwbGUsIGJpdE1hdHJpeCk7XHJcbiAgICAgICAgaWYgKCFiYXJjb2RlQ29vcmRpbmF0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGJpdE1hdHJpeCA9IGJpdE1hdHJpeC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBiaXRNYXRyaXgucm90YXRlMTgwKCk7XHJcbiAgICAgICAgICAgIGJhcmNvZGVDb29yZGluYXRlcyA9IERldGVjdG9yLmRldGVjdChtdWx0aXBsZSwgYml0TWF0cml4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQREY0MTdEZXRlY3RvclJlc3VsdF8xLmRlZmF1bHQoYml0TWF0cml4LCBiYXJjb2RlQ29vcmRpbmF0ZXMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZWN0cyBQREY0MTcgY29kZXMgaW4gYW4gaW1hZ2UuIE9ubHkgY2hlY2tzIDAgZGVncmVlIHJvdGF0aW9uXHJcbiAgICAgKiBAcGFyYW0gbXVsdGlwbGUgaWYgdHJ1ZSwgdGhlbiB0aGUgaW1hZ2UgaXMgc2VhcmNoZWQgZm9yIG11bHRpcGxlIGNvZGVzLiBJZiBmYWxzZSwgdGhlbiBhdCBtb3N0IG9uZSBjb2RlIHdpbGxcclxuICAgICAqIGJlIGZvdW5kIGFuZCByZXR1cm5lZFxyXG4gICAgICogQHBhcmFtIGJpdE1hdHJpeCBiaXQgbWF0cml4IHRvIGRldGVjdCBiYXJjb2RlcyBpblxyXG4gICAgICogQHJldHVybiBMaXN0IG9mIFJlc3VsdFBvaW50IGFycmF5cyBjb250YWluaW5nIHRoZSBjb29yZGluYXRlcyBvZiBmb3VuZCBiYXJjb2Rlc1xyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5kZXRlY3QgPSBmdW5jdGlvbiAobXVsdGlwbGUsIGJpdE1hdHJpeCkge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIHZhciBiYXJjb2RlQ29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB2YXIgcm93ID0gMDtcclxuICAgICAgICB2YXIgY29sdW1uID0gMDtcclxuICAgICAgICB2YXIgZm91bmRCYXJjb2RlSW5Sb3cgPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAocm93IDwgYml0TWF0cml4LmdldEhlaWdodCgpKSB7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IERldGVjdG9yLmZpbmRWZXJ0aWNlcyhiaXRNYXRyaXgsIHJvdywgY29sdW1uKTtcclxuICAgICAgICAgICAgaWYgKHZlcnRpY2VzWzBdID09IG51bGwgJiYgdmVydGljZXNbM10gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZEJhcmNvZGVJblJvdykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRpZG4ndCBmaW5kIGFueSBiYXJjb2RlIHNvIHRoYXQncyB0aGUgZW5kIG9mIHNlYXJjaGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gd2UgZGlkbid0IGZpbmQgYSBiYXJjb2RlIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBjb2x1bW4gYW5kIHJvdy4gVHJ5IGFnYWluIGZyb20gdGhlIGZpcnN0IGNvbHVtbiBhbmQgc2xpZ2h0bHlcclxuICAgICAgICAgICAgICAgIC8vIGJlbG93IHRoZSBsb3dlc3QgYmFyY29kZSB3ZSBmb3VuZCBzbyBmYXIuXHJcbiAgICAgICAgICAgICAgICBmb3VuZEJhcmNvZGVJblJvdyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY29sdW1uID0gMDtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYmFyY29kZUNvb3JkaW5hdGVzXzEgPSBfX3ZhbHVlcyhiYXJjb2RlQ29vcmRpbmF0ZXMpLCBiYXJjb2RlQ29vcmRpbmF0ZXNfMV8xID0gYmFyY29kZUNvb3JkaW5hdGVzXzEubmV4dCgpOyAhYmFyY29kZUNvb3JkaW5hdGVzXzFfMS5kb25lOyBiYXJjb2RlQ29vcmRpbmF0ZXNfMV8xID0gYmFyY29kZUNvb3JkaW5hdGVzXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiYXJjb2RlQ29vcmRpbmF0ZSA9IGJhcmNvZGVDb29yZGluYXRlc18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXJjb2RlQ29vcmRpbmF0ZVsxXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgPSBNYXRoLnRydW5jKE1hdGgubWF4KHJvdywgYmFyY29kZUNvb3JkaW5hdGVbMV0uZ2V0WSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhcmNvZGVDb29yZGluYXRlWzNdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IE1hdGgubWF4KHJvdywgTWF0aC50cnVuYyhiYXJjb2RlQ29vcmRpbmF0ZVszXS5nZXRZKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFyY29kZUNvb3JkaW5hdGVzXzFfMSAmJiAhYmFyY29kZUNvb3JkaW5hdGVzXzFfMS5kb25lICYmIChfYSA9IGJhcmNvZGVDb29yZGluYXRlc18xLnJldHVybikpIF9hLmNhbGwoYmFyY29kZUNvb3JkaW5hdGVzXzEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByb3cgKz0gRGV0ZWN0b3IuUk9XX1NURVA7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3VuZEJhcmNvZGVJblJvdyA9IHRydWU7XHJcbiAgICAgICAgICAgIGJhcmNvZGVDb29yZGluYXRlcy5wdXNoKHZlcnRpY2VzKTtcclxuICAgICAgICAgICAgaWYgKCFtdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSByaWdodCByb3cgaW5kaWNhdG9yIGNvbHVtbiwgdGhlbiBjb250aW51ZSB0aGUgc2VhcmNoIGZvciB0aGUgbmV4dCBiYXJjb2RlIGFmdGVyIHRoZVxyXG4gICAgICAgICAgICAvLyBzdGFydCBwYXR0ZXJuIG9mIHRoZSBiYXJjb2RlIGp1c3QgZm91bmQuXHJcbiAgICAgICAgICAgIGlmICh2ZXJ0aWNlc1syXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBNYXRoLnRydW5jKHZlcnRpY2VzWzJdLmdldFgoKSk7XHJcbiAgICAgICAgICAgICAgICByb3cgPSBNYXRoLnRydW5jKHZlcnRpY2VzWzJdLmdldFkoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBNYXRoLnRydW5jKHZlcnRpY2VzWzRdLmdldFgoKSk7XHJcbiAgICAgICAgICAgICAgICByb3cgPSBNYXRoLnRydW5jKHZlcnRpY2VzWzRdLmdldFkoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJhcmNvZGVDb29yZGluYXRlcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExvY2F0ZSB0aGUgdmVydGljZXMgYW5kIHRoZSBjb2Rld29yZHMgYXJlYSBvZiBhIGJsYWNrIGJsb2IgdXNpbmcgdGhlIFN0YXJ0XHJcbiAgICAgKiBhbmQgU3RvcCBwYXR0ZXJucyBhcyBsb2NhdG9ycy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gbWF0cml4IHRoZSBzY2FubmVkIGJhcmNvZGUgaW1hZ2UuXHJcbiAgICAgKiBAcmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHZlcnRpY2VzOlxyXG4gICAgICogICAgICAgICAgIHZlcnRpY2VzWzBdIHgsIHkgdG9wIGxlZnQgYmFyY29kZVxyXG4gICAgICogICAgICAgICAgIHZlcnRpY2VzWzFdIHgsIHkgYm90dG9tIGxlZnQgYmFyY29kZVxyXG4gICAgICogICAgICAgICAgIHZlcnRpY2VzWzJdIHgsIHkgdG9wIHJpZ2h0IGJhcmNvZGVcclxuICAgICAqICAgICAgICAgICB2ZXJ0aWNlc1szXSB4LCB5IGJvdHRvbSByaWdodCBiYXJjb2RlXHJcbiAgICAgKiAgICAgICAgICAgdmVydGljZXNbNF0geCwgeSB0b3AgbGVmdCBjb2Rld29yZCBhcmVhXHJcbiAgICAgKiAgICAgICAgICAgdmVydGljZXNbNV0geCwgeSBib3R0b20gbGVmdCBjb2Rld29yZCBhcmVhXHJcbiAgICAgKiAgICAgICAgICAgdmVydGljZXNbNl0geCwgeSB0b3AgcmlnaHQgY29kZXdvcmQgYXJlYVxyXG4gICAgICogICAgICAgICAgIHZlcnRpY2VzWzddIHgsIHkgYm90dG9tIHJpZ2h0IGNvZGV3b3JkIGFyZWFcclxuICAgICAqL1xyXG4gICAgRGV0ZWN0b3IuZmluZFZlcnRpY2VzID0gZnVuY3Rpb24gKG1hdHJpeCwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IG1hdHJpeC5nZXRIZWlnaHQoKTtcclxuICAgICAgICB2YXIgd2lkdGggPSBtYXRyaXguZ2V0V2lkdGgoKTtcclxuICAgICAgICAvLyBjb25zdCByZXN1bHQgPSBuZXcgUmVzdWx0UG9pbnRbOF07XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSg4KTtcclxuICAgICAgICBEZXRlY3Rvci5jb3B5VG9SZXN1bHQocmVzdWx0LCBEZXRlY3Rvci5maW5kUm93c1dpdGhQYXR0ZXJuKG1hdHJpeCwgaGVpZ2h0LCB3aWR0aCwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCBEZXRlY3Rvci5TVEFSVF9QQVRURVJOKSwgRGV0ZWN0b3IuSU5ERVhFU19TVEFSVF9QQVRURVJOKTtcclxuICAgICAgICBpZiAocmVzdWx0WzRdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBNYXRoLnRydW5jKHJlc3VsdFs0XS5nZXRYKCkpO1xyXG4gICAgICAgICAgICBzdGFydFJvdyA9IE1hdGgudHJ1bmMocmVzdWx0WzRdLmdldFkoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIERldGVjdG9yLmNvcHlUb1Jlc3VsdChyZXN1bHQsIERldGVjdG9yLmZpbmRSb3dzV2l0aFBhdHRlcm4obWF0cml4LCBoZWlnaHQsIHdpZHRoLCBzdGFydFJvdywgc3RhcnRDb2x1bW4sIERldGVjdG9yLlNUT1BfUEFUVEVSTiksIERldGVjdG9yLklOREVYRVNfU1RPUF9QQVRURVJOKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIERldGVjdG9yLmNvcHlUb1Jlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQsIHRtcFJlc3VsdCwgZGVzdGluYXRpb25JbmRleGVzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXN0aW5hdGlvbkluZGV4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0W2Rlc3RpbmF0aW9uSW5kZXhlc1tpXV0gPSB0bXBSZXN1bHRbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERldGVjdG9yLmZpbmRSb3dzV2l0aFBhdHRlcm4gPSBmdW5jdGlvbiAobWF0cml4LCBoZWlnaHQsIHdpZHRoLCBzdGFydFJvdywgc3RhcnRDb2x1bW4sIHBhdHRlcm4pIHtcclxuICAgICAgICAvLyBjb25zdCByZXN1bHQgPSBuZXcgUmVzdWx0UG9pbnRbNF07XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSg0KTtcclxuICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgY291bnRlcnMgPSBuZXcgSW50MzJBcnJheShwYXR0ZXJuLmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICg7IHN0YXJ0Um93IDwgaGVpZ2h0OyBzdGFydFJvdyArPSBEZXRlY3Rvci5ST1dfU1RFUCkge1xyXG4gICAgICAgICAgICB2YXIgbG9jID0gRGV0ZWN0b3IuZmluZEd1YXJkUGF0dGVybihtYXRyaXgsIHN0YXJ0Q29sdW1uLCBzdGFydFJvdywgd2lkdGgsIGZhbHNlLCBwYXR0ZXJuLCBjb3VudGVycyk7XHJcbiAgICAgICAgICAgIGlmIChsb2MgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0YXJ0Um93ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c1Jvd0xvYyA9IERldGVjdG9yLmZpbmRHdWFyZFBhdHRlcm4obWF0cml4LCBzdGFydENvbHVtbiwgLS1zdGFydFJvdywgd2lkdGgsIGZhbHNlLCBwYXR0ZXJuLCBjb3VudGVycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzUm93TG9jICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jID0gcHJldmlvdXNSb3dMb2M7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFJvdysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbMF0gPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KGxvY1swXSwgc3RhcnRSb3cpO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0WzFdID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChsb2NbMV0sIHN0YXJ0Um93KTtcclxuICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdG9wUm93ID0gc3RhcnRSb3cgKyAxO1xyXG4gICAgICAgIC8vIExhc3Qgcm93IG9mIHRoZSBjdXJyZW50IHN5bWJvbCB0aGF0IGNvbnRhaW5zIHBhdHRlcm5cclxuICAgICAgICBpZiAoZm91bmQpIHtcclxuICAgICAgICAgICAgdmFyIHNraXBwZWRSb3dDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1Jvd0xvYyA9IEludDMyQXJyYXkuZnJvbShbTWF0aC50cnVuYyhyZXN1bHRbMF0uZ2V0WCgpKSwgTWF0aC50cnVuYyhyZXN1bHRbMV0uZ2V0WCgpKV0pO1xyXG4gICAgICAgICAgICBmb3IgKDsgc3RvcFJvdyA8IGhlaWdodDsgc3RvcFJvdysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jID0gRGV0ZWN0b3IuZmluZEd1YXJkUGF0dGVybihtYXRyaXgsIHByZXZpb3VzUm93TG9jWzBdLCBzdG9wUm93LCB3aWR0aCwgZmFsc2UsIHBhdHRlcm4sIGNvdW50ZXJzKTtcclxuICAgICAgICAgICAgICAgIC8vIGEgZm91bmQgcGF0dGVybiBpcyBvbmx5IGNvbnNpZGVyZWQgdG8gYmVsb25nIHRvIHRoZSBzYW1lIGJhcmNvZGUgaWYgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zXHJcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBkaWZmZXIgdG9vIG11Y2guIFBhdHRlcm4gZHJpZnQgc2hvdWxkIGJlIG5vdCBiaWdnZXIgdGhhbiB0d28gZm9yIGNvbnNlY3V0aXZlIHJvd3MuIFdpdGhcclxuICAgICAgICAgICAgICAgIC8vIGEgaGlnaGVyIG51bWJlciBvZiBza2lwcGVkIHJvd3MgZHJpZnQgY291bGQgYmUgbGFyZ2VyLiBUbyBrZWVwIGl0IHNpbXBsZSBmb3Igbm93LCB3ZSBhbGxvdyBhIHNsaWdodGx5XHJcbiAgICAgICAgICAgICAgICAvLyBsYXJnZXIgZHJpZnQgYW5kIGRvbid0IGNoZWNrIGZvciBza2lwcGVkIHJvd3MuXHJcbiAgICAgICAgICAgICAgICBpZiAobG9jICE9IG51bGwgJiZcclxuICAgICAgICAgICAgICAgICAgICBNYXRoLmFicyhwcmV2aW91c1Jvd0xvY1swXSAtIGxvY1swXSkgPCBEZXRlY3Rvci5NQVhfUEFUVEVSTl9EUklGVCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHByZXZpb3VzUm93TG9jWzFdIC0gbG9jWzFdKSA8IERldGVjdG9yLk1BWF9QQVRURVJOX0RSSUZUKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNSb3dMb2MgPSBsb2M7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcHBlZFJvd0NvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwcGVkUm93Q291bnQgPiBEZXRlY3Rvci5TS0lQUEVEX1JPV19DT1VOVF9NQVgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkUm93Q291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3RvcFJvdyAtPSBza2lwcGVkUm93Q291bnQgKyAxO1xyXG4gICAgICAgICAgICByZXN1bHRbMl0gPSBuZXcgUmVzdWx0UG9pbnRfMS5kZWZhdWx0KHByZXZpb3VzUm93TG9jWzBdLCBzdG9wUm93KTtcclxuICAgICAgICAgICAgcmVzdWx0WzNdID0gbmV3IFJlc3VsdFBvaW50XzEuZGVmYXVsdChwcmV2aW91c1Jvd0xvY1sxXSwgc3RvcFJvdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdG9wUm93IC0gc3RhcnRSb3cgPCBEZXRlY3Rvci5CQVJDT0RFX01JTl9IRUlHSFQpIHtcclxuICAgICAgICAgICAgQXJyYXlzXzEuZGVmYXVsdC5maWxsKHJlc3VsdCwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbWF0cml4IHJvdyBvZiBibGFjay93aGl0ZSB2YWx1ZXMgdG8gc2VhcmNoXHJcbiAgICAgKiBAcGFyYW0gY29sdW1uIHggcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoXHJcbiAgICAgKiBAcGFyYW0gcm93IHkgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggdGhlIG51bWJlciBvZiBwaXhlbHMgdG8gc2VhcmNoIG9uIHRoaXMgcm93XHJcbiAgICAgKiBAcGFyYW0gcGF0dGVybiBwYXR0ZXJuIG9mIGNvdW50cyBvZiBudW1iZXIgb2YgYmxhY2sgYW5kIHdoaXRlIHBpeGVscyB0aGF0IGFyZVxyXG4gICAgICogICAgICAgICAgICAgICAgIGJlaW5nIHNlYXJjaGVkIGZvciBhcyBhIHBhdHRlcm5cclxuICAgICAqIEBwYXJhbSBjb3VudGVycyBhcnJheSBvZiBjb3VudGVycywgYXMgbG9uZyBhcyBwYXR0ZXJuLCB0byByZS11c2VcclxuICAgICAqIEByZXR1cm4gc3RhcnQvZW5kIGhvcml6b250YWwgb2Zmc2V0IG9mIGd1YXJkIHBhdHRlcm4sIGFzIGFuIGFycmF5IG9mIHR3byBpbnRzLlxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5maW5kR3VhcmRQYXR0ZXJuID0gZnVuY3Rpb24gKG1hdHJpeCwgY29sdW1uLCByb3csIHdpZHRoLCB3aGl0ZUZpcnN0LCBwYXR0ZXJuLCBjb3VudGVycykge1xyXG4gICAgICAgIEFycmF5c18xLmRlZmF1bHQuZmlsbFdpdGhpbihjb3VudGVycywgMCwgY291bnRlcnMubGVuZ3RoLCAwKTtcclxuICAgICAgICB2YXIgcGF0dGVyblN0YXJ0ID0gY29sdW1uO1xyXG4gICAgICAgIHZhciBwaXhlbERyaWZ0ID0gMDtcclxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgYmxhY2sgcGl4ZWxzIGxlZnQgb2YgdGhlIGN1cnJlbnQgcGl4ZWwgc2hpZnQgdG8gdGhlIGxlZnQsIGJ1dCBvbmx5IGZvciBNQVhfUElYRUxfRFJJRlQgcGl4ZWxzXHJcbiAgICAgICAgd2hpbGUgKG1hdHJpeC5nZXQocGF0dGVyblN0YXJ0LCByb3cpICYmIHBhdHRlcm5TdGFydCA+IDAgJiYgcGl4ZWxEcmlmdCsrIDwgRGV0ZWN0b3IuTUFYX1BJWEVMX0RSSUZUKSB7XHJcbiAgICAgICAgICAgIHBhdHRlcm5TdGFydC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgeCA9IHBhdHRlcm5TdGFydDtcclxuICAgICAgICB2YXIgY291bnRlclBvc2l0aW9uID0gMDtcclxuICAgICAgICB2YXIgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGlzV2hpdGUgPSB3aGl0ZUZpcnN0OyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSBtYXRyaXguZ2V0KHgsIHJvdyk7XHJcbiAgICAgICAgICAgIGlmIChwaXhlbCAhPT0gaXNXaGl0ZSkge1xyXG4gICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJQb3NpdGlvbiA9PT0gcGF0dGVybkxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoRGV0ZWN0b3IucGF0dGVybk1hdGNoVmFyaWFuY2UoY291bnRlcnMsIHBhdHRlcm4sIERldGVjdG9yLk1BWF9JTkRJVklEVUFMX1ZBUklBTkNFKSA8IERldGVjdG9yLk1BWF9BVkdfVkFSSUFOQ0UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KFtwYXR0ZXJuU3RhcnQsIHhdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVyblN0YXJ0ICs9IGNvdW50ZXJzWzBdICsgY291bnRlcnNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkoY291bnRlcnMsIDIsIGNvdW50ZXJzLCAwLCBjb3VudGVyUG9zaXRpb24gLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1tjb3VudGVyUG9zaXRpb24gLSAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnNbY291bnRlclBvc2l0aW9uXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlclBvc2l0aW9uLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyUG9zaXRpb24rKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvdW50ZXJzW2NvdW50ZXJQb3NpdGlvbl0gPSAxO1xyXG4gICAgICAgICAgICAgICAgaXNXaGl0ZSA9ICFpc1doaXRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb3VudGVyUG9zaXRpb24gPT09IHBhdHRlcm5MZW5ndGggLSAxICYmXHJcbiAgICAgICAgICAgIERldGVjdG9yLnBhdHRlcm5NYXRjaFZhcmlhbmNlKGNvdW50ZXJzLCBwYXR0ZXJuLCBEZXRlY3Rvci5NQVhfSU5ESVZJRFVBTF9WQVJJQU5DRSkgPCBEZXRlY3Rvci5NQVhfQVZHX1ZBUklBTkNFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheShbcGF0dGVyblN0YXJ0LCB4IC0gMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgaG93IGNsb3NlbHkgYSBzZXQgb2Ygb2JzZXJ2ZWQgY291bnRzIG9mIHJ1bnMgb2YgYmxhY2svd2hpdGVcclxuICAgICAqIHZhbHVlcyBtYXRjaGVzIGEgZ2l2ZW4gdGFyZ2V0IHBhdHRlcm4uIFRoaXMgaXMgcmVwb3J0ZWQgYXMgdGhlIHJhdGlvIG9mXHJcbiAgICAgKiB0aGUgdG90YWwgdmFyaWFuY2UgZnJvbSB0aGUgZXhwZWN0ZWQgcGF0dGVybiBwcm9wb3J0aW9ucyBhY3Jvc3MgYWxsXHJcbiAgICAgKiBwYXR0ZXJuIGVsZW1lbnRzLCB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwYXR0ZXJuLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb3VudGVycyBvYnNlcnZlZCBjb3VudGVyc1xyXG4gICAgICogQHBhcmFtIHBhdHRlcm4gZXhwZWN0ZWQgcGF0dGVyblxyXG4gICAgICogQHBhcmFtIG1heEluZGl2aWR1YWxWYXJpYW5jZSBUaGUgbW9zdCBhbnkgY291bnRlciBjYW4gZGlmZmVyIGJlZm9yZSB3ZSBnaXZlIHVwXHJcbiAgICAgKiBAcmV0dXJuIHJhdGlvIG9mIHRvdGFsIHZhcmlhbmNlIGJldHdlZW4gY291bnRlcnMgYW5kIHBhdHRlcm4gY29tcGFyZWQgdG8gdG90YWwgcGF0dGVybiBzaXplXHJcbiAgICAgKi9cclxuICAgIERldGVjdG9yLnBhdHRlcm5NYXRjaFZhcmlhbmNlID0gZnVuY3Rpb24gKGNvdW50ZXJzLCBwYXR0ZXJuLCBtYXhJbmRpdmlkdWFsVmFyaWFuY2UpIHtcclxuICAgICAgICB2YXIgbnVtQ291bnRlcnMgPSBjb3VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHRvdGFsID0gMDtcclxuICAgICAgICB2YXIgcGF0dGVybkxlbmd0aCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Db3VudGVyczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRvdGFsICs9IGNvdW50ZXJzW2ldO1xyXG4gICAgICAgICAgICBwYXR0ZXJuTGVuZ3RoICs9IHBhdHRlcm5baV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b3RhbCA8IHBhdHRlcm5MZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgZXZlbiBoYXZlIG9uZSBwaXhlbCBwZXIgdW5pdCBvZiBiYXIgd2lkdGgsIGFzc3VtZSB0aGlzXHJcbiAgICAgICAgICAgIC8vIGlzIHRvbyBzbWFsbCB0byByZWxpYWJseSBtYXRjaCwgc28gZmFpbDpcclxuICAgICAgICAgICAgcmV0dXJuIC8qRmxvYXQuUE9TSVRJVkVfSU5GSU5JVFkqLyBJbmZpbml0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gZmFrZSBmbG9hdGluZy1wb2ludCBtYXRoIGluIGludGVnZXJzLiBXZSBqdXN0IG5lZWQgdG8gdXNlIG1vcmUgYml0cy5cclxuICAgICAgICAvLyBTY2FsZSB1cCBwYXR0ZXJuTGVuZ3RoIHNvIHRoYXQgaW50ZXJtZWRpYXRlIHZhbHVlcyBiZWxvdyBsaWtlIHNjYWxlZENvdW50ZXIgd2lsbCBoYXZlXHJcbiAgICAgICAgLy8gbW9yZSBcInNpZ25pZmljYW50IGRpZ2l0c1wiLlxyXG4gICAgICAgIHZhciB1bml0QmFyV2lkdGggPSB0b3RhbCAvIHBhdHRlcm5MZW5ndGg7XHJcbiAgICAgICAgbWF4SW5kaXZpZHVhbFZhcmlhbmNlICo9IHVuaXRCYXJXaWR0aDtcclxuICAgICAgICB2YXIgdG90YWxWYXJpYW5jZSA9IDAuMDtcclxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG51bUNvdW50ZXJzOyB4KyspIHtcclxuICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSBjb3VudGVyc1t4XTtcclxuICAgICAgICAgICAgdmFyIHNjYWxlZFBhdHRlcm4gPSBwYXR0ZXJuW3hdICogdW5pdEJhcldpZHRoO1xyXG4gICAgICAgICAgICB2YXIgdmFyaWFuY2UgPSBjb3VudGVyID4gc2NhbGVkUGF0dGVybiA/IGNvdW50ZXIgLSBzY2FsZWRQYXR0ZXJuIDogc2NhbGVkUGF0dGVybiAtIGNvdW50ZXI7XHJcbiAgICAgICAgICAgIGlmICh2YXJpYW5jZSA+IG1heEluZGl2aWR1YWxWYXJpYW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qRmxvYXQuUE9TSVRJVkVfSU5GSU5JVFkqLyBJbmZpbml0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b3RhbFZhcmlhbmNlICs9IHZhcmlhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG90YWxWYXJpYW5jZSAvIHRvdGFsO1xyXG4gICAgfTtcclxuICAgIERldGVjdG9yLklOREVYRVNfU1RBUlRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbMCwgNCwgMSwgNV0pO1xyXG4gICAgRGV0ZWN0b3IuSU5ERVhFU19TVE9QX1BBVFRFUk4gPSBJbnQzMkFycmF5LmZyb20oWzYsIDIsIDcsIDNdKTtcclxuICAgIERldGVjdG9yLk1BWF9BVkdfVkFSSUFOQ0UgPSAwLjQyO1xyXG4gICAgRGV0ZWN0b3IuTUFYX0lORElWSURVQUxfVkFSSUFOQ0UgPSAwLjg7XHJcbiAgICAvLyBCIFMgQiBTIEIgUyBCIFMgQmFyL1NwYWNlIHBhdHRlcm5cclxuICAgIC8vIDExMTExMTExIDAgMSAwIDEgMCAxIDAwMFxyXG4gICAgRGV0ZWN0b3IuU1RBUlRfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbOCwgMSwgMSwgMSwgMSwgMSwgMSwgM10pO1xyXG4gICAgLy8gMTExMTExMSAwIDEgMDAwIDEgMCAxIDAwIDFcclxuICAgIERldGVjdG9yLlNUT1BfUEFUVEVSTiA9IEludDMyQXJyYXkuZnJvbShbNywgMSwgMSwgMywgMSwgMSwgMSwgMiwgMV0pO1xyXG4gICAgRGV0ZWN0b3IuTUFYX1BJWEVMX0RSSUZUID0gMztcclxuICAgIERldGVjdG9yLk1BWF9QQVRURVJOX0RSSUZUID0gNTtcclxuICAgIC8vIGlmIHdlIHNldCB0aGUgdmFsdWUgdG9vIGxvdywgdGhlbiB3ZSBkb24ndCBkZXRlY3QgdGhlIGNvcnJlY3QgaGVpZ2h0IG9mIHRoZSBiYXIgaWYgdGhlIHN0YXJ0IHBhdHRlcm5zIGFyZSBkYW1hZ2VkLlxyXG4gICAgLy8gaWYgd2Ugc2V0IHRoZSB2YWx1ZSB0b28gaGlnaCwgdGhlbiB3ZSBtaWdodCBkZXRlY3QgdGhlIHN0YXJ0IHBhdHRlcm4gZnJvbSBhIG5laWdoYm9yIGJhcmNvZGUuXHJcbiAgICBEZXRlY3Rvci5TS0lQUEVEX1JPV19DT1VOVF9NQVggPSAyNTtcclxuICAgIC8vIEEgUERGNDcxIGJhcmNvZGUgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMyByb3dzLCB3aXRoIGVhY2ggcm93IGJlaW5nID49IDMgdGltZXMgdGhlIG1vZHVsZSB3aWR0aC4gVGhlcmVmb3JlIGl0IHNob3VsZCBiZSBhdCBsZWFzdFxyXG4gICAgLy8gOSBwaXhlbHMgdGFsbC4gVG8gYmUgY29uc2VydmF0aXZlLCB3ZSB1c2UgYWJvdXQgaGFsZiB0aGUgc2l6ZSB0byBlbnN1cmUgd2UgZG9uJ3QgbWlzcyBpdC5cclxuICAgIERldGVjdG9yLlJPV19TVEVQID0gNTtcclxuICAgIERldGVjdG9yLkJBUkNPREVfTUlOX0hFSUdIVCA9IDEwO1xyXG4gICAgcmV0dXJuIERldGVjdG9yO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEZXRlY3RvcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGV0ZWN0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4qXHJcbiogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4qIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gaW1wb3J0IGphdmEudXRpbC5MaXN0O1xyXG4vKipcclxuICogQGF1dGhvciBHdWVudGhlciBHcmF1XHJcbiAqL1xyXG52YXIgUERGNDE3RGV0ZWN0b3JSZXN1bHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQREY0MTdEZXRlY3RvclJlc3VsdChiaXRzLCBwb2ludHMpIHtcclxuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xyXG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgfVxyXG4gICAgUERGNDE3RGV0ZWN0b3JSZXN1bHQucHJvdG90eXBlLmdldEJpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYml0cztcclxuICAgIH07XHJcbiAgICBQREY0MTdEZXRlY3RvclJlc3VsdC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvaW50cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gUERGNDE3RGV0ZWN0b3JSZXN1bHQ7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFBERjQxN0RldGVjdG9yUmVzdWx0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1QREY0MTdEZXRlY3RvclJlc3VsdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlIHsqL1xyXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XHJcbnZhciBEZWNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0RlY29kZUhpbnRUeXBlXCIpO1xyXG52YXIgUmVzdWx0XzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0XCIpO1xyXG52YXIgUmVzdWx0TWV0YWRhdGFUeXBlXzEgPSByZXF1aXJlKFwiLi4vUmVzdWx0TWV0YWRhdGFUeXBlXCIpO1xyXG52YXIgQml0TWF0cml4XzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0JpdE1hdHJpeFwiKTtcclxudmFyIERlY29kZXJfMSA9IHJlcXVpcmUoXCIuL2RlY29kZXIvRGVjb2RlclwiKTtcclxudmFyIFFSQ29kZURlY29kZXJNZXRhRGF0YV8xID0gcmVxdWlyZShcIi4vZGVjb2Rlci9RUkNvZGVEZWNvZGVyTWV0YURhdGFcIik7XHJcbnZhciBEZXRlY3Rvcl8xID0gcmVxdWlyZShcIi4vZGV0ZWN0b3IvRGV0ZWN0b3JcIik7XHJcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xyXG4vKmltcG9ydCBqYXZhLnV0aWwuTGlzdDsqL1xyXG4vKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXHJcbi8qKlxyXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGNhbiBkZXRlY3QgYW5kIGRlY29kZSBRUiBDb2RlcyBpbiBhbiBpbWFnZS5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICovXHJcbnZhciBRUkNvZGVSZWFkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBRUkNvZGVSZWFkZXIoKSB7XHJcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IERlY29kZXJfMS5kZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICBRUkNvZGVSZWFkZXIucHJvdG90eXBlLmdldERlY29kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIExvY2F0ZXMgYW5kIGRlY29kZXMgYSBRUiBjb2RlIGluIGFuIGltYWdlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gYSByZXByZXNlbnRpbmc6IHN0cmluZyB0aGUgY29udGVudCBlbmNvZGVkIGJ5IHRoZSBRUiBjb2RlXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGEgUVIgY29kZSBjYW5ub3QgYmUgZm91bmRcclxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGEgUVIgY29kZSBjYW5ub3QgYmUgZGVjb2RlZFxyXG4gICAgICogQHRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiBpZiBlcnJvciBjb3JyZWN0aW9uIGZhaWxzXHJcbiAgICAgKi9cclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIC8vIHB1YmxpYyBkZWNvZGUoaW1hZ2U6IEJpbmFyeUJpdG1hcCk6IFJlc3VsdCAvKnRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiwgQ2hlY2tzdW1FeGNlcHRpb24sIEZvcm1hdEV4Y2VwdGlvbiAqLyB7XHJcbiAgICAvLyAgIHJldHVybiB0aGlzLmRlY29kZShpbWFnZSwgbnVsbClcclxuICAgIC8vIH1cclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIFFSQ29kZVJlYWRlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKGltYWdlLCBoaW50cykge1xyXG4gICAgICAgIHZhciBkZWNvZGVyUmVzdWx0O1xyXG4gICAgICAgIHZhciBwb2ludHM7XHJcbiAgICAgICAgaWYgKGhpbnRzICE9PSB1bmRlZmluZWQgJiYgaGludHMgIT09IG51bGwgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRGVjb2RlSGludFR5cGVfMS5kZWZhdWx0LlBVUkVfQkFSQ09ERSkpIHtcclxuICAgICAgICAgICAgdmFyIGJpdHMgPSBRUkNvZGVSZWFkZXIuZXh0cmFjdFB1cmVCaXRzKGltYWdlLmdldEJsYWNrTWF0cml4KCkpO1xyXG4gICAgICAgICAgICBkZWNvZGVyUmVzdWx0ID0gdGhpcy5kZWNvZGVyLmRlY29kZUJpdE1hdHJpeChiaXRzLCBoaW50cyk7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IFFSQ29kZVJlYWRlci5OT19QT0lOVFM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZGV0ZWN0b3JSZXN1bHQgPSBuZXcgRGV0ZWN0b3JfMS5kZWZhdWx0KGltYWdlLmdldEJsYWNrTWF0cml4KCkpLmRldGVjdChoaW50cyk7XHJcbiAgICAgICAgICAgIGRlY29kZXJSZXN1bHQgPSB0aGlzLmRlY29kZXIuZGVjb2RlQml0TWF0cml4KGRldGVjdG9yUmVzdWx0LmdldEJpdHMoKSwgaGludHMpO1xyXG4gICAgICAgICAgICBwb2ludHMgPSBkZXRlY3RvclJlc3VsdC5nZXRQb2ludHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlIGNvZGUgd2FzIG1pcnJvcmVkOiBzd2FwIHRoZSBib3R0b20tbGVmdCBhbmQgdGhlIHRvcC1yaWdodCBwb2ludHMuXHJcbiAgICAgICAgaWYgKGRlY29kZXJSZXN1bHQuZ2V0T3RoZXIoKSBpbnN0YW5jZW9mIFFSQ29kZURlY29kZXJNZXRhRGF0YV8xLmRlZmF1bHQpIHtcclxuICAgICAgICAgICAgZGVjb2RlclJlc3VsdC5nZXRPdGhlcigpLmFwcGx5TWlycm9yZWRDb3JyZWN0aW9uKHBvaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgUmVzdWx0XzEuZGVmYXVsdChkZWNvZGVyUmVzdWx0LmdldFRleHQoKSwgZGVjb2RlclJlc3VsdC5nZXRSYXdCeXRlcygpLCB1bmRlZmluZWQsIHBvaW50cywgQmFyY29kZUZvcm1hdF8xLmRlZmF1bHQuUVJfQ09ERSwgdW5kZWZpbmVkKTtcclxuICAgICAgICB2YXIgYnl0ZVNlZ21lbnRzID0gZGVjb2RlclJlc3VsdC5nZXRCeXRlU2VnbWVudHMoKTtcclxuICAgICAgICBpZiAoYnl0ZVNlZ21lbnRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0LkJZVEVfU0VHTUVOVFMsIGJ5dGVTZWdtZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlY0xldmVsID0gZGVjb2RlclJlc3VsdC5nZXRFQ0xldmVsKCk7XHJcbiAgICAgICAgaWYgKGVjTGV2ZWwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnB1dE1ldGFkYXRhKFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQuRVJST1JfQ09SUkVDVElPTl9MRVZFTCwgZWNMZXZlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWNvZGVyUmVzdWx0Lmhhc1N0cnVjdHVyZWRBcHBlbmQoKSkge1xyXG4gICAgICAgICAgICByZXN1bHQucHV0TWV0YWRhdGEoUmVzdWx0TWV0YWRhdGFUeXBlXzEuZGVmYXVsdC5TVFJVQ1RVUkVEX0FQUEVORF9TRVFVRU5DRSwgZGVjb2RlclJlc3VsdC5nZXRTdHJ1Y3R1cmVkQXBwZW5kU2VxdWVuY2VOdW1iZXIoKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXRNZXRhZGF0YShSZXN1bHRNZXRhZGF0YVR5cGVfMS5kZWZhdWx0LlNUUlVDVFVSRURfQVBQRU5EX1BBUklUWSwgZGVjb2RlclJlc3VsdC5nZXRTdHJ1Y3R1cmVkQXBwZW5kUGFyaXR5KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIFFSQ29kZVJlYWRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgZGV0ZWN0cyBhIGNvZGUgaW4gYSBcInB1cmVcIiBpbWFnZSAtLSB0aGF0IGlzLCBwdXJlIG1vbm9jaHJvbWUgaW1hZ2VcclxuICAgICAqIHdoaWNoIGNvbnRhaW5zIG9ubHkgYW4gdW5yb3RhdGVkLCB1bnNrZXdlZCwgaW1hZ2Ugb2YgYSBjb2RlLCB3aXRoIHNvbWUgd2hpdGUgYm9yZGVyXHJcbiAgICAgKiBhcm91bmQgaXQuIFRoaXMgaXMgYSBzcGVjaWFsaXplZCBtZXRob2QgdGhhdCB3b3JrcyBleGNlcHRpb25hbGx5IGZhc3QgaW4gdGhpcyBzcGVjaWFsXHJcbiAgICAgKiBjYXNlLlxyXG4gICAgICpcclxuICAgICAqIEBzZWUgY29tLmdvb2dsZS56eGluZy5kYXRhbWF0cml4LkRhdGFNYXRyaXhSZWFkZXIjZXh0cmFjdFB1cmVCaXRzKEJpdE1hdHJpeClcclxuICAgICAqL1xyXG4gICAgUVJDb2RlUmVhZGVyLmV4dHJhY3RQdXJlQml0cyA9IGZ1bmN0aW9uIChpbWFnZSkge1xyXG4gICAgICAgIHZhciBsZWZ0VG9wQmxhY2sgPSBpbWFnZS5nZXRUb3BMZWZ0T25CaXQoKTtcclxuICAgICAgICB2YXIgcmlnaHRCb3R0b21CbGFjayA9IGltYWdlLmdldEJvdHRvbVJpZ2h0T25CaXQoKTtcclxuICAgICAgICBpZiAobGVmdFRvcEJsYWNrID09PSBudWxsIHx8IHJpZ2h0Qm90dG9tQmxhY2sgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IHRoaXMubW9kdWxlU2l6ZShsZWZ0VG9wQmxhY2ssIGltYWdlKTtcclxuICAgICAgICB2YXIgdG9wID0gbGVmdFRvcEJsYWNrWzFdO1xyXG4gICAgICAgIHZhciBib3R0b20gPSByaWdodEJvdHRvbUJsYWNrWzFdO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gbGVmdFRvcEJsYWNrWzBdO1xyXG4gICAgICAgIHZhciByaWdodCA9IHJpZ2h0Qm90dG9tQmxhY2tbMF07XHJcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrIVxyXG4gICAgICAgIGlmIChsZWZ0ID49IHJpZ2h0IHx8IHRvcCA+PSBib3R0b20pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYm90dG9tIC0gdG9wICE9PSByaWdodCAtIGxlZnQpIHtcclxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlLCB3aGVyZSBib3R0b20tcmlnaHQgbW9kdWxlIHdhc24ndCBibGFjayBzbyB3ZSBmb3VuZCBzb21ldGhpbmcgZWxzZSBpbiB0aGUgbGFzdCByb3dcclxuICAgICAgICAgICAgLy8gQXNzdW1lIGl0J3MgYSBzcXVhcmUsIHNvIHVzZSBoZWlnaHQgYXMgdGhlIHdpZHRoXHJcbiAgICAgICAgICAgIHJpZ2h0ID0gbGVmdCArIChib3R0b20gLSB0b3ApO1xyXG4gICAgICAgICAgICBpZiAocmlnaHQgPj0gaW1hZ2UuZ2V0V2lkdGgoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQWJvcnQgaWYgdGhhdCB3b3VsZCBub3QgbWFrZSBzZW5zZSAtLSBvZmYgaW1hZ2VcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF0cml4V2lkdGggPSBNYXRoLnJvdW5kKChyaWdodCAtIGxlZnQgKyAxKSAvIG1vZHVsZVNpemUpO1xyXG4gICAgICAgIHZhciBtYXRyaXhIZWlnaHQgPSBNYXRoLnJvdW5kKChib3R0b20gLSB0b3AgKyAxKSAvIG1vZHVsZVNpemUpO1xyXG4gICAgICAgIGlmIChtYXRyaXhXaWR0aCA8PSAwIHx8IG1hdHJpeEhlaWdodCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hdHJpeEhlaWdodCAhPT0gbWF0cml4V2lkdGgpIHtcclxuICAgICAgICAgICAgLy8gT25seSBwb3NzaWJseSBkZWNvZGUgc3F1YXJlIHJlZ2lvbnNcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQdXNoIGluIHRoZSBcImJvcmRlclwiIGJ5IGhhbGYgdGhlIG1vZHVsZSB3aWR0aCBzbyB0aGF0IHdlIHN0YXJ0XHJcbiAgICAgICAgLy8gc2FtcGxpbmcgaW4gdGhlIG1pZGRsZSBvZiB0aGUgbW9kdWxlLiBKdXN0IGluIGNhc2UgdGhlIGltYWdlIGlzIGFcclxuICAgICAgICAvLyBsaXR0bGUgb2ZmLCB0aGlzIHdpbGwgaGVscCByZWNvdmVyLlxyXG4gICAgICAgIHZhciBudWRnZSA9IC8qKGludCkgKi8gTWF0aC5mbG9vcihtb2R1bGVTaXplIC8gMi4wKTtcclxuICAgICAgICB0b3AgKz0gbnVkZ2U7XHJcbiAgICAgICAgbGVmdCArPSBudWRnZTtcclxuICAgICAgICAvLyBCdXQgY2FyZWZ1bCB0aGF0IHRoaXMgZG9lcyBub3Qgc2FtcGxlIG9mZiB0aGUgZWRnZVxyXG4gICAgICAgIC8vIFwicmlnaHRcIiBpcyB0aGUgZmFydGhlc3QtcmlnaHQgdmFsaWQgcGl4ZWwgbG9jYXRpb24gLS0gcmlnaHQrMSBpcyBub3QgbmVjZXNzYXJpbHlcclxuICAgICAgICAvLyBUaGlzIGlzIHBvc2l0aXZlIGJ5IGhvdyBtdWNoIHRoZSBpbm5lciB4IGxvb3AgYmVsb3cgd291bGQgYmUgdG9vIGxhcmdlXHJcbiAgICAgICAgdmFyIG51ZGdlZFRvb0ZhclJpZ2h0ID0gbGVmdCArIC8qKGludCkgKi8gTWF0aC5mbG9vcigobWF0cml4V2lkdGggLSAxKSAqIG1vZHVsZVNpemUpIC0gcmlnaHQ7XHJcbiAgICAgICAgaWYgKG51ZGdlZFRvb0ZhclJpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICBpZiAobnVkZ2VkVG9vRmFyUmlnaHQgPiBudWRnZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTmVpdGhlciB3YXkgZml0czsgYWJvcnRcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZWZ0IC09IG51ZGdlZFRvb0ZhclJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZWUgbG9naWMgYWJvdmVcclxuICAgICAgICB2YXIgbnVkZ2VkVG9vRmFyRG93biA9IHRvcCArIC8qKGludCkgKi8gTWF0aC5mbG9vcigobWF0cml4SGVpZ2h0IC0gMSkgKiBtb2R1bGVTaXplKSAtIGJvdHRvbTtcclxuICAgICAgICBpZiAobnVkZ2VkVG9vRmFyRG93biA+IDApIHtcclxuICAgICAgICAgICAgaWYgKG51ZGdlZFRvb0ZhckRvd24gPiBudWRnZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTmVpdGhlciB3YXkgZml0czsgYWJvcnRcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b3AgLT0gbnVkZ2VkVG9vRmFyRG93bjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93IGp1c3QgcmVhZCBvZmYgdGhlIGJpdHNcclxuICAgICAgICB2YXIgYml0cyA9IG5ldyBCaXRNYXRyaXhfMS5kZWZhdWx0KG1hdHJpeFdpZHRoLCBtYXRyaXhIZWlnaHQpO1xyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgbWF0cml4SGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgdmFyIGlPZmZzZXQgPSB0b3AgKyAvKihpbnQpICovIE1hdGguZmxvb3IoeSAqIG1vZHVsZVNpemUpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IG1hdHJpeFdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbWFnZS5nZXQobGVmdCArIC8qKGludCkgKi8gTWF0aC5mbG9vcih4ICogbW9kdWxlU2l6ZSksIGlPZmZzZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYml0cy5zZXQoeCwgeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJpdHM7XHJcbiAgICB9O1xyXG4gICAgUVJDb2RlUmVhZGVyLm1vZHVsZVNpemUgPSBmdW5jdGlvbiAobGVmdFRvcEJsYWNrLCBpbWFnZSkge1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBpbWFnZS5nZXRIZWlnaHQoKTtcclxuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHZhciB4ID0gbGVmdFRvcEJsYWNrWzBdO1xyXG4gICAgICAgIHZhciB5ID0gbGVmdFRvcEJsYWNrWzFdO1xyXG4gICAgICAgIHZhciBpbkJsYWNrID0gdHJ1ZTtcclxuICAgICAgICB2YXIgdHJhbnNpdGlvbnMgPSAwO1xyXG4gICAgICAgIHdoaWxlICh4IDwgd2lkdGggJiYgeSA8IGhlaWdodCkge1xyXG4gICAgICAgICAgICBpZiAoaW5CbGFjayAhPT0gaW1hZ2UuZ2V0KHgsIHkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKyt0cmFuc2l0aW9ucyA9PT0gNSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5CbGFjayA9ICFpbkJsYWNrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHgrKztcclxuICAgICAgICAgICAgeSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeCA9PT0gd2lkdGggfHwgeSA9PT0gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh4IC0gbGVmdFRvcEJsYWNrWzBdKSAvIDcuMDtcclxuICAgIH07XHJcbiAgICBRUkNvZGVSZWFkZXIuTk9fUE9JTlRTID0gbmV3IEFycmF5KCk7XHJcbiAgICByZXR1cm4gUVJDb2RlUmVhZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBRUkNvZGVSZWFkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVFSQ29kZVJlYWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlIHsqL1xyXG52YXIgQmFyY29kZUZvcm1hdF8xID0gcmVxdWlyZShcIi4uL0JhcmNvZGVGb3JtYXRcIik7XHJcbnZhciBFbmNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0VuY29kZUhpbnRUeXBlXCIpO1xyXG52YXIgQml0TWF0cml4XzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0JpdE1hdHJpeFwiKTtcclxudmFyIEVycm9yQ29ycmVjdGlvbkxldmVsXzEgPSByZXF1aXJlKFwiLi9kZWNvZGVyL0Vycm9yQ29ycmVjdGlvbkxldmVsXCIpO1xyXG52YXIgRW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vZW5jb2Rlci9FbmNvZGVyXCIpO1xyXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xyXG52YXIgSWxsZWdhbFN0YXRlRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vSWxsZWdhbFN0YXRlRXhjZXB0aW9uXCIpO1xyXG4vKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXHJcbi8qKlxyXG4gKiBUaGlzIG9iamVjdCByZW5kZXJzIGEgUVIgQ29kZSBhcyBhIEJpdE1hdHJpeCAyRCBhcnJheSBvZiBncmV5c2NhbGUgdmFsdWVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxyXG4gKi9cclxudmFyIFFSQ29kZVdyaXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFFSQ29kZVdyaXRlcigpIHtcclxuICAgIH1cclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIC8vIHB1YmxpYyBlbmNvZGUoY29udGVudHM6IHN0cmluZywgZm9ybWF0OiBCYXJjb2RlRm9ybWF0LCB3aWR0aDogbnVtYmVyIC8qaW50Ki8sIGhlaWdodDogbnVtYmVyIC8qaW50Ki8pOiBCaXRNYXRyaXhcclxuICAgIC8vICAgICAvKnRocm93cyBXcml0ZXJFeGNlcHRpb24gKi8ge1xyXG4gICAgLy8gICByZXR1cm4gZW5jb2RlKGNvbnRlbnRzLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIG51bGwpXHJcbiAgICAvLyB9XHJcbiAgICAvKkBPdmVycmlkZSovXHJcbiAgICBRUkNvZGVXcml0ZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChjb250ZW50cywgZm9ybWF0LCB3aWR0aCAvKmludCovLCBoZWlnaHQgLyppbnQqLywgaGludHMpIHtcclxuICAgICAgICBpZiAoY29udGVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdGb3VuZCBlbXB0eSBjb250ZW50cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9ybWF0ICE9PSBCYXJjb2RlRm9ybWF0XzEuZGVmYXVsdC5RUl9DT0RFKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdDYW4gb25seSBlbmNvZGUgUVJfQ09ERSwgYnV0IGdvdCAnICsgZm9ybWF0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdpZHRoIDwgMCB8fCBoZWlnaHQgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KFwiUmVxdWVzdGVkIGRpbWVuc2lvbnMgYXJlIHRvbyBzbWFsbDogXCIgKyB3aWR0aCArIFwieFwiICsgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGVycm9yQ29ycmVjdGlvbkxldmVsID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWxfMS5kZWZhdWx0Lkw7XHJcbiAgICAgICAgdmFyIHF1aWV0Wm9uZSA9IFFSQ29kZVdyaXRlci5RVUlFVF9aT05FX1NJWkU7XHJcbiAgICAgICAgaWYgKGhpbnRzICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGhpbnRzLmdldChFbmNvZGVIaW50VHlwZV8xLmRlZmF1bHQuRVJST1JfQ09SUkVDVElPTikpIHtcclxuICAgICAgICAgICAgICAgIGVycm9yQ29ycmVjdGlvbkxldmVsID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWxfMS5kZWZhdWx0LmZyb21TdHJpbmcoaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5FUlJPUl9DT1JSRUNUSU9OKS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0Lk1BUkdJTikpIHtcclxuICAgICAgICAgICAgICAgIHF1aWV0Wm9uZSA9IE51bWJlci5wYXJzZUludChoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0Lk1BUkdJTikudG9TdHJpbmcoKSwgMTApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb2RlID0gRW5jb2Rlcl8xLmRlZmF1bHQuZW5jb2RlKGNvbnRlbnRzLCBlcnJvckNvcnJlY3Rpb25MZXZlbCwgaGludHMpO1xyXG4gICAgICAgIHJldHVybiBRUkNvZGVXcml0ZXIucmVuZGVyUmVzdWx0KGNvZGUsIHdpZHRoLCBoZWlnaHQsIHF1aWV0Wm9uZSk7XHJcbiAgICB9O1xyXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBpbnB1dCBtYXRyaXggdXNlcyAwID09IHdoaXRlLCAxID09IGJsYWNrLCB3aGlsZSB0aGUgb3V0cHV0IG1hdHJpeCB1c2VzXHJcbiAgICAvLyAwID09IGJsYWNrLCAyNTUgPT0gd2hpdGUgKGkuZS4gYW4gOCBiaXQgZ3JleXNjYWxlIGJpdG1hcCkuXHJcbiAgICBRUkNvZGVXcml0ZXIucmVuZGVyUmVzdWx0ID0gZnVuY3Rpb24gKGNvZGUsIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBxdWlldFpvbmUgLyppbnQqLykge1xyXG4gICAgICAgIHZhciBpbnB1dCA9IGNvZGUuZ2V0TWF0cml4KCk7XHJcbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbnB1dFdpZHRoID0gaW5wdXQuZ2V0V2lkdGgoKTtcclxuICAgICAgICB2YXIgaW5wdXRIZWlnaHQgPSBpbnB1dC5nZXRIZWlnaHQoKTtcclxuICAgICAgICB2YXIgcXJXaWR0aCA9IGlucHV0V2lkdGggKyAocXVpZXRab25lICogMik7XHJcbiAgICAgICAgdmFyIHFySGVpZ2h0ID0gaW5wdXRIZWlnaHQgKyAocXVpZXRab25lICogMik7XHJcbiAgICAgICAgdmFyIG91dHB1dFdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHFyV2lkdGgpO1xyXG4gICAgICAgIHZhciBvdXRwdXRIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHFySGVpZ2h0KTtcclxuICAgICAgICB2YXIgbXVsdGlwbGUgPSBNYXRoLm1pbihNYXRoLmZsb29yKG91dHB1dFdpZHRoIC8gcXJXaWR0aCksIE1hdGguZmxvb3Iob3V0cHV0SGVpZ2h0IC8gcXJIZWlnaHQpKTtcclxuICAgICAgICAvLyBQYWRkaW5nIGluY2x1ZGVzIGJvdGggdGhlIHF1aWV0IHpvbmUgYW5kIHRoZSBleHRyYSB3aGl0ZSBwaXhlbHMgdG8gYWNjb21tb2RhdGUgdGhlIHJlcXVlc3RlZFxyXG4gICAgICAgIC8vIGRpbWVuc2lvbnMuIEZvciBleGFtcGxlLCBpZiBpbnB1dCBpcyAyNXgyNSB0aGUgUVIgd2lsbCBiZSAzM3gzMyBpbmNsdWRpbmcgdGhlIHF1aWV0IHpvbmUuXHJcbiAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3RlZCBzaXplIGlzIDIwMHgxNjAsIHRoZSBtdWx0aXBsZSB3aWxsIGJlIDQsIGZvciBhIFFSIG9mIDEzMngxMzIuIFRoZXNlIHdpbGxcclxuICAgICAgICAvLyBoYW5kbGUgYWxsIHRoZSBwYWRkaW5nIGZyb20gMTAweDEwMCAodGhlIGFjdHVhbCBRUikgdXAgdG8gMjAweDE2MC5cclxuICAgICAgICB2YXIgbGVmdFBhZGRpbmcgPSBNYXRoLmZsb29yKChvdXRwdXRXaWR0aCAtIChpbnB1dFdpZHRoICogbXVsdGlwbGUpKSAvIDIpO1xyXG4gICAgICAgIHZhciB0b3BQYWRkaW5nID0gTWF0aC5mbG9vcigob3V0cHV0SGVpZ2h0IC0gKGlucHV0SGVpZ2h0ICogbXVsdGlwbGUpKSAvIDIpO1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSBuZXcgQml0TWF0cml4XzEuZGVmYXVsdChvdXRwdXRXaWR0aCwgb3V0cHV0SGVpZ2h0KTtcclxuICAgICAgICBmb3IgKHZhciBpbnB1dFkgPSAwLCBvdXRwdXRZID0gdG9wUGFkZGluZzsgaW5wdXRZIDwgaW5wdXRIZWlnaHQ7IGlucHV0WSsrLCBvdXRwdXRZICs9IG11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgIC8vIFdyaXRlIHRoZSBjb250ZW50cyBvZiB0aGlzIHJvdyBvZiB0aGUgYmFyY29kZVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dFggPSAwLCBvdXRwdXRYID0gbGVmdFBhZGRpbmc7IGlucHV0WCA8IGlucHV0V2lkdGg7IGlucHV0WCsrLCBvdXRwdXRYICs9IG11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZ2V0KGlucHV0WCwgaW5wdXRZKSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXRSZWdpb24ob3V0cHV0WCwgb3V0cHV0WSwgbXVsdGlwbGUsIG11bHRpcGxlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfTtcclxuICAgIFFSQ29kZVdyaXRlci5RVUlFVF9aT05FX1NJWkUgPSA0O1xyXG4gICAgcmV0dXJuIFFSQ29kZVdyaXRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUVJDb2RlV3JpdGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1RUkNvZGVXcml0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVmVyc2lvbl8xID0gcmVxdWlyZShcIi4vVmVyc2lvblwiKTtcclxudmFyIEZvcm1hdEluZm9ybWF0aW9uXzEgPSByZXF1aXJlKFwiLi9Gb3JtYXRJbmZvcm1hdGlvblwiKTtcclxudmFyIERhdGFNYXNrXzEgPSByZXF1aXJlKFwiLi9EYXRhTWFza1wiKTtcclxudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqL1xyXG52YXIgQml0TWF0cml4UGFyc2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYml0TWF0cml4IHtAbGluayBCaXRNYXRyaXh9IHRvIHBhcnNlXHJcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBkaW1lbnNpb24gaXMgbm90ID49IDIxIGFuZCAxIG1vZCA0XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIEJpdE1hdHJpeFBhcnNlcihiaXRNYXRyaXgpIHtcclxuICAgICAgICB2YXIgZGltZW5zaW9uID0gYml0TWF0cml4LmdldEhlaWdodCgpO1xyXG4gICAgICAgIGlmIChkaW1lbnNpb24gPCAyMSB8fCAoZGltZW5zaW9uICYgMHgwMykgIT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5iaXRNYXRyaXggPSBiaXRNYXRyaXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIDxwPlJlYWRzIGZvcm1hdCBpbmZvcm1hdGlvbiBmcm9tIG9uZSBvZiBpdHMgdHdvIGxvY2F0aW9ucyB3aXRoaW4gdGhlIFFSIENvZGUuPC9wPlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge0BsaW5rIEZvcm1hdEluZm9ybWF0aW9ufSBlbmNhcHN1bGF0aW5nIHRoZSBRUiBDb2RlJ3MgZm9ybWF0IGluZm9cclxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGJvdGggZm9ybWF0IGluZm9ybWF0aW9uIGxvY2F0aW9ucyBjYW5ub3QgYmUgcGFyc2VkIGFzXHJcbiAgICAgKiB0aGUgdmFsaWQgZW5jb2Rpbmcgb2YgZm9ybWF0IGluZm9ybWF0aW9uXHJcbiAgICAgKi9cclxuICAgIEJpdE1hdHJpeFBhcnNlci5wcm90b3R5cGUucmVhZEZvcm1hdEluZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBhcnNlZEZvcm1hdEluZm8gIT09IG51bGwgJiYgdGhpcy5wYXJzZWRGb3JtYXRJbmZvICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VkRm9ybWF0SW5mbztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVhZCB0b3AtbGVmdCBmb3JtYXQgaW5mbyBiaXRzXHJcbiAgICAgICAgdmFyIGZvcm1hdEluZm9CaXRzMSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcclxuICAgICAgICAgICAgZm9ybWF0SW5mb0JpdHMxID0gdGhpcy5jb3B5Qml0KGksIDgsIGZvcm1hdEluZm9CaXRzMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIC4uIGFuZCBza2lwIGEgYml0IGluIHRoZSB0aW1pbmcgcGF0dGVybiAuLi5cclxuICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoNywgOCwgZm9ybWF0SW5mb0JpdHMxKTtcclxuICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoOCwgOCwgZm9ybWF0SW5mb0JpdHMxKTtcclxuICAgICAgICBmb3JtYXRJbmZvQml0czEgPSB0aGlzLmNvcHlCaXQoOCwgNywgZm9ybWF0SW5mb0JpdHMxKTtcclxuICAgICAgICAvLyAuLiBhbmQgc2tpcCBhIGJpdCBpbiB0aGUgdGltaW5nIHBhdHRlcm4gLi4uXHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDU7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdEluZm9CaXRzMSA9IHRoaXMuY29weUJpdCg4LCBqLCBmb3JtYXRJbmZvQml0czEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZWFkIHRoZSB0b3AtcmlnaHQvYm90dG9tLWxlZnQgcGF0dGVybiB0b29cclxuICAgICAgICB2YXIgZGltZW5zaW9uID0gdGhpcy5iaXRNYXRyaXguZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgdmFyIGZvcm1hdEluZm9CaXRzMiA9IDA7XHJcbiAgICAgICAgdmFyIGpNaW4gPSBkaW1lbnNpb24gLSA3O1xyXG4gICAgICAgIGZvciAodmFyIGogPSBkaW1lbnNpb24gLSAxOyBqID49IGpNaW47IGotLSkge1xyXG4gICAgICAgICAgICBmb3JtYXRJbmZvQml0czIgPSB0aGlzLmNvcHlCaXQoOCwgaiwgZm9ybWF0SW5mb0JpdHMyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGRpbWVuc2lvbiAtIDg7IGkgPCBkaW1lbnNpb247IGkrKykge1xyXG4gICAgICAgICAgICBmb3JtYXRJbmZvQml0czIgPSB0aGlzLmNvcHlCaXQoaSwgOCwgZm9ybWF0SW5mb0JpdHMyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYXJzZWRGb3JtYXRJbmZvID0gRm9ybWF0SW5mb3JtYXRpb25fMS5kZWZhdWx0LmRlY29kZUZvcm1hdEluZm9ybWF0aW9uKGZvcm1hdEluZm9CaXRzMSwgZm9ybWF0SW5mb0JpdHMyKTtcclxuICAgICAgICBpZiAodGhpcy5wYXJzZWRGb3JtYXRJbmZvICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZEZvcm1hdEluZm87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5SZWFkcyB2ZXJzaW9uIGluZm9ybWF0aW9uIGZyb20gb25lIG9mIGl0cyB0d28gbG9jYXRpb25zIHdpdGhpbiB0aGUgUVIgQ29kZS48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7QGxpbmsgVmVyc2lvbn0gZW5jYXBzdWxhdGluZyB0aGUgUVIgQ29kZSdzIHZlcnNpb25cclxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIGJvdGggdmVyc2lvbiBpbmZvcm1hdGlvbiBsb2NhdGlvbnMgY2Fubm90IGJlIHBhcnNlZCBhc1xyXG4gICAgICogdGhlIHZhbGlkIGVuY29kaW5nIG9mIHZlcnNpb24gaW5mb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5yZWFkVmVyc2lvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJzZWRWZXJzaW9uICE9PSBudWxsICYmIHRoaXMucGFyc2VkVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFZlcnNpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmJpdE1hdHJpeC5nZXRIZWlnaHQoKTtcclxuICAgICAgICB2YXIgcHJvdmlzaW9uYWxWZXJzaW9uID0gTWF0aC5mbG9vcigoZGltZW5zaW9uIC0gMTcpIC8gNCk7XHJcbiAgICAgICAgaWYgKHByb3Zpc2lvbmFsVmVyc2lvbiA8PSA2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBWZXJzaW9uXzEuZGVmYXVsdC5nZXRWZXJzaW9uRm9yTnVtYmVyKHByb3Zpc2lvbmFsVmVyc2lvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlYWQgdG9wLXJpZ2h0IHZlcnNpb24gaW5mbzogMyB3aWRlIGJ5IDYgdGFsbFxyXG4gICAgICAgIHZhciB2ZXJzaW9uQml0cyA9IDA7XHJcbiAgICAgICAgdmFyIGlqTWluID0gZGltZW5zaW9uIC0gMTE7XHJcbiAgICAgICAgZm9yICh2YXIgaiA9IDU7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBkaW1lbnNpb24gLSA5OyBpID49IGlqTWluOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgIHZlcnNpb25CaXRzID0gdGhpcy5jb3B5Qml0KGksIGosIHZlcnNpb25CaXRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGhlUGFyc2VkVmVyc2lvbiA9IFZlcnNpb25fMS5kZWZhdWx0LmRlY29kZVZlcnNpb25JbmZvcm1hdGlvbih2ZXJzaW9uQml0cyk7XHJcbiAgICAgICAgaWYgKHRoZVBhcnNlZFZlcnNpb24gIT09IG51bGwgJiYgdGhlUGFyc2VkVmVyc2lvbi5nZXREaW1lbnNpb25Gb3JWZXJzaW9uKCkgPT09IGRpbWVuc2lvbikge1xyXG4gICAgICAgICAgICB0aGlzLnBhcnNlZFZlcnNpb24gPSB0aGVQYXJzZWRWZXJzaW9uO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhlUGFyc2VkVmVyc2lvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSG1tLCBmYWlsZWQuIFRyeSBib3R0b20gbGVmdDogNiB3aWRlIGJ5IDMgdGFsbFxyXG4gICAgICAgIHZlcnNpb25CaXRzID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gNTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGRpbWVuc2lvbiAtIDk7IGogPj0gaWpNaW47IGotLSkge1xyXG4gICAgICAgICAgICAgICAgdmVyc2lvbkJpdHMgPSB0aGlzLmNvcHlCaXQoaSwgaiwgdmVyc2lvbkJpdHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoZVBhcnNlZFZlcnNpb24gPSBWZXJzaW9uXzEuZGVmYXVsdC5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24odmVyc2lvbkJpdHMpO1xyXG4gICAgICAgIGlmICh0aGVQYXJzZWRWZXJzaW9uICE9PSBudWxsICYmIHRoZVBhcnNlZFZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpID09PSBkaW1lbnNpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJzZWRWZXJzaW9uID0gdGhlUGFyc2VkVmVyc2lvbjtcclxuICAgICAgICAgICAgcmV0dXJuIHRoZVBhcnNlZFZlcnNpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICB9O1xyXG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5jb3B5Qml0ID0gZnVuY3Rpb24gKGkgLyppbnQqLywgaiAvKmludCovLCB2ZXJzaW9uQml0cyAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIGJpdCA9IHRoaXMuaXNNaXJyb3IgPyB0aGlzLmJpdE1hdHJpeC5nZXQoaiwgaSkgOiB0aGlzLmJpdE1hdHJpeC5nZXQoaSwgaik7XHJcbiAgICAgICAgcmV0dXJuIGJpdCA/ICh2ZXJzaW9uQml0cyA8PCAxKSB8IDB4MSA6IHZlcnNpb25CaXRzIDw8IDE7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5SZWFkcyB0aGUgYml0cyBpbiB0aGUge0BsaW5rIEJpdE1hdHJpeH0gcmVwcmVzZW50aW5nIHRoZSBmaW5kZXIgcGF0dGVybiBpbiB0aGVcclxuICAgICAqIGNvcnJlY3Qgb3JkZXIgaW4gb3JkZXIgdG8gcmVjb25zdHJ1Y3QgdGhlIGNvZGV3b3JkcyBieXRlcyBjb250YWluZWQgd2l0aGluIHRoZVxyXG4gICAgICogUVIgQ29kZS48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgUVIgQ29kZVxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIGV4YWN0IG51bWJlciBvZiBieXRlcyBleHBlY3RlZCBpcyBub3QgcmVhZFxyXG4gICAgICovXHJcbiAgICBCaXRNYXRyaXhQYXJzZXIucHJvdG90eXBlLnJlYWRDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZvcm1hdEluZm8gPSB0aGlzLnJlYWRGb3JtYXRJbmZvcm1hdGlvbigpO1xyXG4gICAgICAgIHZhciB2ZXJzaW9uID0gdGhpcy5yZWFkVmVyc2lvbigpO1xyXG4gICAgICAgIC8vIEdldCB0aGUgZGF0YSBtYXNrIGZvciB0aGUgZm9ybWF0IHVzZWQgaW4gdGhpcyBRUiBDb2RlLiBUaGlzIHdpbGwgZXhjbHVkZVxyXG4gICAgICAgIC8vIHNvbWUgYml0cyBmcm9tIHJlYWRpbmcgYXMgd2Ugd2luZCB0aHJvdWdoIHRoZSBiaXQgbWF0cml4LlxyXG4gICAgICAgIHZhciBkYXRhTWFzayA9IERhdGFNYXNrXzEuZGVmYXVsdC52YWx1ZXMuZ2V0KGZvcm1hdEluZm8uZ2V0RGF0YU1hc2soKSk7XHJcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpO1xyXG4gICAgICAgIGRhdGFNYXNrLnVubWFza0JpdE1hdHJpeCh0aGlzLmJpdE1hdHJpeCwgZGltZW5zaW9uKTtcclxuICAgICAgICB2YXIgZnVuY3Rpb25QYXR0ZXJuID0gdmVyc2lvbi5idWlsZEZ1bmN0aW9uUGF0dGVybigpO1xyXG4gICAgICAgIHZhciByZWFkaW5nVXAgPSB0cnVlO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheSh2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkpO1xyXG4gICAgICAgIHZhciByZXN1bHRPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciBjdXJyZW50Qnl0ZSA9IDA7XHJcbiAgICAgICAgdmFyIGJpdHNSZWFkID0gMDtcclxuICAgICAgICAvLyBSZWFkIGNvbHVtbnMgaW4gcGFpcnMsIGZyb20gcmlnaHQgdG8gbGVmdFxyXG4gICAgICAgIGZvciAodmFyIGogPSBkaW1lbnNpb24gLSAxOyBqID4gMDsgaiAtPSAyKSB7XHJcbiAgICAgICAgICAgIGlmIChqID09PSA2KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdob2xlIGNvbHVtbiB3aXRoIHZlcnRpY2FsIGFsaWdubWVudCBwYXR0ZXJuXHJcbiAgICAgICAgICAgICAgICAvLyBzYXZlcyB0aW1lIGFuZCBtYWtlcyB0aGUgb3RoZXIgY29kZSBwcm9jZWVkIG1vcmUgY2xlYW5seVxyXG4gICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJlYWQgYWx0ZXJuYXRpbmdseSBmcm9tIGJvdHRvbSB0byB0b3AgdGhlbiB0b3AgdG8gYm90dG9tXHJcbiAgICAgICAgICAgIGZvciAodmFyIGNvdW50ID0gMDsgY291bnQgPCBkaW1lbnNpb247IGNvdW50KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gcmVhZGluZ1VwID8gZGltZW5zaW9uIC0gMSAtIGNvdW50IDogY291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCAyOyBjb2wrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBiaXRzIGNvdmVyZWQgYnkgdGhlIGZ1bmN0aW9uIHBhdHRlcm5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uUGF0dGVybi5nZXQoaiAtIGNvbCwgaSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVhZCBhIGJpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaXRzUmVhZCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSA8PD0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYml0TWF0cml4LmdldChqIC0gY29sLCBpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJ5dGUgfD0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBtYWRlIGEgd2hvbGUgYnl0ZSwgc2F2ZSBpdCBvZmZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdHNSZWFkID09PSA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0T2Zmc2V0KytdID0gLyooYnl0ZSkgKi8gY3VycmVudEJ5dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzUmVhZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Qnl0ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVhZGluZ1VwID0gIXJlYWRpbmdVcDsgLy8gcmVhZGluZ1VwIF49IHRydWU7IC8vIHJlYWRpbmdVcCA9ICFyZWFkaW5nVXA7IC8vIHN3aXRjaCBkaXJlY3Rpb25zXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHRPZmZzZXQgIT09IHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV2ZXJ0IHRoZSBtYXNrIHJlbW92YWwgZG9uZSB3aGlsZSByZWFkaW5nIHRoZSBjb2RlIHdvcmRzLiBUaGUgYml0IG1hdHJpeCBzaG91bGQgcmV2ZXJ0IHRvIGl0cyBvcmlnaW5hbCBzdGF0ZS5cclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5yZW1hc2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkRm9ybWF0SW5mbyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIFdlIGhhdmUgbm8gZm9ybWF0IGluZm9ybWF0aW9uLCBhbmQgaGF2ZSBubyBkYXRhIG1hc2tcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRhdGFNYXNrID0gRGF0YU1hc2tfMS5kZWZhdWx0LnZhbHVlc1t0aGlzLnBhcnNlZEZvcm1hdEluZm8uZ2V0RGF0YU1hc2soKV07XHJcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuYml0TWF0cml4LmdldEhlaWdodCgpO1xyXG4gICAgICAgIGRhdGFNYXNrLnVubWFza0JpdE1hdHJpeCh0aGlzLmJpdE1hdHJpeCwgZGltZW5zaW9uKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFByZXBhcmUgdGhlIHBhcnNlciBmb3IgYSBtaXJyb3JlZCBvcGVyYXRpb24uXHJcbiAgICAgKiBUaGlzIGZsYWcgaGFzIGVmZmVjdCBvbmx5IG9uIHRoZSB7QGxpbmsgI3JlYWRGb3JtYXRJbmZvcm1hdGlvbigpfSBhbmQgdGhlXHJcbiAgICAgKiB7QGxpbmsgI3JlYWRWZXJzaW9uKCl9LiBCZWZvcmUgcHJvY2VlZGluZyB3aXRoIHtAbGluayAjcmVhZENvZGV3b3JkcygpfSB0aGVcclxuICAgICAqIHtAbGluayAjbWlycm9yKCl9IG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtaXJyb3IgV2hldGhlciB0byByZWFkIHZlcnNpb24gYW5kIGZvcm1hdCBpbmZvcm1hdGlvbiBtaXJyb3JlZC5cclxuICAgICAqL1xyXG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5zZXRNaXJyb3IgPSBmdW5jdGlvbiAoaXNNaXJyb3IpIHtcclxuICAgICAgICB0aGlzLnBhcnNlZFZlcnNpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGFyc2VkRm9ybWF0SW5mbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc01pcnJvciA9IGlzTWlycm9yO1xyXG4gICAgfTtcclxuICAgIC8qKiBNaXJyb3IgdGhlIGJpdCBtYXRyaXggaW4gb3JkZXIgdG8gYXR0ZW1wdCBhIHNlY29uZCByZWFkaW5nLiAqL1xyXG4gICAgQml0TWF0cml4UGFyc2VyLnByb3RvdHlwZS5taXJyb3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGJpdE1hdHJpeCA9IHRoaXMuYml0TWF0cml4O1xyXG4gICAgICAgIGZvciAodmFyIHggPSAwLCB3aWR0aCA9IGJpdE1hdHJpeC5nZXRXaWR0aCgpOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0geCArIDEsIGhlaWdodCA9IGJpdE1hdHJpeC5nZXRIZWlnaHQoKTsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYml0TWF0cml4LmdldCh4LCB5KSAhPT0gYml0TWF0cml4LmdldCh5LCB4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5mbGlwKHksIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5mbGlwKHgsIHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBCaXRNYXRyaXhQYXJzZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJpdE1hdHJpeFBhcnNlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qml0TWF0cml4UGFyc2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIDxwPkVuY2Fwc3VsYXRlcyBhIGJsb2NrIG9mIGRhdGEgd2l0aGluIGEgUVIgQ29kZS4gUVIgQ29kZXMgbWF5IHNwbGl0IHRoZWlyIGRhdGEgaW50b1xyXG4gKiBtdWx0aXBsZSBibG9ja3MsIGVhY2ggb2Ygd2hpY2ggaXMgYSB1bml0IG9mIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzLiBFYWNoXHJcbiAqIGlzIHJlcHJlc2VudGVkIGJ5IGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIERhdGFCbG9jayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERhdGFCbG9jayhudW1EYXRhQ29kZXdvcmRzIC8qaW50Ki8sIGNvZGV3b3Jkcykge1xyXG4gICAgICAgIHRoaXMubnVtRGF0YUNvZGV3b3JkcyA9IG51bURhdGFDb2Rld29yZHM7XHJcbiAgICAgICAgdGhpcy5jb2Rld29yZHMgPSBjb2Rld29yZHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIDxwPldoZW4gUVIgQ29kZXMgdXNlIG11bHRpcGxlIGRhdGEgYmxvY2tzLCB0aGV5IGFyZSBhY3R1YWxseSBpbnRlcmxlYXZlZC5cclxuICAgICAqIFRoYXQgaXMsIHRoZSBmaXJzdCBieXRlIG9mIGRhdGEgYmxvY2sgMSB0byBuIGlzIHdyaXR0ZW4sIHRoZW4gdGhlIHNlY29uZCBieXRlcywgYW5kIHNvIG9uLiBUaGlzXHJcbiAgICAgKiBtZXRob2Qgd2lsbCBzZXBhcmF0ZSB0aGUgZGF0YSBpbnRvIG9yaWdpbmFsIGJsb2Nrcy48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJhd0NvZGV3b3JkcyBieXRlcyBhcyByZWFkIGRpcmVjdGx5IGZyb20gdGhlIFFSIENvZGVcclxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIHZlcnNpb24gb2YgdGhlIFFSIENvZGVcclxuICAgICAqIEBwYXJhbSBlY0xldmVsIGVycm9yLWNvcnJlY3Rpb24gbGV2ZWwgb2YgdGhlIFFSIENvZGVcclxuICAgICAqIEByZXR1cm4gRGF0YUJsb2NrcyBjb250YWluaW5nIG9yaWdpbmFsIGJ5dGVzLCBcImRlLWludGVybGVhdmVkXCIgZnJvbSByZXByZXNlbnRhdGlvbiBpbiB0aGVcclxuICAgICAqICAgICAgICAgUVIgQ29kZVxyXG4gICAgICovXHJcbiAgICBEYXRhQmxvY2suZ2V0RGF0YUJsb2NrcyA9IGZ1bmN0aW9uIChyYXdDb2Rld29yZHMsIHZlcnNpb24sIGVjTGV2ZWwpIHtcclxuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcclxuICAgICAgICBpZiAocmF3Q29kZXdvcmRzLmxlbmd0aCAhPT0gdmVyc2lvbi5nZXRUb3RhbENvZGV3b3JkcygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIG51bWJlciBhbmQgc2l6ZSBvZiBkYXRhIGJsb2NrcyB1c2VkIGJ5IHRoaXMgdmVyc2lvbiBhbmRcclxuICAgICAgICAvLyBlcnJvciBjb3JyZWN0aW9uIGxldmVsXHJcbiAgICAgICAgdmFyIGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpO1xyXG4gICAgICAgIC8vIEZpcnN0IGNvdW50IHRoZSB0b3RhbCBudW1iZXIgb2YgZGF0YSBibG9ja3NcclxuICAgICAgICB2YXIgdG90YWxCbG9ja3MgPSAwO1xyXG4gICAgICAgIHZhciBlY0Jsb2NrQXJyYXkgPSBlY0Jsb2Nrcy5nZXRFQ0Jsb2NrcygpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGVjQmxvY2tBcnJheV8xID0gX192YWx1ZXMoZWNCbG9ja0FycmF5KSwgZWNCbG9ja0FycmF5XzFfMSA9IGVjQmxvY2tBcnJheV8xLm5leHQoKTsgIWVjQmxvY2tBcnJheV8xXzEuZG9uZTsgZWNCbG9ja0FycmF5XzFfMSA9IGVjQmxvY2tBcnJheV8xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVjQmxvY2sgPSBlY0Jsb2NrQXJyYXlfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdG90YWxCbG9ja3MgKz0gZWNCbG9jay5nZXRDb3VudCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWNCbG9ja0FycmF5XzFfMSAmJiAhZWNCbG9ja0FycmF5XzFfMS5kb25lICYmIChfYSA9IGVjQmxvY2tBcnJheV8xLnJldHVybikpIF9hLmNhbGwoZWNCbG9ja0FycmF5XzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm93IGVzdGFibGlzaCBEYXRhQmxvY2tzIG9mIHRoZSBhcHByb3ByaWF0ZSBzaXplIGFuZCBudW1iZXIgb2YgZGF0YSBjb2Rld29yZHNcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHRvdGFsQmxvY2tzKTtcclxuICAgICAgICB2YXIgbnVtUmVzdWx0QmxvY2tzID0gMDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBlY0Jsb2NrQXJyYXlfMiA9IF9fdmFsdWVzKGVjQmxvY2tBcnJheSksIGVjQmxvY2tBcnJheV8yXzEgPSBlY0Jsb2NrQXJyYXlfMi5uZXh0KCk7ICFlY0Jsb2NrQXJyYXlfMl8xLmRvbmU7IGVjQmxvY2tBcnJheV8yXzEgPSBlY0Jsb2NrQXJyYXlfMi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlY0Jsb2NrID0gZWNCbG9ja0FycmF5XzJfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWNCbG9jay5nZXRDb3VudCgpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRGF0YUNvZGV3b3JkcyA9IGVjQmxvY2suZ2V0RGF0YUNvZGV3b3JkcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1CbG9ja0NvZGV3b3JkcyA9IGVjQmxvY2tzLmdldEVDQ29kZXdvcmRzUGVyQmxvY2soKSArIG51bURhdGFDb2Rld29yZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W251bVJlc3VsdEJsb2NrcysrXSA9IG5ldyBEYXRhQmxvY2sobnVtRGF0YUNvZGV3b3JkcywgbmV3IFVpbnQ4QXJyYXkobnVtQmxvY2tDb2Rld29yZHMpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVjQmxvY2tBcnJheV8yXzEgJiYgIWVjQmxvY2tBcnJheV8yXzEuZG9uZSAmJiAoX2IgPSBlY0Jsb2NrQXJyYXlfMi5yZXR1cm4pKSBfYi5jYWxsKGVjQmxvY2tBcnJheV8yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFsbCBibG9ja3MgaGF2ZSB0aGUgc2FtZSBhbW91bnQgb2YgZGF0YSwgZXhjZXB0IHRoYXQgdGhlIGxhc3QgblxyXG4gICAgICAgIC8vICh3aGVyZSBuIG1heSBiZSAwKSBoYXZlIDEgbW9yZSBieXRlLiBGaWd1cmUgb3V0IHdoZXJlIHRoZXNlIHN0YXJ0LlxyXG4gICAgICAgIHZhciBzaG9ydGVyQmxvY2tzVG90YWxDb2Rld29yZHMgPSByZXN1bHRbMF0uY29kZXdvcmRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgbG9uZ2VyQmxvY2tzU3RhcnRBdCA9IHJlc3VsdC5sZW5ndGggLSAxO1xyXG4gICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBjaGVjayBsZW5ndGggaXMgY29ycmVjdCBoZXJlXHJcbiAgICAgICAgd2hpbGUgKGxvbmdlckJsb2Nrc1N0YXJ0QXQgPj0gMCkge1xyXG4gICAgICAgICAgICB2YXIgbnVtQ29kZXdvcmRzID0gcmVzdWx0W2xvbmdlckJsb2Nrc1N0YXJ0QXRdLmNvZGV3b3Jkcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChudW1Db2Rld29yZHMgPT09IHNob3J0ZXJCbG9ja3NUb3RhbENvZGV3b3Jkcykge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9uZ2VyQmxvY2tzU3RhcnRBdC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb25nZXJCbG9ja3NTdGFydEF0Kys7XHJcbiAgICAgICAgdmFyIHNob3J0ZXJCbG9ja3NOdW1EYXRhQ29kZXdvcmRzID0gc2hvcnRlckJsb2Nrc1RvdGFsQ29kZXdvcmRzIC0gZWNCbG9ja3MuZ2V0RUNDb2Rld29yZHNQZXJCbG9jaygpO1xyXG4gICAgICAgIC8vIFRoZSBsYXN0IGVsZW1lbnRzIG9mIHJlc3VsdCBtYXkgYmUgMSBlbGVtZW50IGxvbmdlclxyXG4gICAgICAgIC8vIGZpcnN0IGZpbGwgb3V0IGFzIG1hbnkgZWxlbWVudHMgYXMgYWxsIG9mIHRoZW0gaGF2ZVxyXG4gICAgICAgIHZhciByYXdDb2Rld29yZHNPZmZzZXQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvcnRlckJsb2Nrc051bURhdGFDb2Rld29yZHM7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bVJlc3VsdEJsb2NrczsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW2ldID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGaWxsIG91dCB0aGUgbGFzdCBkYXRhIGJsb2NrIGluIHRoZSBsb25nZXIgb25lc1xyXG4gICAgICAgIGZvciAodmFyIGogPSBsb25nZXJCbG9ja3NTdGFydEF0OyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0W2pdLmNvZGV3b3Jkc1tzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3Jkc10gPSByYXdDb2Rld29yZHNbcmF3Q29kZXdvcmRzT2Zmc2V0KytdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3cgYWRkIGluIGVycm9yIGNvcnJlY3Rpb24gYmxvY2tzXHJcbiAgICAgICAgdmFyIG1heCA9IHJlc3VsdFswXS5jb2Rld29yZHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBzaG9ydGVyQmxvY2tzTnVtRGF0YUNvZGV3b3JkczsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtUmVzdWx0QmxvY2tzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpT2Zmc2V0ID0gaiA8IGxvbmdlckJsb2Nrc1N0YXJ0QXQgPyBpIDogaSArIDE7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRbal0uY29kZXdvcmRzW2lPZmZzZXRdID0gcmF3Q29kZXdvcmRzW3Jhd0NvZGV3b3Jkc09mZnNldCsrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIERhdGFCbG9jay5wcm90b3R5cGUuZ2V0TnVtRGF0YUNvZGV3b3JkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5udW1EYXRhQ29kZXdvcmRzO1xyXG4gICAgfTtcclxuICAgIERhdGFCbG9jay5wcm90b3R5cGUuZ2V0Q29kZXdvcmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvZGV3b3JkcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0YUJsb2NrO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXRhQmxvY2s7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFCbG9jay5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBEYXRhTWFza1ZhbHVlcztcclxuKGZ1bmN0aW9uIChEYXRhTWFza1ZhbHVlcykge1xyXG4gICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMDAwXCJdID0gMF0gPSBcIkRBVEFfTUFTS18wMDBcIjtcclxuICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzAwMVwiXSA9IDFdID0gXCJEQVRBX01BU0tfMDAxXCI7XHJcbiAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18wMTBcIl0gPSAyXSA9IFwiREFUQV9NQVNLXzAxMFwiO1xyXG4gICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMDExXCJdID0gM10gPSBcIkRBVEFfTUFTS18wMTFcIjtcclxuICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzEwMFwiXSA9IDRdID0gXCJEQVRBX01BU0tfMTAwXCI7XHJcbiAgICBEYXRhTWFza1ZhbHVlc1tEYXRhTWFza1ZhbHVlc1tcIkRBVEFfTUFTS18xMDFcIl0gPSA1XSA9IFwiREFUQV9NQVNLXzEwMVwiO1xyXG4gICAgRGF0YU1hc2tWYWx1ZXNbRGF0YU1hc2tWYWx1ZXNbXCJEQVRBX01BU0tfMTEwXCJdID0gNl0gPSBcIkRBVEFfTUFTS18xMTBcIjtcclxuICAgIERhdGFNYXNrVmFsdWVzW0RhdGFNYXNrVmFsdWVzW1wiREFUQV9NQVNLXzExMVwiXSA9IDddID0gXCJEQVRBX01BU0tfMTExXCI7XHJcbn0pKERhdGFNYXNrVmFsdWVzID0gZXhwb3J0cy5EYXRhTWFza1ZhbHVlcyB8fCAoZXhwb3J0cy5EYXRhTWFza1ZhbHVlcyA9IHt9KSk7XHJcbi8qKlxyXG4gKiA8cD5FbmNhcHN1bGF0ZXMgZGF0YSBtYXNrcyBmb3IgdGhlIGRhdGEgYml0cyBpbiBhIFFSIGNvZGUsIHBlciBJU08gMTgwMDQ6MjAwNiA2LjguIEltcGxlbWVudGF0aW9uc1xyXG4gKiBvZiB0aGlzIGNsYXNzIGNhbiB1bi1tYXNrIGEgcmF3IEJpdE1hdHJpeC4gRm9yIHNpbXBsaWNpdHksIHRoZXkgd2lsbCB1bm1hc2sgdGhlIGVudGlyZSBCaXRNYXRyaXgsXHJcbiAqIGluY2x1ZGluZyBhcmVhcyB1c2VkIGZvciBmaW5kZXIgcGF0dGVybnMsIHRpbWluZyBwYXR0ZXJucywgZXRjLiBUaGVzZSBhcmVhcyBzaG91bGQgYmUgdW51c2VkXHJcbiAqIGFmdGVyIHRoZSBwb2ludCB0aGV5IGFyZSB1bm1hc2tlZCBhbnl3YXkuPC9wPlxyXG4gKlxyXG4gKiA8cD5Ob3RlIHRoYXQgdGhlIGRpYWdyYW0gaW4gc2VjdGlvbiA2LjguMSBpcyBtaXNsZWFkaW5nIHNpbmNlIGl0IGluZGljYXRlcyB0aGF0IGkgaXMgY29sdW1uIHBvc2l0aW9uXHJcbiAqIGFuZCBqIGlzIHJvdyBwb3NpdGlvbi4gSW4gZmFjdCwgYXMgdGhlIHRleHQgc2F5cywgaSBpcyByb3cgcG9zaXRpb24gYW5kIGogaXMgY29sdW1uIHBvc2l0aW9uLjwvcD5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICovXHJcbnZhciBEYXRhTWFzayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIFNlZSBJU08gMTgwMDQ6MjAwNiA2LjguMVxyXG4gICAgZnVuY3Rpb24gRGF0YU1hc2sodmFsdWUsIGlzTWFza2VkKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuaXNNYXNrZWQgPSBpc01hc2tlZDtcclxuICAgIH1cclxuICAgIC8vIEVuZCBvZiBlbnVtIGNvbnN0YW50cy5cclxuICAgIC8qKlxyXG4gICAgICogPHA+SW1wbGVtZW50YXRpb25zIG9mIHRoaXMgbWV0aG9kIHJldmVyc2UgdGhlIGRhdGEgbWFza2luZyBwcm9jZXNzIGFwcGxpZWQgdG8gYSBRUiBDb2RlIGFuZFxyXG4gICAgICogbWFrZSBpdHMgYml0cyByZWFkeSB0byByZWFkLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYml0cyByZXByZXNlbnRhdGlvbiBvZiBRUiBDb2RlIGJpdHNcclxuICAgICAqIEBwYXJhbSBkaW1lbnNpb24gZGltZW5zaW9uIG9mIFFSIENvZGUsIHJlcHJlc2VudGVkIGJ5IGJpdHMsIGJlaW5nIHVubWFza2VkXHJcbiAgICAgKi9cclxuICAgIERhdGFNYXNrLnByb3RvdHlwZS51bm1hc2tCaXRNYXRyaXggPSBmdW5jdGlvbiAoYml0cywgZGltZW5zaW9uIC8qaW50Ki8pIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGltZW5zaW9uOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTWFza2VkKGksIGopKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYml0cy5mbGlwKGosIGkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGFNYXNrLnZhbHVlcyA9IG5ldyBNYXAoW1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIDAwMDogbWFzayBiaXRzIGZvciB3aGljaCAoeCArIHkpIG1vZCAyID09IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAwMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMDAsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gKChpICsgaikgJiAweDAxKSA9PT0gMDsgfSldLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIDAwMTogbWFzayBiaXRzIGZvciB3aGljaCB4IG1vZCAyID09IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAwMSwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMDEsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gKGkgJiAweDAxKSA9PT0gMDsgfSldLFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIDAxMDogbWFzayBiaXRzIGZvciB3aGljaCB5IG1vZCAzID09IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzAxMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMTAsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gaiAlIDMgPT09IDA7IH0pXSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAwMTE6IG1hc2sgYml0cyBmb3Igd2hpY2ggKHggKyB5KSBtb2QgMyA9PSAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18wMTEsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMDExLCBmdW5jdGlvbiAoaSAvKmludCovLCBqIC8qaW50Ki8pIHsgcmV0dXJuIChpICsgaikgJSAzID09PSAwOyB9KV0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogMTAwOiBtYXNrIGJpdHMgZm9yIHdoaWNoICh4LzIgKyB5LzMpIG1vZCAyID09IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzEwMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMDAsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gKChNYXRoLmZsb29yKGkgLyAyKSArIE1hdGguZmxvb3IoaiAvIDMpKSAmIDB4MDEpID09PSAwOyB9KV0sXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogMTAxOiBtYXNrIGJpdHMgZm9yIHdoaWNoIHh5IG1vZCAyICsgeHkgbW9kIDMgPT0gMFxyXG4gICAgICAgICAqIGVxdWl2YWxlbnRseSwgc3VjaCB0aGF0IHh5IG1vZCA2ID09IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzEwMSwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMDEsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gKGkgKiBqKSAlIDYgPT09IDA7IH0pXSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAxMTA6IG1hc2sgYml0cyBmb3Igd2hpY2ggKHh5IG1vZCAyICsgeHkgbW9kIDMpIG1vZCAyID09IDBcclxuICAgICAgICAgKiBlcXVpdmFsZW50bHksIHN1Y2ggdGhhdCB4eSBtb2QgNiA8IDNcclxuICAgICAgICAgKi9cclxuICAgICAgICBbRGF0YU1hc2tWYWx1ZXMuREFUQV9NQVNLXzExMCwgbmV3IERhdGFNYXNrKERhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMTAsIGZ1bmN0aW9uIChpIC8qaW50Ki8sIGogLyppbnQqLykgeyByZXR1cm4gKChpICogaikgJSA2KSA8IDM7IH0pXSxcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAxMTE6IG1hc2sgYml0cyBmb3Igd2hpY2ggKCh4K3kpbW9kIDIgKyB4eSBtb2QgMykgbW9kIDIgPT0gMFxyXG4gICAgICAgICAqIGVxdWl2YWxlbnRseSwgc3VjaCB0aGF0ICh4ICsgeSArIHh5IG1vZCAzKSBtb2QgMiA9PSAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgW0RhdGFNYXNrVmFsdWVzLkRBVEFfTUFTS18xMTEsIG5ldyBEYXRhTWFzayhEYXRhTWFza1ZhbHVlcy5EQVRBX01BU0tfMTExLCBmdW5jdGlvbiAoaSAvKmludCovLCBqIC8qaW50Ki8pIHsgcmV0dXJuICgoaSArIGogKyAoKGkgKiBqKSAlIDMpKSAmIDB4MDEpID09PSAwOyB9KV0sXHJcbiAgICBdKTtcclxuICAgIHJldHVybiBEYXRhTWFzaztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0YU1hc2s7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURhdGFNYXNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEJpdFNvdXJjZV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9CaXRTb3VyY2VcIik7XHJcbnZhciBDaGFyYWN0ZXJTZXRFQ0lfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vQ2hhcmFjdGVyU2V0RUNJXCIpO1xyXG52YXIgRGVjb2RlclJlc3VsdF8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9EZWNvZGVyUmVzdWx0XCIpO1xyXG52YXIgU3RyaW5nVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vU3RyaW5nVXRpbHNcIik7XHJcbnZhciBNb2RlXzEgPSByZXF1aXJlKFwiLi9Nb2RlXCIpO1xyXG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcclxudmFyIFN0cmluZ0VuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9TdHJpbmdFbmNvZGluZ1wiKTtcclxudmFyIEZvcm1hdEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0Zvcm1hdEV4Y2VwdGlvblwiKTtcclxuLyppbXBvcnQgamF2YS5pby5VbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uOyovXHJcbi8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cclxuLyppbXBvcnQgamF2YS51dGlsLkNvbGxlY3Rpb247Ki9cclxuLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cclxuLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xyXG4vKipcclxuICogPHA+UVIgQ29kZXMgY2FuIGVuY29kZSB0ZXh0IGFzIGJpdHMgaW4gb25lIG9mIHNldmVyYWwgbW9kZXMsIGFuZCBjYW4gdXNlIG11bHRpcGxlIG1vZGVzXHJcbiAqIGluIG9uZSBRUiBDb2RlLiBUaGlzIGNsYXNzIGRlY29kZXMgdGhlIGJpdHMgYmFjayBpbnRvIHRleHQuPC9wPlxyXG4gKlxyXG4gKiA8cD5TZWUgSVNPIDE4MDA0OjIwMDYsIDYuNC4zIC0gNi40Ljc8L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqL1xyXG52YXIgRGVjb2RlZEJpdFN0cmVhbVBhcnNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlY29kZWRCaXRTdHJlYW1QYXJzZXIoKSB7XHJcbiAgICB9XHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZSA9IGZ1bmN0aW9uIChieXRlcywgdmVyc2lvbiwgZWNMZXZlbCwgaGludHMpIHtcclxuICAgICAgICB2YXIgYml0cyA9IG5ldyBCaXRTb3VyY2VfMS5kZWZhdWx0KGJ5dGVzKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgdmFyIGJ5dGVTZWdtZW50cyA9IG5ldyBBcnJheSgpOyAvLyAxXHJcbiAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IEkgZG8gbm90IHVzZSBjb25zdHJ1Y3RvciB3aXRoIHNpemUgMSBhcyBpbiBvcmlnaW5hbCBKYXZhIG1lYW5zIGNhcGFjaXR5IGFuZCB0aGUgYXJyYXkgbGVuZ3RoIGlzIGNoZWNrZWQgYmVsb3dcclxuICAgICAgICB2YXIgc3ltYm9sU2VxdWVuY2UgPSAtMTtcclxuICAgICAgICB2YXIgcGFyaXR5RGF0YSA9IC0xO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIGZjMUluRWZmZWN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBtb2RlID0gdm9pZCAwO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAvLyBXaGlsZSBzdGlsbCBhbm90aGVyIHNlZ21lbnQgdG8gcmVhZC4uLlxyXG4gICAgICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT0ssIGFzc3VtZSB3ZSdyZSBkb25lLiBSZWFsbHksIGEgVEVSTUlOQVRPUiBtb2RlIHNob3VsZCBoYXZlIGJlZW4gcmVjb3JkZWQgaGVyZVxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGUgPSBNb2RlXzEuZGVmYXVsdC5URVJNSU5BVE9SO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGVCaXRzID0gYml0cy5yZWFkQml0cyg0KTtcclxuICAgICAgICAgICAgICAgICAgICBtb2RlID0gTW9kZV8xLmRlZmF1bHQuZm9yQml0cyhtb2RlQml0cyk7IC8vIG1vZGUgaXMgZW5jb2RlZCBieSA0IGJpdHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuVEVSTUlOQVRPUjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlXzEuZGVmYXVsdC5GTkMxX0ZJUlNUX1BPU0lUSU9OOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuRk5DMV9TRUNPTkRfUE9TSVRJT046XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvIGxpdHRsZSB3aXRoIEZOQzEgZXhjZXB0IGFsdGVyIHRoZSBwYXJzZWQgcmVzdWx0IGEgYml0IGFjY29yZGluZyB0byB0aGUgc3BlY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYzFJbkVmZmVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuU1RSVUNUVVJFRF9BUFBFTkQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaXRzLmF2YWlsYWJsZSgpIDwgMTYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VxdWVuY2UgbnVtYmVyIGFuZCBwYXJpdHkgaXMgYWRkZWQgbGF0ZXIgdG8gdGhlIHJlc3VsdCBtZXRhZGF0YVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWFkIG5leHQgOCBiaXRzIChzeW1ib2wgc2VxdWVuY2UgIykgYW5kIDggYml0cyAoZGF0YTogcGFyaXR5KSwgdGhlbiBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2xTZXF1ZW5jZSA9IGJpdHMucmVhZEJpdHMoOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcml0eURhdGEgPSBiaXRzLnJlYWRCaXRzKDgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0LkVDSTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgZG9lc24ndCBhcHBseSB0byBFQ0lcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5wYXJzZUVDSVZhbHVlKGJpdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJID0gQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5nZXRDaGFyYWN0ZXJTZXRFQ0lCeVZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0kgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBNb2RlXzEuZGVmYXVsdC5IQU5aSTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgaGFuZGxlIEhhbnppIG1vZGUgd2hpY2ggZG9lcyBub3Qgc3RhcnQgd2l0aCBjaGFyYWN0ZXIgY291bnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hpbmVzZSBtb2RlIGNvbnRhaW5zIGEgc3ViIHNldCBpbmRpY2F0b3IgcmlnaHQgYWZ0ZXIgbW9kZSBpbmRpY2F0b3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YnNldCA9IGJpdHMucmVhZEJpdHMoNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudEhhbnppID0gYml0cy5yZWFkQml0cyhtb2RlLmdldENoYXJhY3RlckNvdW50Qml0cyh2ZXJzaW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzZXQgPT09IERlY29kZWRCaXRTdHJlYW1QYXJzZXIuR0IyMzEyX1NVQlNFVCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVIYW56aVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudEhhbnppKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBcIk5vcm1hbFwiIFFSIGNvZGUgbW9kZXM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvdyBtYW55IGNoYXJhY3RlcnMgd2lsbCBmb2xsb3csIGVuY29kZWQgaW4gdGhpcyBtb2RlP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBiaXRzLnJlYWRCaXRzKG1vZGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKHZlcnNpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0Lk5VTUVSSUM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVOdW1lcmljU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuQUxQSEFOVU1FUklDOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlQWxwaGFudW1lcmljU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50LCBmYzFJbkVmZmVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0LkJZVEU6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVCeXRlU2VnbWVudChiaXRzLCByZXN1bHQsIGNvdW50LCBjdXJyZW50Q2hhcmFjdGVyU2V0RUNJLCBieXRlU2VnbWVudHMsIGhpbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuS0FOSkk6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVLYW5qaVNlZ21lbnQoYml0cywgcmVzdWx0LCBjb3VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKG1vZGUgIT09IE1vZGVfMS5kZWZhdWx0LlRFUk1JTkFUT1IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoaWFlIC8qOiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24qLykge1xyXG4gICAgICAgICAgICAvLyBmcm9tIHJlYWRCaXRzKCkgY2FsbHNcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVyUmVzdWx0XzEuZGVmYXVsdChieXRlcywgcmVzdWx0LnRvU3RyaW5nKCksIGJ5dGVTZWdtZW50cy5sZW5ndGggPT09IDAgPyBudWxsIDogYnl0ZVNlZ21lbnRzLCBlY0xldmVsID09PSBudWxsID8gbnVsbCA6IGVjTGV2ZWwudG9TdHJpbmcoKSwgc3ltYm9sU2VxdWVuY2UsIHBhcml0eURhdGEpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2VlIHNwZWNpZmljYXRpb24gR0JUIDE4Mjg0LTIwMDBcclxuICAgICAqL1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVIYW56aVNlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovKSB7XHJcbiAgICAgICAgLy8gRG9uJ3QgY3Jhc2ggdHJ5aW5nIHRvIHJlYWQgbW9yZSBiaXRzIHRoYW4gd2UgaGF2ZSBhdmFpbGFibGUuXHJcbiAgICAgICAgaWYgKGNvdW50ICogMTMgPiBiaXRzLmF2YWlsYWJsZSgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEVhY2ggY2hhcmFjdGVyIHdpbGwgcmVxdWlyZSAyIGJ5dGVzLiBSZWFkIHRoZSBjaGFyYWN0ZXJzIGFzIDItYnl0ZSBwYWlyc1xyXG4gICAgICAgIC8vIGFuZCBkZWNvZGUgYXMgR0IyMzEyIGFmdGVyd2FyZHNcclxuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMiAqIGNvdW50KTtcclxuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcclxuICAgICAgICB3aGlsZSAoY291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIEVhY2ggMTMgYml0cyBlbmNvZGVzIGEgMi1ieXRlIGNoYXJhY3RlclxyXG4gICAgICAgICAgICB2YXIgdHdvQnl0ZXMgPSBiaXRzLnJlYWRCaXRzKDEzKTtcclxuICAgICAgICAgICAgdmFyIGFzc2VtYmxlZFR3b0J5dGVzID0gKCgodHdvQnl0ZXMgLyAweDA2MCkgPDwgOCkgJiAweEZGRkZGRkZGKSB8ICh0d29CeXRlcyAlIDB4MDYwKTtcclxuICAgICAgICAgICAgaWYgKGFzc2VtYmxlZFR3b0J5dGVzIDwgMHgwMDNCRikge1xyXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIDB4QTFBMSB0byAweEFBRkUgcmFuZ2VcclxuICAgICAgICAgICAgICAgIGFzc2VtYmxlZFR3b0J5dGVzICs9IDB4MEExQTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgMHhCMEExIHRvIDB4RkFGRSByYW5nZVxyXG4gICAgICAgICAgICAgICAgYXNzZW1ibGVkVHdvQnl0ZXMgKz0gMHgwQTZBMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBidWZmZXJbb2Zmc2V0XSA9IC8qKGJ5dGUpICovICgoYXNzZW1ibGVkVHdvQnl0ZXMgPj4gOCkgJiAweEZGKTtcclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIDFdID0gLyooYnl0ZSkgKi8gKGFzc2VtYmxlZFR3b0J5dGVzICYgMHhGRik7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSAyO1xyXG4gICAgICAgICAgICBjb3VudC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKFN0cmluZ0VuY29kaW5nXzEuZGVmYXVsdC5kZWNvZGUoYnVmZmVyLCBTdHJpbmdVdGlsc18xLmRlZmF1bHQuR0IyMzEyKSk7XHJcbiAgICAgICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBUT0RPOiBpbXBsZW1lbnQgR0IyMzEyIGRlY29kZS4gU3RyaW5nVmlldyBmcm9tIE1ETiBjb3VsZCBiZSBhIHN0YXJ0aW5nIHBvaW50XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uKi8pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoaWdub3JlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuZGVjb2RlS2FuamlTZWdtZW50ID0gZnVuY3Rpb24gKGJpdHMsIHJlc3VsdCwgY291bnQgLyppbnQqLykge1xyXG4gICAgICAgIC8vIERvbid0IGNyYXNoIHRyeWluZyB0byByZWFkIG1vcmUgYml0cyB0aGFuIHdlIGhhdmUgYXZhaWxhYmxlLlxyXG4gICAgICAgIGlmIChjb3VudCAqIDEzID4gYml0cy5hdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBFYWNoIGNoYXJhY3RlciB3aWxsIHJlcXVpcmUgMiBieXRlcy4gUmVhZCB0aGUgY2hhcmFjdGVycyBhcyAyLWJ5dGUgcGFpcnNcclxuICAgICAgICAvLyBhbmQgZGVjb2RlIGFzIFNoaWZ0X0pJUyBhZnRlcndhcmRzXHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDIgKiBjb3VudCk7XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGNvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAvLyBFYWNoIDEzIGJpdHMgZW5jb2RlcyBhIDItYnl0ZSBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgdmFyIHR3b0J5dGVzID0gYml0cy5yZWFkQml0cygxMyk7XHJcbiAgICAgICAgICAgIHZhciBhc3NlbWJsZWRUd29CeXRlcyA9ICgoKHR3b0J5dGVzIC8gMHgwQzApIDw8IDgpICYgMHhGRkZGRkZGRikgfCAodHdvQnl0ZXMgJSAweDBDMCk7XHJcbiAgICAgICAgICAgIGlmIChhc3NlbWJsZWRUd29CeXRlcyA8IDB4MDFGMDApIHtcclxuICAgICAgICAgICAgICAgIC8vIEluIHRoZSAweDgxNDAgdG8gMHg5RkZDIHJhbmdlXHJcbiAgICAgICAgICAgICAgICBhc3NlbWJsZWRUd29CeXRlcyArPSAweDA4MTQwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIDB4RTA0MCB0byAweEVCQkYgcmFuZ2VcclxuICAgICAgICAgICAgICAgIGFzc2VtYmxlZFR3b0J5dGVzICs9IDB4MEMxNDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnVmZmVyW29mZnNldF0gPSAvKihieXRlKSAqLyAoYXNzZW1ibGVkVHdvQnl0ZXMgPj4gOCk7XHJcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyAxXSA9IC8qKGJ5dGUpICovIGFzc2VtYmxlZFR3b0J5dGVzO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gMjtcclxuICAgICAgICAgICAgY291bnQtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2hpZnRfSklTIG1heSBub3QgYmUgc3VwcG9ydGVkIGluIHNvbWUgZW52aXJvbm1lbnRzOlxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmRlY29kZShidWZmZXIsIFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5TSElGVF9KSVMpKTtcclxuICAgICAgICAgICAgLy8gVFlQRVNDUklQVFBPUlQ6IFRPRE86IGltcGxlbWVudCBTSElGVF9KSVMgZGVjb2RlLiBTdHJpbmdWaWV3IGZyb20gTUROIGNvdWxkIGJlIGEgc3RhcnRpbmcgcG9pbnRcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdChpZ25vcmVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVCeXRlU2VnbWVudCA9IGZ1bmN0aW9uIChiaXRzLCByZXN1bHQsIGNvdW50IC8qaW50Ki8sIGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0ksIGJ5dGVTZWdtZW50cywgaGludHMpIHtcclxuICAgICAgICAvLyBEb24ndCBjcmFzaCB0cnlpbmcgdG8gcmVhZCBtb3JlIGJpdHMgdGhhbiB3ZSBoYXZlIGF2YWlsYWJsZS5cclxuICAgICAgICBpZiAoOCAqIGNvdW50ID4gYml0cy5hdmFpbGFibGUoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVhZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICByZWFkQnl0ZXNbaV0gPSAvKihieXRlKSAqLyBiaXRzLnJlYWRCaXRzKDgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZW5jb2Rpbmc7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXJTZXRFQ0kgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gVGhlIHNwZWMgaXNuJ3QgY2xlYXIgb24gdGhpcyBtb2RlOyBzZWVcclxuICAgICAgICAgICAgLy8gc2VjdGlvbiA2LjQuNTogdCBkb2VzIG5vdCBzYXkgd2hpY2ggZW5jb2RpbmcgdG8gYXNzdW1pbmdcclxuICAgICAgICAgICAgLy8gdXBvbiBkZWNvZGluZy4gSSBoYXZlIHNlZW4gSVNPLTg4NTktMSB1c2VkIGFzIHdlbGwgYXNcclxuICAgICAgICAgICAgLy8gU2hpZnRfSklTIC0tIHdpdGhvdXQgYW55dGhpbmcgbGlrZSBhbiBFQ0kgZGVzaWduYXRvciB0b1xyXG4gICAgICAgICAgICAvLyBnaXZlIGEgaGludC5cclxuICAgICAgICAgICAgZW5jb2RpbmcgPSBTdHJpbmdVdGlsc18xLmRlZmF1bHQuZ3Vlc3NFbmNvZGluZyhyZWFkQnl0ZXMsIGhpbnRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVuY29kaW5nID0gY3VycmVudENoYXJhY3RlclNldEVDSS5nZXROYW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmRlY29kZShyZWFkQnl0ZXMsIGVuY29kaW5nKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uKi8pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoaWdub3JlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ5dGVTZWdtZW50cy5wdXNoKHJlYWRCeXRlcyk7XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50b0FscGhhTnVtZXJpY0NoYXIgPSBmdW5jdGlvbiAodmFsdWUgLyppbnQqLykge1xyXG4gICAgICAgIGlmICh2YWx1ZSA+PSBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLkFMUEhBTlVNRVJJQ19DSEFSUy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuQUxQSEFOVU1FUklDX0NIQVJTW3ZhbHVlXTtcclxuICAgIH07XHJcbiAgICBEZWNvZGVkQml0U3RyZWFtUGFyc2VyLmRlY29kZUFscGhhbnVtZXJpY1NlZ21lbnQgPSBmdW5jdGlvbiAoYml0cywgcmVzdWx0LCBjb3VudCAvKmludCovLCBmYzFJbkVmZmVjdCkge1xyXG4gICAgICAgIC8vIFJlYWQgdHdvIGNoYXJhY3RlcnMgYXQgYSB0aW1lXHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmVzdWx0Lmxlbmd0aCgpO1xyXG4gICAgICAgIHdoaWxlIChjb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCAxMSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgbmV4dFR3b0NoYXJzQml0cyA9IGJpdHMucmVhZEJpdHMoMTEpO1xyXG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IobmV4dFR3b0NoYXJzQml0cyAvIDQ1KSkpO1xyXG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyKG5leHRUd29DaGFyc0JpdHMgJSA0NSkpO1xyXG4gICAgICAgICAgICBjb3VudCAtPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY291bnQgPT09IDEpIHtcclxuICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlOiBvbmUgY2hhcmFjdGVyIGxlZnRcclxuICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA2KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50b0FscGhhTnVtZXJpY0NoYXIoYml0cy5yZWFkQml0cyg2KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZWUgc2VjdGlvbiA2LjQuOC4xLCA2LjQuOC4yXHJcbiAgICAgICAgaWYgKGZjMUluRWZmZWN0KSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFzc2FnZSB0aGUgcmVzdWx0IGEgYml0IGlmIGluIGFuIEZOQzEgbW9kZTpcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgcmVzdWx0Lmxlbmd0aCgpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuY2hhckF0KGkpID09PSAnJScpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IHJlc3VsdC5sZW5ndGgoKSAtIDEgJiYgcmVzdWx0LmNoYXJBdChpICsgMSkgPT09ICclJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAlJSBpcyByZW5kZXJlZCBhcyAlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kZWxldGVDaGFyQXQoaSArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW4gYWxwaGEgbW9kZSwgJSBzaG91bGQgYmUgY29udmVydGVkIHRvIEZOQzEgc2VwYXJhdG9yIDB4MURcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldENoYXJBdChpLCBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4MUQpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5kZWNvZGVOdW1lcmljU2VnbWVudCA9IGZ1bmN0aW9uIChiaXRzLCByZXN1bHQsIGNvdW50IC8qaW50Ki8pIHtcclxuICAgICAgICAvLyBSZWFkIHRocmVlIGRpZ2l0cyBhdCBhIHRpbWVcclxuICAgICAgICB3aGlsZSAoY291bnQgPj0gMykge1xyXG4gICAgICAgICAgICAvLyBFYWNoIDEwIGJpdHMgZW5jb2RlcyB0aHJlZSBkaWdpdHNcclxuICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCAxMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGhyZWVEaWdpdHNCaXRzID0gYml0cy5yZWFkQml0cygxMCk7XHJcbiAgICAgICAgICAgIGlmICh0aHJlZURpZ2l0c0JpdHMgPj0gMTAwMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IodGhyZWVEaWdpdHNCaXRzIC8gMTAwKSkpO1xyXG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kKERlY29kZWRCaXRTdHJlYW1QYXJzZXIudG9BbHBoYU51bWVyaWNDaGFyKE1hdGguZmxvb3IodGhyZWVEaWdpdHNCaXRzIC8gMTApICUgMTApKTtcclxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRvQWxwaGFOdW1lcmljQ2hhcih0aHJlZURpZ2l0c0JpdHMgJSAxMCkpO1xyXG4gICAgICAgICAgICBjb3VudCAtPSAzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY291bnQgPT09IDIpIHtcclxuICAgICAgICAgICAgLy8gVHdvIGRpZ2l0cyBsZWZ0IG92ZXIgdG8gcmVhZCwgZW5jb2RlZCBpbiA3IGJpdHNcclxuICAgICAgICAgICAgaWYgKGJpdHMuYXZhaWxhYmxlKCkgPCA3KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB0d29EaWdpdHNCaXRzID0gYml0cy5yZWFkQml0cyg3KTtcclxuICAgICAgICAgICAgaWYgKHR3b0RpZ2l0c0JpdHMgPj0gMTAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50b0FscGhhTnVtZXJpY0NoYXIoTWF0aC5mbG9vcih0d29EaWdpdHNCaXRzIC8gMTApKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoRGVjb2RlZEJpdFN0cmVhbVBhcnNlci50b0FscGhhTnVtZXJpY0NoYXIodHdvRGlnaXRzQml0cyAlIDEwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIE9uZSBkaWdpdCBsZWZ0IG92ZXIgdG8gcmVhZFxyXG4gICAgICAgICAgICBpZiAoYml0cy5hdmFpbGFibGUoKSA8IDQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGRpZ2l0Qml0cyA9IGJpdHMucmVhZEJpdHMoNCk7XHJcbiAgICAgICAgICAgIGlmIChkaWdpdEJpdHMgPj0gMTApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChEZWNvZGVkQml0U3RyZWFtUGFyc2VyLnRvQWxwaGFOdW1lcmljQ2hhcihkaWdpdEJpdHMpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5wYXJzZUVDSVZhbHVlID0gZnVuY3Rpb24gKGJpdHMpIHtcclxuICAgICAgICB2YXIgZmlyc3RCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcclxuICAgICAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4ODApID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIGp1c3Qgb25lIGJ5dGVcclxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0Qnl0ZSAmIDB4N0Y7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoZmlyc3RCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcclxuICAgICAgICAgICAgLy8gdHdvIGJ5dGVzXHJcbiAgICAgICAgICAgIHZhciBzZWNvbmRCeXRlID0gYml0cy5yZWFkQml0cyg4KTtcclxuICAgICAgICAgICAgcmV0dXJuICgoKGZpcnN0Qnl0ZSAmIDB4M0YpIDw8IDgpICYgMHhGRkZGRkZGRikgfCBzZWNvbmRCeXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKGZpcnN0Qnl0ZSAmIDB4RTApID09PSAweEMwKSB7XHJcbiAgICAgICAgICAgIC8vIHRocmVlIGJ5dGVzXHJcbiAgICAgICAgICAgIHZhciBzZWNvbmRUaGlyZEJ5dGVzID0gYml0cy5yZWFkQml0cygxNik7XHJcbiAgICAgICAgICAgIHJldHVybiAoKChmaXJzdEJ5dGUgJiAweDFGKSA8PCAxNikgJiAweEZGRkZGRkZGKSB8IHNlY29uZFRoaXJkQnl0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYsIDYuNC40IFRhYmxlIDVcclxuICAgICAqL1xyXG4gICAgRGVjb2RlZEJpdFN0cmVhbVBhcnNlci5BTFBIQU5VTUVSSUNfQ0hBUlMgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaICQlKistLi86JztcclxuICAgIERlY29kZWRCaXRTdHJlYW1QYXJzZXIuR0IyMzEyX1NVQlNFVCA9IDE7XHJcbiAgICByZXR1cm4gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGVjb2RlZEJpdFN0cmVhbVBhcnNlcjtcclxuZnVuY3Rpb24gVWludDhBcnJheVRvU3RyaW5nKGEpIHtcclxuICAgIHZhciBDSFVOS19TWiA9IDB4ODAwMDtcclxuICAgIHZhciBjID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzEgPSBhLmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpICs9IENIVU5LX1NaKSB7XHJcbiAgICAgICAgYy5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhLnN1YmFycmF5KGksIGkgKyBDSFVOS19TWikpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjLnRvU3RyaW5nKCk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVjb2RlZEJpdFN0cmVhbVBhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBCaXRNYXRyaXhfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vQml0TWF0cml4XCIpO1xyXG52YXIgR2VuZXJpY0dGXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL3JlZWRzb2xvbW9uL0dlbmVyaWNHRlwiKTtcclxudmFyIFJlZWRTb2xvbW9uRGVjb2Rlcl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9yZWVkc29sb21vbi9SZWVkU29sb21vbkRlY29kZXJcIik7XHJcbnZhciBCaXRNYXRyaXhQYXJzZXJfMSA9IHJlcXVpcmUoXCIuL0JpdE1hdHJpeFBhcnNlclwiKTtcclxudmFyIFFSQ29kZURlY29kZXJNZXRhRGF0YV8xID0gcmVxdWlyZShcIi4vUVJDb2RlRGVjb2Rlck1ldGFEYXRhXCIpO1xyXG52YXIgRGF0YUJsb2NrXzEgPSByZXF1aXJlKFwiLi9EYXRhQmxvY2tcIik7XHJcbnZhciBEZWNvZGVkQml0U3RyZWFtUGFyc2VyXzEgPSByZXF1aXJlKFwiLi9EZWNvZGVkQml0U3RyZWFtUGFyc2VyXCIpO1xyXG52YXIgQ2hlY2tzdW1FeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9DaGVja3N1bUV4Y2VwdGlvblwiKTtcclxuLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xyXG4vKipcclxuICogPHA+VGhlIG1haW4gY2xhc3Mgd2hpY2ggaW1wbGVtZW50cyBRUiBDb2RlIGRlY29kaW5nIC0tIGFzIG9wcG9zZWQgdG8gbG9jYXRpbmcgYW5kIGV4dHJhY3RpbmdcclxuICogdGhlIFFSIENvZGUgZnJvbSBhbiBpbWFnZS48L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqL1xyXG52YXIgRGVjb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERlY29kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5yc0RlY29kZXIgPSBuZXcgUmVlZFNvbG9tb25EZWNvZGVyXzEuZGVmYXVsdChHZW5lcmljR0ZfMS5kZWZhdWx0LlFSX0NPREVfRklFTERfMjU2KTtcclxuICAgIH1cclxuICAgIC8vIHB1YmxpYyBkZWNvZGUoaW1hZ2U6IGJvb2xlYW5bXVtdKTogRGVjb2RlclJlc3VsdCAvKnRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uKi8ge1xyXG4gICAgLy8gICByZXR1cm4gZGVjb2RlKGltYWdlLCBudWxsKVxyXG4gICAgLy8gfVxyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5Db252ZW5pZW5jZSBtZXRob2QgdGhhdCBjYW4gZGVjb2RlIGEgUVIgQ29kZSByZXByZXNlbnRlZCBhcyBhIDJEIGFycmF5IG9mIGJvb2xlYW5zLlxyXG4gICAgICogXCJ0cnVlXCIgaXMgdGFrZW4gdG8gbWVhbiBhIGJsYWNrIG1vZHVsZS48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGltYWdlIGJvb2xlYW5zIHJlcHJlc2VudGluZyB3aGl0ZS9ibGFjayBRUiBDb2RlIG1vZHVsZXNcclxuICAgICAqIEBwYXJhbSBoaW50cyBkZWNvZGluZyBoaW50cyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGluZmx1ZW5jZSBkZWNvZGluZ1xyXG4gICAgICogQHJldHVybiB0ZXh0IGFuZCBieXRlcyBlbmNvZGVkIHdpdGhpbiB0aGUgUVIgQ29kZVxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgdGhlIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWRcclxuICAgICAqIEB0aHJvd3MgQ2hlY2tzdW1FeGNlcHRpb24gaWYgZXJyb3IgY29ycmVjdGlvbiBmYWlsc1xyXG4gICAgICovXHJcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVCb29sZWFuQXJyYXkgPSBmdW5jdGlvbiAoaW1hZ2UsIGhpbnRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVjb2RlQml0TWF0cml4KEJpdE1hdHJpeF8xLmRlZmF1bHQucGFyc2VGcm9tQm9vbGVhbkFycmF5KGltYWdlKSwgaGludHMpO1xyXG4gICAgfTtcclxuICAgIC8vIHB1YmxpYyBkZWNvZGVCaXRNYXRyaXgoYml0czogQml0TWF0cml4KTogRGVjb2RlclJlc3VsdCAvKnRocm93cyBDaGVja3N1bUV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uKi8ge1xyXG4gICAgLy8gICByZXR1cm4gZGVjb2RlKGJpdHMsIG51bGwpXHJcbiAgICAvLyB9XHJcbiAgICAvKipcclxuICAgICAqIDxwPkRlY29kZXMgYSBRUiBDb2RlIHJlcHJlc2VudGVkIGFzIGEge0BsaW5rIEJpdE1hdHJpeH0uIEEgMSBvciBcInRydWVcIiBpcyB0YWtlbiB0byBtZWFuIGEgYmxhY2sgbW9kdWxlLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYml0cyBib29sZWFucyByZXByZXNlbnRpbmcgd2hpdGUvYmxhY2sgUVIgQ29kZSBtb2R1bGVzXHJcbiAgICAgKiBAcGFyYW0gaGludHMgZGVjb2RpbmcgaGludHMgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBpbmZsdWVuY2UgZGVjb2RpbmdcclxuICAgICAqIEByZXR1cm4gdGV4dCBhbmQgYnl0ZXMgZW5jb2RlZCB3aXRoaW4gdGhlIFFSIENvZGVcclxuICAgICAqIEB0aHJvd3MgRm9ybWF0RXhjZXB0aW9uIGlmIHRoZSBRUiBDb2RlIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcclxuICAgICAqL1xyXG4gICAgRGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlQml0TWF0cml4ID0gZnVuY3Rpb24gKGJpdHMsIGhpbnRzKSB7XHJcbiAgICAgICAgLy8gQ29uc3RydWN0IGEgcGFyc2VyIGFuZCByZWFkIHZlcnNpb24sIGVycm9yLWNvcnJlY3Rpb24gbGV2ZWxcclxuICAgICAgICB2YXIgcGFyc2VyID0gbmV3IEJpdE1hdHJpeFBhcnNlcl8xLmRlZmF1bHQoYml0cyk7XHJcbiAgICAgICAgdmFyIGV4ID0gbnVsbDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVCaXRNYXRyaXhQYXJzZXIocGFyc2VyLCBoaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlIC8qOiBGb3JtYXRFeGNlcHRpb24sIENoZWNrc3VtRXhjZXB0aW9uKi8pIHtcclxuICAgICAgICAgICAgZXggPSBlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBSZXZlcnQgdGhlIGJpdCBtYXRyaXhcclxuICAgICAgICAgICAgcGFyc2VyLnJlbWFzaygpO1xyXG4gICAgICAgICAgICAvLyBXaWxsIGJlIGF0dGVtcHRpbmcgYSBtaXJyb3JlZCByZWFkaW5nIG9mIHRoZSB2ZXJzaW9uIGFuZCBmb3JtYXQgaW5mby5cclxuICAgICAgICAgICAgcGFyc2VyLnNldE1pcnJvcih0cnVlKTtcclxuICAgICAgICAgICAgLy8gUHJlZW1wdGl2ZWx5IHJlYWQgdGhlIHZlcnNpb24uXHJcbiAgICAgICAgICAgIHBhcnNlci5yZWFkVmVyc2lvbigpO1xyXG4gICAgICAgICAgICAvLyBQcmVlbXB0aXZlbHkgcmVhZCB0aGUgZm9ybWF0IGluZm9ybWF0aW9uLlxyXG4gICAgICAgICAgICBwYXJzZXIucmVhZEZvcm1hdEluZm9ybWF0aW9uKCk7XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFNpbmNlIHdlJ3JlIGhlcmUsIHRoaXMgbWVhbnMgd2UgaGF2ZSBzdWNjZXNzZnVsbHkgZGV0ZWN0ZWQgc29tZSBraW5kXHJcbiAgICAgICAgICAgICAqIG9mIHZlcnNpb24gYW5kIGZvcm1hdCBpbmZvcm1hdGlvbiB3aGVuIG1pcnJvcmVkLiBUaGlzIGlzIGEgZ29vZCBzaWduLFxyXG4gICAgICAgICAgICAgKiB0aGF0IHRoZSBRUiBjb2RlIG1heSBiZSBtaXJyb3JlZCwgYW5kIHdlIHNob3VsZCB0cnkgb25jZSBtb3JlIHdpdGggYVxyXG4gICAgICAgICAgICAgKiBtaXJyb3JlZCBjb250ZW50LlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgLy8gUHJlcGFyZSBmb3IgYSBtaXJyb3JlZCByZWFkaW5nLlxyXG4gICAgICAgICAgICBwYXJzZXIubWlycm9yKCk7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmRlY29kZUJpdE1hdHJpeFBhcnNlcihwYXJzZXIsIGhpbnRzKTtcclxuICAgICAgICAgICAgLy8gU3VjY2VzcyEgTm90aWZ5IHRoZSBjYWxsZXIgdGhhdCB0aGUgY29kZSB3YXMgbWlycm9yZWQuXHJcbiAgICAgICAgICAgIHJlc3VsdC5zZXRPdGhlcihuZXcgUVJDb2RlRGVjb2Rlck1ldGFEYXRhXzEuZGVmYXVsdCh0cnVlKSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlIC8qRm9ybWF0RXhjZXB0aW9uIHwgQ2hlY2tzdW1FeGNlcHRpb24qLykge1xyXG4gICAgICAgICAgICAvLyBUaHJvdyB0aGUgZXhjZXB0aW9uIGZyb20gdGhlIG9yaWdpbmFsIHJlYWRpbmdcclxuICAgICAgICAgICAgaWYgKGV4ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aHJvdyBlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZWNvZGVyLnByb3RvdHlwZS5kZWNvZGVCaXRNYXRyaXhQYXJzZXIgPSBmdW5jdGlvbiAocGFyc2VyLCBoaW50cykge1xyXG4gICAgICAgIHZhciBlXzEsIF9hLCBlXzIsIF9iO1xyXG4gICAgICAgIHZhciB2ZXJzaW9uID0gcGFyc2VyLnJlYWRWZXJzaW9uKCk7XHJcbiAgICAgICAgdmFyIGVjTGV2ZWwgPSBwYXJzZXIucmVhZEZvcm1hdEluZm9ybWF0aW9uKCkuZ2V0RXJyb3JDb3JyZWN0aW9uTGV2ZWwoKTtcclxuICAgICAgICAvLyBSZWFkIGNvZGV3b3Jkc1xyXG4gICAgICAgIHZhciBjb2Rld29yZHMgPSBwYXJzZXIucmVhZENvZGV3b3JkcygpO1xyXG4gICAgICAgIC8vIFNlcGFyYXRlIGludG8gZGF0YSBibG9ja3NcclxuICAgICAgICB2YXIgZGF0YUJsb2NrcyA9IERhdGFCbG9ja18xLmRlZmF1bHQuZ2V0RGF0YUJsb2Nrcyhjb2Rld29yZHMsIHZlcnNpb24sIGVjTGV2ZWwpO1xyXG4gICAgICAgIC8vIENvdW50IHRvdGFsIG51bWJlciBvZiBkYXRhIGJ5dGVzXHJcbiAgICAgICAgdmFyIHRvdGFsQnl0ZXMgPSAwO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGRhdGFCbG9ja3NfMSA9IF9fdmFsdWVzKGRhdGFCbG9ja3MpLCBkYXRhQmxvY2tzXzFfMSA9IGRhdGFCbG9ja3NfMS5uZXh0KCk7ICFkYXRhQmxvY2tzXzFfMS5kb25lOyBkYXRhQmxvY2tzXzFfMSA9IGRhdGFCbG9ja3NfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhQmxvY2sgPSBkYXRhQmxvY2tzXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRvdGFsQnl0ZXMgKz0gZGF0YUJsb2NrLmdldE51bURhdGFDb2Rld29yZHMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGFCbG9ja3NfMV8xICYmICFkYXRhQmxvY2tzXzFfMS5kb25lICYmIChfYSA9IGRhdGFCbG9ja3NfMS5yZXR1cm4pKSBfYS5jYWxsKGRhdGFCbG9ja3NfMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0Qnl0ZXMgPSBuZXcgVWludDhBcnJheSh0b3RhbEJ5dGVzKTtcclxuICAgICAgICB2YXIgcmVzdWx0T2Zmc2V0ID0gMDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBFcnJvci1jb3JyZWN0IGFuZCBjb3B5IGRhdGEgYmxvY2tzIHRvZ2V0aGVyIGludG8gYSBzdHJlYW0gb2YgYnl0ZXNcclxuICAgICAgICAgICAgZm9yICh2YXIgZGF0YUJsb2Nrc18yID0gX192YWx1ZXMoZGF0YUJsb2NrcyksIGRhdGFCbG9ja3NfMl8xID0gZGF0YUJsb2Nrc18yLm5leHQoKTsgIWRhdGFCbG9ja3NfMl8xLmRvbmU7IGRhdGFCbG9ja3NfMl8xID0gZGF0YUJsb2Nrc18yLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFCbG9jayA9IGRhdGFCbG9ja3NfMl8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvZGV3b3JkQnl0ZXMgPSBkYXRhQmxvY2suZ2V0Q29kZXdvcmRzKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnVtRGF0YUNvZGV3b3JkcyA9IGRhdGFCbG9jay5nZXROdW1EYXRhQ29kZXdvcmRzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvcnJlY3RFcnJvcnMoY29kZXdvcmRCeXRlcywgbnVtRGF0YUNvZGV3b3Jkcyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bURhdGFDb2Rld29yZHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdEJ5dGVzW3Jlc3VsdE9mZnNldCsrXSA9IGNvZGV3b3JkQnl0ZXNbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhQmxvY2tzXzJfMSAmJiAhZGF0YUJsb2Nrc18yXzEuZG9uZSAmJiAoX2IgPSBkYXRhQmxvY2tzXzIucmV0dXJuKSkgX2IuY2FsbChkYXRhQmxvY2tzXzIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGVjb2RlIHRoZSBjb250ZW50cyBvZiB0aGF0IHN0cmVhbSBvZiBieXRlc1xyXG4gICAgICAgIHJldHVybiBEZWNvZGVkQml0U3RyZWFtUGFyc2VyXzEuZGVmYXVsdC5kZWNvZGUocmVzdWx0Qnl0ZXMsIHZlcnNpb24sIGVjTGV2ZWwsIGhpbnRzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPkdpdmVuIGRhdGEgYW5kIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzIHJlY2VpdmVkLCBwb3NzaWJseSBjb3JydXB0ZWQgYnkgZXJyb3JzLCBhdHRlbXB0cyB0b1xyXG4gICAgICogY29ycmVjdCB0aGUgZXJyb3JzIGluLXBsYWNlIHVzaW5nIFJlZWQtU29sb21vbiBlcnJvciBjb3JyZWN0aW9uLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29kZXdvcmRCeXRlcyBkYXRhIGFuZCBlcnJvciBjb3JyZWN0aW9uIGNvZGV3b3Jkc1xyXG4gICAgICogQHBhcmFtIG51bURhdGFDb2Rld29yZHMgbnVtYmVyIG9mIGNvZGV3b3JkcyB0aGF0IGFyZSBkYXRhIGJ5dGVzXHJcbiAgICAgKiBAdGhyb3dzIENoZWNrc3VtRXhjZXB0aW9uIGlmIGVycm9yIGNvcnJlY3Rpb24gZmFpbHNcclxuICAgICAqL1xyXG4gICAgRGVjb2Rlci5wcm90b3R5cGUuY29ycmVjdEVycm9ycyA9IGZ1bmN0aW9uIChjb2Rld29yZEJ5dGVzLCBudW1EYXRhQ29kZXdvcmRzIC8qaW50Ki8pIHtcclxuICAgICAgICB2YXIgbnVtQ29kZXdvcmRzID0gY29kZXdvcmRCeXRlcy5sZW5ndGg7XHJcbiAgICAgICAgLy8gRmlyc3QgcmVhZCBpbnRvIGFuIGFycmF5IG9mIGludHNcclxuICAgICAgICB2YXIgY29kZXdvcmRzSW50cyA9IG5ldyBJbnQzMkFycmF5KGNvZGV3b3JkQnl0ZXMpO1xyXG4gICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBub3QgcmVhbHkgbmVjZXNzYXJ5IHRvIHRyYW5zZm9ybSB0byBpbnRzPyBjb3VsZCByZWRlc2lnbiBldmVyeXRoaW5nIHRvIHdvcmsgd2l0aCB1bnNpZ25lZCBieXRlcz9cclxuICAgICAgICAvLyBjb25zdCBjb2Rld29yZHNJbnRzID0gbmV3IEludDMyQXJyYXkobnVtQ29kZXdvcmRzKVxyXG4gICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29kZXdvcmRzOyBpKyspIHtcclxuICAgICAgICAvLyAgIGNvZGV3b3Jkc0ludHNbaV0gPSBjb2Rld29yZEJ5dGVzW2ldICYgMHhGRlxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB0aGlzLnJzRGVjb2Rlci5kZWNvZGUoY29kZXdvcmRzSW50cywgY29kZXdvcmRCeXRlcy5sZW5ndGggLSBudW1EYXRhQ29kZXdvcmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGlnbm9yZWQgLyo6IFJlZWRTb2xvbW9uRXhjZXB0aW9uKi8pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IENoZWNrc3VtRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb3B5IGJhY2sgaW50byBhcnJheSBvZiBieXRlcyAtLSBvbmx5IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhlIGJ5dGVzIHRoYXQgd2VyZSBkYXRhXHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCBlcnJvcnMgaW4gdGhlIGVycm9yLWNvcnJlY3Rpb24gY29kZXdvcmRzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXRhQ29kZXdvcmRzOyBpKyspIHtcclxuICAgICAgICAgICAgY29kZXdvcmRCeXRlc1tpXSA9IC8qKGJ5dGUpICovIGNvZGV3b3Jkc0ludHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEZWNvZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEZWNvZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWNvZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiA8cD5FbmNhcHN1bGF0ZXMgdGhlIHBhcmFtZXRlcnMgZm9yIG9uZSBlcnJvci1jb3JyZWN0aW9uIGJsb2NrIGluIG9uZSBzeW1ib2wgdmVyc2lvbi5cclxuICogVGhpcyBpbmNsdWRlcyB0aGUgbnVtYmVyIG9mIGRhdGEgY29kZXdvcmRzLCBhbmQgdGhlIG51bWJlciBvZiB0aW1lcyBhIGJsb2NrIHdpdGggdGhlc2VcclxuICogcGFyYW1ldGVycyBpcyB1c2VkIGNvbnNlY3V0aXZlbHkgaW4gdGhlIFFSIGNvZGUgdmVyc2lvbidzIGZvcm1hdC48L3A+XHJcbiAqL1xyXG52YXIgRUNCID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRUNCKGNvdW50IC8qaW50Ki8sIGRhdGFDb2Rld29yZHMgLyppbnQqLykge1xyXG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcclxuICAgICAgICB0aGlzLmRhdGFDb2Rld29yZHMgPSBkYXRhQ29kZXdvcmRzO1xyXG4gICAgfVxyXG4gICAgRUNCLnByb3RvdHlwZS5nZXRDb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3VudDtcclxuICAgIH07XHJcbiAgICBFQ0IucHJvdG90eXBlLmdldERhdGFDb2Rld29yZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUNvZGV3b3JkcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRUNCO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFQ0I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVDQi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogPHA+RW5jYXBzdWxhdGVzIGEgc2V0IG9mIGVycm9yLWNvcnJlY3Rpb24gYmxvY2tzIGluIG9uZSBzeW1ib2wgdmVyc2lvbi4gTW9zdCB2ZXJzaW9ucyB3aWxsXHJcbiAqIHVzZSBibG9ja3Mgb2YgZGlmZmVyaW5nIHNpemVzIHdpdGhpbiBvbmUgdmVyc2lvbiwgc28sIHRoaXMgZW5jYXBzdWxhdGVzIHRoZSBwYXJhbWV0ZXJzIGZvclxyXG4gKiBlYWNoIHNldCBvZiBibG9ja3MuIEl0IGFsc28gaG9sZHMgdGhlIG51bWJlciBvZiBlcnJvci1jb3JyZWN0aW9uIGNvZGV3b3JkcyBwZXIgYmxvY2sgc2luY2UgaXRcclxuICogd2lsbCBiZSB0aGUgc2FtZSBhY3Jvc3MgYWxsIGJsb2NrcyB3aXRoaW4gb25lIHZlcnNpb24uPC9wPlxyXG4gKi9cclxudmFyIEVDQmxvY2tzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRUNCbG9ja3MoZWNDb2Rld29yZHNQZXJCbG9jayAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIGVjQmxvY2tzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgZWNCbG9ja3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWNDb2Rld29yZHNQZXJCbG9jayA9IGVjQ29kZXdvcmRzUGVyQmxvY2s7XHJcbiAgICAgICAgdGhpcy5lY0Jsb2NrcyA9IGVjQmxvY2tzO1xyXG4gICAgfVxyXG4gICAgRUNCbG9ja3MucHJvdG90eXBlLmdldEVDQ29kZXdvcmRzUGVyQmxvY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWNDb2Rld29yZHNQZXJCbG9jaztcclxuICAgIH07XHJcbiAgICBFQ0Jsb2Nrcy5wcm90b3R5cGUuZ2V0TnVtQmxvY2tzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIHZhciB0b3RhbCA9IDA7XHJcbiAgICAgICAgdmFyIGVjQmxvY2tzID0gdGhpcy5lY0Jsb2NrcztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBlY0Jsb2Nrc18xID0gX192YWx1ZXMoZWNCbG9ja3MpLCBlY0Jsb2Nrc18xXzEgPSBlY0Jsb2Nrc18xLm5leHQoKTsgIWVjQmxvY2tzXzFfMS5kb25lOyBlY0Jsb2Nrc18xXzEgPSBlY0Jsb2Nrc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVjQmxvY2sgPSBlY0Jsb2Nrc18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0b3RhbCArPSBlY0Jsb2NrLmdldENvdW50KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChlY0Jsb2Nrc18xXzEgJiYgIWVjQmxvY2tzXzFfMS5kb25lICYmIChfYSA9IGVjQmxvY2tzXzEucmV0dXJuKSkgX2EuY2FsbChlY0Jsb2Nrc18xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b3RhbDtcclxuICAgIH07XHJcbiAgICBFQ0Jsb2Nrcy5wcm90b3R5cGUuZ2V0VG90YWxFQ0NvZGV3b3JkcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lY0NvZGV3b3Jkc1BlckJsb2NrICogdGhpcy5nZXROdW1CbG9ja3MoKTtcclxuICAgIH07XHJcbiAgICBFQ0Jsb2Nrcy5wcm90b3R5cGUuZ2V0RUNCbG9ja3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWNCbG9ja3M7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEVDQmxvY2tzO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFQ0Jsb2NrcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RUNCbG9ja3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZWNvZGVyIHsqL1xyXG52YXIgQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Bcmd1bWVudEV4Y2VwdGlvblwiKTtcclxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxudmFyIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzO1xyXG4oZnVuY3Rpb24gKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzKSB7XHJcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tcIkxcIl0gPSAwXSA9IFwiTFwiO1xyXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXNbXCJNXCJdID0gMV0gPSBcIk1cIjtcclxuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW0Vycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzW1wiUVwiXSA9IDJdID0gXCJRXCI7XHJcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlc1tcIkhcIl0gPSAzXSA9IFwiSFwiO1xyXG59KShFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcyA9IGV4cG9ydHMuRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMgfHwgKGV4cG9ydHMuRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMgPSB7fSkpO1xyXG4vKipcclxuICogPHA+U2VlIElTTyAxODAwNDoyMDA2LCA2LjUuMS4gVGhpcyBlbnVtIGVuY2Fwc3VsYXRlcyB0aGUgZm91ciBlcnJvciBjb3JyZWN0aW9uIGxldmVsc1xyXG4gKiBkZWZpbmVkIGJ5IHRoZSBRUiBjb2RlIHN0YW5kYXJkLjwvcD5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICovXHJcbnZhciBFcnJvckNvcnJlY3Rpb25MZXZlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEVycm9yQ29ycmVjdGlvbkxldmVsKHZhbHVlLCBzdHJpbmdWYWx1ZSwgYml0cyAvKmludCovKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZTtcclxuICAgICAgICB0aGlzLmJpdHMgPSBiaXRzO1xyXG4gICAgICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9CSVRTLnNldChiaXRzLCB0aGlzKTtcclxuICAgICAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfVkFMVUUuc2V0KHZhbHVlLCB0aGlzKTtcclxuICAgIH1cclxuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5wcm90b3R5cGUuZ2V0Qml0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iaXRzO1xyXG4gICAgfTtcclxuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgIHN3aXRjaCAocykge1xyXG4gICAgICAgICAgICBjYXNlICdMJzogcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLkw7XHJcbiAgICAgICAgICAgIGNhc2UgJ00nOiByZXR1cm4gRXJyb3JDb3JyZWN0aW9uTGV2ZWwuTTtcclxuICAgICAgICAgICAgY2FzZSAnUSc6IHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbC5RO1xyXG4gICAgICAgICAgICBjYXNlICdIJzogcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLkg7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQocyArICdub3QgYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdWYWx1ZTtcclxuICAgIH07XHJcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgRXJyb3JDb3JyZWN0aW9uTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG90aGVyID0gbztcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gb3RoZXIudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYml0cyBpbnQgY29udGFpbmluZyB0aGUgdHdvIGJpdHMgZW5jb2RpbmcgYSBRUiBDb2RlJ3MgZXJyb3IgY29ycmVjdGlvbiBsZXZlbFxyXG4gICAgICogQHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbCByZXByZXNlbnRpbmcgdGhlIGVuY29kZWQgZXJyb3IgY29ycmVjdGlvbiBsZXZlbFxyXG4gICAgICovXHJcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5mb3JCaXRzID0gZnVuY3Rpb24gKGJpdHMgLyppbnQqLykge1xyXG4gICAgICAgIGlmIChiaXRzIDwgMCB8fCBiaXRzID49IEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9CSVRTLnNpemUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9CSVRTLmdldChiaXRzKTtcclxuICAgIH07XHJcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5GT1JfQklUUyA9IG5ldyBNYXAoKTtcclxuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkZPUl9WQUxVRSA9IG5ldyBNYXAoKTtcclxuICAgIC8qKiBMID0gfjclIGNvcnJlY3Rpb24gKi9cclxuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkwgPSBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMuTCwgJ0wnLCAweDAxKTtcclxuICAgIC8qKiBNID0gfjE1JSBjb3JyZWN0aW9uICovXHJcbiAgICBFcnJvckNvcnJlY3Rpb25MZXZlbC5NID0gbmV3IEVycm9yQ29ycmVjdGlvbkxldmVsKEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzLk0sICdNJywgMHgwMCk7XHJcbiAgICAvKiogUSA9IH4yNSUgY29ycmVjdGlvbiAqL1xyXG4gICAgRXJyb3JDb3JyZWN0aW9uTGV2ZWwuUSA9IG5ldyBFcnJvckNvcnJlY3Rpb25MZXZlbChFcnJvckNvcnJlY3Rpb25MZXZlbFZhbHVlcy5RLCAnUScsIDB4MDMpO1xyXG4gICAgLyoqIEggPSB+MzAlIGNvcnJlY3Rpb24gKi9cclxuICAgIEVycm9yQ29ycmVjdGlvbkxldmVsLkggPSBuZXcgRXJyb3JDb3JyZWN0aW9uTGV2ZWwoRXJyb3JDb3JyZWN0aW9uTGV2ZWxWYWx1ZXMuSCwgJ0gnLCAweDAyKTtcclxuICAgIHJldHVybiBFcnJvckNvcnJlY3Rpb25MZXZlbDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXJyb3JDb3JyZWN0aW9uTGV2ZWw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVycm9yQ29ycmVjdGlvbkxldmVsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLypuYW1lc3BhY2UgY29tLmdvb2dsZS56eGluZy5xcmNvZGUuZGVjb2RlciB7Ki9cclxudmFyIEVycm9yQ29ycmVjdGlvbkxldmVsXzEgPSByZXF1aXJlKFwiLi9FcnJvckNvcnJlY3Rpb25MZXZlbFwiKTtcclxudmFyIEludGVnZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0ludGVnZXJcIik7XHJcbi8qKlxyXG4gKiA8cD5FbmNhcHN1bGF0ZXMgYSBRUiBDb2RlJ3MgZm9ybWF0IGluZm9ybWF0aW9uLCBpbmNsdWRpbmcgdGhlIGRhdGEgbWFzayB1c2VkIGFuZFxyXG4gKiBlcnJvciBjb3JyZWN0aW9uIGxldmVsLjwvcD5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICogQHNlZSBEYXRhTWFza1xyXG4gKiBAc2VlIEVycm9yQ29ycmVjdGlvbkxldmVsXHJcbiAqL1xyXG52YXIgRm9ybWF0SW5mb3JtYXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGb3JtYXRJbmZvcm1hdGlvbihmb3JtYXRJbmZvIC8qaW50Ki8pIHtcclxuICAgICAgICAvLyBCaXRzIDMsNFxyXG4gICAgICAgIHRoaXMuZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBFcnJvckNvcnJlY3Rpb25MZXZlbF8xLmRlZmF1bHQuZm9yQml0cygoZm9ybWF0SW5mbyA+PiAzKSAmIDB4MDMpO1xyXG4gICAgICAgIC8vIEJvdHRvbSAzIGJpdHNcclxuICAgICAgICB0aGlzLmRhdGFNYXNrID0gLyooYnl0ZSkgKi8gKGZvcm1hdEluZm8gJiAweDA3KTtcclxuICAgIH1cclxuICAgIEZvcm1hdEluZm9ybWF0aW9uLm51bUJpdHNEaWZmZXJpbmcgPSBmdW5jdGlvbiAoYSAvKmludCovLCBiIC8qaW50Ki8pIHtcclxuICAgICAgICByZXR1cm4gSW50ZWdlcl8xLmRlZmF1bHQuYml0Q291bnQoYSBeIGIpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG1hc2tlZEZvcm1hdEluZm8xIGZvcm1hdCBpbmZvIGluZGljYXRvciwgd2l0aCBtYXNrIHN0aWxsIGFwcGxpZWRcclxuICAgICAqIEBwYXJhbSBtYXNrZWRGb3JtYXRJbmZvMiBzZWNvbmQgY29weSBvZiBzYW1lIGluZm87IGJvdGggYXJlIGNoZWNrZWQgYXQgdGhlIHNhbWUgdGltZVxyXG4gICAgICogIHRvIGVzdGFibGlzaCBiZXN0IG1hdGNoXHJcbiAgICAgKiBAcmV0dXJuIGluZm9ybWF0aW9uIGFib3V0IHRoZSBmb3JtYXQgaXQgc3BlY2lmaWVzLCBvciB7QGNvZGUgbnVsbH1cclxuICAgICAqICBpZiBkb2Vzbid0IHNlZW0gdG8gbWF0Y2ggYW55IGtub3duIHBhdHRlcm5cclxuICAgICAqL1xyXG4gICAgRm9ybWF0SW5mb3JtYXRpb24uZGVjb2RlRm9ybWF0SW5mb3JtYXRpb24gPSBmdW5jdGlvbiAobWFza2VkRm9ybWF0SW5mbzEgLyppbnQqLywgbWFza2VkRm9ybWF0SW5mbzIgLyppbnQqLykge1xyXG4gICAgICAgIHZhciBmb3JtYXRJbmZvID0gRm9ybWF0SW5mb3JtYXRpb24uZG9EZWNvZGVGb3JtYXRJbmZvcm1hdGlvbihtYXNrZWRGb3JtYXRJbmZvMSwgbWFza2VkRm9ybWF0SW5mbzIpO1xyXG4gICAgICAgIGlmIChmb3JtYXRJbmZvICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRJbmZvO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTaG91bGQgcmV0dXJuIG51bGwsIGJ1dCwgc29tZSBRUiBjb2RlcyBhcHBhcmVudGx5XHJcbiAgICAgICAgLy8gZG8gbm90IG1hc2sgdGhpcyBpbmZvLiBUcnkgYWdhaW4gYnkgYWN0dWFsbHkgbWFza2luZyB0aGUgcGF0dGVyblxyXG4gICAgICAgIC8vIGZpcnN0XHJcbiAgICAgICAgcmV0dXJuIEZvcm1hdEluZm9ybWF0aW9uLmRvRGVjb2RlRm9ybWF0SW5mb3JtYXRpb24obWFza2VkRm9ybWF0SW5mbzEgXiBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19NQVNLX1FSLCBtYXNrZWRGb3JtYXRJbmZvMiBeIEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX01BU0tfUVIpO1xyXG4gICAgfTtcclxuICAgIEZvcm1hdEluZm9ybWF0aW9uLmRvRGVjb2RlRm9ybWF0SW5mb3JtYXRpb24gPSBmdW5jdGlvbiAobWFza2VkRm9ybWF0SW5mbzEgLyppbnQqLywgbWFza2VkRm9ybWF0SW5mbzIgLyppbnQqLykge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIC8vIEZpbmQgdGhlIGludCBpbiBGT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQIHdpdGggZmV3ZXN0IGJpdHMgZGlmZmVyaW5nXHJcbiAgICAgICAgdmFyIGJlc3REaWZmZXJlbmNlID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcbiAgICAgICAgdmFyIGJlc3RGb3JtYXRJbmZvID0gMDtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKEZvcm1hdEluZm9ybWF0aW9uLkZPUk1BVF9JTkZPX0RFQ09ERV9MT09LVVApLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVjb2RlSW5mbyA9IF9jLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEluZm8gPSBkZWNvZGVJbmZvWzBdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldEluZm8gPT09IG1hc2tlZEZvcm1hdEluZm8xIHx8IHRhcmdldEluZm8gPT09IG1hc2tlZEZvcm1hdEluZm8yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gZXhhY3QgbWF0Y2hcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1hdEluZm9ybWF0aW9uKGRlY29kZUluZm9bMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGJpdHNEaWZmZXJlbmNlID0gRm9ybWF0SW5mb3JtYXRpb24ubnVtQml0c0RpZmZlcmluZyhtYXNrZWRGb3JtYXRJbmZvMSwgdGFyZ2V0SW5mbyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYml0c0RpZmZlcmVuY2UgPCBiZXN0RGlmZmVyZW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJlc3RGb3JtYXRJbmZvID0gZGVjb2RlSW5mb1sxXTtcclxuICAgICAgICAgICAgICAgICAgICBiZXN0RGlmZmVyZW5jZSA9IGJpdHNEaWZmZXJlbmNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hc2tlZEZvcm1hdEluZm8xICE9PSBtYXNrZWRGb3JtYXRJbmZvMikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gdHJ5IHRoZSBvdGhlciBvcHRpb25cclxuICAgICAgICAgICAgICAgICAgICBiaXRzRGlmZmVyZW5jZSA9IEZvcm1hdEluZm9ybWF0aW9uLm51bUJpdHNEaWZmZXJpbmcobWFza2VkRm9ybWF0SW5mbzIsIHRhcmdldEluZm8pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiaXRzRGlmZmVyZW5jZSA8IGJlc3REaWZmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RGb3JtYXRJbmZvID0gZGVjb2RlSW5mb1sxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdERpZmZlcmVuY2UgPSBiaXRzRGlmZmVyZW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEhhbW1pbmcgZGlzdGFuY2Ugb2YgdGhlIDMyIG1hc2tlZCBjb2RlcyBpcyA3LCBieSBjb25zdHJ1Y3Rpb24sIHNvIDw9IDMgYml0c1xyXG4gICAgICAgIC8vIGRpZmZlcmluZyBtZWFucyB3ZSBmb3VuZCBhIG1hdGNoXHJcbiAgICAgICAgaWYgKGJlc3REaWZmZXJlbmNlIDw9IDMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGb3JtYXRJbmZvcm1hdGlvbihiZXN0Rm9ybWF0SW5mbyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIEZvcm1hdEluZm9ybWF0aW9uLnByb3RvdHlwZS5nZXRFcnJvckNvcnJlY3Rpb25MZXZlbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbDtcclxuICAgIH07XHJcbiAgICBGb3JtYXRJbmZvcm1hdGlvbi5wcm90b3R5cGUuZ2V0RGF0YU1hc2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1hc2s7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgRm9ybWF0SW5mb3JtYXRpb24ucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5lcnJvckNvcnJlY3Rpb25MZXZlbC5nZXRCaXRzKCkgPDwgMykgfCB0aGlzLmRhdGFNYXNrO1xyXG4gICAgfTtcclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIEZvcm1hdEluZm9ybWF0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAobykge1xyXG4gICAgICAgIGlmICghKG8gaW5zdGFuY2VvZiBGb3JtYXRJbmZvcm1hdGlvbikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3RoZXIgPSBvO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsID09PSBvdGhlci5lcnJvckNvcnJlY3Rpb25MZXZlbCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFNYXNrID09PSBvdGhlci5kYXRhTWFzaztcclxuICAgIH07XHJcbiAgICBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19NQVNLX1FSID0gMHg1NDEyO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYsIEFubmV4IEMsIFRhYmxlIEMuMVxyXG4gICAgICovXHJcbiAgICBGb3JtYXRJbmZvcm1hdGlvbi5GT1JNQVRfSU5GT19ERUNPREVfTE9PS1VQID0gW1xyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg1NDEyLCAweDAwXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDUxMjUsIDB4MDFdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NUU3QywgMHgwMl0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg1QjRCLCAweDAzXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDQ1RjksIDB4MDRdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NDBDRSwgMHgwNV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg0Rjk3LCAweDA2XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDRBQTAsIDB4MDddKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NzdDNCwgMHgwOF0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg3MkYzLCAweDA5XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDdEQUEsIDB4MEFdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4Nzg5RCwgMHgwQl0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg2NjJGLCAweDBDXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDYzMTgsIDB4MERdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4NkM0MSwgMHgwRV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHg2OTc2LCAweDBGXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDE2ODksIDB4MTBdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MTNCRSwgMHgxMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgxQ0U3LCAweDEyXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDE5RDAsIDB4MTNdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MDc2MiwgMHgxNF0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgwMjU1LCAweDE1XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDBEMEMsIDB4MTZdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MDgzQiwgMHgxN10pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgzNTVGLCAweDE4XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDMwNjgsIDB4MTldKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4M0YzMSwgMHgxQV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgzQTA2LCAweDFCXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDI0QjQsIDB4MUNdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzB4MjE4MywgMHgxRF0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbMHgyRURBLCAweDFFXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsweDJCRUQsIDB4MUZdKSxcclxuICAgIF07XHJcbiAgICByZXR1cm4gRm9ybWF0SW5mb3JtYXRpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZvcm1hdEluZm9ybWF0aW9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gb3JtYXRJbmZvcm1hdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbnZhciBNb2RlVmFsdWVzO1xyXG4oZnVuY3Rpb24gKE1vZGVWYWx1ZXMpIHtcclxuICAgIE1vZGVWYWx1ZXNbTW9kZVZhbHVlc1tcIlRFUk1JTkFUT1JcIl0gPSAwXSA9IFwiVEVSTUlOQVRPUlwiO1xyXG4gICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiTlVNRVJJQ1wiXSA9IDFdID0gXCJOVU1FUklDXCI7XHJcbiAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJBTFBIQU5VTUVSSUNcIl0gPSAyXSA9IFwiQUxQSEFOVU1FUklDXCI7XHJcbiAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJTVFJVQ1RVUkVEX0FQUEVORFwiXSA9IDNdID0gXCJTVFJVQ1RVUkVEX0FQUEVORFwiO1xyXG4gICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiQllURVwiXSA9IDRdID0gXCJCWVRFXCI7XHJcbiAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJFQ0lcIl0gPSA1XSA9IFwiRUNJXCI7XHJcbiAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJLQU5KSVwiXSA9IDZdID0gXCJLQU5KSVwiO1xyXG4gICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiRk5DMV9GSVJTVF9QT1NJVElPTlwiXSA9IDddID0gXCJGTkMxX0ZJUlNUX1BPU0lUSU9OXCI7XHJcbiAgICBNb2RlVmFsdWVzW01vZGVWYWx1ZXNbXCJGTkMxX1NFQ09ORF9QT1NJVElPTlwiXSA9IDhdID0gXCJGTkMxX1NFQ09ORF9QT1NJVElPTlwiO1xyXG4gICAgLyoqIFNlZSBHQlQgMTgyODQtMjAwMDsgXCJIYW56aVwiIGlzIGEgdHJhbnNsaXRlcmF0aW9uIG9mIHRoaXMgbW9kZSBuYW1lLiAqL1xyXG4gICAgTW9kZVZhbHVlc1tNb2RlVmFsdWVzW1wiSEFOWklcIl0gPSA5XSA9IFwiSEFOWklcIjtcclxufSkoTW9kZVZhbHVlcyA9IGV4cG9ydHMuTW9kZVZhbHVlcyB8fCAoZXhwb3J0cy5Nb2RlVmFsdWVzID0ge30pKTtcclxuLyoqXHJcbiAqIDxwPlNlZSBJU08gMTgwMDQ6MjAwNiwgNi40LjEsIFRhYmxlcyAyIGFuZCAzLiBUaGlzIGVudW0gZW5jYXBzdWxhdGVzIHRoZSB2YXJpb3VzIG1vZGVzIGluIHdoaWNoXHJcbiAqIGRhdGEgY2FuIGJlIGVuY29kZWQgdG8gYml0cyBpbiB0aGUgUVIgY29kZSBzdGFuZGFyZC48L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqL1xyXG52YXIgTW9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1vZGUodmFsdWUsIHN0cmluZ1ZhbHVlLCBjaGFyYWN0ZXJDb3VudEJpdHNGb3JWZXJzaW9ucywgYml0cyAvKmludCovKSB7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuc3RyaW5nVmFsdWUgPSBzdHJpbmdWYWx1ZTtcclxuICAgICAgICB0aGlzLmNoYXJhY3RlckNvdW50Qml0c0ZvclZlcnNpb25zID0gY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnM7XHJcbiAgICAgICAgdGhpcy5iaXRzID0gYml0cztcclxuICAgICAgICBNb2RlLkZPUl9CSVRTLnNldChiaXRzLCB0aGlzKTtcclxuICAgICAgICBNb2RlLkZPUl9WQUxVRS5zZXQodmFsdWUsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYml0cyBmb3VyIGJpdHMgZW5jb2RpbmcgYSBRUiBDb2RlIGRhdGEgbW9kZVxyXG4gICAgICogQHJldHVybiBNb2RlIGVuY29kZWQgYnkgdGhlc2UgYml0c1xyXG4gICAgICogQHRocm93cyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgYml0cyBkbyBub3QgY29ycmVzcG9uZCB0byBhIGtub3duIG1vZGVcclxuICAgICAqL1xyXG4gICAgTW9kZS5mb3JCaXRzID0gZnVuY3Rpb24gKGJpdHMgLyppbnQqLykge1xyXG4gICAgICAgIHZhciBtb2RlID0gTW9kZS5GT1JfQklUUy5nZXQoYml0cyk7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gbW9kZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbW9kZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIHZlcnNpb24gaW4gcXVlc3Rpb25cclxuICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIGJpdHMgdXNlZCwgaW4gdGhpcyBRUiBDb2RlIHN5bWJvbCB7QGxpbmsgVmVyc2lvbn0sIHRvIGVuY29kZSB0aGVcclxuICAgICAqICAgICAgICAgY291bnQgb2YgY2hhcmFjdGVycyB0aGF0IHdpbGwgZm9sbG93IGVuY29kZWQgaW4gdGhpcyBNb2RlXHJcbiAgICAgKi9cclxuICAgIE1vZGUucHJvdG90eXBlLmdldENoYXJhY3RlckNvdW50Qml0cyA9IGZ1bmN0aW9uICh2ZXJzaW9uKSB7XHJcbiAgICAgICAgdmFyIHZlcnNpb25OdW1iZXIgPSB2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKTtcclxuICAgICAgICB2YXIgb2Zmc2V0O1xyXG4gICAgICAgIGlmICh2ZXJzaW9uTnVtYmVyIDw9IDkpIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmVyc2lvbk51bWJlciA8PSAyNikge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb2Zmc2V0ID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhcmFjdGVyQ291bnRCaXRzRm9yVmVyc2lvbnNbb2Zmc2V0XTtcclxuICAgIH07XHJcbiAgICBNb2RlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBNb2RlLnByb3RvdHlwZS5nZXRCaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJpdHM7XHJcbiAgICB9O1xyXG4gICAgTW9kZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgTW9kZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3RoZXIgPSBvO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSBvdGhlci52YWx1ZTtcclxuICAgIH07XHJcbiAgICBNb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdWYWx1ZTtcclxuICAgIH07XHJcbiAgICBNb2RlLkZPUl9CSVRTID0gbmV3IE1hcCgpO1xyXG4gICAgTW9kZS5GT1JfVkFMVUUgPSBuZXcgTWFwKCk7XHJcbiAgICBNb2RlLlRFUk1JTkFUT1IgPSBuZXcgTW9kZShNb2RlVmFsdWVzLlRFUk1JTkFUT1IsICdURVJNSU5BVE9SJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDApOyAvLyBOb3QgcmVhbGx5IGEgbW9kZS4uLlxyXG4gICAgTW9kZS5OVU1FUklDID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5OVU1FUklDLCAnTlVNRVJJQycsIEludDMyQXJyYXkuZnJvbShbMTAsIDEyLCAxNF0pLCAweDAxKTtcclxuICAgIE1vZGUuQUxQSEFOVU1FUklDID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5BTFBIQU5VTUVSSUMsICdBTFBIQU5VTUVSSUMnLCBJbnQzMkFycmF5LmZyb20oWzksIDExLCAxM10pLCAweDAyKTtcclxuICAgIE1vZGUuU1RSVUNUVVJFRF9BUFBFTkQgPSBuZXcgTW9kZShNb2RlVmFsdWVzLlNUUlVDVFVSRURfQVBQRU5ELCAnU1RSVUNUVVJFRF9BUFBFTkQnLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwMyk7IC8vIE5vdCBzdXBwb3J0ZWRcclxuICAgIE1vZGUuQllURSA9IG5ldyBNb2RlKE1vZGVWYWx1ZXMuQllURSwgJ0JZVEUnLCBJbnQzMkFycmF5LmZyb20oWzgsIDE2LCAxNl0pLCAweDA0KTtcclxuICAgIE1vZGUuRUNJID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5FQ0ksICdFQ0knLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwNyk7IC8vIGNoYXJhY3RlciBjb3VudHMgZG9uJ3QgYXBwbHlcclxuICAgIE1vZGUuS0FOSkkgPSBuZXcgTW9kZShNb2RlVmFsdWVzLktBTkpJLCAnS0FOSkknLCBJbnQzMkFycmF5LmZyb20oWzgsIDEwLCAxMl0pLCAweDA4KTtcclxuICAgIE1vZGUuRk5DMV9GSVJTVF9QT1NJVElPTiA9IG5ldyBNb2RlKE1vZGVWYWx1ZXMuRk5DMV9GSVJTVF9QT1NJVElPTiwgJ0ZOQzFfRklSU1RfUE9TSVRJT04nLCBJbnQzMkFycmF5LmZyb20oWzAsIDAsIDBdKSwgMHgwNSk7XHJcbiAgICBNb2RlLkZOQzFfU0VDT05EX1BPU0lUSU9OID0gbmV3IE1vZGUoTW9kZVZhbHVlcy5GTkMxX1NFQ09ORF9QT1NJVElPTiwgJ0ZOQzFfU0VDT05EX1BPU0lUSU9OJywgSW50MzJBcnJheS5mcm9tKFswLCAwLCAwXSksIDB4MDkpO1xyXG4gICAgLyoqIFNlZSBHQlQgMTgyODQtMjAwMDsgXCJIYW56aVwiIGlzIGEgdHJhbnNsaXRlcmF0aW9uIG9mIHRoaXMgbW9kZSBuYW1lLiAqL1xyXG4gICAgTW9kZS5IQU5aSSA9IG5ldyBNb2RlKE1vZGVWYWx1ZXMuSEFOWkksICdIQU5aSScsIEludDMyQXJyYXkuZnJvbShbOCwgMTAsIDEyXSksIDB4MEQpO1xyXG4gICAgcmV0dXJuIE1vZGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vZGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDEzIFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogTWV0YS1kYXRhIGNvbnRhaW5lciBmb3IgUVIgQ29kZSBkZWNvZGluZy4gSW5zdGFuY2VzIG9mIHRoaXMgY2xhc3MgbWF5IGJlIHVzZWQgdG8gY29udmV5IGluZm9ybWF0aW9uIGJhY2sgdG8gdGhlXHJcbiAqIGRlY29kaW5nIGNhbGxlci4gQ2FsbGVycyBhcmUgZXhwZWN0ZWQgdG8gcHJvY2VzcyB0aGlzLlxyXG4gKlxyXG4gKiBAc2VlIGNvbS5nb29nbGUuenhpbmcuY29tbW9uLkRlY29kZXJSZXN1bHQjZ2V0T3RoZXIoKVxyXG4gKi9cclxudmFyIFFSQ29kZURlY29kZXJNZXRhRGF0YSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFFSQ29kZURlY29kZXJNZXRhRGF0YShtaXJyb3JlZCkge1xyXG4gICAgICAgIHRoaXMubWlycm9yZWQgPSBtaXJyb3JlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBRUiBDb2RlIHdhcyBtaXJyb3JlZC5cclxuICAgICAqL1xyXG4gICAgUVJDb2RlRGVjb2Rlck1ldGFEYXRhLnByb3RvdHlwZS5pc01pcnJvcmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1pcnJvcmVkO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgdGhlIHJlc3VsdCBwb2ludHMnIG9yZGVyIGNvcnJlY3Rpb24gZHVlIHRvIG1pcnJvcmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRzIEFycmF5IG9mIHBvaW50cyB0byBhcHBseSBtaXJyb3IgY29ycmVjdGlvbiB0by5cclxuICAgICAqL1xyXG4gICAgUVJDb2RlRGVjb2Rlck1ldGFEYXRhLnByb3RvdHlwZS5hcHBseU1pcnJvcmVkQ29ycmVjdGlvbiA9IGZ1bmN0aW9uIChwb2ludHMpIHtcclxuICAgICAgICBpZiAoIXRoaXMubWlycm9yZWQgfHwgcG9pbnRzID09PSBudWxsIHx8IHBvaW50cy5sZW5ndGggPCAzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJvdHRvbUxlZnQgPSBwb2ludHNbMF07XHJcbiAgICAgICAgcG9pbnRzWzBdID0gcG9pbnRzWzJdO1xyXG4gICAgICAgIHBvaW50c1syXSA9IGJvdHRvbUxlZnQ7XHJcbiAgICAgICAgLy8gTm8gbmVlZCB0byAnZml4JyB0b3AtbGVmdCBhbmQgYWxpZ25tZW50IHBhdHRlcm4uXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFFSQ29kZURlY29kZXJNZXRhRGF0YTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUVJDb2RlRGVjb2Rlck1ldGFEYXRhO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1RUkNvZGVEZWNvZGVyTWV0YURhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZWNvZGVyIHsqL1xyXG52YXIgQml0TWF0cml4XzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0JpdE1hdHJpeFwiKTtcclxudmFyIEZvcm1hdEluZm9ybWF0aW9uXzEgPSByZXF1aXJlKFwiLi9Gb3JtYXRJbmZvcm1hdGlvblwiKTtcclxudmFyIEVDQmxvY2tzXzEgPSByZXF1aXJlKFwiLi9FQ0Jsb2Nrc1wiKTtcclxudmFyIEVDQl8xID0gcmVxdWlyZShcIi4vRUNCXCIpO1xyXG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vRm9ybWF0RXhjZXB0aW9uXCIpO1xyXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogU2VlIElTTyAxODAwNDoyMDA2IEFubmV4IERcclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICovXHJcbnZhciBWZXJzaW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmVyc2lvbih2ZXJzaW9uTnVtYmVyIC8qaW50Ki8sIGFsaWdubWVudFBhdHRlcm5DZW50ZXJzKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgdmFyIGVjQmxvY2tzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgZWNCbG9ja3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmVyc2lvbk51bWJlciA9IHZlcnNpb25OdW1iZXI7XHJcbiAgICAgICAgdGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVycyA9IGFsaWdubWVudFBhdHRlcm5DZW50ZXJzO1xyXG4gICAgICAgIHRoaXMuZWNCbG9ja3MgPSBlY0Jsb2NrcztcclxuICAgICAgICB2YXIgdG90YWwgPSAwO1xyXG4gICAgICAgIHZhciBlY0NvZGV3b3JkcyA9IGVjQmxvY2tzWzBdLmdldEVDQ29kZXdvcmRzUGVyQmxvY2soKTtcclxuICAgICAgICB2YXIgZWNiQXJyYXkgPSBlY0Jsb2Nrc1swXS5nZXRFQ0Jsb2NrcygpO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGVjYkFycmF5XzEgPSBfX3ZhbHVlcyhlY2JBcnJheSksIGVjYkFycmF5XzFfMSA9IGVjYkFycmF5XzEubmV4dCgpOyAhZWNiQXJyYXlfMV8xLmRvbmU7IGVjYkFycmF5XzFfMSA9IGVjYkFycmF5XzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWNCbG9jayA9IGVjYkFycmF5XzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgIHRvdGFsICs9IGVjQmxvY2suZ2V0Q291bnQoKSAqIChlY0Jsb2NrLmdldERhdGFDb2Rld29yZHMoKSArIGVjQ29kZXdvcmRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVjYkFycmF5XzFfMSAmJiAhZWNiQXJyYXlfMV8xLmRvbmUgJiYgKF9hID0gZWNiQXJyYXlfMS5yZXR1cm4pKSBfYS5jYWxsKGVjYkFycmF5XzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50b3RhbENvZGV3b3JkcyA9IHRvdGFsO1xyXG4gICAgfVxyXG4gICAgVmVyc2lvbi5wcm90b3R5cGUuZ2V0VmVyc2lvbk51bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52ZXJzaW9uTnVtYmVyO1xyXG4gICAgfTtcclxuICAgIFZlcnNpb24ucHJvdG90eXBlLmdldEFsaWdubWVudFBhdHRlcm5DZW50ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzO1xyXG4gICAgfTtcclxuICAgIFZlcnNpb24ucHJvdG90eXBlLmdldFRvdGFsQ29kZXdvcmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsQ29kZXdvcmRzO1xyXG4gICAgfTtcclxuICAgIFZlcnNpb24ucHJvdG90eXBlLmdldERpbWVuc2lvbkZvclZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIDE3ICsgNCAqIHRoaXMudmVyc2lvbk51bWJlcjtcclxuICAgIH07XHJcbiAgICBWZXJzaW9uLnByb3RvdHlwZS5nZXRFQ0Jsb2Nrc0ZvckxldmVsID0gZnVuY3Rpb24gKGVjTGV2ZWwpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lY0Jsb2Nrc1tlY0xldmVsLmdldFZhbHVlKCldO1xyXG4gICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBvcmlnaW5hbCB3YXMgdXNpbmcgb3JkaW5hbCwgYW5kIHVzaW5nIHRoZSBvcmRlciBvZiBsZXZlbHMgYXMgZGVmaW5lZCBpbiBFcnJvckNvcnJlY3Rpb25MZXZlbCBlbnVtIChMTVFIKVxyXG4gICAgICAgIC8vIEkgd2lsbCB1c2UgdGhlIGRpcmVjdCB2YWx1ZSBmcm9tIEVycm9yQ29ycmVjdGlvbkxldmVsVmFsdWVzIGVudW0gd2hpY2ggaW4gdHlwZXNjcmlwdCBnb2VzIHRvIGEgbnVtYmVyXHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5EZWR1Y2VzIHZlcnNpb24gaW5mb3JtYXRpb24gcHVyZWx5IGZyb20gUVIgQ29kZSBkaW1lbnNpb25zLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGltZW5zaW9uIGRpbWVuc2lvbiBpbiBtb2R1bGVzXHJcbiAgICAgKiBAcmV0dXJuIFZlcnNpb24gZm9yIGEgUVIgQ29kZSBvZiB0aGF0IGRpbWVuc2lvblxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgZGltZW5zaW9uIGlzIG5vdCAxIG1vZCA0XHJcbiAgICAgKi9cclxuICAgIFZlcnNpb24uZ2V0UHJvdmlzaW9uYWxWZXJzaW9uRm9yRGltZW5zaW9uID0gZnVuY3Rpb24gKGRpbWVuc2lvbiAvKmludCovKSB7XHJcbiAgICAgICAgaWYgKGRpbWVuc2lvbiAlIDQgIT09IDEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEZvcm1hdEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmVyc2lvbkZvck51bWJlcigoZGltZW5zaW9uIC0gMTcpIC8gNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChpZ25vcmVkIC8qOiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24qLykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRm9ybWF0RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWZXJzaW9uLmdldFZlcnNpb25Gb3JOdW1iZXIgPSBmdW5jdGlvbiAodmVyc2lvbk51bWJlciAvKmludCovKSB7XHJcbiAgICAgICAgaWYgKHZlcnNpb25OdW1iZXIgPCAxIHx8IHZlcnNpb25OdW1iZXIgPiA0MCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVmVyc2lvbi5WRVJTSU9OU1t2ZXJzaW9uTnVtYmVyIC0gMV07XHJcbiAgICB9O1xyXG4gICAgVmVyc2lvbi5kZWNvZGVWZXJzaW9uSW5mb3JtYXRpb24gPSBmdW5jdGlvbiAodmVyc2lvbkJpdHMgLyppbnQqLykge1xyXG4gICAgICAgIHZhciBiZXN0RGlmZmVyZW5jZSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgICAgIHZhciBiZXN0VmVyc2lvbiA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWZXJzaW9uLlZFUlNJT05fREVDT0RFX0lORk8ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldFZlcnNpb24gPSBWZXJzaW9uLlZFUlNJT05fREVDT0RFX0lORk9baV07XHJcbiAgICAgICAgICAgIC8vIERvIHRoZSB2ZXJzaW9uIGluZm8gYml0cyBtYXRjaCBleGFjdGx5PyBkb25lLlxyXG4gICAgICAgICAgICBpZiAodGFyZ2V0VmVyc2lvbiA9PT0gdmVyc2lvbkJpdHMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBWZXJzaW9uLmdldFZlcnNpb25Gb3JOdW1iZXIoaSArIDcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBzZWUgaWYgdGhpcyBpcyB0aGUgY2xvc2VzdCB0byBhIHJlYWwgdmVyc2lvbiBpbmZvIGJpdCBzdHJpbmdcclxuICAgICAgICAgICAgLy8gd2UgaGF2ZSBzZWVuIHNvIGZhclxyXG4gICAgICAgICAgICB2YXIgYml0c0RpZmZlcmVuY2UgPSBGb3JtYXRJbmZvcm1hdGlvbl8xLmRlZmF1bHQubnVtQml0c0RpZmZlcmluZyh2ZXJzaW9uQml0cywgdGFyZ2V0VmVyc2lvbik7XHJcbiAgICAgICAgICAgIGlmIChiaXRzRGlmZmVyZW5jZSA8IGJlc3REaWZmZXJlbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0VmVyc2lvbiA9IGkgKyA3O1xyXG4gICAgICAgICAgICAgICAgYmVzdERpZmZlcmVuY2UgPSBiaXRzRGlmZmVyZW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBjYW4gdG9sZXJhdGUgdXAgdG8gMyBiaXRzIG9mIGVycm9yIHNpbmNlIG5vIHR3byB2ZXJzaW9uIGluZm8gY29kZXdvcmRzIHdpbGxcclxuICAgICAgICAvLyBkaWZmZXIgaW4gbGVzcyB0aGFuIDggYml0cy5cclxuICAgICAgICBpZiAoYmVzdERpZmZlcmVuY2UgPD0gMykge1xyXG4gICAgICAgICAgICByZXR1cm4gVmVyc2lvbi5nZXRWZXJzaW9uRm9yTnVtYmVyKGJlc3RWZXJzaW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYSBjbG9zZSBlbm91Z2ggbWF0Y2gsIGZhaWxcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNlZSBJU08gMTgwMDQ6MjAwNiBBbm5leCBFXHJcbiAgICAgKi9cclxuICAgIFZlcnNpb24ucHJvdG90eXBlLmJ1aWxkRnVuY3Rpb25QYXR0ZXJuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLmdldERpbWVuc2lvbkZvclZlcnNpb24oKTtcclxuICAgICAgICB2YXIgYml0TWF0cml4ID0gbmV3IEJpdE1hdHJpeF8xLmRlZmF1bHQoZGltZW5zaW9uKTtcclxuICAgICAgICAvLyBUb3AgbGVmdCBmaW5kZXIgcGF0dGVybiArIHNlcGFyYXRvciArIGZvcm1hdFxyXG4gICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oMCwgMCwgOSwgOSk7XHJcbiAgICAgICAgLy8gVG9wIHJpZ2h0IGZpbmRlciBwYXR0ZXJuICsgc2VwYXJhdG9yICsgZm9ybWF0XHJcbiAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbihkaW1lbnNpb24gLSA4LCAwLCA4LCA5KTtcclxuICAgICAgICAvLyBCb3R0b20gbGVmdCBmaW5kZXIgcGF0dGVybiArIHNlcGFyYXRvciArIGZvcm1hdFxyXG4gICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oMCwgZGltZW5zaW9uIC0gOCwgOSwgOCk7XHJcbiAgICAgICAgLy8gQWxpZ25tZW50IHBhdHRlcm5zXHJcbiAgICAgICAgdmFyIG1heCA9IHRoaXMuYWxpZ25tZW50UGF0dGVybkNlbnRlcnMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgbWF4OyB4KyspIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmFsaWdubWVudFBhdHRlcm5DZW50ZXJzW3hdIC0gMjtcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBtYXg7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCh4ID09PSAwICYmICh5ID09PSAwIHx8IHkgPT09IG1heCAtIDEpKSB8fCAoeCA9PT0gbWF4IC0gMSAmJiB5ID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGFsaWdubWVudCBwYXR0ZXJucyBuZWFyIHRoZSB0aHJlZSBmaW5kZXIgcGF0dGVybnNcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24odGhpcy5hbGlnbm1lbnRQYXR0ZXJuQ2VudGVyc1t5XSAtIDIsIGksIDUsIDUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuXHJcbiAgICAgICAgYml0TWF0cml4LnNldFJlZ2lvbig2LCA5LCAxLCBkaW1lbnNpb24gLSAxNyk7XHJcbiAgICAgICAgLy8gSG9yaXpvbnRhbCB0aW1pbmcgcGF0dGVyblxyXG4gICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oOSwgNiwgZGltZW5zaW9uIC0gMTcsIDEpO1xyXG4gICAgICAgIGlmICh0aGlzLnZlcnNpb25OdW1iZXIgPiA2KSB7XHJcbiAgICAgICAgICAgIC8vIFZlcnNpb24gaW5mbywgdG9wIHJpZ2h0XHJcbiAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oZGltZW5zaW9uIC0gMTEsIDAsIDMsIDYpO1xyXG4gICAgICAgICAgICAvLyBWZXJzaW9uIGluZm8sIGJvdHRvbSBsZWZ0XHJcbiAgICAgICAgICAgIGJpdE1hdHJpeC5zZXRSZWdpb24oMCwgZGltZW5zaW9uIC0gMTEsIDYsIDMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYml0TWF0cml4O1xyXG4gICAgfTtcclxuICAgIC8qQE92ZXJyaWRlKi9cclxuICAgIFZlcnNpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnJyArIHRoaXMudmVyc2lvbk51bWJlcjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAgICogU2VlIElTTyAxODAwNDoyMDA2IEFubmV4IEQuXHJcbiAgICAgICAqIEVsZW1lbnQgaSByZXByZXNlbnRzIHRoZSByYXcgdmVyc2lvbiBiaXRzIHRoYXQgc3BlY2lmeSB2ZXJzaW9uIGkgKyA3XHJcbiAgICAgICAqL1xyXG4gICAgVmVyc2lvbi5WRVJTSU9OX0RFQ09ERV9JTkZPID0gSW50MzJBcnJheS5mcm9tKFtcclxuICAgICAgICAweDA3Qzk0LCAweDA4NUJDLCAweDA5QTk5LCAweDBBNEQzLCAweDBCQkY2LFxyXG4gICAgICAgIDB4MEM3NjIsIDB4MEQ4NDcsIDB4MEU2MEQsIDB4MEY5MjgsIDB4MTBCNzgsXHJcbiAgICAgICAgMHgxMTQ1RCwgMHgxMkExNywgMHgxMzUzMiwgMHgxNDlBNiwgMHgxNTY4MyxcclxuICAgICAgICAweDE2OEM5LCAweDE3N0VDLCAweDE4RUM0LCAweDE5MUUxLCAweDFBRkFCLFxyXG4gICAgICAgIDB4MUIwOEUsIDB4MUNDMUEsIDB4MUQzM0YsIDB4MUVENzUsIDB4MUYyNTAsXHJcbiAgICAgICAgMHgyMDlENSwgMHgyMTZGMCwgMHgyMjhCQSwgMHgyMzc5RiwgMHgyNEIwQixcclxuICAgICAgICAweDI1NDJFLCAweDI2QTY0LCAweDI3NTQxLCAweDI4QzY5XHJcbiAgICBdKTtcclxuICAgIC8qKlxyXG4gICAgICAgKiBTZWUgSVNPIDE4MDA0OjIwMDYgNi41LjEgVGFibGUgOVxyXG4gICAgICAgKi9cclxuICAgIFZlcnNpb24uVkVSU0lPTlMgPSBbXHJcbiAgICAgICAgbmV3IFZlcnNpb24oMSwgbmV3IEludDMyQXJyYXkoMCksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoNywgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxMCwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxMywgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTMpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxNywgbmV3IEVDQl8xLmRlZmF1bHQoMSwgOSkpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigyLCBJbnQzMkFycmF5LmZyb20oWzYsIDE4XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTAsIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDM0KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTYsIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDI4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjIsIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDIyKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDE2KSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDMsIEludDMyQXJyYXkuZnJvbShbNiwgMjJdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxNSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgNTUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgNDQpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgxOCwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyMiwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTMpKSksXHJcbiAgICAgICAgbmV3IFZlcnNpb24oNCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNl0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIwLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA4MCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE4LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAzMikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAyNCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDE2LCBuZXcgRUNCXzEuZGVmYXVsdCg0LCA5KSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDUsIEludDMyQXJyYXkuZnJvbShbNiwgMzBdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTA4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDQzKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyMiwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTEpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxMikpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbig2LCBJbnQzMkFycmF5LmZyb20oWzYsIDM0XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDY4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTYsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDI3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDE5KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDE1KSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDcsIEludDMyQXJyYXkuZnJvbShbNiwgMjIsIDM4XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDc4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTgsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDMxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDE0KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTMpLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAxNCkpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbig4LCBJbnQzMkFycmF5LmZyb20oWzYsIDI0LCA0Ml0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCA5NykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIyLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAzOCksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDM5KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjIsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDE4KSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTQpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxNSkpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbig5LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0Nl0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxMTYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyMiwgbmV3IEVDQl8xLmRlZmF1bHQoMywgMzYpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAzNykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIwLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxNiksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDE3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDEyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTMpKSksXHJcbiAgICAgICAgbmV3IFZlcnNpb24oMTAsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDUwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMTgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDY4KSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgNjkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgNDMpLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA0NCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAxOSksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDIwKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTYpKSksXHJcbiAgICAgICAgbmV3IFZlcnNpb24oMTEsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDgxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDUwKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgNTEpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMjIpLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAyMykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCgzLCAxMiksIG5ldyBFQ0JfMS5kZWZhdWx0KDgsIDEzKSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDEyLCBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCA5MiksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDkzKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjIsIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDM2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMzcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMjApLCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAyMSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCg3LCAxNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDE1KSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDEzLCBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2Ml0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyMiwgbmV3IEVDQl8xLmRlZmF1bHQoOCwgMzcpLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAzOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCg4LCAyMCksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDIxKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjIsIG5ldyBFQ0JfMS5kZWZhdWx0KDEyLCAxMSksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDEyKSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDE0LCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA0NiwgNjZdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMywgMTE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTE2KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDQwKSwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgNDEpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTEsIDE2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgMTcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoMTEsIDEyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgMTMpKSksXHJcbiAgICAgICAgbmV3IFZlcnNpb24oMTUsIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ4LCA3MF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDIyLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCA4NyksIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDg4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDQxKSwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgNDIpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCg3LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCgxMSwgMTIpLCBuZXcgRUNCXzEuZGVmYXVsdCg3LCAxMykpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigxNiwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjQsIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDk4KSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgOTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoNywgNDUpLCBuZXcgRUNCXzEuZGVmYXVsdCgzLCA0NikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI0LCBuZXcgRUNCXzEuZGVmYXVsdCgxNSwgMTkpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAyMCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgzLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEzLCAxNikpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigxNywgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTQsIDc4XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDEwNyksIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDEwOCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgNDYpLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCA0NykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAyMiksIG5ldyBFQ0JfMS5kZWZhdWx0KDE1LCAyMykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDE3LCAxNSkpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigxOCwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTYsIDgyXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDEyMCksIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDEyMSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI2LCBuZXcgRUNCXzEuZGVmYXVsdCg5LCA0MyksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDQ0KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDE3LCAyMiksIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDIzKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDE0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTksIDE1KSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDE5LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1OCwgODZdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMywgMTEzKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTE0KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDQ0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTEsIDQ1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDE3LCAyMSksIG5ldyBFQ0JfMS5kZWZhdWx0KDQsIDIyKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDksIDEzKSwgbmV3IEVDQl8xLmRlZmF1bHQoMTYsIDE0KSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDIwLCBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MiwgOTBdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMywgMTA3KSwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgMTA4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjYsIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDQxKSwgbmV3IEVDQl8xLmRlZmF1bHQoMTMsIDQyKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDE1LCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDUsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDE1LCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCAxNikpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigyMSwgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTAsIDcyLCA5NF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMTYpLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMTcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoMTcsIDQyKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDE3LCAyMiksIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDIzKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDE5LCAxNiksIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDE3KSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDIyLCBJbnQzMkFycmF5LmZyb20oWzYsIDI2LCA1MCwgNzQsIDk4XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDExMSksIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDExMikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxNywgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNywgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNiwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNCwgbmV3IEVDQl8xLmRlZmF1bHQoMzQsIDEzKSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDIzLCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzgsIDEwMl0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMjEpLCBuZXcgRUNCXzEuZGVmYXVsdCg1LCAxMjIpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgNDcpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgNDgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTEsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTQsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDE2LCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDE0LCAxNikpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigyNCwgSW50MzJBcnJheS5mcm9tKFs2LCAyOCwgNTQsIDgwLCAxMDZdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgMTE3KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTE4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDQ1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTQsIDQ2KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDExLCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDE2LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgzMCwgMTYpLCBuZXcgRUNCXzEuZGVmYXVsdCgyLCAxNykpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigyNSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMiwgNTgsIDg0LCAxMTBdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyNiwgbmV3IEVDQl8xLmRlZmF1bHQoOCwgMTA2KSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTA3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDgsIDQ3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTMsIDQ4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjIsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIyLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDEzLCAxNikpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigyNiwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTRdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTAsIDExNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDExNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxOSwgNDYpLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCA0NykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgyOCwgMjIpLCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAyMykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgzMywgMTYpLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxNykpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigyNywgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjIsIDkwLCAxMThdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoOCwgMTIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTIzKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIyLCA0NSksIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDQ2KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDgsIDIzKSwgbmV3IEVDQl8xLmRlZmF1bHQoMjYsIDI0KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDEyLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDI4LCAxNikpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigyOCwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDMsIDExNyksIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCAxMTgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMywgNDUpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMywgNDYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgzMSwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTEsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzEsIDE2KSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDI5LCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NCwgNzgsIDEwMiwgMTI2XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDExNiksIG5ldyBFQ0JfMS5kZWZhdWx0KDcsIDExNykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgyMSwgNDUpLCBuZXcgRUNCXzEuZGVmYXVsdCg3LCA0NikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAyMyksIG5ldyBFQ0JfMS5kZWZhdWx0KDM3LCAyNCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxOSwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCgyNiwgMTYpKSksXHJcbiAgICAgICAgbmV3IFZlcnNpb24oMzAsIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzBdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNSwgMTE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTAsIDExNikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxOSwgNDcpLCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgNDgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTUsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjUsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIzLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDI1LCAxNikpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigzMSwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTYsIDgyLCAxMDgsIDEzNF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxMywgMTE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMywgMTE2KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDIsIDQ2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjksIDQ3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQyLCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDEsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIzLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDI4LCAxNikpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigzMiwgSW50MzJBcnJheS5mcm9tKFs2LCAzNCwgNjAsIDg2LCAxMTIsIDEzOF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxNywgMTE1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCA0NiksIG5ldyBFQ0JfMS5kZWZhdWx0KDIzLCA0NykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgzNSwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTksIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzUsIDE2KSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDMzLCBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1OCwgODYsIDExNCwgMTQyXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDE3LCAxMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCgxLCAxMTYpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTQsIDQ2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjEsIDQ3KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDI5LCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDE5LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxMSwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCg0NiwgMTYpKSksXHJcbiAgICAgICAgbmV3IFZlcnNpb24oMzQsIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgMTE4LCAxNDZdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMTMsIDExNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDYsIDExNikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgNDYpLCBuZXcgRUNCXzEuZGVmYXVsdCgyMywgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNDQsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoNywgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNTksIDE2KSwgbmV3IEVDQl8xLmRlZmF1bHQoMSwgMTcpKSksXHJcbiAgICAgICAgbmV3IFZlcnNpb24oMzUsIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxMiwgMTIxKSwgbmV3IEVDQl8xLmRlZmF1bHQoNywgMTIyKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDEyLCA0NyksIG5ldyBFQ0JfMS5kZWZhdWx0KDI2LCA0OCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgzOSwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxNCwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMjIsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoNDEsIDE2KSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDM2LCBJbnQzMkFycmF5LmZyb20oWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNiwgMTIxKSwgbmV3IEVDQl8xLmRlZmF1bHQoMTQsIDEyMikpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCg2LCA0NyksIG5ldyBFQ0JfMS5kZWZhdWx0KDM0LCA0OCkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg0NiwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMiwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCg2NCwgMTYpKSksXHJcbiAgICAgICAgbmV3IFZlcnNpb24oMzcsIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0pLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgxNywgMTIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTIzKSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMjgsIG5ldyBFQ0JfMS5kZWZhdWx0KDI5LCA0NiksIG5ldyBFQ0JfMS5kZWZhdWx0KDE0LCA0NykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCg0OSwgMjQpLCBuZXcgRUNCXzEuZGVmYXVsdCgxMCwgMjUpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoMjQsIDE1KSwgbmV3IEVDQl8xLmRlZmF1bHQoNDYsIDE2KSkpLFxyXG4gICAgICAgIG5ldyBWZXJzaW9uKDM4LCBJbnQzMkFycmF5LmZyb20oWzYsIDMyLCA1OCwgODQsIDExMCwgMTM2LCAxNjJdKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNCwgMTIyKSwgbmV3IEVDQl8xLmRlZmF1bHQoMTgsIDEyMykpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDI4LCBuZXcgRUNCXzEuZGVmYXVsdCgxMywgNDYpLCBuZXcgRUNCXzEuZGVmYXVsdCgzMiwgNDcpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNDgsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMTQsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDQyLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDMyLCAxNikpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbigzOSwgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDIwLCAxMTcpLCBuZXcgRUNCXzEuZGVmYXVsdCg0LCAxMTgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoNDAsIDQ3KSwgbmV3IEVDQl8xLmRlZmF1bHQoNywgNDgpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgzMCwgbmV3IEVDQl8xLmRlZmF1bHQoNDMsIDI0KSwgbmV3IEVDQl8xLmRlZmF1bHQoMjIsIDI1KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDEwLCAxNSksIG5ldyBFQ0JfMS5kZWZhdWx0KDY3LCAxNikpKSxcclxuICAgICAgICBuZXcgVmVyc2lvbig0MCwgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDE5LCAxMTgpLCBuZXcgRUNCXzEuZGVmYXVsdCg2LCAxMTkpKSwgbmV3IEVDQmxvY2tzXzEuZGVmYXVsdCgyOCwgbmV3IEVDQl8xLmRlZmF1bHQoMTgsIDQ3KSwgbmV3IEVDQl8xLmRlZmF1bHQoMzEsIDQ4KSksIG5ldyBFQ0Jsb2Nrc18xLmRlZmF1bHQoMzAsIG5ldyBFQ0JfMS5kZWZhdWx0KDM0LCAyNCksIG5ldyBFQ0JfMS5kZWZhdWx0KDM0LCAyNSkpLCBuZXcgRUNCbG9ja3NfMS5kZWZhdWx0KDMwLCBuZXcgRUNCXzEuZGVmYXVsdCgyMCwgMTUpLCBuZXcgRUNCXzEuZGVmYXVsdCg2MSwgMTYpKSlcclxuICAgIF07XHJcbiAgICByZXR1cm4gVmVyc2lvbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVmVyc2lvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZXRlY3RvciB7Ki9cclxudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVzdWx0UG9pbnRcIik7XHJcbi8qKlxyXG4gKiA8cD5FbmNhcHN1bGF0ZXMgYW4gYWxpZ25tZW50IHBhdHRlcm4sIHdoaWNoIGFyZSB0aGUgc21hbGxlciBzcXVhcmUgcGF0dGVybnMgZm91bmQgaW5cclxuICogYWxsIGJ1dCB0aGUgc2ltcGxlc3QgUVIgQ29kZXMuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIEFsaWdubWVudFBhdHRlcm4gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoQWxpZ25tZW50UGF0dGVybiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFsaWdubWVudFBhdHRlcm4ocG9zWCAvKmZsb2F0Ki8sIHBvc1kgLypmbG9hdCovLCBlc3RpbWF0ZWRNb2R1bGVTaXplIC8qZmxvYXQqLykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHBvc1gsIHBvc1kpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGVzdGltYXRlZE1vZHVsZVNpemU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5EZXRlcm1pbmVzIGlmIHRoaXMgYWxpZ25tZW50IHBhdHRlcm4gXCJhYm91dCBlcXVhbHNcIiBhbiBhbGlnbm1lbnQgcGF0dGVybiBhdCB0aGUgc3RhdGVkXHJcbiAgICAgKiBwb3NpdGlvbiBhbmQgc2l6ZSAtLSBtZWFuaW5nLCBpdCBpcyBhdCBuZWFybHkgdGhlIHNhbWUgY2VudGVyIHdpdGggbmVhcmx5IHRoZSBzYW1lIHNpemUuPC9wPlxyXG4gICAgICovXHJcbiAgICBBbGlnbm1lbnRQYXR0ZXJuLnByb3RvdHlwZS5hYm91dEVxdWFscyA9IGZ1bmN0aW9uIChtb2R1bGVTaXplIC8qZmxvYXQqLywgaSAvKmZsb2F0Ki8sIGogLypmbG9hdCovKSB7XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGkgLSB0aGlzLmdldFkoKSkgPD0gbW9kdWxlU2l6ZSAmJiBNYXRoLmFicyhqIC0gdGhpcy5nZXRYKCkpIDw9IG1vZHVsZVNpemUpIHtcclxuICAgICAgICAgICAgdmFyIG1vZHVsZVNpemVEaWZmID0gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHRoaXMuZXN0aW1hdGVkTW9kdWxlU2l6ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVTaXplRGlmZiA8PSAxLjAgfHwgbW9kdWxlU2l6ZURpZmYgPD0gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb21iaW5lcyB0aGlzIG9iamVjdCdzIGN1cnJlbnQgZXN0aW1hdGUgb2YgYSBmaW5kZXIgcGF0dGVybiBwb3NpdGlvbiBhbmQgbW9kdWxlIHNpemVcclxuICAgICAqIHdpdGggYSBuZXcgZXN0aW1hdGUuIEl0IHJldHVybnMgYSBuZXcge0Bjb2RlIEZpbmRlclBhdHRlcm59IGNvbnRhaW5pbmcgYW4gYXZlcmFnZSBvZiB0aGUgdHdvLlxyXG4gICAgICovXHJcbiAgICBBbGlnbm1lbnRQYXR0ZXJuLnByb3RvdHlwZS5jb21iaW5lRXN0aW1hdGUgPSBmdW5jdGlvbiAoaSAvKmZsb2F0Ki8sIGogLypmbG9hdCovLCBuZXdNb2R1bGVTaXplIC8qZmxvYXQqLykge1xyXG4gICAgICAgIHZhciBjb21iaW5lZFggPSAodGhpcy5nZXRYKCkgKyBqKSAvIDIuMDtcclxuICAgICAgICB2YXIgY29tYmluZWRZID0gKHRoaXMuZ2V0WSgpICsgaSkgLyAyLjA7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTW9kdWxlU2l6ZSA9ICh0aGlzLmVzdGltYXRlZE1vZHVsZVNpemUgKyBuZXdNb2R1bGVTaXplKSAvIDIuMDtcclxuICAgICAgICByZXR1cm4gbmV3IEFsaWdubWVudFBhdHRlcm4oY29tYmluZWRYLCBjb21iaW5lZFksIGNvbWJpbmVkTW9kdWxlU2l6ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFsaWdubWVudFBhdHRlcm47XHJcbn0oUmVzdWx0UG9pbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFsaWdubWVudFBhdHRlcm47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFsaWdubWVudFBhdHRlcm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgQWxpZ25tZW50UGF0dGVybl8xID0gcmVxdWlyZShcIi4vQWxpZ25tZW50UGF0dGVyblwiKTtcclxudmFyIE5vdEZvdW5kRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbi8qaW1wb3J0IGphdmEudXRpbC5BcnJheUxpc3Q7Ki9cclxuLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cclxuLyoqXHJcbiAqIDxwPlRoaXMgY2xhc3MgYXR0ZW1wdHMgdG8gZmluZCBhbGlnbm1lbnQgcGF0dGVybnMgaW4gYSBRUiBDb2RlLiBBbGlnbm1lbnQgcGF0dGVybnMgbG9vayBsaWtlIGZpbmRlclxyXG4gKiBwYXR0ZXJucyBidXQgYXJlIHNtYWxsZXIgYW5kIGFwcGVhciBhdCByZWd1bGFyIGludGVydmFscyB0aHJvdWdob3V0IHRoZSBpbWFnZS48L3A+XHJcbiAqXHJcbiAqIDxwPkF0IHRoZSBtb21lbnQgdGhpcyBvbmx5IGxvb2tzIGZvciB0aGUgYm90dG9tLXJpZ2h0IGFsaWdubWVudCBwYXR0ZXJuLjwvcD5cclxuICpcclxuICogPHA+VGhpcyBpcyBtb3N0bHkgYSBzaW1wbGlmaWVkIGNvcHkgb2Yge0BsaW5rIEZpbmRlclBhdHRlcm5GaW5kZXJ9LiBJdCBpcyBjb3BpZWQsXHJcbiAqIHBhc3RlZCBhbmQgc3RyaXBwZWQgZG93biBoZXJlIGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlIGJ1dCBkb2VzIHVuZm9ydHVuYXRlbHkgZHVwbGljYXRlXHJcbiAqIHNvbWUgY29kZS48L3A+XHJcbiAqXHJcbiAqIDxwPlRoaXMgY2xhc3MgaXMgdGhyZWFkLXNhZmUgYnV0IG5vdCByZWVudHJhbnQuIEVhY2ggdGhyZWFkIG11c3QgYWxsb2NhdGUgaXRzIG93biBvYmplY3QuPC9wPlxyXG4gKlxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIEFsaWdubWVudFBhdHRlcm5GaW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIDxwPkNyZWF0ZXMgYSBmaW5kZXIgdGhhdCB3aWxsIGxvb2sgaW4gYSBwb3J0aW9uIG9mIHRoZSB3aG9sZSBpbWFnZS48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGltYWdlIGltYWdlIHRvIHNlYXJjaFxyXG4gICAgICogQHBhcmFtIHN0YXJ0WCBsZWZ0IGNvbHVtbiBmcm9tIHdoaWNoIHRvIHN0YXJ0IHNlYXJjaGluZ1xyXG4gICAgICogQHBhcmFtIHN0YXJ0WSB0b3Agcm93IGZyb20gd2hpY2ggdG8gc3RhcnQgc2VhcmNoaW5nXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggd2lkdGggb2YgcmVnaW9uIHRvIHNlYXJjaFxyXG4gICAgICogQHBhcmFtIGhlaWdodCBoZWlnaHQgb2YgcmVnaW9uIHRvIHNlYXJjaFxyXG4gICAgICogQHBhcmFtIG1vZHVsZVNpemUgZXN0aW1hdGVkIG1vZHVsZSBzaXplIHNvIGZhclxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyKGltYWdlLCBzdGFydFggLyppbnQqLywgc3RhcnRZIC8qaW50Ki8sIHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovLCBtb2R1bGVTaXplIC8qZmxvYXQqLywgcmVzdWx0UG9pbnRDYWxsYmFjaykge1xyXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBpbWFnZTtcclxuICAgICAgICB0aGlzLnN0YXJ0WCA9IHN0YXJ0WDtcclxuICAgICAgICB0aGlzLnN0YXJ0WSA9IHN0YXJ0WTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5tb2R1bGVTaXplID0gbW9kdWxlU2l6ZTtcclxuICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSByZXN1bHRQb2ludENhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMucG9zc2libGVDZW50ZXJzID0gW107IC8vIG5ldyBBcnJheTxhbnk+KDUpKVxyXG4gICAgICAgIC8vIFRZUEVTQ1JJUFRQT1JUOiBhcnJheSBpbml0aWFsaXphdGlvbiB3aXRob3V0IHNpemUgYXMgdGhlIGxlbmd0aCBpcyBjaGVja2VkIGJlbG93XHJcbiAgICAgICAgdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudCA9IG5ldyBJbnQzMkFycmF5KDMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5UaGlzIG1ldGhvZCBhdHRlbXB0cyB0byBmaW5kIHRoZSBib3R0b20tcmlnaHQgYWxpZ25tZW50IHBhdHRlcm4gaW4gdGhlIGltYWdlLiBJdCBpcyBhIGJpdCBtZXNzeSBzaW5jZVxyXG4gICAgICogaXQncyBwcmV0dHkgcGVyZm9ybWFuY2UtY3JpdGljYWwgYW5kIHNvIGlzIHdyaXR0ZW4gdG8gYmUgZmFzdCBmb3JlbW9zdC48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0gaWYgZm91bmRcclxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgbm90IGZvdW5kXHJcbiAgICAgKi9cclxuICAgIEFsaWdubWVudFBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0WCA9IHRoaXMuc3RhcnRYO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIHZhciBtYXhKID0gc3RhcnRYICsgd2lkdGg7XHJcbiAgICAgICAgdmFyIG1pZGRsZUkgPSB0aGlzLnN0YXJ0WSArIChoZWlnaHQgLyAyKTtcclxuICAgICAgICAvLyBXZSBhcmUgbG9va2luZyBmb3IgYmxhY2svd2hpdGUvYmxhY2sgbW9kdWxlcyBpbiAxOjE6MSByYXRpb1xyXG4gICAgICAgIC8vIHRoaXMgdHJhY2tzIHRoZSBudW1iZXIgb2YgYmxhY2svd2hpdGUvYmxhY2sgbW9kdWxlcyBzZWVuIHNvIGZhclxyXG4gICAgICAgIHZhciBzdGF0ZUNvdW50ID0gbmV3IEludDMyQXJyYXkoMyk7XHJcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcclxuICAgICAgICBmb3IgKHZhciBpR2VuID0gMDsgaUdlbiA8IGhlaWdodDsgaUdlbisrKSB7XHJcbiAgICAgICAgICAgIC8vIFNlYXJjaCBmcm9tIG1pZGRsZSBvdXR3YXJkc1xyXG4gICAgICAgICAgICB2YXIgaSA9IG1pZGRsZUkgKyAoKGlHZW4gJiAweDAxKSA9PT0gMCA/IE1hdGguZmxvb3IoKGlHZW4gKyAxKSAvIDIpIDogLU1hdGguZmxvb3IoKGlHZW4gKyAxKSAvIDIpKTtcclxuICAgICAgICAgICAgc3RhdGVDb3VudFswXSA9IDA7XHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAwO1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcclxuICAgICAgICAgICAgdmFyIGogPSBzdGFydFg7XHJcbiAgICAgICAgICAgIC8vIEJ1cm4gb2ZmIGxlYWRpbmcgd2hpdGUgcGl4ZWxzIGJlZm9yZSBhbnl0aGluZyBlbHNlOyBpZiB3ZSBzdGFydCBpbiB0aGUgbWlkZGxlIG9mXHJcbiAgICAgICAgICAgIC8vIGEgd2hpdGUgcnVuLCBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gY291bnQgaXRzIGxlbmd0aCwgc2luY2Ugd2UgZG9uJ3Qga25vdyBpZiB0aGVcclxuICAgICAgICAgICAgLy8gd2hpdGUgcnVuIGNvbnRpbnVlZCB0byB0aGUgbGVmdCBvZiB0aGUgc3RhcnQgcG9pbnRcclxuICAgICAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmICFpbWFnZS5nZXQoaiwgaSkpIHtcclxuICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKGogPCBtYXhKKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2UuZ2V0KGosIGkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQmxhY2sgcGl4ZWxcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlID09PSAxKSB7IC8vIENvdW50aW5nIGJsYWNrIHBpeGVsc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gMikgeyAvLyBBIHdpbm5lcj9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7IC8vIFllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIGopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtZWQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gc3RhdGVDb3VudFsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsrK2N1cnJlbnRTdGF0ZV0rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBXaGl0ZSBwaXhlbFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3RhdGUgPT09IDEpIHsgLy8gQ291bnRpbmcgYmxhY2sgcGl4ZWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50W2N1cnJlbnRTdGF0ZV0rKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGorKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgbWF4Sik7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlybWVkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1lZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBIbW0sIG5vdGhpbmcgd2Ugc2F3IHdhcyBvYnNlcnZlZCBhbmQgY29uZmlybWVkIHR3aWNlLiBJZiB3ZSBoYWRcclxuICAgICAgICAvLyBhbnkgZ3Vlc3MgYXQgYWxsLCByZXR1cm4gaXQuXHJcbiAgICAgICAgaWYgKHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NzaWJsZUNlbnRlcnNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgY291bnQgb2YgYmxhY2svd2hpdGUvYmxhY2sgcGl4ZWxzIGp1c3Qgc2VlbiBhbmQgYW4gZW5kIHBvc2l0aW9uLFxyXG4gICAgICogZmlndXJlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGlzIGJsYWNrL3doaXRlL2JsYWNrIHJ1bi5cclxuICAgICAqL1xyXG4gICAgQWxpZ25tZW50UGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kID0gZnVuY3Rpb24gKHN0YXRlQ291bnQsIGVuZCAvKmludCovKSB7XHJcbiAgICAgICAgcmV0dXJuIChlbmQgLSBzdGF0ZUNvdW50WzJdKSAtIHN0YXRlQ291bnRbMV0gLyAyLjA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gc3RhdGVDb3VudCBjb3VudCBvZiBibGFjay93aGl0ZS9ibGFjayBwaXhlbHMganVzdCByZWFkXHJcbiAgICAgKiBAcmV0dXJuIHRydWUgaWZmIHRoZSBwcm9wb3J0aW9ucyBvZiB0aGUgY291bnRzIGlzIGNsb3NlIGVub3VnaCB0byB0aGUgMS8xLzEgcmF0aW9zXHJcbiAgICAgKiAgICAgICAgIHVzZWQgYnkgYWxpZ25tZW50IHBhdHRlcm5zIHRvIGJlIGNvbnNpZGVyZWQgYSBtYXRjaFxyXG4gICAgICovXHJcbiAgICBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5mb3VuZFBhdHRlcm5Dcm9zcyA9IGZ1bmN0aW9uIChzdGF0ZUNvdW50KSB7XHJcbiAgICAgICAgdmFyIG1vZHVsZVNpemUgPSB0aGlzLm1vZHVsZVNpemU7XHJcbiAgICAgICAgdmFyIG1heFZhcmlhbmNlID0gbW9kdWxlU2l6ZSAvIDIuMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbaV0pID49IG1heFZhcmlhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5BZnRlciBhIGhvcml6b250YWwgc2NhbiBmaW5kcyBhIHBvdGVudGlhbCBhbGlnbm1lbnQgcGF0dGVybiwgdGhpcyBtZXRob2RcclxuICAgICAqIFwiY3Jvc3MtY2hlY2tzXCIgYnkgc2Nhbm5pbmcgZG93biB2ZXJ0aWNhbGx5IHRocm91Z2ggdGhlIGNlbnRlciBvZiB0aGUgcG9zc2libGVcclxuICAgICAqIGFsaWdubWVudCBwYXR0ZXJuIHRvIHNlZSBpZiB0aGUgc2FtZSBwcm9wb3J0aW9uIGlzIGRldGVjdGVkLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhcnRJIHJvdyB3aGVyZSBhbiBhbGlnbm1lbnQgcGF0dGVybiB3YXMgZGV0ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYW4gYWxpZ25tZW50IHBhdHRlcm5cclxuICAgICAqIEBwYXJhbSBtYXhDb3VudCBtYXhpbXVtIHJlYXNvbmFibGUgbnVtYmVyIG9mIG1vZHVsZXMgdGhhdCBzaG91bGQgYmVcclxuICAgICAqIG9ic2VydmVkIGluIGFueSByZWFkaW5nIHN0YXRlLCBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGUgaG9yaXpvbnRhbCBzY2FuXHJcbiAgICAgKiBAcmV0dXJuIHZlcnRpY2FsIGNlbnRlciBvZiBhbGlnbm1lbnQgcGF0dGVybiwgb3Ige0BsaW5rIEZsb2F0I05hTn0gaWYgbm90IGZvdW5kXHJcbiAgICAgKi9cclxuICAgIEFsaWdubWVudFBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmNyb3NzQ2hlY2tWZXJ0aWNhbCA9IGZ1bmN0aW9uIChzdGFydEkgLyppbnQqLywgY2VudGVySiAvKmludCovLCBtYXhDb3VudCAvKmludCovLCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcclxuICAgICAgICB2YXIgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpO1xyXG4gICAgICAgIHZhciBzdGF0ZUNvdW50ID0gdGhpcy5jcm9zc0NoZWNrU3RhdGVDb3VudDtcclxuICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcclxuICAgICAgICBzdGF0ZUNvdW50WzFdID0gMDtcclxuICAgICAgICBzdGF0ZUNvdW50WzJdID0gMDtcclxuICAgICAgICAvLyBTdGFydCBjb3VudGluZyB1cCBmcm9tIGNlbnRlclxyXG4gICAgICAgIHZhciBpID0gc3RhcnRJO1xyXG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgaW1hZ2UuZ2V0KGNlbnRlckosIGkpICYmIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xyXG4gICAgICAgICAgICBpLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGFscmVhZHkgdG9vIG1hbnkgbW9kdWxlcyBpbiB0aGlzIHN0YXRlIG9yIHJhbiBvZmYgdGhlIGVkZ2U6XHJcbiAgICAgICAgaWYgKGkgPCAwIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoaSA+PSAwICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XHJcbiAgICAgICAgICAgIGktLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3cgYWxzbyBjb3VudCBkb3duIGZyb20gY2VudGVyXHJcbiAgICAgICAgaSA9IHN0YXJ0SSArIDE7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA9PT0gbWF4SSB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFsyXSA8PSBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlQ291bnRbMl0gPiBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdO1xyXG4gICAgICAgIGlmICg1ICogTWF0aC5hYnMoc3RhdGVDb3VudFRvdGFsIC0gb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwpID49IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSA/IEFsaWdubWVudFBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBpKSA6IE5hTjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPlRoaXMgaXMgY2FsbGVkIHdoZW4gYSBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3NzaWJsZSBhbGlnbm1lbnQgcGF0dGVybi4gSXQgd2lsbFxyXG4gICAgICogY3Jvc3MgY2hlY2sgd2l0aCBhIHZlcnRpY2FsIHNjYW4sIGFuZCBpZiBzdWNjZXNzZnVsLCB3aWxsIHNlZSBpZiB0aGlzIHBhdHRlcm4gaGFkIGJlZW5cclxuICAgICAqIGZvdW5kIG9uIGEgcHJldmlvdXMgaG9yaXpvbnRhbCBzY2FuLiBJZiBzbywgd2UgY29uc2lkZXIgaXQgY29uZmlybWVkIGFuZCBjb25jbHVkZSB3ZSBoYXZlXHJcbiAgICAgKiBmb3VuZCB0aGUgYWxpZ25tZW50IHBhdHRlcm4uPC9wPlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZUNvdW50IHJlYWRpbmcgc3RhdGUgbW9kdWxlIGNvdW50cyBmcm9tIGhvcml6b250YWwgc2NhblxyXG4gICAgICogQHBhcmFtIGkgcm93IHdoZXJlIGFsaWdubWVudCBwYXR0ZXJuIG1heSBiZSBmb3VuZFxyXG4gICAgICogQHBhcmFtIGogZW5kIG9mIHBvc3NpYmxlIGFsaWdubWVudCBwYXR0ZXJuIGluIHJvd1xyXG4gICAgICogQHJldHVybiB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0gaWYgd2UgaGF2ZSBmb3VuZCB0aGUgc2FtZSBwYXR0ZXJuIHR3aWNlLCBvciBudWxsIGlmIG5vdFxyXG4gICAgICovXHJcbiAgICBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5oYW5kbGVQb3NzaWJsZUNlbnRlciA9IGZ1bmN0aW9uIChzdGF0ZUNvdW50LCBpIC8qaW50Ki8sIGogLyppbnQqLykge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl07XHJcbiAgICAgICAgdmFyIGNlbnRlckogPSBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaik7XHJcbiAgICAgICAgdmFyIGNlbnRlckkgPSB0aGlzLmNyb3NzQ2hlY2tWZXJ0aWNhbChpLCAvKihpbnQpICovIGNlbnRlckosIDIgKiBzdGF0ZUNvdW50WzFdLCBzdGF0ZUNvdW50VG90YWwpO1xyXG4gICAgICAgIGlmICghaXNOYU4oY2VudGVySSkpIHtcclxuICAgICAgICAgICAgdmFyIGVzdGltYXRlZE1vZHVsZVNpemUgPSAoc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdKSAvIDMuMDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5wb3NzaWJsZUNlbnRlcnMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IF9jLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGFib3V0IHRoZSBzYW1lIGNlbnRlciBhbmQgbW9kdWxlIHNpemU6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlci5hYm91dEVxdWFscyhlc3RpbWF0ZWRNb2R1bGVTaXplLCBjZW50ZXJJLCBjZW50ZXJKKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2VudGVyLmNvbWJpbmVFc3RpbWF0ZShjZW50ZXJJLCBjZW50ZXJKLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBIYWRuJ3QgZm91bmQgdGhpcyBiZWZvcmU7IHNhdmUgaXRcclxuICAgICAgICAgICAgdmFyIHBvaW50ID0gbmV3IEFsaWdubWVudFBhdHRlcm5fMS5kZWZhdWx0KGNlbnRlckosIGNlbnRlckksIGVzdGltYXRlZE1vZHVsZVNpemUpO1xyXG4gICAgICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycy5wdXNoKHBvaW50KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayAhPT0gbnVsbCAmJiB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrLmZvdW5kUG9zc2libGVSZXN1bHRQb2ludChwb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFsaWdubWVudFBhdHRlcm5GaW5kZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFsaWdubWVudFBhdHRlcm5GaW5kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFsaWdubWVudFBhdHRlcm5GaW5kZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA3IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZXRlY3RvciB7Ki9cclxudmFyIERlY29kZUhpbnRUeXBlXzEgPSByZXF1aXJlKFwiLi4vLi4vRGVjb2RlSGludFR5cGVcIik7XHJcbnZhciBSZXN1bHRQb2ludF8xID0gcmVxdWlyZShcIi4uLy4uL1Jlc3VsdFBvaW50XCIpO1xyXG52YXIgRGV0ZWN0b3JSZXN1bHRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vRGV0ZWN0b3JSZXN1bHRcIik7XHJcbnZhciBHcmlkU2FtcGxlckluc3RhbmNlXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0dyaWRTYW1wbGVySW5zdGFuY2VcIik7XHJcbnZhciBQZXJzcGVjdGl2ZVRyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9QZXJzcGVjdGl2ZVRyYW5zZm9ybVwiKTtcclxudmFyIE1hdGhVdGlsc18xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9kZXRlY3Rvci9NYXRoVXRpbHNcIik7XHJcbnZhciBWZXJzaW9uXzEgPSByZXF1aXJlKFwiLi4vZGVjb2Rlci9WZXJzaW9uXCIpO1xyXG52YXIgRmluZGVyUGF0dGVybkZpbmRlcl8xID0gcmVxdWlyZShcIi4vRmluZGVyUGF0dGVybkZpbmRlclwiKTtcclxudmFyIEFsaWdubWVudFBhdHRlcm5GaW5kZXJfMSA9IHJlcXVpcmUoXCIuL0FsaWdubWVudFBhdHRlcm5GaW5kZXJcIik7XHJcbnZhciBOb3RGb3VuZEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uLy4uL05vdEZvdW5kRXhjZXB0aW9uXCIpO1xyXG4vKmltcG9ydCBqYXZhLnV0aWwuTWFwOyovXHJcbi8qKlxyXG4gKiA8cD5FbmNhcHN1bGF0ZXMgbG9naWMgdGhhdCBjYW4gZGV0ZWN0IGEgUVIgQ29kZSBpbiBhbiBpbWFnZSwgZXZlbiBpZiB0aGUgUVIgQ29kZVxyXG4gKiBpcyByb3RhdGVkIG9yIHNrZXdlZCwgb3IgcGFydGlhbGx5IG9ic2N1cmVkLjwvcD5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICovXHJcbnZhciBEZXRlY3RvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIERldGVjdG9yKGltYWdlKSB7XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xyXG4gICAgfVxyXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmdldEltYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlO1xyXG4gICAgfTtcclxuICAgIERldGVjdG9yLnByb3RvdHlwZS5nZXRSZXN1bHRQb2ludENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2s7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5EZXRlY3RzIGEgUVIgQ29kZSBpbiBhbiBpbWFnZS48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7QGxpbmsgRGV0ZWN0b3JSZXN1bHR9IGVuY2Fwc3VsYXRpbmcgcmVzdWx0cyBvZiBkZXRlY3RpbmcgYSBRUiBDb2RlXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIFFSIENvZGUgY2Fubm90IGJlIGZvdW5kXHJcbiAgICAgKiBAdGhyb3dzIEZvcm1hdEV4Y2VwdGlvbiBpZiBhIFFSIENvZGUgY2Fubm90IGJlIGRlY29kZWRcclxuICAgICAqL1xyXG4gICAgLy8gcHVibGljIGRldGVjdCgpOiBEZXRlY3RvclJlc3VsdCAvKnRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiwgRm9ybWF0RXhjZXB0aW9uKi8ge1xyXG4gICAgLy8gICByZXR1cm4gZGV0ZWN0KG51bGwpXHJcbiAgICAvLyB9XHJcbiAgICAvKipcclxuICAgICAqIDxwPkRldGVjdHMgYSBRUiBDb2RlIGluIGFuIGltYWdlLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gaGludHMgb3B0aW9uYWwgaGludHMgdG8gZGV0ZWN0b3JcclxuICAgICAqIEByZXR1cm4ge0BsaW5rIERldGVjdG9yUmVzdWx0fSBlbmNhcHN1bGF0aW5nIHJlc3VsdHMgb2YgZGV0ZWN0aW5nIGEgUVIgQ29kZVxyXG4gICAgICogQHRocm93cyBOb3RGb3VuZEV4Y2VwdGlvbiBpZiBRUiBDb2RlIGNhbm5vdCBiZSBmb3VuZFxyXG4gICAgICogQHRocm93cyBGb3JtYXRFeGNlcHRpb24gaWYgYSBRUiBDb2RlIGNhbm5vdCBiZSBkZWNvZGVkXHJcbiAgICAgKi9cclxuICAgIERldGVjdG9yLnByb3RvdHlwZS5kZXRlY3QgPSBmdW5jdGlvbiAoaGludHMpIHtcclxuICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSAoaGludHMgPT09IG51bGwgfHwgaGludHMgPT09IHVuZGVmaW5lZCkgPyBudWxsIDpcclxuICAgICAgICAgICAgLyooUmVzdWx0UG9pbnRDYWxsYmFjaykgKi8gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5ORUVEX1JFU1VMVF9QT0lOVF9DQUxMQkFDSyk7XHJcbiAgICAgICAgdmFyIGZpbmRlciA9IG5ldyBGaW5kZXJQYXR0ZXJuRmluZGVyXzEuZGVmYXVsdCh0aGlzLmltYWdlLCB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2spO1xyXG4gICAgICAgIHZhciBpbmZvID0gZmluZGVyLmZpbmQoaGludHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NGaW5kZXJQYXR0ZXJuSW5mbyhpbmZvKTtcclxuICAgIH07XHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUucHJvY2Vzc0ZpbmRlclBhdHRlcm5JbmZvID0gZnVuY3Rpb24gKGluZm8pIHtcclxuICAgICAgICB2YXIgdG9wTGVmdCA9IGluZm8uZ2V0VG9wTGVmdCgpO1xyXG4gICAgICAgIHZhciB0b3BSaWdodCA9IGluZm8uZ2V0VG9wUmlnaHQoKTtcclxuICAgICAgICB2YXIgYm90dG9tTGVmdCA9IGluZm8uZ2V0Qm90dG9tTGVmdCgpO1xyXG4gICAgICAgIHZhciBtb2R1bGVTaXplID0gdGhpcy5jYWxjdWxhdGVNb2R1bGVTaXplKHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0KTtcclxuICAgICAgICBpZiAobW9kdWxlU2l6ZSA8IDEuMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCdObyBwYXR0ZXJuIGZvdW5kIGluIHByb2NjZXNzIGZpbmRlci4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRpbWVuc2lvbiA9IERldGVjdG9yLmNvbXB1dGVEaW1lbnNpb24odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIG1vZHVsZVNpemUpO1xyXG4gICAgICAgIHZhciBwcm92aXNpb25hbFZlcnNpb24gPSBWZXJzaW9uXzEuZGVmYXVsdC5nZXRQcm92aXNpb25hbFZlcnNpb25Gb3JEaW1lbnNpb24oZGltZW5zaW9uKTtcclxuICAgICAgICB2YXIgbW9kdWxlc0JldHdlZW5GUENlbnRlcnMgPSBwcm92aXNpb25hbFZlcnNpb24uZ2V0RGltZW5zaW9uRm9yVmVyc2lvbigpIC0gNztcclxuICAgICAgICB2YXIgYWxpZ25tZW50UGF0dGVybiA9IG51bGw7XHJcbiAgICAgICAgLy8gQW55dGhpbmcgYWJvdmUgdmVyc2lvbiAxIGhhcyBhbiBhbGlnbm1lbnQgcGF0dGVyblxyXG4gICAgICAgIGlmIChwcm92aXNpb25hbFZlcnNpb24uZ2V0QWxpZ25tZW50UGF0dGVybkNlbnRlcnMoKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIEd1ZXNzIHdoZXJlIGEgXCJib3R0b20gcmlnaHRcIiBmaW5kZXIgcGF0dGVybiB3b3VsZCBoYXZlIGJlZW5cclxuICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0WCA9IHRvcFJpZ2h0LmdldFgoKSAtIHRvcExlZnQuZ2V0WCgpICsgYm90dG9tTGVmdC5nZXRYKCk7XHJcbiAgICAgICAgICAgIHZhciBib3R0b21SaWdodFkgPSB0b3BSaWdodC5nZXRZKCkgLSB0b3BMZWZ0LmdldFkoKSArIGJvdHRvbUxlZnQuZ2V0WSgpO1xyXG4gICAgICAgICAgICAvLyBFc3RpbWF0ZSB0aGF0IGFsaWdubWVudCBwYXR0ZXJuIGlzIGNsb3NlciBieSAzIG1vZHVsZXNcclxuICAgICAgICAgICAgLy8gZnJvbSBcImJvdHRvbSByaWdodFwiIHRvIGtub3duIHRvcCBsZWZ0IGxvY2F0aW9uXHJcbiAgICAgICAgICAgIHZhciBjb3JyZWN0aW9uVG9Ub3BMZWZ0ID0gMS4wIC0gMy4wIC8gbW9kdWxlc0JldHdlZW5GUENlbnRlcnM7XHJcbiAgICAgICAgICAgIHZhciBlc3RBbGlnbm1lbnRYID0gLyooaW50KSAqLyBNYXRoLmZsb29yKHRvcExlZnQuZ2V0WCgpICsgY29ycmVjdGlvblRvVG9wTGVmdCAqIChib3R0b21SaWdodFggLSB0b3BMZWZ0LmdldFgoKSkpO1xyXG4gICAgICAgICAgICB2YXIgZXN0QWxpZ25tZW50WSA9IC8qKGludCkgKi8gTWF0aC5mbG9vcih0b3BMZWZ0LmdldFkoKSArIGNvcnJlY3Rpb25Ub1RvcExlZnQgKiAoYm90dG9tUmlnaHRZIC0gdG9wTGVmdC5nZXRZKCkpKTtcclxuICAgICAgICAgICAgLy8gS2luZCBvZiBhcmJpdHJhcnkgLS0gZXhwYW5kIHNlYXJjaCByYWRpdXMgYmVmb3JlIGdpdmluZyB1cFxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gNDsgaSA8PSAxNjsgaSA8PD0gMSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRQYXR0ZXJuID0gdGhpcy5maW5kQWxpZ25tZW50SW5SZWdpb24obW9kdWxlU2l6ZSwgZXN0QWxpZ25tZW50WCwgZXN0QWxpZ25tZW50WSwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAocmUgLypOb3RGb3VuZEV4Y2VwdGlvbiovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocmUgaW5zdGFuY2VvZiBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHJlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgbmV4dCByb3VuZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFsaWdubWVudCBwYXR0ZXJuLi4uIHdlbGwgdHJ5IGFueXdheSB3aXRob3V0IGl0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0cmFuc2Zvcm0gPSBEZXRlY3Rvci5jcmVhdGVUcmFuc2Zvcm0odG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGFsaWdubWVudFBhdHRlcm4sIGRpbWVuc2lvbik7XHJcbiAgICAgICAgdmFyIGJpdHMgPSBEZXRlY3Rvci5zYW1wbGVHcmlkKHRoaXMuaW1hZ2UsIHRyYW5zZm9ybSwgZGltZW5zaW9uKTtcclxuICAgICAgICB2YXIgcG9pbnRzO1xyXG4gICAgICAgIGlmIChhbGlnbm1lbnRQYXR0ZXJuID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IFtib3R0b21MZWZ0LCB0b3BMZWZ0LCB0b3BSaWdodF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwb2ludHMgPSBbYm90dG9tTGVmdCwgdG9wTGVmdCwgdG9wUmlnaHQsIGFsaWdubWVudFBhdHRlcm5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IERldGVjdG9yUmVzdWx0XzEuZGVmYXVsdChiaXRzLCBwb2ludHMpO1xyXG4gICAgfTtcclxuICAgIERldGVjdG9yLmNyZWF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYWxpZ25tZW50UGF0dGVybiwgZGltZW5zaW9uIC8qaW50Ki8pIHtcclxuICAgICAgICB2YXIgZGltTWludXNUaHJlZSA9IGRpbWVuc2lvbiAtIDMuNTtcclxuICAgICAgICB2YXIgYm90dG9tUmlnaHRYOyAvKmZsb2F0Ki9cclxuICAgICAgICB2YXIgYm90dG9tUmlnaHRZOyAvKmZsb2F0Ki9cclxuICAgICAgICB2YXIgc291cmNlQm90dG9tUmlnaHRYOyAvKmZsb2F0Ki9cclxuICAgICAgICB2YXIgc291cmNlQm90dG9tUmlnaHRZOyAvKmZsb2F0Ki9cclxuICAgICAgICBpZiAoYWxpZ25tZW50UGF0dGVybiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBib3R0b21SaWdodFggPSBhbGlnbm1lbnRQYXR0ZXJuLmdldFgoKTtcclxuICAgICAgICAgICAgYm90dG9tUmlnaHRZID0gYWxpZ25tZW50UGF0dGVybi5nZXRZKCk7XHJcbiAgICAgICAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WCA9IGRpbU1pbnVzVGhyZWUgLSAzLjA7XHJcbiAgICAgICAgICAgIHNvdXJjZUJvdHRvbVJpZ2h0WSA9IHNvdXJjZUJvdHRvbVJpZ2h0WDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IGhhdmUgYW4gYWxpZ25tZW50IHBhdHRlcm4sIGp1c3QgbWFrZSB1cCB0aGUgYm90dG9tLXJpZ2h0IHBvaW50XHJcbiAgICAgICAgICAgIGJvdHRvbVJpZ2h0WCA9ICh0b3BSaWdodC5nZXRYKCkgLSB0b3BMZWZ0LmdldFgoKSkgKyBib3R0b21MZWZ0LmdldFgoKTtcclxuICAgICAgICAgICAgYm90dG9tUmlnaHRZID0gKHRvcFJpZ2h0LmdldFkoKSAtIHRvcExlZnQuZ2V0WSgpKSArIGJvdHRvbUxlZnQuZ2V0WSgpO1xyXG4gICAgICAgICAgICBzb3VyY2VCb3R0b21SaWdodFggPSBkaW1NaW51c1RocmVlO1xyXG4gICAgICAgICAgICBzb3VyY2VCb3R0b21SaWdodFkgPSBkaW1NaW51c1RocmVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGVyc3BlY3RpdmVUcmFuc2Zvcm1fMS5kZWZhdWx0LnF1YWRyaWxhdGVyYWxUb1F1YWRyaWxhdGVyYWwoMy41LCAzLjUsIGRpbU1pbnVzVGhyZWUsIDMuNSwgc291cmNlQm90dG9tUmlnaHRYLCBzb3VyY2VCb3R0b21SaWdodFksIDMuNSwgZGltTWludXNUaHJlZSwgdG9wTGVmdC5nZXRYKCksIHRvcExlZnQuZ2V0WSgpLCB0b3BSaWdodC5nZXRYKCksIHRvcFJpZ2h0LmdldFkoKSwgYm90dG9tUmlnaHRYLCBib3R0b21SaWdodFksIGJvdHRvbUxlZnQuZ2V0WCgpLCBib3R0b21MZWZ0LmdldFkoKSk7XHJcbiAgICB9O1xyXG4gICAgRGV0ZWN0b3Iuc2FtcGxlR3JpZCA9IGZ1bmN0aW9uIChpbWFnZSwgdHJhbnNmb3JtLCBkaW1lbnNpb24gLyppbnQqLykge1xyXG4gICAgICAgIHZhciBzYW1wbGVyID0gR3JpZFNhbXBsZXJJbnN0YW5jZV8xLmRlZmF1bHQuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICByZXR1cm4gc2FtcGxlci5zYW1wbGVHcmlkV2l0aFRyYW5zZm9ybShpbWFnZSwgZGltZW5zaW9uLCBkaW1lbnNpb24sIHRyYW5zZm9ybSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5Db21wdXRlcyB0aGUgZGltZW5zaW9uIChudW1iZXIgb2YgbW9kdWxlcyBvbiBhIHNpemUpIG9mIHRoZSBRUiBDb2RlIGJhc2VkIG9uIHRoZSBwb3NpdGlvblxyXG4gICAgICogb2YgdGhlIGZpbmRlciBwYXR0ZXJucyBhbmQgZXN0aW1hdGVkIG1vZHVsZSBzaXplLjwvcD5cclxuICAgICAqL1xyXG4gICAgRGV0ZWN0b3IuY29tcHV0ZURpbWVuc2lvbiA9IGZ1bmN0aW9uICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgbW9kdWxlU2l6ZSAvKmZsb2F0Ki8pIHtcclxuICAgICAgICB2YXIgdGx0ckNlbnRlcnNEaW1lbnNpb24gPSBNYXRoVXRpbHNfMS5kZWZhdWx0LnJvdW5kKFJlc3VsdFBvaW50XzEuZGVmYXVsdC5kaXN0YW5jZSh0b3BMZWZ0LCB0b3BSaWdodCkgLyBtb2R1bGVTaXplKTtcclxuICAgICAgICB2YXIgdGxibENlbnRlcnNEaW1lbnNpb24gPSBNYXRoVXRpbHNfMS5kZWZhdWx0LnJvdW5kKFJlc3VsdFBvaW50XzEuZGVmYXVsdC5kaXN0YW5jZSh0b3BMZWZ0LCBib3R0b21MZWZ0KSAvIG1vZHVsZVNpemUpO1xyXG4gICAgICAgIHZhciBkaW1lbnNpb24gPSBNYXRoLmZsb29yKCh0bHRyQ2VudGVyc0RpbWVuc2lvbiArIHRsYmxDZW50ZXJzRGltZW5zaW9uKSAvIDIpICsgNztcclxuICAgICAgICBzd2l0Y2ggKGRpbWVuc2lvbiAmIDB4MDMpIHsgLy8gbW9kIDRcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgZGltZW5zaW9uKys7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLy8gMT8gZG8gbm90aGluZ1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBkaW1lbnNpb24tLTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCdEaW1lbnNpb25zIGNvdWxkIGJlIG5vdCBmb3VuZC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpbWVuc2lvbjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPkNvbXB1dGVzIGFuIGF2ZXJhZ2UgZXN0aW1hdGVkIG1vZHVsZSBzaXplIGJhc2VkIG9uIGVzdGltYXRlZCBkZXJpdmVkIGZyb20gdGhlIHBvc2l0aW9uc1xyXG4gICAgICogb2YgdGhlIHRocmVlIGZpbmRlciBwYXR0ZXJucy48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRvcExlZnQgZGV0ZWN0ZWQgdG9wLWxlZnQgZmluZGVyIHBhdHRlcm4gY2VudGVyXHJcbiAgICAgKiBAcGFyYW0gdG9wUmlnaHQgZGV0ZWN0ZWQgdG9wLXJpZ2h0IGZpbmRlciBwYXR0ZXJuIGNlbnRlclxyXG4gICAgICogQHBhcmFtIGJvdHRvbUxlZnQgZGV0ZWN0ZWQgYm90dG9tLWxlZnQgZmluZGVyIHBhdHRlcm4gY2VudGVyXHJcbiAgICAgKiBAcmV0dXJuIGVzdGltYXRlZCBtb2R1bGUgc2l6ZVxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuY2FsY3VsYXRlTW9kdWxlU2l6ZSA9IGZ1bmN0aW9uICh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCkge1xyXG4gICAgICAgIC8vIFRha2UgdGhlIGF2ZXJhZ2VcclxuICAgICAgICByZXR1cm4gKHRoaXMuY2FsY3VsYXRlTW9kdWxlU2l6ZU9uZVdheSh0b3BMZWZ0LCB0b3BSaWdodCkgK1xyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkodG9wTGVmdCwgYm90dG9tTGVmdCkpIC8gMi4wO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogPHA+RXN0aW1hdGVzIG1vZHVsZSBzaXplIGJhc2VkIG9uIHR3byBmaW5kZXIgcGF0dGVybnMgLS0gaXQgdXNlc1xyXG4gICAgICoge0BsaW5rICNzaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cyhpbnQsIGludCwgaW50LCBpbnQpfSB0byBmaWd1cmUgdGhlXHJcbiAgICAgKiB3aWR0aCBvZiBlYWNoLCBtZWFzdXJpbmcgYWxvbmcgdGhlIGF4aXMgYmV0d2VlbiB0aGVpciBjZW50ZXJzLjwvcD5cclxuICAgICAqL1xyXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmNhbGN1bGF0ZU1vZHVsZVNpemVPbmVXYXkgPSBmdW5jdGlvbiAocGF0dGVybiwgb3RoZXJQYXR0ZXJuKSB7XHJcbiAgICAgICAgdmFyIG1vZHVsZVNpemVFc3QxID0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cygvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRYKCkpLCBcclxuICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3IocGF0dGVybi5nZXRZKCkpLCBcclxuICAgICAgICAvKihpbnQpICovIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLmdldFgoKSksIFxyXG4gICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihvdGhlclBhdHRlcm4uZ2V0WSgpKSk7XHJcbiAgICAgICAgdmFyIG1vZHVsZVNpemVFc3QyID0gdGhpcy5zaXplT2ZCbGFja1doaXRlQmxhY2tSdW5Cb3RoV2F5cygvKihpbnQpICovIE1hdGguZmxvb3Iob3RoZXJQYXR0ZXJuLmdldFgoKSksIFxyXG4gICAgICAgIC8qKGludCkgKi8gTWF0aC5mbG9vcihvdGhlclBhdHRlcm4uZ2V0WSgpKSwgXHJcbiAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKHBhdHRlcm4uZ2V0WCgpKSwgXHJcbiAgICAgICAgLyooaW50KSAqLyBNYXRoLmZsb29yKHBhdHRlcm4uZ2V0WSgpKSk7XHJcbiAgICAgICAgaWYgKGlzTmFOKG1vZHVsZVNpemVFc3QxKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9kdWxlU2l6ZUVzdDIgLyA3LjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05hTihtb2R1bGVTaXplRXN0MikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVNpemVFc3QxIC8gNy4wO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBdmVyYWdlIHRoZW0sIGFuZCBkaXZpZGUgYnkgNyBzaW5jZSB3ZSd2ZSBjb3VudGVkIHRoZSB3aWR0aCBvZiAzIGJsYWNrIG1vZHVsZXMsXHJcbiAgICAgICAgLy8gYW5kIDEgd2hpdGUgYW5kIDEgYmxhY2sgbW9kdWxlIG9uIGVpdGhlciBzaWRlLiBFcmdvLCBkaXZpZGUgc3VtIGJ5IDE0LlxyXG4gICAgICAgIHJldHVybiAobW9kdWxlU2l6ZUVzdDEgKyBtb2R1bGVTaXplRXN0MikgLyAxNC4wO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2VlIHtAbGluayAjc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGludCwgaW50LCBpbnQsIGludCl9OyBjb21wdXRlcyB0aGUgdG90YWwgd2lkdGggb2ZcclxuICAgICAqIGEgZmluZGVyIHBhdHRlcm4gYnkgbG9va2luZyBmb3IgYSBibGFjay13aGl0ZS1ibGFjayBydW4gZnJvbSB0aGUgY2VudGVyIGluIHRoZSBkaXJlY3Rpb25cclxuICAgICAqIG9mIGFub3RoZXIgcG9pbnQgKGFub3RoZXIgZmluZGVyIHBhdHRlcm4gY2VudGVyKSwgYW5kIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gdG9vLlxyXG4gICAgICovXHJcbiAgICBEZXRlY3Rvci5wcm90b3R5cGUuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuQm90aFdheXMgPSBmdW5jdGlvbiAoZnJvbVggLyppbnQqLywgZnJvbVkgLyppbnQqLywgdG9YIC8qaW50Ki8sIHRvWSAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc2l6ZU9mQmxhY2tXaGl0ZUJsYWNrUnVuKGZyb21YLCBmcm9tWSwgdG9YLCB0b1kpO1xyXG4gICAgICAgIC8vIE5vdyBjb3VudCBvdGhlciB3YXkgLS0gZG9uJ3QgcnVuIG9mZiBpbWFnZSB0aG91Z2ggb2YgY291cnNlXHJcbiAgICAgICAgdmFyIHNjYWxlID0gMS4wO1xyXG4gICAgICAgIHZhciBvdGhlclRvWCA9IGZyb21YIC0gKHRvWCAtIGZyb21YKTtcclxuICAgICAgICBpZiAob3RoZXJUb1ggPCAwKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gZnJvbVggLyAvKihmbG9hdCkgKi8gKGZyb21YIC0gb3RoZXJUb1gpO1xyXG4gICAgICAgICAgICBvdGhlclRvWCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG90aGVyVG9YID49IHRoaXMuaW1hZ2UuZ2V0V2lkdGgoKSkge1xyXG4gICAgICAgICAgICBzY2FsZSA9ICh0aGlzLmltYWdlLmdldFdpZHRoKCkgLSAxIC0gZnJvbVgpIC8gLyooZmxvYXQpICovIChvdGhlclRvWCAtIGZyb21YKTtcclxuICAgICAgICAgICAgb3RoZXJUb1ggPSB0aGlzLmltYWdlLmdldFdpZHRoKCkgLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3RoZXJUb1kgPSAvKihpbnQpICovIE1hdGguZmxvb3IoZnJvbVkgLSAodG9ZIC0gZnJvbVkpICogc2NhbGUpO1xyXG4gICAgICAgIHNjYWxlID0gMS4wO1xyXG4gICAgICAgIGlmIChvdGhlclRvWSA8IDApIHtcclxuICAgICAgICAgICAgc2NhbGUgPSBmcm9tWSAvIC8qKGZsb2F0KSAqLyAoZnJvbVkgLSBvdGhlclRvWSk7XHJcbiAgICAgICAgICAgIG90aGVyVG9ZID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3RoZXJUb1kgPj0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSkge1xyXG4gICAgICAgICAgICBzY2FsZSA9ICh0aGlzLmltYWdlLmdldEhlaWdodCgpIC0gMSAtIGZyb21ZKSAvIC8qKGZsb2F0KSAqLyAob3RoZXJUb1kgLSBmcm9tWSk7XHJcbiAgICAgICAgICAgIG90aGVyVG9ZID0gdGhpcy5pbWFnZS5nZXRIZWlnaHQoKSAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG90aGVyVG9YID0gLyooaW50KSAqLyBNYXRoLmZsb29yKGZyb21YICsgKG90aGVyVG9YIC0gZnJvbVgpICogc2NhbGUpO1xyXG4gICAgICAgIHJlc3VsdCArPSB0aGlzLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1bihmcm9tWCwgZnJvbVksIG90aGVyVG9YLCBvdGhlclRvWSk7XHJcbiAgICAgICAgLy8gTWlkZGxlIHBpeGVsIGlzIGRvdWJsZS1jb3VudGVkIHRoaXMgd2F5OyBzdWJ0cmFjdCAxXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAtIDEuMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPlRoaXMgbWV0aG9kIHRyYWNlcyBhIGxpbmUgZnJvbSBhIHBvaW50IGluIHRoZSBpbWFnZSwgaW4gdGhlIGRpcmVjdGlvbiB0b3dhcmRzIGFub3RoZXIgcG9pbnQuXHJcbiAgICAgKiBJdCBiZWdpbnMgaW4gYSBibGFjayByZWdpb24sIGFuZCBrZWVwcyBnb2luZyB1bnRpbCBpdCBmaW5kcyB3aGl0ZSwgdGhlbiBibGFjaywgdGhlbiB3aGl0ZSBhZ2Fpbi5cclxuICAgICAqIEl0IHJlcG9ydHMgdGhlIGRpc3RhbmNlIGZyb20gdGhlIHN0YXJ0IHRvIHRoaXMgcG9pbnQuPC9wPlxyXG4gICAgICpcclxuICAgICAqIDxwPlRoaXMgaXMgdXNlZCB3aGVuIGZpZ3VyaW5nIG91dCBob3cgd2lkZSBhIGZpbmRlciBwYXR0ZXJuIGlzLCB3aGVuIHRoZSBmaW5kZXIgcGF0dGVyblxyXG4gICAgICogbWF5IGJlIHNrZXdlZCBvciByb3RhdGVkLjwvcD5cclxuICAgICAqL1xyXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLnNpemVPZkJsYWNrV2hpdGVCbGFja1J1biA9IGZ1bmN0aW9uIChmcm9tWCAvKmludCovLCBmcm9tWSAvKmludCovLCB0b1ggLyppbnQqLywgdG9ZIC8qaW50Ki8pIHtcclxuICAgICAgICAvLyBNaWxkIHZhcmlhbnQgb2YgQnJlc2VuaGFtJ3MgYWxnb3JpdGhtXHJcbiAgICAgICAgLy8gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlc2VuaGFtJ3NfbGluZV9hbGdvcml0aG1cclxuICAgICAgICB2YXIgc3RlZXAgPSBNYXRoLmFicyh0b1kgLSBmcm9tWSkgPiBNYXRoLmFicyh0b1ggLSBmcm9tWCk7XHJcbiAgICAgICAgaWYgKHN0ZWVwKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZW1wID0gZnJvbVg7XHJcbiAgICAgICAgICAgIGZyb21YID0gZnJvbVk7XHJcbiAgICAgICAgICAgIGZyb21ZID0gdGVtcDtcclxuICAgICAgICAgICAgdGVtcCA9IHRvWDtcclxuICAgICAgICAgICAgdG9YID0gdG9ZO1xyXG4gICAgICAgICAgICB0b1kgPSB0ZW1wO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh0b1ggLSBmcm9tWCk7XHJcbiAgICAgICAgdmFyIGR5ID0gTWF0aC5hYnModG9ZIC0gZnJvbVkpO1xyXG4gICAgICAgIHZhciBlcnJvciA9IC1keCAvIDI7XHJcbiAgICAgICAgdmFyIHhzdGVwID0gZnJvbVggPCB0b1ggPyAxIDogLTE7XHJcbiAgICAgICAgdmFyIHlzdGVwID0gZnJvbVkgPCB0b1kgPyAxIDogLTE7XHJcbiAgICAgICAgLy8gSW4gYmxhY2sgcGl4ZWxzLCBsb29raW5nIGZvciB3aGl0ZSwgZmlyc3Qgb3Igc2Vjb25kIHRpbWUuXHJcbiAgICAgICAgdmFyIHN0YXRlID0gMDtcclxuICAgICAgICAvLyBMb29wIHVwIHVudGlsIHggPT0gdG9YLCBidXQgbm90IGJleW9uZFxyXG4gICAgICAgIHZhciB4TGltaXQgPSB0b1ggKyB4c3RlcDtcclxuICAgICAgICBmb3IgKHZhciB4ID0gZnJvbVgsIHkgPSBmcm9tWTsgeCAhPT0geExpbWl0OyB4ICs9IHhzdGVwKSB7XHJcbiAgICAgICAgICAgIHZhciByZWFsWCA9IHN0ZWVwID8geSA6IHg7XHJcbiAgICAgICAgICAgIHZhciByZWFsWSA9IHN0ZWVwID8geCA6IHk7XHJcbiAgICAgICAgICAgIC8vIERvZXMgY3VycmVudCBwaXhlbCBtZWFuIHdlIGhhdmUgbW92ZWQgd2hpdGUgdG8gYmxhY2sgb3IgdmljZSB2ZXJzYT9cclxuICAgICAgICAgICAgLy8gU2Nhbm5pbmcgYmxhY2sgaW4gc3RhdGUgMCwyIGFuZCB3aGl0ZSBpbiBzdGF0ZSAxLCBzbyBpZiB3ZSBmaW5kIHRoZSB3cm9uZ1xyXG4gICAgICAgICAgICAvLyBjb2xvciwgYWR2YW5jZSB0byBuZXh0IHN0YXRlIG9yIGVuZCBpZiB3ZSBhcmUgaW4gc3RhdGUgMiBhbHJlYWR5XHJcbiAgICAgICAgICAgIGlmICgoc3RhdGUgPT09IDEpID09PSB0aGlzLmltYWdlLmdldChyZWFsWCwgcmVhbFkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aFV0aWxzXzEuZGVmYXVsdC5kaXN0YW5jZSh4LCB5LCBmcm9tWCwgZnJvbVkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc3RhdGUrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlcnJvciArPSBkeTtcclxuICAgICAgICAgICAgaWYgKGVycm9yID4gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHkgPT09IHRvWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgeSArPSB5c3RlcDtcclxuICAgICAgICAgICAgICAgIGVycm9yIC09IGR4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZvdW5kIGJsYWNrLXdoaXRlLWJsYWNrOyBnaXZlIHRoZSBiZW5lZml0IG9mIHRoZSBkb3VidCB0aGF0IHRoZSBuZXh0IHBpeGVsIG91dHNpZGUgdGhlIGltYWdlXHJcbiAgICAgICAgLy8gaXMgXCJ3aGl0ZVwiIHNvIHRoaXMgbGFzdCBwb2ludCBhdCAodG9YK3hTdGVwLHRvWSkgaXMgdGhlIHJpZ2h0IGVuZGluZy4gVGhpcyBpcyByZWFsbHkgYVxyXG4gICAgICAgIC8vIHNtYWxsIGFwcHJveGltYXRpb247ICh0b1greFN0ZXAsdG9ZK3lTdGVwKSBtaWdodCBiZSByZWFsbHkgY29ycmVjdC4gSWdub3JlIHRoaXMuXHJcbiAgICAgICAgaWYgKHN0YXRlID09PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoVXRpbHNfMS5kZWZhdWx0LmRpc3RhbmNlKHRvWCArIHhzdGVwLCB0b1ksIGZyb21YLCBmcm9tWSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVsc2Ugd2UgZGlkbid0IGZpbmQgZXZlbiBibGFjay13aGl0ZS1ibGFjazsgbm8gZXN0aW1hdGUgaXMgcmVhbGx5IHBvc3NpYmxlXHJcbiAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPkF0dGVtcHRzIHRvIGxvY2F0ZSBhbiBhbGlnbm1lbnQgcGF0dGVybiBpbiBhIGxpbWl0ZWQgcmVnaW9uIG9mIHRoZSBpbWFnZSwgd2hpY2ggaXNcclxuICAgICAqIGd1ZXNzZWQgdG8gY29udGFpbiBpdC4gVGhpcyBtZXRob2QgdXNlcyB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0uPC9wPlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvdmVyYWxsRXN0TW9kdWxlU2l6ZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemUgc28gZmFyXHJcbiAgICAgKiBAcGFyYW0gZXN0QWxpZ25tZW50WCB4IGNvb3JkaW5hdGUgb2YgY2VudGVyIG9mIGFyZWEgcHJvYmFibHkgY29udGFpbmluZyBhbGlnbm1lbnQgcGF0dGVyblxyXG4gICAgICogQHBhcmFtIGVzdEFsaWdubWVudFkgeSBjb29yZGluYXRlIG9mIGFib3ZlXHJcbiAgICAgKiBAcGFyYW0gYWxsb3dhbmNlRmFjdG9yIG51bWJlciBvZiBwaXhlbHMgaW4gYWxsIGRpcmVjdGlvbnMgdG8gc2VhcmNoIGZyb20gdGhlIGNlbnRlclxyXG4gICAgICogQHJldHVybiB7QGxpbmsgQWxpZ25tZW50UGF0dGVybn0gaWYgZm91bmQsIG9yIG51bGwgb3RoZXJ3aXNlXHJcbiAgICAgKiBAdGhyb3dzIE5vdEZvdW5kRXhjZXB0aW9uIGlmIGFuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJzIGR1cmluZyBkZXRlY3Rpb25cclxuICAgICAqL1xyXG4gICAgRGV0ZWN0b3IucHJvdG90eXBlLmZpbmRBbGlnbm1lbnRJblJlZ2lvbiA9IGZ1bmN0aW9uIChvdmVyYWxsRXN0TW9kdWxlU2l6ZSAvKmZsb2F0Ki8sIGVzdEFsaWdubWVudFggLyppbnQqLywgZXN0QWxpZ25tZW50WSAvKmludCovLCBhbGxvd2FuY2VGYWN0b3IgLypmbG9hdCovKSB7XHJcbiAgICAgICAgLy8gTG9vayBmb3IgYW4gYWxpZ25tZW50IHBhdHRlcm4gKDMgbW9kdWxlcyBpbiBzaXplKSBhcm91bmQgd2hlcmUgaXRcclxuICAgICAgICAvLyBzaG91bGQgYmVcclxuICAgICAgICB2YXIgYWxsb3dhbmNlID0gLyooaW50KSAqLyBNYXRoLmZsb29yKGFsbG93YW5jZUZhY3RvciAqIG92ZXJhbGxFc3RNb2R1bGVTaXplKTtcclxuICAgICAgICB2YXIgYWxpZ25tZW50QXJlYUxlZnRYID0gTWF0aC5tYXgoMCwgZXN0QWxpZ25tZW50WCAtIGFsbG93YW5jZSk7XHJcbiAgICAgICAgdmFyIGFsaWdubWVudEFyZWFSaWdodFggPSBNYXRoLm1pbih0aGlzLmltYWdlLmdldFdpZHRoKCkgLSAxLCBlc3RBbGlnbm1lbnRYICsgYWxsb3dhbmNlKTtcclxuICAgICAgICBpZiAoYWxpZ25tZW50QXJlYVJpZ2h0WCAtIGFsaWdubWVudEFyZWFMZWZ0WCA8IG92ZXJhbGxFc3RNb2R1bGVTaXplICogMykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFeGNlcHRpb25fMS5kZWZhdWx0KCdBbGlnbm1lbnQgdG9wIGV4Y2VlZHMgZXN0aW1hdGVkIG1vZHVsZSBzaXplLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWxpZ25tZW50QXJlYVRvcFkgPSBNYXRoLm1heCgwLCBlc3RBbGlnbm1lbnRZIC0gYWxsb3dhbmNlKTtcclxuICAgICAgICB2YXIgYWxpZ25tZW50QXJlYUJvdHRvbVkgPSBNYXRoLm1pbih0aGlzLmltYWdlLmdldEhlaWdodCgpIC0gMSwgZXN0QWxpZ25tZW50WSArIGFsbG93YW5jZSk7XHJcbiAgICAgICAgaWYgKGFsaWdubWVudEFyZWFCb3R0b21ZIC0gYWxpZ25tZW50QXJlYVRvcFkgPCBvdmVyYWxsRXN0TW9kdWxlU2l6ZSAqIDMpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXhjZXB0aW9uXzEuZGVmYXVsdCgnQWxpZ25tZW50IGJvdHRvbSBleGNlZWRzIGVzdGltYXRlZCBtb2R1bGUgc2l6ZS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFsaWdubWVudEZpbmRlciA9IG5ldyBBbGlnbm1lbnRQYXR0ZXJuRmluZGVyXzEuZGVmYXVsdCh0aGlzLmltYWdlLCBhbGlnbm1lbnRBcmVhTGVmdFgsIGFsaWdubWVudEFyZWFUb3BZLCBhbGlnbm1lbnRBcmVhUmlnaHRYIC0gYWxpZ25tZW50QXJlYUxlZnRYLCBhbGlnbm1lbnRBcmVhQm90dG9tWSAtIGFsaWdubWVudEFyZWFUb3BZLCBvdmVyYWxsRXN0TW9kdWxlU2l6ZSwgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrKTtcclxuICAgICAgICByZXR1cm4gYWxpZ25tZW50RmluZGVyLmZpbmQoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGV0ZWN0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERldGVjdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZXRlY3Rvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gICAgfTtcclxufSkoKTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5kZXRlY3RvciB7Ki9cclxudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVzdWx0UG9pbnRcIik7XHJcbi8qKlxyXG4gKiA8cD5FbmNhcHN1bGF0ZXMgYSBmaW5kZXIgcGF0dGVybiwgd2hpY2ggYXJlIHRoZSB0aHJlZSBzcXVhcmUgcGF0dGVybnMgZm91bmQgaW5cclxuICogdGhlIGNvcm5lcnMgb2YgUVIgQ29kZXMuIEl0IGFsc28gZW5jYXBzdWxhdGVzIGEgY291bnQgb2Ygc2ltaWxhciBmaW5kZXIgcGF0dGVybnMsXHJcbiAqIGFzIGEgY29udmVuaWVuY2UgdG8gdGhlIGZpbmRlcidzIGJvb2trZWVwaW5nLjwvcD5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICovXHJcbnZhciBGaW5kZXJQYXR0ZXJuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEZpbmRlclBhdHRlcm4sIF9zdXBlcik7XHJcbiAgICAvLyBGaW5kZXJQYXR0ZXJuKHBvc1g6IG51bWJlci8qZmxvYXQqLywgcG9zWTogbnVtYmVyLypmbG9hdCovLCBlc3RpbWF0ZWRNb2R1bGVTaXplOiBudW1iZXIvKmZsb2F0Ki8pIHtcclxuICAgIC8vICAgdGhpcyhwb3NYLCBwb3NZLCBlc3RpbWF0ZWRNb2R1bGVTaXplLCAxKVxyXG4gICAgLy8gfVxyXG4gICAgZnVuY3Rpb24gRmluZGVyUGF0dGVybihwb3NYIC8qZmxvYXQqLywgcG9zWSAvKmZsb2F0Ki8sIGVzdGltYXRlZE1vZHVsZVNpemUgLypmbG9hdCovLCBjb3VudCAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcG9zWCwgcG9zWSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplID0gZXN0aW1hdGVkTW9kdWxlU2l6ZTtcclxuICAgICAgICBfdGhpcy5jb3VudCA9IGNvdW50O1xyXG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNvdW50KSB7XHJcbiAgICAgICAgICAgIF90aGlzLmNvdW50ID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRmluZGVyUGF0dGVybi5wcm90b3R5cGUuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplO1xyXG4gICAgfTtcclxuICAgIEZpbmRlclBhdHRlcm4ucHJvdG90eXBlLmdldENvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvdW50O1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICB2b2lkIGluY3JlbWVudENvdW50KCkge1xyXG4gICAgICB0aGlzLmNvdW50KytcclxuICAgIH1cclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5EZXRlcm1pbmVzIGlmIHRoaXMgZmluZGVyIHBhdHRlcm4gXCJhYm91dCBlcXVhbHNcIiBhIGZpbmRlciBwYXR0ZXJuIGF0IHRoZSBzdGF0ZWRcclxuICAgICAqIHBvc2l0aW9uIGFuZCBzaXplIC0tIG1lYW5pbmcsIGl0IGlzIGF0IG5lYXJseSB0aGUgc2FtZSBjZW50ZXIgd2l0aCBuZWFybHkgdGhlIHNhbWUgc2l6ZS48L3A+XHJcbiAgICAgKi9cclxuICAgIEZpbmRlclBhdHRlcm4ucHJvdG90eXBlLmFib3V0RXF1YWxzID0gZnVuY3Rpb24gKG1vZHVsZVNpemUgLypmbG9hdCovLCBpIC8qZmxvYXQqLywgaiAvKmZsb2F0Ki8pIHtcclxuICAgICAgICBpZiAoTWF0aC5hYnMoaSAtIHRoaXMuZ2V0WSgpKSA8PSBtb2R1bGVTaXplICYmIE1hdGguYWJzKGogLSB0aGlzLmdldFgoKSkgPD0gbW9kdWxlU2l6ZSkge1xyXG4gICAgICAgICAgICB2YXIgbW9kdWxlU2l6ZURpZmYgPSBNYXRoLmFicyhtb2R1bGVTaXplIC0gdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplKTtcclxuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZVNpemVEaWZmIDw9IDEuMCB8fCBtb2R1bGVTaXplRGlmZiA8PSB0aGlzLmVzdGltYXRlZE1vZHVsZVNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmVzIHRoaXMgb2JqZWN0J3MgY3VycmVudCBlc3RpbWF0ZSBvZiBhIGZpbmRlciBwYXR0ZXJuIHBvc2l0aW9uIGFuZCBtb2R1bGUgc2l6ZVxyXG4gICAgICogd2l0aCBhIG5ldyBlc3RpbWF0ZS4gSXQgcmV0dXJucyBhIG5ldyB7QGNvZGUgRmluZGVyUGF0dGVybn0gY29udGFpbmluZyBhIHdlaWdodGVkIGF2ZXJhZ2VcclxuICAgICAqIGJhc2VkIG9uIGNvdW50LlxyXG4gICAgICovXHJcbiAgICBGaW5kZXJQYXR0ZXJuLnByb3RvdHlwZS5jb21iaW5lRXN0aW1hdGUgPSBmdW5jdGlvbiAoaSAvKmZsb2F0Ki8sIGogLypmbG9hdCovLCBuZXdNb2R1bGVTaXplIC8qZmxvYXQqLykge1xyXG4gICAgICAgIHZhciBjb21iaW5lZENvdW50ID0gdGhpcy5jb3VudCArIDE7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkWCA9ICh0aGlzLmNvdW50ICogdGhpcy5nZXRYKCkgKyBqKSAvIGNvbWJpbmVkQ291bnQ7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkWSA9ICh0aGlzLmNvdW50ICogdGhpcy5nZXRZKCkgKyBpKSAvIGNvbWJpbmVkQ291bnQ7XHJcbiAgICAgICAgdmFyIGNvbWJpbmVkTW9kdWxlU2l6ZSA9ICh0aGlzLmNvdW50ICogdGhpcy5lc3RpbWF0ZWRNb2R1bGVTaXplICsgbmV3TW9kdWxlU2l6ZSkgLyBjb21iaW5lZENvdW50O1xyXG4gICAgICAgIHJldHVybiBuZXcgRmluZGVyUGF0dGVybihjb21iaW5lZFgsIGNvbWJpbmVkWSwgY29tYmluZWRNb2R1bGVTaXplLCBjb21iaW5lZENvdW50KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRmluZGVyUGF0dGVybjtcclxufShSZXN1bHRQb2ludF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRmluZGVyUGF0dGVybjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmluZGVyUGF0dGVybi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDcgWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlLmRldGVjdG9yIHsqL1xyXG52YXIgRGVjb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9EZWNvZGVIaW50VHlwZVwiKTtcclxudmFyIFJlc3VsdFBvaW50XzEgPSByZXF1aXJlKFwiLi4vLi4vUmVzdWx0UG9pbnRcIik7XHJcbnZhciBGaW5kZXJQYXR0ZXJuXzEgPSByZXF1aXJlKFwiLi9GaW5kZXJQYXR0ZXJuXCIpO1xyXG52YXIgRmluZGVyUGF0dGVybkluZm9fMSA9IHJlcXVpcmUoXCIuL0ZpbmRlclBhdHRlcm5JbmZvXCIpO1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Ob3RGb3VuZEV4Y2VwdGlvblwiKTtcclxuLyppbXBvcnQgamF2YS5pby5TZXJpYWxpemFibGU7Ki9cclxuLyppbXBvcnQgamF2YS51dGlsLkFycmF5TGlzdDsqL1xyXG4vKmltcG9ydCBqYXZhLnV0aWwuQ29sbGVjdGlvbnM7Ki9cclxuLyppbXBvcnQgamF2YS51dGlsLkNvbXBhcmF0b3I7Ki9cclxuLyppbXBvcnQgamF2YS51dGlsLkxpc3Q7Ki9cclxuLyppbXBvcnQgamF2YS51dGlsLk1hcDsqL1xyXG4vKipcclxuICogPHA+VGhpcyBjbGFzcyBhdHRlbXB0cyB0byBmaW5kIGZpbmRlciBwYXR0ZXJucyBpbiBhIFFSIENvZGUuIEZpbmRlciBwYXR0ZXJucyBhcmUgdGhlIHNxdWFyZVxyXG4gKiBtYXJrZXJzIGF0IHRocmVlIGNvcm5lcnMgb2YgYSBRUiBDb2RlLjwvcD5cclxuICpcclxuICogPHA+VGhpcyBjbGFzcyBpcyB0aHJlYWQtc2FmZSBidXQgbm90IHJlZW50cmFudC4gRWFjaCB0aHJlYWQgbXVzdCBhbGxvY2F0ZSBpdHMgb3duIG9iamVjdC5cclxuICpcclxuICogQGF1dGhvciBTZWFuIE93ZW5cclxuICovXHJcbnZhciBGaW5kZXJQYXR0ZXJuRmluZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiA8cD5DcmVhdGVzIGEgZmluZGVyIHRoYXQgd2lsbCBzZWFyY2ggdGhlIGltYWdlIGZvciB0aHJlZSBmaW5kZXIgcGF0dGVybnMuPC9wPlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbWFnZSBpbWFnZSB0byBzZWFyY2hcclxuICAgICAqL1xyXG4gICAgLy8gcHVibGljIGNvbnN0cnVjdG9yKGltYWdlOiBCaXRNYXRyaXgpIHtcclxuICAgIC8vICAgdGhpcyhpbWFnZSwgbnVsbClcclxuICAgIC8vIH1cclxuICAgIGZ1bmN0aW9uIEZpbmRlclBhdHRlcm5GaW5kZXIoaW1hZ2UsIHJlc3VsdFBvaW50Q2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgdGhpcy5yZXN1bHRQb2ludENhbGxiYWNrID0gcmVzdWx0UG9pbnRDYWxsYmFjaztcclxuICAgICAgICB0aGlzLnBvc3NpYmxlQ2VudGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnQgPSBuZXcgSW50MzJBcnJheSg1KTtcclxuICAgICAgICB0aGlzLnJlc3VsdFBvaW50Q2FsbGJhY2sgPSByZXN1bHRQb2ludENhbGxiYWNrO1xyXG4gICAgfVxyXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuZ2V0SW1hZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2U7XHJcbiAgICB9O1xyXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuZ2V0UG9zc2libGVDZW50ZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc3NpYmxlQ2VudGVycztcclxuICAgIH07XHJcbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGhpbnRzKSB7XHJcbiAgICAgICAgdmFyIHRyeUhhcmRlciA9IChoaW50cyAhPT0gbnVsbCAmJiBoaW50cyAhPT0gdW5kZWZpbmVkKSAmJiB1bmRlZmluZWQgIT09IGhpbnRzLmdldChEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQuVFJZX0hBUkRFUik7XHJcbiAgICAgICAgdmFyIHB1cmVCYXJjb2RlID0gKGhpbnRzICE9PSBudWxsICYmIGhpbnRzICE9PSB1bmRlZmluZWQpICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KERlY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5QVVJFX0JBUkNPREUpO1xyXG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XHJcbiAgICAgICAgdmFyIG1heEkgPSBpbWFnZS5nZXRIZWlnaHQoKTtcclxuICAgICAgICB2YXIgbWF4SiA9IGltYWdlLmdldFdpZHRoKCk7XHJcbiAgICAgICAgLy8gV2UgYXJlIGxvb2tpbmcgZm9yIGJsYWNrL3doaXRlL2JsYWNrL3doaXRlL2JsYWNrIG1vZHVsZXMgaW5cclxuICAgICAgICAvLyAxOjE6MzoxOjEgcmF0aW87IHRoaXMgdHJhY2tzIHRoZSBudW1iZXIgb2Ygc3VjaCBtb2R1bGVzIHNlZW4gc28gZmFyXHJcbiAgICAgICAgLy8gTGV0J3MgYXNzdW1lIHRoYXQgdGhlIG1heGltdW0gdmVyc2lvbiBRUiBDb2RlIHdlIHN1cHBvcnQgdGFrZXMgdXAgMS80IHRoZSBoZWlnaHQgb2YgdGhlXHJcbiAgICAgICAgLy8gaW1hZ2UsIGFuZCB0aGVuIGFjY291bnQgZm9yIHRoZSBjZW50ZXIgYmVpbmcgMyBtb2R1bGVzIGluIHNpemUuIFRoaXMgZ2l2ZXMgdGhlIHNtYWxsZXN0XHJcbiAgICAgICAgLy8gbnVtYmVyIG9mIHBpeGVscyB0aGUgY2VudGVyIGNvdWxkIGJlLCBzbyBza2lwIHRoaXMgb2Z0ZW4uIFdoZW4gdHJ5aW5nIGhhcmRlciwgbG9vayBmb3IgYWxsXHJcbiAgICAgICAgLy8gUVIgdmVyc2lvbnMgcmVnYXJkbGVzcyBvZiBob3cgZGVuc2UgdGhleSBhcmUuXHJcbiAgICAgICAgdmFyIGlTa2lwID0gTWF0aC5mbG9vcigoMyAqIG1heEkpIC8gKDQgKiBGaW5kZXJQYXR0ZXJuRmluZGVyLk1BWF9NT0RVTEVTKSk7XHJcbiAgICAgICAgaWYgKGlTa2lwIDwgRmluZGVyUGF0dGVybkZpbmRlci5NSU5fU0tJUCB8fCB0cnlIYXJkZXIpIHtcclxuICAgICAgICAgICAgaVNraXAgPSBGaW5kZXJQYXR0ZXJuRmluZGVyLk1JTl9TS0lQO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBzdGF0ZUNvdW50ID0gbmV3IEludDMyQXJyYXkoNSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGlTa2lwIC0gMTsgaSA8IG1heEkgJiYgIWRvbmU7IGkgKz0gaVNraXApIHtcclxuICAgICAgICAgICAgLy8gR2V0IGEgcm93IG9mIGJsYWNrL3doaXRlIHZhbHVlc1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gMDtcclxuICAgICAgICAgICAgc3RhdGVDb3VudFsxXSA9IDA7XHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwO1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMDtcclxuICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA9IDA7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1heEo7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmdldChqLCBpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEJsYWNrIHBpeGVsXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50U3RhdGUgJiAxKSA9PT0gMSkgeyAvLyBDb3VudGluZyB3aGl0ZSBwaXhlbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbY3VycmVudFN0YXRlXSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vIFdoaXRlIHBpeGVsXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChjdXJyZW50U3RhdGUgJiAxKSA9PT0gMCkgeyAvLyBDb3VudGluZyBibGFjayBwaXhlbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gNCkgeyAvLyBBIHdpbm5lcj9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpKSB7IC8vIFllc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maXJtZWQgPSB0aGlzLmhhbmRsZVBvc3NpYmxlQ2VudGVyKHN0YXRlQ291bnQsIGksIGosIHB1cmVCYXJjb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGV4YW1pbmluZyBldmVyeSBvdGhlciBsaW5lLiBDaGVja2luZyBlYWNoIGxpbmUgdHVybmVkIG91dCB0byBiZSB0b29cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwZW5zaXZlIGFuZCBkaWRuJ3QgaW1wcm92ZSBwZXJmb3JtYW5jZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVNraXAgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNTa2lwcGVkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdGhpcy5oYXZlTXVsdGlwbHlDb25maXJtZWRDZW50ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93U2tpcCA9IHRoaXMuZmluZFJvd1NraXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3dTa2lwID4gc3RhdGVDb3VudFsyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcm93cyBiZXR3ZWVuIHJvdyBvZiBsb3dlciBjb25maXJtZWQgY2VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRvcCBvZiBwcmVzdW1lZCB0aGlyZCBjb25maXJtZWQgY2VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGJhY2sgdXAgYSBiaXQgdG8gZ2V0IGEgZnVsbCBjaGFuY2Ugb2YgZGV0ZWN0aW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQsIGVudGlyZSB3aWR0aCBvZiBjZW50ZXIgb2YgZmluZGVyIHBhdHRlcm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGJ5IHJvd1NraXAsIGJ1dCBiYWNrIG9mZiBieSBzdGF0ZUNvdW50WzJdIChzaXplIG9mIGxhc3QgY2VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgcGF0dGVybiB3ZSBzYXcpIHRvIGJlIGNvbnNlcnZhdGl2ZSwgYW5kIGFsc28gYmFjayBvZmYgYnkgaVNraXAgd2hpY2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyBhYm91dCB0byBiZSByZS1hZGRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gcm93U2tpcCAtIHN0YXRlQ291bnRbMl0gLSBpU2tpcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gbWF4SiAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSBzdGF0ZUNvdW50WzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gc3RhdGVDb3VudFszXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsyXSA9IHN0YXRlQ291bnRbNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0YXRlID0gMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHN0YXRlIHRvIHN0YXJ0IGxvb2tpbmcgYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbMl0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbNF0gPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIE5vLCBzaGlmdCBjb3VudHMgYmFjayBieSB0d29cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzBdID0gc3RhdGVDb3VudFsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzFdID0gc3RhdGVDb3VudFszXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzJdID0gc3RhdGVDb3VudFs0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzNdID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZUNvdW50WzRdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVDb3VudFsrK2N1cnJlbnRTdGF0ZV0rKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gQ291bnRpbmcgd2hpdGUgcGl4ZWxzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlQ291bnRbY3VycmVudFN0YXRlXSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpcm1lZCA9IHRoaXMuaGFuZGxlUG9zc2libGVDZW50ZXIoc3RhdGVDb3VudCwgaSwgbWF4SiwgcHVyZUJhcmNvZGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1lZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlTa2lwID0gc3RhdGVDb3VudFswXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNTa2lwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIGEgdGhpcmQgb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0aGlzLmhhdmVNdWx0aXBseUNvbmZpcm1lZENlbnRlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBhdHRlcm5JbmZvID0gdGhpcy5zZWxlY3RCZXN0UGF0dGVybnMoKTtcclxuICAgICAgICBSZXN1bHRQb2ludF8xLmRlZmF1bHQub3JkZXJCZXN0UGF0dGVybnMocGF0dGVybkluZm8pO1xyXG4gICAgICAgIHJldHVybiBuZXcgRmluZGVyUGF0dGVybkluZm9fMS5kZWZhdWx0KHBhdHRlcm5JbmZvKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgY291bnQgb2YgYmxhY2svd2hpdGUvYmxhY2svd2hpdGUvYmxhY2sgcGl4ZWxzIGp1c3Qgc2VlbiBhbmQgYW4gZW5kIHBvc2l0aW9uLFxyXG4gICAgICogZmlndXJlcyB0aGUgbG9jYXRpb24gb2YgdGhlIGNlbnRlciBvZiB0aGlzIHJ1bi5cclxuICAgICAqL1xyXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kID0gZnVuY3Rpb24gKHN0YXRlQ291bnQsIGVuZCAvKmludCovKSB7XHJcbiAgICAgICAgcmV0dXJuIChlbmQgLSBzdGF0ZUNvdW50WzRdIC0gc3RhdGVDb3VudFszXSkgLSBzdGF0ZUNvdW50WzJdIC8gMi4wO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHN0YXRlQ291bnQgY291bnQgb2YgYmxhY2svd2hpdGUvYmxhY2svd2hpdGUvYmxhY2sgcGl4ZWxzIGp1c3QgcmVhZFxyXG4gICAgICogQHJldHVybiB0cnVlIGlmZiB0aGUgcHJvcG9ydGlvbnMgb2YgdGhlIGNvdW50cyBpcyBjbG9zZSBlbm91Z2ggdG8gdGhlIDEvMS8zLzEvMSByYXRpb3NcclxuICAgICAqICAgICAgICAgdXNlZCBieSBmaW5kZXIgcGF0dGVybnMgdG8gYmUgY29uc2lkZXJlZCBhIG1hdGNoXHJcbiAgICAgKi9cclxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIuZm91bmRQYXR0ZXJuQ3Jvc3MgPSBmdW5jdGlvbiAoc3RhdGVDb3VudCkge1xyXG4gICAgICAgIHZhciB0b3RhbE1vZHVsZVNpemUgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjb3VudCA9IHN0YXRlQ291bnRbaV07XHJcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRvdGFsTW9kdWxlU2l6ZSArPSBjb3VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvdGFsTW9kdWxlU2l6ZSA8IDcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbW9kdWxlU2l6ZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIDcuMDtcclxuICAgICAgICB2YXIgbWF4VmFyaWFuY2UgPSBtb2R1bGVTaXplIC8gMi4wO1xyXG4gICAgICAgIC8vIEFsbG93IGxlc3MgdGhhbiA1MCUgdmFyaWFuY2UgZnJvbSAxLTEtMy0xLTEgcHJvcG9ydGlvbnNcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbMF0pIDwgbWF4VmFyaWFuY2UgJiZcclxuICAgICAgICAgICAgTWF0aC5hYnMobW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbMV0pIDwgbWF4VmFyaWFuY2UgJiZcclxuICAgICAgICAgICAgTWF0aC5hYnMoMy4wICogbW9kdWxlU2l6ZSAtIHN0YXRlQ291bnRbMl0pIDwgMyAqIG1heFZhcmlhbmNlICYmXHJcbiAgICAgICAgICAgIE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzNdKSA8IG1heFZhcmlhbmNlICYmXHJcbiAgICAgICAgICAgIE1hdGguYWJzKG1vZHVsZVNpemUgLSBzdGF0ZUNvdW50WzRdKSA8IG1heFZhcmlhbmNlO1xyXG4gICAgfTtcclxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjcm9zc0NoZWNrU3RhdGVDb3VudCA9IHRoaXMuY3Jvc3NDaGVja1N0YXRlQ291bnQ7XHJcbiAgICAgICAgY3Jvc3NDaGVja1N0YXRlQ291bnRbMF0gPSAwO1xyXG4gICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzFdID0gMDtcclxuICAgICAgICBjcm9zc0NoZWNrU3RhdGVDb3VudFsyXSA9IDA7XHJcbiAgICAgICAgY3Jvc3NDaGVja1N0YXRlQ291bnRbM10gPSAwO1xyXG4gICAgICAgIGNyb3NzQ2hlY2tTdGF0ZUNvdW50WzRdID0gMDtcclxuICAgICAgICByZXR1cm4gY3Jvc3NDaGVja1N0YXRlQ291bnQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZnRlciBhIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3RlbnRpYWwgZmluZGVyIHBhdHRlcm4sIHRoaXMgbWV0aG9kXHJcbiAgICAgKiBcImNyb3NzLWNyb3NzLWNyb3NzLWNoZWNrc1wiIGJ5IHNjYW5uaW5nIGRvd24gZGlhZ29uYWxseSB0aHJvdWdoIHRoZSBjZW50ZXIgb2YgdGhlIHBvc3NpYmxlXHJcbiAgICAgKiBmaW5kZXIgcGF0dGVybiB0byBzZWUgaWYgdGhlIHNhbWUgcHJvcG9ydGlvbiBpcyBkZXRlY3RlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RhcnRJIHJvdyB3aGVyZSBhIGZpbmRlciBwYXR0ZXJuIHdhcyBkZXRlY3RlZFxyXG4gICAgICogQHBhcmFtIGNlbnRlckogY2VudGVyIG9mIHRoZSBzZWN0aW9uIHRoYXQgYXBwZWFycyB0byBjcm9zcyBhIGZpbmRlciBwYXR0ZXJuXHJcbiAgICAgKiBAcGFyYW0gbWF4Q291bnQgbWF4aW11bSByZWFzb25hYmxlIG51bWJlciBvZiBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlXHJcbiAgICAgKiAgb2JzZXJ2ZWQgaW4gYW55IHJlYWRpbmcgc3RhdGUsIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBob3Jpem9udGFsIHNjYW5cclxuICAgICAqIEBwYXJhbSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCBUaGUgb3JpZ2luYWwgc3RhdGUgY291bnQgdG90YWwuXHJcbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvcG9ydGlvbnMgYXJlIHdpdGhpbmcgZXhwZWN0ZWQgbGltaXRzXHJcbiAgICAgKi9cclxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmNyb3NzQ2hlY2tEaWFnb25hbCA9IGZ1bmN0aW9uIChzdGFydEkgLyppbnQqLywgY2VudGVySiAvKmludCovLCBtYXhDb3VudCAvKmludCovLCBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7XHJcbiAgICAgICAgLy8gU3RhcnQgY291bnRpbmcgdXAsIGxlZnQgZnJvbSBjZW50ZXIgZmluZGluZyBibGFjayBjZW50ZXIgbWFzc1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xyXG4gICAgICAgIHdoaWxlIChzdGFydEkgPj0gaSAmJiBjZW50ZXJKID49IGkgJiYgaW1hZ2UuZ2V0KGNlbnRlckogLSBpLCBzdGFydEkgLSBpKSkge1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0SSA8IGkgfHwgY2VudGVySiA8IGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb250aW51ZSB1cCwgbGVmdCBmaW5kaW5nIHdoaXRlIHNwYWNlXHJcbiAgICAgICAgd2hpbGUgKHN0YXJ0SSA+PSBpICYmIGNlbnRlckogPj0gaSAmJiAhaW1hZ2UuZ2V0KGNlbnRlckogLSBpLCBzdGFydEkgLSBpKSAmJlxyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBhbHJlYWR5IHRvbyBtYW55IG1vZHVsZXMgaW4gdGhpcyBzdGF0ZSBvciByYW4gb2ZmIHRoZSBlZGdlOlxyXG4gICAgICAgIGlmIChzdGFydEkgPCBpIHx8IGNlbnRlckogPCBpIHx8IHN0YXRlQ291bnRbMV0gPiBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvbnRpbnVlIHVwLCBsZWZ0IGZpbmRpbmcgYmxhY2sgYm9yZGVyXHJcbiAgICAgICAgd2hpbGUgKHN0YXJ0SSA+PSBpICYmIGNlbnRlckogPj0gaSAmJiBpbWFnZS5nZXQoY2VudGVySiAtIGksIHN0YXJ0SSAtIGkpICYmXHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMF0gPD0gbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgc3RhdGVDb3VudFswXSsrO1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZUNvdW50WzBdID4gbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF4SSA9IGltYWdlLmdldEhlaWdodCgpO1xyXG4gICAgICAgIHZhciBtYXhKID0gaW1hZ2UuZ2V0V2lkdGgoKTtcclxuICAgICAgICAvLyBOb3cgYWxzbyBjb3VudCBkb3duLCByaWdodCBmcm9tIGNlbnRlclxyXG4gICAgICAgIGkgPSAxO1xyXG4gICAgICAgIHdoaWxlIChzdGFydEkgKyBpIDwgbWF4SSAmJiBjZW50ZXJKICsgaSA8IG1heEogJiYgaW1hZ2UuZ2V0KGNlbnRlckogKyBpLCBzdGFydEkgKyBpKSkge1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgZWRnZT9cclxuICAgICAgICBpZiAoc3RhcnRJICsgaSA+PSBtYXhJIHx8IGNlbnRlckogKyBpID49IG1heEopIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoc3RhcnRJICsgaSA8IG1heEkgJiYgY2VudGVySiArIGkgPCBtYXhKICYmICFpbWFnZS5nZXQoY2VudGVySiArIGksIHN0YXJ0SSArIGkpICYmXHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbM10gPCBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzNdKys7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0SSArIGkgPj0gbWF4SSB8fCBjZW50ZXJKICsgaSA+PSBtYXhKIHx8IHN0YXRlQ291bnRbM10gPj0gbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoc3RhcnRJICsgaSA8IG1heEkgJiYgY2VudGVySiArIGkgPCBtYXhKICYmIGltYWdlLmdldChjZW50ZXJKICsgaSwgc3RhcnRJICsgaSkgJiZcclxuICAgICAgICAgICAgc3RhdGVDb3VudFs0XSA8IG1heENvdW50KSB7XHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbNF0rKztcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGVDb3VudFs0XSA+PSBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZmluZGVyLXBhdHRlcm4tbGlrZSBzZWN0aW9uLCBidXQgaXRzIHNpemUgaXMgbW9yZSB0aGFuIDEwMCUgZGlmZmVyZW50IHRoYW5cclxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGFzc3VtZSBpdCdzIGEgZmFsc2UgcG9zaXRpdmVcclxuICAgICAgICB2YXIgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArIHN0YXRlQ291bnRbNF07XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA8IDIgKiBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCAmJlxyXG4gICAgICAgICAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogPHA+QWZ0ZXIgYSBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3RlbnRpYWwgZmluZGVyIHBhdHRlcm4sIHRoaXMgbWV0aG9kXHJcbiAgICAgKiBcImNyb3NzLWNoZWNrc1wiIGJ5IHNjYW5uaW5nIGRvd24gdmVydGljYWxseSB0aHJvdWdoIHRoZSBjZW50ZXIgb2YgdGhlIHBvc3NpYmxlXHJcbiAgICAgKiBmaW5kZXIgcGF0dGVybiB0byBzZWUgaWYgdGhlIHNhbWUgcHJvcG9ydGlvbiBpcyBkZXRlY3RlZC48L3A+XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0YXJ0SSByb3cgd2hlcmUgYSBmaW5kZXIgcGF0dGVybiB3YXMgZGV0ZWN0ZWRcclxuICAgICAqIEBwYXJhbSBjZW50ZXJKIGNlbnRlciBvZiB0aGUgc2VjdGlvbiB0aGF0IGFwcGVhcnMgdG8gY3Jvc3MgYSBmaW5kZXIgcGF0dGVyblxyXG4gICAgICogQHBhcmFtIG1heENvdW50IG1heGltdW0gcmVhc29uYWJsZSBudW1iZXIgb2YgbW9kdWxlcyB0aGF0IHNob3VsZCBiZVxyXG4gICAgICogb2JzZXJ2ZWQgaW4gYW55IHJlYWRpbmcgc3RhdGUsIGJhc2VkIG9uIHRoZSByZXN1bHRzIG9mIHRoZSBob3Jpem9udGFsIHNjYW5cclxuICAgICAqIEByZXR1cm4gdmVydGljYWwgY2VudGVyIG9mIGZpbmRlciBwYXR0ZXJuLCBvciB7QGxpbmsgRmxvYXQjTmFOfSBpZiBub3QgZm91bmRcclxuICAgICAqL1xyXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuY3Jvc3NDaGVja1ZlcnRpY2FsID0gZnVuY3Rpb24gKHN0YXJ0SSAvKmludCovLCBjZW50ZXJKIC8qaW50Ki8sIG1heENvdW50IC8qaW50Ki8sIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsIC8qaW50Ki8pIHtcclxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xyXG4gICAgICAgIHZhciBtYXhJID0gaW1hZ2UuZ2V0SGVpZ2h0KCk7XHJcbiAgICAgICAgdmFyIHN0YXRlQ291bnQgPSB0aGlzLmdldENyb3NzQ2hlY2tTdGF0ZUNvdW50KCk7XHJcbiAgICAgICAgLy8gU3RhcnQgY291bnRpbmcgdXAgZnJvbSBjZW50ZXJcclxuICAgICAgICB2YXIgaSA9IHN0YXJ0STtcclxuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSkge1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XHJcbiAgICAgICAgICAgIGktLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgIWltYWdlLmdldChjZW50ZXJKLCBpKSAmJiBzdGF0ZUNvdW50WzFdIDw9IG1heENvdW50KSB7XHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMV0rKztcclxuICAgICAgICAgICAgaS0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBhbHJlYWR5IHRvbyBtYW55IG1vZHVsZXMgaW4gdGhpcyBzdGF0ZSBvciByYW4gb2ZmIHRoZSBlZGdlOlxyXG4gICAgICAgIGlmIChpIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XHJcbiAgICAgICAgICAgIGktLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOb3cgYWxzbyBjb3VudCBkb3duIGZyb20gY2VudGVyXHJcbiAgICAgICAgaSA9IHN0YXJ0SSArIDE7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmIGltYWdlLmdldChjZW50ZXJKLCBpKSkge1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzJdKys7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPT09IG1heEkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGkgPCBtYXhJICYmICFpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFszXSA8IG1heENvdW50KSB7XHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbM10rKztcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaSA9PT0gbWF4SSB8fCBzdGF0ZUNvdW50WzNdID49IG1heENvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpIDwgbWF4SSAmJiBpbWFnZS5nZXQoY2VudGVySiwgaSkgJiYgc3RhdGVDb3VudFs0XSA8IG1heENvdW50KSB7XHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbNF0rKztcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhdGVDb3VudFs0XSA+PSBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhIGZpbmRlci1wYXR0ZXJuLWxpa2Ugc2VjdGlvbiwgYnV0IGl0cyBzaXplIGlzIG1vcmUgdGhhbiA0MCUgZGlmZmVyZW50IHRoYW5cclxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwsIGFzc3VtZSBpdCdzIGEgZmFsc2UgcG9zaXRpdmVcclxuICAgICAgICB2YXIgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArXHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbNF07XHJcbiAgICAgICAgaWYgKDUgKiBNYXRoLmFicyhzdGF0ZUNvdW50VG90YWwgLSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkgPj0gMiAqIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBGaW5kZXJQYXR0ZXJuRmluZGVyLmZvdW5kUGF0dGVybkNyb3NzKHN0YXRlQ291bnQpID8gRmluZGVyUGF0dGVybkZpbmRlci5jZW50ZXJGcm9tRW5kKHN0YXRlQ291bnQsIGkpIDogTmFOO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogPHA+TGlrZSB7QGxpbmsgI2Nyb3NzQ2hlY2tWZXJ0aWNhbChpbnQsIGludCwgaW50LCBpbnQpfSwgYW5kIGluIGZhY3QgaXMgYmFzaWNhbGx5IGlkZW50aWNhbCxcclxuICAgICAqIGV4Y2VwdCBpdCByZWFkcyBob3Jpem9udGFsbHkgaW5zdGVhZCBvZiB2ZXJ0aWNhbGx5LiBUaGlzIGlzIHVzZWQgdG8gY3Jvc3MtY3Jvc3NcclxuICAgICAqIGNoZWNrIGEgdmVydGljYWwgY3Jvc3MgY2hlY2sgYW5kIGxvY2F0ZSB0aGUgcmVhbCBjZW50ZXIgb2YgdGhlIGFsaWdubWVudCBwYXR0ZXJuLjwvcD5cclxuICAgICAqL1xyXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuY3Jvc3NDaGVja0hvcml6b250YWwgPSBmdW5jdGlvbiAoc3RhcnRKIC8qaW50Ki8sIGNlbnRlckkgLyppbnQqLywgbWF4Q291bnQgLyppbnQqLywgb3JpZ2luYWxTdGF0ZUNvdW50VG90YWwgLyppbnQqLykge1xyXG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XHJcbiAgICAgICAgdmFyIG1heEogPSBpbWFnZS5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHZhciBzdGF0ZUNvdW50ID0gdGhpcy5nZXRDcm9zc0NoZWNrU3RhdGVDb3VudCgpO1xyXG4gICAgICAgIHZhciBqID0gc3RhcnRKO1xyXG4gICAgICAgIHdoaWxlIChqID49IDAgJiYgaW1hZ2UuZ2V0KGosIGNlbnRlckkpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcclxuICAgICAgICAgICAgai0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaiA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGogPj0gMCAmJiAhaW1hZ2UuZ2V0KGosIGNlbnRlckkpICYmIHN0YXRlQ291bnRbMV0gPD0gbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgc3RhdGVDb3VudFsxXSsrO1xyXG4gICAgICAgICAgICBqLS07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqIDwgMCB8fCBzdGF0ZUNvdW50WzFdID4gbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGogPj0gMCAmJiBpbWFnZS5nZXQoaiwgY2VudGVySSkgJiYgc3RhdGVDb3VudFswXSA8PSBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICBzdGF0ZUNvdW50WzBdKys7XHJcbiAgICAgICAgICAgIGotLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRlQ291bnRbMF0gPiBtYXhDb3VudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICBqID0gc3RhcnRKICsgMTtcclxuICAgICAgICB3aGlsZSAoaiA8IG1heEogJiYgaW1hZ2UuZ2V0KGosIGNlbnRlckkpKSB7XHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbMl0rKztcclxuICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaiA9PT0gbWF4Sikge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAoaiA8IG1heEogJiYgIWltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzNdIDwgbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgc3RhdGVDb3VudFszXSsrO1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChqID09PSBtYXhKIHx8IHN0YXRlQ291bnRbM10gPj0gbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKGogPCBtYXhKICYmIGltYWdlLmdldChqLCBjZW50ZXJJKSAmJiBzdGF0ZUNvdW50WzRdIDwgbWF4Q291bnQpIHtcclxuICAgICAgICAgICAgc3RhdGVDb3VudFs0XSsrO1xyXG4gICAgICAgICAgICBqKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0ZUNvdW50WzRdID49IG1heENvdW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGZvdW5kIGEgZmluZGVyLXBhdHRlcm4tbGlrZSBzZWN0aW9uLCBidXQgaXRzIHNpemUgaXMgc2lnbmlmaWNhbnRseSBkaWZmZXJlbnQgdGhhblxyXG4gICAgICAgIC8vIHRoZSBvcmlnaW5hbCwgYXNzdW1lIGl0J3MgYSBmYWxzZSBwb3NpdGl2ZVxyXG4gICAgICAgIHZhciBzdGF0ZUNvdW50VG90YWwgPSBzdGF0ZUNvdW50WzBdICsgc3RhdGVDb3VudFsxXSArIHN0YXRlQ291bnRbMl0gKyBzdGF0ZUNvdW50WzNdICtcclxuICAgICAgICAgICAgc3RhdGVDb3VudFs0XTtcclxuICAgICAgICBpZiAoNSAqIE1hdGguYWJzKHN0YXRlQ291bnRUb3RhbCAtIG9yaWdpbmFsU3RhdGVDb3VudFRvdGFsKSA+PSBvcmlnaW5hbFN0YXRlQ291bnRUb3RhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gRmluZGVyUGF0dGVybkZpbmRlci5mb3VuZFBhdHRlcm5Dcm9zcyhzdGF0ZUNvdW50KSA/IEZpbmRlclBhdHRlcm5GaW5kZXIuY2VudGVyRnJvbUVuZChzdGF0ZUNvdW50LCBqKSA6IE5hTjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIDxwPlRoaXMgaXMgY2FsbGVkIHdoZW4gYSBob3Jpem9udGFsIHNjYW4gZmluZHMgYSBwb3NzaWJsZSBhbGlnbm1lbnQgcGF0dGVybi4gSXQgd2lsbFxyXG4gICAgICogY3Jvc3MgY2hlY2sgd2l0aCBhIHZlcnRpY2FsIHNjYW4sIGFuZCBpZiBzdWNjZXNzZnVsLCB3aWxsLCBhaCwgY3Jvc3MtY3Jvc3MtY2hlY2tcclxuICAgICAqIHdpdGggYW5vdGhlciBob3Jpem9udGFsIHNjYW4uIFRoaXMgaXMgbmVlZGVkIHByaW1hcmlseSB0byBsb2NhdGUgdGhlIHJlYWwgaG9yaXpvbnRhbFxyXG4gICAgICogY2VudGVyIG9mIHRoZSBwYXR0ZXJuIGluIGNhc2VzIG9mIGV4dHJlbWUgc2tldy5cclxuICAgICAqIEFuZCB0aGVuIHdlIGNyb3NzLWNyb3NzLWNyb3NzIGNoZWNrIHdpdGggYW5vdGhlciBkaWFnb25hbCBzY2FuLjwvcD5cclxuICAgICAqXHJcbiAgICAgKiA8cD5JZiB0aGF0IHN1Y2NlZWRzIHRoZSBmaW5kZXIgcGF0dGVybiBsb2NhdGlvbiBpcyBhZGRlZCB0byBhIGxpc3QgdGhhdCB0cmFja3NcclxuICAgICAqIHRoZSBudW1iZXIgb2YgdGltZXMgZWFjaCBsb2NhdGlvbiBoYXMgYmVlbiBuZWFybHktbWF0Y2hlZCBhcyBhIGZpbmRlciBwYXR0ZXJuLlxyXG4gICAgICogRWFjaCBhZGRpdGlvbmFsIGZpbmQgaXMgbW9yZSBldmlkZW5jZSB0aGF0IHRoZSBsb2NhdGlvbiBpcyBpbiBmYWN0IGEgZmluZGVyXHJcbiAgICAgKiBwYXR0ZXJuIGNlbnRlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdGF0ZUNvdW50IHJlYWRpbmcgc3RhdGUgbW9kdWxlIGNvdW50cyBmcm9tIGhvcml6b250YWwgc2NhblxyXG4gICAgICogQHBhcmFtIGkgcm93IHdoZXJlIGZpbmRlciBwYXR0ZXJuIG1heSBiZSBmb3VuZFxyXG4gICAgICogQHBhcmFtIGogZW5kIG9mIHBvc3NpYmxlIGZpbmRlciBwYXR0ZXJuIGluIHJvd1xyXG4gICAgICogQHBhcmFtIHB1cmVCYXJjb2RlIHRydWUgaWYgaW4gXCJwdXJlIGJhcmNvZGVcIiBtb2RlXHJcbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgYSBmaW5kZXIgcGF0dGVybiBjYW5kaWRhdGUgd2FzIGZvdW5kIHRoaXMgdGltZVxyXG4gICAgICovXHJcbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLnByb3RvdHlwZS5oYW5kbGVQb3NzaWJsZUNlbnRlciA9IGZ1bmN0aW9uIChzdGF0ZUNvdW50LCBpIC8qaW50Ki8sIGogLyppbnQqLywgcHVyZUJhcmNvZGUpIHtcclxuICAgICAgICB2YXIgc3RhdGVDb3VudFRvdGFsID0gc3RhdGVDb3VudFswXSArIHN0YXRlQ291bnRbMV0gKyBzdGF0ZUNvdW50WzJdICsgc3RhdGVDb3VudFszXSArXHJcbiAgICAgICAgICAgIHN0YXRlQ291bnRbNF07XHJcbiAgICAgICAgdmFyIGNlbnRlckogPSBGaW5kZXJQYXR0ZXJuRmluZGVyLmNlbnRlckZyb21FbmQoc3RhdGVDb3VudCwgaik7XHJcbiAgICAgICAgdmFyIGNlbnRlckkgPSB0aGlzLmNyb3NzQ2hlY2tWZXJ0aWNhbChpLCAvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySiksIHN0YXRlQ291bnRbMl0sIHN0YXRlQ291bnRUb3RhbCk7XHJcbiAgICAgICAgaWYgKCFpc05hTihjZW50ZXJJKSkge1xyXG4gICAgICAgICAgICAvLyBSZS1jcm9zcyBjaGVja1xyXG4gICAgICAgICAgICBjZW50ZXJKID0gdGhpcy5jcm9zc0NoZWNrSG9yaXpvbnRhbCgvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySiksIC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJJKSwgc3RhdGVDb3VudFsyXSwgc3RhdGVDb3VudFRvdGFsKTtcclxuICAgICAgICAgICAgaWYgKCFpc05hTihjZW50ZXJKKSAmJlxyXG4gICAgICAgICAgICAgICAgKCFwdXJlQmFyY29kZSB8fCB0aGlzLmNyb3NzQ2hlY2tEaWFnb25hbCgvKihpbnQpICovIE1hdGguZmxvb3IoY2VudGVySSksIC8qKGludCkgKi8gTWF0aC5mbG9vcihjZW50ZXJKKSwgc3RhdGVDb3VudFsyXSwgc3RhdGVDb3VudFRvdGFsKSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlc3RpbWF0ZWRNb2R1bGVTaXplID0gc3RhdGVDb3VudFRvdGFsIC8gNy4wO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVDZW50ZXJzID0gdGhpcy5wb3NzaWJsZUNlbnRlcnM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aF8xID0gcG9zc2libGVDZW50ZXJzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGhfMTsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBwb3NzaWJsZUNlbnRlcnNbaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGFib3V0IHRoZSBzYW1lIGNlbnRlciBhbmQgbW9kdWxlIHNpemU6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbnRlci5hYm91dEVxdWFscyhlc3RpbWF0ZWRNb2R1bGVTaXplLCBjZW50ZXJJLCBjZW50ZXJKKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbaW5kZXhdID0gY2VudGVyLmNvbWJpbmVFc3RpbWF0ZShjZW50ZXJJLCBjZW50ZXJKLCBlc3RpbWF0ZWRNb2R1bGVTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gbmV3IEZpbmRlclBhdHRlcm5fMS5kZWZhdWx0KGNlbnRlckosIGNlbnRlckksIGVzdGltYXRlZE1vZHVsZVNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5wdXNoKHBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHRQb2ludENhbGxiYWNrICE9PSBudWxsICYmIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0UG9pbnRDYWxsYmFjay5mb3VuZFBvc3NpYmxlUmVzdWx0UG9pbnQocG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4gbnVtYmVyIG9mIHJvd3Mgd2UgY291bGQgc2FmZWx5IHNraXAgZHVyaW5nIHNjYW5uaW5nLCBiYXNlZCBvbiB0aGUgZmlyc3RcclxuICAgICAqICAgICAgICAgdHdvIGZpbmRlciBwYXR0ZXJucyB0aGF0IGhhdmUgYmVlbiBsb2NhdGVkLiBJbiBzb21lIGNhc2VzIHRoZWlyIHBvc2l0aW9uIHdpbGxcclxuICAgICAqICAgICAgICAgYWxsb3cgdXMgdG8gaW5mZXIgdGhhdCB0aGUgdGhpcmQgcGF0dGVybiBtdXN0IGxpZSBiZWxvdyBhIGNlcnRhaW4gcG9pbnQgZmFydGhlclxyXG4gICAgICogICAgICAgICBkb3duIGluIHRoZSBpbWFnZS5cclxuICAgICAqL1xyXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuZmluZFJvd1NraXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgdmFyIG1heCA9IHRoaXMucG9zc2libGVDZW50ZXJzLmxlbmd0aDtcclxuICAgICAgICBpZiAobWF4IDw9IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBmaXJzdENvbmZpcm1lZENlbnRlciA9IG51bGw7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLnBvc3NpYmxlQ2VudGVycyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjZW50ZXIgPSBfYy52YWx1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChjZW50ZXIuZ2V0Q291bnQoKSA+PSBGaW5kZXJQYXR0ZXJuRmluZGVyLkNFTlRFUl9RVU9SVU0pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RDb25maXJtZWRDZW50ZXIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdENvbmZpcm1lZENlbnRlciA9IGNlbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdHdvIGNvbmZpcm1lZCBjZW50ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhvdyBmYXIgZG93biBjYW4gd2Ugc2tpcCBiZWZvcmUgcmVzdW1pbmcgbG9va2luZyBmb3IgdGhlIG5leHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGF0dGVybj8gSW4gdGhlIHdvcnN0IGNhc2UsIG9ubHkgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiB0aGUgeCAvIHkgY29vcmRpbmF0ZXMgb2YgdGhlIHR3byBjZW50ZXJzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBjYXNlIHdoZXJlIHlvdSBmaW5kIHRvcCBsZWZ0IGxhc3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzU2tpcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvKihpbnQpICovIE1hdGguZmxvb3IoKE1hdGguYWJzKGZpcnN0Q29uZmlybWVkQ2VudGVyLmdldFgoKSAtIGNlbnRlci5nZXRYKCkpIC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKGZpcnN0Q29uZmlybWVkQ2VudGVyLmdldFkoKSAtIGNlbnRlci5nZXRZKCkpKSAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHRydWUgaWZmIHdlIGhhdmUgZm91bmQgYXQgbGVhc3QgMyBmaW5kZXIgcGF0dGVybnMgdGhhdCBoYXZlIGJlZW4gZGV0ZWN0ZWRcclxuICAgICAqICAgICAgICAgYXQgbGVhc3Qge0BsaW5rICNDRU5URVJfUVVPUlVNfSB0aW1lcyBlYWNoLCBhbmQsIHRoZSBlc3RpbWF0ZWQgbW9kdWxlIHNpemUgb2YgdGhlXHJcbiAgICAgKiAgICAgICAgIGNhbmRpZGF0ZXMgaXMgXCJwcmV0dHkgc2ltaWxhclwiXHJcbiAgICAgKi9cclxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIucHJvdG90eXBlLmhhdmVNdWx0aXBseUNvbmZpcm1lZENlbnRlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVfMiwgX2EsIGVfMywgX2I7XHJcbiAgICAgICAgdmFyIGNvbmZpcm1lZENvdW50ID0gMDtcclxuICAgICAgICB2YXIgdG90YWxNb2R1bGVTaXplID0gMC4wO1xyXG4gICAgICAgIHZhciBtYXggPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyh0aGlzLnBvc3NpYmxlQ2VudGVycyksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gX2QudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0dGVybi5nZXRDb3VudCgpID49IEZpbmRlclBhdHRlcm5GaW5kZXIuQ0VOVEVSX1FVT1JVTSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpcm1lZENvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgdG90YWxNb2R1bGVTaXplICs9IHBhdHRlcm4uZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlybWVkQ291bnQgPCAzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT0ssIHdlIGhhdmUgYXQgbGVhc3QgMyBjb25maXJtZWQgY2VudGVycywgYnV0LCBpdCdzIHBvc3NpYmxlIHRoYXQgb25lIGlzIGEgXCJmYWxzZSBwb3NpdGl2ZVwiXHJcbiAgICAgICAgLy8gYW5kIHRoYXQgd2UgbmVlZCB0byBrZWVwIGxvb2tpbmcuIFdlIGRldGVjdCB0aGlzIGJ5IGFza2luZyBpZiB0aGUgZXN0aW1hdGVkIG1vZHVsZSBzaXplc1xyXG4gICAgICAgIC8vIHZhcnkgdG9vIG11Y2guIFdlIGFyYml0cmFyaWx5IHNheSB0aGF0IHdoZW4gdGhlIHRvdGFsIGRldmlhdGlvbiBmcm9tIGF2ZXJhZ2UgZXhjZWVkc1xyXG4gICAgICAgIC8vIDUlIG9mIHRoZSB0b3RhbCBtb2R1bGUgc2l6ZSBlc3RpbWF0ZXMsIGl0J3MgdG9vIG11Y2guXHJcbiAgICAgICAgdmFyIGF2ZXJhZ2UgPSB0b3RhbE1vZHVsZVNpemUgLyBtYXg7XHJcbiAgICAgICAgdmFyIHRvdGFsRGV2aWF0aW9uID0gMC4wO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9lID0gX192YWx1ZXModGhpcy5wb3NzaWJsZUNlbnRlcnMpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IF9mLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdG90YWxEZXZpYXRpb24gKz0gTWF0aC5hYnMocGF0dGVybi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsRGV2aWF0aW9uIDw9IDAuMDUgKiB0b3RhbE1vZHVsZVNpemU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIHRoZSAzIGJlc3Qge0BsaW5rIEZpbmRlclBhdHRlcm59cyBmcm9tIG91ciBsaXN0IG9mIGNhbmRpZGF0ZXMuIFRoZSBcImJlc3RcIiBhcmVcclxuICAgICAqICAgICAgICAgdGhvc2UgdGhhdCBoYXZlIGJlZW4gZGV0ZWN0ZWQgYXQgbGVhc3Qge0BsaW5rICNDRU5URVJfUVVPUlVNfSB0aW1lcywgYW5kIHdob3NlIG1vZHVsZVxyXG4gICAgICogICAgICAgICBzaXplIGRpZmZlcnMgZnJvbSB0aGUgYXZlcmFnZSBhbW9uZyB0aG9zZSBwYXR0ZXJucyB0aGUgbGVhc3RcclxuICAgICAqIEB0aHJvd3MgTm90Rm91bmRFeGNlcHRpb24gaWYgMyBzdWNoIGZpbmRlciBwYXR0ZXJucyBkbyBub3QgZXhpc3RcclxuICAgICAqL1xyXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5wcm90b3R5cGUuc2VsZWN0QmVzdFBhdHRlcm5zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlXzQsIF9hLCBlXzUsIF9iO1xyXG4gICAgICAgIHZhciBzdGFydFNpemUgPSB0aGlzLnBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHN0YXJ0U2l6ZSA8IDMpIHtcclxuICAgICAgICAgICAgLy8gQ291bGRuJ3QgZmluZCBlbm91Z2ggZmluZGVyIHBhdHRlcm5zXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHBvc3NpYmxlQ2VudGVycyA9IHRoaXMucG9zc2libGVDZW50ZXJzO1xyXG4gICAgICAgIHZhciBhdmVyYWdlO1xyXG4gICAgICAgIC8vIEZpbHRlciBvdXRsaWVyIHBvc3NpYmlsaXRpZXMgd2hvc2UgbW9kdWxlIHNpemUgaXMgdG9vIGRpZmZlcmVudFxyXG4gICAgICAgIGlmIChzdGFydFNpemUgPiAzKSB7XHJcbiAgICAgICAgICAgIC8vIEJ1dCB3ZSBjYW4gb25seSBhZmZvcmQgdG8gZG8gc28gaWYgd2UgaGF2ZSBhdCBsZWFzdCA0IHBvc3NpYmlsaXRpZXMgdG8gY2hvb3NlIGZyb21cclxuICAgICAgICAgICAgdmFyIHRvdGFsTW9kdWxlU2l6ZSA9IDAuMDtcclxuICAgICAgICAgICAgdmFyIHNxdWFyZSA9IDAuMDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXModGhpcy5wb3NzaWJsZUNlbnRlcnMpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbnRlciA9IF9kLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplID0gY2VudGVyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbE1vZHVsZVNpemUgKz0gc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICBzcXVhcmUgKz0gc2l6ZSAqIHNpemU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhdmVyYWdlID0gdG90YWxNb2R1bGVTaXplIC8gc3RhcnRTaXplO1xyXG4gICAgICAgICAgICB2YXIgc3RkRGV2ID0gTWF0aC5zcXJ0KHNxdWFyZSAvIHN0YXJ0U2l6ZSAtIGF2ZXJhZ2UgKiBhdmVyYWdlKTtcclxuICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnNvcnQoXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiA8cD5PcmRlcnMgYnkgZnVydGhlc3QgZnJvbSBhdmVyYWdlPC9wPlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgLy8gRnVydGhlc3RGcm9tQXZlcmFnZUNvbXBhcmF0b3IgaW1wbGVtZW50cyBDb21wYXJhdG9yPEZpbmRlclBhdHRlcm4+XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjZW50ZXIxLCBjZW50ZXIyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZEEgPSBNYXRoLmFicyhjZW50ZXIyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRCID0gTWF0aC5hYnMoY2VudGVyMS5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkQSA8IGRCID8gLTEgOiBkQSA+IGRCID8gMSA6IDA7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB2YXIgbGltaXQgPSBNYXRoLm1heCgwLjIgKiBhdmVyYWdlLCBzdGREZXYpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3NpYmxlQ2VudGVycy5sZW5ndGggJiYgcG9zc2libGVDZW50ZXJzLmxlbmd0aCA+IDM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSBwb3NzaWJsZUNlbnRlcnNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocGF0dGVybi5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCkgLSBhdmVyYWdlKSA+IGxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvc3NpYmxlQ2VudGVycy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICAgIC8vIFRocm93IGF3YXkgYWxsIGJ1dCB0aG9zZSBmaXJzdCBzaXplIGNhbmRpZGF0ZSBwb2ludHMgd2UgZm91bmQuXHJcbiAgICAgICAgICAgIHZhciB0b3RhbE1vZHVsZVNpemUgPSAwLjA7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwb3NzaWJsZUNlbnRlcnNfMSA9IF9fdmFsdWVzKHBvc3NpYmxlQ2VudGVycyksIHBvc3NpYmxlQ2VudGVyc18xXzEgPSBwb3NzaWJsZUNlbnRlcnNfMS5uZXh0KCk7ICFwb3NzaWJsZUNlbnRlcnNfMV8xLmRvbmU7IHBvc3NpYmxlQ2VudGVyc18xXzEgPSBwb3NzaWJsZUNlbnRlcnNfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVDZW50ZXIgPSBwb3NzaWJsZUNlbnRlcnNfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsTW9kdWxlU2l6ZSArPSBwb3NzaWJsZUNlbnRlci5nZXRFc3RpbWF0ZWRNb2R1bGVTaXplKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfNV8xKSB7IGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07IH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NzaWJsZUNlbnRlcnNfMV8xICYmICFwb3NzaWJsZUNlbnRlcnNfMV8xLmRvbmUgJiYgKF9iID0gcG9zc2libGVDZW50ZXJzXzEucmV0dXJuKSkgX2IuY2FsbChwb3NzaWJsZUNlbnRlcnNfMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXZlcmFnZSA9IHRvdGFsTW9kdWxlU2l6ZSAvIHBvc3NpYmxlQ2VudGVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVycy5zb3J0KFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogPHA+T3JkZXJzIGJ5IHtAbGluayBGaW5kZXJQYXR0ZXJuI2dldENvdW50KCl9LCBkZXNjZW5kaW5nLjwvcD5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIC8vIENlbnRlckNvbXBhcmF0b3IgaW1wbGVtZW50cyBDb21wYXJhdG9yPEZpbmRlclBhdHRlcm4+XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIChjZW50ZXIxLCBjZW50ZXIyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2VudGVyMi5nZXRDb3VudCgpID09PSBjZW50ZXIxLmdldENvdW50KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZEEgPSBNYXRoLmFicyhjZW50ZXIyLmdldEVzdGltYXRlZE1vZHVsZVNpemUoKSAtIGF2ZXJhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkQiA9IE1hdGguYWJzKGNlbnRlcjEuZ2V0RXN0aW1hdGVkTW9kdWxlU2l6ZSgpIC0gYXZlcmFnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRBIDwgZEIgPyAxIDogZEEgPiBkQiA/IC0xIDogMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjZW50ZXIyLmdldENvdW50KCkgLSBjZW50ZXIxLmdldENvdW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnMuc3BsaWNlKDMpOyAvLyB0aGlzIGlzIG5vdCByZWFseSBuZWNlc3NhcnkgYXMgd2Ugb25seSByZXR1cm4gZmlyc3QgMyBhbnl3YXlcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgcG9zc2libGVDZW50ZXJzWzBdLFxyXG4gICAgICAgICAgICBwb3NzaWJsZUNlbnRlcnNbMV0sXHJcbiAgICAgICAgICAgIHBvc3NpYmxlQ2VudGVyc1syXVxyXG4gICAgICAgIF07XHJcbiAgICB9O1xyXG4gICAgRmluZGVyUGF0dGVybkZpbmRlci5DRU5URVJfUVVPUlVNID0gMjtcclxuICAgIEZpbmRlclBhdHRlcm5GaW5kZXIuTUlOX1NLSVAgPSAzOyAvLyAxIHBpeGVsL21vZHVsZSB0aW1lcyAzIG1vZHVsZXMvY2VudGVyXHJcbiAgICBGaW5kZXJQYXR0ZXJuRmluZGVyLk1BWF9NT0RVTEVTID0gNTc7IC8vIHN1cHBvcnQgdXAgdG8gdmVyc2lvbiAxMCBmb3IgbW9iaWxlIGNsaWVudHNcclxuICAgIHJldHVybiBGaW5kZXJQYXR0ZXJuRmluZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBGaW5kZXJQYXR0ZXJuRmluZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaW5kZXJQYXR0ZXJuRmluZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwNyBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIDxwPkVuY2Fwc3VsYXRlcyBpbmZvcm1hdGlvbiBhYm91dCBmaW5kZXIgcGF0dGVybnMgaW4gYW4gaW1hZ2UsIGluY2x1ZGluZyB0aGUgbG9jYXRpb24gb2ZcclxuICogdGhlIHRocmVlIGZpbmRlciBwYXR0ZXJucywgYW5kIHRoZWlyIGVzdGltYXRlZCBtb2R1bGUgc2l6ZS48L3A+XHJcbiAqXHJcbiAqIEBhdXRob3IgU2VhbiBPd2VuXHJcbiAqL1xyXG52YXIgRmluZGVyUGF0dGVybkluZm8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGaW5kZXJQYXR0ZXJuSW5mbyhwYXR0ZXJuQ2VudGVycykge1xyXG4gICAgICAgIHRoaXMuYm90dG9tTGVmdCA9IHBhdHRlcm5DZW50ZXJzWzBdO1xyXG4gICAgICAgIHRoaXMudG9wTGVmdCA9IHBhdHRlcm5DZW50ZXJzWzFdO1xyXG4gICAgICAgIHRoaXMudG9wUmlnaHQgPSBwYXR0ZXJuQ2VudGVyc1syXTtcclxuICAgIH1cclxuICAgIEZpbmRlclBhdHRlcm5JbmZvLnByb3RvdHlwZS5nZXRCb3R0b21MZWZ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbUxlZnQ7XHJcbiAgICB9O1xyXG4gICAgRmluZGVyUGF0dGVybkluZm8ucHJvdG90eXBlLmdldFRvcExlZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wTGVmdDtcclxuICAgIH07XHJcbiAgICBGaW5kZXJQYXR0ZXJuSW5mby5wcm90b3R5cGUuZ2V0VG9wUmlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wUmlnaHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZpbmRlclBhdHRlcm5JbmZvO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBGaW5kZXJQYXR0ZXJuSW5mbztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmluZGVyUGF0dGVybkluZm8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5lbmNvZGVyIHsqL1xyXG52YXIgQmxvY2tQYWlyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQmxvY2tQYWlyKGRhdGFCeXRlcywgZXJyb3JDb3JyZWN0aW9uQnl0ZXMpIHtcclxuICAgICAgICB0aGlzLmRhdGFCeXRlcyA9IGRhdGFCeXRlcztcclxuICAgICAgICB0aGlzLmVycm9yQ29ycmVjdGlvbkJ5dGVzID0gZXJyb3JDb3JyZWN0aW9uQnl0ZXM7XHJcbiAgICB9XHJcbiAgICBCbG9ja1BhaXIucHJvdG90eXBlLmdldERhdGFCeXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhQnl0ZXM7XHJcbiAgICB9O1xyXG4gICAgQmxvY2tQYWlyLnByb3RvdHlwZS5nZXRFcnJvckNvcnJlY3Rpb25CeXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lcnJvckNvcnJlY3Rpb25CeXRlcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gQmxvY2tQYWlyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCbG9ja1BhaXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb2NrUGFpci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLypcclxuICogQ29weXJpZ2h0IDIwMDggWlhpbmcgYXV0aG9yc1xyXG4gKlxyXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4gKlxyXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4gKlxyXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAqL1xyXG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qbmFtZXNwYWNlIGNvbS5nb29nbGUuenhpbmcucXJjb2RlLmVuY29kZXIgeyovXHJcbi8qaW1wb3J0IGphdmEudXRpbC5BcnJheXM7Ki9cclxudmFyIEFycmF5c18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvQXJyYXlzXCIpO1xyXG52YXIgU3RyaW5nQnVpbGRlcl8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvU3RyaW5nQnVpbGRlclwiKTtcclxuLyoqXHJcbiAqIEpBVkFQT1JUOiBUaGUgb3JpZ2luYWwgY29kZSB3YXMgYSAyRCBhcnJheSBvZiBpbnRzLCBidXQgc2luY2UgaXQgb25seSBldmVyIGdldHMgYXNzaWduZWRcclxuICogLTEsIDAsIGFuZCAxLCBJJ20gZ29pbmcgdG8gdXNlIGxlc3MgbWVtb3J5IGFuZCBnbyB3aXRoIGJ5dGVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKVxyXG4gKi9cclxudmFyIEJ5dGVNYXRyaXggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBCeXRlTWF0cml4KHdpZHRoIC8qaW50Ki8sIGhlaWdodCAvKmludCovKSB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShoZWlnaHQpOyAvLyBbaGVpZ2h0XVt3aWR0aF1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gaGVpZ2h0OyBpKyspIHtcclxuICAgICAgICAgICAgYnl0ZXNbaV0gPSBuZXcgVWludDhBcnJheSh3aWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnl0ZXMgPSBieXRlcztcclxuICAgIH1cclxuICAgIEJ5dGVNYXRyaXgucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XHJcbiAgICB9O1xyXG4gICAgQnl0ZU1hdHJpeC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XHJcbiAgICB9O1xyXG4gICAgQnl0ZU1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHggLyppbnQqLywgeSAvKmludCovKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbeV1beF07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJuIGFuIGludGVybmFsIHJlcHJlc2VudGF0aW9uIGFzIGJ5dGVzLCBpbiByb3ctbWFqb3Igb3JkZXIuIGFycmF5W3ldW3hdIHJlcHJlc2VudHMgcG9pbnQgKHgseSlcclxuICAgICAqL1xyXG4gICAgQnl0ZU1hdHJpeC5wcm90b3R5cGUuZ2V0QXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gVFlQRVNDUklQVFBPUlQ6IHByZWZmZXIgdG8gbGV0IHR3byBtZXRob2RzIGluc3RlYWQgb2Ygb3ZlcnJpZGUgdG8gYXZvaWQgdHlwZSBjb21wYXJpc29uIGluc2lkZVxyXG4gICAgQnl0ZU1hdHJpeC5wcm90b3R5cGUuc2V0TnVtYmVyID0gZnVuY3Rpb24gKHggLyppbnQqLywgeSAvKmludCovLCB2YWx1ZSAvKmJ5dGV8aW50Ki8pIHtcclxuICAgICAgICB0aGlzLmJ5dGVzW3ldW3hdID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgLy8gcHVibGljIHNldCh4OiBudW1iZXIgLyppbnQqLywgeTogbnVtYmVyIC8qaW50Ki8sIHZhbHVlOiBudW1iZXIgLyppbnQqLyk6IHZvaWQge1xyXG4gICAgLy8gICBieXRlc1t5XVt4XSA9IChieXRlKSB2YWx1ZVxyXG4gICAgLy8gfVxyXG4gICAgQnl0ZU1hdHJpeC5wcm90b3R5cGUuc2V0Qm9vbGVhbiA9IGZ1bmN0aW9uICh4IC8qaW50Ki8sIHkgLyppbnQqLywgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJ5dGVzW3ldW3hdID0gLyooYnl0ZSkgKi8gKHZhbHVlID8gMSA6IDApO1xyXG4gICAgfTtcclxuICAgIEJ5dGVNYXRyaXgucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKHZhbHVlIC8qYnl0ZSovKSB7XHJcbiAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLmJ5dGVzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFCeXRlID0gX2MudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBBcnJheXNfMS5kZWZhdWx0LmZpbGwoYUJ5dGUsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQnl0ZU1hdHJpeC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIShvIGluc3RhbmNlb2YgQnl0ZU1hdHJpeCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgb3RoZXIgPSBvO1xyXG4gICAgICAgIGlmICh0aGlzLndpZHRoICE9PSBvdGhlci53aWR0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gb3RoZXIuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDAsIGhlaWdodCA9IHRoaXMuaGVpZ2h0OyB5IDwgaGVpZ2h0OyArK3kpIHtcclxuICAgICAgICAgICAgdmFyIGJ5dGVzWSA9IHRoaXMuYnl0ZXNbeV07XHJcbiAgICAgICAgICAgIHZhciBvdGhlckJ5dGVzWSA9IG90aGVyLmJ5dGVzW3ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMCwgd2lkdGggPSB0aGlzLndpZHRoOyB4IDwgd2lkdGg7ICsreCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzWVt4XSAhPT0gb3RoZXJCeXRlc1lbeF0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgQnl0ZU1hdHJpeC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBTdHJpbmdCdWlsZGVyXzEuZGVmYXVsdCgpOyAvLyAoMiAqIHdpZHRoICogaGVpZ2h0ICsgMilcclxuICAgICAgICBmb3IgKHZhciB5ID0gMCwgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7IHkgPCBoZWlnaHQ7ICsreSkge1xyXG4gICAgICAgICAgICB2YXIgYnl0ZXNZID0gdGhpcy5ieXRlc1t5XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHdpZHRoID0gdGhpcy53aWR0aDsgeCA8IHdpZHRoOyArK3gpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYnl0ZXNZW3hdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXBwZW5kKCcgMCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyAxJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJyAgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJ5dGVNYXRyaXg7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJ5dGVNYXRyaXg7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ5dGVNYXRyaXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5lbmNvZGVyIHsqL1xyXG52YXIgRW5jb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuLi8uLi9FbmNvZGVIaW50VHlwZVwiKTtcclxudmFyIEJpdEFycmF5XzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0JpdEFycmF5XCIpO1xyXG52YXIgQ2hhcmFjdGVyU2V0RUNJXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL0NoYXJhY3RlclNldEVDSVwiKTtcclxudmFyIEdlbmVyaWNHRl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi9yZWVkc29sb21vbi9HZW5lcmljR0ZcIik7XHJcbnZhciBSZWVkU29sb21vbkVuY29kZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25FbmNvZGVyXCIpO1xyXG52YXIgTW9kZV8xID0gcmVxdWlyZShcIi4uL2RlY29kZXIvTW9kZVwiKTtcclxudmFyIFZlcnNpb25fMSA9IHJlcXVpcmUoXCIuLi9kZWNvZGVyL1ZlcnNpb25cIik7XHJcbnZhciBNYXNrVXRpbF8xID0gcmVxdWlyZShcIi4vTWFza1V0aWxcIik7XHJcbnZhciBCeXRlTWF0cml4XzEgPSByZXF1aXJlKFwiLi9CeXRlTWF0cml4XCIpO1xyXG52YXIgUVJDb2RlXzEgPSByZXF1aXJlKFwiLi9RUkNvZGVcIik7XHJcbnZhciBNYXRyaXhVdGlsXzEgPSByZXF1aXJlKFwiLi9NYXRyaXhVdGlsXCIpO1xyXG52YXIgU3RyaW5nRW5jb2RpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N0cmluZ0VuY29kaW5nXCIpO1xyXG52YXIgQmxvY2tQYWlyXzEgPSByZXF1aXJlKFwiLi9CbG9ja1BhaXJcIik7XHJcbnZhciBXcml0ZXJFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Xcml0ZXJFeGNlcHRpb25cIik7XHJcbi8qaW1wb3J0IGphdmEuaW8uVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbjsqL1xyXG4vKmltcG9ydCBqYXZhLnV0aWwuQXJyYXlMaXN0OyovXHJcbi8qaW1wb3J0IGphdmEudXRpbC5Db2xsZWN0aW9uOyovXHJcbi8qaW1wb3J0IGphdmEudXRpbC5NYXA7Ki9cclxuLyoqXHJcbiAqIEBhdXRob3Igc2F0b3J1eEBnb29nbGUuY29tIChTYXRvcnUgVGFrYWJheWFzaGkpIC0gY3JlYXRvclxyXG4gKiBAYXV0aG9yIGRzd2l0a2luQGdvb2dsZS5jb20gKERhbmllbCBTd2l0a2luKSAtIHBvcnRlZCBmcm9tIEMrK1xyXG4gKi9cclxudmFyIEVuY29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBUWVBFU0NSSVBUUE9SVDogY2hhbmdlZCB0byBVVEY4LCB0aGUgZGVmYXVsdCBmb3IganNcclxuICAgIGZ1bmN0aW9uIEVuY29kZXIoKSB7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgbWFzayBwZW5hbHR5IGNhbGN1bGF0aW9uIGlzIGNvbXBsaWNhdGVkLiAgU2VlIFRhYmxlIDIxIG9mIEpJU1gwNTEwOjIwMDQgKHAuNDUpIGZvciBkZXRhaWxzLlxyXG4gICAgLy8gQmFzaWNhbGx5IGl0IGFwcGxpZXMgZm91ciBydWxlcyBhbmQgc3VtbWF0ZSBhbGwgcGVuYWx0aWVzLlxyXG4gICAgRW5jb2Rlci5jYWxjdWxhdGVNYXNrUGVuYWx0eSA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcclxuICAgICAgICByZXR1cm4gTWFza1V0aWxfMS5kZWZhdWx0LmFwcGx5TWFza1BlbmFsdHlSdWxlMShtYXRyaXgpXHJcbiAgICAgICAgICAgICsgTWFza1V0aWxfMS5kZWZhdWx0LmFwcGx5TWFza1BlbmFsdHlSdWxlMihtYXRyaXgpXHJcbiAgICAgICAgICAgICsgTWFza1V0aWxfMS5kZWZhdWx0LmFwcGx5TWFza1BlbmFsdHlSdWxlMyhtYXRyaXgpXHJcbiAgICAgICAgICAgICsgTWFza1V0aWxfMS5kZWZhdWx0LmFwcGx5TWFza1BlbmFsdHlSdWxlNChtYXRyaXgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbnRlbnQgdGV4dCB0byBlbmNvZGVcclxuICAgICAqIEBwYXJhbSBlY0xldmVsIGVycm9yIGNvcnJlY3Rpb24gbGV2ZWwgdG8gdXNlXHJcbiAgICAgKiBAcmV0dXJuIHtAbGluayBRUkNvZGV9IHJlcHJlc2VudGluZyB0aGUgZW5jb2RlZCBRUiBjb2RlXHJcbiAgICAgKiBAdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiBpZiBlbmNvZGluZyBjYW4ndCBzdWNjZWVkLCBiZWNhdXNlIG9mIGZvciBleGFtcGxlIGludmFsaWQgY29udGVudFxyXG4gICAgICogICBvciBjb25maWd1cmF0aW9uXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyBzdGF0aWMgZW5jb2RlKGNvbnRlbnQ6IHN0cmluZywgZWNMZXZlbDogRXJyb3JDb3JyZWN0aW9uTGV2ZWwpOiBRUkNvZGUgLyp0aHJvd3MgV3JpdGVyRXhjZXB0aW9uKi8ge1xyXG4gICAgLy8gICByZXR1cm4gZW5jb2RlKGNvbnRlbnQsIGVjTGV2ZWwsIG51bGwpXHJcbiAgICAvLyB9XHJcbiAgICBFbmNvZGVyLmVuY29kZSA9IGZ1bmN0aW9uIChjb250ZW50LCBlY0xldmVsLCBoaW50cykge1xyXG4gICAgICAgIGlmIChoaW50cyA9PT0gdm9pZCAwKSB7IGhpbnRzID0gbnVsbDsgfVxyXG4gICAgICAgIC8vIERldGVybWluZSB3aGF0IGNoYXJhY3RlciBlbmNvZGluZyBoYXMgYmVlbiBzcGVjaWZpZWQgYnkgdGhlIGNhbGxlciwgaWYgYW55XHJcbiAgICAgICAgdmFyIGVuY29kaW5nID0gRW5jb2Rlci5ERUZBVUxUX0JZVEVfTU9ERV9FTkNPRElORztcclxuICAgICAgICB2YXIgaGFzRW5jb2RpbmdIaW50ID0gaGludHMgIT09IG51bGwgJiYgdW5kZWZpbmVkICE9PSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LkNIQVJBQ1RFUl9TRVQpO1xyXG4gICAgICAgIGlmIChoYXNFbmNvZGluZ0hpbnQpIHtcclxuICAgICAgICAgICAgZW5jb2RpbmcgPSBoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LkNIQVJBQ1RFUl9TRVQpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBpY2sgYW4gZW5jb2RpbmcgbW9kZSBhcHByb3ByaWF0ZSBmb3IgdGhlIGNvbnRlbnQuIE5vdGUgdGhhdCB0aGlzIHdpbGwgbm90IGF0dGVtcHQgdG8gdXNlXHJcbiAgICAgICAgLy8gbXVsdGlwbGUgbW9kZXMgLyBzZWdtZW50cyBldmVuIGlmIHRoYXQgd2VyZSBtb3JlIGVmZmljaWVudC4gVHdvdWxkIGJlIG5pY2UuXHJcbiAgICAgICAgdmFyIG1vZGUgPSB0aGlzLmNob29zZU1vZGUoY29udGVudCwgZW5jb2RpbmcpO1xyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBzdG9yZSB0aGUgaGVhZGVyIGluZm9ybWF0aW9uLCBsaWtlIG1vZGUgYW5kXHJcbiAgICAgICAgLy8gbGVuZ3RoLCBhcyB3ZWxsIGFzIFwiaGVhZGVyXCIgc2VnbWVudHMgbGlrZSBhbiBFQ0kgc2VnbWVudC5cclxuICAgICAgICB2YXIgaGVhZGVyQml0cyA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQoKTtcclxuICAgICAgICAvLyBBcHBlbmQgRUNJIHNlZ21lbnQgaWYgYXBwbGljYWJsZVxyXG4gICAgICAgIGlmIChtb2RlID09PSBNb2RlXzEuZGVmYXVsdC5CWVRFICYmIChoYXNFbmNvZGluZ0hpbnQgfHwgRW5jb2Rlci5ERUZBVUxUX0JZVEVfTU9ERV9FTkNPRElORyAhPT0gZW5jb2RpbmcpKSB7XHJcbiAgICAgICAgICAgIHZhciBlY2kgPSBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LmdldENoYXJhY3RlclNldEVDSUJ5TmFtZShlbmNvZGluZyk7XHJcbiAgICAgICAgICAgIGlmIChlY2kgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFQ0koZWNpLCBoZWFkZXJCaXRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyAoV2l0aCBFQ0kgaW4gcGxhY2UsKSBXcml0ZSB0aGUgbW9kZSBtYXJrZXJcclxuICAgICAgICB0aGlzLmFwcGVuZE1vZGVJbmZvKG1vZGUsIGhlYWRlckJpdHMpO1xyXG4gICAgICAgIC8vIENvbGxlY3QgZGF0YSB3aXRoaW4gdGhlIG1haW4gc2VnbWVudCwgc2VwYXJhdGVseSwgdG8gY291bnQgaXRzIHNpemUgaWYgbmVlZGVkLiBEb24ndCBhZGQgaXQgdG9cclxuICAgICAgICAvLyBtYWluIHBheWxvYWQgeWV0LlxyXG4gICAgICAgIHZhciBkYXRhQml0cyA9IG5ldyBCaXRBcnJheV8xLmRlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLmFwcGVuZEJ5dGVzKGNvbnRlbnQsIG1vZGUsIGRhdGFCaXRzLCBlbmNvZGluZyk7XHJcbiAgICAgICAgdmFyIHZlcnNpb247XHJcbiAgICAgICAgaWYgKGhpbnRzICE9PSBudWxsICYmIHVuZGVmaW5lZCAhPT0gaGludHMuZ2V0KEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdC5RUl9WRVJTSU9OKSkge1xyXG4gICAgICAgICAgICB2YXIgdmVyc2lvbk51bWJlciA9IE51bWJlci5wYXJzZUludChoaW50cy5nZXQoRW5jb2RlSGludFR5cGVfMS5kZWZhdWx0LlFSX1ZFUlNJT04pLnRvU3RyaW5nKCksIDEwKTtcclxuICAgICAgICAgICAgdmVyc2lvbiA9IFZlcnNpb25fMS5kZWZhdWx0LmdldFZlcnNpb25Gb3JOdW1iZXIodmVyc2lvbk51bWJlcik7XHJcbiAgICAgICAgICAgIHZhciBiaXRzTmVlZGVkID0gdGhpcy5jYWxjdWxhdGVCaXRzTmVlZGVkKG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzLCB2ZXJzaW9uKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLndpbGxGaXQoYml0c05lZWRlZCwgdmVyc2lvbiwgZWNMZXZlbCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdEYXRhIHRvbyBiaWcgZm9yIHJlcXVlc3RlZCB2ZXJzaW9uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZlcnNpb24gPSB0aGlzLnJlY29tbWVuZFZlcnNpb24oZWNMZXZlbCwgbW9kZSwgaGVhZGVyQml0cywgZGF0YUJpdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGVhZGVyQW5kRGF0YUJpdHMgPSBuZXcgQml0QXJyYXlfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgaGVhZGVyQW5kRGF0YUJpdHMuYXBwZW5kQml0QXJyYXkoaGVhZGVyQml0cyk7XHJcbiAgICAgICAgLy8gRmluZCBcImxlbmd0aFwiIG9mIG1haW4gc2VnbWVudCBhbmQgd3JpdGUgaXRcclxuICAgICAgICB2YXIgbnVtTGV0dGVycyA9IG1vZGUgPT09IE1vZGVfMS5kZWZhdWx0LkJZVEUgPyBkYXRhQml0cy5nZXRTaXplSW5CeXRlcygpIDogY29udGVudC5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5hcHBlbmRMZW5ndGhJbmZvKG51bUxldHRlcnMsIHZlcnNpb24sIG1vZGUsIGhlYWRlckFuZERhdGFCaXRzKTtcclxuICAgICAgICAvLyBQdXQgZGF0YSB0b2dldGhlciBpbnRvIHRoZSBvdmVyYWxsIHBheWxvYWRcclxuICAgICAgICBoZWFkZXJBbmREYXRhQml0cy5hcHBlbmRCaXRBcnJheShkYXRhQml0cyk7XHJcbiAgICAgICAgdmFyIGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpO1xyXG4gICAgICAgIHZhciBudW1EYXRhQnl0ZXMgPSB2ZXJzaW9uLmdldFRvdGFsQ29kZXdvcmRzKCkgLSBlY0Jsb2Nrcy5nZXRUb3RhbEVDQ29kZXdvcmRzKCk7XHJcbiAgICAgICAgLy8gVGVybWluYXRlIHRoZSBiaXRzIHByb3Blcmx5LlxyXG4gICAgICAgIHRoaXMudGVybWluYXRlQml0cyhudW1EYXRhQnl0ZXMsIGhlYWRlckFuZERhdGFCaXRzKTtcclxuICAgICAgICAvLyBJbnRlcmxlYXZlIGRhdGEgYml0cyB3aXRoIGVycm9yIGNvcnJlY3Rpb24gY29kZS5cclxuICAgICAgICB2YXIgZmluYWxCaXRzID0gdGhpcy5pbnRlcmxlYXZlV2l0aEVDQnl0ZXMoaGVhZGVyQW5kRGF0YUJpdHMsIHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKSwgbnVtRGF0YUJ5dGVzLCBlY0Jsb2Nrcy5nZXROdW1CbG9ja3MoKSk7XHJcbiAgICAgICAgdmFyIHFyQ29kZSA9IG5ldyBRUkNvZGVfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgcXJDb2RlLnNldEVDTGV2ZWwoZWNMZXZlbCk7XHJcbiAgICAgICAgcXJDb2RlLnNldE1vZGUobW9kZSk7XHJcbiAgICAgICAgcXJDb2RlLnNldFZlcnNpb24odmVyc2lvbik7XHJcbiAgICAgICAgLy8gIENob29zZSB0aGUgbWFzayBwYXR0ZXJuIGFuZCBzZXQgdG8gXCJxckNvZGVcIi5cclxuICAgICAgICB2YXIgZGltZW5zaW9uID0gdmVyc2lvbi5nZXREaW1lbnNpb25Gb3JWZXJzaW9uKCk7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBCeXRlTWF0cml4XzEuZGVmYXVsdChkaW1lbnNpb24sIGRpbWVuc2lvbik7XHJcbiAgICAgICAgdmFyIG1hc2tQYXR0ZXJuID0gdGhpcy5jaG9vc2VNYXNrUGF0dGVybihmaW5hbEJpdHMsIGVjTGV2ZWwsIHZlcnNpb24sIG1hdHJpeCk7XHJcbiAgICAgICAgcXJDb2RlLnNldE1hc2tQYXR0ZXJuKG1hc2tQYXR0ZXJuKTtcclxuICAgICAgICAvLyBCdWlsZCB0aGUgbWF0cml4IGFuZCBzZXQgaXQgdG8gXCJxckNvZGVcIi5cclxuICAgICAgICBNYXRyaXhVdGlsXzEuZGVmYXVsdC5idWlsZE1hdHJpeChmaW5hbEJpdHMsIGVjTGV2ZWwsIHZlcnNpb24sIG1hc2tQYXR0ZXJuLCBtYXRyaXgpO1xyXG4gICAgICAgIHFyQ29kZS5zZXRNYXRyaXgobWF0cml4KTtcclxuICAgICAgICByZXR1cm4gcXJDb2RlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVjaWRlcyB0aGUgc21hbGxlc3QgdmVyc2lvbiBvZiBRUiBjb2RlIHRoYXQgd2lsbCBjb250YWluIGFsbCBvZiB0aGUgcHJvdmlkZWQgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIFdyaXRlckV4Y2VwdGlvbiBpZiB0aGUgZGF0YSBjYW5ub3QgZml0IGluIGFueSB2ZXJzaW9uXHJcbiAgICAgKi9cclxuICAgIEVuY29kZXIucmVjb21tZW5kVmVyc2lvbiA9IGZ1bmN0aW9uIChlY0xldmVsLCBtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cykge1xyXG4gICAgICAgIC8vIEhhcmQgcGFydDogbmVlZCB0byBrbm93IHZlcnNpb24gdG8ga25vdyBob3cgbWFueSBiaXRzIGxlbmd0aCB0YWtlcy4gQnV0IG5lZWQgdG8ga25vdyBob3cgbWFueVxyXG4gICAgICAgIC8vIGJpdHMgaXQgdGFrZXMgdG8ga25vdyB2ZXJzaW9uLiBGaXJzdCB3ZSB0YWtlIGEgZ3Vlc3MgYXQgdmVyc2lvbiBieSBhc3N1bWluZyB2ZXJzaW9uIHdpbGwgYmVcclxuICAgICAgICAvLyB0aGUgbWluaW11bSwgMTpcclxuICAgICAgICB2YXIgcHJvdmlzaW9uYWxCaXRzTmVlZGVkID0gdGhpcy5jYWxjdWxhdGVCaXRzTmVlZGVkKG1vZGUsIGhlYWRlckJpdHMsIGRhdGFCaXRzLCBWZXJzaW9uXzEuZGVmYXVsdC5nZXRWZXJzaW9uRm9yTnVtYmVyKDEpKTtcclxuICAgICAgICB2YXIgcHJvdmlzaW9uYWxWZXJzaW9uID0gdGhpcy5jaG9vc2VWZXJzaW9uKHByb3Zpc2lvbmFsQml0c05lZWRlZCwgZWNMZXZlbCk7XHJcbiAgICAgICAgLy8gVXNlIHRoYXQgZ3Vlc3MgdG8gY2FsY3VsYXRlIHRoZSByaWdodCB2ZXJzaW9uLiBJIGFtIHN0aWxsIG5vdCBzdXJlIHRoaXMgd29ya3MgaW4gMTAwJSBvZiBjYXNlcy5cclxuICAgICAgICB2YXIgYml0c05lZWRlZCA9IHRoaXMuY2FsY3VsYXRlQml0c05lZWRlZChtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cywgcHJvdmlzaW9uYWxWZXJzaW9uKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jaG9vc2VWZXJzaW9uKGJpdHNOZWVkZWQsIGVjTGV2ZWwpO1xyXG4gICAgfTtcclxuICAgIEVuY29kZXIuY2FsY3VsYXRlQml0c05lZWRlZCA9IGZ1bmN0aW9uIChtb2RlLCBoZWFkZXJCaXRzLCBkYXRhQml0cywgdmVyc2lvbikge1xyXG4gICAgICAgIHJldHVybiBoZWFkZXJCaXRzLmdldFNpemUoKSArIG1vZGUuZ2V0Q2hhcmFjdGVyQ291bnRCaXRzKHZlcnNpb24pICsgZGF0YUJpdHMuZ2V0U2l6ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB0aGUgY29kZSBwb2ludCBvZiB0aGUgdGFibGUgdXNlZCBpbiBhbHBoYW51bWVyaWMgbW9kZSBvclxyXG4gICAgICogIC0xIGlmIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgY29kZSBpbiB0aGUgdGFibGUuXHJcbiAgICAgKi9cclxuICAgIEVuY29kZXIuZ2V0QWxwaGFudW1lcmljQ29kZSA9IGZ1bmN0aW9uIChjb2RlIC8qaW50Ki8pIHtcclxuICAgICAgICBpZiAoY29kZSA8IEVuY29kZXIuQUxQSEFOVU1FUklDX1RBQkxFLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gRW5jb2Rlci5BTFBIQU5VTUVSSUNfVEFCTEVbY29kZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH07XHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIGNob29zZU1vZGUoY29udGVudDogc3RyaW5nKTogTW9kZSB7XHJcbiAgICAvLyAgIHJldHVybiBjaG9vc2VNb2RlKGNvbnRlbnQsIG51bGwpO1xyXG4gICAgLy8gfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaG9vc2UgdGhlIGJlc3QgbW9kZSBieSBleGFtaW5pbmcgdGhlIGNvbnRlbnQuIE5vdGUgdGhhdCAnZW5jb2RpbmcnIGlzIHVzZWQgYXMgYSBoaW50O1xyXG4gICAgICogaWYgaXQgaXMgU2hpZnRfSklTLCBhbmQgdGhlIGlucHV0IGlzIG9ubHkgZG91YmxlLWJ5dGUgS2FuamksIHRoZW4gd2UgcmV0dXJuIHtAbGluayBNb2RlI0tBTkpJfS5cclxuICAgICAqL1xyXG4gICAgRW5jb2Rlci5jaG9vc2VNb2RlID0gZnVuY3Rpb24gKGNvbnRlbnQsIGVuY29kaW5nKSB7XHJcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSB2b2lkIDApIHsgZW5jb2RpbmcgPSBudWxsOyB9XHJcbiAgICAgICAgaWYgKENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQuU0pJUy5nZXROYW1lKCkgPT09IGVuY29kaW5nICYmIHRoaXMuaXNPbmx5RG91YmxlQnl0ZUthbmppKGNvbnRlbnQpKSB7XHJcbiAgICAgICAgICAgIC8vIENob29zZSBLYW5qaSBtb2RlIGlmIGFsbCBpbnB1dCBhcmUgZG91YmxlLWJ5dGUgY2hhcmFjdGVyc1xyXG4gICAgICAgICAgICByZXR1cm4gTW9kZV8xLmRlZmF1bHQuS0FOSkk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoYXNOdW1lcmljID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGhhc0FscGhhbnVtZXJpYyA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IGNvbnRlbnQubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgYyA9IGNvbnRlbnQuY2hhckF0KGkpO1xyXG4gICAgICAgICAgICBpZiAoRW5jb2Rlci5pc0RpZ2l0KGMpKSB7XHJcbiAgICAgICAgICAgICAgICBoYXNOdW1lcmljID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmdldEFscGhhbnVtZXJpY0NvZGUoYy5jaGFyQ29kZUF0KDApKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGhhc0FscGhhbnVtZXJpYyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTW9kZV8xLmRlZmF1bHQuQllURTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzQWxwaGFudW1lcmljKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNb2RlXzEuZGVmYXVsdC5BTFBIQU5VTUVSSUM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNOdW1lcmljKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNb2RlXzEuZGVmYXVsdC5OVU1FUklDO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTW9kZV8xLmRlZmF1bHQuQllURTtcclxuICAgIH07XHJcbiAgICBFbmNvZGVyLmlzT25seURvdWJsZUJ5dGVLYW5qaSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgdmFyIGJ5dGVzO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGJ5dGVzID0gU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmVuY29kZShjb250ZW50LCBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LlNKSVMpOyAvLyBjb250ZW50LmdldEJ5dGVzKFwiU2hpZnRfSklTXCIpKVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoaWdub3JlZCAvKjogVW5zdXBwb3J0ZWRFbmNvZGluZ0V4Y2VwdGlvbiovKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgICBpZiAobGVuZ3RoICUgMiAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIGJ5dGUxID0gYnl0ZXNbaV0gJiAweEZGO1xyXG4gICAgICAgICAgICBpZiAoKGJ5dGUxIDwgMHg4MSB8fCBieXRlMSA+IDB4OUYpICYmIChieXRlMSA8IDB4RTAgfHwgYnl0ZTEgPiAweEVCKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIEVuY29kZXIuY2hvb3NlTWFza1BhdHRlcm4gPSBmdW5jdGlvbiAoYml0cywgZWNMZXZlbCwgdmVyc2lvbiwgbWF0cml4KSB7XHJcbiAgICAgICAgdmFyIG1pblBlbmFsdHkgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjsgLy8gTG93ZXIgcGVuYWx0eSBpcyBiZXR0ZXIuXHJcbiAgICAgICAgdmFyIGJlc3RNYXNrUGF0dGVybiA9IC0xO1xyXG4gICAgICAgIC8vIFdlIHRyeSBhbGwgbWFzayBwYXR0ZXJucyB0byBjaG9vc2UgdGhlIGJlc3Qgb25lLlxyXG4gICAgICAgIGZvciAodmFyIG1hc2tQYXR0ZXJuID0gMDsgbWFza1BhdHRlcm4gPCBRUkNvZGVfMS5kZWZhdWx0Lk5VTV9NQVNLX1BBVFRFUk5TOyBtYXNrUGF0dGVybisrKSB7XHJcbiAgICAgICAgICAgIE1hdHJpeFV0aWxfMS5kZWZhdWx0LmJ1aWxkTWF0cml4KGJpdHMsIGVjTGV2ZWwsIHZlcnNpb24sIG1hc2tQYXR0ZXJuLCBtYXRyaXgpO1xyXG4gICAgICAgICAgICB2YXIgcGVuYWx0eSA9IHRoaXMuY2FsY3VsYXRlTWFza1BlbmFsdHkobWF0cml4KTtcclxuICAgICAgICAgICAgaWYgKHBlbmFsdHkgPCBtaW5QZW5hbHR5KSB7XHJcbiAgICAgICAgICAgICAgICBtaW5QZW5hbHR5ID0gcGVuYWx0eTtcclxuICAgICAgICAgICAgICAgIGJlc3RNYXNrUGF0dGVybiA9IG1hc2tQYXR0ZXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiZXN0TWFza1BhdHRlcm47XHJcbiAgICB9O1xyXG4gICAgRW5jb2Rlci5jaG9vc2VWZXJzaW9uID0gZnVuY3Rpb24gKG51bUlucHV0Qml0cyAvKmludCovLCBlY0xldmVsKSB7XHJcbiAgICAgICAgZm9yICh2YXIgdmVyc2lvbk51bSA9IDE7IHZlcnNpb25OdW0gPD0gNDA7IHZlcnNpb25OdW0rKykge1xyXG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IFZlcnNpb25fMS5kZWZhdWx0LmdldFZlcnNpb25Gb3JOdW1iZXIodmVyc2lvbk51bSk7XHJcbiAgICAgICAgICAgIGlmIChFbmNvZGVyLndpbGxGaXQobnVtSW5wdXRCaXRzLCB2ZXJzaW9uLCBlY0xldmVsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnNpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0RhdGEgdG9vIGJpZycpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybiB0cnVlIGlmIHRoZSBudW1iZXIgb2YgaW5wdXQgYml0cyB3aWxsIGZpdCBpbiBhIGNvZGUgd2l0aCB0aGUgc3BlY2lmaWVkIHZlcnNpb24gYW5kXHJcbiAgICAgKiBlcnJvciBjb3JyZWN0aW9uIGxldmVsLlxyXG4gICAgICovXHJcbiAgICBFbmNvZGVyLndpbGxGaXQgPSBmdW5jdGlvbiAobnVtSW5wdXRCaXRzIC8qaW50Ki8sIHZlcnNpb24sIGVjTGV2ZWwpIHtcclxuICAgICAgICAvLyBJbiB0aGUgZm9sbG93aW5nIGNvbW1lbnRzLCB3ZSB1c2UgbnVtYmVycyBvZiBWZXJzaW9uIDctSC5cclxuICAgICAgICAvLyBudW1CeXRlcyA9IDE5NlxyXG4gICAgICAgIHZhciBudW1CeXRlcyA9IHZlcnNpb24uZ2V0VG90YWxDb2Rld29yZHMoKTtcclxuICAgICAgICAvLyBnZXROdW1FQ0J5dGVzID0gMTMwXHJcbiAgICAgICAgdmFyIGVjQmxvY2tzID0gdmVyc2lvbi5nZXRFQ0Jsb2Nrc0ZvckxldmVsKGVjTGV2ZWwpO1xyXG4gICAgICAgIHZhciBudW1FY0J5dGVzID0gZWNCbG9ja3MuZ2V0VG90YWxFQ0NvZGV3b3JkcygpO1xyXG4gICAgICAgIC8vIGdldE51bURhdGFCeXRlcyA9IDE5NiAtIDEzMCA9IDY2XHJcbiAgICAgICAgdmFyIG51bURhdGFCeXRlcyA9IG51bUJ5dGVzIC0gbnVtRWNCeXRlcztcclxuICAgICAgICB2YXIgdG90YWxJbnB1dEJ5dGVzID0gKG51bUlucHV0Qml0cyArIDcpIC8gODtcclxuICAgICAgICByZXR1cm4gbnVtRGF0YUJ5dGVzID49IHRvdGFsSW5wdXRCeXRlcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRlcm1pbmF0ZSBiaXRzIGFzIGRlc2NyaWJlZCBpbiA4LjQuOCBhbmQgOC40Ljkgb2YgSklTWDA1MTA6MjAwNCAocC4yNCkuXHJcbiAgICAgKi9cclxuICAgIEVuY29kZXIudGVybWluYXRlQml0cyA9IGZ1bmN0aW9uIChudW1EYXRhQnl0ZXMgLyppbnQqLywgYml0cykge1xyXG4gICAgICAgIHZhciBjYXBhY2l0eSA9IG51bURhdGFCeXRlcyAqIDg7XHJcbiAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZSgpID4gY2FwYWNpdHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ2RhdGEgYml0cyBjYW5ub3QgZml0IGluIHRoZSBRUiBDb2RlJyArIGJpdHMuZ2V0U2l6ZSgpICsgJyA+ICcgK1xyXG4gICAgICAgICAgICAgICAgY2FwYWNpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgYml0cy5nZXRTaXplKCkgPCBjYXBhY2l0eTsgKytpKSB7XHJcbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0KGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQXBwZW5kIHRlcm1pbmF0aW9uIGJpdHMuIFNlZSA4LjQuOCBvZiBKSVNYMDUxMDoyMDA0IChwLjI0KSBmb3IgZGV0YWlscy5cclxuICAgICAgICAvLyBJZiB0aGUgbGFzdCBieXRlIGlzbid0IDgtYml0IGFsaWduZWQsIHdlJ2xsIGFkZCBwYWRkaW5nIGJpdHMuXHJcbiAgICAgICAgdmFyIG51bUJpdHNJbkxhc3RCeXRlID0gYml0cy5nZXRTaXplKCkgJiAweDA3O1xyXG4gICAgICAgIGlmIChudW1CaXRzSW5MYXN0Qnl0ZSA+IDApIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IG51bUJpdHNJbkxhc3RCeXRlOyBpIDwgODsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdChmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHNwYWNlLCB3ZSdsbCBmaWxsIHRoZSBzcGFjZSB3aXRoIHBhZGRpbmcgcGF0dGVybnMgZGVmaW5lZCBpbiA4LjQuOSAocC4yNCkuXHJcbiAgICAgICAgdmFyIG51bVBhZGRpbmdCeXRlcyA9IG51bURhdGFCeXRlcyAtIGJpdHMuZ2V0U2l6ZUluQnl0ZXMoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBhZGRpbmdCeXRlczsgKytpKSB7XHJcbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cygoaSAmIDB4MDEpID09PSAwID8gMHhFQyA6IDB4MTEsIDgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYml0cy5nZXRTaXplKCkgIT09IGNhcGFjaXR5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdCaXRzIHNpemUgZG9lcyBub3QgZXF1YWwgY2FwYWNpdHknKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgbnVtYmVyIG9mIGRhdGEgYnl0ZXMgYW5kIG51bWJlciBvZiBlcnJvciBjb3JyZWN0aW9uIGJ5dGVzIGZvciBibG9jayBpZCBcImJsb2NrSURcIi4gU3RvcmVcclxuICAgICAqIHRoZSByZXN1bHQgaW4gXCJudW1EYXRhQnl0ZXNJbkJsb2NrXCIsIGFuZCBcIm51bUVDQnl0ZXNJbkJsb2NrXCIuIFNlZSB0YWJsZSAxMiBpbiA4LjUuMSBvZlxyXG4gICAgICogSklTWDA1MTA6MjAwNCAocC4zMClcclxuICAgICAqL1xyXG4gICAgRW5jb2Rlci5nZXROdW1EYXRhQnl0ZXNBbmROdW1FQ0J5dGVzRm9yQmxvY2tJRCA9IGZ1bmN0aW9uIChudW1Ub3RhbEJ5dGVzIC8qaW50Ki8sIG51bURhdGFCeXRlcyAvKmludCovLCBudW1SU0Jsb2NrcyAvKmludCovLCBibG9ja0lEIC8qaW50Ki8sIG51bURhdGFCeXRlc0luQmxvY2ssIG51bUVDQnl0ZXNJbkJsb2NrKSB7XHJcbiAgICAgICAgaWYgKGJsb2NrSUQgPj0gbnVtUlNCbG9ja3MpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0Jsb2NrIElEIHRvbyBsYXJnZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBudW1Sc0Jsb2Nrc0luR3JvdXAyID0gMTk2ICUgNSA9IDFcclxuICAgICAgICB2YXIgbnVtUnNCbG9ja3NJbkdyb3VwMiA9IG51bVRvdGFsQnl0ZXMgJSBudW1SU0Jsb2NrcztcclxuICAgICAgICAvLyBudW1Sc0Jsb2Nrc0luR3JvdXAxID0gNSAtIDEgPSA0XHJcbiAgICAgICAgdmFyIG51bVJzQmxvY2tzSW5Hcm91cDEgPSBudW1SU0Jsb2NrcyAtIG51bVJzQmxvY2tzSW5Hcm91cDI7XHJcbiAgICAgICAgLy8gbnVtVG90YWxCeXRlc0luR3JvdXAxID0gMTk2IC8gNSA9IDM5XHJcbiAgICAgICAgdmFyIG51bVRvdGFsQnl0ZXNJbkdyb3VwMSA9IE1hdGguZmxvb3IobnVtVG90YWxCeXRlcyAvIG51bVJTQmxvY2tzKTtcclxuICAgICAgICAvLyBudW1Ub3RhbEJ5dGVzSW5Hcm91cDIgPSAzOSArIDEgPSA0MFxyXG4gICAgICAgIHZhciBudW1Ub3RhbEJ5dGVzSW5Hcm91cDIgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgKyAxO1xyXG4gICAgICAgIC8vIG51bURhdGFCeXRlc0luR3JvdXAxID0gNjYgLyA1ID0gMTNcclxuICAgICAgICB2YXIgbnVtRGF0YUJ5dGVzSW5Hcm91cDEgPSBNYXRoLmZsb29yKG51bURhdGFCeXRlcyAvIG51bVJTQmxvY2tzKTtcclxuICAgICAgICAvLyBudW1EYXRhQnl0ZXNJbkdyb3VwMiA9IDEzICsgMSA9IDE0XHJcbiAgICAgICAgdmFyIG51bURhdGFCeXRlc0luR3JvdXAyID0gbnVtRGF0YUJ5dGVzSW5Hcm91cDEgKyAxO1xyXG4gICAgICAgIC8vIG51bUVjQnl0ZXNJbkdyb3VwMSA9IDM5IC0gMTMgPSAyNlxyXG4gICAgICAgIHZhciBudW1FY0J5dGVzSW5Hcm91cDEgPSBudW1Ub3RhbEJ5dGVzSW5Hcm91cDEgLSBudW1EYXRhQnl0ZXNJbkdyb3VwMTtcclxuICAgICAgICAvLyBudW1FY0J5dGVzSW5Hcm91cDIgPSA0MCAtIDE0ID0gMjZcclxuICAgICAgICB2YXIgbnVtRWNCeXRlc0luR3JvdXAyID0gbnVtVG90YWxCeXRlc0luR3JvdXAyIC0gbnVtRGF0YUJ5dGVzSW5Hcm91cDI7XHJcbiAgICAgICAgLy8gU2FuaXR5IGNoZWNrcy5cclxuICAgICAgICAvLyAyNiA9IDI2XHJcbiAgICAgICAgaWYgKG51bUVjQnl0ZXNJbkdyb3VwMSAhPT0gbnVtRWNCeXRlc0luR3JvdXAyKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdFQyBieXRlcyBtaXNtYXRjaCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyA1ID0gNCArIDEuXHJcbiAgICAgICAgaWYgKG51bVJTQmxvY2tzICE9PSBudW1Sc0Jsb2Nrc0luR3JvdXAxICsgbnVtUnNCbG9ja3NJbkdyb3VwMikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgnUlMgYmxvY2tzIG1pc21hdGNoJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIDE5NiA9ICgxMyArIDI2KSAqIDQgKyAoMTQgKyAyNikgKiAxXHJcbiAgICAgICAgaWYgKG51bVRvdGFsQnl0ZXMgIT09XHJcbiAgICAgICAgICAgICgobnVtRGF0YUJ5dGVzSW5Hcm91cDEgKyBudW1FY0J5dGVzSW5Hcm91cDEpICpcclxuICAgICAgICAgICAgICAgIG51bVJzQmxvY2tzSW5Hcm91cDEpICtcclxuICAgICAgICAgICAgICAgICgobnVtRGF0YUJ5dGVzSW5Hcm91cDIgKyBudW1FY0J5dGVzSW5Hcm91cDIpICpcclxuICAgICAgICAgICAgICAgICAgICBudW1Sc0Jsb2Nrc0luR3JvdXAyKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgnVG90YWwgYnl0ZXMgbWlzbWF0Y2gnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJsb2NrSUQgPCBudW1Sc0Jsb2Nrc0luR3JvdXAxKSB7XHJcbiAgICAgICAgICAgIG51bURhdGFCeXRlc0luQmxvY2tbMF0gPSBudW1EYXRhQnl0ZXNJbkdyb3VwMTtcclxuICAgICAgICAgICAgbnVtRUNCeXRlc0luQmxvY2tbMF0gPSBudW1FY0J5dGVzSW5Hcm91cDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBudW1EYXRhQnl0ZXNJbkJsb2NrWzBdID0gbnVtRGF0YUJ5dGVzSW5Hcm91cDI7XHJcbiAgICAgICAgICAgIG51bUVDQnl0ZXNJbkJsb2NrWzBdID0gbnVtRWNCeXRlc0luR3JvdXAyO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludGVybGVhdmUgXCJiaXRzXCIgd2l0aCBjb3JyZXNwb25kaW5nIGVycm9yIGNvcnJlY3Rpb24gYnl0ZXMuIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW5cclxuICAgICAqIFwicmVzdWx0XCIuIFRoZSBpbnRlcmxlYXZlIHJ1bGUgaXMgY29tcGxpY2F0ZWQuIFNlZSA4LjYgb2YgSklTWDA1MTA6MjAwNCAocC4zNykgZm9yIGRldGFpbHMuXHJcbiAgICAgKi9cclxuICAgIEVuY29kZXIuaW50ZXJsZWF2ZVdpdGhFQ0J5dGVzID0gZnVuY3Rpb24gKGJpdHMsIG51bVRvdGFsQnl0ZXMgLyppbnQqLywgbnVtRGF0YUJ5dGVzIC8qaW50Ki8sIG51bVJTQmxvY2tzIC8qaW50Ki8pIHtcclxuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcclxuICAgICAgICAvLyBcImJpdHNcIiBtdXN0IGhhdmUgXCJnZXROdW1EYXRhQnl0ZXNcIiBieXRlcyBvZiBkYXRhLlxyXG4gICAgICAgIGlmIChiaXRzLmdldFNpemVJbkJ5dGVzKCkgIT09IG51bURhdGFCeXRlcykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgnTnVtYmVyIG9mIGJpdHMgYW5kIGRhdGEgYnl0ZXMgZG9lcyBub3QgbWF0Y2gnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3RlcCAxLiAgRGl2aWRlIGRhdGEgYnl0ZXMgaW50byBibG9ja3MgYW5kIGdlbmVyYXRlIGVycm9yIGNvcnJlY3Rpb24gYnl0ZXMgZm9yIHRoZW0uIFdlJ2xsXHJcbiAgICAgICAgLy8gc3RvcmUgdGhlIGRpdmlkZWQgZGF0YSBieXRlcyBibG9ja3MgYW5kIGVycm9yIGNvcnJlY3Rpb24gYnl0ZXMgYmxvY2tzIGludG8gXCJibG9ja3NcIi5cclxuICAgICAgICB2YXIgZGF0YUJ5dGVzT2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgbWF4TnVtRGF0YUJ5dGVzID0gMDtcclxuICAgICAgICB2YXIgbWF4TnVtRWNCeXRlcyA9IDA7XHJcbiAgICAgICAgLy8gU2luY2UsIHdlIGtub3cgdGhlIG51bWJlciBvZiByZWVkc29sbW9uIGJsb2Nrcywgd2UgY2FuIGluaXRpYWxpemUgdGhlIHZlY3RvciB3aXRoIHRoZSBudW1iZXIuXHJcbiAgICAgICAgdmFyIGJsb2NrcyA9IG5ldyBBcnJheSgpOyAvLyBuZXcgQXJyYXk8QmxvY2tQYWlyPihudW1SU0Jsb2NrcylcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVJTQmxvY2tzOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIG51bURhdGFCeXRlc0luQmxvY2sgPSBuZXcgSW50MzJBcnJheSgxKTtcclxuICAgICAgICAgICAgdmFyIG51bUVjQnl0ZXNJbkJsb2NrID0gbmV3IEludDMyQXJyYXkoMSk7XHJcbiAgICAgICAgICAgIEVuY29kZXIuZ2V0TnVtRGF0YUJ5dGVzQW5kTnVtRUNCeXRlc0ZvckJsb2NrSUQobnVtVG90YWxCeXRlcywgbnVtRGF0YUJ5dGVzLCBudW1SU0Jsb2NrcywgaSwgbnVtRGF0YUJ5dGVzSW5CbG9jaywgbnVtRWNCeXRlc0luQmxvY2spO1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IG51bURhdGFCeXRlc0luQmxvY2tbMF07XHJcbiAgICAgICAgICAgIHZhciBkYXRhQnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcclxuICAgICAgICAgICAgYml0cy50b0J5dGVzKDggKiBkYXRhQnl0ZXNPZmZzZXQsIGRhdGFCeXRlcywgMCwgc2l6ZSk7XHJcbiAgICAgICAgICAgIHZhciBlY0J5dGVzID0gRW5jb2Rlci5nZW5lcmF0ZUVDQnl0ZXMoZGF0YUJ5dGVzLCBudW1FY0J5dGVzSW5CbG9ja1swXSk7XHJcbiAgICAgICAgICAgIGJsb2Nrcy5wdXNoKG5ldyBCbG9ja1BhaXJfMS5kZWZhdWx0KGRhdGFCeXRlcywgZWNCeXRlcykpO1xyXG4gICAgICAgICAgICBtYXhOdW1EYXRhQnl0ZXMgPSBNYXRoLm1heChtYXhOdW1EYXRhQnl0ZXMsIHNpemUpO1xyXG4gICAgICAgICAgICBtYXhOdW1FY0J5dGVzID0gTWF0aC5tYXgobWF4TnVtRWNCeXRlcywgZWNCeXRlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBkYXRhQnl0ZXNPZmZzZXQgKz0gbnVtRGF0YUJ5dGVzSW5CbG9ja1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG51bURhdGFCeXRlcyAhPT0gZGF0YUJ5dGVzT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdEYXRhIGJ5dGVzIGRvZXMgbm90IG1hdGNoIG9mZnNldCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIC8vIEZpcnN0LCBwbGFjZSBkYXRhIGJsb2Nrcy5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heE51bURhdGFCeXRlczsgKytpKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBibG9ja3NfMSA9IF9fdmFsdWVzKGJsb2NrcyksIGJsb2Nrc18xXzEgPSBibG9ja3NfMS5uZXh0KCk7ICFibG9ja3NfMV8xLmRvbmU7IGJsb2Nrc18xXzEgPSBibG9ja3NfMS5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBibG9ja3NfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhQnl0ZXMgPSBibG9jay5nZXREYXRhQnl0ZXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IGRhdGFCeXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZEJpdHMoZGF0YUJ5dGVzW2ldLCA4KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9ja3NfMV8xICYmICFibG9ja3NfMV8xLmRvbmUgJiYgKF9hID0gYmxvY2tzXzEucmV0dXJuKSkgX2EuY2FsbChibG9ja3NfMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVGhlbiwgcGxhY2UgZXJyb3IgY29ycmVjdGlvbiBibG9ja3MuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhOdW1FY0J5dGVzOyArK2kpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGJsb2Nrc18yID0gX192YWx1ZXMoYmxvY2tzKSwgYmxvY2tzXzJfMSA9IGJsb2Nrc18yLm5leHQoKTsgIWJsb2Nrc18yXzEuZG9uZTsgYmxvY2tzXzJfMSA9IGJsb2Nrc18yLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9jayA9IGJsb2Nrc18yXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVjQnl0ZXMgPSBibG9jay5nZXRFcnJvckNvcnJlY3Rpb25CeXRlcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpIDwgZWNCeXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFwcGVuZEJpdHMoZWNCeXRlc1tpXSwgOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XHJcbiAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tzXzJfMSAmJiAhYmxvY2tzXzJfMS5kb25lICYmIChfYiA9IGJsb2Nrc18yLnJldHVybikpIF9iLmNhbGwoYmxvY2tzXzIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChudW1Ub3RhbEJ5dGVzICE9PSByZXN1bHQuZ2V0U2l6ZUluQnl0ZXMoKSkgeyAvLyBTaG91bGQgYmUgc2FtZS5cclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0ludGVybGVhdmluZyBlcnJvcjogJyArIG51bVRvdGFsQnl0ZXMgKyAnIGFuZCAnICtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5nZXRTaXplSW5CeXRlcygpICsgJyBkaWZmZXIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgRW5jb2Rlci5nZW5lcmF0ZUVDQnl0ZXMgPSBmdW5jdGlvbiAoZGF0YUJ5dGVzLCBudW1FY0J5dGVzSW5CbG9jayAvKmludCovKSB7XHJcbiAgICAgICAgdmFyIG51bURhdGFCeXRlcyA9IGRhdGFCeXRlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHRvRW5jb2RlID0gbmV3IEludDMyQXJyYXkobnVtRGF0YUJ5dGVzICsgbnVtRWNCeXRlc0luQmxvY2spOyAvLyBpbnRbbnVtRGF0YUJ5dGVzICsgbnVtRWNCeXRlc0luQmxvY2tdXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXRhQnl0ZXM7IGkrKykge1xyXG4gICAgICAgICAgICB0b0VuY29kZVtpXSA9IGRhdGFCeXRlc1tpXSAmIDB4RkY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ldyBSZWVkU29sb21vbkVuY29kZXJfMS5kZWZhdWx0KEdlbmVyaWNHRl8xLmRlZmF1bHQuUVJfQ09ERV9GSUVMRF8yNTYpLmVuY29kZSh0b0VuY29kZSwgbnVtRWNCeXRlc0luQmxvY2spO1xyXG4gICAgICAgIHZhciBlY0J5dGVzID0gbmV3IFVpbnQ4QXJyYXkobnVtRWNCeXRlc0luQmxvY2spO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRWNCeXRlc0luQmxvY2s7IGkrKykge1xyXG4gICAgICAgICAgICBlY0J5dGVzW2ldID0gLyooYnl0ZSkgKi8gdG9FbmNvZGVbbnVtRGF0YUJ5dGVzICsgaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlY0J5dGVzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kIG1vZGUgaW5mby4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIi5cclxuICAgICAqL1xyXG4gICAgRW5jb2Rlci5hcHBlbmRNb2RlSW5mbyA9IGZ1bmN0aW9uIChtb2RlLCBiaXRzKSB7XHJcbiAgICAgICAgYml0cy5hcHBlbmRCaXRzKG1vZGUuZ2V0Qml0cygpLCA0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZCBsZW5ndGggaW5mby4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIi5cclxuICAgICAqL1xyXG4gICAgRW5jb2Rlci5hcHBlbmRMZW5ndGhJbmZvID0gZnVuY3Rpb24gKG51bUxldHRlcnMgLyppbnQqLywgdmVyc2lvbiwgbW9kZSwgYml0cykge1xyXG4gICAgICAgIHZhciBudW1CaXRzID0gbW9kZS5nZXRDaGFyYWN0ZXJDb3VudEJpdHModmVyc2lvbik7XHJcbiAgICAgICAgaWYgKG51bUxldHRlcnMgPj0gKDEgPDwgbnVtQml0cykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQobnVtTGV0dGVycyArICcgaXMgYmlnZ2VyIHRoYW4gJyArICgoMSA8PCBudW1CaXRzKSAtIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYml0cy5hcHBlbmRCaXRzKG51bUxldHRlcnMsIG51bUJpdHMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kIFwiYnl0ZXNcIiBpbiBcIm1vZGVcIiBtb2RlIChlbmNvZGluZykgaW50byBcImJpdHNcIi4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIi5cclxuICAgICAqL1xyXG4gICAgRW5jb2Rlci5hcHBlbmRCeXRlcyA9IGZ1bmN0aW9uIChjb250ZW50LCBtb2RlLCBiaXRzLCBlbmNvZGluZykge1xyXG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xyXG4gICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0Lk5VTUVSSUM6XHJcbiAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZE51bWVyaWNCeXRlcyhjb250ZW50LCBiaXRzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE1vZGVfMS5kZWZhdWx0LkFMUEhBTlVNRVJJQzpcclxuICAgICAgICAgICAgICAgIEVuY29kZXIuYXBwZW5kQWxwaGFudW1lcmljQnl0ZXMoY29udGVudCwgYml0cyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBNb2RlXzEuZGVmYXVsdC5CWVRFOlxyXG4gICAgICAgICAgICAgICAgRW5jb2Rlci5hcHBlbmQ4Qml0Qnl0ZXMoY29udGVudCwgYml0cywgZW5jb2RpbmcpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTW9kZV8xLmRlZmF1bHQuS0FOSkk6XHJcbiAgICAgICAgICAgICAgICBFbmNvZGVyLmFwcGVuZEthbmppQnl0ZXMoY29udGVudCwgYml0cyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdJbnZhbGlkIG1vZGU6ICcgKyBtb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRW5jb2Rlci5nZXREaWdpdCA9IGZ1bmN0aW9uIChzaW5nbGVDaGFyYWN0ZXIpIHtcclxuICAgICAgICByZXR1cm4gc2luZ2xlQ2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgLSA0ODtcclxuICAgIH07XHJcbiAgICBFbmNvZGVyLmlzRGlnaXQgPSBmdW5jdGlvbiAoc2luZ2xlQ2hhcmFjdGVyKSB7XHJcbiAgICAgICAgdmFyIGNuID0gRW5jb2Rlci5nZXREaWdpdChzaW5nbGVDaGFyYWN0ZXIpO1xyXG4gICAgICAgIHJldHVybiBjbiA+PSAwICYmIGNuIDw9IDk7XHJcbiAgICB9O1xyXG4gICAgRW5jb2Rlci5hcHBlbmROdW1lcmljQnl0ZXMgPSBmdW5jdGlvbiAoY29udGVudCwgYml0cykge1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIG51bTEgPSBFbmNvZGVyLmdldERpZ2l0KGNvbnRlbnQuY2hhckF0KGkpKTtcclxuICAgICAgICAgICAgaWYgKGkgKyAyIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFbmNvZGUgdGhyZWUgbnVtZXJpYyBsZXR0ZXJzIGluIHRlbiBiaXRzLlxyXG4gICAgICAgICAgICAgICAgdmFyIG51bTIgPSBFbmNvZGVyLmdldERpZ2l0KGNvbnRlbnQuY2hhckF0KGkgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnVtMyA9IEVuY29kZXIuZ2V0RGlnaXQoY29udGVudC5jaGFyQXQoaSArIDIpKTtcclxuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhudW0xICogMTAwICsgbnVtMiAqIDEwICsgbnVtMywgMTApO1xyXG4gICAgICAgICAgICAgICAgaSArPSAzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGkgKyAxIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFbmNvZGUgdHdvIG51bWVyaWMgbGV0dGVycyBpbiBzZXZlbiBiaXRzLlxyXG4gICAgICAgICAgICAgICAgdmFyIG51bTIgPSBFbmNvZGVyLmdldERpZ2l0KGNvbnRlbnQuY2hhckF0KGkgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMobnVtMSAqIDEwICsgbnVtMiwgNyk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFbmNvZGUgb25lIG51bWVyaWMgbGV0dGVyIGluIGZvdXIgYml0cy5cclxuICAgICAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhudW0xLCA0KTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFbmNvZGVyLmFwcGVuZEFscGhhbnVtZXJpY0J5dGVzID0gZnVuY3Rpb24gKGNvbnRlbnQsIGJpdHMpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gY29udGVudC5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2RlMSA9IEVuY29kZXIuZ2V0QWxwaGFudW1lcmljQ29kZShjb250ZW50LmNoYXJDb2RlQXQoaSkpO1xyXG4gICAgICAgICAgICBpZiAoY29kZTEgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpICsgMSA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvZGUyID0gRW5jb2Rlci5nZXRBbHBoYW51bWVyaWNDb2RlKGNvbnRlbnQuY2hhckNvZGVBdChpICsgMSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUyID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBFbmNvZGUgdHdvIGFscGhhbnVtZXJpYyBsZXR0ZXJzIGluIDExIGJpdHMuXHJcbiAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoY29kZTEgKiA0NSArIGNvZGUyLCAxMSk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFbmNvZGUgb25lIGFscGhhbnVtZXJpYyBsZXR0ZXIgaW4gc2l4IGJpdHMuXHJcbiAgICAgICAgICAgICAgICBiaXRzLmFwcGVuZEJpdHMoY29kZTEsIDYpO1xyXG4gICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVuY29kZXIuYXBwZW5kOEJpdEJ5dGVzID0gZnVuY3Rpb24gKGNvbnRlbnQsIGJpdHMsIGVuY29kaW5nKSB7XHJcbiAgICAgICAgdmFyIGJ5dGVzO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGJ5dGVzID0gU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmVuY29kZShjb250ZW50LCBlbmNvZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoICh1ZWUgLyo6IFVuc3VwcG9ydGVkRW5jb2RpbmdFeGNlcHRpb24qLykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCh1ZWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzIgPSBieXRlcy5sZW5ndGg7IGkgIT09IGxlbmd0aF8yOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBieXRlc1tpXTtcclxuICAgICAgICAgICAgYml0cy5hcHBlbmRCaXRzKGIsIDgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEB0aHJvd3MgV3JpdGVyRXhjZXB0aW9uXHJcbiAgICAgKi9cclxuICAgIEVuY29kZXIuYXBwZW5kS2FuamlCeXRlcyA9IGZ1bmN0aW9uIChjb250ZW50LCBiaXRzKSB7XHJcbiAgICAgICAgdmFyIGJ5dGVzO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGJ5dGVzID0gU3RyaW5nRW5jb2RpbmdfMS5kZWZhdWx0LmVuY29kZShjb250ZW50LCBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LlNKSVMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAodWVlIC8qOiBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uKi8pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQodWVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciBieXRlMSA9IGJ5dGVzW2ldICYgMHhGRjtcclxuICAgICAgICAgICAgdmFyIGJ5dGUyID0gYnl0ZXNbaSArIDFdICYgMHhGRjtcclxuICAgICAgICAgICAgdmFyIGNvZGUgPSAoKGJ5dGUxIDw8IDgpICYgMHhGRkZGRkZGRikgfCBieXRlMjtcclxuICAgICAgICAgICAgdmFyIHN1YnRyYWN0ZWQgPSAtMTtcclxuICAgICAgICAgICAgaWYgKGNvZGUgPj0gMHg4MTQwICYmIGNvZGUgPD0gMHg5ZmZjKSB7XHJcbiAgICAgICAgICAgICAgICBzdWJ0cmFjdGVkID0gY29kZSAtIDB4ODE0MDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb2RlID49IDB4ZTA0MCAmJiBjb2RlIDw9IDB4ZWJiZikge1xyXG4gICAgICAgICAgICAgICAgc3VidHJhY3RlZCA9IGNvZGUgLSAweGMxNDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN1YnRyYWN0ZWQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgnSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGVuY29kZWQgPSAoKHN1YnRyYWN0ZWQgPj4gOCkgKiAweGMwKSArIChzdWJ0cmFjdGVkICYgMHhmZik7XHJcbiAgICAgICAgICAgIGJpdHMuYXBwZW5kQml0cyhlbmNvZGVkLCAxMyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEVuY29kZXIuYXBwZW5kRUNJID0gZnVuY3Rpb24gKGVjaSwgYml0cykge1xyXG4gICAgICAgIGJpdHMuYXBwZW5kQml0cyhNb2RlXzEuZGVmYXVsdC5FQ0kuZ2V0Qml0cygpLCA0KTtcclxuICAgICAgICAvLyBUaGlzIGlzIGNvcnJlY3QgZm9yIHZhbHVlcyB1cCB0byAxMjcsIHdoaWNoIGlzIGFsbCB3ZSBuZWVkIG5vdy5cclxuICAgICAgICBiaXRzLmFwcGVuZEJpdHMoZWNpLmdldFZhbHVlKCksIDgpO1xyXG4gICAgfTtcclxuICAgIC8vIFRoZSBvcmlnaW5hbCB0YWJsZSBpcyBkZWZpbmVkIGluIHRoZSB0YWJsZSA1IG9mIEpJU1gwNTEwOjIwMDQgKHAuMTkpLlxyXG4gICAgRW5jb2Rlci5BTFBIQU5VTUVSSUNfVEFCTEUgPSBJbnQzMkFycmF5LmZyb20oW1xyXG4gICAgICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4gICAgICAgIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLFxyXG4gICAgICAgIDM2LCAtMSwgLTEsIC0xLCAzNywgMzgsIC0xLCAtMSwgLTEsIC0xLCAzOSwgNDAsIC0xLCA0MSwgNDIsIDQzLFxyXG4gICAgICAgIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDQ0LCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbiAgICAgICAgLTEsIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjQsXHJcbiAgICAgICAgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAtMSwgLTEsIC0xLCAtMSwgLTEsXHJcbiAgICBdKTtcclxuICAgIEVuY29kZXIuREVGQVVMVF9CWVRFX01PREVfRU5DT0RJTkcgPSBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LlVURjguZ2V0TmFtZSgpOyAvLyBcIklTTy04ODU5LTFcIlxyXG4gICAgcmV0dXJuIEVuY29kZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEVuY29kZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVuY29kZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXCIpO1xyXG4vKipcclxuICogQGF1dGhvciBTYXRvcnUgVGFrYWJheWFzaGlcclxuICogQGF1dGhvciBEYW5pZWwgU3dpdGtpblxyXG4gKiBAYXV0aG9yIFNlYW4gT3dlblxyXG4gKi9cclxudmFyIE1hc2tVdGlsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWFza1V0aWwoKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAxIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuIEZpbmQgcmVwZXRpdGl2ZSBjZWxscyB3aXRoIHRoZSBzYW1lIGNvbG9yIGFuZFxyXG4gICAgICogZ2l2ZSBwZW5hbHR5IHRvIHRoZW0uIEV4YW1wbGU6IDAwMDAwIG9yIDExMTExLlxyXG4gICAgICovXHJcbiAgICBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTEgPSBmdW5jdGlvbiAobWF0cml4KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMUludGVybmFsKG1hdHJpeCwgdHJ1ZSkgKyBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTFJbnRlcm5hbChtYXRyaXgsIGZhbHNlKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IG1hc2sgcGVuYWx0eSBydWxlIDIgYW5kIHJldHVybiB0aGUgcGVuYWx0eS4gRmluZCAyeDIgYmxvY2tzIHdpdGggdGhlIHNhbWUgY29sb3IgYW5kIGdpdmVcclxuICAgICAqIHBlbmFsdHkgdG8gdGhlbS4gVGhpcyBpcyBhY3R1YWxseSBlcXVpdmFsZW50IHRvIHRoZSBzcGVjJ3MgcnVsZSwgd2hpY2ggaXMgdG8gZmluZCBNeE4gYmxvY2tzIGFuZCBnaXZlIGFcclxuICAgICAqIHBlbmFsdHkgcHJvcG9ydGlvbmFsIHRvIChNLTEpeChOLTEpLCBiZWNhdXNlIHRoaXMgaXMgdGhlIG51bWJlciBvZiAyeDIgYmxvY2tzIGluc2lkZSBzdWNoIGEgYmxvY2suXHJcbiAgICAgKi9cclxuICAgIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlMiA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcclxuICAgICAgICB2YXIgcGVuYWx0eSA9IDA7XHJcbiAgICAgICAgdmFyIGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gbWF0cml4LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IG1hdHJpeC5nZXRIZWlnaHQoKTtcclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodCAtIDE7IHkrKykge1xyXG4gICAgICAgICAgICB2YXIgYXJyYXlZID0gYXJyYXlbeV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGggLSAxOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5WVt4XTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gYXJyYXlZW3ggKyAxXSAmJiB2YWx1ZSA9PT0gYXJyYXlbeSArIDFdW3hdICYmIHZhbHVlID09PSBhcnJheVt5ICsgMV1beCArIDFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGVuYWx0eSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBNYXNrVXRpbC5OMiAqIHBlbmFsdHk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBtYXNrIHBlbmFsdHkgcnVsZSAzIGFuZCByZXR1cm4gdGhlIHBlbmFsdHkuIEZpbmQgY29uc2VjdXRpdmUgcnVucyBvZiAxOjE6MzoxOjE6NFxyXG4gICAgICogc3RhcnRpbmcgd2l0aCBibGFjaywgb3IgNDoxOjE6MzoxOjEgc3RhcnRpbmcgd2l0aCB3aGl0ZSwgYW5kIGdpdmUgcGVuYWx0eSB0byB0aGVtLiAgSWYgd2VcclxuICAgICAqIGZpbmQgcGF0dGVybnMgbGlrZSAwMDAwMTAxMTEwMTAwMDAsIHdlIGdpdmUgcGVuYWx0eSBvbmNlLlxyXG4gICAgICovXHJcbiAgICBNYXNrVXRpbC5hcHBseU1hc2tQZW5hbHR5UnVsZTMgPSBmdW5jdGlvbiAobWF0cml4KSB7XHJcbiAgICAgICAgdmFyIG51bVBlbmFsdGllcyA9IDA7XHJcbiAgICAgICAgdmFyIGFycmF5ID0gbWF0cml4LmdldEFycmF5KCk7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gbWF0cml4LmdldFdpZHRoKCk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IG1hdHJpeC5nZXRIZWlnaHQoKTtcclxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFycmF5WSA9IGFycmF5W3ldOyAvLyBXZSBjYW4gYXQgbGVhc3Qgb3B0aW1pemUgdGhpcyBhY2Nlc3NcclxuICAgICAgICAgICAgICAgIGlmICh4ICsgNiA8IHdpZHRoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlZW3hdID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlZW3ggKyAxXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgMl0gPT09IDEgJiZcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVlbeCArIDNdID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlZW3ggKyA0XSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5WVt4ICsgNV0gPT09IDAgJiZcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVlbeCArIDZdID09PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKE1hc2tVdGlsLmlzV2hpdGVIb3Jpem9udGFsKGFycmF5WSwgeCAtIDQsIHgpIHx8IE1hc2tVdGlsLmlzV2hpdGVIb3Jpem9udGFsKGFycmF5WSwgeCArIDcsIHggKyAxMSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbnVtUGVuYWx0aWVzKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeSArIDYgPCBoZWlnaHQgJiZcclxuICAgICAgICAgICAgICAgICAgICBhcnJheVt5XVt4XSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyAxXVt4XSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyAyXVt4XSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyAzXVt4XSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyA0XVt4XSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyA1XVt4XSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGFycmF5W3kgKyA2XVt4XSA9PT0gMSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChNYXNrVXRpbC5pc1doaXRlVmVydGljYWwoYXJyYXksIHgsIHkgLSA0LCB5KSB8fCBNYXNrVXRpbC5pc1doaXRlVmVydGljYWwoYXJyYXksIHgsIHkgKyA3LCB5ICsgMTEpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG51bVBlbmFsdGllcysrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudW1QZW5hbHRpZXMgKiBNYXNrVXRpbC5OMztcclxuICAgIH07XHJcbiAgICBNYXNrVXRpbC5pc1doaXRlSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIChyb3dBcnJheSwgZnJvbSAvKmludCovLCB0byAvKmludCovKSB7XHJcbiAgICAgICAgZnJvbSA9IE1hdGgubWF4KGZyb20sIDApO1xyXG4gICAgICAgIHRvID0gTWF0aC5taW4odG8sIHJvd0FycmF5Lmxlbmd0aCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChyb3dBcnJheVtpXSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIE1hc2tVdGlsLmlzV2hpdGVWZXJ0aWNhbCA9IGZ1bmN0aW9uIChhcnJheSwgY29sIC8qaW50Ki8sIGZyb20gLyppbnQqLywgdG8gLyppbnQqLykge1xyXG4gICAgICAgIGZyb20gPSBNYXRoLm1heChmcm9tLCAwKTtcclxuICAgICAgICB0byA9IE1hdGgubWluKHRvLCBhcnJheS5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXlbaV1bY29sXSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgbWFzayBwZW5hbHR5IHJ1bGUgNCBhbmQgcmV0dXJuIHRoZSBwZW5hbHR5LiBDYWxjdWxhdGUgdGhlIHJhdGlvIG9mIGRhcmsgY2VsbHMgYW5kIGdpdmVcclxuICAgICAqIHBlbmFsdHkgaWYgdGhlIHJhdGlvIGlzIGZhciBmcm9tIDUwJS4gSXQgZ2l2ZXMgMTAgcGVuYWx0eSBmb3IgNSUgZGlzdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIE1hc2tVdGlsLmFwcGx5TWFza1BlbmFsdHlSdWxlNCA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcclxuICAgICAgICB2YXIgbnVtRGFya0NlbGxzID0gMDtcclxuICAgICAgICB2YXIgYXJyYXkgPSBtYXRyaXguZ2V0QXJyYXkoKTtcclxuICAgICAgICB2YXIgd2lkdGggPSBtYXRyaXguZ2V0V2lkdGgoKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gbWF0cml4LmdldEhlaWdodCgpO1xyXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgdmFyIGFycmF5WSA9IGFycmF5W3ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcnJheVlbeF0gPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBudW1EYXJrQ2VsbHMrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbnVtVG90YWxDZWxscyA9IG1hdHJpeC5nZXRIZWlnaHQoKSAqIG1hdHJpeC5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHZhciBmaXZlUGVyY2VudFZhcmlhbmNlcyA9IE1hdGguZmxvb3IoTWF0aC5hYnMobnVtRGFya0NlbGxzICogMiAtIG51bVRvdGFsQ2VsbHMpICogMTAgLyBudW1Ub3RhbENlbGxzKTtcclxuICAgICAgICByZXR1cm4gZml2ZVBlcmNlbnRWYXJpYW5jZXMgKiBNYXNrVXRpbC5ONDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgbWFzayBiaXQgZm9yIFwiZ2V0TWFza1BhdHRlcm5cIiBhdCBcInhcIiBhbmQgXCJ5XCIuIFNlZSA4Ljggb2YgSklTWDA1MTA6MjAwNCBmb3IgbWFza1xyXG4gICAgICogcGF0dGVybiBjb25kaXRpb25zLlxyXG4gICAgICovXHJcbiAgICBNYXNrVXRpbC5nZXREYXRhTWFza0JpdCA9IGZ1bmN0aW9uIChtYXNrUGF0dGVybiAvKmludCovLCB4IC8qaW50Ki8sIHkgLyppbnQqLykge1xyXG4gICAgICAgIHZhciBpbnRlcm1lZGlhdGU7IC8qaW50Ki9cclxuICAgICAgICB2YXIgdGVtcDsgLyppbnQqL1xyXG4gICAgICAgIHN3aXRjaCAobWFza1BhdHRlcm4pIHtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgaW50ZXJtZWRpYXRlID0gKHkgKyB4KSAmIDB4MTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSB5ICYgMHgxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IHggJSAzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICh5ICsgeCkgJSAzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9IChNYXRoLmZsb29yKHkgLyAyKSArIE1hdGguZmxvb3IoeCAvIDMpKSAmIDB4MTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDU6XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0geSAqIHg7XHJcbiAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSAodGVtcCAmIDB4MSkgKyAodGVtcCAlIDMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgIHRlbXAgPSB5ICogeDtcclxuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZSA9ICgodGVtcCAmIDB4MSkgKyAodGVtcCAlIDMpKSAmIDB4MTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICB0ZW1wID0geSAqIHg7XHJcbiAgICAgICAgICAgICAgICBpbnRlcm1lZGlhdGUgPSAoKHRlbXAgJSAzKSArICgoeSArIHgpICYgMHgxKSkgJiAweDE7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0KCdJbnZhbGlkIG1hc2sgcGF0dGVybjogJyArIG1hc2tQYXR0ZXJuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGludGVybWVkaWF0ZSA9PT0gMDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiBmb3IgYXBwbHlNYXNrUGVuYWx0eVJ1bGUxLiBXZSBuZWVkIHRoaXMgZm9yIGRvaW5nIHRoaXMgY2FsY3VsYXRpb24gaW4gYm90aFxyXG4gICAgICogdmVydGljYWwgYW5kIGhvcml6b250YWwgb3JkZXJzIHJlc3BlY3RpdmVseS5cclxuICAgICAqL1xyXG4gICAgTWFza1V0aWwuYXBwbHlNYXNrUGVuYWx0eVJ1bGUxSW50ZXJuYWwgPSBmdW5jdGlvbiAobWF0cml4LCBpc0hvcml6b250YWwpIHtcclxuICAgICAgICB2YXIgcGVuYWx0eSA9IDA7XHJcbiAgICAgICAgdmFyIGlMaW1pdCA9IGlzSG9yaXpvbnRhbCA/IG1hdHJpeC5nZXRIZWlnaHQoKSA6IG1hdHJpeC5nZXRXaWR0aCgpO1xyXG4gICAgICAgIHZhciBqTGltaXQgPSBpc0hvcml6b250YWwgPyBtYXRyaXguZ2V0V2lkdGgoKSA6IG1hdHJpeC5nZXRIZWlnaHQoKTtcclxuICAgICAgICB2YXIgYXJyYXkgPSBtYXRyaXguZ2V0QXJyYXkoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlMaW1pdDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1TYW1lQml0Q2VsbHMgPSAwO1xyXG4gICAgICAgICAgICB2YXIgcHJldkJpdCA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGpMaW1pdDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYml0ID0gaXNIb3Jpem9udGFsID8gYXJyYXlbaV1bal0gOiBhcnJheVtqXVtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChiaXQgPT09IHByZXZCaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBudW1TYW1lQml0Q2VsbHMrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChudW1TYW1lQml0Q2VsbHMgPj0gNSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5hbHR5ICs9IE1hc2tVdGlsLk4xICsgKG51bVNhbWVCaXRDZWxscyAtIDUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBudW1TYW1lQml0Q2VsbHMgPSAxOyAvLyBJbmNsdWRlIHRoZSBjZWxsIGl0c2VsZi5cclxuICAgICAgICAgICAgICAgICAgICBwcmV2Qml0ID0gYml0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChudW1TYW1lQml0Q2VsbHMgPj0gNSkge1xyXG4gICAgICAgICAgICAgICAgcGVuYWx0eSArPSBNYXNrVXRpbC5OMSArIChudW1TYW1lQml0Q2VsbHMgLSA1KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGVuYWx0eTtcclxuICAgIH07XHJcbiAgICAvLyBQZW5hbHR5IHdlaWdodHMgZnJvbSBzZWN0aW9uIDYuOC4yLjFcclxuICAgIE1hc2tVdGlsLk4xID0gMztcclxuICAgIE1hc2tVdGlsLk4yID0gMztcclxuICAgIE1hc2tVdGlsLk4zID0gNDA7XHJcbiAgICBNYXNrVXRpbC5ONCA9IDEwO1xyXG4gICAgcmV0dXJuIE1hc2tVdGlsO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBNYXNrVXRpbDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWFza1V0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAyMDA4IFpYaW5nIGF1dGhvcnNcclxuICpcclxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuICpcclxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuICpcclxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKm5hbWVzcGFjZSBjb20uZ29vZ2xlLnp4aW5nLnFyY29kZS5lbmNvZGVyIHsqL1xyXG52YXIgQml0QXJyYXlfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vQml0QXJyYXlcIik7XHJcbnZhciBJbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9JbnRlZ2VyXCIpO1xyXG52YXIgUVJDb2RlXzEgPSByZXF1aXJlKFwiLi9RUkNvZGVcIik7XHJcbnZhciBNYXNrVXRpbF8xID0gcmVxdWlyZShcIi4vTWFza1V0aWxcIik7XHJcbnZhciBXcml0ZXJFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9Xcml0ZXJFeGNlcHRpb25cIik7XHJcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHNhdG9ydXhAZ29vZ2xlLmNvbSAoU2F0b3J1IFRha2FiYXlhc2hpKSAtIGNyZWF0b3JcclxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikgLSBwb3J0ZWQgZnJvbSBDKytcclxuICovXHJcbnZhciBNYXRyaXhVdGlsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWF0cml4VXRpbCgpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICB9XHJcbiAgICAvLyBTZXQgYWxsIGNlbGxzIHRvIC0xIChUWVBFU0NSSVBUUE9SVDogMjU1KS4gIC0xIChUWVBFU0NSSVBUUE9SVDogMjU1KSBtZWFucyB0aGF0IHRoZSBjZWxsIGlzIGVtcHR5IChub3Qgc2V0IHlldCkuXHJcbiAgICAvL1xyXG4gICAgLy8gSkFWQVBPUlQ6IFdlIHNob3VsZG4ndCBuZWVkIHRvIGRvIHRoaXMgYXQgYWxsLiBUaGUgY29kZSBzaG91bGQgYmUgcmV3cml0dGVuIHRvIGJlZ2luIGVuY29kaW5nXHJcbiAgICAvLyB3aXRoIHRoZSBCeXRlTWF0cml4IGluaXRpYWxpemVkIGFsbCB0byB6ZXJvLlxyXG4gICAgTWF0cml4VXRpbC5jbGVhck1hdHJpeCA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcclxuICAgICAgICAvLyBUWVBFU0NSSVBUUE9SVDogd2UgdXNlIFVpbnRBcnJheSBzZSBjaGFuZ2VkIGhlcmUgZnJvbSAtMSB0byAyNTVcclxuICAgICAgICBtYXRyaXguY2xlYXIoLyooYnl0ZSkgKi8gLyotMSovIDI1NSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGQgMkQgbWF0cml4IG9mIFFSIENvZGUgZnJvbSBcImRhdGFCaXRzXCIgd2l0aCBcImVjTGV2ZWxcIiwgXCJ2ZXJzaW9uXCIgYW5kIFwiZ2V0TWFza1BhdHRlcm5cIi4gT25cclxuICAgIC8vIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW4gXCJtYXRyaXhcIiBhbmQgcmV0dXJuIHRydWUuXHJcbiAgICBNYXRyaXhVdGlsLmJ1aWxkTWF0cml4ID0gZnVuY3Rpb24gKGRhdGFCaXRzLCBlY0xldmVsLCB2ZXJzaW9uLCBtYXNrUGF0dGVybiAvKmludCovLCBtYXRyaXgpIHtcclxuICAgICAgICBNYXRyaXhVdGlsLmNsZWFyTWF0cml4KG1hdHJpeCk7XHJcbiAgICAgICAgTWF0cml4VXRpbC5lbWJlZEJhc2ljUGF0dGVybnModmVyc2lvbiwgbWF0cml4KTtcclxuICAgICAgICAvLyBUeXBlIGluZm9ybWF0aW9uIGFwcGVhciB3aXRoIGFueSB2ZXJzaW9uLlxyXG4gICAgICAgIE1hdHJpeFV0aWwuZW1iZWRUeXBlSW5mbyhlY0xldmVsLCBtYXNrUGF0dGVybiwgbWF0cml4KTtcclxuICAgICAgICAvLyBWZXJzaW9uIGluZm8gYXBwZWFyIGlmIHZlcnNpb24gPj0gNy5cclxuICAgICAgICBNYXRyaXhVdGlsLm1heWJlRW1iZWRWZXJzaW9uSW5mbyh2ZXJzaW9uLCBtYXRyaXgpO1xyXG4gICAgICAgIC8vIERhdGEgc2hvdWxkIGJlIGVtYmVkZGVkIGF0IGVuZC5cclxuICAgICAgICBNYXRyaXhVdGlsLmVtYmVkRGF0YUJpdHMoZGF0YUJpdHMsIG1hc2tQYXR0ZXJuLCBtYXRyaXgpO1xyXG4gICAgfTtcclxuICAgIC8vIEVtYmVkIGJhc2ljIHBhdHRlcm5zLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeCBhbmQgcmV0dXJuIHRydWUuXHJcbiAgICAvLyBUaGUgYmFzaWMgcGF0dGVybnMgYXJlOlxyXG4gICAgLy8gLSBQb3NpdGlvbiBkZXRlY3Rpb24gcGF0dGVybnNcclxuICAgIC8vIC0gVGltaW5nIHBhdHRlcm5zXHJcbiAgICAvLyAtIERhcmsgZG90IGF0IHRoZSBsZWZ0IGJvdHRvbSBjb3JuZXJcclxuICAgIC8vIC0gUG9zaXRpb24gYWRqdXN0bWVudCBwYXR0ZXJucywgaWYgbmVlZCBiZVxyXG4gICAgTWF0cml4VXRpbC5lbWJlZEJhc2ljUGF0dGVybnMgPSBmdW5jdGlvbiAodmVyc2lvbiwgbWF0cml4KSB7XHJcbiAgICAgICAgLy8gTGV0J3MgZ2V0IHN0YXJ0ZWQgd2l0aCBlbWJlZGRpbmcgYmlnIHNxdWFyZXMgYXQgY29ybmVycy5cclxuICAgICAgICBNYXRyaXhVdGlsLmVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuc0FuZFNlcGFyYXRvcnMobWF0cml4KTtcclxuICAgICAgICAvLyBUaGVuLCBlbWJlZCB0aGUgZGFyayBkb3QgYXQgdGhlIGxlZnQgYm90dG9tIGNvcm5lci5cclxuICAgICAgICBNYXRyaXhVdGlsLmVtYmVkRGFya0RvdEF0TGVmdEJvdHRvbUNvcm5lcihtYXRyaXgpO1xyXG4gICAgICAgIC8vIFBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMgYXBwZWFyIGlmIHZlcnNpb24gPj0gMi5cclxuICAgICAgICBNYXRyaXhVdGlsLm1heWJlRW1iZWRQb3NpdGlvbkFkanVzdG1lbnRQYXR0ZXJucyh2ZXJzaW9uLCBtYXRyaXgpO1xyXG4gICAgICAgIC8vIFRpbWluZyBwYXR0ZXJucyBzaG91bGQgYmUgZW1iZWRkZWQgYWZ0ZXIgcG9zaXRpb24gYWRqLiBwYXR0ZXJucy5cclxuICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVGltaW5nUGF0dGVybnMobWF0cml4KTtcclxuICAgIH07XHJcbiAgICAvLyBFbWJlZCB0eXBlIGluZm9ybWF0aW9uLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeC5cclxuICAgIE1hdHJpeFV0aWwuZW1iZWRUeXBlSW5mbyA9IGZ1bmN0aW9uIChlY0xldmVsLCBtYXNrUGF0dGVybiAvKmludCovLCBtYXRyaXgpIHtcclxuICAgICAgICB2YXIgdHlwZUluZm9CaXRzID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIE1hdHJpeFV0aWwubWFrZVR5cGVJbmZvQml0cyhlY0xldmVsLCBtYXNrUGF0dGVybiwgdHlwZUluZm9CaXRzKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgc2l6ZSA9IHR5cGVJbmZvQml0cy5nZXRTaXplKCk7IGkgPCBzaXplOyArK2kpIHtcclxuICAgICAgICAgICAgLy8gUGxhY2UgYml0cyBpbiBMU0IgdG8gTVNCIG9yZGVyLiAgTFNCIChsZWFzdCBzaWduaWZpY2FudCBiaXQpIGlzIHRoZSBsYXN0IHZhbHVlIGluXHJcbiAgICAgICAgICAgIC8vIFwidHlwZUluZm9CaXRzXCIuXHJcbiAgICAgICAgICAgIHZhciBiaXQgPSB0eXBlSW5mb0JpdHMuZ2V0KHR5cGVJbmZvQml0cy5nZXRTaXplKCkgLSAxIC0gaSk7XHJcbiAgICAgICAgICAgIC8vIFR5cGUgaW5mbyBiaXRzIGF0IHRoZSBsZWZ0IHRvcCBjb3JuZXIuIFNlZSA4Ljkgb2YgSklTWDA1MTA6MjAwNCAocC40NikuXHJcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlcyA9IE1hdHJpeFV0aWwuVFlQRV9JTkZPX0NPT1JESU5BVEVTW2ldO1xyXG4gICAgICAgICAgICB2YXIgeDEgPSBjb29yZGluYXRlc1swXTtcclxuICAgICAgICAgICAgdmFyIHkxID0gY29vcmRpbmF0ZXNbMV07XHJcbiAgICAgICAgICAgIG1hdHJpeC5zZXRCb29sZWFuKHgxLCB5MSwgYml0KTtcclxuICAgICAgICAgICAgaWYgKGkgPCA4KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxyXG4gICAgICAgICAgICAgICAgdmFyIHgyID0gbWF0cml4LmdldFdpZHRoKCkgLSBpIC0gMTtcclxuICAgICAgICAgICAgICAgIHZhciB5MiA9IDg7XHJcbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0Qm9vbGVhbih4MiwgeTIsIGJpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXHJcbiAgICAgICAgICAgICAgICB2YXIgeDIgPSA4O1xyXG4gICAgICAgICAgICAgICAgdmFyIHkyID0gbWF0cml4LmdldEhlaWdodCgpIC0gNyArIChpIC0gOCk7XHJcbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0Qm9vbGVhbih4MiwgeTIsIGJpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRW1iZWQgdmVyc2lvbiBpbmZvcm1hdGlvbiBpZiBuZWVkIGJlLiBPbiBzdWNjZXNzLCBtb2RpZnkgdGhlIG1hdHJpeCBhbmQgcmV0dXJuIHRydWUuXHJcbiAgICAvLyBTZWUgOC4xMCBvZiBKSVNYMDUxMDoyMDA0IChwLjQ3KSBmb3IgaG93IHRvIGVtYmVkIHZlcnNpb24gaW5mb3JtYXRpb24uXHJcbiAgICBNYXRyaXhVdGlsLm1heWJlRW1iZWRWZXJzaW9uSW5mbyA9IGZ1bmN0aW9uICh2ZXJzaW9uLCBtYXRyaXgpIHtcclxuICAgICAgICBpZiAodmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKCkgPCA3KSB7IC8vIFZlcnNpb24gaW5mbyBpcyBuZWNlc3NhcnkgaWYgdmVyc2lvbiA+PSA3LlxyXG4gICAgICAgICAgICByZXR1cm47IC8vIERvbid0IG5lZWQgdmVyc2lvbiBpbmZvLlxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmVyc2lvbkluZm9CaXRzID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIE1hdHJpeFV0aWwubWFrZVZlcnNpb25JbmZvQml0cyh2ZXJzaW9uLCB2ZXJzaW9uSW5mb0JpdHMpO1xyXG4gICAgICAgIHZhciBiaXRJbmRleCA9IDYgKiAzIC0gMTsgLy8gSXQgd2lsbCBkZWNyZWFzZSBmcm9tIDE3IHRvIDAuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyArK2kpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyArK2opIHtcclxuICAgICAgICAgICAgICAgIC8vIFBsYWNlIGJpdHMgaW4gTFNCIChsZWFzdCBzaWduaWZpY2FudCBiaXQpIHRvIE1TQiBvcmRlci5cclxuICAgICAgICAgICAgICAgIHZhciBiaXQgPSB2ZXJzaW9uSW5mb0JpdHMuZ2V0KGJpdEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGJpdEluZGV4LS07XHJcbiAgICAgICAgICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXHJcbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0Qm9vbGVhbihpLCBtYXRyaXguZ2V0SGVpZ2h0KCkgLSAxMSArIGosIGJpdCk7XHJcbiAgICAgICAgICAgICAgICAvLyBSaWdodCBib3R0b20gY29ybmVyLlxyXG4gICAgICAgICAgICAgICAgbWF0cml4LnNldEJvb2xlYW4obWF0cml4LmdldEhlaWdodCgpIC0gMTEgKyBqLCBpLCBiaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEVtYmVkIFwiZGF0YUJpdHNcIiB1c2luZyBcImdldE1hc2tQYXR0ZXJuXCIuIE9uIHN1Y2Nlc3MsIG1vZGlmeSB0aGUgbWF0cml4IGFuZCByZXR1cm4gdHJ1ZS5cclxuICAgIC8vIEZvciBkZWJ1Z2dpbmcgcHVycG9zZXMsIGl0IHNraXBzIG1hc2tpbmcgcHJvY2VzcyBpZiBcImdldE1hc2tQYXR0ZXJuXCIgaXMgLTEoVFlQRVNDUklQVFBPUlQ6IDI1NSkuXHJcbiAgICAvLyBTZWUgOC43IG9mIEpJU1gwNTEwOjIwMDQgKHAuMzgpIGZvciBob3cgdG8gZW1iZWQgZGF0YSBiaXRzLlxyXG4gICAgTWF0cml4VXRpbC5lbWJlZERhdGFCaXRzID0gZnVuY3Rpb24gKGRhdGFCaXRzLCBtYXNrUGF0dGVybiAvKmludCovLCBtYXRyaXgpIHtcclxuICAgICAgICB2YXIgYml0SW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAvLyBTdGFydCBmcm9tIHRoZSByaWdodCBib3R0b20gY2VsbC5cclxuICAgICAgICB2YXIgeCA9IG1hdHJpeC5nZXRXaWR0aCgpIC0gMTtcclxuICAgICAgICB2YXIgeSA9IG1hdHJpeC5nZXRIZWlnaHQoKSAtIDE7XHJcbiAgICAgICAgd2hpbGUgKHggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIFNraXAgdGhlIHZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuLlxyXG4gICAgICAgICAgICBpZiAoeCA9PT0gNikge1xyXG4gICAgICAgICAgICAgICAgeCAtPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlICh5ID49IDAgJiYgeSA8IG1hdHJpeC5nZXRIZWlnaHQoKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeHggPSB4IC0gaTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHRoZSBjZWxsIGlmIGl0J3Mgbm90IGVtcHR5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoeHgsIHkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYml0SW5kZXggPCBkYXRhQml0cy5nZXRTaXplKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYml0ID0gZGF0YUJpdHMuZ2V0KGJpdEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKytiaXRJbmRleDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZGRpbmcgYml0LiBJZiB0aGVyZSBpcyBubyBiaXQgbGVmdCwgd2UnbGwgZmlsbCB0aGUgbGVmdCBjZWxscyB3aXRoIDAsIGFzIGRlc2NyaWJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiA4LjQuOSBvZiBKSVNYMDUxMDoyMDA0IChwLiAyNCkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIG1hc2tpbmcgaWYgbWFza19wYXR0ZXJuIGlzIC0xIChUWVBFU0NSSVBUUE9SVDogMjU1KS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFza1BhdHRlcm4gIT09IDI1NSAmJiBNYXNrVXRpbF8xLmRlZmF1bHQuZ2V0RGF0YU1hc2tCaXQobWFza1BhdHRlcm4sIHh4LCB5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiaXQgPSAhYml0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtYXRyaXguc2V0Qm9vbGVhbih4eCwgeSwgYml0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHkgKz0gZGlyZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IC1kaXJlY3Rpb247IC8vIFJldmVyc2UgdGhlIGRpcmVjdGlvbi5cclxuICAgICAgICAgICAgeSArPSBkaXJlY3Rpb247XHJcbiAgICAgICAgICAgIHggLT0gMjsgLy8gTW92ZSB0byB0aGUgbGVmdC5cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQWxsIGJpdHMgc2hvdWxkIGJlIGNvbnN1bWVkLlxyXG4gICAgICAgIGlmIChiaXRJbmRleCAhPT0gZGF0YUJpdHMuZ2V0U2l6ZSgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdOb3QgYWxsIGJpdHMgY29uc3VtZWQ6ICcgKyBiaXRJbmRleCArICcvJyArIGRhdGFCaXRzLmdldFNpemUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IHNldCAob25lOiB0bykgaW4gdGhlIFwidmFsdWVcIi4gVGhlIG1vc3RcclxuICAgIC8vIHNpZ25pZmljYW50IGJpdCBpcyBwb3NpdGlvbiAzMi4gSWYgdGhlcmUgaXMgbm8gYml0IHNldCwgcmV0dXJuIDAuIEV4YW1wbGVzOlxyXG4gICAgLy8gLSBmaW5kTVNCU2V0KDApID0+IDBcclxuICAgIC8vIC0gZmluZE1TQlNldCgxKSA9PiAxXHJcbiAgICAvLyAtIGZpbmRNU0JTZXQoMjU1KSA9PiA4XHJcbiAgICBNYXRyaXhVdGlsLmZpbmRNU0JTZXQgPSBmdW5jdGlvbiAodmFsdWUgLyppbnQqLykge1xyXG4gICAgICAgIHJldHVybiAzMiAtIEludGVnZXJfMS5kZWZhdWx0Lm51bWJlck9mTGVhZGluZ1plcm9zKHZhbHVlKTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxjdWxhdGUgQkNIIChCb3NlLUNoYXVkaHVyaS1Ib2NxdWVuZ2hlbSkgY29kZSBmb3IgXCJ2YWx1ZVwiIHVzaW5nIHBvbHlub21pYWwgXCJwb2x5XCIuIFRoZSBCQ0hcclxuICAgIC8vIGNvZGUgaXMgdXNlZCBmb3IgZW5jb2RpbmcgdHlwZSBpbmZvcm1hdGlvbiBhbmQgdmVyc2lvbiBpbmZvcm1hdGlvbi5cclxuICAgIC8vIEV4YW1wbGU6IENhbGN1bGF0aW9uIG9mIHZlcnNpb24gaW5mb3JtYXRpb24gb2YgNy5cclxuICAgIC8vIGYoeCkgaXMgY3JlYXRlZCBmcm9tIDcuXHJcbiAgICAvLyAgIC0gNyA9IDAwMDExMSBpbiA2IGJpdHNcclxuICAgIC8vICAgLSBmKHgpID0geF4yICsgeF4xICsgeF4wXHJcbiAgICAvLyBnKHgpIGlzIGdpdmVuIGJ5IHRoZSBzdGFuZGFyZCAocC4gNjcpXHJcbiAgICAvLyAgIC0gZyh4KSA9IHheMTIgKyB4XjExICsgeF4xMCArIHheOSArIHheOCArIHheNSArIHheMiArIDFcclxuICAgIC8vIE11bHRpcGx5IGYoeCkgYnkgeF4oMTggLSA2KVxyXG4gICAgLy8gICAtIGYnKHgpID0gZih4KSAqIHheKDE4IC0gNilcclxuICAgIC8vICAgLSBmJyh4KSA9IHheMTQgKyB4XjEzICsgeF4xMlxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSByZW1haW5kZXIgb2YgZicoeCkgLyBnKHgpXHJcbiAgICAvLyAgICAgICAgIHheMlxyXG4gICAgLy8gICAgICAgICBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xyXG4gICAgLy8gICBnKHgpICl4XjE0ICsgeF4xMyArIHheMTJcclxuICAgIC8vICAgICAgICAgeF4xNCArIHheMTMgKyB4XjEyICsgeF4xMSArIHheMTAgKyB4XjcgKyB4XjQgKyB4XjJcclxuICAgIC8vICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeF4xMSArIHheMTAgKyB4XjcgKyB4XjQgKyB4XjJcclxuICAgIC8vXHJcbiAgICAvLyBUaGUgcmVtYWluZGVyIGlzIHheMTEgKyB4XjEwICsgeF43ICsgeF40ICsgeF4yXHJcbiAgICAvLyBFbmNvZGUgaXQgaW4gYmluYXJ5OiAxMTAwMTAwMTAxMDBcclxuICAgIC8vIFRoZSByZXR1cm4gdmFsdWUgaXMgMHhjOTQgKDExMDAgMTAwMSAwMTAwKVxyXG4gICAgLy9cclxuICAgIC8vIFNpbmNlIGFsbCBjb2VmZmljaWVudHMgaW4gdGhlIHBvbHlub21pYWxzIGFyZSAxIG9yIDAsIHdlIGNhbiBkbyB0aGUgY2FsY3VsYXRpb24gYnkgYml0XHJcbiAgICAvLyBvcGVyYXRpb25zLiBXZSBkb24ndCBjYXJlIGlmIGNvZWZmaWNpZW50cyBhcmUgcG9zaXRpdmUgb3IgbmVnYXRpdmUuXHJcbiAgICBNYXRyaXhVdGlsLmNhbGN1bGF0ZUJDSENvZGUgPSBmdW5jdGlvbiAodmFsdWUgLyppbnQqLywgcG9seSAvKmludCovKSB7XHJcbiAgICAgICAgaWYgKHBvbHkgPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJzAgcG9seW5vbWlhbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBwb2x5IGlzIFwiMSAxMTExIDAwMTAgMDEwMVwiICh2ZXJzaW9uIGluZm8gcG9seSksIG1zYlNldEluUG9seSBpcyAxMy4gV2UnbGwgc3VidHJhY3QgMVxyXG4gICAgICAgIC8vIGZyb20gMTMgdG8gbWFrZSBpdCAxMi5cclxuICAgICAgICB2YXIgbXNiU2V0SW5Qb2x5ID0gTWF0cml4VXRpbC5maW5kTVNCU2V0KHBvbHkpO1xyXG4gICAgICAgIHZhbHVlIDw8PSBtc2JTZXRJblBvbHkgLSAxO1xyXG4gICAgICAgIC8vIERvIHRoZSBkaXZpc2lvbiBidXNpbmVzcyB1c2luZyBleGNsdXNpdmUtb3Igb3BlcmF0aW9ucy5cclxuICAgICAgICB3aGlsZSAoTWF0cml4VXRpbC5maW5kTVNCU2V0KHZhbHVlKSA+PSBtc2JTZXRJblBvbHkpIHtcclxuICAgICAgICAgICAgdmFsdWUgXj0gcG9seSA8PCAoTWF0cml4VXRpbC5maW5kTVNCU2V0KHZhbHVlKSAtIG1zYlNldEluUG9seSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vdyB0aGUgXCJ2YWx1ZVwiIGlzIHRoZSByZW1haW5kZXIgKGkuZS4gdGhlIEJDSCBjb2RlKVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICAvLyBNYWtlIGJpdCB2ZWN0b3Igb2YgdHlwZSBpbmZvcm1hdGlvbi4gT24gc3VjY2Vzcywgc3RvcmUgdGhlIHJlc3VsdCBpbiBcImJpdHNcIiBhbmQgcmV0dXJuIHRydWUuXHJcbiAgICAvLyBFbmNvZGUgZXJyb3IgY29ycmVjdGlvbiBsZXZlbCBhbmQgbWFzayBwYXR0ZXJuLiBTZWUgOC45IG9mXHJcbiAgICAvLyBKSVNYMDUxMDoyMDA0IChwLjQ1KSBmb3IgZGV0YWlscy5cclxuICAgIE1hdHJpeFV0aWwubWFrZVR5cGVJbmZvQml0cyA9IGZ1bmN0aW9uIChlY0xldmVsLCBtYXNrUGF0dGVybiAvKmludCovLCBiaXRzKSB7XHJcbiAgICAgICAgaWYgKCFRUkNvZGVfMS5kZWZhdWx0LmlzVmFsaWRNYXNrUGF0dGVybihtYXNrUGF0dGVybikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoJ0ludmFsaWQgbWFzayBwYXR0ZXJuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0eXBlSW5mbyA9IChlY0xldmVsLmdldEJpdHMoKSA8PCAzKSB8IG1hc2tQYXR0ZXJuO1xyXG4gICAgICAgIGJpdHMuYXBwZW5kQml0cyh0eXBlSW5mbywgNSk7XHJcbiAgICAgICAgdmFyIGJjaENvZGUgPSBNYXRyaXhVdGlsLmNhbGN1bGF0ZUJDSENvZGUodHlwZUluZm8sIE1hdHJpeFV0aWwuVFlQRV9JTkZPX1BPTFkpO1xyXG4gICAgICAgIGJpdHMuYXBwZW5kQml0cyhiY2hDb2RlLCAxMCk7XHJcbiAgICAgICAgdmFyIG1hc2tCaXRzID0gbmV3IEJpdEFycmF5XzEuZGVmYXVsdCgpO1xyXG4gICAgICAgIG1hc2tCaXRzLmFwcGVuZEJpdHMoTWF0cml4VXRpbC5UWVBFX0lORk9fTUFTS19QQVRURVJOLCAxNSk7XHJcbiAgICAgICAgYml0cy54b3IobWFza0JpdHMpO1xyXG4gICAgICAgIGlmIChiaXRzLmdldFNpemUoKSAhPT0gMTUpIHsgLy8gSnVzdCBpbiBjYXNlLlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgV3JpdGVyRXhjZXB0aW9uXzEuZGVmYXVsdCgnc2hvdWxkIG5vdCBoYXBwZW4gYnV0IHdlIGdvdDogJyArIGJpdHMuZ2V0U2l6ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gTWFrZSBiaXQgdmVjdG9yIG9mIHZlcnNpb24gaW5mb3JtYXRpb24uIE9uIHN1Y2Nlc3MsIHN0b3JlIHRoZSByZXN1bHQgaW4gXCJiaXRzXCIgYW5kIHJldHVybiB0cnVlLlxyXG4gICAgLy8gU2VlIDguMTAgb2YgSklTWDA1MTA6MjAwNCAocC40NSkgZm9yIGRldGFpbHMuXHJcbiAgICBNYXRyaXhVdGlsLm1ha2VWZXJzaW9uSW5mb0JpdHMgPSBmdW5jdGlvbiAodmVyc2lvbiwgYml0cykge1xyXG4gICAgICAgIGJpdHMuYXBwZW5kQml0cyh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSwgNik7XHJcbiAgICAgICAgdmFyIGJjaENvZGUgPSBNYXRyaXhVdGlsLmNhbGN1bGF0ZUJDSENvZGUodmVyc2lvbi5nZXRWZXJzaW9uTnVtYmVyKCksIE1hdHJpeFV0aWwuVkVSU0lPTl9JTkZPX1BPTFkpO1xyXG4gICAgICAgIGJpdHMuYXBwZW5kQml0cyhiY2hDb2RlLCAxMik7XHJcbiAgICAgICAgaWYgKGJpdHMuZ2V0U2l6ZSgpICE9PSAxOCkgeyAvLyBKdXN0IGluIGNhc2UuXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0KCdzaG91bGQgbm90IGhhcHBlbiBidXQgd2UgZ290OiAnICsgYml0cy5nZXRTaXplKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDaGVjayBpZiBcInZhbHVlXCIgaXMgZW1wdHkuXHJcbiAgICBNYXRyaXhVdGlsLmlzRW1wdHkgPSBmdW5jdGlvbiAodmFsdWUgLyppbnQqLykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMjU1OyAvLyAtMVxyXG4gICAgfTtcclxuICAgIE1hdHJpeFV0aWwuZW1iZWRUaW1pbmdQYXR0ZXJucyA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcclxuICAgICAgICAvLyAtOCBpcyBmb3Igc2tpcHBpbmcgcG9zaXRpb24gZGV0ZWN0aW9uIHBhdHRlcm5zICg3OiBzaXplKSwgYW5kIHR3byBob3Jpem9udGFsL3ZlcnRpY2FsXHJcbiAgICAgICAgLy8gc2VwYXJhdGlvbiBwYXR0ZXJucyAoMTogc2l6ZSkuIFRodXMsIDggPSA3ICsgMS5cclxuICAgICAgICBmb3IgKHZhciBpID0gODsgaSA8IG1hdHJpeC5nZXRXaWR0aCgpIC0gODsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBiaXQgPSAoaSArIDEpICUgMjtcclxuICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBsaW5lLlxyXG4gICAgICAgICAgICBpZiAoTWF0cml4VXRpbC5pc0VtcHR5KG1hdHJpeC5nZXQoaSwgNikpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKGksIDYsIGJpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVmVydGljYWwgbGluZS5cclxuICAgICAgICAgICAgaWYgKE1hdHJpeFV0aWwuaXNFbXB0eShtYXRyaXguZ2V0KDYsIGkpKSkge1xyXG4gICAgICAgICAgICAgICAgbWF0cml4LnNldE51bWJlcig2LCBpLCBiaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEVtYmVkIHRoZSBsb25lbHkgZGFyayBkb3QgYXQgbGVmdCBib3R0b20gY29ybmVyLiBKSVNYMDUxMDoyMDA0IChwLjQ2KVxyXG4gICAgTWF0cml4VXRpbC5lbWJlZERhcmtEb3RBdExlZnRCb3R0b21Db3JuZXIgPSBmdW5jdGlvbiAobWF0cml4KSB7XHJcbiAgICAgICAgaWYgKG1hdHJpeC5nZXQoOCwgbWF0cml4LmdldEhlaWdodCgpIC0gOCkgPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWF0cml4LnNldE51bWJlcig4LCBtYXRyaXguZ2V0SGVpZ2h0KCkgLSA4LCAxKTtcclxuICAgIH07XHJcbiAgICBNYXRyaXhVdGlsLmVtYmVkSG9yaXpvbnRhbFNlcGFyYXRpb25QYXR0ZXJuID0gZnVuY3Rpb24gKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XHJcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA4OyArK3gpIHtcclxuICAgICAgICAgICAgaWYgKCFNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4U3RhcnQgKyB4LCB5U3RhcnQpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCArIHgsIHlTdGFydCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1hdHJpeFV0aWwuZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuID0gZnVuY3Rpb24gKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA3OyArK3kpIHtcclxuICAgICAgICAgICAgaWYgKCFNYXRyaXhVdGlsLmlzRW1wdHkobWF0cml4LmdldCh4U3RhcnQsIHlTdGFydCArIHkpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdyaXRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCwgeVN0YXJ0ICsgeSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1hdHJpeFV0aWwuZW1iZWRQb3NpdGlvbkFkanVzdG1lbnRQYXR0ZXJuID0gZnVuY3Rpb24gKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA1OyArK3kpIHtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm5ZID0gTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk5beV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgNTsgKyt4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXRyaXguc2V0TnVtYmVyKHhTdGFydCArIHgsIHlTdGFydCArIHksIHBhdHRlcm5ZW3hdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYXRyaXhVdGlsLmVtYmVkUG9zaXRpb25EZXRlY3Rpb25QYXR0ZXJuID0gZnVuY3Rpb24gKHhTdGFydCAvKmludCovLCB5U3RhcnQgLyppbnQqLywgbWF0cml4KSB7XHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCA3OyArK3kpIHtcclxuICAgICAgICAgICAgdmFyIHBhdHRlcm5ZID0gTWF0cml4VXRpbC5QT1NJVElPTl9ERVRFQ1RJT05fUEFUVEVSTlt5XTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCA3OyArK3gpIHtcclxuICAgICAgICAgICAgICAgIG1hdHJpeC5zZXROdW1iZXIoeFN0YXJ0ICsgeCwgeVN0YXJ0ICsgeSwgcGF0dGVybllbeF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEVtYmVkIHBvc2l0aW9uIGRldGVjdGlvbiBwYXR0ZXJucyBhbmQgc3Vycm91bmRpbmcgdmVydGljYWwvaG9yaXpvbnRhbCBzZXBhcmF0b3JzLlxyXG4gICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybnNBbmRTZXBhcmF0b3JzID0gZnVuY3Rpb24gKG1hdHJpeCkge1xyXG4gICAgICAgIC8vIEVtYmVkIHRocmVlIGJpZyBzcXVhcmVzIGF0IGNvcm5lcnMuXHJcbiAgICAgICAgdmFyIHBkcFdpZHRoID0gTWF0cml4VXRpbC5QT1NJVElPTl9ERVRFQ1RJT05fUEFUVEVSTlswXS5sZW5ndGg7XHJcbiAgICAgICAgLy8gTGVmdCB0b3AgY29ybmVyLlxyXG4gICAgICAgIE1hdHJpeFV0aWwuZW1iZWRQb3NpdGlvbkRldGVjdGlvblBhdHRlcm4oMCwgMCwgbWF0cml4KTtcclxuICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxyXG4gICAgICAgIE1hdHJpeFV0aWwuZW1iZWRQb3NpdGlvbkRldGVjdGlvblBhdHRlcm4obWF0cml4LmdldFdpZHRoKCkgLSBwZHBXaWR0aCwgMCwgbWF0cml4KTtcclxuICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXHJcbiAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uRGV0ZWN0aW9uUGF0dGVybigwLCBtYXRyaXguZ2V0V2lkdGgoKSAtIHBkcFdpZHRoLCBtYXRyaXgpO1xyXG4gICAgICAgIC8vIEVtYmVkIGhvcml6b250YWwgc2VwYXJhdGlvbiBwYXR0ZXJucyBhcm91bmQgdGhlIHNxdWFyZXMuXHJcbiAgICAgICAgdmFyIGhzcFdpZHRoID0gODtcclxuICAgICAgICAvLyBMZWZ0IHRvcCBjb3JuZXIuXHJcbiAgICAgICAgTWF0cml4VXRpbC5lbWJlZEhvcml6b250YWxTZXBhcmF0aW9uUGF0dGVybigwLCBoc3BXaWR0aCAtIDEsIG1hdHJpeCk7XHJcbiAgICAgICAgLy8gUmlnaHQgdG9wIGNvcm5lci5cclxuICAgICAgICBNYXRyaXhVdGlsLmVtYmVkSG9yaXpvbnRhbFNlcGFyYXRpb25QYXR0ZXJuKG1hdHJpeC5nZXRXaWR0aCgpIC0gaHNwV2lkdGgsIGhzcFdpZHRoIC0gMSwgbWF0cml4KTtcclxuICAgICAgICAvLyBMZWZ0IGJvdHRvbSBjb3JuZXIuXHJcbiAgICAgICAgTWF0cml4VXRpbC5lbWJlZEhvcml6b250YWxTZXBhcmF0aW9uUGF0dGVybigwLCBtYXRyaXguZ2V0V2lkdGgoKSAtIGhzcFdpZHRoLCBtYXRyaXgpO1xyXG4gICAgICAgIC8vIEVtYmVkIHZlcnRpY2FsIHNlcGFyYXRpb24gcGF0dGVybnMgYXJvdW5kIHRoZSBzcXVhcmVzLlxyXG4gICAgICAgIHZhciB2c3BTaXplID0gNztcclxuICAgICAgICAvLyBMZWZ0IHRvcCBjb3JuZXIuXHJcbiAgICAgICAgTWF0cml4VXRpbC5lbWJlZFZlcnRpY2FsU2VwYXJhdGlvblBhdHRlcm4odnNwU2l6ZSwgMCwgbWF0cml4KTtcclxuICAgICAgICAvLyBSaWdodCB0b3AgY29ybmVyLlxyXG4gICAgICAgIE1hdHJpeFV0aWwuZW1iZWRWZXJ0aWNhbFNlcGFyYXRpb25QYXR0ZXJuKG1hdHJpeC5nZXRIZWlnaHQoKSAtIHZzcFNpemUgLSAxLCAwLCBtYXRyaXgpO1xyXG4gICAgICAgIC8vIExlZnQgYm90dG9tIGNvcm5lci5cclxuICAgICAgICBNYXRyaXhVdGlsLmVtYmVkVmVydGljYWxTZXBhcmF0aW9uUGF0dGVybih2c3BTaXplLCBtYXRyaXguZ2V0SGVpZ2h0KCkgLSB2c3BTaXplLCBtYXRyaXgpO1xyXG4gICAgfTtcclxuICAgIC8vIEVtYmVkIHBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybnMgaWYgbmVlZCBiZS5cclxuICAgIE1hdHJpeFV0aWwubWF5YmVFbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm5zID0gZnVuY3Rpb24gKHZlcnNpb24sIG1hdHJpeCkge1xyXG4gICAgICAgIGlmICh2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSA8IDIpIHsgLy8gVGhlIHBhdHRlcm5zIGFwcGVhciBpZiB2ZXJzaW9uID49IDJcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5kZXggPSB2ZXJzaW9uLmdldFZlcnNpb25OdW1iZXIoKSAtIDE7XHJcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gTWF0cml4VXRpbC5QT1NJVElPTl9BREpVU1RNRU5UX1BBVFRFUk5fQ09PUkRJTkFURV9UQUJMRVtpbmRleF07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gY29vcmRpbmF0ZXMubGVuZ3RoOyBpICE9PSBsZW5ndGhfMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB5ID0gY29vcmRpbmF0ZXNbaV07XHJcbiAgICAgICAgICAgIGlmICh5ID49IDApIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqICE9PSBsZW5ndGhfMTsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA+PSAwICYmIE1hdHJpeFV0aWwuaXNFbXB0eShtYXRyaXguZ2V0KHgsIHkpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2VsbCBpcyB1bnNldCwgd2UgZW1iZWQgdGhlIHBvc2l0aW9uIGFkanVzdG1lbnQgcGF0dGVybiBoZXJlLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAtMiBpcyBuZWNlc3Nhcnkgc2luY2UgdGhlIHgveSBjb29yZGluYXRlcyBwb2ludCB0byB0aGUgY2VudGVyIG9mIHRoZSBwYXR0ZXJuLCBub3QgdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlZnQgdG9wIGNvcm5lci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0cml4VXRpbC5lbWJlZFBvc2l0aW9uQWRqdXN0bWVudFBhdHRlcm4oeCAtIDIsIHkgLSAyLCBtYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYXRyaXhVdGlsLlBPU0lUSU9OX0RFVEVDVElPTl9QQVRURVJOID0gQXJyYXkuZnJvbShbXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxLCAxXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAwLCAwLCAwLCAwLCAxXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAxLCAxLCAxLCAwLCAxXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAxLCAxLCAxLCAwLCAxXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAxLCAxLCAxLCAwLCAxXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAwLCAwLCAwLCAwLCAxXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxLCAxLCAxXSksXHJcbiAgICBdKTtcclxuICAgIE1hdHJpeFV0aWwuUE9TSVRJT05fQURKVVNUTUVOVF9QQVRURVJOID0gQXJyYXkuZnJvbShbXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAwLCAwLCAxXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAxLCAwLCAxXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAwLCAwLCAwLCAxXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCAxLCAxLCAxLCAxXSksXHJcbiAgICBdKTtcclxuICAgIC8vIEZyb20gQXBwZW5kaXggRS4gVGFibGUgMSwgSklTMDUxMFg6MjAwNCAoNzE6IHApLiBUaGUgdGFibGUgd2FzIGRvdWJsZS1jaGVja2VkIGJ5IGtvbWF0c3UuXHJcbiAgICBNYXRyaXhVdGlsLlBPU0lUSU9OX0FESlVTVE1FTlRfUEFUVEVSTl9DT09SRElOQVRFX1RBQkxFID0gQXJyYXkuZnJvbShbXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFstMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMTgsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjIsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIC0xLCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjIsIDM4LCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjQsIDQyLCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ2LCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDUwLCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4LCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCAtMSwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ2LCA2NiwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDQ4LCA3MCwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUwLCA3NCwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU2LCA4MiwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYyLCA5MCwgLTEsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDUwLCA3MiwgOTQsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDUwLCA3NCwgOTgsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAtMSwgLTFdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDI4LCA1NCwgODAsIDEwNiwgLTEsIC0xXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMiwgNTgsIDg0LCAxMTAsIC0xLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAtMSwgLTFdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MiwgOTAsIDExOCwgLTEsIC0xXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyLCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIC0xXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAyNiwgNTIsIDc4LCAxMDQsIDEzMCwgLTFdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDMwLCA1NiwgODIsIDEwOCwgMTM0LCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzQsIDYwLCA4NiwgMTEyLCAxMzgsIC0xXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgLTFdKSxcclxuICAgICAgICBJbnQzMkFycmF5LmZyb20oWzYsIDM0LCA2MiwgOTAsIDExOCwgMTQ2LCAtMV0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU0LCA3OCwgMTAyLCAxMjYsIDE1MF0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjQsIDUwLCA3NiwgMTAyLCAxMjgsIDE1NF0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzIsIDU4LCA4NCwgMTEwLCAxMzYsIDE2Ml0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMjYsIDU0LCA4MiwgMTEwLCAxMzgsIDE2Nl0pLFxyXG4gICAgICAgIEludDMyQXJyYXkuZnJvbShbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIDE3MF0pLFxyXG4gICAgXSk7XHJcbiAgICAvLyBUeXBlIGluZm8gY2VsbHMgYXQgdGhlIGxlZnQgdG9wIGNvcm5lci5cclxuICAgIE1hdHJpeFV0aWwuVFlQRV9JTkZPX0NPT1JESU5BVEVTID0gQXJyYXkuZnJvbShbXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAwXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAxXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAyXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCAzXSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCA0XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCA1XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCA3XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs4LCA4XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs3LCA4XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs1LCA4XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFs0LCA4XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFszLCA4XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsyLCA4XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFsxLCA4XSksXHJcbiAgICAgICAgSW50MzJBcnJheS5mcm9tKFswLCA4XSksXHJcbiAgICBdKTtcclxuICAgIC8vIEZyb20gQXBwZW5kaXggRCBpbiBKSVNYMDUxMDoyMDA0IChwLiA2NylcclxuICAgIE1hdHJpeFV0aWwuVkVSU0lPTl9JTkZPX1BPTFkgPSAweDFmMjU7IC8vIDEgMTExMSAwMDEwIDAxMDFcclxuICAgIC8vIEZyb20gQXBwZW5kaXggQyBpbiBKSVNYMDUxMDoyMDA0IChwLjY1KS5cclxuICAgIE1hdHJpeFV0aWwuVFlQRV9JTkZPX1BPTFkgPSAweDUzNztcclxuICAgIE1hdHJpeFV0aWwuVFlQRV9JTkZPX01BU0tfUEFUVEVSTiA9IDB4NTQxMjtcclxuICAgIHJldHVybiBNYXRyaXhVdGlsO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBNYXRyaXhVdGlsO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRyaXhVdGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgMjAwOCBaWGluZyBhdXRob3JzXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFN0cmluZ0J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1N0cmluZ0J1aWxkZXJcIik7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHNhdG9ydXhAZ29vZ2xlLmNvbSAoU2F0b3J1IFRha2FiYXlhc2hpKSAtIGNyZWF0b3JcclxuICogQGF1dGhvciBkc3dpdGtpbkBnb29nbGUuY29tIChEYW5pZWwgU3dpdGtpbikgLSBwb3J0ZWQgZnJvbSBDKytcclxuICovXHJcbnZhciBRUkNvZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBRUkNvZGUoKSB7XHJcbiAgICAgICAgdGhpcy5tYXNrUGF0dGVybiA9IC0xO1xyXG4gICAgfVxyXG4gICAgUVJDb2RlLnByb3RvdHlwZS5nZXRNb2RlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vZGU7XHJcbiAgICB9O1xyXG4gICAgUVJDb2RlLnByb3RvdHlwZS5nZXRFQ0xldmVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVjTGV2ZWw7XHJcbiAgICB9O1xyXG4gICAgUVJDb2RlLnByb3RvdHlwZS5nZXRWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XHJcbiAgICB9O1xyXG4gICAgUVJDb2RlLnByb3RvdHlwZS5nZXRNYXNrUGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXNrUGF0dGVybjtcclxuICAgIH07XHJcbiAgICBRUkNvZGUucHJvdG90eXBlLmdldE1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XHJcbiAgICB9O1xyXG4gICAgLypAT3ZlcnJpZGUqL1xyXG4gICAgUVJDb2RlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFN0cmluZ0J1aWxkZXJfMS5kZWZhdWx0KCk7IC8vICgyMDApXHJcbiAgICAgICAgcmVzdWx0LmFwcGVuZCgnPDxcXG4nKTtcclxuICAgICAgICByZXN1bHQuYXBwZW5kKCcgbW9kZTogJyk7XHJcbiAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLm1vZGUgPyB0aGlzLm1vZGUudG9TdHJpbmcoKSA6ICdudWxsJyk7XHJcbiAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuIGVjTGV2ZWw6ICcpO1xyXG4gICAgICAgIHJlc3VsdC5hcHBlbmQodGhpcy5lY0xldmVsID8gdGhpcy5lY0xldmVsLnRvU3RyaW5nKCkgOiAnbnVsbCcpO1xyXG4gICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiB2ZXJzaW9uOiAnKTtcclxuICAgICAgICByZXN1bHQuYXBwZW5kKHRoaXMudmVyc2lvbiA/IHRoaXMudmVyc2lvbi50b1N0cmluZygpIDogJ251bGwnKTtcclxuICAgICAgICByZXN1bHQuYXBwZW5kKCdcXG4gbWFza1BhdHRlcm46ICcpO1xyXG4gICAgICAgIHJlc3VsdC5hcHBlbmQodGhpcy5tYXNrUGF0dGVybi50b1N0cmluZygpKTtcclxuICAgICAgICBpZiAodGhpcy5tYXRyaXgpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCgnXFxuIG1hdHJpeDpcXG4nKTtcclxuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZCh0aGlzLm1hdHJpeC50b1N0cmluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hcHBlbmQoJ1xcbiBtYXRyaXg6IG51bGxcXG4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LmFwcGVuZCgnPj5cXG4nKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvU3RyaW5nKCk7XHJcbiAgICB9O1xyXG4gICAgUVJDb2RlLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgUVJDb2RlLnByb3RvdHlwZS5zZXRFQ0xldmVsID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5lY0xldmVsID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgUVJDb2RlLnByb3RvdHlwZS5zZXRWZXJzaW9uID0gZnVuY3Rpb24gKHZlcnNpb24pIHtcclxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgfTtcclxuICAgIFFSQ29kZS5wcm90b3R5cGUuc2V0TWFza1BhdHRlcm4gPSBmdW5jdGlvbiAodmFsdWUgLyppbnQqLykge1xyXG4gICAgICAgIHRoaXMubWFza1BhdHRlcm4gPSB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBRUkNvZGUucHJvdG90eXBlLnNldE1hdHJpeCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMubWF0cml4ID0gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2hlY2sgaWYgXCJtYXNrX3BhdHRlcm5cIiBpcyB2YWxpZC5cclxuICAgIFFSQ29kZS5pc1ZhbGlkTWFza1BhdHRlcm4gPSBmdW5jdGlvbiAobWFza1BhdHRlcm4gLyppbnQqLykge1xyXG4gICAgICAgIHJldHVybiBtYXNrUGF0dGVybiA+PSAwICYmIG1hc2tQYXR0ZXJuIDwgUVJDb2RlLk5VTV9NQVNLX1BBVFRFUk5TO1xyXG4gICAgfTtcclxuICAgIFFSQ29kZS5OVU1fTUFTS19QQVRURVJOUyA9IDg7XHJcbiAgICByZXR1cm4gUVJDb2RlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBRUkNvZGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVFSQ29kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25cIik7XHJcbnZhciBBcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuLi9BcnJheUluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25cIik7XHJcbnZhciBBcnJheXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBcnJheXMoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBzcGVjaWZpZWQgYXJyYXlcclxuICAgICAqIG9mIGludHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGEgdGhlIGFycmF5IHRvIGJlIGZpbGxlZFxyXG4gICAgICogQHBhcmFtIHZhbCB0aGUgdmFsdWUgdG8gYmUgc3RvcmVkIGluIGFsbCBlbGVtZW50cyBvZiB0aGUgYXJyYXlcclxuICAgICAqL1xyXG4gICAgQXJyYXlzLmZpbGwgPSBmdW5jdGlvbiAoYSwgdmFsKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspXHJcbiAgICAgICAgICAgIGFbaV0gPSB2YWw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBc3NpZ25zIHRoZSBzcGVjaWZpZWQgaW50IHZhbHVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKiByYW5nZSBvZiB0aGUgc3BlY2lmaWVkIGFycmF5IG9mIGludHMuICBUaGUgcmFuZ2UgdG8gYmUgZmlsbGVkXHJcbiAgICAgKiBleHRlbmRzIGZyb20gaW5kZXgge0Bjb2RlIGZyb21JbmRleH0sIGluY2x1c2l2ZSwgdG8gaW5kZXhcclxuICAgICAqIHtAY29kZSB0b0luZGV4fSwgZXhjbHVzaXZlLiAgKElmIHtAY29kZSBmcm9tSW5kZXg9PXRvSW5kZXh9LCB0aGVcclxuICAgICAqIHJhbmdlIHRvIGJlIGZpbGxlZCBpcyBlbXB0eS4pXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGEgdGhlIGFycmF5IHRvIGJlIGZpbGxlZFxyXG4gICAgICogQHBhcmFtIGZyb21JbmRleCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGVsZW1lbnQgKGluY2x1c2l2ZSkgdG8gYmVcclxuICAgICAqICAgICAgICBmaWxsZWQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gdG9JbmRleCB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZWxlbWVudCAoZXhjbHVzaXZlKSB0byBiZVxyXG4gICAgICogICAgICAgIGZpbGxlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVcclxuICAgICAqIEBwYXJhbSB2YWwgdGhlIHZhbHVlIHRvIGJlIHN0b3JlZCBpbiBhbGwgZWxlbWVudHMgb2YgdGhlIGFycmF5XHJcbiAgICAgKiBAdGhyb3dzIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBpZiB7QGNvZGUgZnJvbUluZGV4ID4gdG9JbmRleH1cclxuICAgICAqIEB0aHJvd3MgQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uIGlmIHtAY29kZSBmcm9tSW5kZXggPCAwfSBvclxyXG4gICAgICogICAgICAgICB7QGNvZGUgdG9JbmRleCA+IGEubGVuZ3RofVxyXG4gICAgICovXHJcbiAgICBBcnJheXMuZmlsbFdpdGhpbiA9IGZ1bmN0aW9uIChhLCBmcm9tSW5kZXgsIHRvSW5kZXgsIHZhbCkge1xyXG4gICAgICAgIEFycmF5cy5yYW5nZUNoZWNrKGEubGVuZ3RoLCBmcm9tSW5kZXgsIHRvSW5kZXgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXg7IGkgPCB0b0luZGV4OyBpKyspXHJcbiAgICAgICAgICAgIGFbaV0gPSB2YWw7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdGhhdCB7QGNvZGUgZnJvbUluZGV4fSBhbmQge0Bjb2RlIHRvSW5kZXh9IGFyZSBpblxyXG4gICAgICogdGhlIHJhbmdlIGFuZCB0aHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZXkgYXJlbid0LlxyXG4gICAgICovXHJcbiAgICBBcnJheXMucmFuZ2VDaGVjayA9IGZ1bmN0aW9uIChhcnJheUxlbmd0aCwgZnJvbUluZGV4LCB0b0luZGV4KSB7XHJcbiAgICAgICAgaWYgKGZyb21JbmRleCA+IHRvSW5kZXgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ2Zyb21JbmRleCgnICsgZnJvbUluZGV4ICsgJykgPiB0b0luZGV4KCcgKyB0b0luZGV4ICsgJyknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEFycmF5SW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbl8xLmRlZmF1bHQoZnJvbUluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRvSW5kZXggPiBhcnJheUxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJyYXlJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXzEuZGVmYXVsdCh0b0luZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXJyYXlzLmFzTGlzdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyZ3M7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlzLmNyZWF0ZSA9IGZ1bmN0aW9uIChyb3dzLCBjb2xzLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBhcnIgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiByb3dzIH0pO1xyXG4gICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb2xzIH0pLmZpbGwodmFsdWUpOyB9KTtcclxuICAgIH07XHJcbiAgICBBcnJheXMuY3JlYXRlSW50MzJBcnJheSA9IGZ1bmN0aW9uIChyb3dzLCBjb2xzLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBhcnIgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiByb3dzIH0pO1xyXG4gICAgICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBJbnQzMkFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHMgfSkuZmlsbCh2YWx1ZSk7IH0pO1xyXG4gICAgfTtcclxuICAgIEFycmF5cy5lcXVhbHMgPSBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xyXG4gICAgICAgIGlmICghZmlyc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNlY29uZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZmlyc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzZWNvbmQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpcnN0Lmxlbmd0aCAhPT0gc2Vjb25kLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IGZpcnN0Lmxlbmd0aDsgaSA8IGxlbmd0aF8xOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGZpcnN0W2ldICE9PSBzZWNvbmRbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBBcnJheXMuaGFzaENvZGUgPSBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgIHZhciBlXzEsIF9hO1xyXG4gICAgICAgIGlmIChhID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gMTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBhXzEgPSBfX3ZhbHVlcyhhKSwgYV8xXzEgPSBhXzEubmV4dCgpOyAhYV8xXzEuZG9uZTsgYV8xXzEgPSBhXzEubmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGFfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gMzEgKiByZXN1bHQgKyBlbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYV8xXzEgJiYgIWFfMV8xLmRvbmUgJiYgKF9hID0gYV8xLnJldHVybikpIF9hLmNhbGwoYV8xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlzLmZpbGxVaW50OEFycmF5ID0gZnVuY3Rpb24gKGEsIHZhbHVlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYVtpXSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBcnJheXMuY29weU9mID0gZnVuY3Rpb24gKG9yaWdpbmFsLCBuZXdMZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gb3JpZ2luYWwuc2xpY2UoMCwgbmV3TGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICBBcnJheXMuY29weU9mVWludDhBcnJheSA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbmV3TGVuZ3RoKSB7XHJcbiAgICAgICAgaWYgKG9yaWdpbmFsLmxlbmd0aCA8PSBuZXdMZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIG5ld0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkobmV3TGVuZ3RoKTtcclxuICAgICAgICAgICAgbmV3QXJyYXkuc2V0KG9yaWdpbmFsKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ld0FycmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3JpZ2luYWwuc2xpY2UoMCwgbmV3TGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICBBcnJheXMuY29weU9mUmFuZ2UgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGZyb20sIHRvKSB7XHJcbiAgICAgICAgdmFyIG5ld0xlbmd0aCA9IHRvIC0gZnJvbTtcclxuICAgICAgICB2YXIgY29weSA9IG5ldyBJbnQzMkFycmF5KG5ld0xlbmd0aCk7XHJcbiAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkob3JpZ2luYWwsIGZyb20sIGNvcHksIDAsIG5ld0xlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgICogUmV0dXJucyB0aGUgaW5kZXggb2Ygb2YgdGhlIGVsZW1lbnQgaW4gYSBzb3J0ZWQgYXJyYXkgb3IgKC1uLTEpIHdoZXJlIG4gaXMgdGhlIGluc2VydGlvbiBwb2ludFxyXG4gICAgKiBmb3IgdGhlIG5ldyBlbGVtZW50LlxyXG4gICAgKiBQYXJhbWV0ZXJzOlxyXG4gICAgKiAgICAgYXIgLSBBIHNvcnRlZCBhcnJheVxyXG4gICAgKiAgICAgZWwgLSBBbiBlbGVtZW50IHRvIHNlYXJjaCBmb3JcclxuICAgICogICAgIGNvbXBhcmF0b3IgLSBBIGNvbXBhcmF0b3IgZnVuY3Rpb24uIFRoZSBmdW5jdGlvbiB0YWtlcyB0d28gYXJndW1lbnRzOiAoYSwgYikgYW5kIHJldHVybnM6XHJcbiAgICAqICAgICAgICBhIG5lZ2F0aXZlIG51bWJlciAgaWYgYSBpcyBsZXNzIHRoYW4gYjtcclxuICAgICogICAgICAgIDAgaWYgYSBpcyBlcXVhbCB0byBiO1xyXG4gICAgKiAgICAgICAgYSBwb3NpdGl2ZSBudW1iZXIgb2YgYSBpcyBncmVhdGVyIHRoYW4gYi5cclxuICAgICogVGhlIGFycmF5IG1heSBjb250YWluIGR1cGxpY2F0ZSBlbGVtZW50cy4gSWYgdGhlcmUgYXJlIG1vcmUgdGhhbiBvbmUgZXF1YWwgZWxlbWVudHMgaW4gdGhlIGFycmF5LFxyXG4gICAgKiB0aGUgcmV0dXJuZWQgdmFsdWUgY2FuIGJlIHRoZSBpbmRleCBvZiBhbnkgb25lIG9mIHRoZSBlcXVhbCBlbGVtZW50cy5cclxuICAgICpcclxuICAgICogaHR0cDovL2pzZmlkZGxlLm5ldC9hcnl6aG92L3BrZnN0NTUwL1xyXG4gICAgKi9cclxuICAgIEFycmF5cy5iaW5hcnlTZWFyY2ggPSBmdW5jdGlvbiAoYXIsIGVsLCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY29tcGFyYXRvcikge1xyXG4gICAgICAgICAgICBjb21wYXJhdG9yID0gQXJyYXlzLm51bWJlckNvbXBhcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtID0gMDtcclxuICAgICAgICB2YXIgbiA9IGFyLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgd2hpbGUgKG0gPD0gbikge1xyXG4gICAgICAgICAgICB2YXIgayA9IChuICsgbSkgPj4gMTtcclxuICAgICAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoZWwsIGFyW2tdKTtcclxuICAgICAgICAgICAgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG0gPSBrICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBuID0gayAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLW0gLSAxO1xyXG4gICAgfTtcclxuICAgIEFycmF5cy5udW1iZXJDb21wYXJhdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEFycmF5cztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQXJyYXlzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qXHJcbiAqIENvcHlyaWdodCAoYykgMTk5NCwgMjAxMCwgT3JhY2xlIGFuZC9vciBpdHMgYWZmaWxpYXRlcy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICogRE8gTk9UIEFMVEVSIE9SIFJFTU9WRSBDT1BZUklHSFQgTk9USUNFUyBPUiBUSElTIEZJTEUgSEVBREVSLlxyXG4gKlxyXG4gKiBUaGlzIGNvZGUgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdFxyXG4gKiB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gMiBvbmx5LCBhc1xyXG4gKiBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbi4gIE9yYWNsZSBkZXNpZ25hdGVzIHRoaXNcclxuICogcGFydGljdWxhciBmaWxlIGFzIHN1YmplY3QgdG8gdGhlIFwiQ2xhc3NwYXRoXCIgZXhjZXB0aW9uIGFzIHByb3ZpZGVkXHJcbiAqIGJ5IE9yYWNsZSBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXQgYWNjb21wYW5pZWQgdGhpcyBjb2RlLlxyXG4gKlxyXG4gKiBUaGlzIGNvZGUgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVRcclxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yXHJcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxyXG4gKiB2ZXJzaW9uIDIgZm9yIG1vcmUgZGV0YWlscyAoYSBjb3B5IGlzIGluY2x1ZGVkIGluIHRoZSBMSUNFTlNFIGZpbGUgdGhhdFxyXG4gKiBhY2NvbXBhbmllZCB0aGlzIGNvZGUpLlxyXG4gKlxyXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uXHJcbiAqIDIgYWxvbmcgd2l0aCB0aGlzIHdvcms7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbixcclxuICogSW5jLiwgNTEgRnJhbmtsaW4gU3QsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBLlxyXG4gKlxyXG4gKiBQbGVhc2UgY29udGFjdCBPcmFjbGUsIDUwMCBPcmFjbGUgUGFya3dheSwgUmVkd29vZCBTaG9yZXMsIENBIDk0MDY1IFVTQVxyXG4gKiBvciB2aXNpdCB3d3cub3JhY2xlLmNvbSBpZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIG9yIGhhdmUgYW55XHJcbiAqIHF1ZXN0aW9ucy5cclxuICovXHJcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG59KSgpO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIHBhY2thZ2UgamF2YS5pbztcclxuLy8gaW1wb3J0IGphdmEudXRpbC5BcnJheXM7XHJcbnZhciBBcnJheXNfMSA9IHJlcXVpcmUoXCIuL0FycmF5c1wiKTtcclxudmFyIE91dHB1dFN0cmVhbV8xID0gcmVxdWlyZShcIi4vT3V0cHV0U3RyZWFtXCIpO1xyXG52YXIgSW50ZWdlcl8xID0gcmVxdWlyZShcIi4vSW50ZWdlclwiKTtcclxudmFyIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxudmFyIE91dE9mTWVtb3J5RXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9PdXRPZk1lbW9yeUVycm9yXCIpO1xyXG52YXIgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbnZhciBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi4vSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvblwiKTtcclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBhbiBvdXRwdXQgc3RyZWFtIGluIHdoaWNoIHRoZSBkYXRhIGlzXHJcbiAqIHdyaXR0ZW4gaW50byBhIGJ5dGUgYXJyYXkuIFRoZSBidWZmZXIgYXV0b21hdGljYWxseSBncm93cyBhcyBkYXRhXHJcbiAqIGlzIHdyaXR0ZW4gdG8gaXQuXHJcbiAqIFRoZSBkYXRhIGNhbiBiZSByZXRyaWV2ZWQgdXNpbmcgPGNvZGU+dG9CeXRlQXJyYXkoKTwvY29kZT4gYW5kXHJcbiAqIDxjb2RlPnRvU3RyaW5nKCk8L2NvZGU+LlxyXG4gKiA8cD5cclxuICogQ2xvc2luZyBhIDx0dD5CeXRlQXJyYXlPdXRwdXRTdHJlYW08L3R0PiBoYXMgbm8gZWZmZWN0LiBUaGUgbWV0aG9kcyBpblxyXG4gKiB0aGlzIGNsYXNzIGNhbiBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHN0cmVhbSBoYXMgYmVlbiBjbG9zZWQgd2l0aG91dFxyXG4gKiBnZW5lcmF0aW5nIGFuIDx0dD5JT0V4Y2VwdGlvbjwvdHQ+LlxyXG4gKlxyXG4gKiBAYXV0aG9yICBBcnRodXIgdmFuIEhvZmZcclxuICogQHNpbmNlICAgSkRLMS4wXHJcbiAqL1xyXG52YXIgQnl0ZUFycmF5T3V0cHV0U3RyZWFtID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKEJ5dGVBcnJheU91dHB1dFN0cmVhbSwgX3N1cGVyKTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0uIFRoZSBidWZmZXIgY2FwYWNpdHkgaXNcclxuICAgICAqIGluaXRpYWxseSAzMiBieXRlcywgdGhvdWdoIGl0cyBzaXplIGluY3JlYXNlcyBpZiBuZWNlc3NhcnkuXHJcbiAgICAgKi9cclxuICAgIC8vIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgIC8vICAgICB0aGlzKDMyKTtcclxuICAgIC8vIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0sIHdpdGggYSBidWZmZXIgY2FwYWNpdHkgb2ZcclxuICAgICAqIHRoZSBzcGVjaWZpZWQgc2l6ZSwgaW4gYnl0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgc2l6ZSAgIHRoZSBpbml0aWFsIHNpemUuXHJcbiAgICAgKiBAZXhjZXB0aW9uICBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gaWYgc2l6ZSBpcyBuZWdhdGl2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQnl0ZUFycmF5T3V0cHV0U3RyZWFtKHNpemUpIHtcclxuICAgICAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSB7IHNpemUgPSAzMjsgfVxyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG51bWJlciBvZiB2YWxpZCBieXRlcyBpbiB0aGUgYnVmZmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmNvdW50ID0gMDtcclxuICAgICAgICBpZiAoc2l6ZSA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbl8xLmRlZmF1bHQoJ05lZ2F0aXZlIGluaXRpYWwgc2l6ZTogJ1xyXG4gICAgICAgICAgICAgICAgKyBzaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuYnVmID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmNyZWFzZXMgdGhlIGNhcGFjaXR5IGlmIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhhdCBpdCBjYW4gaG9sZFxyXG4gICAgICogYXQgbGVhc3QgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzcGVjaWZpZWQgYnkgdGhlIG1pbmltdW1cclxuICAgICAqIGNhcGFjaXR5IGFyZ3VtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtaW5DYXBhY2l0eSB0aGUgZGVzaXJlZCBtaW5pbXVtIGNhcGFjaXR5XHJcbiAgICAgKiBAdGhyb3dzIE91dE9mTWVtb3J5RXJyb3IgaWYge0Bjb2RlIG1pbkNhcGFjaXR5IDwgMH0uICBUaGlzIGlzXHJcbiAgICAgKiBpbnRlcnByZXRlZCBhcyBhIHJlcXVlc3QgZm9yIHRoZSB1bnNhdGlzZmlhYmx5IGxhcmdlIGNhcGFjaXR5XHJcbiAgICAgKiB7QGNvZGUgKGxvbmcpIEludGVnZXIuTUFYX1ZBTFVFICsgKG1pbkNhcGFjaXR5IC0gSW50ZWdlci5NQVhfVkFMVUUpfS5cclxuICAgICAqL1xyXG4gICAgQnl0ZUFycmF5T3V0cHV0U3RyZWFtLnByb3RvdHlwZS5lbnN1cmVDYXBhY2l0eSA9IGZ1bmN0aW9uIChtaW5DYXBhY2l0eSkge1xyXG4gICAgICAgIC8vIG92ZXJmbG93LWNvbnNjaW91cyBjb2RlXHJcbiAgICAgICAgaWYgKG1pbkNhcGFjaXR5IC0gdGhpcy5idWYubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgdGhpcy5ncm93KG1pbkNhcGFjaXR5KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluY3JlYXNlcyB0aGUgY2FwYWNpdHkgdG8gZW5zdXJlIHRoYXQgaXQgY2FuIGhvbGQgYXQgbGVhc3QgdGhlXHJcbiAgICAgKiBudW1iZXIgb2YgZWxlbWVudHMgc3BlY2lmaWVkIGJ5IHRoZSBtaW5pbXVtIGNhcGFjaXR5IGFyZ3VtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtaW5DYXBhY2l0eSB0aGUgZGVzaXJlZCBtaW5pbXVtIGNhcGFjaXR5XHJcbiAgICAgKi9cclxuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUuZ3JvdyA9IGZ1bmN0aW9uIChtaW5DYXBhY2l0eSkge1xyXG4gICAgICAgIC8vIG92ZXJmbG93LWNvbnNjaW91cyBjb2RlXHJcbiAgICAgICAgdmFyIG9sZENhcGFjaXR5ID0gdGhpcy5idWYubGVuZ3RoO1xyXG4gICAgICAgIHZhciBuZXdDYXBhY2l0eSA9IG9sZENhcGFjaXR5IDw8IDE7XHJcbiAgICAgICAgaWYgKG5ld0NhcGFjaXR5IC0gbWluQ2FwYWNpdHkgPCAwKVxyXG4gICAgICAgICAgICBuZXdDYXBhY2l0eSA9IG1pbkNhcGFjaXR5O1xyXG4gICAgICAgIGlmIChuZXdDYXBhY2l0eSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKG1pbkNhcGFjaXR5IDwgMCkgLy8gb3ZlcmZsb3dcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPdXRPZk1lbW9yeUVycm9yXzEuZGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBuZXdDYXBhY2l0eSA9IEludGVnZXJfMS5kZWZhdWx0Lk1BWF9WQUxVRTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5idWYgPSBBcnJheXNfMS5kZWZhdWx0LmNvcHlPZlVpbnQ4QXJyYXkodGhpcy5idWYsIG5ld0NhcGFjaXR5KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyB0aGUgc3BlY2lmaWVkIGJ5dGUgdG8gdGhpcyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgYiAgIHRoZSBieXRlIHRvIGJlIHdyaXR0ZW4uXHJcbiAgICAgKi9cclxuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5jb3VudCArIDEpO1xyXG4gICAgICAgIHRoaXMuYnVmW3RoaXMuY291bnRdID0gLyooYnl0ZSkqLyBiO1xyXG4gICAgICAgIHRoaXMuY291bnQgKz0gMTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyA8Y29kZT5sZW48L2NvZGU+IGJ5dGVzIGZyb20gdGhlIHNwZWNpZmllZCBieXRlIGFycmF5XHJcbiAgICAgKiBzdGFydGluZyBhdCBvZmZzZXQgPGNvZGU+b2ZmPC9jb2RlPiB0byB0aGlzIGJ5dGUgYXJyYXkgb3V0cHV0IHN0cmVhbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICBiICAgICB0aGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSAgIG9mZiAgIHRoZSBzdGFydCBvZmZzZXQgaW4gdGhlIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0gICBsZW4gICB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlLlxyXG4gICAgICovXHJcbiAgICBCeXRlQXJyYXlPdXRwdXRTdHJlYW0ucHJvdG90eXBlLndyaXRlQnl0ZXNPZmZzZXQgPSBmdW5jdGlvbiAoYiwgb2ZmLCBsZW4pIHtcclxuICAgICAgICBpZiAoKG9mZiA8IDApIHx8IChvZmYgPiBiLmxlbmd0aCkgfHwgKGxlbiA8IDApIHx8XHJcbiAgICAgICAgICAgICgob2ZmICsgbGVuKSAtIGIubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkodGhpcy5jb3VudCArIGxlbik7XHJcbiAgICAgICAgU3lzdGVtXzEuZGVmYXVsdC5hcnJheWNvcHkoYiwgb2ZmLCB0aGlzLmJ1ZiwgdGhpcy5jb3VudCwgbGVuKTtcclxuICAgICAgICB0aGlzLmNvdW50ICs9IGxlbjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyB0aGUgY29tcGxldGUgY29udGVudHMgb2YgdGhpcyBieXRlIGFycmF5IG91dHB1dCBzdHJlYW0gdG9cclxuICAgICAqIHRoZSBzcGVjaWZpZWQgb3V0cHV0IHN0cmVhbSBhcmd1bWVudCwgYXMgaWYgYnkgY2FsbGluZyB0aGUgb3V0cHV0XHJcbiAgICAgKiBzdHJlYW0ncyB3cml0ZSBtZXRob2QgdXNpbmcgPGNvZGU+b3V0LndyaXRlKGJ1ZiwgMCwgY291bnQpPC9jb2RlPi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICAgICBvdXQgICB0aGUgb3V0cHV0IHN0cmVhbSB0byB3aGljaCB0byB3cml0ZSB0aGUgZGF0YS5cclxuICAgICAqIEBleGNlcHRpb24gIElPRXhjZXB0aW9uICBpZiBhbiBJL08gZXJyb3Igb2NjdXJzLlxyXG4gICAgICovXHJcbiAgICBCeXRlQXJyYXlPdXRwdXRTdHJlYW0ucHJvdG90eXBlLndyaXRlVG8gPSBmdW5jdGlvbiAob3V0KSB7XHJcbiAgICAgICAgb3V0LndyaXRlQnl0ZXNPZmZzZXQodGhpcy5idWYsIDAsIHRoaXMuY291bnQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSA8Y29kZT5jb3VudDwvY29kZT4gZmllbGQgb2YgdGhpcyBieXRlIGFycmF5IG91dHB1dFxyXG4gICAgICogc3RyZWFtIHRvIHplcm8sIHNvIHRoYXQgYWxsIGN1cnJlbnRseSBhY2N1bXVsYXRlZCBvdXRwdXQgaW4gdGhlXHJcbiAgICAgKiBvdXRwdXQgc3RyZWFtIGlzIGRpc2NhcmRlZC4gVGhlIG91dHB1dCBzdHJlYW0gY2FuIGJlIHVzZWQgYWdhaW4sXHJcbiAgICAgKiByZXVzaW5nIHRoZSBhbHJlYWR5IGFsbG9jYXRlZCBidWZmZXIgc3BhY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSAgICAgamF2YS5pby5CeXRlQXJyYXlJbnB1dFN0cmVhbSNjb3VudFxyXG4gICAgICovXHJcbiAgICBCeXRlQXJyYXlPdXRwdXRTdHJlYW0ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ld2x5IGFsbG9jYXRlZCBieXRlIGFycmF5LiBJdHMgc2l6ZSBpcyB0aGUgY3VycmVudFxyXG4gICAgICogc2l6ZSBvZiB0aGlzIG91dHB1dCBzdHJlYW0gYW5kIHRoZSB2YWxpZCBjb250ZW50cyBvZiB0aGUgYnVmZmVyXHJcbiAgICAgKiBoYXZlIGJlZW4gY29waWVkIGludG8gaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiAgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhpcyBvdXRwdXQgc3RyZWFtLCBhcyBhIGJ5dGUgYXJyYXkuXHJcbiAgICAgKiBAc2VlICAgICBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbSNzaXplKClcclxuICAgICAqL1xyXG4gICAgQnl0ZUFycmF5T3V0cHV0U3RyZWFtLnByb3RvdHlwZS50b0J5dGVBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXlzXzEuZGVmYXVsdC5jb3B5T2ZVaW50OEFycmF5KHRoaXMuYnVmLCB0aGlzLmNvdW50KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4gIHRoZSB2YWx1ZSBvZiB0aGUgPGNvZGU+Y291bnQ8L2NvZGU+IGZpZWxkLCB3aGljaCBpcyB0aGUgbnVtYmVyXHJcbiAgICAgKiAgICAgICAgICBvZiB2YWxpZCBieXRlcyBpbiB0aGlzIG91dHB1dCBzdHJlYW0uXHJcbiAgICAgKiBAc2VlICAgICBqYXZhLmlvLkJ5dGVBcnJheU91dHB1dFN0cmVhbSNjb3VudFxyXG4gICAgICovXHJcbiAgICBCeXRlQXJyYXlPdXRwdXRTdHJlYW0ucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnQ7XHJcbiAgICB9O1xyXG4gICAgQnl0ZUFycmF5T3V0cHV0U3RyZWFtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChwYXJhbSkge1xyXG4gICAgICAgIGlmICghcGFyYW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmdfdm9pZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZ19zdHJpbmcocGFyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZ19udW1iZXIocGFyYW0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGJ1ZmZlcidzIGNvbnRlbnRzIGludG8gYSBzdHJpbmcgZGVjb2RpbmcgYnl0ZXMgdXNpbmcgdGhlXHJcbiAgICAgKiBwbGF0Zm9ybSdzIGRlZmF1bHQgY2hhcmFjdGVyIHNldC4gVGhlIGxlbmd0aCBvZiB0aGUgbmV3IDx0dD5TdHJpbmc8L3R0PlxyXG4gICAgICogaXMgYSBmdW5jdGlvbiBvZiB0aGUgY2hhcmFjdGVyIHNldCwgYW5kIGhlbmNlIG1heSBub3QgYmUgZXF1YWwgdG8gdGhlXHJcbiAgICAgKiBzaXplIG9mIHRoZSBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogPHA+IFRoaXMgbWV0aG9kIGFsd2F5cyByZXBsYWNlcyBtYWxmb3JtZWQtaW5wdXQgYW5kIHVubWFwcGFibGUtY2hhcmFjdGVyXHJcbiAgICAgKiBzZXF1ZW5jZXMgd2l0aCB0aGUgZGVmYXVsdCByZXBsYWNlbWVudCBzdHJpbmcgZm9yIHRoZSBwbGF0Zm9ybSdzXHJcbiAgICAgKiBkZWZhdWx0IGNoYXJhY3RlciBzZXQuIFRoZSB7QGxpbmtwbGFpbiBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXREZWNvZGVyfVxyXG4gICAgICogY2xhc3Mgc2hvdWxkIGJlIHVzZWQgd2hlbiBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgZGVjb2RpbmcgcHJvY2VzcyBpc1xyXG4gICAgICogcmVxdWlyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBTdHJpbmcgZGVjb2RlZCBmcm9tIHRoZSBidWZmZXIncyBjb250ZW50cy5cclxuICAgICAqIEBzaW5jZSAgSkRLMS4xXHJcbiAgICAgKi9cclxuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUudG9TdHJpbmdfdm9pZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFN0cmluZyh0aGlzLmJ1ZiAvKiwgMCwgdGhpcy5jb3VudCovKS50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIGJ1ZmZlcidzIGNvbnRlbnRzIGludG8gYSBzdHJpbmcgYnkgZGVjb2RpbmcgdGhlIGJ5dGVzIHVzaW5nXHJcbiAgICAgKiB0aGUgc3BlY2lmaWVkIHtAbGluayBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXQgY2hhcnNldE5hbWV9LiBUaGUgbGVuZ3RoIG9mXHJcbiAgICAgKiB0aGUgbmV3IDx0dD5TdHJpbmc8L3R0PiBpcyBhIGZ1bmN0aW9uIG9mIHRoZSBjaGFyc2V0LCBhbmQgaGVuY2UgbWF5IG5vdCBiZVxyXG4gICAgICogZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYnl0ZSBhcnJheS5cclxuICAgICAqXHJcbiAgICAgKiA8cD4gVGhpcyBtZXRob2QgYWx3YXlzIHJlcGxhY2VzIG1hbGZvcm1lZC1pbnB1dCBhbmQgdW5tYXBwYWJsZS1jaGFyYWN0ZXJcclxuICAgICAqIHNlcXVlbmNlcyB3aXRoIHRoaXMgY2hhcnNldCdzIGRlZmF1bHQgcmVwbGFjZW1lbnQgc3RyaW5nLiBUaGUge0BsaW5rXHJcbiAgICAgKiBqYXZhLm5pby5jaGFyc2V0LkNoYXJzZXREZWNvZGVyfSBjbGFzcyBzaG91bGQgYmUgdXNlZCB3aGVuIG1vcmUgY29udHJvbFxyXG4gICAgICogb3ZlciB0aGUgZGVjb2RpbmcgcHJvY2VzcyBpcyByZXF1aXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gIGNoYXJzZXROYW1lICB0aGUgbmFtZSBvZiBhIHN1cHBvcnRlZFxyXG4gICAgICogICAgICAgICAgICAgIHtAbGlua3BsYWluIGphdmEubmlvLmNoYXJzZXQuQ2hhcnNldCA8L2NvZGU+Y2hhcnNldDxjb2RlPn1cclxuICAgICAqIEByZXR1cm4gU3RyaW5nIGRlY29kZWQgZnJvbSB0aGUgYnVmZmVyJ3MgY29udGVudHMuXHJcbiAgICAgKiBAZXhjZXB0aW9uICBVbnN1cHBvcnRlZEVuY29kaW5nRXhjZXB0aW9uXHJcbiAgICAgKiAgICAgICAgICAgICBJZiB0aGUgbmFtZWQgY2hhcnNldCBpcyBub3Qgc3VwcG9ydGVkXHJcbiAgICAgKiBAc2luY2UgICBKREsxLjFcclxuICAgICAqL1xyXG4gICAgQnl0ZUFycmF5T3V0cHV0U3RyZWFtLnByb3RvdHlwZS50b1N0cmluZ19zdHJpbmcgPSBmdW5jdGlvbiAoY2hhcnNldE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFN0cmluZyh0aGlzLmJ1ZiAvKiwgMCwgdGhpcy5jb3VudCwgY2hhcnNldE5hbWUqLykudG9TdHJpbmcoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXdseSBhbGxvY2F0ZWQgc3RyaW5nLiBJdHMgc2l6ZSBpcyB0aGUgY3VycmVudCBzaXplIG9mXHJcbiAgICAgKiB0aGUgb3V0cHV0IHN0cmVhbSBhbmQgdGhlIHZhbGlkIGNvbnRlbnRzIG9mIHRoZSBidWZmZXIgaGF2ZSBiZWVuXHJcbiAgICAgKiBjb3BpZWQgaW50byBpdC4gRWFjaCBjaGFyYWN0ZXIgPGk+YzwvaT4gaW4gdGhlIHJlc3VsdGluZyBzdHJpbmcgaXNcclxuICAgICAqIGNvbnN0cnVjdGVkIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCA8aT5iPC9pPiBpbiB0aGUgYnl0ZVxyXG4gICAgICogYXJyYXkgc3VjaCB0aGF0OlxyXG4gICAgICogPGJsb2NrcXVvdGU+PHByZT5cclxuICAgICAqICAgICBjID09IChjaGFyKSgoKGhpYnl0ZSAmYW1wOyAweGZmKSAmbHQ7Jmx0OyA4KSB8IChiICZhbXA7IDB4ZmYpKVxyXG4gICAgICogPC9wcmU+PC9ibG9ja3F1b3RlPlxyXG4gICAgICpcclxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgbWV0aG9kIGRvZXMgbm90IHByb3Blcmx5IGNvbnZlcnQgYnl0ZXMgaW50byBjaGFyYWN0ZXJzLlxyXG4gICAgICogQXMgb2YgSkRLJm5ic3A7MS4xLCB0aGUgcHJlZmVycmVkIHdheSB0byBkbyB0aGlzIGlzIHZpYSB0aGVcclxuICAgICAqIDxjb2RlPnRvU3RyaW5nKFN0cmluZyBlbmMpPC9jb2RlPiBtZXRob2QsIHdoaWNoIHRha2VzIGFuIGVuY29kaW5nLW5hbWVcclxuICAgICAqIGFyZ3VtZW50LCBvciB0aGUgPGNvZGU+dG9TdHJpbmcoKTwvY29kZT4gbWV0aG9kLCB3aGljaCB1c2VzIHRoZVxyXG4gICAgICogcGxhdGZvcm0ncyBkZWZhdWx0IGNoYXJhY3RlciBlbmNvZGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICAgICBoaWJ5dGUgICAgdGhlIGhpZ2ggYnl0ZSBvZiBlYWNoIHJlc3VsdGluZyBVbmljb2RlIGNoYXJhY3Rlci5cclxuICAgICAqIEByZXR1cm4gICAgIHRoZSBjdXJyZW50IGNvbnRlbnRzIG9mIHRoZSBvdXRwdXQgc3RyZWFtLCBhcyBhIHN0cmluZy5cclxuICAgICAqIEBzZWUgICAgICAgIGphdmEuaW8uQnl0ZUFycmF5T3V0cHV0U3RyZWFtI3NpemUoKVxyXG4gICAgICogQHNlZSAgICAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jdG9TdHJpbmcoU3RyaW5nKVxyXG4gICAgICogQHNlZSAgICAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW0jdG9TdHJpbmcoKVxyXG4gICAgICovXHJcbiAgICAvLyBARGVwcmVjYXRlZFxyXG4gICAgQnl0ZUFycmF5T3V0cHV0U3RyZWFtLnByb3RvdHlwZS50b1N0cmluZ19udW1iZXIgPSBmdW5jdGlvbiAoaGlieXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmcodGhpcy5idWYgLyosIGhpYnl0ZSwgMCwgdGhpcy5jb3VudCovKS50b1N0cmluZygpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2luZyBhIDx0dD5CeXRlQXJyYXlPdXRwdXRTdHJlYW08L3R0PiBoYXMgbm8gZWZmZWN0LiBUaGUgbWV0aG9kcyBpblxyXG4gICAgICogdGhpcyBjbGFzcyBjYW4gYmUgY2FsbGVkIGFmdGVyIHRoZSBzdHJlYW0gaGFzIGJlZW4gY2xvc2VkIHdpdGhvdXRcclxuICAgICAqIGdlbmVyYXRpbmcgYW4gPHR0PklPRXhjZXB0aW9uPC90dD4uXHJcbiAgICAgKiA8cD5cclxuICAgICAqXHJcbiAgICAgKiBAdGhyb3dzIElPRXhjZXB0aW9uXHJcbiAgICAgKi9cclxuICAgIEJ5dGVBcnJheU91dHB1dFN0cmVhbS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJ5dGVBcnJheU91dHB1dFN0cmVhbTtcclxufShPdXRwdXRTdHJlYW1fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJ5dGVBcnJheU91dHB1dFN0cmVhbTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qnl0ZUFycmF5T3V0cHV0U3RyZWFtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBQb255ZmlsbCBmb3IgSmF2YSdzIEZsb2F0IGNsYXNzLlxyXG4gKi9cclxudmFyIEZsb2F0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRmxvYXQoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNpbmNUUyBoYXMgbm8gZGlmZmVyZW5jZSBiZXR3ZWVuIGludCBhbmQgZmxvYXQsIHRoZXJlJ3MgYWxsIG51bWJlcnMsXHJcbiAgICAgKiB0aGlzIGlzIHVzZWQgb25seSB0byBwb2x5ZmlsbCBKYXZhIGNvZGUuXHJcbiAgICAgKi9cclxuICAgIEZsb2F0LmZsb2F0VG9JbnRCaXRzID0gZnVuY3Rpb24gKGYpIHtcclxuICAgICAgICByZXR1cm4gZjtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmbG9hdCBtYXggdmFsdWUgaW4gSlMgaXMgdGhlIG51bWJlciBtYXggdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIEZsb2F0Lk1BWF9WQUxVRSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgcmV0dXJuIEZsb2F0O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBGbG9hdDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmxvYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEphdmEgRm9ybWF0dGVyIGNsYXNzIHBvbHlmaWxsIHRoYXQgd29ya3MgaW4gdGhlIEpTIHdheS5cclxuICovXHJcbnZhciBGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGb3JtYXR0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSAnJztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEzNDM5NzExLzQzNjc2ODNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RyXHJcbiAgICAgKiBAcGFyYW0gYXJyXHJcbiAgICAgKi9cclxuICAgIEZvcm1hdHRlci5mb3JtID0gZnVuY3Rpb24gKHN0ciwgYXJyKSB7XHJcbiAgICAgICAgdmFyIGkgPSAtMTtcclxuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhleHAsIHAwLCBwMSwgcDIsIHAzLCBwNCkge1xyXG4gICAgICAgICAgICBpZiAoZXhwID09PSAnJSUnKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICclJztcclxuICAgICAgICAgICAgaWYgKGFyclsrK2ldID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBleHAgPSBwMiA/IHBhcnNlSW50KHAyLnN1YnN0cigxKSkgOiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHZhciBiYXNlID0gcDMgPyBwYXJzZUludChwMy5zdWJzdHIoMSkpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHA0KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzJzpcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcnJbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdjJzpcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBhcnJbaV1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdmJzpcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFycltpXSkudG9GaXhlZChleHApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdChhcnJbaV0pLnRvUHJlY2lzaW9uKGV4cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdlJzpcclxuICAgICAgICAgICAgICAgICAgICB2YWwgPSBwYXJzZUZsb2F0KGFycltpXSkudG9FeHBvbmVudGlhbChleHApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAneCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQoYXJyW2ldKS50b1N0cmluZyhiYXNlID8gYmFzZSA6IDE2KTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQocGFyc2VJbnQoYXJyW2ldLCBiYXNlID8gYmFzZSA6IDEwKS50b1ByZWNpc2lvbihleHApKS50b0ZpeGVkKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdvYmplY3QnID8gSlNPTi5zdHJpbmdpZnkodmFsKSA6ICgrdmFsKS50b1N0cmluZyhiYXNlKTtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSBwYXJzZUludChwMSk7IC8qIHBhZGRpbmcgc2l6ZSAqL1xyXG4gICAgICAgICAgICB2YXIgY2ggPSBwMSAmJiAocDFbMF0gKyAnJykgPT09ICcwJyA/ICcwJyA6ICcgJzsgLyogaXNudWxsPyAqL1xyXG4gICAgICAgICAgICB3aGlsZSAodmFsLmxlbmd0aCA8IHNpemUpXHJcbiAgICAgICAgICAgICAgICB2YWwgPSBwMCAhPT0gdW5kZWZpbmVkID8gdmFsICsgY2ggOiBjaCArIHZhbDsgLyogaXNtaW51cz8gKi9cclxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlZ2V4ID0gLyUoLSk/KDA/WzAtOV0rKT8oWy5dWzAtOV0rKT8oWyNdWzAtOV0rKT8oW3NjZnBleGQlXSkvZztcclxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnZXgsIGNhbGxiYWNrKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXBwZW5kIFRoZSBuZXcgc3RyaW5nIHRvIGFwcGVuZC5cclxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZXRzIHZhbHVlcyB0byBiZSBmb3JtYXRlZC5cclxuICAgICAqL1xyXG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoYXBwZW5kKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJ1ZmZlciArPSBGb3JtYXR0ZXIuZm9ybShhcHBlbmQsIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgRm9ybWF0dGVyIHN0cmluZyB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgRm9ybWF0dGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEZvcm1hdHRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRm9ybWF0dGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gb3JtYXR0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFBvbnlmaWxsIGZvciBKYXZhJ3MgSW50ZWdlciBjbGFzcy5cclxuICovXHJcbnZhciBJbnRlZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW50ZWdlcigpIHtcclxuICAgIH1cclxuICAgIEludGVnZXIubnVtYmVyT2ZUcmFpbGluZ1plcm9zID0gZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICB2YXIgeTtcclxuICAgICAgICBpZiAoaSA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIDMyO1xyXG4gICAgICAgIHZhciBuID0gMzE7XHJcbiAgICAgICAgeSA9IGkgPDwgMTY7XHJcbiAgICAgICAgaWYgKHkgIT09IDApIHtcclxuICAgICAgICAgICAgbiAtPSAxNjtcclxuICAgICAgICAgICAgaSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkgPSBpIDw8IDg7XHJcbiAgICAgICAgaWYgKHkgIT09IDApIHtcclxuICAgICAgICAgICAgbiAtPSA4O1xyXG4gICAgICAgICAgICBpID0geTtcclxuICAgICAgICB9XHJcbiAgICAgICAgeSA9IGkgPDwgNDtcclxuICAgICAgICBpZiAoeSAhPT0gMCkge1xyXG4gICAgICAgICAgICBuIC09IDQ7XHJcbiAgICAgICAgICAgIGkgPSB5O1xyXG4gICAgICAgIH1cclxuICAgICAgICB5ID0gaSA8PCAyO1xyXG4gICAgICAgIGlmICh5ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIG4gLT0gMjtcclxuICAgICAgICAgICAgaSA9IHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuIC0gKChpIDw8IDEpID4+PiAzMSk7XHJcbiAgICB9O1xyXG4gICAgSW50ZWdlci5udW1iZXJPZkxlYWRpbmdaZXJvcyA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgLy8gSEQsIEZpZ3VyZSA1LTZcclxuICAgICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMzI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuID0gMTtcclxuICAgICAgICBpZiAoaSA+Pj4gMTYgPT09IDApIHtcclxuICAgICAgICAgICAgbiArPSAxNjtcclxuICAgICAgICAgICAgaSA8PD0gMTY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4+PiAyNCA9PT0gMCkge1xyXG4gICAgICAgICAgICBuICs9IDg7XHJcbiAgICAgICAgICAgIGkgPDw9IDg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4+PiAyOCA9PT0gMCkge1xyXG4gICAgICAgICAgICBuICs9IDQ7XHJcbiAgICAgICAgICAgIGkgPDw9IDQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpID4+PiAzMCA9PT0gMCkge1xyXG4gICAgICAgICAgICBuICs9IDI7XHJcbiAgICAgICAgICAgIGkgPDw9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG4gLT0gaSA+Pj4gMzE7XHJcbiAgICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG4gICAgSW50ZWdlci50b0hleFN0cmluZyA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgcmV0dXJuIGkudG9TdHJpbmcoMTYpO1xyXG4gICAgfTtcclxuICAgIEludGVnZXIudG9CaW5hcnlTdHJpbmcgPSBmdW5jdGlvbiAoaW50TnVtYmVyKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0cmluZyhwYXJzZUludChTdHJpbmcoaW50TnVtYmVyKSwgMikpO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBvbmUtYml0cyBpbiB0aGUgdHdvJ3MgY29tcGxlbWVudCBiaW5hcnkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCBpbnQgdmFsdWUuIFRoaXMgZnVuY3Rpb24gaXMgc29tZXRpbWVzIHJlZmVycmVkIHRvIGFzIHRoZSBwb3B1bGF0aW9uIGNvdW50LlxyXG4gICAgLy8gUmV0dXJuczpcclxuICAgIC8vIHRoZSBudW1iZXIgb2Ygb25lLWJpdHMgaW4gdGhlIHR3bydzIGNvbXBsZW1lbnQgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzcGVjaWZpZWQgaW50IHZhbHVlLlxyXG4gICAgSW50ZWdlci5iaXRDb3VudCA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgLy8gSEQsIEZpZ3VyZSA1LTJcclxuICAgICAgICBpID0gaSAtICgoaSA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcclxuICAgICAgICBpID0gKGkgJiAweDMzMzMzMzMzKSArICgoaSA+Pj4gMikgJiAweDMzMzMzMzMzKTtcclxuICAgICAgICBpID0gKGkgKyAoaSA+Pj4gNCkpICYgMHgwZjBmMGYwZjtcclxuICAgICAgICBpID0gaSArIChpID4+PiA4KTtcclxuICAgICAgICBpID0gaSArIChpID4+PiAxNik7XHJcbiAgICAgICAgcmV0dXJuIGkgJiAweDNmO1xyXG4gICAgfTtcclxuICAgIEludGVnZXIudHJ1bmNEaXZpc2lvbiA9IGZ1bmN0aW9uIChkaXZpZGVuZCwgZGl2aXNvcikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnRydW5jKGRpdmlkZW5kIC8gZGl2aXNvcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBBIHN0cmluZyB0byBhbiBpbnRlZ2VyLlxyXG4gICAgICogQHBhcmFtIHMgQSBzdHJpbmcgdG8gY29udmVydCBpbnRvIGEgbnVtYmVyLlxyXG4gICAgICogQHBhcmFtIHJhZGl4IEEgdmFsdWUgYmV0d2VlbiAyIGFuZCAzNiB0aGF0IHNwZWNpZmllcyB0aGUgYmFzZSBvZiB0aGUgbnVtYmVyIGluIG51bVN0cmluZy4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3Qgc3VwcGxpZWQsIHN0cmluZ3Mgd2l0aCBhIHByZWZpeCBvZiAnMHgnIGFyZSBjb25zaWRlcmVkIGhleGFkZWNpbWFsLiBBbGwgb3RoZXIgc3RyaW5ncyBhcmUgY29uc2lkZXJlZCBkZWNpbWFsLlxyXG4gICAgICovXHJcbiAgICBJbnRlZ2VyLnBhcnNlSW50ID0gZnVuY3Rpb24gKG51bSwgcmFkaXgpIHtcclxuICAgICAgICBpZiAocmFkaXggPT09IHZvaWQgMCkgeyByYWRpeCA9IHVuZGVmaW5lZDsgfVxyXG4gICAgICAgIHJldHVybiBwYXJzZUludChudW0sIHJhZGl4KTtcclxuICAgIH07XHJcbiAgICBJbnRlZ2VyLk1JTl9WQUxVRV8zMl9CSVRTID0gLTIxNDc0ODM2NDg7XHJcbiAgICBJbnRlZ2VyLk1BWF9WQUxVRSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgcmV0dXJuIEludGVnZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEludGVnZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUludGVnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFBvbnlmaWxsIGZvciBKYXZhJ3MgTG9uZyBjbGFzcy5cclxuICovXHJcbnZhciBMb25nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTG9uZygpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VzIGEgc3RyaW5nIHRvIGEgbnVtYmVyLCBzaW5jZSBKUyBoYXMgbm8gcmVhbGx5IEludDY0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBudW0gTnVtZXJpYyBzdHJpbmcuXHJcbiAgICAgKiBAcGFyYW0gcmFkaXggRGVzdGluYXRpb24gcmFkaXguXHJcbiAgICAgKi9cclxuICAgIExvbmcucGFyc2VMb25nID0gZnVuY3Rpb24gKG51bSwgcmFkaXgpIHtcclxuICAgICAgICBpZiAocmFkaXggPT09IHZvaWQgMCkgeyByYWRpeCA9IHVuZGVmaW5lZDsgfVxyXG4gICAgICAgIHJldHVybiBwYXJzZUludChudW0sIHJhZGl4KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTG9uZztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTG9uZztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TG9uZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL0luZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25cIik7XHJcbnZhciBOdWxsUG9pbnRlckV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL051bGxQb2ludGVyRXhjZXB0aW9uXCIpO1xyXG4vKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDE5OTQsIDIwMDQsIE9yYWNsZSBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqIERPIE5PVCBBTFRFUiBPUiBSRU1PVkUgQ09QWVJJR0hUIE5PVElDRVMgT1IgVEhJUyBGSUxFIEhFQURFUi5cclxuICpcclxuICogVGhpcyBjb2RlIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcclxuICogdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSB2ZXJzaW9uIDIgb25seSwgYXNcclxuICogcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24uICBPcmFjbGUgZGVzaWduYXRlcyB0aGlzXHJcbiAqIHBhcnRpY3VsYXIgZmlsZSBhcyBzdWJqZWN0IHRvIHRoZSBcIkNsYXNzcGF0aFwiIGV4Y2VwdGlvbiBhcyBwcm92aWRlZFxyXG4gKiBieSBPcmFjbGUgaW4gdGhlIExJQ0VOU0UgZmlsZSB0aGF0IGFjY29tcGFuaWVkIHRoaXMgY29kZS5cclxuICpcclxuICogVGhpcyBjb2RlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsIGJ1dCBXSVRIT1VUXHJcbiAqIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWSBvclxyXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcclxuICogdmVyc2lvbiAyIGZvciBtb3JlIGRldGFpbHMgKGEgY29weSBpcyBpbmNsdWRlZCBpbiB0aGUgTElDRU5TRSBmaWxlIHRoYXRcclxuICogYWNjb21wYW5pZWQgdGhpcyBjb2RlKS5cclxuICpcclxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvblxyXG4gKiAyIGFsb25nIHdpdGggdGhpcyB3b3JrOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sXHJcbiAqIEluYy4sIDUxIEZyYW5rbGluIFN0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQS5cclxuICpcclxuICogUGxlYXNlIGNvbnRhY3QgT3JhY2xlLCA1MDAgT3JhY2xlIFBhcmt3YXksIFJlZHdvb2QgU2hvcmVzLCBDQSA5NDA2NSBVU0FcclxuICogb3IgdmlzaXQgd3d3Lm9yYWNsZS5jb20gaWYgeW91IG5lZWQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBvciBoYXZlIGFueVxyXG4gKiBxdWVzdGlvbnMuXHJcbiAqL1xyXG4vLyBwYWNrYWdlIGphdmEuaW87XHJcbi8qKlxyXG4gKiBUaGlzIGFic3RyYWN0IGNsYXNzIGlzIHRoZSBzdXBlcmNsYXNzIG9mIGFsbCBjbGFzc2VzIHJlcHJlc2VudGluZ1xyXG4gKiBhbiBvdXRwdXQgc3RyZWFtIG9mIGJ5dGVzLiBBbiBvdXRwdXQgc3RyZWFtIGFjY2VwdHMgb3V0cHV0IGJ5dGVzXHJcbiAqIGFuZCBzZW5kcyB0aGVtIHRvIHNvbWUgc2luay5cclxuICogPHA+XHJcbiAqIEFwcGxpY2F0aW9ucyB0aGF0IG5lZWQgdG8gZGVmaW5lIGEgc3ViY2xhc3Mgb2ZcclxuICogPGNvZGU+T3V0cHV0U3RyZWFtPC9jb2RlPiBtdXN0IGFsd2F5cyBwcm92aWRlIGF0IGxlYXN0IGEgbWV0aG9kXHJcbiAqIHRoYXQgd3JpdGVzIG9uZSBieXRlIG9mIG91dHB1dC5cclxuICpcclxuICogQGF1dGhvciAgQXJ0aHVyIHZhbiBIb2ZmXHJcbiAqIEBzZWUgICAgIGphdmEuaW8uQnVmZmVyZWRPdXRwdXRTdHJlYW1cclxuICogQHNlZSAgICAgamF2YS5pby5CeXRlQXJyYXlPdXRwdXRTdHJlYW1cclxuICogQHNlZSAgICAgamF2YS5pby5EYXRhT3V0cHV0U3RyZWFtXHJcbiAqIEBzZWUgICAgIGphdmEuaW8uRmlsdGVyT3V0cHV0U3RyZWFtXHJcbiAqIEBzZWUgICAgIGphdmEuaW8uSW5wdXRTdHJlYW1cclxuICogQHNlZSAgICAgamF2YS5pby5PdXRwdXRTdHJlYW0jd3JpdGUoaW50KVxyXG4gKiBAc2luY2UgICBKREsxLjBcclxuICovXHJcbnZhciBPdXRwdXRTdHJlYW0gLyppbXBsZW1lbnRzIENsb3NlYWJsZSwgRmx1c2hhYmxlKi8gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPdXRwdXRTdHJlYW0oKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyA8Y29kZT5iLmxlbmd0aDwvY29kZT4gYnl0ZXMgZnJvbSB0aGUgc3BlY2lmaWVkIGJ5dGUgYXJyYXlcclxuICAgICAqIHRvIHRoaXMgb3V0cHV0IHN0cmVhbS4gVGhlIGdlbmVyYWwgY29udHJhY3QgZm9yIDxjb2RlPndyaXRlKGIpPC9jb2RlPlxyXG4gICAgICogaXMgdGhhdCBpdCBzaG91bGQgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVmZmVjdCBhcyB0aGUgY2FsbFxyXG4gICAgICogPGNvZGU+d3JpdGUoYiwgMCwgYi5sZW5ndGgpPC9jb2RlPi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gICAgICBiICAgdGhlIGRhdGEuXHJcbiAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy5cclxuICAgICAqIEBzZWUgICAgICAgIGphdmEuaW8uT3V0cHV0U3RyZWFtI3dyaXRlKGJ5dGVbXSwgaW50LCBpbnQpXHJcbiAgICAgKi9cclxuICAgIE91dHB1dFN0cmVhbS5wcm90b3R5cGUud3JpdGVCeXRlcyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgICAgdGhpcy53cml0ZUJ5dGVzT2Zmc2V0KGIsIDAsIGIubGVuZ3RoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyA8Y29kZT5sZW48L2NvZGU+IGJ5dGVzIGZyb20gdGhlIHNwZWNpZmllZCBieXRlIGFycmF5XHJcbiAgICAgKiBzdGFydGluZyBhdCBvZmZzZXQgPGNvZGU+b2ZmPC9jb2RlPiB0byB0aGlzIG91dHB1dCBzdHJlYW0uXHJcbiAgICAgKiBUaGUgZ2VuZXJhbCBjb250cmFjdCBmb3IgPGNvZGU+d3JpdGUoYiwgb2ZmLCBsZW4pPC9jb2RlPiBpcyB0aGF0XHJcbiAgICAgKiBzb21lIG9mIHRoZSBieXRlcyBpbiB0aGUgYXJyYXkgPGNvZGU+YjwvY29kZT4gYXJlIHdyaXR0ZW4gdG8gdGhlXHJcbiAgICAgKiBvdXRwdXQgc3RyZWFtIGluIG9yZGVyOyBlbGVtZW50IDxjb2RlPmJbb2ZmXTwvY29kZT4gaXMgdGhlIGZpcnN0XHJcbiAgICAgKiBieXRlIHdyaXR0ZW4gYW5kIDxjb2RlPmJbb2ZmK2xlbi0xXTwvY29kZT4gaXMgdGhlIGxhc3QgYnl0ZSB3cml0dGVuXHJcbiAgICAgKiBieSB0aGlzIG9wZXJhdGlvbi5cclxuICAgICAqIDxwPlxyXG4gICAgICogVGhlIDxjb2RlPndyaXRlPC9jb2RlPiBtZXRob2Qgb2YgPGNvZGU+T3V0cHV0U3RyZWFtPC9jb2RlPiBjYWxsc1xyXG4gICAgICogdGhlIHdyaXRlIG1ldGhvZCBvZiBvbmUgYXJndW1lbnQgb24gZWFjaCBvZiB0aGUgYnl0ZXMgdG8gYmVcclxuICAgICAqIHdyaXR0ZW4gb3V0LiBTdWJjbGFzc2VzIGFyZSBlbmNvdXJhZ2VkIHRvIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGFuZFxyXG4gICAgICogcHJvdmlkZSBhIG1vcmUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uLlxyXG4gICAgICogPHA+XHJcbiAgICAgKiBJZiA8Y29kZT5iPC9jb2RlPiBpcyA8Y29kZT5udWxsPC9jb2RlPiwgYVxyXG4gICAgICogPGNvZGU+TnVsbFBvaW50ZXJFeGNlcHRpb248L2NvZGU+IGlzIHRocm93bi5cclxuICAgICAqIDxwPlxyXG4gICAgICogSWYgPGNvZGU+b2ZmPC9jb2RlPiBpcyBuZWdhdGl2ZSwgb3IgPGNvZGU+bGVuPC9jb2RlPiBpcyBuZWdhdGl2ZSwgb3JcclxuICAgICAqIDxjb2RlPm9mZitsZW48L2NvZGU+IGlzIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheVxyXG4gICAgICogPGNvZGU+YjwvY29kZT4sIHRoZW4gYW4gPHR0PkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb248L3R0PiBpcyB0aHJvd24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICAgICAgYiAgICAgdGhlIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0gICAgICBvZmYgICB0aGUgc3RhcnQgb2Zmc2V0IGluIHRoZSBkYXRhLlxyXG4gICAgICogQHBhcmFtICAgICAgbGVuICAgdGhlIG51bWJlciBvZiBieXRlcyB0byB3cml0ZS5cclxuICAgICAqIEBleGNlcHRpb24gIElPRXhjZXB0aW9uICBpZiBhbiBJL08gZXJyb3Igb2NjdXJzLiBJbiBwYXJ0aWN1bGFyLFxyXG4gICAgICogICAgICAgICAgICAgYW4gPGNvZGU+SU9FeGNlcHRpb248L2NvZGU+IGlzIHRocm93biBpZiB0aGUgb3V0cHV0XHJcbiAgICAgKiAgICAgICAgICAgICBzdHJlYW0gaXMgY2xvc2VkLlxyXG4gICAgICovXHJcbiAgICBPdXRwdXRTdHJlYW0ucHJvdG90eXBlLndyaXRlQnl0ZXNPZmZzZXQgPSBmdW5jdGlvbiAoYiwgb2ZmLCBsZW4pIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBOdWxsUG9pbnRlckV4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoKG9mZiA8IDApIHx8IChvZmYgPiBiLmxlbmd0aCkgfHwgKGxlbiA8IDApIHx8XHJcbiAgICAgICAgICAgICgob2ZmICsgbGVuKSA+IGIubGVuZ3RoKSB8fCAoKG9mZiArIGxlbikgPCAwKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLndyaXRlKGJbb2ZmICsgaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZsdXNoZXMgdGhpcyBvdXRwdXQgc3RyZWFtIGFuZCBmb3JjZXMgYW55IGJ1ZmZlcmVkIG91dHB1dCBieXRlc1xyXG4gICAgICogdG8gYmUgd3JpdHRlbiBvdXQuIFRoZSBnZW5lcmFsIGNvbnRyYWN0IG9mIDxjb2RlPmZsdXNoPC9jb2RlPiBpc1xyXG4gICAgICogdGhhdCBjYWxsaW5nIGl0IGlzIGFuIGluZGljYXRpb24gdGhhdCwgaWYgYW55IGJ5dGVzIHByZXZpb3VzbHlcclxuICAgICAqIHdyaXR0ZW4gaGF2ZSBiZWVuIGJ1ZmZlcmVkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgb3V0cHV0XHJcbiAgICAgKiBzdHJlYW0sIHN1Y2ggYnl0ZXMgc2hvdWxkIGltbWVkaWF0ZWx5IGJlIHdyaXR0ZW4gdG8gdGhlaXJcclxuICAgICAqIGludGVuZGVkIGRlc3RpbmF0aW9uLlxyXG4gICAgICogPHA+XHJcbiAgICAgKiBJZiB0aGUgaW50ZW5kZWQgZGVzdGluYXRpb24gb2YgdGhpcyBzdHJlYW0gaXMgYW4gYWJzdHJhY3Rpb24gcHJvdmlkZWQgYnlcclxuICAgICAqIHRoZSB1bmRlcmx5aW5nIG9wZXJhdGluZyBzeXN0ZW0sIGZvciBleGFtcGxlIGEgZmlsZSwgdGhlbiBmbHVzaGluZyB0aGVcclxuICAgICAqIHN0cmVhbSBndWFyYW50ZWVzIG9ubHkgdGhhdCBieXRlcyBwcmV2aW91c2x5IHdyaXR0ZW4gdG8gdGhlIHN0cmVhbSBhcmVcclxuICAgICAqIHBhc3NlZCB0byB0aGUgb3BlcmF0aW5nIHN5c3RlbSBmb3Igd3JpdGluZzsgaXQgZG9lcyBub3QgZ3VhcmFudGVlIHRoYXRcclxuICAgICAqIHRoZXkgYXJlIGFjdHVhbGx5IHdyaXR0ZW4gdG8gYSBwaHlzaWNhbCBkZXZpY2Ugc3VjaCBhcyBhIGRpc2sgZHJpdmUuXHJcbiAgICAgKiA8cD5cclxuICAgICAqIFRoZSA8Y29kZT5mbHVzaDwvY29kZT4gbWV0aG9kIG9mIDxjb2RlPk91dHB1dFN0cmVhbTwvY29kZT4gZG9lcyBub3RoaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBleGNlcHRpb24gIElPRXhjZXB0aW9uICBpZiBhbiBJL08gZXJyb3Igb2NjdXJzLlxyXG4gICAgICovXHJcbiAgICBPdXRwdXRTdHJlYW0ucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoaXMgb3V0cHV0IHN0cmVhbSBhbmQgcmVsZWFzZXMgYW55IHN5c3RlbSByZXNvdXJjZXNcclxuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0cmVhbS4gVGhlIGdlbmVyYWwgY29udHJhY3Qgb2YgPGNvZGU+Y2xvc2U8L2NvZGU+XHJcbiAgICAgKiBpcyB0aGF0IGl0IGNsb3NlcyB0aGUgb3V0cHV0IHN0cmVhbS4gQSBjbG9zZWQgc3RyZWFtIGNhbm5vdCBwZXJmb3JtXHJcbiAgICAgKiBvdXRwdXQgb3BlcmF0aW9ucyBhbmQgY2Fubm90IGJlIHJlb3BlbmVkLlxyXG4gICAgICogPHA+XHJcbiAgICAgKiBUaGUgPGNvZGU+Y2xvc2U8L2NvZGU+IG1ldGhvZCBvZiA8Y29kZT5PdXRwdXRTdHJlYW08L2NvZGU+IGRvZXMgbm90aGluZy5cclxuICAgICAqXHJcbiAgICAgKiBAZXhjZXB0aW9uICBJT0V4Y2VwdGlvbiAgaWYgYW4gSS9PIGVycm9yIG9jY3Vycy5cclxuICAgICAqL1xyXG4gICAgT3V0cHV0U3RyZWFtLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIH07XHJcbiAgICByZXR1cm4gT3V0cHV0U3RyZWFtO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBPdXRwdXRTdHJlYW07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU91dHB1dFN0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU3RyaW5nVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vU3RyaW5nVXRpbHNcIik7XHJcbnZhciBTdHJpbmdCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3RyaW5nQnVpbGRlcih2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gJyc7IH1cclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5lbmFibGVEZWNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xyXG4gICAgICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAocykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSArPSBzLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZW5jb2RpbmcpIHtcclxuICAgICAgICAgICAgLy8gdXNlIHBhc3NlZCBmb3JtYXQgKGZyb21DaGFyQ29kZSB3aWxsIHJldHVybiBVVEY4IGVuY29kaW5nKVxyXG4gICAgICAgICAgICB0aGlzLnZhbHVlICs9IFN0cmluZ1V0aWxzXzEuZGVmYXVsdC5jYXN0QXNOb25VdGY4Q2hhcihzLCB0aGlzLmVuY29kaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGNvcnJlY3RseSBjb252ZXJ0cyBmcm9tIFVURi04LCBidXQgbm90IG90aGVyIGVuY29kaW5nc1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5sZW5ndGg7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuY2hhckF0ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5jaGFyQXQobik7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuZGVsZXRlQ2hhckF0ID0gZnVuY3Rpb24gKG4pIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5zdWJzdHIoMCwgbikgKyB0aGlzLnZhbHVlLnN1YnN0cmluZyhuICsgMSk7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nQnVpbGRlci5wcm90b3R5cGUuc2V0Q2hhckF0ID0gZnVuY3Rpb24gKG4sIGMpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZS5zdWJzdHIoMCwgbikgKyBjICsgdGhpcy52YWx1ZS5zdWJzdHIobiArIDEpO1xyXG4gICAgfTtcclxuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLnN1YnN0cmluZyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQG5vdGUgaGVscGVyIG1ldGhvZCBmb3IgUlNTIEV4cGFuZGVkXHJcbiAgICAgKi9cclxuICAgIFN0cmluZ0J1aWxkZXIucHJvdG90eXBlLnNldExlbmd0aFRvWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcclxuICAgIH07XHJcbiAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcclxuICAgIH07XHJcbiAgICBTdHJpbmdCdWlsZGVyLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAobiwgYykge1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlLnN1YnN0cigwLCBuKSArIGMgKyB0aGlzLnZhbHVlLnN1YnN0cihuICsgYy5sZW5ndGgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHJpbmdCdWlsZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTdHJpbmdCdWlsZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHJpbmdCdWlsZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4uL1Vuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uXCIpO1xyXG52YXIgQ2hhcmFjdGVyU2V0RUNJXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL0NoYXJhY3RlclNldEVDSVwiKTtcclxuLyoqXHJcbiAqIFJlc3BvbnNpYmxlIGZvciBlbi9kZWNvZGluZyBzdHJpbmdzLlxyXG4gKi9cclxudmFyIFN0cmluZ0VuY29kaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3RyaW5nRW5jb2RpbmcoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlY29kZXMgc29tZSBVaW50OEFycmF5IHRvIGEgc3RyaW5nIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgU3RyaW5nRW5jb2RpbmcuZGVjb2RlID0gZnVuY3Rpb24gKGJ5dGVzLCBlbmNvZGluZykge1xyXG4gICAgICAgIHZhciBlbmNvZGluZ05hbWUgPSB0aGlzLmVuY29kaW5nTmFtZShlbmNvZGluZyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tRGVjb2Rlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21EZWNvZGVyKGJ5dGVzLCBlbmNvZGluZ05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbmNyZWFzZXMgYnJvd3NlciBzdXBwb3J0LlxyXG4gICAgICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuc2hvdWxkRGVjb2RlT25GYWxsYmFjayhlbmNvZGluZ05hbWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUZhbGxiYWNrKGJ5dGVzLCBlbmNvZGluZ05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nTmFtZSkuZGVjb2RlKGJ5dGVzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgZGVjb2RpbmcgbWV0aG9kIHNob3VsZCB1c2UgdGhlIGZhbGxiYWNrIGZvciBkZWNvZGluZ1xyXG4gICAgICogb25jZSBOb2RlIFRleHREZWNvZGVyIGRvZXNuJ3Qgc3VwcG9ydCBhbGwgZW5jb2RpbmcgZm9ybWF0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW5jb2RpbmdOYW1lXHJcbiAgICAgKi9cclxuICAgIFN0cmluZ0VuY29kaW5nLnNob3VsZERlY29kZU9uRmFsbGJhY2sgPSBmdW5jdGlvbiAoZW5jb2RpbmdOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICFTdHJpbmdFbmNvZGluZy5pc0Jyb3dzZXIoKSAmJiBlbmNvZGluZ05hbWUgPT09ICdJU08tODg1OS0xJztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEVuY29kZXMgc29tZSBzdHJpbmcgaW50byBhIFVpbnQ4QXJyYXkuXHJcbiAgICAgKi9cclxuICAgIFN0cmluZ0VuY29kaW5nLmVuY29kZSA9IGZ1bmN0aW9uIChzLCBlbmNvZGluZykge1xyXG4gICAgICAgIHZhciBlbmNvZGluZ05hbWUgPSB0aGlzLmVuY29kaW5nTmFtZShlbmNvZGluZyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tRW5jb2Rlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21FbmNvZGVyKHMsIGVuY29kaW5nTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluY3JlYXNlcyBicm93c2VyIHN1cHBvcnQuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlRmFsbGJhY2socyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRleHRFbmNvZGVyIG9ubHkgZW5jb2RlcyB0byBVVEY4IGJ5IGRlZmF1bHQgYXMgc3BlY2lmaWVkIGJ5IGVuY29kaW5nLnNwZWMud2hhdHdnLm9yZ1xyXG4gICAgICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocyk7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nRW5jb2RpbmcuaXNCcm93c2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbCh3aW5kb3cpID09PSAnW29iamVjdCBXaW5kb3ddJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgdmFsdWUgZnJvbSBzb21lIGVuY29kaW5nIGNoYXJhY3RlciBzZXQuXHJcbiAgICAgKi9cclxuICAgIFN0cmluZ0VuY29kaW5nLmVuY29kaW5nTmFtZSA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXHJcbiAgICAgICAgICAgID8gZW5jb2RpbmdcclxuICAgICAgICAgICAgOiBlbmNvZGluZy5nZXROYW1lKCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGNoYXJhY3RlciBzZXQgZnJvbSBzb21lIGVuY29kaW5nIGNoYXJhY3RlciBzZXQuXHJcbiAgICAgKi9cclxuICAgIFN0cmluZ0VuY29kaW5nLmVuY29kaW5nQ2hhcmFjdGVyU2V0ID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XHJcbiAgICAgICAgaWYgKGVuY29kaW5nIGluc3RhbmNlb2YgQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW5jb2Rpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LmdldENoYXJhY3RlclNldEVDSUJ5TmFtZShlbmNvZGluZyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGEgZmFsbGJhY2sgZm9yIHRoZSBuYXRpdmUgZGVjb2RpbmcgZnVuY2lvbi5cclxuICAgICAqL1xyXG4gICAgU3RyaW5nRW5jb2RpbmcuZGVjb2RlRmFsbGJhY2sgPSBmdW5jdGlvbiAoYnl0ZXMsIGVuY29kaW5nKSB7XHJcbiAgICAgICAgdmFyIGNoYXJhY3RlclNldCA9IHRoaXMuZW5jb2RpbmdDaGFyYWN0ZXJTZXQoZW5jb2RpbmcpO1xyXG4gICAgICAgIGlmIChTdHJpbmdFbmNvZGluZy5pc0RlY29kZUZhbGxiYWNrU3VwcG9ydGVkKGNoYXJhY3RlclNldCkpIHtcclxuICAgICAgICAgICAgdmFyIHMgPSAnJztcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gYnl0ZXMubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGggPSBieXRlc1tpXS50b1N0cmluZygxNik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9ICcwJyArIGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzICs9ICclJyArIGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYXJhY3RlclNldC5lcXVhbHMoQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5Vbmljb2RlQmlnVW5tYXJrZWQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50MTZBcnJheShieXRlcy5idWZmZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uXzEuZGVmYXVsdChcIkVuY29kaW5nIFwiICsgdGhpcy5lbmNvZGluZ05hbWUoZW5jb2RpbmcpICsgXCIgbm90IHN1cHBvcnRlZCBieSBmYWxsYmFjay5cIik7XHJcbiAgICB9O1xyXG4gICAgU3RyaW5nRW5jb2RpbmcuaXNEZWNvZGVGYWxsYmFja1N1cHBvcnRlZCA9IGZ1bmN0aW9uIChjaGFyYWN0ZXJTZXQpIHtcclxuICAgICAgICByZXR1cm4gY2hhcmFjdGVyU2V0LmVxdWFscyhDaGFyYWN0ZXJTZXRFQ0lfMS5kZWZhdWx0LlVURjgpIHx8XHJcbiAgICAgICAgICAgIGNoYXJhY3RlclNldC5lcXVhbHMoQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5JU084ODU5XzEpIHx8XHJcbiAgICAgICAgICAgIGNoYXJhY3RlclNldC5lcXVhbHMoQ2hhcmFjdGVyU2V0RUNJXzEuZGVmYXVsdC5BU0NJSSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGEgZmFsbGJhY2sgZm9yIHRoZSBuYXRpdmUgZW5jb2RpbmcgZnVuY2lvbi5cclxuICAgICAqXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzE5Mjg0NS80MzY3NjgzXHJcbiAgICAgKi9cclxuICAgIFN0cmluZ0VuY29kaW5nLmVuY29kZUZhbGxiYWNrID0gZnVuY3Rpb24gKHMpIHtcclxuICAgICAgICB2YXIgZW5jb2RlZFVSSXN0cmluZyA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHMpKSk7XHJcbiAgICAgICAgdmFyIGNoYXJMaXN0ID0gZW5jb2RlZFVSSXN0cmluZy5zcGxpdCgnJyk7XHJcbiAgICAgICAgdmFyIHVpbnRBcnJheSA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhckxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdWludEFycmF5LnB1c2goY2hhckxpc3RbaV0uY2hhckNvZGVBdCgwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh1aW50QXJyYXkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHJpbmdFbmNvZGluZztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gU3RyaW5nRW5jb2Rpbmc7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0cmluZ0VuY29kaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTeXN0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBTeXN0ZW0oKSB7XHJcbiAgICB9XHJcbiAgICAvLyBwdWJsaWMgc3RhdGljIHZvaWQgYXJyYXljb3B5KE9iamVjdCBzcmMsIGludCBzcmNQb3MsIE9iamVjdCBkZXN0LCBpbnQgZGVzdFBvcywgaW50IGxlbmd0aClcclxuICAgIC8qKlxyXG4gICAgICogTWFrZXMgYSBjb3B5IG9mIGEgYXJyYXkuXHJcbiAgICAgKi9cclxuICAgIFN5c3RlbS5hcnJheWNvcHkgPSBmdW5jdGlvbiAoc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MsIGxlbmd0aCkge1xyXG4gICAgICAgIC8vIFRPRE86IGJldHRlciB1c2Ugc3BsaXQgb3Igc2V0P1xyXG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3lzdGVtO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTeXN0ZW07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5c3RlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gX19leHBvcnQobSkge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuX19leHBvcnQocmVxdWlyZShcIi4vYnJvd3NlclwiKSk7XHJcbi8vIEV4Y2VwdGlvbnNcclxudmFyIEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL0FyZ3VtZW50RXhjZXB0aW9uXCIpO1xyXG5leHBvcnRzLkFyZ3VtZW50RXhjZXB0aW9uID0gQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0O1xyXG52YXIgQXJpdGhtZXRpY0V4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vY29yZS9Bcml0aG1ldGljRXhjZXB0aW9uXCIpO1xyXG5leHBvcnRzLkFyaXRobWV0aWNFeGNlcHRpb24gPSBBcml0aG1ldGljRXhjZXB0aW9uXzEuZGVmYXVsdDtcclxudmFyIENoZWNrc3VtRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL0NoZWNrc3VtRXhjZXB0aW9uXCIpO1xyXG5leHBvcnRzLkNoZWNrc3VtRXhjZXB0aW9uID0gQ2hlY2tzdW1FeGNlcHRpb25fMS5kZWZhdWx0O1xyXG52YXIgRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL0V4Y2VwdGlvblwiKTtcclxuZXhwb3J0cy5FeGNlcHRpb24gPSBFeGNlcHRpb25fMS5kZWZhdWx0O1xyXG52YXIgRm9ybWF0RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL0Zvcm1hdEV4Y2VwdGlvblwiKTtcclxuZXhwb3J0cy5Gb3JtYXRFeGNlcHRpb24gPSBGb3JtYXRFeGNlcHRpb25fMS5kZWZhdWx0O1xyXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvblwiKTtcclxuZXhwb3J0cy5JbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gPSBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb25fMS5kZWZhdWx0O1xyXG52YXIgSWxsZWdhbFN0YXRlRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL0lsbGVnYWxTdGF0ZUV4Y2VwdGlvblwiKTtcclxuZXhwb3J0cy5JbGxlZ2FsU3RhdGVFeGNlcHRpb24gPSBJbGxlZ2FsU3RhdGVFeGNlcHRpb25fMS5kZWZhdWx0O1xyXG52YXIgTm90Rm91bmRFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL2NvcmUvTm90Rm91bmRFeGNlcHRpb25cIik7XHJcbmV4cG9ydHMuTm90Rm91bmRFeGNlcHRpb24gPSBOb3RGb3VuZEV4Y2VwdGlvbl8xLmRlZmF1bHQ7XHJcbnZhciBSZWFkZXJFeGNlcHRpb25fMSA9IHJlcXVpcmUoXCIuL2NvcmUvUmVhZGVyRXhjZXB0aW9uXCIpO1xyXG5leHBvcnRzLlJlYWRlckV4Y2VwdGlvbiA9IFJlYWRlckV4Y2VwdGlvbl8xLmRlZmF1bHQ7XHJcbnZhciBSZWVkU29sb21vbkV4Y2VwdGlvbl8xID0gcmVxdWlyZShcIi4vY29yZS9SZWVkU29sb21vbkV4Y2VwdGlvblwiKTtcclxuZXhwb3J0cy5SZWVkU29sb21vbkV4Y2VwdGlvbiA9IFJlZWRTb2xvbW9uRXhjZXB0aW9uXzEuZGVmYXVsdDtcclxudmFyIFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL1Vuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uXCIpO1xyXG5leHBvcnRzLlVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uID0gVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb25fMS5kZWZhdWx0O1xyXG52YXIgV3JpdGVyRXhjZXB0aW9uXzEgPSByZXF1aXJlKFwiLi9jb3JlL1dyaXRlckV4Y2VwdGlvblwiKTtcclxuZXhwb3J0cy5Xcml0ZXJFeGNlcHRpb24gPSBXcml0ZXJFeGNlcHRpb25fMS5kZWZhdWx0O1xyXG4vLyBjb3JlXHJcbnZhciBCYXJjb2RlRm9ybWF0XzEgPSByZXF1aXJlKFwiLi9jb3JlL0JhcmNvZGVGb3JtYXRcIik7XHJcbmV4cG9ydHMuQmFyY29kZUZvcm1hdCA9IEJhcmNvZGVGb3JtYXRfMS5kZWZhdWx0O1xyXG52YXIgQmluYXJpemVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL0JpbmFyaXplclwiKTtcclxuZXhwb3J0cy5CaW5hcml6ZXIgPSBCaW5hcml6ZXJfMS5kZWZhdWx0O1xyXG52YXIgQmluYXJ5Qml0bWFwXzEgPSByZXF1aXJlKFwiLi9jb3JlL0JpbmFyeUJpdG1hcFwiKTtcclxuZXhwb3J0cy5CaW5hcnlCaXRtYXAgPSBCaW5hcnlCaXRtYXBfMS5kZWZhdWx0O1xyXG52YXIgRGVjb2RlSGludFR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvcmUvRGVjb2RlSGludFR5cGVcIik7XHJcbmV4cG9ydHMuRGVjb2RlSGludFR5cGUgPSBEZWNvZGVIaW50VHlwZV8xLmRlZmF1bHQ7XHJcbnZhciBJbnZlcnRlZEx1bWluYW5jZVNvdXJjZV8xID0gcmVxdWlyZShcIi4vY29yZS9JbnZlcnRlZEx1bWluYW5jZVNvdXJjZVwiKTtcclxuZXhwb3J0cy5JbnZlcnRlZEx1bWluYW5jZVNvdXJjZSA9IEludmVydGVkTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdDtcclxudmFyIEx1bWluYW5jZVNvdXJjZV8xID0gcmVxdWlyZShcIi4vY29yZS9MdW1pbmFuY2VTb3VyY2VcIik7XHJcbmV4cG9ydHMuTHVtaW5hbmNlU291cmNlID0gTHVtaW5hbmNlU291cmNlXzEuZGVmYXVsdDtcclxudmFyIE11bHRpRm9ybWF0UmVhZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL011bHRpRm9ybWF0UmVhZGVyXCIpO1xyXG5leHBvcnRzLk11bHRpRm9ybWF0UmVhZGVyID0gTXVsdGlGb3JtYXRSZWFkZXJfMS5kZWZhdWx0O1xyXG52YXIgTXVsdGlGb3JtYXRXcml0ZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvTXVsdGlGb3JtYXRXcml0ZXJcIik7XHJcbmV4cG9ydHMuTXVsdGlGb3JtYXRXcml0ZXIgPSBNdWx0aUZvcm1hdFdyaXRlcl8xLmRlZmF1bHQ7XHJcbnZhciBQbGFuYXJZVVZMdW1pbmFuY2VTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2NvcmUvUGxhbmFyWVVWTHVtaW5hbmNlU291cmNlXCIpO1xyXG5leHBvcnRzLlBsYW5hcllVVkx1bWluYW5jZVNvdXJjZSA9IFBsYW5hcllVVkx1bWluYW5jZVNvdXJjZV8xLmRlZmF1bHQ7XHJcbnZhciBSZXN1bHRfMSA9IHJlcXVpcmUoXCIuL2NvcmUvUmVzdWx0XCIpO1xyXG5leHBvcnRzLlJlc3VsdCA9IFJlc3VsdF8xLmRlZmF1bHQ7XHJcbnZhciBSZXN1bHRNZXRhZGF0YVR5cGVfMSA9IHJlcXVpcmUoXCIuL2NvcmUvUmVzdWx0TWV0YWRhdGFUeXBlXCIpO1xyXG5leHBvcnRzLlJlc3VsdE1ldGFkYXRhVHlwZSA9IFJlc3VsdE1ldGFkYXRhVHlwZV8xLmRlZmF1bHQ7XHJcbnZhciBSR0JMdW1pbmFuY2VTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL2NvcmUvUkdCTHVtaW5hbmNlU291cmNlXCIpO1xyXG5leHBvcnRzLlJHQkx1bWluYW5jZVNvdXJjZSA9IFJHQkx1bWluYW5jZVNvdXJjZV8xLmRlZmF1bHQ7XHJcbi8vIGNvcmUvY29tbW9uXHJcbnZhciBCaXRBcnJheV8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vQml0QXJyYXlcIik7XHJcbmV4cG9ydHMuQml0QXJyYXkgPSBCaXRBcnJheV8xLmRlZmF1bHQ7XHJcbnZhciBCaXRNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL0JpdE1hdHJpeFwiKTtcclxuZXhwb3J0cy5CaXRNYXRyaXggPSBCaXRNYXRyaXhfMS5kZWZhdWx0O1xyXG52YXIgQml0U291cmNlXzEgPSByZXF1aXJlKFwiLi9jb3JlL2NvbW1vbi9CaXRTb3VyY2VcIik7XHJcbmV4cG9ydHMuQml0U291cmNlID0gQml0U291cmNlXzEuZGVmYXVsdDtcclxudmFyIENoYXJhY3RlclNldEVDSV8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vQ2hhcmFjdGVyU2V0RUNJXCIpO1xyXG5leHBvcnRzLkNoYXJhY3RlclNldEVDSSA9IENoYXJhY3RlclNldEVDSV8xLmRlZmF1bHQ7XHJcbnZhciBEZWNvZGVyUmVzdWx0XzEgPSByZXF1aXJlKFwiLi9jb3JlL2NvbW1vbi9EZWNvZGVyUmVzdWx0XCIpO1xyXG5leHBvcnRzLkRlY29kZXJSZXN1bHQgPSBEZWNvZGVyUmVzdWx0XzEuZGVmYXVsdDtcclxudmFyIERlZmF1bHRHcmlkU2FtcGxlcl8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vRGVmYXVsdEdyaWRTYW1wbGVyXCIpO1xyXG5leHBvcnRzLkRlZmF1bHRHcmlkU2FtcGxlciA9IERlZmF1bHRHcmlkU2FtcGxlcl8xLmRlZmF1bHQ7XHJcbnZhciBEZXRlY3RvclJlc3VsdF8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vRGV0ZWN0b3JSZXN1bHRcIik7XHJcbmV4cG9ydHMuRGV0ZWN0b3JSZXN1bHQgPSBEZXRlY3RvclJlc3VsdF8xLmRlZmF1bHQ7XHJcbnZhciBFbmNvZGVIaW50VHlwZV8xID0gcmVxdWlyZShcIi4vY29yZS9FbmNvZGVIaW50VHlwZVwiKTtcclxuZXhwb3J0cy5FbmNvZGVIaW50VHlwZSA9IEVuY29kZUhpbnRUeXBlXzEuZGVmYXVsdDtcclxudmFyIEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcl8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vR2xvYmFsSGlzdG9ncmFtQmluYXJpemVyXCIpO1xyXG5leHBvcnRzLkdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplciA9IEdsb2JhbEhpc3RvZ3JhbUJpbmFyaXplcl8xLmRlZmF1bHQ7XHJcbnZhciBHcmlkU2FtcGxlcl8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vR3JpZFNhbXBsZXJcIik7XHJcbmV4cG9ydHMuR3JpZFNhbXBsZXIgPSBHcmlkU2FtcGxlcl8xLmRlZmF1bHQ7XHJcbnZhciBHcmlkU2FtcGxlckluc3RhbmNlXzEgPSByZXF1aXJlKFwiLi9jb3JlL2NvbW1vbi9HcmlkU2FtcGxlckluc3RhbmNlXCIpO1xyXG5leHBvcnRzLkdyaWRTYW1wbGVySW5zdGFuY2UgPSBHcmlkU2FtcGxlckluc3RhbmNlXzEuZGVmYXVsdDtcclxudmFyIEh5YnJpZEJpbmFyaXplcl8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vSHlicmlkQmluYXJpemVyXCIpO1xyXG5leHBvcnRzLkh5YnJpZEJpbmFyaXplciA9IEh5YnJpZEJpbmFyaXplcl8xLmRlZmF1bHQ7XHJcbnZhciBQZXJzcGVjdGl2ZVRyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vUGVyc3BlY3RpdmVUcmFuc2Zvcm1cIik7XHJcbmV4cG9ydHMuUGVyc3BlY3RpdmVUcmFuc2Zvcm0gPSBQZXJzcGVjdGl2ZVRyYW5zZm9ybV8xLmRlZmF1bHQ7XHJcbnZhciBTdHJpbmdVdGlsc18xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vU3RyaW5nVXRpbHNcIik7XHJcbmV4cG9ydHMuU3RyaW5nVXRpbHMgPSBTdHJpbmdVdGlsc18xLmRlZmF1bHQ7XHJcbi8vIGNvcmUvY29tbW9uL2RldGVjdG9yXHJcbnZhciBNYXRoVXRpbHNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL2RldGVjdG9yL01hdGhVdGlsc1wiKTtcclxuZXhwb3J0cy5NYXRoVXRpbHMgPSBNYXRoVXRpbHNfMS5kZWZhdWx0O1xyXG4vLyBleHBvcnQgeyBkZWZhdWx0IGFzIE1vbm9jaHJvbWVSZWN0YW5nbGVEZXRlY3RvciB9IGZyb20gJy4vY29yZS9jb21tb24vZGV0ZWN0b3IvTW9ub2Nocm9tZVJlY3RhbmdsZURldGVjdG9yJztcclxudmFyIFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3JfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL2RldGVjdG9yL1doaXRlUmVjdGFuZ2xlRGV0ZWN0b3JcIik7XHJcbmV4cG9ydHMuV2hpdGVSZWN0YW5nbGVEZXRlY3RvciA9IFdoaXRlUmVjdGFuZ2xlRGV0ZWN0b3JfMS5kZWZhdWx0O1xyXG4vLyBjb3JlL2NvbW1vbi9yZWVkc29sb21vblxyXG52YXIgR2VuZXJpY0dGXzEgPSByZXF1aXJlKFwiLi9jb3JlL2NvbW1vbi9yZWVkc29sb21vbi9HZW5lcmljR0ZcIik7XHJcbmV4cG9ydHMuR2VuZXJpY0dGID0gR2VuZXJpY0dGXzEuZGVmYXVsdDtcclxudmFyIEdlbmVyaWNHRlBvbHlfMSA9IHJlcXVpcmUoXCIuL2NvcmUvY29tbW9uL3JlZWRzb2xvbW9uL0dlbmVyaWNHRlBvbHlcIik7XHJcbmV4cG9ydHMuR2VuZXJpY0dGUG9seSA9IEdlbmVyaWNHRlBvbHlfMS5kZWZhdWx0O1xyXG52YXIgUmVlZFNvbG9tb25EZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL2NvbW1vbi9yZWVkc29sb21vbi9SZWVkU29sb21vbkRlY29kZXJcIik7XHJcbmV4cG9ydHMuUmVlZFNvbG9tb25EZWNvZGVyID0gUmVlZFNvbG9tb25EZWNvZGVyXzEuZGVmYXVsdDtcclxudmFyIFJlZWRTb2xvbW9uRW5jb2Rlcl8xID0gcmVxdWlyZShcIi4vY29yZS9jb21tb24vcmVlZHNvbG9tb24vUmVlZFNvbG9tb25FbmNvZGVyXCIpO1xyXG5leHBvcnRzLlJlZWRTb2xvbW9uRW5jb2RlciA9IFJlZWRTb2xvbW9uRW5jb2Rlcl8xLmRlZmF1bHQ7XHJcbi8vIGNvcmUvZGF0YW1hdHJpeFxyXG52YXIgRGF0YU1hdHJpeFJlYWRlcl8xID0gcmVxdWlyZShcIi4vY29yZS9kYXRhbWF0cml4L0RhdGFNYXRyaXhSZWFkZXJcIik7XHJcbmV4cG9ydHMuRGF0YU1hdHJpeFJlYWRlciA9IERhdGFNYXRyaXhSZWFkZXJfMS5kZWZhdWx0O1xyXG4vLyBjb3JlL3R3b2QvcXJjb2RlXHJcbnZhciBRUkNvZGVSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvcXJjb2RlL1FSQ29kZVJlYWRlclwiKTtcclxuZXhwb3J0cy5RUkNvZGVSZWFkZXIgPSBRUkNvZGVSZWFkZXJfMS5kZWZhdWx0O1xyXG52YXIgUVJDb2RlV3JpdGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL3FyY29kZS9RUkNvZGVXcml0ZXJcIik7XHJcbmV4cG9ydHMuUVJDb2RlV3JpdGVyID0gUVJDb2RlV3JpdGVyXzEuZGVmYXVsdDtcclxudmFyIEVycm9yQ29ycmVjdGlvbkxldmVsXzEgPSByZXF1aXJlKFwiLi9jb3JlL3FyY29kZS9kZWNvZGVyL0Vycm9yQ29ycmVjdGlvbkxldmVsXCIpO1xyXG5leHBvcnRzLlFSQ29kZURlY29kZXJFcnJvckNvcnJlY3Rpb25MZXZlbCA9IEVycm9yQ29ycmVjdGlvbkxldmVsXzEuZGVmYXVsdDtcclxudmFyIEVuY29kZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvcXJjb2RlL2VuY29kZXIvRW5jb2RlclwiKTtcclxuZXhwb3J0cy5RUkNvZGVFbmNvZGVyID0gRW5jb2Rlcl8xLmRlZmF1bHQ7XHJcbnZhciBRUkNvZGVfMSA9IHJlcXVpcmUoXCIuL2NvcmUvcXJjb2RlL2VuY29kZXIvUVJDb2RlXCIpO1xyXG5leHBvcnRzLlFSQ29kZUVuY29kZXJRUkNvZGUgPSBRUkNvZGVfMS5kZWZhdWx0O1xyXG4vLyBjb3JlL3R3b2QvYXp0ZWNcclxudmFyIEF6dGVjUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL2F6dGVjL0F6dGVjUmVhZGVyXCIpO1xyXG5leHBvcnRzLkF6dGVjQ29kZVJlYWRlciA9IEF6dGVjUmVhZGVyXzEuZGVmYXVsdDtcclxuLy8gY29yZS9vbmVkXHJcbnZhciBPbmVEUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL29uZWQvT25lRFJlYWRlclwiKTtcclxuZXhwb3J0cy5PbmVEUmVhZGVyID0gT25lRFJlYWRlcl8xLmRlZmF1bHQ7XHJcbnZhciBFQU4xM1JlYWRlcl8xID0gcmVxdWlyZShcIi4vY29yZS9vbmVkL0VBTjEzUmVhZGVyXCIpO1xyXG5leHBvcnRzLkVBTjEzUmVhZGVyID0gRUFOMTNSZWFkZXJfMS5kZWZhdWx0O1xyXG52YXIgQ29kZTEyOFJlYWRlcl8xID0gcmVxdWlyZShcIi4vY29yZS9vbmVkL0NvZGUxMjhSZWFkZXJcIik7XHJcbmV4cG9ydHMuQ29kZTEyOFJlYWRlciA9IENvZGUxMjhSZWFkZXJfMS5kZWZhdWx0O1xyXG52YXIgSVRGUmVhZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL29uZWQvSVRGUmVhZGVyXCIpO1xyXG5leHBvcnRzLklURlJlYWRlciA9IElURlJlYWRlcl8xLmRlZmF1bHQ7XHJcbnZhciBDb2RlMzlSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvb25lZC9Db2RlMzlSZWFkZXJcIik7XHJcbmV4cG9ydHMuQ29kZTM5UmVhZGVyID0gQ29kZTM5UmVhZGVyXzEuZGVmYXVsdDtcclxudmFyIFJTUzE0UmVhZGVyXzEgPSByZXF1aXJlKFwiLi9jb3JlL29uZWQvcnNzL1JTUzE0UmVhZGVyXCIpO1xyXG5leHBvcnRzLlJTUzE0UmVhZGVyID0gUlNTMTRSZWFkZXJfMS5kZWZhdWx0O1xyXG52YXIgUlNTRXhwYW5kZWRSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvb25lZC9yc3MvZXhwYW5kZWQvUlNTRXhwYW5kZWRSZWFkZXJcIik7XHJcbmV4cG9ydHMuUlNTRXhwYW5kZWRSZWFkZXIgPSBSU1NFeHBhbmRlZFJlYWRlcl8xLmRlZmF1bHQ7XHJcbnZhciBNdWx0aUZvcm1hdE9uZURSZWFkZXJfMSA9IHJlcXVpcmUoXCIuL2NvcmUvb25lZC9NdWx0aUZvcm1hdE9uZURSZWFkZXJcIik7XHJcbmV4cG9ydHMuTXVsdGlmb3JtYXRSZWFkZXIgPSBNdWx0aUZvcm1hdE9uZURSZWFkZXJfMS5kZWZhdWx0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcclxufTtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XHJcbmNvbnN0IGxpYnJhcnlfMSA9IHJlcXVpcmUoXCJAenhpbmcvbGlicmFyeVwiKTtcclxuY29uc3QgcmVhY3Rfd2ViY2FtXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJlYWN0LXdlYmNhbVwiKSk7XHJcbmNvbnN0IEJhcmNvZGVTY2FubmVyQ29tcG9uZW50ID0gKHsgb25VcGRhdGUsIG9uRXJyb3IsIHdpZHRoID0gXCIxMDAlXCIsIGhlaWdodCA9IFwiMTAwJVwiLCBmYWNpbmdNb2RlID0gXCJlbnZpcm9ubWVudFwiLCB0b3JjaCwgZGVsYXkgPSA1MDAsIHZpZGVvQ29uc3RyYWludHMsIHN0b3BTdHJlYW0sIH0pID0+IHtcclxuICAgIGNvbnN0IHdlYmNhbVJlZiA9IHJlYWN0XzEuZGVmYXVsdC51c2VSZWYobnVsbCk7XHJcbiAgICBjb25zdCBjYXB0dXJlID0gcmVhY3RfMS5kZWZhdWx0LnVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgY29kZVJlYWRlciA9IG5ldyBsaWJyYXJ5XzEuQnJvd3Nlck11bHRpRm9ybWF0UmVhZGVyKCk7XHJcbiAgICAgICAgY29uc3QgaW1hZ2VTcmMgPSAoX2EgPSB3ZWJjYW1SZWYgPT09IG51bGwgfHwgd2ViY2FtUmVmID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3ZWJjYW1SZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFNjcmVlbnNob3QoKTtcclxuICAgICAgICBpZiAoaW1hZ2VTcmMpIHtcclxuICAgICAgICAgICAgY29kZVJlYWRlclxyXG4gICAgICAgICAgICAgICAgLmRlY29kZUZyb21JbWFnZSh1bmRlZmluZWQsIGltYWdlU3JjKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25VcGRhdGUobnVsbCwgcmVzdWx0KTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvblVwZGF0ZShlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbb25VcGRhdGVdKTtcclxuICAgIHJlYWN0XzEuZGVmYXVsdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgLy8gVHVybiBvbiB0aGUgZmxhc2hsaWdodCBpZiBwcm9wIGlzIGRlZmluZWQgYW5kIGRldmljZSBoYXMgdGhlIGNhcGFiaWxpdHlcclxuICAgICAgICBpZiAodHlwZW9mIHRvcmNoID09PSBcImJvb2xlYW5cIiAmJiAoKF9hID0gXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIG5hdmlnYXRvciA9PT0gbnVsbCB8fCBcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBcclxuICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN1cHBvcnRlZENvbnN0cmFpbnRzKCkudG9yY2gpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IChfYiA9IHdlYmNhbVJlZiA9PT0gbnVsbCB8fCB3ZWJjYW1SZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdlYmNhbVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmlkZW8uc3JjT2JqZWN0O1xyXG4gICAgICAgICAgICBjb25zdCB0cmFjayA9IHN0cmVhbSA9PT0gbnVsbCB8fCBzdHJlYW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdOyAvLyBnZXQgdGhlIGFjdGl2ZSB0cmFjayBvZiB0aGUgc3RyZWFtXHJcbiAgICAgICAgICAgIGlmICh0cmFjayAmJlxyXG4gICAgICAgICAgICAgICAgdHJhY2suZ2V0Q2FwYWJpbGl0aWVzKCkudG9yY2ggJiZcclxuICAgICAgICAgICAgICAgICF0cmFjay5nZXRDb25zdHJhaW50cygpLnRvcmNoKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFja1xyXG4gICAgICAgICAgICAgICAgICAgIC5hcHBseUNvbnN0cmFpbnRzKHtcclxuICAgICAgICAgICAgICAgICAgICBhZHZhbmNlZDogW3sgdG9yY2ggfV0sXHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiBvblVwZGF0ZShlcnIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFt0b3JjaCwgb25VcGRhdGVdKTtcclxuICAgIHJlYWN0XzEuZGVmYXVsdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoc3RvcFN0cmVhbSkge1xyXG4gICAgICAgICAgICBsZXQgc3RyZWFtID0gKF9hID0gd2ViY2FtUmVmID09PSBudWxsIHx8IHdlYmNhbVJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2ViY2FtUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52aWRlby5zcmNPYmplY3Q7XHJcbiAgICAgICAgICAgIGlmIChzdHJlYW0pIHtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3N0b3BTdHJlYW1dKTtcclxuICAgIHJlYWN0XzEuZGVmYXVsdC51c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoY2FwdHVyZSwgZGVsYXkpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KHJlYWN0X3dlYmNhbV8xLmRlZmF1bHQsIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgcmVmOiB3ZWJjYW1SZWYsIHNjcmVlbnNob3RGb3JtYXQ6IFwiaW1hZ2UvanBlZ1wiLCB2aWRlb0NvbnN0cmFpbnRzOiB2aWRlb0NvbnN0cmFpbnRzIHx8IHtcclxuICAgICAgICAgICAgZmFjaW5nTW9kZSxcclxuICAgICAgICB9LCBhdWRpbzogZmFsc2UsIG9uVXNlck1lZGlhRXJyb3I6IG9uRXJyb3IgfSkpO1xyXG59O1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCYXJjb2RlU2Nhbm5lckNvbXBvbmVudDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XHJcbn07XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFyY29kZVNjYW5uZXJDb21wb25lbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9CYXJjb2RlU2Nhbm5lckNvbXBvbmVudFwiKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJhcmNvZGVTY2FubmVyQ29tcG9uZW50XzEuZGVmYXVsdDtcclxuIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcclxuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcclxuXHRcdGRlZmluZShbXCJyZWFjdFwiXSwgZmFjdG9yeSk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcblx0XHRleHBvcnRzW1wiV2ViY2FtXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xyXG5cdGVsc2VcclxuXHRcdHJvb3RbXCJXZWJjYW1cIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XHJcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXykge1xyXG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxyXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXHJcbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXHJcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xyXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXHJcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XHJcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxyXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcclxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cclxuLyoqKioqKi8gXHRcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxyXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcclxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcclxuLyoqKioqKi8gXHR9XHJcbi8qKioqKiovXHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcclxuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xyXG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XHJcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxyXG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxyXG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xyXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxyXG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xyXG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xyXG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcclxuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xyXG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xyXG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xyXG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcclxuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xyXG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxyXG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xyXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xyXG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XHJcbi8qKioqKiovXHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXHJcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9yZWFjdC13ZWJjYW0udHN4XCIpO1xyXG4vKioqKioqLyB9KVxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKioqKioqLyAoe1xyXG5cclxuLyoqKi8gXCIuL3NyYy9yZWFjdC13ZWJjYW0udHN4XCI6XHJcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcclxuICAhKioqIC4vc3JjL3JlYWN0LXdlYmNhbS50c3ggKioqIVxyXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlYWN0ICovIFwicmVhY3RcIik7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xyXG52YXIgX19leHRlbmRzID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxuICAgIH07XHJcbn0pKCk7XHJcbnZhciBfX2Fzc2lnbiA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXHJcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcbnZhciBfX3Jlc3QgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufTtcclxuXHJcbi8vIHBvbHlmaWxsIGJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9NZWRpYURldmljZXMvZ2V0VXNlck1lZGlhXHJcbihmdW5jdGlvbiBwb2x5ZmlsbEdldFVzZXJNZWRpYSgpIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIE9sZGVyIGJyb3dzZXJzIG1pZ2h0IG5vdCBpbXBsZW1lbnQgbWVkaWFEZXZpY2VzIGF0IGFsbCwgc28gd2Ugc2V0IGFuIGVtcHR5IG9iamVjdCBmaXJzdFxyXG4gICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMgPSB7fTtcclxuICAgIH1cclxuICAgIC8vIFNvbWUgYnJvd3NlcnMgcGFydGlhbGx5IGltcGxlbWVudCBtZWRpYURldmljZXMuIFdlIGNhbid0IGp1c3QgYXNzaWduIGFuIG9iamVjdFxyXG4gICAgLy8gd2l0aCBnZXRVc2VyTWVkaWEgYXMgaXQgd291bGQgb3ZlcndyaXRlIGV4aXN0aW5nIHByb3BlcnRpZXMuXHJcbiAgICAvLyBIZXJlLCB3ZSB3aWxsIGp1c3QgYWRkIHRoZSBnZXRVc2VyTWVkaWEgcHJvcGVydHkgaWYgaXQncyBtaXNzaW5nLlxyXG4gICAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGZ1bmN0aW9uIChjb25zdHJhaW50cykge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCBnZXQgYWhvbGQgb2YgdGhlIGxlZ2FjeSBnZXRVc2VyTWVkaWEsIGlmIHByZXNlbnRcclxuICAgICAgICAgICAgdmFyIGdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHxcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci53ZWJraXRHZXRVc2VyTWVkaWEgfHxcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5tb3pHZXRVc2VyTWVkaWEgfHxcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYTtcclxuICAgICAgICAgICAgLy8gU29tZSBicm93c2VycyBqdXN0IGRvbid0IGltcGxlbWVudCBpdCAtIHJldHVybiBhIHJlamVjdGVkIHByb21pc2Ugd2l0aCBhbiBlcnJvclxyXG4gICAgICAgICAgICAvLyB0byBrZWVwIGEgY29uc2lzdGVudCBpbnRlcmZhY2VcclxuICAgICAgICAgICAgaWYgKCFnZXRVc2VyTWVkaWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJnZXRVc2VyTWVkaWEgaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgYnJvd3NlclwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB3cmFwIHRoZSBjYWxsIHRvIHRoZSBvbGQgbmF2aWdhdG9yLmdldFVzZXJNZWRpYSB3aXRoIGEgUHJvbWlzZVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgZ2V0VXNlck1lZGlhLmNhbGwobmF2aWdhdG9yLCBjb25zdHJhaW50cywgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufSkoKTtcclxuZnVuY3Rpb24gaGFzR2V0VXNlck1lZGlhKCkge1xyXG4gICAgcmV0dXJuICEhKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpO1xyXG59XHJcbnZhciBXZWJjYW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoV2ViY2FtLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gV2ViY2FtKHByb3BzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY2FudmFzID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5jdHggPSBudWxsO1xyXG4gICAgICAgIF90aGlzLnVubW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBoYXNVc2VyTWVkaWE6IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBXZWJjYW0ucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHN0YXRlID0gX2Euc3RhdGUsIHByb3BzID0gX2EucHJvcHM7XHJcbiAgICAgICAgaWYgKCFoYXNHZXRVc2VyTWVkaWEoKSkge1xyXG4gICAgICAgICAgICBwcm9wcy5vblVzZXJNZWRpYUVycm9yKFwiZ2V0VXNlck1lZGlhIG5vdCBzdXBwb3J0ZWRcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzdGF0ZS5oYXNVc2VyTWVkaWEpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0VXNlck1lZGlhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFdlYmNhbS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgaWYgKCFoYXNHZXRVc2VyTWVkaWEoKSkge1xyXG4gICAgICAgICAgICBwcm9wcy5vblVzZXJNZWRpYUVycm9yKFwiZ2V0VXNlck1lZGlhIG5vdCBzdXBwb3J0ZWRcIik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGF1ZGlvQ29uc3RyYWludHNDaGFuZ2VkID0gSlNPTi5zdHJpbmdpZnkobmV4dFByb3BzLmF1ZGlvQ29uc3RyYWludHMpICE9PVxyXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeShwcm9wcy5hdWRpb0NvbnN0cmFpbnRzKTtcclxuICAgICAgICB2YXIgdmlkZW9Db25zdHJhaW50c0NoYW5nZWQgPSBKU09OLnN0cmluZ2lmeShuZXh0UHJvcHMudmlkZW9Db25zdHJhaW50cykgIT09XHJcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHByb3BzLnZpZGVvQ29uc3RyYWludHMpO1xyXG4gICAgICAgIHZhciBtaW5TY3JlZW5zaG90V2lkdGhDaGFuZ2VkID0gbmV4dFByb3BzLm1pblNjcmVlbnNob3RXaWR0aCAhPT0gcHJvcHMubWluU2NyZWVuc2hvdFdpZHRoO1xyXG4gICAgICAgIHZhciBtaW5TY3JlZW5zaG90SGVpZ2h0Q2hhbmdlZCA9IG5leHRQcm9wcy5taW5TY3JlZW5zaG90SGVpZ2h0ICE9PSBwcm9wcy5taW5TY3JlZW5zaG90SGVpZ2h0O1xyXG4gICAgICAgIGlmICh2aWRlb0NvbnN0cmFpbnRzQ2hhbmdlZCB8fFxyXG4gICAgICAgICAgICBtaW5TY3JlZW5zaG90V2lkdGhDaGFuZ2VkIHx8XHJcbiAgICAgICAgICAgIG1pblNjcmVlbnNob3RIZWlnaHRDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jdHggPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXVkaW9Db25zdHJhaW50c0NoYW5nZWQgfHwgdmlkZW9Db25zdHJhaW50c0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wQW5kQ2xlYW51cCgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RVc2VyTWVkaWEoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgV2ViY2FtLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVubW91bnRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5zdG9wQW5kQ2xlYW51cCgpO1xyXG4gICAgfTtcclxuICAgIFdlYmNhbS5zdG9wTWVkaWFTdHJlYW0gPSBmdW5jdGlvbiAoc3RyZWFtKSB7XHJcbiAgICAgICAgaWYgKHN0cmVhbSkge1xyXG4gICAgICAgICAgICBpZiAoc3RyZWFtLmdldFZpZGVvVHJhY2tzICYmIHN0cmVhbS5nZXRBdWRpb1RyYWNrcykge1xyXG4gICAgICAgICAgICAgICAgc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkubWFwKGZ1bmN0aW9uICh0cmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5tYXAoZnVuY3Rpb24gKHRyYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0cmVhbS5zdG9wKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgV2ViY2FtLnByb3RvdHlwZS5zdG9wQW5kQ2xlYW51cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xyXG4gICAgICAgIGlmIChzdGF0ZS5oYXNVc2VyTWVkaWEpIHtcclxuICAgICAgICAgICAgV2ViY2FtLnN0b3BNZWRpYVN0cmVhbSh0aGlzLnN0cmVhbSk7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zcmMpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKHN0YXRlLnNyYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgV2ViY2FtLnByb3RvdHlwZS5nZXRTY3JlZW5zaG90ID0gZnVuY3Rpb24gKHNjcmVlbnNob3REaW1lbnNpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcywgc3RhdGUgPSBfYS5zdGF0ZSwgcHJvcHMgPSBfYS5wcm9wcztcclxuICAgICAgICBpZiAoIXN0YXRlLmhhc1VzZXJNZWRpYSlcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKHNjcmVlbnNob3REaW1lbnNpb25zKTtcclxuICAgICAgICByZXR1cm4gKGNhbnZhcyAmJlxyXG4gICAgICAgICAgICBjYW52YXMudG9EYXRhVVJMKHByb3BzLnNjcmVlbnNob3RGb3JtYXQsIHByb3BzLnNjcmVlbnNob3RRdWFsaXR5KSk7XHJcbiAgICB9O1xyXG4gICAgV2ViY2FtLnByb3RvdHlwZS5nZXRDYW52YXMgPSBmdW5jdGlvbiAoc2NyZWVuc2hvdERpbWVuc2lvbnMpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBzdGF0ZSA9IF9hLnN0YXRlLCBwcm9wcyA9IF9hLnByb3BzO1xyXG4gICAgICAgIGlmICghdGhpcy52aWRlbykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzdGF0ZS5oYXNVc2VyTWVkaWEgfHwgIXRoaXMudmlkZW8udmlkZW9IZWlnaHQpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIGlmICghdGhpcy5jdHgpIHtcclxuICAgICAgICAgICAgdmFyIGNhbnZhc1dpZHRoID0gdGhpcy52aWRlby52aWRlb1dpZHRoO1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gdGhpcy52aWRlby52aWRlb0hlaWdodDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BzLmZvcmNlU2NyZWVuc2hvdFNvdXJjZVNpemUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IGNhbnZhc1dpZHRoIC8gY2FudmFzSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY2FudmFzV2lkdGggPSBwcm9wcy5taW5TY3JlZW5zaG90V2lkdGggfHwgdGhpcy52aWRlby5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgICAgIGNhbnZhc0hlaWdodCA9IGNhbnZhc1dpZHRoIC8gYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMubWluU2NyZWVuc2hvdEhlaWdodCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0hlaWdodCA8IHByb3BzLm1pblNjcmVlbnNob3RIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYW52YXNIZWlnaHQgPSBwcm9wcy5taW5TY3JlZW5zaG90SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc1dpZHRoID0gY2FudmFzSGVpZ2h0ICogYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IChzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gbnVsbCB8fCBzY3JlZW5zaG90RGltZW5zaW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NyZWVuc2hvdERpbWVuc2lvbnMud2lkdGgpIHx8IGNhbnZhc1dpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSAoc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IG51bGwgfHwgc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjcmVlbnNob3REaW1lbnNpb25zLmhlaWdodCkgfHwgY2FudmFzSGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9iID0gdGhpcywgY3R4ID0gX2IuY3R4LCBjYW52YXMgPSBfYi5jYW52YXM7XHJcbiAgICAgICAgaWYgKGN0eCAmJiBjYW52YXMpIHtcclxuICAgICAgICAgICAgLy8gbWlycm9yIHRoZSBzY3JlZW5zaG90XHJcbiAgICAgICAgICAgIGlmIChwcm9wcy5taXJyb3JlZCkge1xyXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShjYW52YXMud2lkdGgsIDApO1xyXG4gICAgICAgICAgICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gcHJvcHMuaW1hZ2VTbW9vdGhpbmc7XHJcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy52aWRlbywgMCwgMCwgKHNjcmVlbnNob3REaW1lbnNpb25zID09PSBudWxsIHx8IHNjcmVlbnNob3REaW1lbnNpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzY3JlZW5zaG90RGltZW5zaW9ucy53aWR0aCkgfHwgY2FudmFzLndpZHRoLCAoc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IG51bGwgfHwgc2NyZWVuc2hvdERpbWVuc2lvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNjcmVlbnNob3REaW1lbnNpb25zLmhlaWdodCkgfHwgY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIC8vIGludmVydCBtaXJyb3JpbmdcclxuICAgICAgICAgICAgaWYgKHByb3BzLm1pcnJvcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtY2FudmFzLndpZHRoLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfTtcclxuICAgIFdlYmNhbS5wcm90b3R5cGUucmVxdWVzdFVzZXJNZWRpYSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIHNvdXJjZVNlbGVjdGVkID0gZnVuY3Rpb24gKGF1ZGlvQ29uc3RyYWludHMsIHZpZGVvQ29uc3RyYWludHMpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0ge1xyXG4gICAgICAgICAgICAgICAgdmlkZW86IHR5cGVvZiB2aWRlb0NvbnN0cmFpbnRzICE9PSBcInVuZGVmaW5lZFwiID8gdmlkZW9Db25zdHJhaW50cyA6IHRydWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHByb3BzLmF1ZGlvKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdHJhaW50cy5hdWRpbyA9XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGF1ZGlvQ29uc3RyYWludHMgIT09IFwidW5kZWZpbmVkXCIgPyBhdWRpb0NvbnN0cmFpbnRzIDogdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzXHJcbiAgICAgICAgICAgICAgICAuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHN0cmVhbSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnVubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIFdlYmNhbS5zdG9wTWVkaWFTdHJlYW0oc3RyZWFtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVVzZXJNZWRpYShudWxsLCBzdHJlYW0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVVc2VyTWVkaWEoZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKFwibWVkaWFEZXZpY2VzXCIgaW4gbmF2aWdhdG9yKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZVNlbGVjdGVkKHByb3BzLmF1ZGlvQ29uc3RyYWludHMsIHByb3BzLnZpZGVvQ29uc3RyYWludHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbmFsU291cmNlXzEgPSBmdW5jdGlvbiAoaWQpIHsgcmV0dXJuICh7IG9wdGlvbmFsOiBbeyBzb3VyY2VJZDogaWQgfV0gfSk7IH07XHJcbiAgICAgICAgICAgIHZhciBjb25zdHJhaW50VG9Tb3VyY2VJZF8xID0gZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZXZpY2VJZCA9IGNvbnN0cmFpbnQuZGV2aWNlSWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRldmljZUlkID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZUlkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGV2aWNlSWQpICYmIGRldmljZUlkLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGV2aWNlSWRbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRldmljZUlkID09PSBcIm9iamVjdFwiICYmIGRldmljZUlkLmlkZWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldmljZUlkLmlkZWFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGRlcHJlY2F0ZWQgYXBpXHJcbiAgICAgICAgICAgIE1lZGlhU3RyZWFtVHJhY2suZ2V0U291cmNlcyhmdW5jdGlvbiAoc291cmNlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF1ZGlvU291cmNlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciB2aWRlb1NvdXJjZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uua2luZCA9PT0gXCJhdWRpb1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvU291cmNlID0gc291cmNlLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2Uua2luZCA9PT0gXCJ2aWRlb1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZGVvU291cmNlID0gc291cmNlLmlkO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGF1ZGlvU291cmNlSWQgPSBjb25zdHJhaW50VG9Tb3VyY2VJZF8xKHByb3BzLmF1ZGlvQ29uc3RyYWludHMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF1ZGlvU291cmNlSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBhdWRpb1NvdXJjZSA9IGF1ZGlvU291cmNlSWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdmlkZW9Tb3VyY2VJZCA9IGNvbnN0cmFpbnRUb1NvdXJjZUlkXzEocHJvcHMudmlkZW9Db25zdHJhaW50cyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodmlkZW9Tb3VyY2VJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZGVvU291cmNlID0gdmlkZW9Tb3VyY2VJZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNvdXJjZVNlbGVjdGVkKG9wdGlvbmFsU291cmNlXzEoYXVkaW9Tb3VyY2UpLCBvcHRpb25hbFNvdXJjZV8xKHZpZGVvU291cmNlKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBXZWJjYW0ucHJvdG90eXBlLmhhbmRsZVVzZXJNZWRpYSA9IGZ1bmN0aW9uIChlcnIsIHN0cmVhbSkge1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgaWYgKGVyciB8fCAhc3RyZWFtKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBoYXNVc2VyTWVkaWE6IGZhbHNlIH0pO1xyXG4gICAgICAgICAgICBwcm9wcy5vblVzZXJNZWRpYUVycm9yKGVycik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmlkZW8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBoYXNVc2VyTWVkaWE6IHRydWUgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIGhhc1VzZXJNZWRpYTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNyYzogd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoc3RyZWFtKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcHMub25Vc2VyTWVkaWEoc3RyZWFtKTtcclxuICAgIH07XHJcbiAgICBXZWJjYW0ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHN0YXRlID0gX2Euc3RhdGUsIHByb3BzID0gX2EucHJvcHM7XHJcbiAgICAgICAgdmFyIGF1ZGlvID0gcHJvcHMuYXVkaW8sIGZvcmNlU2NyZWVuc2hvdFNvdXJjZVNpemUgPSBwcm9wcy5mb3JjZVNjcmVlbnNob3RTb3VyY2VTaXplLCBvblVzZXJNZWRpYSA9IHByb3BzLm9uVXNlck1lZGlhLCBvblVzZXJNZWRpYUVycm9yID0gcHJvcHMub25Vc2VyTWVkaWFFcnJvciwgc2NyZWVuc2hvdEZvcm1hdCA9IHByb3BzLnNjcmVlbnNob3RGb3JtYXQsIHNjcmVlbnNob3RRdWFsaXR5ID0gcHJvcHMuc2NyZWVuc2hvdFF1YWxpdHksIG1pblNjcmVlbnNob3RXaWR0aCA9IHByb3BzLm1pblNjcmVlbnNob3RXaWR0aCwgbWluU2NyZWVuc2hvdEhlaWdodCA9IHByb3BzLm1pblNjcmVlbnNob3RIZWlnaHQsIGF1ZGlvQ29uc3RyYWludHMgPSBwcm9wcy5hdWRpb0NvbnN0cmFpbnRzLCB2aWRlb0NvbnN0cmFpbnRzID0gcHJvcHMudmlkZW9Db25zdHJhaW50cywgaW1hZ2VTbW9vdGhpbmcgPSBwcm9wcy5pbWFnZVNtb290aGluZywgbWlycm9yZWQgPSBwcm9wcy5taXJyb3JlZCwgX2IgPSBwcm9wcy5zdHlsZSwgc3R5bGUgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYiwgcmVzdCA9IF9fcmVzdChwcm9wcywgW1wiYXVkaW9cIiwgXCJmb3JjZVNjcmVlbnNob3RTb3VyY2VTaXplXCIsIFwib25Vc2VyTWVkaWFcIiwgXCJvblVzZXJNZWRpYUVycm9yXCIsIFwic2NyZWVuc2hvdEZvcm1hdFwiLCBcInNjcmVlbnNob3RRdWFsaXR5XCIsIFwibWluU2NyZWVuc2hvdFdpZHRoXCIsIFwibWluU2NyZWVuc2hvdEhlaWdodFwiLCBcImF1ZGlvQ29uc3RyYWludHNcIiwgXCJ2aWRlb0NvbnN0cmFpbnRzXCIsIFwiaW1hZ2VTbW9vdGhpbmdcIiwgXCJtaXJyb3JlZFwiLCBcInN0eWxlXCJdKTtcclxuICAgICAgICB2YXIgdmlkZW9TdHlsZSA9IG1pcnJvcmVkID8gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlKSwgeyB0cmFuc2Zvcm06IChzdHlsZS50cmFuc2Zvcm0gfHwgXCJcIikgKyBcIiBzY2FsZVgoLTEpXCIgfSkgOiBzdHlsZTtcclxuICAgICAgICByZXR1cm4gKHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJjcmVhdGVFbGVtZW50XCJdKFwidmlkZW9cIiwgX19hc3NpZ24oeyBhdXRvUGxheTogdHJ1ZSwgc3JjOiBzdGF0ZS5zcmMsIG11dGVkOiBhdWRpbywgcGxheXNJbmxpbmU6IHRydWUsIHJlZjogZnVuY3Rpb24gKHJlZikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudmlkZW8gPSByZWY7XHJcbiAgICAgICAgICAgIH0sIHN0eWxlOiB2aWRlb1N0eWxlIH0sIHJlc3QpKSk7XHJcbiAgICB9O1xyXG4gICAgV2ViY2FtLmRlZmF1bHRQcm9wcyA9IHtcclxuICAgICAgICBhdWRpbzogdHJ1ZSxcclxuICAgICAgICBmb3JjZVNjcmVlbnNob3RTb3VyY2VTaXplOiBmYWxzZSxcclxuICAgICAgICBpbWFnZVNtb290aGluZzogdHJ1ZSxcclxuICAgICAgICBtaXJyb3JlZDogZmFsc2UsXHJcbiAgICAgICAgb25Vc2VyTWVkaWE6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSxcclxuICAgICAgICBvblVzZXJNZWRpYUVycm9yOiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0sXHJcbiAgICAgICAgc2NyZWVuc2hvdEZvcm1hdDogXCJpbWFnZS93ZWJwXCIsXHJcbiAgICAgICAgc2NyZWVuc2hvdFF1YWxpdHk6IDAuOTIsXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFdlYmNhbTtcclxufShyZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiQ29tcG9uZW50XCJdKSk7XHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoV2ViY2FtKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuXHJcbi8qKiovIFwicmVhY3RcIjpcclxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXHJcbiAgISoqKiBleHRlcm5hbCB7XCJyb290XCI6XCJSZWFjdFwiLFwiY29tbW9uanMyXCI6XCJyZWFjdFwiLFwiY29tbW9uanNcIjpcInJlYWN0XCIsXCJhbWRcIjpcInJlYWN0XCJ9ICoqKiFcclxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3JlYWN0X187XHJcblxyXG4vKioqLyB9KVxyXG5cclxuLyoqKioqKi8gfSlbXCJkZWZhdWx0XCJdO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3Qtd2ViY2FtLmpzLm1hcCIsImZ1bmN0aW9uIGZpeFByb3RvKHRhcmdldCwgcHJvdG90eXBlKSB7XHJcbiAgdmFyIHNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mO1xyXG4gIHNldFByb3RvdHlwZU9mID8gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90b3R5cGUpIDogdGFyZ2V0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcclxufVxyXG5mdW5jdGlvbiBmaXhTdGFjayh0YXJnZXQsIGZuKSB7XHJcbiAgaWYgKGZuID09PSB2b2lkIDApIHtcclxuICAgIGZuID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNhcHR1cmVTdGFja1RyYWNlID0gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2U7XHJcbiAgY2FwdHVyZVN0YWNrVHJhY2UgJiYgY2FwdHVyZVN0YWNrVHJhY2UodGFyZ2V0LCBmbik7XHJcbn1cclxuXHJcbnZhciBfX2V4dGVuZHMgPSB1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZXh0ZW5kcyB8fCBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIF9leHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLCBiKSB7XHJcbiAgICBfZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XHJcbiAgICAgIF9fcHJvdG9fXzogW11cclxuICAgIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xyXG4gICAgICBkLl9fcHJvdG9fXyA9IGI7XHJcbiAgICB9IHx8IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgIGZvciAodmFyIHAgaW4gYikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuXHJcbiAgICBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuXHJcbiAgICBmdW5jdGlvbiBfXygpIHtcclxuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XHJcbiAgICB9XHJcblxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG4gIH07XHJcbn0oKTtcclxuXHJcbnZhciBDdXN0b21FcnJvciA9IGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICBfX2V4dGVuZHMoQ3VzdG9tRXJyb3IsIF9zdXBlcik7XHJcblxyXG4gIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlLCBvcHRpb25zKSB8fCB0aGlzO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcywgJ25hbWUnLCB7XHJcbiAgICAgIHZhbHVlOiBfbmV3VGFyZ2V0Lm5hbWUsXHJcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgZml4UHJvdG8oX3RoaXMsIF9uZXdUYXJnZXQucHJvdG90eXBlKTtcclxuICAgIGZpeFN0YWNrKF90aGlzKTtcclxuICAgIHJldHVybiBfdGhpcztcclxuICB9XHJcblxyXG4gIHJldHVybiBDdXN0b21FcnJvcjtcclxufShFcnJvcik7XHJcblxyXG52YXIgX19zcHJlYWRBcnJheSA9IHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19zcHJlYWRBcnJheSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcclxuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59O1xyXG5mdW5jdGlvbiBjdXN0b21FcnJvckZhY3RvcnkoZm4sIHBhcmVudCkge1xyXG4gIGlmIChwYXJlbnQgPT09IHZvaWQgMCkge1xyXG4gICAgcGFyZW50ID0gRXJyb3I7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBDdXN0b21FcnJvcigpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcblxyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpIHJldHVybiBuZXcgKEN1c3RvbUVycm9yLmJpbmQuYXBwbHkoQ3VzdG9tRXJyb3IsIF9fc3ByZWFkQXJyYXkoW3ZvaWQgMF0sIGFyZ3MsIGZhbHNlKSkpKCk7XHJcbiAgICBwYXJlbnQuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hbWUnLCB7XHJcbiAgICAgIHZhbHVlOiBmbi5uYW1lIHx8IHBhcmVudC5uYW1lLFxyXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgZml4U3RhY2sodGhpcywgQ3VzdG9tRXJyb3IpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEN1c3RvbUVycm9yLCB7XHJcbiAgICBwcm90b3R5cGU6IHtcclxuICAgICAgdmFsdWU6IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSwge1xyXG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XHJcbiAgICAgICAgICB2YWx1ZTogQ3VzdG9tRXJyb3IsXHJcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgIH1cclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IHsgQ3VzdG9tRXJyb3IsIGN1c3RvbUVycm9yRmFjdG9yeSB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXN0b20tZXJyb3IubWpzLm1hcFxyXG4iXSwic291cmNlUm9vdCI6IiJ9